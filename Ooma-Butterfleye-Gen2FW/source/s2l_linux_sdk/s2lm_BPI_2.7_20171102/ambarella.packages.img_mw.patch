diff --git a/AmbaConfig b/AmbaConfig
index 60d5f31..b3f7e55 100644
--- a/AmbaConfig
+++ b/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/01/16 - [Jian Tang] Create
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menuconfig BUILD_AMBARELLA_MIDDLEWARE
diff --git a/dev/AmbaConfig b/dev/AmbaConfig
index 65a2080..ac400a1 100644
--- a/dev/AmbaConfig
+++ b/dev/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2013/05/13 - [Zhaoyang Chen] Create
 ##
-## Copyright (C) 2013-2017, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 if (CONFIG_ARCH_A5S || CONFIG_ARCH_S2L || CONFIG_ARCH_S2 || CONFIG_ARCH_S2E || CONFIG_ARCH_S3)
diff --git a/dev/arch_s2l/dc_iris.c b/dev/arch_s2l/dc_iris.c
index 6996d3d..d1cfbc4 100644
--- a/dev/arch_s2l/dc_iris.c
+++ b/dev/arch_s2l/dc_iris.c
@@ -1,18 +1,35 @@
-/**********************************************************************
+/*
  *
  * dc_iris.c
  *
  * History:
  *	2014/09/17 - [Bin Wang] Created this file
  *
- * Copyright (C) 2014 - 2018, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
diff --git a/dev/arch_s2l/ir_led.c b/dev/arch_s2l/ir_led.c
index 5ff7351..80acde5 100644
--- a/dev/arch_s2l/ir_led.c
+++ b/dev/arch_s2l/ir_led.c
@@ -1,17 +1,34 @@
-/**********************************************************************
+/*
  *
  * ir_led.c
  *
  * History:
  * 2014/09/17 - [Bin Wang] Created this file
- * Copyright (C) 2014 - 2018, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -231,8 +248,8 @@ s32 set_pwm_duty(s32 *fd, s32 pwm_ch_id, s32 duty)
 	sprintf(buf, "/sys/class/backlight/%d.pwm_bl/brightness", pwm_ch_id);
 	if (*fd < 0) {
 		if ((*fd = open(buf, O_RDWR)) < 0) {
-			 perror("set_pwm_duty open");
-			 return -1;
+			perror("set_pwm_duty open");
+			return -1;
 		}
 	}
 	sprintf(vbuf, "%d", duty);
@@ -321,31 +338,54 @@ s32 ir_led_get_adc_value(u32 *value)
 
 s32 ir_led_init(u32 init) /* init=1:initiate IR LED, init=0:de-initiate IR LED*/
 {
-#ifndef IR_LED_NO_GPIO_CONTROL
-	s32 ret = -1;
-	char gpio_addr[128] = {0};
-	sprintf(gpio_addr, "/sys/class/gpio/gpio%d",
-			GPIO_ID_LED_IR_ENABLE);
-	if (init) {
-		//set IR CUT control GPIO to default value 0, make sure it is covered
-		if (0 != access(gpio_addr, F_OK)) {
-			do_gpio_export(GPIO_ID_LED_IR_ENABLE, GPIO_EXPORT);
-			set_gpio_direction(GPIO_ID_LED_IR_ENABLE, GPIO_OUT);
+	s32 ret = 0;
+	do {
+		if (!init) {
+			if (ir_led_pwm_fd != -1) {
+				if ((ret = close(ir_led_pwm_fd)) < 0) {
+					perror("close");
+					break;
+				}
+				ir_led_pwm_fd = -1;
+			}
+			if (ir_led_adc_fd != -1) {
+				if ((ret = close(ir_led_adc_fd)) < 0) {
+					perror("close");
+					break;
+				}
+				ir_led_adc_fd = -1;
+			}
 		}
-		ret = ir_led_set_state(GPIO_LOW);
-	} else {
-		if (0 == access(gpio_addr, F_OK)) {
-			ret = do_gpio_export(GPIO_ID_LED_IR_ENABLE, GPIO_UNEXPORT);
+#ifndef IR_LED_NO_GPIO_CONTROL
+		char gpio_addr[128] = { 0 };
+		sprintf(gpio_addr, "/sys/class/gpio/gpio%d",
+		GPIO_ID_LED_IR_ENABLE);
+		if (init) {
+			//set IR CUT control GPIO to default value 0, make sure it is covered
+			if (0 != access(gpio_addr, F_OK)) {
+				if ((ret = do_gpio_export(GPIO_ID_LED_IR_ENABLE, GPIO_EXPORT)) < 0) {
+					fprintf(stderr, "export gpio%d failed!\n", GPIO_ID_LED_IR_ENABLE);
+					break;
+				}
+				if ((ret = set_gpio_direction(GPIO_ID_LED_IR_ENABLE, GPIO_OUT)) < 0) {
+					fprintf(stderr,
+									"set gpio%d direction failed!\n",
+									GPIO_ID_LED_IR_ENABLE);
+					break;
+				}
+			}
+		} else {
+			if (ir_led_gpio_fd != -1) {
+				if ((ret = close(ir_led_gpio_fd)) < 0) {
+					perror("close");
+					break;
+				}
+				ir_led_gpio_fd = -1;
+			}
 		}
-		close(ir_led_gpio_fd);
-		ir_led_gpio_fd = -1;
 #endif
-		close(ir_led_pwm_fd);
-		ir_led_pwm_fd = -1;
-		close(ir_led_adc_fd);
-		ir_led_adc_fd = -1;
-#ifndef IR_LED_NO_GPIO_CONTROL
-	}
+	} while (0);
+
 	if (ret < 0) {
 		if (init) {
 			fprintf(stderr, "ir led init failed!\n");
@@ -355,9 +395,6 @@ s32 ir_led_init(u32 init) /* init=1:initiate IR LED, init=0:de-initiate IR LED*/
 	}
 
 	return ret;
-#else
-	return 0;
-#endif
 }
 
 /* functions for IR cut switch */
@@ -392,24 +429,36 @@ s32 ir_cut_get_state(void)
 
 s32 ir_cut_init(u32 init)/* init=1:initiate IR cut, init=0:de-initiate IR cut*/
 {
-	s32 ret = -1;
-	char gpio_addr[128] = {0};
+	s32 ret = 0;
+	char gpio_addr[128] = { 0 };
 
 	sprintf(gpio_addr, "/sys/class/gpio/gpio%d", GPIO_ID_IR_CUT_CTRL);
-	if (init) {
-		//set IR CUT control GPIO to default value 0, make sure it is covered
-		if (0 != access(gpio_addr, F_OK)) {
-			do_gpio_export(GPIO_ID_IR_CUT_CTRL, GPIO_EXPORT);
-			set_gpio_direction(GPIO_ID_IR_CUT_CTRL, GPIO_OUT);
-		}
-		ret = ir_cut_set_state(GPIO_LOW);
-	} else {
-		if (0 == access(gpio_addr, F_OK)) {
-			ret = do_gpio_export(GPIO_ID_IR_CUT_CTRL, GPIO_UNEXPORT);
+	do {
+		if (init) {
+			//set IR CUT control GPIO to default value 0, make sure it is covered
+			if (0 != access(gpio_addr, F_OK)) {
+				if ((ret = do_gpio_export(GPIO_ID_IR_CUT_CTRL, GPIO_EXPORT)) < 0) {
+					fprintf(stderr, "export gpio%d failed!\n", GPIO_ID_IR_CUT_CTRL);
+					break;
+				}
+				if ((ret = set_gpio_direction(GPIO_ID_IR_CUT_CTRL, GPIO_OUT)) < 0) {
+					fprintf(stderr,
+									"set gpio%d direction failed!\n",
+									GPIO_ID_IR_CUT_CTRL);
+					break;
+				}
+			}
+		} else {
+			if (ir_cut_gpio_fd != -1) {
+				if ((ret = close(ir_cut_gpio_fd)) < 0) {
+					perror("close");
+					break;
+				}
+				ir_cut_gpio_fd = -1;
+			}
 		}
-		close(ir_cut_gpio_fd);
-		ir_cut_gpio_fd = -1;
-	}
+	} while (0);
+
 	if (ret < 0) {
 		if (init) {
 			fprintf(stderr, "ir cut init failed!\n");
diff --git a/dev/arch_s2l/make.inc b/dev/arch_s2l/make.inc
index 6ae1521..d834528 100644
--- a/dev/arch_s2l/make.inc
+++ b/dev/arch_s2l/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/09/17 - [Bin Wang] Created file
 ##
-## Copyright (C) 2014-2018, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 LOCAL_PATH	:= $(call my-dir)
diff --git a/dev/make.inc b/dev/make.inc
index dd2c88f..7429e12 100644
--- a/dev/make.inc
+++ b/dev/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2013/05/13 - [Zhaoyang Chen] Created file
 ##
-## Copyright (C) 2013-2017, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_IMAGE_DEVICE_PROC), y)
diff --git a/document/make.inc b/document/make.inc
index 2e00811..a3b5baa 100644
--- a/document/make.inc
+++ b/document/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##   Apr 22, 2015 - [ypchang] created file
 ##
-## Copyright (C) 2008-2015, Ambarella Co, Ltd.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 LOCAL_PATH := $(call my-dir)
diff --git a/make.inc b/make.inc
index c3d64ba..166e069 100644
--- a/make.inc
+++ b/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_MIDDLEWARE), y)
diff --git a/mw/AmbaConfig b/mw/AmbaConfig
index 710b358..d96781f 100644
--- a/mw/AmbaConfig
+++ b/mw/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/01/16 - [Jian Tang] Create
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menu "MW IMAGE configs"
diff --git a/mw/arch_s2l/include/mw_aaa_params.h b/mw/arch_s2l/include/mw_aaa_params.h
index d8de163..6fd9836 100644
--- a/mw/arch_s2l/include/mw_aaa_params.h
+++ b/mw/arch_s2l/include/mw_aaa_params.h
@@ -1,18 +1,35 @@
-/**********************************************************************
+/*
  *
  * mw_aaa_params.h
  *
  * History:
  *	2012/12/10 - [Jingyang Qiu] Created this file
  *
- * Copyright (C) 2012 - 2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef __SENSOR_ADJ_AEB_FILE_H__
 #define __SENSOR_ADJ_AEB_FILE_H__
diff --git a/mw/arch_s2l/include/mw_dc_iris.h b/mw/arch_s2l/include/mw_dc_iris.h
index 7e7ebd7..323204d 100644
--- a/mw/arch_s2l/include/mw_dc_iris.h
+++ b/mw/arch_s2l/include/mw_dc_iris.h
@@ -1,16 +1,34 @@
-/**********************************************************************
+/*
  * mw_dc_iris.h
  *
  * History:
  * 2014/09/17 - [Bin Wang] Created this file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- *********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef MW_DC_IRIS_H_
 #define MW_DC_IRIS_H_
diff --git a/mw/arch_s2l/include/mw_defines.h b/mw/arch_s2l/include/mw_defines.h
index 2ee65f3..f5331ee 100644
--- a/mw/arch_s2l/include/mw_defines.h
+++ b/mw/arch_s2l/include/mw_defines.h
@@ -1,4 +1,35 @@
-
+/*
+ *
+ * mw_defines.h
+ *
+ * History:
+ *	2012/12/10 - [Jingyang Qiu] Created this file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef _MW_DEFINES_H_
 #define _MW_DEFINES_H_
diff --git a/mw/arch_s2l/include/mw_image_priv.h b/mw/arch_s2l/include/mw_image_priv.h
index 04a897b..5569fa8 100644
--- a/mw/arch_s2l/include/mw_image_priv.h
+++ b/mw/arch_s2l/include/mw_image_priv.h
@@ -1,4 +1,35 @@
-
+/*
+ *
+ * mw_image_priv.h
+ *
+ * History:
+ *	2012/12/10 - [Jingyang Qiu] Created this file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef __MW_IMAGE_PRIV_H__
 #define __MW_IMAGE_PRIV_H__
@@ -24,6 +55,21 @@
 #define	MW_LE_STRENGTH_MIN		(0)
 #define	MW_LE_STRENGTH_MAX		(128)
 
+#define	MW_AUTO_KNEE_MIN		(0)
+#define	MW_AUTO_KNEE_MAX		(255)
+
+#define	MW_HDR_BLEND_EXPO_RATIO_MIN	(4 * 16)
+#define	MW_HDR_BLEND_EXPO_RATIO_MAX	(128 * 16)
+
+#define	MW_HDR_BLEND_BOOST_FACTOR_MIN	(0)
+#define	MW_HDR_BLEND_BOOST_FACTOR_MAX	(256)
+
+#define	MW_WDR_LUMA_RADIUS_MIN			(0)
+#define	MW_WDR_LUMA_RADIUS_MAX			(6)
+
+#define	MW_WDR_LUMA_WEIGHT_MIN			(0)
+#define	MW_WDR_LUMA_WEIGHT_MAX			(31)
+
 #define	FOCUS_INFINITY		(50000)
 #define	FOCUS_MACRO			(50)
 
@@ -33,11 +79,14 @@
 
 #define	SHT_TIME(SHT_Q9)		DIV_ROUND(512000000, (SHT_Q9))
 
-#define	HDR_2X_MAX_SHUTTER(Q9)	((Q9) * 4 / 5)		// 1 + 4 = 5
-#define	HDR_3X_MAX_SHUTTER(Q9)	((Q9) * 16 / 21)		// 1 + 4 + 16 = 21
+#define	HDR_2X_MAX_SHUTTER(Q9, RATIO)	((Q9) * (RATIO) / ((RATIO) + HDR_EXPOSURE_RATIO_UNIT))
+#define	HDR_3X_MAX_SHUTTER(Q9, RATIO)	((Q9) * (RATIO) * (RATIO) / \
+			(HDR_EXPOSURE_RATIO_UNIT * HDR_EXPOSURE_RATIO_UNIT + \
+			HDR_EXPOSURE_RATIO_UNIT * (RATIO) + (RATIO) * (RATIO)))
 
 #define	MW_THREAD_NAME_NETLINK	"img_mw.nl"
 #define	MW_THREAD_NAME_AE_CTRL		"img_mw.ae_ctrl"
+#define	MW_THREAD_NAME_TONE_CURVE_CTRL	"img_mw.tc_ctrl"
 
 typedef enum {
 	MW_CALIB_BPC = 1,
@@ -49,9 +98,9 @@ typedef enum {
 int get_sensor_aaa_params(_mw_global_config *pMw_info);
 int config_sensor_lens_info(_mw_global_config *pMw_info);
 int load_dsp_cc_table(int fd, char *sensor_name, amba_img_dsp_mode_cfg_t *ik_mode);
-inline int get_vin_mode(u32 *vin_mode);
-inline int get_vin_frame_rate(u32 *pFrame_time);
-inline int get_shutter_time(u32 *pShutter_time);
+int get_vin_mode(u32 *vin_mode);
+int get_vin_frame_rate(u32 *pFrame_time);
+int get_shutter_time(u32 *pShutter_time);
 int load_ae_exp_lines(mw_ae_param *ae);
 int get_ae_exposure_lines(mw_ae_line *lines, u32 num);
 int set_ae_exposure_lines(mw_ae_line *lines, u32 num);
@@ -63,7 +112,7 @@ int load_calibration_data(mw_cali_file *file, MW_CALIBRATION_TYPE type);
 int load_default_params(void);
 int check_af_params(mw_af_param *pAF);
 int reload_previous_params(void);
-inline int check_state(void);
+int check_state(void);
 int set_chroma_noise_filter_max(int fd);
 int get_sensor_agc_info(int fd, struct vindev_agc *agc_info);
 int get_dsp_mode_cfg(amba_img_dsp_mode_cfg_t *dsp_mode_cfg);
@@ -92,6 +141,9 @@ int init_sem(void);
 int deinit_sem(void);
 int wait_sem(int ms);
 int signal_sem(void);
+void wait_irq_count(int num);
+
+void tone_curve_task(void *arg);
 
 #endif // __MW_IMAGE_PRIV_H__
 
diff --git a/mw/arch_s2l/include/mw_ir_led.h b/mw/arch_s2l/include/mw_ir_led.h
index 67adf66..af91215 100644
--- a/mw/arch_s2l/include/mw_ir_led.h
+++ b/mw/arch_s2l/include/mw_ir_led.h
@@ -1,16 +1,34 @@
-/**********************************************************************
+/*
  * mw_ir_led.h
  *
  * History:
  * 2014/09/17 - [Bin Wang] Created this file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- *********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef MW_IR_LED_H_
 #define MW_IR_LED_H_
diff --git a/mw/arch_s2l/include/mw_pri_struct.h b/mw/arch_s2l/include/mw_pri_struct.h
index d6fbb24..3a1882a 100644
--- a/mw/arch_s2l/include/mw_pri_struct.h
+++ b/mw/arch_s2l/include/mw_pri_struct.h
@@ -1,3 +1,35 @@
+/*
+ *
+ * mw_pri_struct.h
+ *
+ * History:
+ *	2012/12/10 - [Jingyang Qiu] Created this file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef _MW_PRI_STRUCT_H_
 #define _MW_PRI_STRUCT_H_
@@ -68,6 +100,8 @@ typedef struct {
 	int auto_contrast;
 	int auto_wdr_str;
 	mw_local_exposure_curve le_off_curve;
+	int auto_knee_strength;
+	int auto_dump_cfg;
 } _mw_enhance_param;
 
 //iris
@@ -107,7 +141,7 @@ typedef struct {
 	int raw_bayer;
 	u16 vin_width;
 	u16 vin_height;
-	char name[32];
+	char name[16];
 	u32 default_fps;
 	u32 current_fps;
 	u32 vin_mode;
diff --git a/mw/arch_s2l/make.inc b/mw/arch_s2l/make.inc
index dd4ff20..0c42d54 100644
--- a/mw/arch_s2l/make.inc
+++ b/mw/arch_s2l/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/05/05 - [Zhaoyang Chen] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_MIDDLEWARE_PROC), y)
diff --git a/mw/arch_s2l/src/build_aaa_binary.sh b/mw/arch_s2l/src/build_aaa_binary.sh
index cfe3b0c..e0acd15 100644
--- a/mw/arch_s2l/src/build_aaa_binary.sh
+++ b/mw/arch_s2l/src/build_aaa_binary.sh
@@ -1,17 +1,31 @@
 #!/bin/sh
-
+## History:
 ##
-## prebuild/imgproc/img_data/arch_s2l/build_aaa_binary_header.sh
+## 2016/12/30 - [Jingyang Qiu] Created file
 ##
-## History:
-##    2012/12/10 - [Jingyang Qiu] Created file
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 #####$1: generate param files, $2 source S file,
diff --git a/mw/arch_s2l/src/make.inc b/mw/arch_s2l/src/make.inc
index 0163646..89edf00 100644
--- a/mw/arch_s2l/src/make.inc
+++ b/mw/arch_s2l/src/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2014/05/05 - [Jian Tang] Created file
 ##
-## Copyright (C) 2012-2016, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 LOCAL_PATH	:= $(call my-dir)
@@ -44,7 +61,7 @@ LOCAL_TARGET	:= $(AMP_MODULE)
 include $(BUILD_APP)
 
 .PHONY: $(LOCAL_TARGET)
-$(LOCAL_SRCS): prebuild_idsp_bin create_aaa_binary board_create_aaa_binary
+$(LOCAL_SRCS): create_aaa_binary board_create_aaa_binary
 
 $(LOCAL_TARGET): $(LOCAL_MODULE)
 	@mkdir -p $(FAKEROOT_DIR)/usr/lib/
@@ -59,7 +76,7 @@ $(call add-target-into-build, $(LOCAL_TARGET))
 include $(CLEAR_VARS)
 
 MW_HEADER_PATH:=$(AMB_TOPDIR)/packages/img_mw/mw/arch_$(AMBARELLA_ARCH)/include
-ADJ_PARAMS_CFLAGS:=	-I $(MW_HEADER_PATH) -I $(AMBARELLA_CFLAGS)
+ADJ_PARAMS_CFLAGS:= $(AMBARELLA_CFLAGS) -I $(MW_HEADER_PATH)
 
 PREBUILD_PARAM_FOLDER:=$(AMB_BOARD_OUT)/prebuild/img_data
 PREBUILD_LENS_PARAM_FOLDER:=$(AMB_BOARD_OUT)/prebuild/img_data/lens_params
@@ -84,6 +101,15 @@ ifeq ($(CONFIG_SENSOR_AR0230), y)
 BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/ar0230*_3D.bin)
 BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/ar0230*.c)
 endif
+ifeq ($(CONFIG_SENSOR_AR0521), y)
+BIN_AAA_3D      += $(wildcard ${PREBUILD_3D_PATH}/ar0521*_3D.bin)
+BIN_AAA_3D      += $(wildcard ${PREBUILD_3D_PATH}/ar0521*_3D_hdr.bin)
+BIN_AAA_SRC     += $(wildcard ${ADJ_PARAMS_PATH}/ar0521*.c)
+else ifeq ($(CONFIG_SENSOR_AR0521_MIPI), y)
+BIN_AAA_3D      += $(wildcard ${PREBUILD_3D_PATH}/ar0521*_3D.bin)
+BIN_AAA_3D      += $(wildcard ${PREBUILD_3D_PATH}/ar0521*_3D_hdr.bin)
+BIN_AAA_SRC     += $(wildcard ${ADJ_PARAMS_PATH}/ar0521*.c)
+endif
 ifeq ($(CONFIG_SENSOR_MT9T002), y)
 BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/mt9t002*_3D.bin)
 BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/mt9t002*.c)
@@ -125,6 +151,19 @@ ifeq ($(CONFIG_SENSOR_OV5658_MIPI), y)
 BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/ov5658*_3D.bin)
 BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/ov5658*.c)
 endif
+ifeq ($(CONFIG_SENSOR_OV2718_MIPI), y)
+BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/ov2718*_3D.bin)
+BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/ov2718*.c)
+endif
+ifeq ($(CONFIG_SENSOR_OV2735_MIPI), y)
+BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/ov2735*_3D.bin)
+BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/ov2735*.c)
+endif
+
+ifeq ($(CONFIG_SENSOR_OV2732_MIPI), y)
+BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/ov2732*_3D.bin)
+BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/ov2732*.c)
+endif
 
 ### Sony Sensors
 ifeq ($(CONFIG_SENSOR_IMX104), y)
@@ -143,6 +182,10 @@ ifeq ($(CONFIG_SENSOR_IMX322), y)
 BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/imx322*_3D.bin)
 BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/imx322*.c)
 endif
+ifeq ($(CONFIG_SENSOR_IMX326), y)
+BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/imx326*_3D.bin)
+BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/imx326*.c)
+endif
 ifeq ($(CONFIG_SENSOR_IMX136P), y)
 BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/imx136*_3D.bin)
 BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/imx136*.c)
@@ -167,6 +210,10 @@ ifeq ($(CONFIG_SENSOR_IMX178), y)
 BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/imx178*_3D.bin)
 BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/imx178*.c)
 endif
+ifeq ($(CONFIG_SENSOR_IMX185), y)
+BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/imx185*_3D.bin)
+BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/imx185*.c)
+endif
 ifeq ($(CONFIG_SENSOR_IMX172), y)
 BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/imx172*_3D.bin)
 BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/imx172*.c)
@@ -175,6 +222,10 @@ ifeq ($(CONFIG_SENSOR_IMX174), y)
 BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/imx174*_3D.bin)
 BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/imx174*.c)
 endif
+ifeq ($(CONFIG_SENSOR_IMX377_MIPI), y)
+BIN_AAA_3D	+= $(wildcard ${PREBUILD_3D_PATH}/imx377*_3D.bin)
+BIN_AAA_SRC	+= $(wildcard ${ADJ_PARAMS_PATH}/imx377*.c)
+endif
 
 ### Panasonic Sensors
 ifeq ($(CONFIG_SENSOR_MN34041PL), y)
@@ -248,7 +299,7 @@ ifeq ($(BIN_AAA_PARAM),)
 	@echo "placeholder for non-existing 3A image to avoid compile error"
 else
 ifeq ($(BIN_LENS_PARAM),)
-create_aaa_binary: $(BIN_AAA_PARAM)
+create_aaa_binary: $(BIN_AAA_PARAM) prebuild_idsp_bin
 	@mkdir -p $(IMAGE_DATA_DIR)/adj_params/
 	@cp -f $(BIN_AAA_PARAM) $(IMAGE_DATA_DIR)/adj_params/
 	@mkdir -p $(IMAGE_DATA_DIR)/sensors/
@@ -256,7 +307,7 @@ create_aaa_binary: $(BIN_AAA_PARAM)
 	@cp -f ${BIN_AAA_3D} $(IMAGE_DATA_DIR)/sensors/
 	@echo "Build $@ Done."
 else
-create_aaa_binary: $(BIN_AAA_PARAM) $(BIN_LENS_PARAM)
+create_aaa_binary: $(BIN_AAA_PARAM) $(BIN_LENS_PARAM) prebuild_idsp_bin
 	@mkdir -p $(IMAGE_DATA_DIR)/adj_params/
 	@cp -f $(BIN_AAA_PARAM) $(IMAGE_DATA_DIR)/adj_params/
 	@mkdir -p $(IMAGE_DATA_DIR)/sensors/
@@ -290,6 +341,15 @@ ifeq ($(CONFIG_SENSOR_AR0230), y)
 BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/ar0230*_3D.bin)
 BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/ar0230*.c)
 endif
+ifeq ($(CONFIG_SENSOR_AR0521), y)
+BOARD_BIN_AAA_3D        += $(wildcard ${BOARD_PREBUILD_3D_PATH}/ar0521*_3D.bin)
+BOARD_BIN_AAA_3D        += $(wildcard ${BOARD_PREBUILD_3D_PATH}/ar0521*_3D_hdr.bin)
+BOARD_BIN_AAA_SRC       += $(wildcard ${BOARD_ADJ_PARAMS_PATH}/ar0521*.c)
+else ifeq ($(CONFIG_SENSOR_AR0521_MIPI), y)
+BOARD_BIN_AAA_3D        += $(wildcard ${BOARD_PREBUILD_3D_PATH}/ar0521*_3D.bin)
+BOARD_BIN_AAA_3D        += $(wildcard ${BOARD_PREBUILD_3D_PATH}/ar0521*_3D_hdr.bin)
+BOARD_BIN_AAA_SRC       += $(wildcard ${BOARD_ADJ_PARAMS_PATH}/ar0521*.c)
+endif
 ifeq ($(CONFIG_SENSOR_MT9T002), y)
 BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/mt9t002*_3D.bin)
 BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/mt9t002*.c)
@@ -327,6 +387,19 @@ ifeq ($(CONFIG_SENSOR_OV5658_MIPI), y)
 BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/ov5658*_3D.bin)
 BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/ov5658*.c)
 endif
+ifeq ($(CONFIG_SENSOR_OV2718_MIPI), y)
+BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/ov2718*_3D.bin)
+BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/ov2718*.c)
+endif
+ifeq ($(CONFIG_SENSOR_OV2735_MIPI), y)
+BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/ov2735*_3D.bin)
+BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/ov2735*.c)
+endif
+
+ifeq ($(CONFIG_SENSOR_OV2732_MIPI), y)
+BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/ov2732*_3D.bin)
+BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/ov2732*.c)
+endif
 
 ### Sony Sensors
 ifeq ($(CONFIG_SENSOR_IMX104), y)
@@ -345,6 +418,10 @@ ifeq ($(CONFIG_SENSOR_IMX322), y)
 BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/imx322*_3D.bin)
 BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/imx322*.c)
 endif
+ifeq ($(CONFIG_SENSOR_IMX326), y)
+BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/imx326*_3D.bin)
+BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/imx326*.c)
+endif
 ifeq ($(CONFIG_SENSOR_IMX136P), y)
 BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/imx136*_3D.bin)
 BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/imx136*.c)
@@ -369,6 +446,10 @@ ifeq ($(CONFIG_SENSOR_IMX178), y)
 BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/imx178*_3D.bin)
 BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/imx178*.c)
 endif
+ifeq ($(CONFIG_SENSOR_IMX185), y)
+BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/imx185*_3D.bin)
+BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/imx185*.c)
+endif
 ifeq ($(CONFIG_SENSOR_IMX172), y)
 BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/imx172*_3D.bin)
 BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/imx172*.c)
@@ -377,6 +458,10 @@ ifeq ($(CONFIG_SENSOR_IMX174), y)
 BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/imx174*_3D.bin)
 BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/imx174*.c)
 endif
+ifeq ($(CONFIG_SENSOR_IMX377_MIPI), y)
+BOARD_BIN_AAA_3D	+= $(wildcard ${BOARD_PREBUILD_3D_PATH}/imx377*_3D.bin)
+BOARD_BIN_AAA_SRC	+= $(wildcard ${BOARD_ADJ_PARAMS_PATH}/imx377*.c)
+endif
 
 ### Panasonic Sensors
 ifeq ($(CONFIG_SENSOR_MN34041PL), y)
diff --git a/mw/arch_s2l/src/mw_api.c b/mw/arch_s2l/src/mw_api.c
index 4982746..37b79a0 100644
--- a/mw/arch_s2l/src/mw_api.c
+++ b/mw/arch_s2l/src/mw_api.c
@@ -1,4 +1,4 @@
-/**********************************************************************
+/*
  *
  * mw_api.c
  *
@@ -6,14 +6,31 @@
  *	2010/02/28 - [Jian Tang] Created this file
  *	2011/08/05 - [Jian Tang] Modified this file
  *
- * Copyright (C) 2007 - 2011, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
diff --git a/mw/arch_s2l/src/mw_config.c b/mw/arch_s2l/src/mw_config.c
index f5de4a0..09e07fa 100644
--- a/mw/arch_s2l/src/mw_config.c
+++ b/mw/arch_s2l/src/mw_config.c
@@ -1,18 +1,35 @@
-/**********************************************************************
+/*
  *
  * mw_config.c
  *
  * History:
  *	2010/02/28 - [Jian Tang] Created this file
  *
- * Copyright (C) 2007 - 2010, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -682,25 +699,33 @@ static int printf_parse_msg(Mapping *map)
 
 int mw_save_config_file(char *filename)
 {
-	int file;
+	int file = -1;
 	char *buffer = NULL;
+	int rval = 0;
 
+	do {
+		buffer = malloc(FILE_CONTENT_SIZE);
+		if (buffer == NULL) {
+			MW_ERROR("Malloc buffer error\n");
+			rval = -1;
+			break;
+		}
+		memset(buffer, 0, FILE_CONTENT_SIZE);
 
-	buffer = malloc(FILE_CONTENT_SIZE);
-	if (buffer == NULL) {
-		MW_ERROR("Malloc buffer error\n");
-		return -1;
-	}
-	memset(buffer, 0, FILE_CONTENT_SIZE);
-
-	save_params(AAA_Map, &buffer);
+		save_params(AAA_Map, &buffer);
 
-	if ((file = open(filename, O_RDWR | O_CREAT, 0)) < 0) {
-		MW_ERROR("Open file: %s error\n", filename);
-		return -1;
-	}
+		if ((file = open(filename, O_RDWR | O_CREAT, 0)) < 0) {
+			MW_ERROR("Open file: %s error\n", filename);
+			rval = -1;
+			break;
+		}
 
-	write(file, buffer, strlen(buffer));
+		if (write(file, buffer, strlen(buffer)) < 0) {
+			printf("write error.\n");
+			rval = -1;
+			break;
+		}
+	} while (0);
 
 	if (buffer) {
 		free(buffer);
@@ -710,34 +735,43 @@ int mw_save_config_file(char *filename)
 		close(file);
 		file = -1;
 	}
-	return 0;
+	return rval;
 }
 
 int mw_load_config_file(char *filename)
 {
-	int file, i;
+	int file = -1, i;
 	char *buffer = NULL;
+	int rval = 0;
 
-	buffer = malloc(FILE_CONTENT_SIZE);
-	if (buffer == NULL) {
-		MW_ERROR("Malloc buffer error\n");
-		return -1;
-	}
-	memset(buffer, 0, FILE_CONTENT_SIZE);
+	do {
+		buffer = malloc(FILE_CONTENT_SIZE);
+		if (buffer == NULL) {
+			MW_ERROR("Malloc buffer error\n");
+			rval = -1;
+			break;
+		}
+		memset(buffer, 0, FILE_CONTENT_SIZE);
 
-	if ((file = open(filename, O_RDONLY, 0)) < 0) {
-		MW_ERROR("Open file: %s error\n", filename);
-		return -1;
-	}
-	read(file, buffer, FILE_CONTENT_SIZE);
+		if ((file = open(filename, O_RDONLY, 0)) < 0) {
+			MW_ERROR("Open file: %s error\n", filename);
+			rval = -1;
+			break;
+		}
 
-	load_params(AAA_Map, buffer);
+		if (read(file, buffer, FILE_CONTENT_SIZE) < 0) {
+			printf("read error.\n");
+			rval = -1;
+			break;
+		}
+		load_params(AAA_Map, buffer);
 
-	for(i = 0; i < sizeof(AAA_Map) / sizeof(Mapping); i++) {
-		printf_parse_msg(&AAA_Map[i]);
-	}
+		for(i = 0; i < sizeof(AAA_Map) / sizeof(Mapping); i++) {
+			printf_parse_msg(&AAA_Map[i]);
+		}
 
-	G_mw_config.init_params.load_cfg_file = 1;
+		G_mw_config.init_params.load_cfg_file = 1;
+	} while (0);
 
 	if (buffer) {
 		free(buffer);
@@ -749,7 +783,7 @@ int mw_load_config_file(char *filename)
 		file = -1;
 	}
 
-	return 0;
+	return rval;
 }
 
 #define __END_OF_FILE__
diff --git a/mw/arch_s2l/src/mw_dc_iris.c b/mw/arch_s2l/src/mw_dc_iris.c
index 9373277..62b2eec 100644
--- a/mw/arch_s2l/src/mw_dc_iris.c
+++ b/mw/arch_s2l/src/mw_dc_iris.c
@@ -1,16 +1,34 @@
-/**********************************************************************
+/*
  * mw_dc_iris.c
  *
  * History:
  * 2014/09/17 - [Bin Wang] Created this file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- *********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 #include <unistd.h>
 #include <fcntl.h>
 #include <stdio.h>
diff --git a/mw/arch_s2l/src/mw_dynamic_tonecurve_proc.c b/mw/arch_s2l/src/mw_dynamic_tonecurve_proc.c
new file mode 100644
index 0000000..0eaee94
--- /dev/null
+++ b/mw/arch_s2l/src/mw_dynamic_tonecurve_proc.c
@@ -0,0 +1,422 @@
+/*
+ *
+ * mw_dynamic_tonecurve_proc.c
+ *
+ * History:
+ *	2016/5/27 - [Jian Tang] Created this file
+ *
+ * Copyright (C) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <assert.h>
+#include <basetypes.h>
+
+#include <pthread.h>
+
+#include "iav_common.h"
+#include "iav_ioctl.h"
+#include "iav_fastboot.h"
+#include "iav_vin_ioctl.h"
+#include "iav_vout_ioctl.h"
+#include "ambas_imgproc_arch.h"
+
+#include "img_adv_struct_arch.h"
+#include "img_api_adv_arch.h"
+#include "img_dev.h"
+#include "ambas_imgproc_ioctl_arch.h"
+
+#include "mw_aaa_params.h"
+#include "mw_api.h"
+#include "mw_pri_struct.h"
+#include "mw_image_priv.h"
+#include "mw_ir_led.h"
+
+#include "AmbaDSP_Img3aStatistics.h"
+#include "AmbaDSP_ImgUtility.h"
+#include "img_customer_interface_arch.h"
+
+extern _mw_global_config G_mw_config;
+u8 G_dynamic_tone_curve_active = 0;
+
+static amba_img_dsp_tone_curve_t cus_dyn_tone;
+static u16 cus_histo_info[64];	//for pre-HDR is 128, else are 64
+
+//2xHDR tone 0%
+static amba_img_dsp_tone_curve_t cus_dyn_tone_2xHDR_0 = {
+	.ToneCurveRed = {
+		  0,   9,  14,  20,  26,  33,  39,  44,  51,  56,
+		 64,  69,  78,  83,  89,  97, 103, 109, 116, 122,
+		128, 134, 141, 147, 154, 161, 167, 174, 181, 188,
+		195, 202, 206, 213, 220, 227, 231, 238, 245, 253,
+		257, 264, 271, 275, 283, 290, 294, 302, 309, 313,
+		321, 328, 332, 340, 347, 351, 359, 362, 370, 374,
+		381, 389, 393, 400, 404, 412, 416, 423, 427, 434,
+		442, 445, 453, 457, 464, 468, 475, 478, 486, 489,
+		496, 500, 507, 511, 517, 521, 528, 531, 538, 541,
+		548, 551, 558, 564, 568, 574, 577, 583, 586, 593,
+		596, 602, 604, 610, 613, 619, 622, 627, 633, 635,
+		640, 643, 648, 651, 656, 658, 663, 666, 671, 673,
+		678, 681, 683, 688, 691, 696, 698, 701, 706, 708,
+		711, 715, 718, 720, 725, 728, 730, 732, 737, 740,
+		742, 744, 749, 751, 754, 756, 761, 763, 765, 768,
+		770, 775, 777, 779, 781, 786, 788, 791, 793, 795,
+		800, 802, 804, 806, 808, 811, 815, 817, 819, 821,
+		824, 828, 830, 832, 834, 836, 839, 843, 845, 847,
+		849, 851, 855, 857, 859, 861, 863, 867, 869, 871,
+		873, 875, 879, 881, 883, 885, 887, 891, 893, 894,
+		896, 900, 902, 904, 906, 909, 911, 913, 915, 918,
+		920, 922, 925, 927, 929, 932, 934, 935, 939, 940,
+		942, 945, 947, 950, 952, 953, 956, 958, 961, 962,
+		965, 967, 970, 971, 974, 976, 978, 981, 982, 985,
+		988, 990, 992, 994, 997, 999,1002,1004,1006,1009,
+		1011,1014,1016,1019,1021,1023
+	},
+	.ToneCurveGreen = {
+		  0,   9,  14,  20,  26,  33,  39,  44,  51,  56,
+		 64,  69,  78,  83,  89,  97, 103, 109, 116, 122,
+		128, 134, 141, 147, 154, 161, 167, 174, 181, 188,
+		195, 202, 206, 213, 220, 227, 231, 238, 245, 253,
+		257, 264, 271, 275, 283, 290, 294, 302, 309, 313,
+		321, 328, 332, 340, 347, 351, 359, 362, 370, 374,
+		381, 389, 393, 400, 404, 412, 416, 423, 427, 434,
+		442, 445, 453, 457, 464, 468, 475, 478, 486, 489,
+		496, 500, 507, 511, 517, 521, 528, 531, 538, 541,
+		548, 551, 558, 564, 568, 574, 577, 583, 586, 593,
+		596, 602, 604, 610, 613, 619, 622, 627, 633, 635,
+		640, 643, 648, 651, 656, 658, 663, 666, 671, 673,
+		678, 681, 683, 688, 691, 696, 698, 701, 706, 708,
+		711, 715, 718, 720, 725, 728, 730, 732, 737, 740,
+		742, 744, 749, 751, 754, 756, 761, 763, 765, 768,
+		770, 775, 777, 779, 781, 786, 788, 791, 793, 795,
+		800, 802, 804, 806, 808, 811, 815, 817, 819, 821,
+		824, 828, 830, 832, 834, 836, 839, 843, 845, 847,
+		849, 851, 855, 857, 859, 861, 863, 867, 869, 871,
+		873, 875, 879, 881, 883, 885, 887, 891, 893, 894,
+		896, 900, 902, 904, 906, 909, 911, 913, 915, 918,
+		920, 922, 925, 927, 929, 932, 934, 935, 939, 940,
+		942, 945, 947, 950, 952, 953, 956, 958, 961, 962,
+		965, 967, 970, 971, 974, 976, 978, 981, 982, 985,
+		988, 990, 992, 994, 997, 999,1002,1004,1006,1009,
+		1011,1014,1016,1019,1021,1023
+	},
+	.ToneCurveBlue = {
+		  0,   9,  14,  20,  26,  33,  39,  44,  51,  56,
+		 64,  69,  78,  83,  89,  97, 103, 109, 116, 122,
+		128, 134, 141, 147, 154, 161, 167, 174, 181, 188,
+		195, 202, 206, 213, 220, 227, 231, 238, 245, 253,
+		257, 264, 271, 275, 283, 290, 294, 302, 309, 313,
+		321, 328, 332, 340, 347, 351, 359, 362, 370, 374,
+		381, 389, 393, 400, 404, 412, 416, 423, 427, 434,
+		442, 445, 453, 457, 464, 468, 475, 478, 486, 489,
+		496, 500, 507, 511, 517, 521, 528, 531, 538, 541,
+		548, 551, 558, 564, 568, 574, 577, 583, 586, 593,
+		596, 602, 604, 610, 613, 619, 622, 627, 633, 635,
+		640, 643, 648, 651, 656, 658, 663, 666, 671, 673,
+		678, 681, 683, 688, 691, 696, 698, 701, 706, 708,
+		711, 715, 718, 720, 725, 728, 730, 732, 737, 740,
+		742, 744, 749, 751, 754, 756, 761, 763, 765, 768,
+		770, 775, 777, 779, 781, 786, 788, 791, 793, 795,
+		800, 802, 804, 806, 808, 811, 815, 817, 819, 821,
+		824, 828, 830, 832, 834, 836, 839, 843, 845, 847,
+		849, 851, 855, 857, 859, 861, 863, 867, 869, 871,
+		873, 875, 879, 881, 883, 885, 887, 891, 893, 894,
+		896, 900, 902, 904, 906, 909, 911, 913, 915, 918,
+		920, 922, 925, 927, 929, 932, 934, 935, 939, 940,
+		942, 945, 947, 950, 952, 953, 956, 958, 961, 962,
+		965, 967, 970, 971, 974, 976, 978, 981, 982, 985,
+		988, 990, 992, 994, 997, 999,1002,1004,1006,1009,
+		1011,1014,1016,1019,1021,1023
+	},
+};
+
+//2xHDR tone 100%
+static amba_img_dsp_tone_curve_t cus_dyn_tone_2xHDR_100 = {
+	.ToneCurveRed = {
+		  0,   1,   1,   2,   2,   3,   3,   4,   4,   5,
+		 11,  15,  19,  24,  27,  32,  36,  41,  45,  49,
+		 53,  58,  62,  66,  71,  74,  79,  83,  87,  92,
+		 97, 100, 105, 109, 112, 117, 121, 126, 130, 134,
+		138, 143, 147, 151, 155, 159, 165, 169, 173, 177,
+		181, 185, 189, 193, 198, 202, 206, 210, 215, 219,
+		224, 228, 232, 237, 239, 244, 248, 253, 257, 262,
+		264, 269, 273, 278, 283, 285, 290, 295, 299, 302,
+		307, 311, 316, 319, 324, 328, 331, 336, 341, 343,
+		348, 353, 356, 361, 366, 368, 373, 378, 381, 386,
+		389, 394, 400, 402, 405, 411, 414, 419, 422, 428,
+		431, 434, 440, 443, 447, 453, 456, 459, 463, 469,
+		472, 476, 479, 486, 489, 492, 496, 499, 506, 510,
+		513, 517, 520, 524, 531, 534, 538, 541, 545, 549,
+		552, 560, 563, 567, 571, 574, 578, 582, 585, 589,
+		593, 600, 604, 608, 612, 615, 619, 623, 627, 630,
+		634, 638, 642, 649, 653, 657, 661, 665, 669, 672,
+		676, 680, 684, 688, 691, 695, 703, 707, 710, 714,
+		718, 722, 725, 729, 733, 737, 741, 744, 748, 756,
+		759, 763, 767, 770, 774, 778, 781, 785, 792, 796,
+		800, 803, 807, 810, 814, 818, 825, 828, 832, 835,
+		839, 846, 849, 852, 856, 859, 866, 869, 873, 876,
+		879, 886, 889, 892, 898, 901, 905, 911, 914, 917,
+		923, 926, 929, 934, 937, 943, 946, 951, 954, 959,
+		962, 967, 972, 974, 979, 984, 988, 990, 995, 999,
+		1003,1007,1013,1016,1020,1023
+	},
+	.ToneCurveGreen = {
+		  0,   1,   1,   2,   2,   3,   3,   4,   4,   5,
+		 11,  15,  19,  24,  27,  32,  36,  41,  45,  49,
+		 53,  58,  62,  66,  71,  74,  79,  83,  87,  92,
+		 97, 100, 105, 109, 112, 117, 121, 126, 130, 134,
+		138, 143, 147, 151, 155, 159, 165, 169, 173, 177,
+		181, 185, 189, 193, 198, 202, 206, 210, 215, 219,
+		224, 228, 232, 237, 239, 244, 248, 253, 257, 262,
+		264, 269, 273, 278, 283, 285, 290, 295, 299, 302,
+		307, 311, 316, 319, 324, 328, 331, 336, 341, 343,
+		348, 353, 356, 361, 366, 368, 373, 378, 381, 386,
+		389, 394, 400, 402, 405, 411, 414, 419, 422, 428,
+		431, 434, 440, 443, 447, 453, 456, 459, 463, 469,
+		472, 476, 479, 486, 489, 492, 496, 499, 506, 510,
+		513, 517, 520, 524, 531, 534, 538, 541, 545, 549,
+		552, 560, 563, 567, 571, 574, 578, 582, 585, 589,
+		593, 600, 604, 608, 612, 615, 619, 623, 627, 630,
+		634, 638, 642, 649, 653, 657, 661, 665, 669, 672,
+		676, 680, 684, 688, 691, 695, 703, 707, 710, 714,
+		718, 722, 725, 729, 733, 737, 741, 744, 748, 756,
+		759, 763, 767, 770, 774, 778, 781, 785, 792, 796,
+		800, 803, 807, 810, 814, 818, 825, 828, 832, 835,
+		839, 846, 849, 852, 856, 859, 866, 869, 873, 876,
+		879, 886, 889, 892, 898, 901, 905, 911, 914, 917,
+		923, 926, 929, 934, 937, 943, 946, 951, 954, 959,
+		962, 967, 972, 974, 979, 984, 988, 990, 995, 999,
+		1003,1007,1013,1016,1020,1023
+	},
+	.ToneCurveBlue = {
+		  0,   1,   1,   2,   2,   3,   3,   4,   4,   5,
+		 11,  15,  19,  24,  27,  32,  36,  41,  45,  49,
+		 53,  58,  62,  66,  71,  74,  79,  83,  87,  92,
+		 97, 100, 105, 109, 112, 117, 121, 126, 130, 134,
+		138, 143, 147, 151, 155, 159, 165, 169, 173, 177,
+		181, 185, 189, 193, 198, 202, 206, 210, 215, 219,
+		224, 228, 232, 237, 239, 244, 248, 253, 257, 262,
+		264, 269, 273, 278, 283, 285, 290, 295, 299, 302,
+		307, 311, 316, 319, 324, 328, 331, 336, 341, 343,
+		348, 353, 356, 361, 366, 368, 373, 378, 381, 386,
+		389, 394, 400, 402, 405, 411, 414, 419, 422, 428,
+		431, 434, 440, 443, 447, 453, 456, 459, 463, 469,
+		472, 476, 479, 486, 489, 492, 496, 499, 506, 510,
+		513, 517, 520, 524, 531, 534, 538, 541, 545, 549,
+		552, 560, 563, 567, 571, 574, 578, 582, 585, 589,
+		593, 600, 604, 608, 612, 615, 619, 623, 627, 630,
+		634, 638, 642, 649, 653, 657, 661, 665, 669, 672,
+		676, 680, 684, 688, 691, 695, 703, 707, 710, 714,
+		718, 722, 725, 729, 733, 737, 741, 744, 748, 756,
+		759, 763, 767, 770, 774, 778, 781, 785, 792, 796,
+		800, 803, 807, 810, 814, 818, 825, 828, 832, 835,
+		839, 846, 849, 852, 856, 859, 866, 869, 873, 876,
+		879, 886, 889, 892, 898, 901, 905, 911, 914, 917,
+		923, 926, 929, 934, 937, 943, 946, 951, 954, 959,
+		962, 967, 972, 974, 979, 984, 988, 990, 995, 999,
+		1003,1007,1013,1016,1020,1023
+	}
+};
+
+static struct rgb_aaa_stat rgb_stat[MAX_SLICE_NUM];
+static struct cfa_aaa_stat cfa_stat[MAX_SLICE_NUM];
+static struct cfa_pre_hdr_stat hdr_cfa_pre_stat[MAX_PRE_HDR_STAT_BLK_NUM];
+static u8 rgb_stat_valid;
+static u8 cfa_stat_valid;
+static u8 hdr_cfa_pre_valid;
+
+extern int img_adj_set_filter_adj_argu(s8 mode, filter_id id);
+extern int coll_transmit_filter(void *filter, void *cmd, void *usr1, void *usr2);
+
+static int prepare_to_get_statistics(amba_dsp_aaa_statistic_data_t *stat)
+{
+	memset(rgb_stat, 0, sizeof(rgb_stat));
+	memset(cfa_stat, 0, sizeof(cfa_stat));
+	memset(hdr_cfa_pre_stat, 0, (sizeof(struct cfa_pre_hdr_stat) * MAX_PRE_HDR_STAT_BLK_NUM));
+	rgb_stat_valid = 0;
+	cfa_stat_valid = 0;
+	hdr_cfa_pre_valid = 0;
+	memset(stat, 0, sizeof(amba_dsp_aaa_statistic_data_t));
+
+	stat->CfaAaaDataAddr = (u32)cfa_stat;
+	stat->RgbAaaDataAddr = (u32)rgb_stat;
+	stat->CfaPreHdrDataAddr = (u32)hdr_cfa_pre_stat;
+	stat->CfaDataValid = (u32)&cfa_stat_valid;
+	stat->RgbDataValid = (u32)&rgb_stat_valid;
+	stat->CfaPreHdrDataValid = (u32)&hdr_cfa_pre_valid;
+
+	return 0;
+}
+
+static void get_ae_histo(u32 *p_aaa_Histo_g)
+{
+	int i, bin_count;
+	long long sum, tmp;
+
+	sum = 0;
+	bin_count = 64;
+	for(i = 0; i < bin_count; i++){
+		sum += p_aaa_Histo_g[i];
+	}
+	memset(cus_histo_info, 0, sizeof(u16) * bin_count);
+	if(sum > 0) {
+		for (i = 0; i < bin_count; i++) {
+			tmp = ((long long)p_aaa_Histo_g[i] * 4096) / sum;
+			cus_histo_info[i] = (u16)tmp;
+		}
+	}
+}
+
+static u16 get_ae_histo_sum(u16 srt, u16 end)
+{
+	u16 sum_tmp, i;
+
+	sum_tmp = 0;
+	for (i = srt; i <= end; i++) {
+	sum_tmp += cus_histo_info[i];
+	}
+
+	return (sum_tmp);
+}
+
+static u8 dynamic_calc_tone_curve(img_aaa_stat_t *aaa_stat, u8 expo_num)
+{
+	u8 ret = 0;
+	u16 histo_sum;
+	u16 Th0 = 10;
+	u16	Th1 =200;
+
+	u16 i, w_ratio0 = 100, w_ratio100 = 0, w_sum = 100;
+	static u16 pre_ratio0 = 0;
+
+	//check CFA-histo
+	get_ae_histo(aaa_stat->rgb_hist.his_bin_y);
+	histo_sum = get_ae_histo_sum(49, 63);	//normal v.s. HDR scene
+
+	switch (expo_num) {
+	case 1:
+		MW_MSG("Linear mode not support dynamic tone curve!\n");
+		break;
+	case 2:
+	    if (histo_sum <= Th0) {
+			w_ratio0 = 100;
+			w_ratio100 = 0;
+			w_sum = 100;
+		} else if (histo_sum >= Th1) {
+			w_ratio0 = 0;
+			w_ratio100 = 100;
+			w_sum = 100;
+		} else {
+			w_ratio0 = (Th1 - histo_sum) * 100 / (Th1 - Th0);
+			w_ratio100 = (histo_sum - Th0) * 100 / (Th1 - Th0);
+			w_sum = 100;
+		}
+
+		if ((w_ratio0 - pre_ratio0) > 4) {
+			w_ratio0 = pre_ratio0 + 3;
+			w_ratio100 = 100 - w_ratio0;
+			if(w_ratio100 < 0){
+				w_ratio0 = 100;
+				w_ratio100 = 0;
+			}
+		} else if ((w_ratio0 - pre_ratio0) < -4) {
+			w_ratio0 = pre_ratio0 - 3;
+			w_ratio100 = 100 - w_ratio0;
+			if(w_ratio100 > 100){
+				w_ratio0 = 0;
+				w_ratio100 = 100;
+			}
+		}
+		w_sum = w_ratio0+w_ratio100;
+
+
+		for (i = 0; i < 256; i++) {
+			cus_dyn_tone.ToneCurveGreen[i] = (cus_dyn_tone_2xHDR_0.ToneCurveGreen[i]*w_ratio0 +
+				(cus_dyn_tone_2xHDR_100.ToneCurveGreen[i] * w_ratio100)) / w_sum;
+		}
+		memcpy(cus_dyn_tone.ToneCurveRed, cus_dyn_tone.ToneCurveGreen, sizeof(u16) * 256);
+		memcpy(cus_dyn_tone.ToneCurveBlue, cus_dyn_tone.ToneCurveGreen, sizeof(u16) * 256);
+
+		pre_ratio0 = (w_ratio0 * 100) / w_sum;
+		ret = 1;
+		break;
+	case 3:
+		MW_MSG("Linear mode not support dynamic tone curve!\n");
+		break;
+	}
+
+	return ret;
+}
+
+void tone_curve_task(void *arg)
+{
+	u8 expo_num, tone_update;
+	u8 frame_skip = 0;
+	amba_dsp_aaa_statistic_data_t g_stat;
+	amba_img_dsp_mode_cfg_t dsp_mode_cfg;
+	img_aaa_stat_t aaa_stat_info[MAX_HDR_EXPOSURE_NUM];
+	aaa_tile_report_t act_tile;
+
+	memset(&dsp_mode_cfg, 0, sizeof(dsp_mode_cfg));
+	if (get_dsp_mode_cfg(&dsp_mode_cfg) < 0) {
+		return;
+	}
+	prepare_to_get_statistics(&g_stat);
+	/* stop tone curve adj */
+	img_adj_set_filter_adj_argu(-1, ADJ_TONE);
+
+	while (G_dynamic_tone_curve_active == 1) {
+		if (G_mw_config.ae_params.tone_curve_duration > 0) {
+			frame_skip = G_mw_config.ae_params.tone_curve_duration - 1;
+			if (frame_skip != 0) {
+				wait_irq_count(frame_skip);
+			}
+			if (amba_img_dsp_3a_get_aaa_stat(G_mw_config.fd, &dsp_mode_cfg, &g_stat) < 0) {
+				MW_MSG("amba_img_dsp_3a_get_aaa_stat fail\n");
+				continue;
+			}
+			if (parse_aaa_data(&g_stat, G_mw_config.res.hdr_mode, aaa_stat_info, &act_tile) < 0) {
+				MW_MSG("parse_aaa_data fail\n");
+				continue;
+			}
+
+			expo_num = G_mw_config.res.hdr_expo_num;
+			tone_update = dynamic_calc_tone_curve(&aaa_stat_info[0], expo_num);
+			if(tone_update) {
+				filter_header_t f_header;
+				f_header.filter_id = ADJ_TONE;
+				coll_transmit_filter((void*)&f_header, (void *)&cus_dyn_tone, (void *)G_mw_config.fd, (void *)&dsp_mode_cfg);
+			}
+		}
+	}
+}
+
diff --git a/mw/arch_s2l/src/mw_get_aaa_params.c b/mw/arch_s2l/src/mw_get_aaa_params.c
index c94ceed..ff83db8 100644
--- a/mw/arch_s2l/src/mw_get_aaa_params.c
+++ b/mw/arch_s2l/src/mw_get_aaa_params.c
@@ -1,18 +1,35 @@
-/**********************************************************************
+/*
  *
  * mw_get_aaa_params.c
  *
  * History:
  *	2012/12/10 - [Jingyang Qiu] Created this file
  *
- * Copyright (C) 2012 - 2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -55,8 +72,8 @@ typedef enum {
 	HDR_4X_EXPO_LINES,
 	PIRIS_LINEAR1,
 	PIRIS_LINEAR2,
-	PIRIS_HDR1,
-	PIRIS_HDR2,
+	PIRIS_HDR_2X,
+	PIRIS_HDR_3X,
 	EXPO_LINES_TOTAL,
 } ae_lines_id;
 
@@ -70,83 +87,118 @@ static filter_parser_param filter_parser;
 
 int load_cc_bin(char *sensor_name)
 {
-	int file, count;
+	int file = -1, count;
 	char filename[128];
 	u8 *matrix[4];
 	u8 i;
+	int rval = 0;
 
-	for (i = 0; i < 4; i++) {
-		matrix[i] = malloc(AMBA_DSP_IMG_CC_3D_SIZE);
-		sprintf(filename,"%s/sensors/%s_0%d_3D.bin", IMGPROC_PARAM_PATH, sensor_name, (i+1));
-		if ((file = open(filename, O_RDONLY, 0)) < 0) {
-			MW_ERROR("%s cannot be opened\n", filename);
-			return -1;
+	do {
+		for (i = 0; i < 4; i++) {
+			matrix[i] = malloc(AMBA_DSP_IMG_CC_3D_SIZE);
+			sprintf(filename,"%s/sensors/%s_0%d_3D.bin", IMGPROC_PARAM_PATH, sensor_name, (i+1));
+			if ((file = open(filename, O_RDONLY, 0)) < 0) {
+				MW_ERROR("%s cannot be opened\n", filename);
+				rval = -1;
+				break;
+			}
+			if ((count = read(file, matrix[i], AMBA_DSP_IMG_CC_3D_SIZE)) !=
+				AMBA_DSP_IMG_CC_3D_SIZE) {
+				MW_ERROR("read %s error\n",filename);
+				rval = -1;
+				break;
+			}
+			close(file);
+			file = -1;
 		}
-		if ((count = read(file, matrix[i], AMBA_DSP_IMG_CC_3D_SIZE)) !=
-			AMBA_DSP_IMG_CC_3D_SIZE) {
-			MW_ERROR("read %s error\n",filename);
-			return -1;
+
+		if (rval < 0) {
+			break;
 		}
+		cc_binary_addr_t cc_addr;
+		cc_addr.cc_0 = matrix[0];
+		cc_addr.cc_1 = matrix[1];
+		cc_addr.cc_2 = matrix[2];
+		cc_addr.cc_3 = matrix[3];
+		img_adj_load_cc_binary(&cc_addr);
+	} while (0);
+
+	if (file >= 0) {
 		close(file);
+		file = -1;
 	}
-	cc_binary_addr_t cc_addr;
-	cc_addr.cc_0 = matrix[0];
-	cc_addr.cc_1 = matrix[1];
-	cc_addr.cc_2 = matrix[2];
-	cc_addr.cc_3 = matrix[3];
-	img_adj_load_cc_binary(&cc_addr);
-
-	for(i=0; i<4; i++) {
-		free(matrix[i]);
+
+	for(i = 0; i < 4; i++) {
+		if (matrix[i]) {
+			free(matrix[i]);
+		}
 	}
-	return 0;
+
+	return rval;
 }
 
 int enable_cc(int fd, char *sensor_name, amba_img_dsp_mode_cfg_t *pMode)
 {
 	amba_img_dsp_color_correction_reg_t cc_reg;
 	amba_img_dsp_color_correction_t cc_3d;
-
 	u8 *reg, *matrix;
 	char filename[128];
-	int file, count;
+	int file = -1, count;
+	int rval = 0;
 
-	reg = malloc(AMBA_DSP_IMG_CC_REG_SIZE);
-	matrix = malloc(AMBA_DSP_IMG_CC_3D_SIZE);
+	do {
+		reg = malloc(AMBA_DSP_IMG_CC_REG_SIZE);
+		matrix = malloc(AMBA_DSP_IMG_CC_3D_SIZE);
 
-	sprintf(filename,"%s/reg.bin", IMGPROC_PARAM_PATH);
-	if ((file = open(filename, O_RDONLY, 0)) < 0) {
-		MW_ERROR("%s cannot be opened\n", filename);
-		return -1;
-	}
-	if ((count = read(file, reg, AMBA_DSP_IMG_CC_REG_SIZE)) !=
-		AMBA_DSP_IMG_CC_REG_SIZE) {
-		MW_ERROR("read %s error\n", filename);
-		return -1;
-	}
-	close(file);
+		sprintf(filename,"%s/reg.bin", IMGPROC_PARAM_PATH);
+		if ((file = open(filename, O_RDONLY, 0)) < 0) {
+			MW_ERROR("%s cannot be opened\n", filename);
+			rval = -1;
+			break;
+		}
+		if ((count = read(file, reg, AMBA_DSP_IMG_CC_REG_SIZE)) !=
+			AMBA_DSP_IMG_CC_REG_SIZE) {
+			MW_ERROR("read %s error\n", filename);
+			break;
+		}
+		close(file);
+		file = -1;
 
-	sprintf(filename,"%s/sensors/%s_0%d_3D.bin", IMGPROC_PARAM_PATH, sensor_name, 2);
-	if ((file = open(filename, O_RDONLY, 0)) < 0) {
-		MW_ERROR("%s cannot be opened\n", filename);
-		return -1;
-	}
-	if ((count = read(file, matrix, AMBA_DSP_IMG_CC_3D_SIZE)) !=
-		AMBA_DSP_IMG_CC_3D_SIZE) {
-		MW_ERROR("read %s error\n", filename);
-		return -1;
-	}
-	close(file);
+		sprintf(filename,"%s/sensors/%s_0%d_3D.bin", IMGPROC_PARAM_PATH, sensor_name, 2);
+		if ((file = open(filename, O_RDONLY, 0)) < 0) {
+			MW_ERROR("%s cannot be opened\n", filename);
+			rval = -1;
+			break;
+		}
+		if ((count = read(file, matrix, AMBA_DSP_IMG_CC_3D_SIZE)) !=
+			AMBA_DSP_IMG_CC_3D_SIZE) {
+			MW_ERROR("read %s error\n", filename);
+			rval = -1;
+			break;
+		}
+		close(file);
+		file = -1;
 
-	cc_reg.RegSettingAddr = (u32)reg;
-	amba_img_dsp_set_color_correction_reg(pMode, &cc_reg);
+		cc_reg.RegSettingAddr = (u32)reg;
+		amba_img_dsp_set_color_correction_reg(pMode, &cc_reg);
 
-	cc_3d.MatrixThreeDTableAddr = (u32)matrix;
-	amba_img_dsp_set_color_correction(fd, pMode,&cc_3d);
+		cc_3d.MatrixThreeDTableAddr = (u32)matrix;
+		amba_img_dsp_set_color_correction(fd, pMode,&cc_3d);
+	} while (0);
 
-	free(reg);
-	free(matrix);
-	return 0;
+	if (file >= 0) {
+		close(file);
+		file = -1;
+	}
+	if (reg) {
+		free(reg);
+		reg = NULL;
+	}
+	if (matrix) {
+		free(matrix);
+		matrix = NULL;
+	}
+	return rval;
 }
 
 int load_dsp_cc_table(int fd, char *sensor_name, amba_img_dsp_mode_cfg_t *pMode)
@@ -737,12 +789,15 @@ static int parse_aeb_params(_mw_global_config *pMw_info)
 
 	int item = 0;
 	img_aeb_tile_config_t *ptile_config = NULL;
-	img_aeb_expo_lines_t *pexpo_line[EXPO_LINES_TOTAL]  = {NULL};
+	img_aeb_expo_lines_t *pexpo_line[EXPO_LINES_TOTAL] = {NULL};
 	img_aeb_wb_param_t *pwb_params = NULL;
 	img_aeb_sensor_config_t *paeb_sensor_config = NULL;
 	img_aeb_sht_nl_table_t *psht_table = NULL;
 	img_aeb_gain_table_t *pgain_table = NULL;
 	img_aeb_expo_lines_t *p_tmp_lines = NULL;
+	img_aeb_auto_knee_param_t *p_auto_knee = NULL;
+	img_aeb_digit_wdr_param_t *p_digit_wdr[EXPO_LINES_TOTAL] = {NULL};
+	img_aeb_digit_wdr_param_t *p_curr_digit_wdr = NULL;
 	ae_cfg_tbl_t ae_tbl[EXPO_LINES_TOTAL];
 	amba_img_dsp_mode_cfg_t ik_mode;
 	amba_img_dsp_variable_range_t dsp_variable_range;
@@ -823,10 +878,22 @@ static int parse_aeb_params(_mw_global_config *pMw_info)
 				pexpo_line[PIRIS_LINEAR2] = (img_aeb_expo_lines_t *)buf;
 				break;
 			case AEB_EXPO_LINES_PIRIS_HDR1:
-				pexpo_line[PIRIS_HDR1] = (img_aeb_expo_lines_t *)buf;
+				pexpo_line[PIRIS_HDR_2X] = (img_aeb_expo_lines_t *)buf;
 				break;
 			case AEB_EXPO_LINES_PIRIS_HDR2:
-				pexpo_line[PIRIS_HDR2] = (img_aeb_expo_lines_t *)buf;
+				pexpo_line[PIRIS_HDR_3X] = (img_aeb_expo_lines_t *)buf;
+				break;
+			case AEB_AUTO_KNEE:
+				p_auto_knee = (img_aeb_auto_knee_param_t *)buf;
+				break;
+			case AEB_DIGIT_WDR:
+				p_digit_wdr[NORMAL_EXPO_LINES] = (img_aeb_digit_wdr_param_t *)buf;
+				break;
+			case AEB_DIGIT_WDR_2X_HDR:
+				p_digit_wdr[HDR_2X_EXPO_LINES] = (img_aeb_digit_wdr_param_t *)buf;
+				break;
+			case AEB_DIGIT_WDR_3X_HDR:
+				p_digit_wdr[HDR_3X_EXPO_LINES] = (img_aeb_digit_wdr_param_t *)buf;
 				break;
 			default:
 				MW_ERROR("Error: The type:%d is unknown\n", item);
@@ -899,10 +966,49 @@ static int parse_aeb_params(_mw_global_config *pMw_info)
 				p_tmp_lines = pexpo_line[NORMAL_EXPO_LINES];
 				break;
 			}
+			p_curr_digit_wdr = p_digit_wdr[NORMAL_EXPO_LINES];
 		} else if (resource->hdr_expo_num == HDR_2X) {
-			p_tmp_lines = pexpo_line[HDR_2X_EXPO_LINES];
+			switch (sensor->lens_id) {
+			case LENS_M13VP288IR_ID:
+				if (pexpo_line[PIRIS_HDR_2X] == NULL) {
+					p_tmp_lines = pexpo_line[HDR_2X_EXPO_LINES];
+				} else {
+					p_tmp_lines = pexpo_line[PIRIS_HDR_2X];
+				}
+				break;
+			case LENS_MZ128BP2810ICR_ID:
+				if (pexpo_line[PIRIS_HDR_2X] == NULL) {
+					p_tmp_lines = pexpo_line[HDR_2X_EXPO_LINES];
+				} else {
+					p_tmp_lines = pexpo_line[PIRIS_HDR_2X];
+				}
+				break;
+			default:
+				p_tmp_lines = pexpo_line[HDR_2X_EXPO_LINES];
+				break;
+			}
+			p_curr_digit_wdr = p_digit_wdr[HDR_2X_EXPO_LINES];
 		}  else if (resource->hdr_expo_num == HDR_3X) {
-			p_tmp_lines = pexpo_line[HDR_3X_EXPO_LINES];
+			switch (sensor->lens_id) {
+			case LENS_M13VP288IR_ID:
+				if (pexpo_line[PIRIS_HDR_3X] == NULL) {
+					p_tmp_lines = pexpo_line[HDR_3X_EXPO_LINES];
+				} else {
+					p_tmp_lines = pexpo_line[PIRIS_HDR_3X];
+				}
+				break;
+			case LENS_MZ128BP2810ICR_ID:
+				if (pexpo_line[PIRIS_HDR_3X] == NULL) {
+					p_tmp_lines = pexpo_line[HDR_3X_EXPO_LINES];
+				} else {
+					p_tmp_lines = pexpo_line[PIRIS_HDR_3X];
+				}
+				break;
+			default:
+				p_tmp_lines = pexpo_line[HDR_3X_EXPO_LINES];
+				break;
+			}
+			p_curr_digit_wdr = p_digit_wdr[HDR_3X_EXPO_LINES];
 		} else {
 			MW_ERROR("Error:can't find the proper ae lines for mode %d, expo num %d\n", \
 				resource->hdr_mode, resource->hdr_expo_num);
@@ -923,6 +1029,20 @@ static int parse_aeb_params(_mw_global_config *pMw_info)
 
 		img_config_ae_tables(ae_tbl, resource->hdr_expo_num);
 		img_config_awb_param(&(pwb_params->wb_param));
+		if (p_auto_knee) {
+			if (img_config_auto_knee_info(p_auto_knee) < 0) {
+				MW_ERROR("img_config_auto_knee_info error!\n");
+				error_flag = -1;
+				break;
+			}
+		}
+		if (p_curr_digit_wdr) {
+			if (img_config_digit_wdr_info(p_curr_digit_wdr) < 0) {
+				MW_ERROR("img_config_digit_wdr_info error!\n");
+				error_flag = -1;
+				break;
+			}
+		}
 
 	} while (0);
 
@@ -1062,15 +1182,9 @@ int get_sensor_aaa_params_from_bin(_mw_global_config *pMw_info)
 		}
 		if ((pMw_info->sensor.lens_id != LENS_CMOUNT_ID) &&
 			(strcmp(pMw_info->sensor.load_files.lens_file, "") != 0)) {
-			if (pMw_info->res.hdr_mode == HDR_PIPELINE_OFF) {
-				if ((ret = parse_lens_params(pMw_info)) < 0) {
-					MW_ERROR("error: parse_lens_params\n");
-					break;
-				}
-			} else {
-				MW_INFO("Not support p-iris control in HDR mode now\n");
-				pMw_info->ae_params.lens_aperture.FNO_min = 0;
-				pMw_info->ae_params.lens_aperture.FNO_max = 0;
+			if ((ret = parse_lens_params(pMw_info)) < 0) {
+				MW_ERROR("error: parse_lens_params\n");
+				break;
 			}
 		}
 		pMw_info->init_params.operate_adj = OPERATE_NONE;
diff --git a/mw/arch_s2l/src/mw_image.c b/mw/arch_s2l/src/mw_image.c
index 8179e28..5a87584 100644
--- a/mw/arch_s2l/src/mw_image.c
+++ b/mw/arch_s2l/src/mw_image.c
@@ -1,4 +1,4 @@
-/**********************************************************************
+/*
  *
  * mw_image.c
  *
@@ -6,14 +6,31 @@
  *	2010/02/28 - [Jian Tang] Created this file
  *	2011/06/20 - [Jian Tang] Modified this file
  *
- * Copyright (C) 2007 - 2011, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -71,7 +88,7 @@ _mw_global_config G_mw_config = {
 		.slow_shutter_enable  = 0,
 		.ir_led_mode          = MW_IR_LED_MODE_AUTO,
 		.current_vin_fps      = AMBA_VIDEO_FPS_60,
-		.ae_metering_mode    = MW_AE_CENTER_METERING,
+		.ae_metering_mode     = MW_AE_CENTER_METERING,
 		.ae_metering_table    = {
 			.metering_weight  = {			//AE_METER_CENTER
 				1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
@@ -87,6 +104,7 @@ _mw_global_config G_mw_config = {
 		.ae_level             = {
 		100,
 		},
+		.tone_curve_duration    = MAX_TONE_CURVE_DURATION,
 	},
 	.iris_params = {
 		.iris_type      = 0,
@@ -110,7 +128,7 @@ _mw_global_config G_mw_config = {
 		.auto_contrast    = 0,
 		.auto_wdr_str     = 0,
 		.dn_mode          = 0,
-		.mctf_strength    = 64,
+		.mctf_strength    = 6,
 		.sharpen_strength = 0,
 		.chroma_noise_str = 64,
 		.local_expo_mode  = 0,
@@ -135,6 +153,8 @@ _mw_global_config G_mw_config = {
 				1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024
 			},
 		},
+		.auto_knee_strength = 100,
+		.auto_dump_cfg = 0,
 	},
 };
 
@@ -202,21 +222,39 @@ int mw_get_sys_info(mw_sys_info *pMw_sys_info)
 	return 0;
 }
 
+int mw_get_sys_multi_chan_info(mw_sys_multi_chan_info *pMw_info)
+{
+	if (pMw_info == NULL) {
+		MW_ERROR("The point is null\n\n");
+		return -1;
+	}
+
+	memset(pMw_info, 0, sizeof(mw_sys_multi_chan_info));
+	pMw_info->chan_num = 1;
+	pMw_info->cur_chan_id = 0;
+
+	pMw_info->res[0] = G_mw_config.res;
+	pMw_info->sensor[0].step = G_mw_config.sensor.vin_aaa_info.agc_step;
+
+	return 0;
+}
+
 int mw_start_aaa(int fd)
 {
 	int retry = 3;
 	if (G_mw_config.init_params.mw_enable == 1) {
 		MW_MSG("Already start!\n");
-		return -1;
+		return MW_AAA_SUCCESS;
 	}
 
 	G_mw_config.fd = fd;
 
 	if (init_netlink() < 0) {
 		MW_ERROR("init_netlink \n");
-		return -1;
+		return MW_AAA_NL_INIT_FAIL;
 	}
 
+	G_mw_config.init_params.mw_enable = 1;
 	G_mw_config.init_params.wait_3a = 1;
 	while (G_mw_config.init_params.wait_3a) {
 		if (0 != wait_sem(0)) {
@@ -231,33 +269,40 @@ int mw_start_aaa(int fd)
 		}
 	}
 	G_mw_config.init_params.wait_3a = 0;
-	G_mw_config.init_params.mw_enable = 1;
 
 	MW_MSG("======= [DONE] mw_start_aaa ======= \n");
-	return 0;
+	if (!G_mw_config.init_params.aaa_active) {
+		return MW_AAA_INTERRUPTED;
+	}
+	return MW_AAA_SUCCESS;
 }
 
 int mw_stop_aaa(void)
 {
+	int ret = 0;
+	if (G_mw_config.init_params.mw_enable == 0) {
+		MW_INFO("3A is not enabled. Quit silently.\n");
+		return MW_AAA_SUCCESS;
+	}
+
 	if (G_mw_config.init_params.wait_3a) {
 		G_mw_config.init_params.wait_3a = 0;
 		signal_sem();
 	}
-	if (G_mw_config.init_params.mw_enable == 0) {
-		MW_INFO("3A is not enabled. Quit silently.\n");
-		return 0;
-	}
 
-	if (send_image_msg_stop_aaa() < 0) {
+	if ((ret = send_image_msg_stop_aaa()) < 0) {
 		MW_ERROR("stop_aaa_task\n");
-		return -1;
 	}
 	deinit_netlink();
 	G_mw_config.init_params.mw_enable = 0;
 
 	MW_MSG("======= [DONE] mw_stop_aaa ======= \n");
 
-	return 0;
+	if (ret < 0) {
+		return MW_AAA_SET_FAIL;
+	}
+
+	return MW_AAA_SUCCESS;
 }
 
 int mw_init_mctf(int fd)
@@ -398,18 +443,7 @@ int mw_get_image_statistics(mw_image_stat_info *pInfo)
 		return -1;
 	}
 
-	u32 agc;
-	u32 shutter;
-
-	if (G_mw_config.sensor.is_rgb_sensor == 0) {
-		agc = 0;
-		shutter = Q9_BASE;
-	} else {
-		img_get_ae_system_gain(&agc);
-		get_shutter_time(&shutter);
-	}
-	pInfo->agc = agc * 1024 * 6 / 128;		//expressed in db x 1024
-	pInfo->shutter = shutter;
+	MW_MSG("Not support\n");
 
 	return 0;
 }
@@ -433,7 +467,8 @@ int mw_enable_ae(int enable)
 
 int mw_set_ae_param(mw_ae_param *pAe_param)
 {
-	u32 hdr_shutter_max = 0;
+	u64 hdr_shutter_max = 0;
+	hdr_blend_info_t hdr_blend_cfg;
 
 	if (pAe_param == NULL) {
 		MW_ERROR("mw_set_ae_param pointer is NULL!\n");
@@ -489,33 +524,44 @@ int mw_set_ae_param(mw_ae_param *pAe_param)
 	}
 
 	if (G_mw_config.res.hdr_expo_num == HDR_2X) {
-		hdr_shutter_max = HDR_2X_MAX_SHUTTER(pAe_param->current_vin_fps);
+		if ((pAe_param->tone_curve_duration > MAX_TONE_CURVE_DURATION) ||
+			(pAe_param->tone_curve_duration == 0)) {
+			MW_ERROR("Only support tone curver in 2X hdr mode with duration [1~%d]\n",
+				MAX_TONE_CURVE_DURATION);
+			return -1;
+		}
+	}
+
+	if (G_mw_config.res.hdr_expo_num == HDR_2X) {
+		img_get_hdr_blend_config(&hdr_blend_cfg);
+		hdr_shutter_max = HDR_2X_MAX_SHUTTER((u64)pAe_param->current_vin_fps, (u64)hdr_blend_cfg.expo_ratio);
 		if (pAe_param->shutter_time_max > hdr_shutter_max) {
 			MW_ERROR("Shutter time max [1/%d s] is longer than HDR shutter limit "
-				"[1/%d s]. Ignore this change!\n",
+				"[1/%llu s]. Ignore this change!\n",
 				SHT_TIME(pAe_param->shutter_time_max),
 				SHT_TIME(hdr_shutter_max));
 			return -1;
 		}
 		if (pAe_param->shutter_time_min > hdr_shutter_max) {
 			MW_ERROR("Shutter time min [1/%d s] is longer than HDR shutter limit "
-				"[1/%d s]. Ignore this change!\n",
+				"[1/%llu s]. Ignore this change!\n",
 				SHT_TIME(pAe_param->shutter_time_min),
 				SHT_TIME(hdr_shutter_max));
 			return -1;
 		}
 	} else if (G_mw_config.res.hdr_expo_num == HDR_3X) {
-		hdr_shutter_max = HDR_3X_MAX_SHUTTER(pAe_param->current_vin_fps);
+		img_get_hdr_blend_config(&hdr_blend_cfg);
+		hdr_shutter_max = HDR_3X_MAX_SHUTTER((u64)pAe_param->current_vin_fps, (u64)hdr_blend_cfg.expo_ratio);
 		if (pAe_param->shutter_time_max > hdr_shutter_max) {
 			MW_ERROR("Shutter time max [1/%d s] is longer than HDR shutter limit "
-				"[1/%d s]. Ignore this change!\n",
+				"[1/%llu s]. Ignore this change!\n",
 				SHT_TIME(pAe_param->shutter_time_max),
 				SHT_TIME(hdr_shutter_max));
 			return -1;
 		}
 		if (pAe_param->shutter_time_min > hdr_shutter_max) {
 			MW_ERROR("Shutter time min [1/%d s] is longer than HDR shutter limit "
-				"[1/%d s]. Ignore this change!\n",
+				"[1/%llu s]. Ignore this change!\n",
 				SHT_TIME(pAe_param->shutter_time_min),
 				SHT_TIME(hdr_shutter_max));
 			return -1;
@@ -581,11 +627,11 @@ int mw_set_exposure_level(int *pExposure_level)
 		if (pExposure_level[i] > MW_EXPOSURE_LEVEL_MAX - 1) {
 			pExposure_level[i] = MW_EXPOSURE_LEVEL_MAX - 1;
 		}
+		ae_target[i] = (u16)((pExposure_level[i] << 10) / 100);
 		if (G_mw_config.ae_params.ae_level[i] == pExposure_level[i]) {
 			is_same++;
 			continue;
 		}
-		ae_target[i] = (u16)((pExposure_level[i] << 10) / 100);
 		G_mw_config.ae_params.ae_level[i] = pExposure_level[i];
 	}
 	if (is_same == G_mw_config.res.hdr_expo_num) {
@@ -714,6 +760,11 @@ int mw_get_shutter_time(int fd, int *pShutter_time)
 		*pShutter_time = vsrc_shutter.shutter;
 	}
 
+	if (pShutter_time[0] == 0) {
+		MW_ERROR("AE is not ready or get incorrect value!\n");
+		return -1;
+	}
+
 	return 0;
 }
 
@@ -1328,36 +1379,7 @@ int mw_get_mctf_strength(u32 *pStrength)
 
 int mw_set_auto_local_exposure_mode(u32 mode)
 {
-	MW_INFO("Local exposure mode : [%d].\n", mode);
-	if (mode == 0 || mode ==1) {
-		if (img_set_wdr_enable(mode) < 0) {
-			MW_ERROR("img_set_wdr_enable error/n");
-			return -1;
-		}
-		if (mode == 0) {//restore local exposure to off(no WDR)
-			if (mw_set_local_exposure_curve(G_mw_config.fd,
-				&G_mw_config.enh_params.le_off_curve) < 0) {
-				MW_ERROR("Restore local exposure to off failed\n");
-				return -1;
-			}
-		}
-	} else if (mode <= MW_LE_STRENGTH_MAX) {
-		if (G_mw_config.enh_params.local_expo_mode == 0) {
-			if (img_set_wdr_enable(1) < 0) {
-				MW_ERROR("img_set_wdr_enable error/n");
-				return -1;
-			}
-		}
-		if (img_set_wdr_strength(mode) < 0) {
-			MW_ERROR("img_set_wdr_strength error/n");
-			return -1;
-		}
-	} else {
-		MW_ERROR("Invalide mode %d, range is [%d, %d]\n",
-				mode, MW_LE_STRENGTH_MIN, MW_LE_STRENGTH_MAX);
-		return -1;
-	}
-	G_mw_config.enh_params.local_expo_mode = mode;
+	MW_INFO("Please refer to mw_set_auto_wdr_strength\n");
 	return 0;
 }
 
@@ -1478,6 +1500,10 @@ int mw_set_auto_color_contrast(u32 enable)
 		MW_ERROR("The value must be 0 or 1\n");
 		return -1;
 	}
+	if (img_set_auto_color_contrast(enable) < 0) {
+		MW_ERROR("img_set_auto_color_contrast failed\n");
+		return -1;
+	}
 
 	G_mw_config.enh_params.auto_contrast = enable;
 	return 0;
@@ -1503,6 +1529,10 @@ int mw_set_auto_color_contrast_strength (u32 value)
 		MW_ERROR("\nThe value must be 0~128\n");
 		return -1;
 	}
+	if (img_set_auto_color_contrast_strength(value) < 0) {
+		MW_ERROR("img_set_auto_color_contrast_strength failed\n");
+		return -1;
+	}
 
 	return 0;
 }
@@ -1512,33 +1542,7 @@ int mw_set_auto_color_contrast_strength (u32 value)
 
 int mw_set_ae_area(int enable)
 {
-	struct iav_srcbuf_setup srcbuf_setup;
-	statistics_config_t config;
-
-	memset(&srcbuf_setup, 0, sizeof(struct iav_srcbuf_setup));
-
-	if (ioctl(G_mw_config.fd, IAV_IOC_GET_SOURCE_BUFFER_SETUP, &srcbuf_setup) < 0) {
-		MW_ERROR("IAV_IOC_GET_SOURCE_BUFFER_SETUP\n");
-		return -1;
-	}
-
-	if (enable) {
-		config.ae_tile_col_start = srcbuf_setup.input[IAV_SRCBUF_PMN].x *
-			IMAGE_AREA_WIDTH / srcbuf_setup.size[IAV_SRCBUF_MN].width;
-		config.ae_tile_row_start = srcbuf_setup.input[IAV_SRCBUF_PMN].y *
-			IMAGE_AREA_HEIGHT / srcbuf_setup.size[IAV_SRCBUF_MN].height;
-		config.ae_tile_width = (srcbuf_setup.size[IAV_SRCBUF_PMN].width /
-			config.ae_tile_num_col) * IMAGE_AREA_WIDTH /
-			srcbuf_setup.size[IAV_SRCBUF_MN].width;
-		config.ae_tile_height = (srcbuf_setup.size[IAV_SRCBUF_PMN].height/
-			config.ae_tile_num_row) * IMAGE_AREA_HEIGHT/
-			srcbuf_setup.size[IAV_SRCBUF_MN].height;
-	} else {
-		config.ae_tile_col_start = 0;
-		config.ae_tile_row_start = 0;
-		config.ae_tile_width = IMAGE_AREA_WIDTH / config.ae_tile_num_col;
-		config.ae_tile_height = IMAGE_AREA_HEIGHT / config.ae_tile_num_row;
-	}
+	MW_ERROR("Not support now.\n");
 
 	return 0;
 }
@@ -1585,21 +1589,23 @@ int mw_set_auto_wdr_strength(int strength)
 int mw_load_adj_param(mw_adj_file_param *contents)
 {
 	int i;
+	int file_name_len = 0;
 
 	if (contents->filename == NULL) {
 		MW_ERROR("%s error: pFile_name is null\n", __func__);
 		return -1;
 	}
+	file_name_len = strlen(contents->filename);
 
-	if (strlen(contents->filename) > (FILE_NAME_LENGTH - 1)) {
+	if (file_name_len > (FILE_NAME_LENGTH - 1)) {
 		MW_ERROR("%s error: the file name length must be < %d\n",
 			__func__, FILE_NAME_LENGTH);
 		return -1;
 
 	}
 
-	memcpy(G_mw_config.adj.filename, contents->filename,
-		strlen(contents->filename));
+	memcpy(G_mw_config.adj.filename, contents->filename, file_name_len);
+	G_mw_config.adj.filename[file_name_len] = '\0';
 	for (i = 0; i < ADJ_FILTER_NUM; i++) {
 		G_mw_config.adj.flag[i].apply = contents->flag[i].apply;
 		G_mw_config.adj.flag[i].done = 0;
@@ -1622,21 +1628,23 @@ int mw_load_adj_param(mw_adj_file_param *contents)
 int mw_save_adj_param(mw_adj_file_param *contents)
 {
 	int i;
+	int file_name_len = 0;
 
 	if (contents->filename == NULL) {
 		MW_ERROR("%s error: pFile_name is null\n", __func__);
 		return -1;
 	}
+	file_name_len = strlen(contents->filename);
 
-	if (strlen(contents->filename) > (FILE_NAME_LENGTH - 1)) {
+	if (file_name_len > (FILE_NAME_LENGTH - 1)) {
 		MW_ERROR("%s error: the file name length must be < %d\n",
 			__func__, FILE_NAME_LENGTH);
 		return -1;
 
 	}
 
-	memcpy(G_mw_config.adj.filename, contents->filename,
-		strlen(contents->filename));
+	memcpy(G_mw_config.adj.filename, contents->filename, file_name_len);
+	G_mw_config.adj.filename[file_name_len] = '\0';
 	for (i = 0; i < ADJ_FILTER_NUM; i++) {
 		G_mw_config.adj.flag[i].apply = contents->flag[i].apply;
 		G_mw_config.adj.flag[i].done = 0;
@@ -1658,12 +1666,14 @@ int mw_save_adj_param(mw_adj_file_param *contents)
 
 int mw_load_aaa_param_file(char *pFile_name, int type)
 {
+	int file_name_len = 0;
 	if (pFile_name == NULL) {
 		MW_ERROR("%s error: pFile_name is null\n", __func__);
 		return -1;
 	}
+	file_name_len = strlen(pFile_name);
 
-	if (strlen(pFile_name) > (FILE_NAME_LENGTH - 1)) {
+	if (file_name_len > (FILE_NAME_LENGTH - 1)) {
 		MW_ERROR("%s error: the file name length must be < %d\n",
 			__func__, FILE_NAME_LENGTH);
 		return -1;
@@ -1674,14 +1684,17 @@ int mw_load_aaa_param_file(char *pFile_name, int type)
 	case FILE_TYPE_ADJ:
 		memcpy(G_mw_config.sensor.load_files.adj_file, pFile_name,
 			sizeof(G_mw_config.sensor.load_files.adj_file));
+		G_mw_config.sensor.load_files.adj_file[file_name_len] = '\0';
 		break;
 	case FILE_TYPE_AEB:
 		memcpy(G_mw_config.sensor.load_files.aeb_file, pFile_name,
 			sizeof(G_mw_config.sensor.load_files.aeb_file));
+		G_mw_config.sensor.load_files.aeb_file[file_name_len] = '\0';
 		break;
 	case FILE_TYPE_PIRIS:
 		memcpy(G_mw_config.sensor.load_files.lens_file, pFile_name,
 			sizeof(G_mw_config.sensor.load_files.lens_file));
+		G_mw_config.sensor.load_files.lens_file[file_name_len] = '\0';
 		break;
 	default:
 		MW_ERROR("No the type\n");
@@ -1696,5 +1709,185 @@ int mw_set_lens_id(int lens_id)
 	return 0;
 }
 
+int mw_set_auto_knee_strength (int strength)
+{
+	u8 auto_knee_strength = 0;
+	if (G_mw_config.enh_params.auto_knee_strength == strength) {
+		return 0;
+	}
+
+	if (strength < MW_AUTO_KNEE_MIN || strength > MW_AUTO_KNEE_MAX) {
+		return -1;
+	} else {
+		auto_knee_strength = strength;
+	}
+	if (img_set_ae_auto_knee(&auto_knee_strength) < 0) {
+		return -1;
+	}
+	G_mw_config.enh_params.auto_knee_strength = strength;
+
+	return 0;
+}
+
+int mw_get_auto_knee_strength (int *pStrength)
+{
+	if (pStrength == NULL) {
+		MW_ERROR("NULL pointer, mw_get_auto_knee_strength failed\n");
+		return -1;
+	}
+	*pStrength = G_mw_config.enh_params.auto_knee_strength;
+	return 0;
+}
+
+int mw_enable_auto_dump_cfg(int enable)
+{
+	G_mw_config.enh_params.auto_dump_cfg = !!enable;
+	return 0;
+}
+
+int mw_set_hdr_blend_config(mw_hdr_blend_info *pBlend_cfg)
+{
+	hdr_blend_info_t hdr_blend_cfg;
+	if (pBlend_cfg->boost_factor < MW_HDR_BLEND_BOOST_FACTOR_MIN ||
+			pBlend_cfg->boost_factor > MW_HDR_BLEND_BOOST_FACTOR_MAX) {
+		MW_ERROR("Invalid param: boost factor %d is out of range [%d, %d]",
+				pBlend_cfg->boost_factor, MW_HDR_BLEND_BOOST_FACTOR_MIN,
+				MW_HDR_BLEND_BOOST_FACTOR_MAX);
+		return -1;
+	}
+	if (pBlend_cfg->expo_ratio < MW_HDR_BLEND_EXPO_RATIO_MIN ||
+			pBlend_cfg->expo_ratio > MW_HDR_BLEND_EXPO_RATIO_MAX) {
+		MW_ERROR("Invalid param: exposure ratio %d is out of range [%d, %d]",
+				pBlend_cfg->expo_ratio, MW_HDR_BLEND_EXPO_RATIO_MIN,
+				MW_HDR_BLEND_EXPO_RATIO_MAX);
+		return -1;
+	}
+	hdr_blend_cfg.boost_factor = pBlend_cfg->boost_factor;
+	hdr_blend_cfg.expo_ratio = pBlend_cfg->expo_ratio;
+	if (img_set_hdr_blend_config(&hdr_blend_cfg) < 0) {
+		MW_ERROR("img_set_hdr_blend_config failed!\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+int mw_get_hdr_blend_config(mw_hdr_blend_info *pBlend_cfg)
+{
+	hdr_blend_info_t hdr_blend_cfg;
+	if (img_get_hdr_blend_config(&hdr_blend_cfg) < 0) {
+		MW_ERROR("img_get_hdr_blend_config failed!\n");
+		return -1;
+	}
+	pBlend_cfg->boost_factor = hdr_blend_cfg.boost_factor;
+	pBlend_cfg->expo_ratio = hdr_blend_cfg.expo_ratio;
+
+	return 0;
+}
+
+int mw_set_wdr_luma_config(mw_wdr_luma_info *pWdr_luma_cfg)
+{
+	wdr_luma_config_info_t wdr_luma_cfg;
+	int retv = -1;
+
+	if (pWdr_luma_cfg == NULL) {
+		MW_ERROR("NULL pointer, mw_set_wdr_luma_config failed\n");
+		retv = -1;
+		goto EXIT;
+	}
+
+	if ((pWdr_luma_cfg->radius < MW_WDR_LUMA_RADIUS_MIN) || (pWdr_luma_cfg->radius > MW_WDR_LUMA_RADIUS_MAX)) {
+		MW_ERROR("Invalid param: radius %d is out of range [%d, %d]",
+				pWdr_luma_cfg->radius, MW_WDR_LUMA_RADIUS_MIN,
+				MW_WDR_LUMA_RADIUS_MAX);
+		retv = -1;
+		goto EXIT;
+	}
+
+	if ((pWdr_luma_cfg->luma_weight_red < MW_WDR_LUMA_WEIGHT_MIN) || (pWdr_luma_cfg->luma_weight_red > MW_WDR_LUMA_WEIGHT_MAX)) {
+		MW_ERROR("Invalid param: luma_weight_red %d is out of range [%d, %d]",
+				pWdr_luma_cfg->luma_weight_red, MW_WDR_LUMA_WEIGHT_MIN,
+				MW_WDR_LUMA_WEIGHT_MAX);
+		retv = -1;
+		goto EXIT;
+	}
+
+	if ((pWdr_luma_cfg->luma_weight_green < MW_WDR_LUMA_WEIGHT_MIN) || (pWdr_luma_cfg->luma_weight_green > MW_WDR_LUMA_WEIGHT_MAX)) {
+		MW_ERROR("Invalid param: luma_weight_green %d is out of range [%d, %d]",
+				pWdr_luma_cfg->luma_weight_green, MW_WDR_LUMA_WEIGHT_MIN,
+				MW_WDR_LUMA_WEIGHT_MAX);
+		retv = -1;
+		goto EXIT;
+	}
+
+	if ((pWdr_luma_cfg->luma_weight_blue < MW_WDR_LUMA_WEIGHT_MIN) || (pWdr_luma_cfg->luma_weight_blue > MW_WDR_LUMA_WEIGHT_MAX)) {
+		MW_ERROR("Invalid param: luma_weight_blue %d is out of range [%d, %d]",
+				pWdr_luma_cfg->luma_weight_blue, MW_WDR_LUMA_WEIGHT_MIN,
+				MW_WDR_LUMA_WEIGHT_MAX);
+		retv = -1;
+		goto EXIT;
+	}
+
+	if ((pWdr_luma_cfg->luma_weight_shift < MW_WDR_LUMA_WEIGHT_MIN) || (pWdr_luma_cfg->luma_weight_shift > MW_WDR_LUMA_WEIGHT_MAX)) {
+		MW_ERROR("Invalid param: luma_weight_shift %d is out of range [%d, %d]",
+				pWdr_luma_cfg->luma_weight_shift, MW_WDR_LUMA_WEIGHT_MIN,
+				MW_WDR_LUMA_WEIGHT_MAX);
+		retv = -1;
+		goto EXIT;
+	}
+
+	wdr_luma_cfg.radius = pWdr_luma_cfg->radius;
+	wdr_luma_cfg.luma_weight_red = pWdr_luma_cfg->luma_weight_red;
+	wdr_luma_cfg.luma_weight_green = pWdr_luma_cfg->luma_weight_green;
+	wdr_luma_cfg.luma_weight_blue = pWdr_luma_cfg->luma_weight_blue;
+	wdr_luma_cfg.luma_weight_shift = pWdr_luma_cfg->luma_weight_shift;
+
+	if (img_set_wdr_luma_config(&wdr_luma_cfg) < 0) {
+		MW_ERROR("img_set_wdr_luma_config failed!\n");
+		retv = -1;
+		goto EXIT;
+	}
+
+	retv = 0;
+
+EXIT:
+	return retv;
+}
+
+int mw_get_wdr_luma_config(mw_wdr_luma_info *pWdr_luma_cfg)
+{
+	wdr_luma_config_info_t wdr_luma_cfg;
+	int retv = -1;
+
+	if (pWdr_luma_cfg == NULL) {
+		MW_ERROR("NULL pointer, mw_get_wdr_luma_config failed\n");
+		retv = -1;
+		goto EXIT;
+	}
+
+	if (img_get_wdr_luma_config(&wdr_luma_cfg) < 0) {
+		MW_ERROR("img_get_wdr_luma_config failed!\n");
+		retv = -1;
+		goto EXIT;
+	}
+
+	pWdr_luma_cfg->radius = wdr_luma_cfg.radius;
+	pWdr_luma_cfg->luma_weight_red = wdr_luma_cfg.luma_weight_red;
+	pWdr_luma_cfg->luma_weight_green = wdr_luma_cfg.luma_weight_green;
+	pWdr_luma_cfg->luma_weight_blue = wdr_luma_cfg.luma_weight_blue;
+	pWdr_luma_cfg->luma_weight_shift = wdr_luma_cfg.luma_weight_shift;
+
+	retv = 0;
+
+EXIT:
+	return retv;
+}
+
+int mw_set_img_log_level(u32 level)
+{
+	MW_INFO("Not support %s.\n", __func__);
+	return 0;
+}
+
 #define __END_OF_FILE__
 
diff --git a/mw/arch_s2l/src/mw_image_priv.c b/mw/arch_s2l/src/mw_image_priv.c
index 44a39d7..cac7177 100644
--- a/mw/arch_s2l/src/mw_image_priv.c
+++ b/mw/arch_s2l/src/mw_image_priv.c
@@ -1,4 +1,4 @@
-/**********************************************************************
+/*
  *
  * mw_image_priv.c
  *
@@ -6,14 +6,31 @@
  *	2010/02/28 - [Jian Tang] Created this file
  *	2012/03/23 - [Jian Tang] Modified this file
  *
- * Copyright (C) 2007 - 2012, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -24,11 +41,13 @@
 #include <sys/ioctl.h>
 #include <assert.h>
 #include <basetypes.h>
+#include <sys/mman.h>
 
 #include <pthread.h>
 
 #include "iav_common.h"
 #include "iav_ioctl.h"
+#include "iav_fastboot.h"
 #include "iav_vin_ioctl.h"
 #include "iav_vout_ioctl.h"
 #include "ambas_imgproc_arch.h"
@@ -84,15 +103,15 @@ typedef enum  {
 #define CALI_FILES_PATH		"/ambarella/calibration"
 #define	ADJ_PARAM_PATH	"/etc/idsp/adj_params"
 
-#define PRELOAD_AWB_FILE		"/tmp/awb"
-#define PRELOAD_AE_FILE		"/tmp/ae"
-
 #define AWB_TILE_NUM_COL		(24)
 #define AWB_TILE_NUM_ROW		(16)
 
 extern _mw_global_config G_mw_config;
 static line_t G_mw_ae_lines[MAX_AE_LINES_NUM];
 static pthread_t ae_control_task_id = 0;
+static pthread_t tone_curve_task_id = 0;
+extern u8 G_dynamic_tone_curve_active;
+extern int AmbaDSP_ImgLowIsoDumpCfg(amba_img_dsp_cfg_info_t CfgInfo, char *dir);
 
 /*************************** AE lines **********************************/
 
@@ -329,18 +348,25 @@ static u32 iris_index_to_fno(int index)
 
 #define LENS_FNO(index)		(iris_index_to_fno(index))
 
-inline int update_hdr_shutter_max(u32 fps, int expo_num)
+void wait_irq_count(int num)
 {
-	u32 shutter_max = 0;
+	do {
+		ioctl(G_mw_config.fd, IAV_IOC_WAIT_NEXT_FRAME, 0);
+	} while (--num > 0);
+}
+
+static inline int update_hdr_shutter_max(u32 fps, int expo_num, u16 expo_ratio)
+{
+	u64 shutter_max = 0;
 	int i;
 	const line_t *p_src = NULL;
 
 	switch (expo_num) {
 		case HDR_2X:
-			shutter_max = HDR_2X_MAX_SHUTTER(fps);
+			shutter_max = HDR_2X_MAX_SHUTTER((u64)fps, (u64)expo_ratio);
 			break;
 		case HDR_3X:
-			shutter_max = HDR_3X_MAX_SHUTTER(fps);
+			shutter_max = HDR_3X_MAX_SHUTTER((u64)fps, (u64)expo_ratio);
 			break;
 		default:
 			MW_ERROR("Not support hdr expo num[%d]\n", expo_num);
@@ -361,8 +387,9 @@ inline int update_hdr_shutter_max(u32 fps, int expo_num)
 		}
 	}
 
-	if (G_mw_config.ae_params.shutter_time_max > shutter_max)
+	if (G_mw_config.ae_params.shutter_time_max > shutter_max) {
 		G_mw_config.ae_params.shutter_time_max = shutter_max;
+	}
 
 	return 0;
 }
@@ -374,6 +401,7 @@ int get_sensor_aaa_params(_mw_global_config *pMw_info)
 	mw_sys_res *resource = NULL;
 	struct vindev_devinfo vin_info;
 	struct vindev_video_info video_info;
+	char *adj_file = NULL;
 
 	sensor = &(pMw_info->sensor);
 	resource = &(pMw_info->res);
@@ -389,7 +417,7 @@ int get_sensor_aaa_params(_mw_global_config *pMw_info)
 	video_info.info.mode = AMBA_VIDEO_MODE_CURRENT;
 	if (ioctl(pMw_info->fd, IAV_IOC_VIN_GET_VIDEOINFO, &video_info) < 0) {
 		perror("IAV_IOC_VIN_GET_VIDEOINFO");
-		return 0;
+		return -1;
 	}
 
 	if (video_info.info.width != sensor->vin_width ||
@@ -407,6 +435,7 @@ int get_sensor_aaa_params(_mw_global_config *pMw_info)
 		(video_info.info.type == AMBA_VIDEO_TYPE_RGB_RAW));
 
 	if (!sensor->is_rgb_sensor) {
+		MW_INFO("It's not RGB sensor. Not support.\n");
 		return 0;
 	}
 
@@ -416,12 +445,15 @@ int get_sensor_aaa_params(_mw_global_config *pMw_info)
 		perror("IAV_IOC_VIN_GET_AAAINFO error\n");
 		return -1;
 	}
-	get_vin_frame_rate(&vin_fps);
+	if (get_vin_frame_rate(&vin_fps) < 0) {
+		return -1;
+	}
 	sensor->default_fps = vin_fps;
 	sensor->current_fps = vin_fps;
 
 	if (resource->hdr_expo_num > HDR_1X) {
-		if (update_hdr_shutter_max(vin_fps, resource->hdr_expo_num) < 0) {
+		if (update_hdr_shutter_max(vin_fps, resource->hdr_expo_num,
+			MW_HDR_BLEND_EXPO_RATIO_MIN) < 0) {
 			MW_ERROR("update_hdr_shutter_max error \n");
 			return -1;
 		}
@@ -447,7 +479,15 @@ int get_sensor_aaa_params(_mw_global_config *pMw_info)
 		case SENSOR_OV5658:
 			sprintf(sensor->name, "ov5658");
 			break;
-
+		case SENSOR_OV2718:
+			sprintf(sensor->name, "ov2718");
+			break;
+		case SENSOR_OV2735:
+			sprintf(sensor->name, "ov2735");
+			break;
+		case SENSOR_OV2732:
+			sprintf(sensor->name, "ov2732");
+			break;
 		case SENSOR_IMX123:
 			sprintf(sensor->name, "imx123");
 			break;
@@ -460,6 +500,9 @@ int get_sensor_aaa_params(_mw_global_config *pMw_info)
 		case SENSOR_IMX178:
 			sprintf(sensor->name, "imx178");
 			break;
+		case SENSOR_IMX185:
+			sprintf(sensor->name, "imx185");
+			break;
 		case SENSOR_IMX224:
 			sprintf(sensor->name, "imx224");
 			break;
@@ -472,6 +515,12 @@ int get_sensor_aaa_params(_mw_global_config *pMw_info)
 		case SENSOR_IMX322:
 			sprintf(sensor->name, "imx322");
 			break;
+		case SENSOR_IMX326:
+			sprintf(sensor->name, "imx326");
+			break;
+		case SENSOR_IMX377:
+			sprintf(sensor->name, "imx377");
+			break;
 
 		case SENSOR_AR0141:
 			sprintf(sensor->name, "ar0141");
@@ -485,46 +534,47 @@ int get_sensor_aaa_params(_mw_global_config *pMw_info)
 		case SENSOR_AR0230:
 			sprintf(sensor->name, "ar0230");
 			break;
+		case SENSOR_AR0237:
+			sprintf(sensor->name, "ar0237");
+			break;
 		default:
 			MW_INFO("sensor is [%s]\n", vin_info.name);
 			break;
 	}
 
 	/* fix me, need match the special files and the default different bin */
-	if (strcmp(sensor->load_files.adj_file, "") == 0) {
+	adj_file = sensor->load_files.adj_file;
+	if (strcmp(adj_file, "") == 0) {
 		switch (resource->isp_pipeline) {
 			case ISP_PIPELINE_ADV_LISO:
-				sprintf(sensor->load_files.adj_file, "%s/%s_aliso_adj_param.bin",
+				sprintf(adj_file, "%s/%s_aliso_adj_param.bin",
 					ADJ_PARAM_PATH, sensor->name);
 				break;
 			case ISP_PIPELINE_MID_LISO:
 				if (resource->hdr_mode == HDR_PIPELINE_ADV) {
-					sprintf(sensor->load_files.adj_file,
-						"%s/%s_mliso_adj_param_hdr.bin",
+					sprintf(adj_file, "%s/%s_mliso_adj_param_hdr.bin",
 						ADJ_PARAM_PATH, sensor->name);
-					if (access(sensor->load_files.adj_file, 0) < 0) {
-						sprintf(sensor->load_files.adj_file,
-							"%s/%s_mliso_adj_param.bin",
+					if (access(adj_file, 0) < 0) {
+						sprintf(adj_file, "%s/%s_mliso_adj_param.bin",
 							ADJ_PARAM_PATH, sensor->name);
 						printf("NO HDR adj params for %s HDR mode, use Mid "
 							"ISO adj params instead!\n", sensor->name);
 					}
 				} else {
-					sprintf(sensor->load_files.adj_file,
-						"%s/%s_mliso_adj_param.bin",
+					sprintf(adj_file, "%s/%s_mliso_adj_param.bin",
 						ADJ_PARAM_PATH, sensor->name);
 				}
 				break;
 			case ISP_PIPELINE_LISO:
-				sprintf(sensor->load_files.adj_file, "%s/%s_liso_adj_param.bin",
+				sprintf(adj_file, "%s/%s_liso_adj_param.bin",
 					ADJ_PARAM_PATH, sensor->name);
 				break;
 			case ISP_PIPELINE_B_LISO:
-				sprintf(sensor->load_files.adj_file, "%s/%s_bliso_adj_param.bin",
+				sprintf(adj_file, "%s/%s_bliso_adj_param.bin",
 					ADJ_PARAM_PATH, sensor->name);
 				break;
 			default:
-				sprintf(sensor->load_files.adj_file, "%s/%s_liso_adj_param.bin",
+				sprintf(adj_file, "%s/%s_liso_adj_param.bin",
 					ADJ_PARAM_PATH, sensor->name);
 				break;
 		}
@@ -591,8 +641,7 @@ static inline int set_vsync_vin_framerate(u32 frame_rate)
 	int rval;
 	struct vindev_fps vsrc_fps;
 
-	ioctl(G_mw_config.fd, IAV_IOC_WAIT_NEXT_FRAME, 0);
-
+	wait_irq_count(1);
 	vsrc_fps.vsrc_id = 0;
 	vsrc_fps.fps = frame_rate;
 	if ((rval = ioctl(G_mw_config.fd, IAV_IOC_VIN_SET_FPS, &vsrc_fps)) < 0) {
@@ -935,6 +984,16 @@ static int load_default_image_param(void)
 			G_mw_config.ae_params.lens_aperture.FNO_max;
 	}
 
+	if (img_set_sharpening_strength(G_mw_config.image_params.sharpness) < 0) {
+		MW_ERROR("img_set_sharpness error!\n");
+		return -1;
+	}
+
+	if (img_set_mctf_strength(G_mw_config.enh_params.mctf_strength) < 0) {
+		MW_ERROR("img_set_mctf_strength error!\n");
+		return -1;
+	}
+
 	MW_INFO("   saturation = %d.\n", G_mw_config.image_params.saturation);
 	MW_INFO("   brightness = %d.\n", G_mw_config.image_params.brightness);
 	MW_INFO("		  hue = %d.\n", G_mw_config.image_params.hue);
@@ -949,26 +1008,32 @@ static int load_default_image_param(void)
 int reload_previous_params(void)
 {
 	u16 target_ratio[MAX_HDR_EXPOSURE_NUM];
+	u8 metering_mode[MAX_HDR_EXPOSURE_NUM];
 	awb_control_mode_t wb_mode[MAX_HDR_EXPOSURE_NUM];
 
-	//restores AE line
+	/* restores AE line */
 	if (G_mw_config.ae_params.slow_shutter_enable) {
 		G_mw_config.sensor.current_fps = G_mw_config.ae_params.current_vin_fps;
 	}
 	load_ae_exp_lines(&G_mw_config.ae_params);
-	//restore mctf strength
-	if (img_set_mctf_strength(G_mw_config.enh_params.mctf_strength) < 0) {
-		MW_ERROR("img_set_mctf_strength error!\n");
-		return -1;
-	}
-	//restore AE exposure level
+
+	/* restore AE exposure level */
 	target_ratio[0] = (u16)((G_mw_config.ae_params.ae_level[0] << 10) / 100);
 	if (img_set_ae_target_ratio(target_ratio) < 0) {
 		MW_ERROR("img_ae_set_target_ratio error\n");
 		return -1;
 	}
 
-	//restores Awb
+	/* restore AE metering mode */
+	metering_mode[0] = G_mw_config.ae_params.ae_metering_mode;
+	if (G_mw_config.res.hdr_expo_num == MIN_HDR_EXPOSURE_NUM) {
+		if (img_set_ae_meter_mode(metering_mode) < 0) {
+			MW_ERROR("img_ae_set_meter_mode error\n");
+			return -1;
+		}
+	}
+
+	/* restores Awb */
 	if (G_mw_config.awb_params.wb_mode == MW_WB_MODE_HOLD) {
 		if (img_enable_awb(0) < 0) {
 			MW_ERROR("img_enable_awb error\n");
@@ -1012,6 +1077,18 @@ int reload_previous_params(void)
 		return -1;
 	}
 
+	/* restore mctf strength */
+	if (img_set_mctf_strength(G_mw_config.enh_params.mctf_strength) < 0) {
+		MW_ERROR("img_set_mctf_strength error!\n");
+		return -1;
+	}
+
+	/* restore day_night mode */
+	if (img_set_bw_mode(G_mw_config.enh_params.dn_mode) < 0) {
+		MW_ERROR("img_set_bw_mode error.\n");
+		return -1;
+	}
+
 	MW_INFO("   saturation = %d.\n", G_mw_config.image_params.saturation);
 	MW_INFO("   brightness = %d.\n", G_mw_config.image_params.brightness);
 	MW_INFO("          hue = %d.\n", G_mw_config.image_params.hue);
@@ -1065,90 +1142,13 @@ static inline int print_ae_lines(line_t *lines,
 	return 0;
 }
 
-static int generate_normal_ae_lines(mw_ae_param *p, line_t *lines,
-	int *line_num, u16 *line_belt, int *default_line_belt)
+static void refresh_ae_lines(line_t *lines, int *line_num, u32 p_index_min, u32 p_index_max)
 {
-	int dst, src, i;
-	u32 s_max, s_min, g_max, g_min, p_index_max, p_index_min;
-	const line_t *p_src = NULL;
-	int flicker_off_shutter_time = 0;
-	int longest_possible_shutter = 0, curr_belt = 0;
-	int match_vin_shutter = 0;
-	int match_vin_belt = 0;
-	int calc_def_belt = 0;
-
+	int i = 0;
+	u32 g_min, g_max;
 	struct vindev_agc vsrc_agc;
 
-	s_max = p->shutter_time_max;
-	s_min = p->shutter_time_min;
-	g_max = p->sensor_gain_max;
-	if ((p->lens_aperture.aperture_min == APERTURE_AUTO) ||
-		(p->lens_aperture.aperture_max == APERTURE_AUTO)) {
-		p_index_max = 0;
-		p_index_min = 0;
-	} else {
-		p_index_max = iris_to_index(p->lens_aperture.aperture_min);
-		p_index_min = iris_to_index(p->lens_aperture.aperture_max);
-	}
-
-	p_src = (p->anti_flicker_mode == MW_ANTI_FLICKER_60HZ) ?
-		G_60HZ_LINES : G_50HZ_LINES;
-	flicker_off_shutter_time = (p->anti_flicker_mode == MW_ANTI_FLICKER_60HZ) ?
-		SHUTTER_1BY120_SEC : SHUTTER_1BY100_SEC;
-	dst = src = curr_belt = 0;
-
-	// create line 1 - shutter line / digital gain line
-	if (s_min < flicker_off_shutter_time) {
-		// create shutter line
-		while (s_min >= p_src[src].end.factor[MW_SHUTTER])
-			++src;
-		lines[dst] = p_src[src];
-		lines[dst].start.factor[MW_SHUTTER] = s_min;
-
-		if (s_max < flicker_off_shutter_time) {
-			lines[dst].end.factor[MW_SHUTTER] = s_max;
-			++dst;
-			lines[dst].start.factor[MW_SHUTTER] = s_max;
-			lines[dst].end.factor[MW_SHUTTER] = s_max;
-			lines[dst].end.factor[MW_DGAIN] = g_max;
-			++dst;
-			curr_belt = dst;
-			goto GENERATE_LINES_EXIT;
-		}
-		++dst;
-		++src;
-	} else {
-		// create digital gain line
-		while (s_min > p_src[src].start.factor[MW_SHUTTER])
-			++src;
-		lines[dst] = p_src[src];
-		++dst;
-		++src;
-	}
-
-	// create other lines - digital gain line
-	while (s_max >= p_src[src].start.factor[MW_SHUTTER]) {
-		if (p_src[src].start.factor[MW_SHUTTER] == SHUTTER_INVALID) {
-			break;
-		}
-		/* skip iris lines with non-iris lens */
-		if ((p_src[src].start.factor[MW_SHUTTER] <
-			p_src[src].end.factor[MW_SHUTTER]) ||
-			(p_src[src].start.factor[MW_DGAIN] !=
-			p_src[src].end.factor[MW_DGAIN]) || p_index_max) {
-			lines[dst] = p_src[src];
-			++dst;
-		}
-		++src;
-		if (src >= MAX_AE_LINES_NUM) {
-			MW_ERROR("Fatal error: AE line number exceeds MAX_AE_LINES_NUM %d",
-				MAX_AE_LINES_NUM);
-			return -1;
-		}
-	}
-	lines[dst - 1].end.factor[MW_DGAIN] = g_max;
-
-	// change min gain from sensor driver
+	/* change min gain from sensor driver */
 	get_sensor_agc_info(G_mw_config.fd, &vsrc_agc);
 	g_min = vsrc_agc.agc_min >> 24;
 	i = 0;
@@ -1160,9 +1160,10 @@ static int generate_normal_ae_lines(mw_ae_param *p, line_t *lines,
 	}
 	g_min = G_gain_table[i];
 
-	MW_INFO("---Min Gain: %d, Max Gain: %d\n", g_min, g_max);
+	MW_INFO("---Min Gain: %d\n", g_min);
+
 	i = 0;
-	while (i < dst) {
+	while (i < *line_num) {
 		if (lines[i].start.factor[MW_SHUTTER] != lines[i].end.factor[MW_SHUTTER]) {
 			/* Shutter line: change min gain both for start and end points */
 			if (lines[i].start.factor[MW_DGAIN] < g_min) {
@@ -1184,11 +1185,11 @@ static int generate_normal_ae_lines(mw_ae_param *p, line_t *lines,
 	if (p_index_min < lines[0].start.factor[MW_IRIS]) {
 		 lines[0].start.factor[MW_IRIS] = p_index_min;
 	}
-	if (p_index_max > lines[dst].end.factor[MW_IRIS]) {
-		 lines[dst].end.factor[MW_IRIS] = p_index_max;
+	if (p_index_max > lines[*line_num - 1].end.factor[MW_IRIS]) {
+		 lines[*line_num - 1].end.factor[MW_IRIS] = p_index_max;
 	}
 	i = 0;
-	while (i < dst) {
+	while (i < *line_num) {
 		if (p_index_min > lines[i].start.factor[MW_IRIS]) {
 			 lines[i].start.factor[MW_IRIS] = p_index_min;
 		}
@@ -1204,12 +1205,43 @@ static int generate_normal_ae_lines(mw_ae_param *p, line_t *lines,
 		++i;
 	}
 
-	// calculate line belt of current and default
-	curr_belt = dst;
+	/* seperate the end line,if both end gain/iris are different with start */
+	if ((lines[*line_num - 1].end.factor[MW_IRIS] !=
+		lines[*line_num - 1].start.factor[MW_IRIS]) &&
+		(lines[*line_num - 1].end.factor[MW_DGAIN] !=
+		lines[*line_num - 1].start.factor[MW_DGAIN])) {
+		/* keep the end gain = start gain */
+		g_max = lines[*line_num - 1].end.factor[MW_DGAIN];
+		lines[*line_num - 1].end.factor[MW_DGAIN] =
+			lines[*line_num - 1].start.factor[MW_DGAIN];
+
+		/* create a new lines with max gain*/
+		if (*line_num < MAX_AE_LINES_NUM) {
+			lines[*line_num]= lines[*line_num - 1];
+			/* update start_piris, and end_gain */
+			lines[*line_num].start.factor[MW_IRIS] =
+				lines[*line_num - 1].end.factor[MW_IRIS];
+			lines[*line_num].end.factor[MW_DGAIN] = g_max;
+			*line_num = *line_num + 1;
+		}
+	}
+
+	return;
+}
+
+static void update_ae_belt(mw_ae_param *p, line_t *lines, line_info *ae_belt)
+{
+	int longest_possible_shutter = 0, curr_belt = 0;
+	int match_vin_shutter = 0;
+	int match_vin_belt = 0;
+	int calc_def_belt = 0;
+
+	/* calculate line belt of current and default */
+	curr_belt = ae_belt->line_num;
 	while (1) {
 		longest_possible_shutter = lines[curr_belt - 1].end.factor[MW_SHUTTER];
 		if (longest_possible_shutter <= G_mw_config.sensor.default_fps) {
-			*default_line_belt = curr_belt;
+			ae_belt->belt_def = curr_belt;
 		}
 		if (p->slow_shutter_enable) {
 			if (longest_possible_shutter <= G_mw_config.sensor.current_fps) {
@@ -1221,7 +1253,8 @@ static int generate_normal_ae_lines(mw_ae_param *p, line_t *lines,
 			}
 		} else {
 			if (longest_possible_shutter <= G_mw_config.sensor.default_fps) {
-				lines[curr_belt - 1].end.factor[MW_DGAIN] = g_max;
+				lines[curr_belt - 1].end.factor[MW_DGAIN] =
+					lines[ae_belt->line_num - 1].end.factor[MW_DGAIN];
 				MW_INFO("\tSlow shutter is disabled, restore curr_belt [%d] to"
 					" default frame rate [%d].\n",
 					curr_belt, G_mw_config.sensor.default_fps);
@@ -1234,65 +1267,164 @@ static int generate_normal_ae_lines(mw_ae_param *p, line_t *lines,
 		for (match_vin_belt = curr_belt; match_vin_belt > 1; match_vin_belt--) {
 			match_vin_shutter = lines[match_vin_belt - 1].end.factor[MW_SHUTTER];
 			if (match_vin_shutter <= G_mw_config.sensor.default_fps) {
-				*default_line_belt = match_vin_belt;
+				ae_belt->belt_def = match_vin_belt;
 				break;
 			}
 		}
 		if (match_vin_belt <= 1) {
-			*default_line_belt = 1;
+			ae_belt->belt_def = 1;
 		}
-		calc_def_belt = 0;
 	}
+
+	ae_belt->belt_cur = curr_belt;
+
 	MW_INFO("\tcurr_belt [%d] def_belt [%d] == VIN [%d fps]\n",
-		curr_belt, *default_line_belt, G_mw_config.sensor.current_fps);
+		curr_belt, ae_belt->belt_def, G_mw_config.sensor.current_fps);
+
+	return;
+}
+
+static int generate_normal_ae_lines(mw_ae_param *p, line_t *lines,
+	line_info *ae_belt)
+{
+	int dst, src;
+	u32 s_max, s_min, g_max, p_index_max, p_index_min;
+	const line_t *p_src = NULL;
+	int flicker_off_shutter_time = 0;
+
+	s_max = p->shutter_time_max;
+	s_min = p->shutter_time_min;
+	g_max = p->sensor_gain_max;
+	if ((p->lens_aperture.aperture_min == APERTURE_AUTO) ||
+		(p->lens_aperture.aperture_max == APERTURE_AUTO)) {
+		p_index_max = 0;
+		p_index_min = 0;
+	} else {
+		p_index_max = iris_to_index(p->lens_aperture.aperture_min);
+		p_index_min = iris_to_index(p->lens_aperture.aperture_max);
+	}
+
+	p_src = (p->anti_flicker_mode == MW_ANTI_FLICKER_60HZ) ?
+		G_60HZ_LINES : G_50HZ_LINES;
+	flicker_off_shutter_time = (p->anti_flicker_mode == MW_ANTI_FLICKER_60HZ) ?
+		SHUTTER_1BY120_SEC : SHUTTER_1BY100_SEC;
+	dst = src = 0;
+
+	// create line 1 - shutter line / digital gain line
+	if (s_min < flicker_off_shutter_time) {
+		// create shutter line
+		while (s_min >= p_src[src].end.factor[MW_SHUTTER])
+			++src;
+		lines[dst] = p_src[src];
+		lines[dst].start.factor[MW_SHUTTER] = s_min;
+
+		if (s_max < flicker_off_shutter_time) {
+			lines[dst].end.factor[MW_SHUTTER] = s_max;
+			++dst;
+			lines[dst].start.factor[MW_SHUTTER] = s_max;
+			lines[dst].end.factor[MW_SHUTTER] = s_max;
+			lines[dst].end.factor[MW_DGAIN] = g_max;
+			++dst;
+			goto GENERATE_LINES_EXIT;
+		}
+		++dst;
+		++src;
+	} else {
+		// create digital gain line
+		while (s_min > p_src[src].start.factor[MW_SHUTTER])
+			++src;
+		lines[dst] = p_src[src];
+		++dst;
+		++src;
+	}
+
+	// create other lines - digital gain line
+	while (s_max >= p_src[src].start.factor[MW_SHUTTER]) {
+		if (p_src[src].start.factor[MW_SHUTTER] == SHUTTER_INVALID) {
+			break;
+		}
+		/* skip iris lines with non-iris lens */
+		if ((p_src[src].start.factor[MW_SHUTTER] <
+			p_src[src].end.factor[MW_SHUTTER]) ||
+			(p_src[src].start.factor[MW_DGAIN] !=
+			p_src[src].end.factor[MW_DGAIN]) || p_index_max) {
+			lines[dst] = p_src[src];
+			++dst;
+		}
+		++src;
+		if (src >= MAX_AE_LINES_NUM) {
+			MW_ERROR("Fatal error: AE line number exceeds MAX_AE_LINES_NUM %d",
+				MAX_AE_LINES_NUM);
+			return -1;
+		}
+	}
+	lines[dst - 1].end.factor[MW_DGAIN] = g_max;
 
 GENERATE_LINES_EXIT:
-	*line_num = dst;
-	*line_belt = curr_belt;
 
-	print_ae_lines(lines, dst, curr_belt, 1);
+	refresh_ae_lines(lines, &dst, p_index_min, p_index_max);
+	ae_belt->line_num = dst;
+	update_ae_belt(p, lines, ae_belt);
+	print_ae_lines(lines, dst, ae_belt->belt_cur, 1);
 	return 0;
 }
 
 static inline int generate_manual_shutter_lines(mw_ae_param *p,
-	line_t *lines, int *line_num, u16 *line_belt, int *default_line_belt)
+	line_t *lines, line_info *ae_belt)
 {
 	int total_lines = 0;
+
 	lines[total_lines].start.factor[MW_SHUTTER] = p->shutter_time_max;
 	lines[total_lines].start.factor[MW_DGAIN] = 0;
-	lines[total_lines].start.factor[MW_IRIS] = 0;
 	lines[total_lines].end.factor[MW_SHUTTER] = p->shutter_time_max;
 	lines[total_lines].end.factor[MW_DGAIN] = p->sensor_gain_max;
-	lines[total_lines].end.factor[MW_IRIS] = 0;
+
+	if ((p->lens_aperture.aperture_min == APERTURE_AUTO) ||
+		(p->lens_aperture.aperture_max == APERTURE_AUTO)) {
+		lines[total_lines].start.factor[MW_IRIS] = 0;
+		lines[total_lines].end.factor[MW_IRIS] = 0;
+	} else {
+		lines[total_lines].start.factor[MW_IRIS] =
+			iris_to_index(p->lens_aperture.aperture_max);
+		lines[total_lines].end.factor[MW_IRIS] =
+			iris_to_index(p->lens_aperture.aperture_min);
+	}
+
 	++total_lines;
-	*line_num = total_lines;
-	*line_belt = total_lines;
-	*default_line_belt = total_lines;
+
+	refresh_ae_lines(lines, &total_lines, lines[0].start.factor[MW_IRIS],
+		lines[0].end.factor[MW_IRIS]);
+
+	ae_belt->line_num = total_lines;
+	ae_belt->belt_cur = total_lines;
+	ae_belt->belt_def = total_lines;
 
 	print_ae_lines(lines, total_lines, total_lines, 1);
 	return 0;
 }
 
 static int generate_ae_lines(mw_ae_param *p,
-	line_t *lines, int *line_num, u16 *line_belt, int *default_line_belt)
+	line_t *lines, line_info *ae_belt)
 {
 	int retv = 0;
 
 	if (p->shutter_time_max != p->shutter_time_min) {
-		retv = generate_normal_ae_lines(p, lines, line_num, line_belt, default_line_belt);
+		retv = generate_normal_ae_lines(p, lines, ae_belt);
 	} else {
-		retv = generate_manual_shutter_lines(p, lines, line_num, line_belt, default_line_belt);
+		retv = generate_manual_shutter_lines(p, lines, ae_belt);
 	}
 
 	return retv;
 }
 
-static int load_ae_lines(line_t *line, u16 line_num, u16 line_belt, int default_line_belt)
+static int load_ae_lines(line_t *line, line_info *ae_belt)
 {
 	int i;
 	line_t img_ae_lines[MAX_AE_LINES_NUM * MAX_HDR_EXPOSURE_NUM];
 	u16 line_num_expo[MAX_HDR_EXPOSURE_NUM];
 	u16 line_belt_expo[MAX_HDR_EXPOSURE_NUM];
+	u8 ae_stable;
+	u16 line_num = ae_belt->line_num;
 
 	memcpy(img_ae_lines, line, sizeof(line_t) * line_num);
 	//transfer q9 format to shutter index format
@@ -1304,7 +1436,7 @@ static int load_ae_lines(line_t *line, u16 line_num, u16 line_belt, int default_
 	}
 
 	line_num_expo[0] = line_num;
-	line_belt_expo[0] = line_belt;
+	line_belt_expo[0] = ae_belt->belt_cur;
 
 	if (G_mw_config.res.hdr_expo_num >= HDR_2X) {
 		if (G_mw_config.ae_params.anti_flicker_mode == MW_ANTI_FLICKER_60HZ) {
@@ -1338,19 +1470,30 @@ static int load_ae_lines(line_t *line, u16 line_num, u16 line_belt, int default_
 	if (img_format_ae_line(G_mw_config.fd, img_ae_lines, line_num,
 		G_mw_config.sensor.vin_aaa_info.agc_step) < 0) {
 		MW_ERROR("[img_ae_load_exp_line error] : line_num [%d] line_belt [%d].\n",
-			line_num, line_belt);
+			line_num, ae_belt->belt_cur);
 		return -1;
 	}
 
+	while (G_mw_config.sensor.lens_id != LENS_CMOUNT_ID) {
+		img_get_ae_stable(&ae_stable);
+		MW_DEBUG("Wait AE stable!\n");
+		if (ae_stable != 0) {
+			break;
+		}
+		wait_irq_count(1);
+	}
+
 	if (img_set_ae_exp_lines(img_ae_lines, line_num_expo, line_belt_expo) < 0) {
 		MW_ERROR("[img_set_ae_exp_lines error] : line_num [%d] line_belt [%d].\n",
-			line_num, line_belt);
+			line_num, ae_belt->belt_cur);
 		return -1;
 	}
-	ioctl(G_mw_config.fd, IAV_IOC_WAIT_NEXT_FRAME);//Wait two VIN frames to make sure AE lines becomes effective in image kernel
-	ioctl(G_mw_config.fd, IAV_IOC_WAIT_NEXT_FRAME);
-	G_mw_config.cur_status.ae_belt.line_num = line_num;
-	G_mw_config.cur_status.ae_belt.belt_def = default_line_belt;
+
+	wait_irq_count(2);
+
+	G_mw_config.cur_status.ae_belt.line_num = line_num_expo[0];
+	G_mw_config.cur_status.ae_belt.belt_def = ae_belt->belt_def;
+	G_mw_config.cur_status.ae_belt.belt_cur = ae_belt->belt_cur;
 	memcpy(G_mw_ae_lines, line, sizeof(line_t) * line_num);
 	pthread_mutex_unlock(&G_mw_config.slow_shutter_lock);
 
@@ -1392,7 +1535,7 @@ int check_iav_work(void)
 	return 0;
 }
 
-inline int get_iav_cfg(_mw_global_config *mw_info)
+static inline int get_iav_cfg(_mw_global_config *mw_info)
 {
 	struct iav_system_resource system_resource;
 	struct iav_srcbuf_setup srcbuf_setup;
@@ -1461,11 +1604,11 @@ inline int get_shutter_time(u32 *pShutter_time)
 
 int load_ae_exp_lines(mw_ae_param *ae)
 {
-	u16 ae_line_belt = 0;
-	int default_line_belt = 0;
-	int ae_lines_num;
 	line_t ae_lines[MAX_AE_LINES_NUM];
+	line_info ae_belt;
+
 	memset(ae_lines, 0, sizeof(ae_lines));
+	memset(&ae_belt, 0, sizeof(line_info));
 
 	if (ae->shutter_time_max < ae->shutter_time_min) {
 		MW_INFO("shutter limit max [%d] is less than shutter min [%d]. Tie them to shutter min\n",
@@ -1473,15 +1616,14 @@ int load_ae_exp_lines(mw_ae_param *ae)
 		ae->shutter_time_max = ae->shutter_time_min;
 	}
 
-	if (generate_ae_lines(ae, ae_lines,
-		&ae_lines_num, &ae_line_belt, &default_line_belt) < 0) {
+	if (generate_ae_lines(ae, ae_lines, &ae_belt) < 0) {
 		MW_ERROR("generate_ae_lines error\n");
 		return -1;
 	}
 
-	if (load_ae_lines(ae_lines, ae_lines_num, ae_line_belt, default_line_belt) < 0) {
+	if (load_ae_lines(ae_lines, &ae_belt) < 0) {
 		MW_MSG("load_ae_lines error! line_num [%d], line_belt [%d], default_line_belt [%d]\n",
-			ae_lines_num, ae_line_belt, default_line_belt);
+			ae_belt.line_num, ae_belt.belt_cur, ae_belt.belt_def);
 		return -1;
 	}
 
@@ -1510,6 +1652,7 @@ int set_ae_exposure_lines(mw_ae_line *lines, u32 num)
 	int i, curr_belt;
 	int default_line_belt = 0;
 	line_t ae_lines[MAX_AE_LINES_NUM];
+	line_info ae_belt;
 
 	for (i = 0; i < num - 1; ++i) {
 		if (lines[i+1].start.factor[MW_SHUTTER] == SHUTTER_INVALID) {
@@ -1541,9 +1684,14 @@ int set_ae_exposure_lines(mw_ae_line *lines, u32 num)
 	}
 	default_line_belt = curr_belt;
 	MW_DEBUG("vin [%d]\n", G_mw_config.sensor.current_fps);
+
+	ae_belt.line_num = i;
+	ae_belt.belt_cur = curr_belt;
+	ae_belt.belt_def = default_line_belt;
+
 	print_ae_lines(ae_lines, i, curr_belt, 1);
 
-	if (load_ae_lines(ae_lines, i, curr_belt, default_line_belt) < 0) {
+	if (load_ae_lines(ae_lines, &ae_belt) < 0) {
 		MW_MSG("load_ae_lines error! line_num [%d], line_belt [%d], default_line_belt [%d]\n",
 			i, curr_belt, default_line_belt);
 		return -1;
@@ -1577,7 +1725,7 @@ int set_ae_switch_points(mw_ae_point *points, u32 num)
 		switch_point->factor[MW_DGAIN] = points[i].factor[MW_DGAIN];
 	}
 
-	if (load_ae_lines(G_mw_ae_lines, ae_belt->line_num, ae_belt->belt_cur, ae_belt->belt_def) < 0) {
+	if (load_ae_lines(G_mw_ae_lines, ae_belt) < 0) {
 		MW_MSG("load_ae_lines error! line_num [%d], line_belt_cur [%d], line_belt_def [%d]\n",
 			ae_belt->line_num, ae_belt->belt_cur, ae_belt->belt_def);
 		return -1;
@@ -1624,10 +1772,25 @@ static void slow_shutter_control(int ae_cursor)
 					target_frame_time, G_mw_config.cur_status.ae_belt.belt_cur);
 				transition_counter = 0;
 			}
+		} else {
+			if ((ae_belt->belt_cur > ae_belt->belt_def) &&
+				(ae_cursor <= ae_belt->line_num)) {
+				++transition_counter;
+				if (transition_counter == HISTORY_LENGTH) {
+					img_set_ae_loosen_belt(&ae_belt->belt_cur);
+					MW_INFO("[CHANGE Belt]= def [%d], curr [%d], ae_cursor [%d].\n",
+						ae_belt->belt_def, ae_belt->belt_cur, ae_cursor);
+					transition_counter = 0;
+				}
+			}
 		}
 	} else {
 		if (G_mw_config.sensor.current_fps > G_mw_config.sensor.default_fps) {
-			set_vsync_vin_framerate(G_mw_config.sensor.default_fps);
+			if (set_vsync_vin_framerate(G_mw_config.sensor.default_fps) < 0) {
+				MW_ERROR("set_vsync_vin_framerate failed!\n");
+			} else {
+				G_mw_config.sensor.current_fps = G_mw_config.sensor.default_fps;
+			}
 			img_set_ae_loosen_belt(&ae_belt->belt_def);
 		}
 	}
@@ -1652,7 +1815,7 @@ void ae_control_task(void *arg)
 	}
 
 	while (G_mw_config.init_params.slow_shutter_active) {
-		ioctl(G_mw_config.fd, IAV_IOC_WAIT_NEXT_FRAME, 0);
+		wait_irq_count(1);
 
 		img_get_ae_cursor(&ae_cursor);
 
@@ -1704,6 +1867,19 @@ int create_ae_control_task(void)
 		MW_INFO("Create thread <ae_control_task> successful !\n");
 	}
 
+	if(G_mw_config.res.hdr_expo_num == HDR_2X) {
+		G_dynamic_tone_curve_active = 1;
+		if (tone_curve_task_id == 0) {
+			if (pthread_create(&tone_curve_task_id, NULL,
+				(void *)tone_curve_task, NULL) != 0) {
+				MW_ERROR("Failed. Can't create thread <%s> !\n",
+					MW_THREAD_NAME_TONE_CURVE_CTRL);
+			}
+			pthread_setname_np(tone_curve_task_id, MW_THREAD_NAME_TONE_CURVE_CTRL);
+
+			MW_INFO("Create thread <tone_curve_task> successful !\n");
+		}
+	}
 	return 0;
 }
 
@@ -1719,9 +1895,20 @@ int destroy_ae_control_task(void)
 		}
 		MW_INFO("Destroy thread <ae_control_task> successful !\n");
 	}
-
 	ae_control_task_id = 0;
 
+	/* destroy tone curve thread */
+	G_dynamic_tone_curve_active = 0;
+	if (tone_curve_task_id != 0) {
+		if (pthread_join(tone_curve_task_id, NULL) != 0) {
+			MW_ERROR("Failed. Can't destroy thread <%s> !\n",
+				MW_THREAD_NAME_TONE_CURVE_CTRL);
+			perror("pthread_join in destory tone curve thread");
+		}
+		MW_INFO("Destroy thread <tone_curve_task> successful !\n");
+	}
+	tone_curve_task_id = 0;
+
 	return 0;
 }
 
@@ -1818,7 +2005,8 @@ static inline int load_calibration_file(void)
 	return 0;
 }
 
-static int save_content_file(const char* filename, const char* content)
+static int save_content_file(const char* filename, const void* content,
+	const int size)
 {
 	int fd = -1;
 	int ret = -1;
@@ -1829,13 +2017,36 @@ static int save_content_file(const char* filename, const char* content)
 		return ret;
 	}
 
-	ret = write(fd, content, strlen(content));
+	ret = write(fd, content, size);
+	if (ret != size) {
+		MW_ERROR("Write %s failed!\n", filename);
+		ret = -1;
+	}
 	close(fd);
 	fd = -1;
 
 	return ret;
 }
 
+static int load_content_file(const char *filename, void *dest, const int size)
+{
+	int fd = -1;
+	int ret = -1;
+
+	fd = open(filename, O_RDONLY | O_NONBLOCK);
+	if (fd >= 0) {
+		ret = read(fd, dest, size);
+		if (ret != size) {
+			MW_ERROR("Read %s failed!\n", filename);
+			ret = -1;
+		}
+		close(fd);
+		fd = -1;
+	}
+
+	return ret;
+}
+
 static void save_awb_ae_config(void)
 {
 	int ret = -1;
@@ -1846,23 +2057,54 @@ static void save_awb_ae_config(void)
 	amba_img_dsp_wb_gain_t preload_wb_gain = {0, 0, 0, 0, 0};
 	amba_img_dsp_mode_cfg_t dsp_mode_cfg;
 
-	preload_agc = img_get_sensor_agc();
-	preload_shutter = img_get_sensor_shutter();
+	hdr_sensor_gp_t sht_agc_gp;
+	amba_img_dsp_amp_linearization_t amp_linearizatoin;
 
 	memset(&dsp_mode_cfg, 0, sizeof(dsp_mode_cfg));
 	if (get_dsp_mode_cfg(&dsp_mode_cfg) < 0) {
 		return;
 	}
 
-	amba_img_dsp_get_wb_gain(&dsp_mode_cfg, &preload_wb_gain);
-	preload_dgain = preload_wb_gain.AeGain*preload_wb_gain.GlobalDGain>>12;
+	if (amba_img_dsp_get_wb_gain(&dsp_mode_cfg, &preload_wb_gain) < 0) {
+		MW_ERROR("amba_img_dsp_get_wb_gain \n");
+		return;
+	}
+	preload_dgain = (preload_wb_gain.AeGain *
+		preload_wb_gain.GlobalDGain) >> 12;
+
+
+	if (G_mw_config.res.hdr_expo_num == HDR_1X) {
+		preload_agc = img_get_sensor_agc();
+		preload_shutter = img_get_sensor_shutter();
+	} else {
+		if (img_get_hdr_sensor_shutter_group(G_mw_config.fd,
+			&sht_agc_gp.shutter_gp) < 0) {
+			MW_ERROR("img_get_hdr_sensor_shutter_group \n");
+			return;
+		}
+		if (img_get_hdr_sensor_agc_group(G_mw_config.fd,
+			&sht_agc_gp.agc_gp) < 0) {
+			MW_ERROR("img_get_hdr_sensor_shutter_group \n");
+			return;
+		}
+		preload_shutter = sht_agc_gp.shutter_gp.shutter_info[0];
+		preload_agc = sht_agc_gp.agc_gp.gain_info[0];
+
+		if (amba_img_dsp_get_amp_linearization(&dsp_mode_cfg,
+			&amp_linearizatoin) < 0) {
+			MW_ERROR("amba_img_dsp_get_amp_linearization \n");
+			return;
+		}
+		preload_wb_gain.GainR = amp_linearizatoin.amp_linear[0].mul_r;
+		preload_wb_gain.GainB = amp_linearizatoin.amp_linear[0].mul_b;
+	}
 
 	/* AWB */
 	memset(aaa_content, 0, sizeof(aaa_content));
 	snprintf(aaa_content, sizeof(aaa_content), "%u,%d\n",
 		preload_wb_gain.GainR, preload_wb_gain.GainB);
 
-	ret = save_content_file(PRELOAD_AWB_FILE, aaa_content);
+	ret = save_content_file(PRELOAD_AWB_FILE, aaa_content, strlen(aaa_content));
 	if (ret > 0) {
 		MW_DEBUG("Save AWB: r_gain=%d, b_gain=%d\n",
 			preload_wb_gain.GainR, preload_wb_gain.GainB);
@@ -1872,31 +2114,105 @@ static void save_awb_ae_config(void)
 	memset(aaa_content, 0, sizeof(aaa_content));
 	snprintf(aaa_content, sizeof(aaa_content), "%u,%d,%d\n",
 		preload_dgain, preload_shutter, preload_agc);
-	save_content_file(PRELOAD_AE_FILE, aaa_content);
+	save_content_file(PRELOAD_AE_FILE, aaa_content, strlen(aaa_content));
 	if (ret > 0) {
 		MW_DEBUG("Save AE: d_gain=%d, shutter=%d, agc=%d\n",
 			preload_dgain, preload_shutter, preload_agc);
 	}
 }
 
-static void preload_awb_ae_config(void)
+static int preload_awb_ae_mem(void)
 {
-	int fd_ae = -1;
-	int fd_awb = -1;
+	u32 dsp_size = 0;
+	u8 *dsp_mem = NULL;
 	int preload_agc = 0;
 	int preload_shutter = 0;
 	int preload_dgain = 0;
 	int preload_iris_index = 0;
+	int preload_night_mode = 0;
+	u8 preload_shutter_max = 0;
+	u8 preload_agc_max = 0;
 	amba_img_dsp_wb_gain_t preload_wb_gain = {0, 0, 0, 0, 0};
 	wb_gain_t pre_wb_gain = {0, 0, 0};
+	struct iav_fb_hdr *fb_hdr = NULL;
+	struct iav_querybuf querybuf;
+
+	querybuf.buf = IAV_BUFFER_FB_DATA;
+	if (ioctl(G_mw_config.fd, IAV_IOC_QUERY_BUF, &querybuf) < 0) {
+		perror("IAV_IOC_QUERY_BUF");
+		return -1;
+	}
+
+	dsp_size = querybuf.length;
+	if (!dsp_size) {
+		return -1;
+	}
+
+	dsp_mem = mmap(NULL, dsp_size, PROT_READ, MAP_SHARED, G_mw_config.fd, querybuf.offset);
+	if (dsp_mem == MAP_FAILED) {
+		perror("mmap FB failed");
+		return -1;
+	}
+
+	if (dsp_mem) {
+		fb_hdr = (struct iav_fb_hdr *) dsp_mem;
+		preload_wb_gain.GainR = fb_hdr->pre_aeb.r_gain;
+		preload_wb_gain.GainB = fb_hdr->pre_aeb.b_gain;
+		preload_dgain = fb_hdr->pre_aeb.d_gain;
+		preload_shutter = fb_hdr->pre_aeb.shutter;
+		preload_agc = fb_hdr->pre_aeb.agc;
+		preload_shutter_max = fb_hdr->shutter_max;
+		preload_agc_max = fb_hdr->agc_max;
+		preload_night_mode = fb_hdr->night_mode;
+
+		MW_DEBUG("Preload AWB in memory: r_gain=%d, b_gain=%d\n",
+			preload_wb_gain.GainR, preload_wb_gain.GainB);
+		MW_DEBUG("Preload AE in memory: d_gain=%d, shutter=%d, agc=%d\n",
+			preload_dgain, preload_shutter, preload_agc);
+		MW_DEBUG("Preload Max info: shutter_max=%d, agc_max=%d\n",
+			preload_shutter_max, preload_agc_max);
+		MW_DEBUG("Preload Night mode: night_mode=%d\n", preload_night_mode);
 
+		/* Just for Channel0 in fastboot. */
+		G_mw_config.ae_params.shutter_time_max = SHT_TIME(preload_shutter_max);
+		G_mw_config.ae_params.sensor_gain_max = preload_agc_max;
+		G_mw_config.ae_params.ae_metering_mode = MW_AE_AVERAGE_METERING;
+
+		G_mw_config.enh_params.dn_mode = fb_hdr->night_mode;
+		adj_set_bw_mode(fb_hdr->night_mode);
+
+		pre_wb_gain.r_gain = preload_wb_gain.GainR >> 2;
+		pre_wb_gain.b_gain = preload_wb_gain.GainB >> 2;
+		pre_wb_gain.g_gain = 1024;
+		awb_flow_pre_config(&pre_wb_gain);
+		ae_flow_pre_config(preload_agc, preload_shutter, preload_dgain,
+			preload_iris_index);
+	}
+
+	if (dsp_mem) {
+		munmap(dsp_mem, dsp_size);
+		dsp_mem = NULL;
+	}
+
+	return 0;
+}
+
+static void preload_awb_config(void)
+{
+	int fd_awb = -1;
+	amba_img_dsp_wb_gain_t preload_wb_gain = {0, 0, 0, 0, 0};
+	wb_gain_t pre_wb_gain = {0, 0, 0};
 	char content[32];
 	char *content_c = NULL;
 
 	fd_awb = open(PRELOAD_AWB_FILE, O_RDONLY | O_NONBLOCK);
 	if (fd_awb >= 0) {
 		memset(content, 0, sizeof(content));
-		read(fd_awb, content, sizeof(content));
+		if (read(fd_awb, content, sizeof(content)) < 0) {
+			printf("read error.\n");
+			close(fd_awb);
+			return;
+		}
 		close(fd_awb);
 		fd_awb = -1;
 
@@ -1915,14 +2231,28 @@ static void preload_awb_ae_config(void)
 		pre_wb_gain.r_gain = preload_wb_gain.GainR >> 2;
 		pre_wb_gain.b_gain = preload_wb_gain.GainB >> 2;
 		pre_wb_gain.g_gain = 1024;
-		adj_pre_config();
 		awb_flow_pre_config(&pre_wb_gain);
 	}
+}
+
+static void preload_ae_config(void)
+{
+	int fd_ae = -1;
+	int preload_agc = 0;
+	int preload_shutter = 0;
+	int preload_dgain = 0;
+	int preload_iris_index = 0;
+	char content[32];
+	char *content_c = NULL;
 
 	fd_ae = open(PRELOAD_AE_FILE, O_RDONLY | O_NONBLOCK);
 	if (fd_ae >= 0) {
 		memset(content, 0, sizeof(content));
-		read(fd_ae, content, sizeof(content));
+		if (read(fd_ae, content, sizeof(content)) < 0) {
+			printf("read error.\n");
+			close(fd_ae);
+			return;
+		}
 		close(fd_ae);
 		fd_ae = -1;
 
@@ -1946,6 +2276,99 @@ static void preload_awb_ae_config(void)
 	}
 }
 
+static void save_adj_config(void)
+{
+	amba_img_dsp_tone_curve_t tone_curve;
+	amba_img_dsp_rgb_to_yuv_t rgb2yuv_matrix;
+	amba_img_dsp_local_exposure_t local_exposure;
+	amba_img_dsp_mode_cfg_t dsp_mode_cfg;
+
+	memset(&dsp_mode_cfg, 0, sizeof(dsp_mode_cfg));
+	if (get_dsp_mode_cfg(&dsp_mode_cfg) < 0) {
+		return;
+	}
+
+	if (amba_img_dsp_get_tone_curve(&dsp_mode_cfg, &tone_curve) < 0) {
+		MW_ERROR("Get tone curve failed!\n");
+		return;
+	}
+	if (amba_img_dsp_get_rgb_to_yuv_matrix(&dsp_mode_cfg, &rgb2yuv_matrix) < 0) {
+		MW_ERROR("Get rgb2yuv matrix failed!\n");
+		return;
+	}
+	if (amba_img_dsp_get_local_exposure(&dsp_mode_cfg, &local_exposure) < 0) {
+		MW_ERROR("Get local exposure failed!\n");
+		return;
+	}
+
+	if (save_content_file(PRELOAD_TONE_CURVE, &tone_curve,
+		sizeof(tone_curve)) < 0) {
+		return;
+	}
+	if (save_content_file(PRELOAD_RGB2YUV_MAT, &rgb2yuv_matrix,
+		sizeof(rgb2yuv_matrix)) < 0) {
+		return;
+	}
+	if (save_content_file(PRELOAD_LOCAL_EXPO, &local_exposure,
+		sizeof(local_exposure)) < 0) {
+		return;
+	}
+
+	return;
+}
+
+static int preload_adj_config(void)
+{
+	adj_pre_config_t adj_pre_cfg;
+
+	memset(&adj_pre_cfg, 0, sizeof(adj_pre_cfg));
+	if (load_content_file(PRELOAD_TONE_CURVE, &adj_pre_cfg.tone_curve,
+		sizeof(amba_img_dsp_tone_curve_t)) < 0) {
+		return -1;
+	}
+	if (load_content_file(PRELOAD_RGB2YUV_MAT, &adj_pre_cfg.r2y,
+		sizeof(amba_img_dsp_rgb_to_yuv_t)) < 0) {
+		return -1;
+	}
+	if (load_content_file(PRELOAD_LOCAL_EXPO, &adj_pre_cfg.le,
+		sizeof(amba_img_dsp_local_exposure_t)) < 0) {
+		return -1;
+	}
+
+	adj_pre_config_ex(&adj_pre_cfg);
+
+	return 0;
+}
+
+static struct aaa_statistics_ex af_eng_cof = {
+	0,					// af_horizontal_filter1_mode;
+	0,					// af_horizontal_filter1_stage1_enb;
+	1,					// af_horizontal_filter1_stage2_enb;
+	0,					// af_horizontal_filter1_stage3_enb;
+	{200, 0, 0, 0, -55, 0, 0},		// af_horizontal_filter1_gain[7];
+	{6, 0, 0, 0},		// af_horizontal_filter1_shift[4];
+	0,					// af_horizontal_filter1_bias_off;
+	0,					// af_horizontal_filter1_thresh;
+	0,					// af_vertical_filter1_thresh;
+	8,					// af_tile_fv1_horizontal_shift;
+	8,					// af_tile_fv1_vertical_shift;
+	168,				// af_tile_fv1_horizontal_weight;
+	87,					// af_tile_fv1_vertical_weight;
+	0,					// af_horizontal_filter2_mode;
+	1,					// af_horizontal_filter2_stage1_enb;
+	1,					// af_horizontal_filter2_stage2_enb;
+	1,					// af_horizontal_filter2_stage3_enb;
+	{188, 467, -235, 375, -184, 276, -206},		// af_horizontal_filter2_gain[7];
+	{7, 2, 2, 0},		// af_horizontal_filter2_shift[4];
+	0,					// af_horizontal_filter2_bias_off;
+	0,					// af_horizontal_filter2_thresh;
+	0,					// af_vertical_filter2_thresh;
+	8,					// af_tile_fv2_horizontal_shift;
+	8,					// af_tile_fv2_vertical_shift;
+	123,				// af_tile_fv2_horizontal_weight;
+	132					// af_tile_fv2_vertical_weight;
+};
+
 int do_prepare_aaa(void)
 {
 	img_config_info_t img_config;
@@ -1979,13 +2402,21 @@ int do_prepare_aaa(void)
 	img_config.raw_resolution = G_mw_config.sensor.raw_resolution;
 
 	if (G_mw_config.sensor.is_rgb_sensor) {
-
 		vin_aaa_info = &G_mw_config.sensor.vin_aaa_info;
 		img_config.raw_bayer = vin_aaa_info->bayer_pattern;
 
-		/* Preload 3A param from /tmp when start process, Just support LISO now */
-		if (img_config.isp_pipeline == ISP_PIPELINE_LISO) {
-			preload_awb_ae_config();
+		/* Preload 3A param from /tmp when start process. */
+		if (img_config.isp_pipeline == ISP_PIPELINE_MID_LISO ||
+			img_config.isp_pipeline == ISP_PIPELINE_ADV_LISO) {
+			if (preload_awb_ae_mem() < 0) {
+				preload_awb_config();
+				if (G_mw_config.sensor.lens_id == LENS_CMOUNT_ID) {
+					preload_ae_config();
+				} else {
+					MW_INFO("It's not CMOUNT lens, skip AE preload.\n");
+				}
+			}
+			preload_adj_config();
 		}
 
 		if (vin_aaa_info->dual_gain_mode) {
@@ -2047,6 +2478,14 @@ int do_prepare_aaa(void)
 		MW_ERROR("img_prepare_isp fail\n");
 		return -1;
 	}
+
+	amba_img_dsp_mode_cfg_t dsp_mode_cfg;
+	memset(&dsp_mode_cfg, 0, sizeof(dsp_mode_cfg));
+	if (get_dsp_mode_cfg(&dsp_mode_cfg) < 0) {
+		return -1;
+	}
+	amba_img_dsp_set_af_statistics_ex(G_mw_config.fd, &dsp_mode_cfg, &af_eng_cof, 1);
+
 	return 0;
 }
 
@@ -2076,6 +2515,9 @@ int do_start_aaa(void)
 		return -1;
 	}
 
+	/* Delay one frame to correct 3A for the first frame. */
+	wait_irq_count(1);
+
 	if (load_calibration_file() < 0) {
 		MW_ERROR("load_calibration_file error!\n");
 		return -1;
@@ -2112,6 +2554,48 @@ int do_start_aaa(void)
 	return 0;
 }
 
+static int auto_dump_img_cfg(void)
+{
+	char liso_file[128];
+
+	amba_img_dsp_mode_cfg_t ik_mode = {0};
+	ik_mode.AlgoMode = AMBA_DSP_IMG_ALGO_MODE_LISO;
+	ik_mode.BatchId = 0xff;
+
+	AMBA_DSP_IMG_DEBUG_MODE_s debug = {0};
+	debug.Step = 0;
+	debug.Mode = 0;
+	amba_img_dsp_set_debug_mode(&ik_mode, &debug);
+
+	/* Fix me, we need remove usleep */
+	usleep(33 * 1000);
+	static amba_img_dsp_cfg_info_t CfgInfo;
+	CfgInfo.Pipe = AMBA_DSP_IMG_PIPE_VIDEO;
+	CfgInfo.CfgId =ik_mode.ConfigId;
+	AmbaDSP_ImgLowIsoDumpCfg(CfgInfo, IDSP_LISO_DUMP_DIR);
+
+	amba_img_dsp_cfg_status_t CfgStatus;
+	amba_img_dsp_get_cfg_status(&CfgInfo, &CfgStatus);
+
+	sprintf(liso_file, "%s/%s", IDSP_LISO_DUMP_DIR, IDSP_LISO_DUMP_FILE);
+	int fd = -1;
+	fd = open(liso_file, O_WRONLY | O_CREAT, 0666);
+
+	if (fd > 0) {
+		/* hard-code the size MW_SIZE_LISO_CFG_ADV for now.
+		When the size info is exposed in the API, change this. */
+		if (write(fd, (void*)CfgStatus.Addr, SIZE_LISO_CFG_ADV_ISO) < 0) {
+			printf("write error.\n");
+			return -1;
+		}
+		close(fd);
+	} else {
+		MW_MSG("failed to open %s.\n", liso_file);
+	}
+
+	return 0;
+}
+
 int do_stop_aaa(void)
 {
 	if (G_mw_config.init_params.aaa_active == 0) {
@@ -2121,12 +2605,12 @@ int do_stop_aaa(void)
 
 	if (G_mw_config.sensor.is_rgb_sensor) {
 		/* Save 3A param to /tmp when start process */
-		if (G_mw_config.res.isp_pipeline == ISP_PIPELINE_LISO) {
+		if (G_mw_config.res.isp_pipeline == ISP_PIPELINE_MID_LISO ||
+			G_mw_config.res.isp_pipeline == ISP_PIPELINE_ADV_LISO) {
 			save_awb_ae_config();
+			save_adj_config();
 		}
-		if (G_mw_config.ae_params.slow_shutter_enable) {
-			destroy_ae_control_task();
-		}
+		destroy_ae_control_task();
 		/*destroy mutex G_mw_config.slow_shutter_lock after destroying slow shutter control thread*/
 		pthread_mutex_destroy(&G_mw_config.slow_shutter_lock);
 		if (img_stop_aaa() < 0) {
@@ -2136,6 +2620,13 @@ int do_stop_aaa(void)
 		usleep(1000);
 	}
 
+	if (G_mw_config.enh_params.auto_dump_cfg) {
+		if (G_mw_config.res.isp_pipeline == ISP_PIPELINE_MID_LISO ||
+			G_mw_config.res.isp_pipeline == ISP_PIPELINE_ADV_LISO) {
+			auto_dump_img_cfg();
+		}
+	}
+
 	if (img_lib_deinit() < 0) {
 		MW_ERROR("img_lib_deinit error!\n");
 		return -1;
diff --git a/mw/arch_s2l/src/mw_ir_led.c b/mw/arch_s2l/src/mw_ir_led.c
index 0a59bde..cea74f3 100644
--- a/mw/arch_s2l/src/mw_ir_led.c
+++ b/mw/arch_s2l/src/mw_ir_led.c
@@ -1,16 +1,34 @@
-/**********************************************************************
+/*
  * mw_ir_led.c
  *
  * History:
  * 2014/09/17 - [Bin Wang] Created this file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- *********************************************************************/
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
diff --git a/mw/arch_s2l/src/mw_md.c b/mw/arch_s2l/src/mw_md.c
index bcf71a7..a65e105 100644
--- a/mw/arch_s2l/src/mw_md.c
+++ b/mw/arch_s2l/src/mw_md.c
@@ -1,18 +1,35 @@
-/**********************************************************************
+/*
  *
  * mw_md.c
  *
  * History:
  *	2010/02/28 - [Jian Tang] Created this file
  *
- * Copyright (C) 2007 - 2010, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *********************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <unistd.h>
 #include <fcntl.h>
diff --git a/mw/arch_s2l/src/mw_netlink.c b/mw/arch_s2l/src/mw_netlink.c
index 474fdb7..46d6107 100644
--- a/mw/arch_s2l/src/mw_netlink.c
+++ b/mw/arch_s2l/src/mw_netlink.c
@@ -5,14 +5,31 @@
  * Histroy:
  *  2014/09/02 2014 - [jingyang qiu] created file
  *
- * Copyright (C) 2012 - 2016, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- ******************************************************************************/
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -385,6 +402,7 @@ void * netlink_loop(void * data)
 			MW_ERROR("do_prepare_aaa\n");
 			return NULL;
 		}
+		wait_irq_count(1);
 		if (do_start_aaa() < 0) {
 			MW_ERROR("do_start_aaa\n");
 			return NULL;
diff --git a/mw/arch_s2l/src/mw_version.c b/mw/arch_s2l/src/mw_version.c
index f7d4722..e2e0327 100644
--- a/mw/arch_s2l/src/mw_version.c
+++ b/mw/arch_s2l/src/mw_version.c
@@ -1,17 +1,35 @@
-/*******************************************************************************
+/*
  * mw_version.c
  *
  * Histroy:
  *  2014/07/14 2014 - [Lei Hong] created file
  *
- * Copyright (C) 2008-2014, Ambarella ShangHai Co,Ltd
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- ******************************************************************************/
+ */
+
 #include "mw_struct.h"
 
 /*
@@ -24,7 +42,7 @@
  *      Support P-iris lens.(m13vp288ir, mz128bp2810icr)
  */
 #define AMP_LIB_MAJOR 2
-#define AMP_LIB_MINOR 5
+#define AMP_LIB_MINOR 6
 #define AMP_LIB_PATCH 2
 #define AMP_LIB_VERSION ((AMP_LIB_MAJOR << 16) | \
                              (AMP_LIB_MINOR << 8)  | \
@@ -35,5 +53,5 @@ mw_version_info mw_version =
 	.major		= AMP_LIB_MAJOR,
 	.minor		= AMP_LIB_MINOR,
 	.patch		= AMP_LIB_PATCH,
-	.update_time	= 0x20150908,
+	.update_time	= 0x20161201,
 };
diff --git a/mw/make.inc b/mw/make.inc
index a344329..9be0b73 100644
--- a/mw/make.inc
+++ b/mw/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/05 - [Cao Rongrong] Created file
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 ifeq ($(BUILD_AMBARELLA_MIDDLEWARE_PROC), y)
