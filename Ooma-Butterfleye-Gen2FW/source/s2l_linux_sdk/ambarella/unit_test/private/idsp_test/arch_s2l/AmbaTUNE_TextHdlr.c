/*
 *
 * idsp_test
 *
 * History:
 *	2013/09/05 - [Dylan] Created this file
 *
 * Description :
 *	Load the tuned file which generated by Img tuning tool.
 *
 * Copyright (C) 2015 Ambarella, Inc.
 *
 * This file and its contents ("Software") are protected by intellectual
 * property rights including, without limitation, U.S. and/or foreign
 * copyrights. This Software is also the confidential and proprietary
 * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
 * disclose, distribute, modify, or otherwise prepare derivative works of this
 * Software or any portion thereof except pursuant to a signed license agreement
 * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
 * In the absence of such an agreement, you agree to promptly notify and return
 * this Software to Ambarella, Inc.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
 * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <stdio.h> // sprintf need
#include <string.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include "AmbaTUNE_TextHdlr.h"
#include "AmbaImgCalibItuner.h" //Note: ITUNER_SYSTEM_s need
//#include "AmbaFS.h" //Note: AMBA_FS_FILE  need
#include "AmbaDSP_ImgDef.h" // Note: AMBA_DSP_IMG_PIPE_VIDEO need
//#include "AmbaDSP.h" // Note: AMBA_DSP_VIDEO_FILTER need
#include "AmbaDSP_ImgFilter.h" // Note: AMBA_DSP_IMG_NUM_EXPOSURE_CURVE need
#include "AmbaDSP_Img3aStatistics.h" // Note: amba_img_dsp_ae_stat_info_t need
//#include "AmbaKAL.h"
//#include "AmbaCardManager.h"// Note: AmbaSCM_GetSlotStatus need
//#include "AmbaUtility.h"// Note: AmbaUtility_Slot2Drive need

#include "AmbaTUNE_Parser.h"
#include "AmbaTUNE_Rule.h"

#define AmbaPrint(format, arg...)	printf(format"\n", ##arg)
typedef FILE AMBA_FS_FILE;

#define HDLR_DEBF(fmt, arg...) AmbaPrint("[TEXT HDLR][DEBUG]"fmt, ##arg)
#define HDLR_WARF(fmt, arg...) AmbaPrint("[TEXT HDLR][WARNING]"fmt, ##arg)
#define HDLR_ERRF(fmt, arg...) AmbaPrint("[TEXT HDLR][ERROR]"fmt, ##arg)


#define MIN(a, b) ((a) > (b) ? (b) : (a))

typedef void (*pfunc_conv_t)(int, void*, void*);

typedef struct _ITUNER_OBJ_s_ {
    amba_img_dsp_mode_cfg_t TuningAlgoMode;
    TUNING_MODE_EXT_e TuningModeExt;
    TUNE_Parser_Object_t* ParserObject;
    UINT8 Is_Idsp_Load_Finish;
} ITUNER_OBJ_s;

typedef struct _TEXT_STREAM_s {
    char* text_addr;
    int size;
    int ptr;
}TEXT_STREAM;

//static int _TextHdlr_Add_Reg(REG_s *pReg);

static int _TextHdlr_Check_Param_Completeness(void);
static AMBA_DSP_IMG_PIPE_e _TextHdlr_Get_Imag_Pipe(TUNING_MODE_e TuningMode);
static AMBA_DSP_IMG_ALGO_MODE_e _TextHdlr_Get_Image_Algo_Mode(TUNING_MODE_e TuningMode);
static int _TextHdlr_Update_ItunerInfo(void);
static int _TextHdlr_Save_Ext_File(char *FileName, int Size, void *Buf);
static int _TextHdlr_load_Ext_file(char *FileName, int Size, void *Buf);


static ITUNER_OBJ_s _Ituner;

static char Ituner_File_Path[64];

static int _save_line(FILE *Fid, char * LineBuf)
{
    return (fwrite(LineBuf, 1, strlen(LineBuf), Fid));
}

#define BUF_SIZE 1024
static char ReadBuffer[BUF_SIZE+32];
static UINT8 READ_TEXT(void* destAddr, int size, int count, TEXT_STREAM* srcAddr)
{
	if( (srcAddr->ptr + size*count) >= srcAddr->size)
		return -1;
	else {
		int idx = srcAddr->ptr;
		memcpy(destAddr, &(srcAddr->text_addr[idx]), size*count);
		srcAddr->ptr = srcAddr->ptr + size*count;
	}
	return 0;
}

static int _read_line(TEXT_STREAM* text, char * Line_Buf, int Buf_Size, char **Ptr)
{
    int Ret = 0;

   *Ptr = Line_Buf;
    while(READ_TEXT(*Ptr, 1, 1, text) == 0) {
        if ((**Ptr == '\r') || (**Ptr == '\n')) {
            **Ptr = 0;
            //AmbaPrintColor(YELLOW, "%s", Line_Buf);
            Ret = 1;
            break;
        }
        (*Ptr)++;
        if ((*Ptr - Line_Buf) >= Buf_Size) {
            HDLR_WARF("%s() %d, Input Text String is too long", __func__, __LINE__);
            Ret = 1;
            break;
        }

    }

    return Ret;

}

int HT_set_ituner_stream(u8* ituner_stream,int size)
{
    char *Buf = NULL;
    int BufSize = 0;
	char *Ptr;
	int Line = 0;
	TEXT_STREAM text;
	text.text_addr =(char*)ituner_stream;
	text.ptr =0;
	text.size =size;
	ITUNER_SYSTEM_s System;

    HDLR_DEBF("---------------------");
    HDLR_DEBF("iTuner ver. %d.%d", ITUNER_VER_MAJOR, ITUNER_VER_MINOR);
    HDLR_DEBF("---------------------");

    TUNE_Parser_Set_Opmode(ITUNER_DEC);
    if (0 != TUNE_Parser_Set_Reglist_Valid(0, _Ituner.ParserObject)) {
        HDLR_WARF("%s() %d, call TUNE_PArser_Set_Reglist_Valid() Fail", __func__, __LINE__);
        return -1;
    }
    if (0 != TUNE_Parser_Get_LineBuf(_Ituner.ParserObject, &Buf, &BufSize)) {
        HDLR_WARF("%s() %d, call TUNE_Parser_Get_LineBuf() Fail", __func__, __LINE__);
        return -1;
    }
	while(_read_line(&text, Buf, BufSize, &Ptr)) {

	TUNE_Parser_Parse_Line(_Ituner.ParserObject);
	Line++;
	}

	AmbaItuner_Get_SystemInfo(&System);
	   // If multi shot mode, read in additional config files
	_Ituner.TuningModeExt = TUNE_Rule_Lookup_Tuning_Mode_Ext(System.TuningModeExt);


    return 0;
}

static int _TextHdlr_Load_Text(char *FileName)
{
    int Line = 0;
    char AscFname[64];
    //char Fmode[] = {'r','b','\0'};
    //char *Ptr;
//    char ExtCfgFileName[64];
    int Fid;
    ITUNER_SYSTEM_s System;
    //uni_to_asc(FileName, AscFname);
    memset(AscFname, 0x0, sizeof(AscFname));
    strncpy(AscFname, FileName, sizeof(AscFname));
    HDLR_DEBF("---------------------");
    HDLR_DEBF("iTuner ver. %d.%d", ITUNER_VER_MAJOR, ITUNER_VER_MINOR);
    HDLR_DEBF("---------------------");
    HDLR_DEBF("file to load:%s", AscFname);
    TUNE_Parser_Set_Opmode(ITUNER_DEC);
    if (0 != TUNE_Parser_Set_Reglist_Valid(0, _Ituner.ParserObject)) {
        HDLR_WARF("%s() %d, call TUNE_PArser_Set_Reglist_Valid() Fail", __func__, __LINE__);
        return -1;
    }
/*    if (0 != _TextHdlr_Change_System_Drive(FileName)) {
        HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, FileName);
        return -1;
    }*/

    char *Buf = NULL;
    int BufSize = 0;
    struct stat FileStat;

    if (0 != TUNE_Parser_Get_LineBuf(_Ituner.ParserObject, &Buf, &BufSize)) {
        HDLR_WARF("%s() %d, call TUNE_Parser_Get_LineBuf() Fail", __func__, __LINE__);
        return -1;
    }

    Fid = open(AscFname, O_RDONLY, 0);
    if (Fid < 0) {
        HDLR_WARF("%s() %d, call open(%s) Fail", __func__, __LINE__, AscFname);
        return -1;
    }

    fstat(Fid, &FileStat);

    memset(ReadBuffer, 0x0, sizeof(ReadBuffer));
    char* pReadBuf = &ReadBuffer[32 - (((UINT32)ReadBuffer)%32)];
    char* pStartOfStr = pReadBuf;
    char* pDstStr = Buf;
    pReadBuf = &ReadBuffer[32 - (((UINT32)ReadBuffer)%32)];
    pStartOfStr = pReadBuf;
    pDstStr = Buf;
    int ReadSize;
    UINT32 len = 0;
    int i;

    ReadSize = FileStat.st_size;
    //AmbaPrint("ReadSize: %d", ReadSize);

    while(ReadSize > 0 && read(Fid, pReadBuf, ((ReadSize > BUF_SIZE) ? BUF_SIZE : ReadSize)) > 0) {
        for (i = 0; i < ((ReadSize > BUF_SIZE) ? BUF_SIZE : ReadSize); i++) {
            if (pReadBuf[i] == '\n' || pReadBuf[i] == '\r') {
                pReadBuf[i] = '\0';
            }
        }
        while (1) {
            len = strlen(pStartOfStr);
            if (&pStartOfStr[len] >= (pReadBuf + BUF_SIZE)) {
                strncpy(pDstStr, pStartOfStr, BUF_SIZE - (pStartOfStr - pReadBuf));
                pDstStr = &Buf[BUF_SIZE - (pStartOfStr - pReadBuf)];
                pStartOfStr = pReadBuf;
                // Feed ReadBuf Again
                break;
            } else {
                strncpy(pDstStr, pStartOfStr, BUF_SIZE - (pStartOfStr - pReadBuf));
                pStartOfStr = &pStartOfStr[len + 1];
                //AmbaPrint("Feed String: %s", Buf);
                if (Buf[0] != '\0') {
                    TUNE_Parser_Parse_Line(_Ituner.ParserObject);
                    Line++;
                }

                if (pStartOfStr - pReadBuf >= ReadSize) {
                    break;
                }
                pDstStr = Buf;
            }
        }
        ReadSize -= BUF_SIZE;
    }

    HDLR_DEBF("%s() %d, Read Line Num: %d", __func__, __LINE__, Line);
    close(Fid);


    AmbaItuner_Get_SystemInfo(&System);
    // If multi shot mode, read in additional config files
    _Ituner.TuningModeExt = TUNE_Rule_Lookup_Tuning_Mode_Ext(System.TuningModeExt);
    /*if (_Ituner.TuningModeExt) {
        HDLR_DEBF("extended config file to load:%s", System.ExtConfigPath);
        if (0 != _TextHdlr_Change_System_Drive(System.ExtConfigPath)) {
            HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, System.ExtConfigPath);
            return -1;
        }
        asc_to_uni(System.ExtConfigPath, ExtCfgFileName);
        Fid = AmbaFS_fopen(ExtCfgFileName, Fmode);
        if (Fid == 0) {
            HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, ExtCfgFileName);
            return -1;
        }
        while(_read_line(Fid, LineBuf, &Ptr)) {
            _parse_line(Line, LineBuf, 1);
            Line++;
        }
        AmbaFS_fclose(Fid);
    }*/
    return 0;
}

int TextHdlr_Init(void)
{
    int i;
    Rule_Info_t Rule_Info;
    TUNE_Parser_Set_Opmode(ITUNER_DEC);
    memset(&_Ituner.TuningAlgoMode,0x0, sizeof(amba_img_dsp_mode_cfg_t));
    _Ituner.TuningAlgoMode.Pipe = AMBA_DSP_IMG_PIPE_VIDEO;
    _Ituner.TuningAlgoMode.AlgoMode= AMBA_DSP_IMG_ALGO_MODE_FAST;
    _Ituner.TuningAlgoMode.BatchId= 0;
    TUNE_Parser_Create(&_Ituner.ParserObject);
    _Ituner.Is_Idsp_Load_Finish = FALSE;
    TUNE_Rule_Get_Info(&Rule_Info);
    for (i = 0; i < Rule_Info.RegCount; i++) {
        TUNE_Parser_Add_Reg(&Rule_Info.RegList[i], _Ituner.ParserObject);
    }

    TUNE_Parser_Set_Reglist_Valid(0, _Ituner.ParserObject);


    /* //TBD
    for(i=0; i<MAX_REGS; i++) {
        if (img_ext_regs[i].index == -1) break;
		ituner_add_ext_reg(&img_ext_regs[i]);
    }*/
    AmbaItuner_Config_t Ituner_Config = {
        .Hook_Func.Load_Data = TextHdlr_Load_Data,
        .Hook_Func.Save_Data = TextHdlr_Save_Data,
    };
    return AmbaItuner_Init(&Ituner_Config);
}

int TextHdlr_Load_IDSP(char *Filepath)
{
	if (0 != _TextHdlr_Load_Text(Filepath)) {
	    HDLR_WARF("%s() %d, call _TextHdlr_Load_Text(%s) Fail", __func__, __LINE__, Filepath);
	    return -1;
	}
	_TextHdlr_Update_ItunerInfo();
	if (0 != _TextHdlr_Check_Param_Completeness()) {
	    HDLR_WARF("%s() %d, call _TextHdlr_Check_Param_Completeness() Fail", __func__, __LINE__);
	    return -1;
	}
	return 0;
}
static int _TextHdlr_Check_Param_Completeness(void)
{
    int Filter_Idx;
    int Param_Idx;
    int Ret = 0;
    REG_s* Reg = NULL;
    PARAM_s* Param = NULL;
    AMBA_ITUNER_VALID_FILTER_t FilterStatus;
    AmbaItuner_Get_FilterStatus(&FilterStatus);

    for (Filter_Idx = 0; Filter_Idx < _Ituner.ParserObject->RegCount; Filter_Idx++) {
        Reg = TUNE_Parser_Get_Reg(Filter_Idx, _Ituner.ParserObject);
        if (Reg == NULL) {
            HDLR_WARF("%s() %d, call TUNE_Param_Get_Reg Fail", __func__, __LINE__);
            continue;
        }
        if (FilterStatus[Reg->Index] == 1) {
            if ((Reg->Valid & ((0x1ULL << Reg->ParamCount) - 1)) != ((0x1ULL << Reg->ParamCount) - 1)) {
                for (Param_Idx = 0; Param_Idx < Reg->ParamCount; Param_Idx++) {
                    if (Reg->Valid & (0x1ULL << Param_Idx)) {
                } else {
                        Param = TUNE_Parser_Get_Param(Reg, Param_Idx);
                    HDLR_WARF("%s() %d, Lost Param: %s.%s, %llx", __func__, __LINE__,
                                Reg->Name, Param->Name, Reg->Valid);
                    Ret = -1;
                }
            }
        }
    }
    }
    return Ret;
}
int TextHdlr_set_ituner(u8* ituner_stream,int size)
{
//	_Ituner.Is_Idsp_Load_Finish = TRUE;
	   if (0 != HT_set_ituner_stream(ituner_stream,size)) {
		   return -1;
	   }
	   _TextHdlr_Update_ItunerInfo();
   	   if (0 != _TextHdlr_Check_Param_Completeness()) {
		   HDLR_WARF("%s() %d, call _TextHdlr_Check_Param_Completeness() Fail", __func__, __LINE__);
		   return -1;
	   }
	return 0;
}

int TextHdlr_Execute_IDSP(int fd_iav, amba_img_dsp_mode_cfg_t Mode, AMBA_ITUNER_PROC_INFO_s *ProcInfo)
{
	AmbaItuner_Execute(fd_iav, Mode, ProcInfo);
	return 0;
}

int TextHdlr_Get_SystemInfo(ITUNER_SYSTEM_s *System) {
    AmbaItuner_Get_SystemInfo(System);
    return 0;
}

int TextHdlr_Set_SystemInfo(ITUNER_SYSTEM_s *System) {
    AmbaItuner_Set_SystemInfo(System);
    return 0;
}
int TextHdlr_Get_ItunerInfo(ITUNER_INFO_s *ItunerInfo) {
    ITUNER_SYSTEM_s System;
    AmbaItuner_Get_SystemInfo(&System);
    TUNING_MODE_e TuningMode = TUNE_Rule_Lookup_Tuning_Mode(System.TuningMode);
    _Ituner.TuningModeExt = TUNE_Rule_Lookup_Tuning_Mode_Ext(System.TuningModeExt);
    _Ituner.TuningAlgoMode.Pipe = _TextHdlr_Get_Imag_Pipe(TuningMode);
    _Ituner.TuningAlgoMode.AlgoMode = _TextHdlr_Get_Image_Algo_Mode(TuningMode);
    _Ituner.TuningAlgoMode.BatchId = 0;//(_Ituner.TuningAlgoMode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO)? AMBA_DSP_VIDEO_FILTER : AMBA_DSP_STILL_LISO_FILTER;
    memcpy(&ItunerInfo->TuningAlgoMode, &_Ituner.TuningAlgoMode, sizeof(ItunerInfo->TuningAlgoMode));
    ItunerInfo->TuningModeExt = _Ituner.TuningModeExt;
    return 0;
}
static int _TextHdlr_Update_ItunerInfo(void)
{
    ITUNER_SYSTEM_s System;
    AmbaItuner_Get_SystemInfo(&System);
    TUNING_MODE_e TuningMode = TUNE_Rule_Lookup_Tuning_Mode(System.TuningMode);
    _Ituner.TuningModeExt = TUNE_Rule_Lookup_Tuning_Mode_Ext(System.TuningModeExt);
    _Ituner.TuningAlgoMode.Pipe = _TextHdlr_Get_Imag_Pipe(TuningMode);
    _Ituner.TuningAlgoMode.AlgoMode = _TextHdlr_Get_Image_Algo_Mode(TuningMode);
    _Ituner.TuningAlgoMode.BatchId = 0;//(_Ituner.TuningAlgoMode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO)? AMBA_DSP_VIDEO_FILTER : AMBA_DSP_STILL_LISO_FILTER;
    if (TuningMode == IMG_MODE_NIGHT_PORTRAIT_STILL) {
        System.InputPicCnt = 4;
    } else {
        System.InputPicCnt = 1;
    }
    AmbaItuner_Set_SystemInfo(&System);
    return 0;
}

static int _TextHdlr_Update_System_Info(amba_img_dsp_mode_cfg_t Mode)
{
    ITUNER_SYSTEM_s System;
    char const *Tuning_Mode_Str;
    AmbaItuner_Get_SystemInfo(&System);
    if (Mode.Pipe == AMBA_DSP_IMG_PIPE_VIDEO) {
        if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_HISO) {
            Tuning_Mode_Str = TUNE_Rule_Lookup_Tuning_Mode_Str(IMG_MODE_HIGH_ISO_VIDEO);
        } else {
            Tuning_Mode_Str = TUNE_Rule_Lookup_Tuning_Mode_Str(IMG_MODE_VIDEO);
        }
    } else { //AMBA_DSP_IMG_PIPE_STILL
        if (Mode.AlgoMode == AMBA_DSP_IMG_ALGO_MODE_HISO) {
            Tuning_Mode_Str = TUNE_Rule_Lookup_Tuning_Mode_Str(IMG_MODE_HIGH_ISO_STILL);
        } else {
            Tuning_Mode_Str = TUNE_Rule_Lookup_Tuning_Mode_Str(IMG_MODE_LOW_ISO_STILL);
        }
    }
    strncpy(System.TuningMode, Tuning_Mode_Str, sizeof(System.TuningMode));
    AmbaItuner_Set_SystemInfo(&System);
    return 0;
}


static int _TextHdlr_Get_Ext_File_Path(Ituner_Ext_File_Type_e Ext_File_Type, char *Ext_File_path)
{
    char* Ext_pos;
    if (strlen(Ituner_File_Path) < 7) {
        HDLR_ERRF("%s() %d, Ituner_File_Path = %s, it should not happened!", __func__, __LINE__, Ext_File_path);
        return -1;
    }
    strncpy(Ext_File_path, Ituner_File_Path, 64);
    Ext_pos = strrchr(Ext_File_path, '.');
    if (Ext_pos == NULL) {
        HDLR_WARF("%s() %d, Ituner_File_Path = %s, it should not happened!", __func__, __LINE__, Ext_File_path);
        return -1;
    }
    *Ext_pos = '\0';
    switch (Ext_File_Type) {
    case EXT_FILE_FPN_MAP:
        strcat(Ext_File_path, "_Fpn_Map.bin");
        break;
    case EXT_FILE_VIGNETTE_GAIN:
        strcat(Ext_File_path, "_Vignette_Gain.bin");
        break;
    case EXT_FILE_WARP_TABLE:
        strcat(Ext_File_path, "_Warp_Table.bin");
        break;
    case EXT_FILE_CA_TABLE:
        strcat(Ext_File_path, "_Ca_Table.bin");
        break;
    case EXT_FILE_CC_REG:
        strcat(Ext_File_path, "_CC_Reg.bin");
        break;
    case EXT_FILE_CC_THREED:
        strcat(Ext_File_path, "_CC_3d.bin");
            break;
    default:
        HDLR_ERRF("%s() %d, Invalid Ext_File_Type = %d", __func__, __LINE__, Ext_File_Type);
        return -1;
    }
    return 0;
}

static int _TextHdlr_Load_Raw(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    int Ret = 0;
/*    char UniRawPath[256];
    ITUNER_SYSTEM_s System;
    AMBA_FS_FILE *Fd;
    AmbaItuner_Get_SystemInfo(&System);
    if (strlen(System.RawPath) < 8 || Ext_File_Param->Raw_Load_Param.Address == NULL || Ext_File_Param->Raw_Load_Param.Max_Size == 0) {
        HDLR_WARF("%s() %d, RawPath: %s, Addr: %p, Max_Size: %d",
            __func__, __LINE__, System.RawPath, Ext_File_Param->Raw_Load_Param.Address, Ext_File_Param->Raw_Load_Param.Max_Size);
        return -1;
    }
    if (0 != _TextHdlr_Change_System_Drive(System.RawPath)) {
        HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, System.RawPath);
        return -1;
    }
    asc_to_uni(System.RawPath, UniRawPath);
    Fd = AmbaFS_fopen(UniRawPath, "r");
    if (Fd == NULL) {
        HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, UniRawPath);
        return -1;
    }
    int InputPitch = ((System.RawPitch + 31) >> 5) << 5;
    int i;
    int Offset = 0;
    for (i = 0; i < System.RawHeight; i++) {
        if ((Offset + System.RawPitch) > Ext_File_Param->Raw_Load_Param.Max_Size) {
            HDLR_WARF("%s() %d, Load Size Buffer Full, Max_Size = %d, i = %d, InputPitch = %d",
                __func__, __LINE__, Ext_File_Param->Raw_Load_Param.Max_Size, i, InputPitch);
            Ret = -1;
        }
        AmbaFS_fread(&((UINT8*)Ext_File_Param->Raw_Load_Param.Address)[Offset], System.RawPitch, 1, Fd);
        Offset += InputPitch;
    }
    AmbaFS_fclose(Fd);*/
    return Ret;
}

static int _TextHldr_Load_Vignette(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_VIGNETTE_s VignetteCompensation;
    AmbaItuner_Get_VignetteCompensation(&VignetteCompensation);
    if (VignetteCompensation.Enable) {
        HDLR_DEBF("%s() %d, Load Vignette Gain", __func__, __LINE__);
        if (Ext_File_Param == NULL) {
            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
            return -1;
        }
        if (strlen(VignetteCompensation.CalibTablePath) < 4 || Ext_File_Param->Vignette_Gain_Load_Param.Address == NULL || Ext_File_Param->Vignette_Gain_Load_Param.Size == 0) {
            HDLR_DEBF("%s() %d, Vignette_Gain_Path = %s, Address = %p, Size = %d",
                    __func__, __LINE__, VignetteCompensation.CalibTablePath, Ext_File_Param->Vignette_Gain_Load_Param.Address, Ext_File_Param->Vignette_Gain_Load_Param.Size);
            return 0;
        }
        if (_TextHdlr_load_Ext_file(VignetteCompensation.CalibTablePath, Ext_File_Param->Vignette_Gain_Load_Param.Size, Ext_File_Param->Vignette_Gain_Load_Param.Address) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                    __func__, __LINE__,VignetteCompensation.CalibTablePath, Ext_File_Param->Vignette_Gain_Load_Param.Address);
            return -1;
        }
    } else {
        HDLR_DEBF("%s() %d, Vignette Disable, Skip Load Process", __func__, __LINE__);
    }
    return 0;
}

static int _TextHldr_Load_Bypass_Vignette(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_VIGNETTE_BYPASS_s VignetteCompensationByPass;
    AmbaItuner_Get_VignetteCompensationByPass(&VignetteCompensationByPass);
    if (VignetteCompensationByPass.Enable) {
        HDLR_DEBF("%s() %d, Load Bypass Vignette Gain", __func__, __LINE__);
        if (Ext_File_Param == NULL) {
            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
            return -1;
        }

        if (strlen(VignetteCompensationByPass.GainPath) < 4 || Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Address == NULL || Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Size == 0) {
            HDLR_ERRF("%s() %d, Bypass Vignette_Gain_Path = %s, Address = %p, Size = %d",
                    __func__, __LINE__, VignetteCompensationByPass.GainPath, Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Address, Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Size);
            return -1;
        }
        if (_TextHdlr_load_Ext_file(VignetteCompensationByPass.GainPath, Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Size, Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Address) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                    __func__, __LINE__,VignetteCompensationByPass.GainPath, Ext_File_Param->Bypass_Vignette_Gain_Load_Param.Address);
            return -1;
        }
    } else {
        HDLR_DEBF("%s() %d, Bypass Vignette Disable, Skip Load Process", __func__, __LINE__);
    }
    return 0;
}
static int _TextHdlr_Load_Warp_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_WARP_s WarpCompensation;
    AmbaItuner_Get_WarpCompensation(&WarpCompensation);
    if (WarpCompensation.Enable) {
        HDLR_DEBF("%s() %d, Load Warp Table", __func__, __LINE__);
        if (Ext_File_Param == NULL) {
            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
            return -1;
        }
        if (strlen(WarpCompensation.WarpGridTablePath) < 4 || Ext_File_Param->Warp_Table_Load_Param.Address == NULL || Ext_File_Param->Warp_Table_Load_Param.Size == 0) {
            HDLR_ERRF("%s() %d, Warp_Table_Path = %s, Address = %p, Size = %d",
                    __func__, __LINE__, WarpCompensation.WarpGridTablePath, Ext_File_Param->Warp_Table_Load_Param.Address, Ext_File_Param->Warp_Table_Load_Param.Size);
            return -1;
        }
        if (_TextHdlr_load_Ext_file(WarpCompensation.WarpGridTablePath, Ext_File_Param->Warp_Table_Load_Param.Size, Ext_File_Param->Warp_Table_Load_Param.Address) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                    __func__, __LINE__,WarpCompensation.WarpGridTablePath, Ext_File_Param->Warp_Table_Load_Param.Address);
            return -1;
        }
    } else {
        HDLR_DEBF("%s() %d, Warp Disable, Skip Load Process", __func__, __LINE__);
    }
    return 0;
}

static int _TextHdlr_Load_Bypass_Horizontal_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_WARP_DZOOM_BYPASS_s WarpCompensationDzoomByPass;
    AmbaItuner_Get_WarpCompensationDzoomByPass(&WarpCompensationDzoomByPass);
    if (WarpCompensationDzoomByPass.WarpControl) {
        HDLR_DEBF("%s() %d, Load Warp Horizontal Table", __func__, __LINE__);
        if (Ext_File_Param == NULL) {
            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
            return -1;
        }

        if (strlen(WarpCompensationDzoomByPass.WarpHorizontalTablePath) < 4 || Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Address == NULL || Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Max_Size == 0) {
            HDLR_ERRF("%s() %d, Warp_Horizontal_Table_Path = %s, Address = %p, Size = %d",
                    __func__, __LINE__, WarpCompensationDzoomByPass.WarpHorizontalTablePath, Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Address, Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Max_Size);
            return -1;
        }
        //AMBA_FS_STAT FileInfo;
        struct stat tmp_fileinfo;
//        if (AmbaFS_Stat(WarpCompensationDzoomByPass.WarpHorizontalTablePath, &FileInfo) != OK) {
	if(stat(WarpCompensationDzoomByPass.WarpHorizontalTablePath, &tmp_fileinfo)<0){
            HDLR_WARF("%s() %d, call AmbaFS_Stat(%s) Fail", __func__, __LINE__, WarpCompensationDzoomByPass.WarpHorizontalTablePath);
            return -1;
        }
//        if (FileInfo.Size > Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Max_Size) {
	if(tmp_fileinfo.st_size> Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Max_Size) {
            HDLR_WARF("%s() %d, call Invalid File Size", __func__, __LINE__);
            return -1;
        }
//        if (_TextHdlr_load_Ext_file(WarpCompensationDzoomByPass.WarpHorizontalTablePath, FileInfo.Size, Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Address) < 0) {
      if (_TextHdlr_load_Ext_file(WarpCompensationDzoomByPass.WarpHorizontalTablePath, tmp_fileinfo.st_size, Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Address) < 0) {

            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                    __func__, __LINE__,WarpCompensationDzoomByPass.WarpHorizontalTablePath, Ext_File_Param->Bypass_Warp_Horizontal_Table_Load_Param.Address);
            return -1;
        }
    } else {
        HDLR_DEBF("%s() %d, Bypass Horizontal Warp Disable, Skip Load Process", __func__, __LINE__);
    }
    return 0;
}

static int _TextHdlr_Load_Bypass_Vertical_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_WARP_DZOOM_BYPASS_s WarpCompensationDzoomByPass;
    AmbaItuner_Get_WarpCompensationDzoomByPass(&WarpCompensationDzoomByPass);
    if (WarpCompensationDzoomByPass.VertWarpEnable) {
        HDLR_DEBF("%s() %d, Load Warp Vertical Table", __func__, __LINE__);
        if (Ext_File_Param == NULL) {
            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
            return -1;
        }

        if (strlen(WarpCompensationDzoomByPass.WarpVerticalTablePath) < 4 || Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Address == NULL || Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Max_Size == 0) {
            HDLR_ERRF("%s() %d, Warp_Vertical_Table_Path = %s, Address = %p, Size = %d",
                    __func__, __LINE__, WarpCompensationDzoomByPass.WarpVerticalTablePath, Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Address, Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Max_Size);
            return -1;
        }
//        AMBA_FS_STAT FileInfo;
	struct stat tmp_fileinfo;
//        if (AmbaFS_Stat(WarpCompensationDzoomByPass.WarpVerticalTablePath, &FileInfo) != OK) {
    	if (stat(WarpCompensationDzoomByPass.WarpVerticalTablePath, &tmp_fileinfo) <0) {
            HDLR_WARF("%s() %d, call AmbaFS_Stat(%s) Fail", __func__, __LINE__, WarpCompensationDzoomByPass.WarpVerticalTablePath);
            return -1;
        }
        if (tmp_fileinfo.st_size > Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Max_Size) {
            HDLR_WARF("%s() %d, call Invalid File Size", __func__, __LINE__);
            return -1;
        }
        if (_TextHdlr_load_Ext_file(WarpCompensationDzoomByPass.WarpVerticalTablePath, tmp_fileinfo.st_size, Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Address) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                    __func__, __LINE__,WarpCompensationDzoomByPass.WarpVerticalTablePath, Ext_File_Param->Bypass_Warp_Vertical_Table_Load_Param.Address);
            return -1;
        }
    } else {
        HDLR_DEBF("%s() %d, Bypass Vertical Warp Disable, Skip Load Process", __func__, __LINE__);
    }
    return 0;
}

static int _TextHdlr_Load_Ca_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_CHROMA_ABERRATION_s ChromaAberrationInfo;
    AmbaItuner_Get_ChromaAberrationInfo(&ChromaAberrationInfo);
    if (ChromaAberrationInfo.Enable) {
        HDLR_DEBF("%s() %d, Load Ca Table", __func__, __LINE__);
        if (Ext_File_Param == NULL) {
            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
            return -1;
        }
        if (strlen(ChromaAberrationInfo.CaGridTablePath) < 4 || Ext_File_Param->Ca_Table_Load_Param.Address == NULL || Ext_File_Param->Ca_Table_Load_Param.Size == 0) {
            HDLR_ERRF("%s() %d, Ca_Table_Path = %s, Address = %p, Size = %d",
                    __func__, __LINE__, ChromaAberrationInfo.CaGridTablePath, Ext_File_Param->Ca_Table_Load_Param.Address, Ext_File_Param->Ca_Table_Load_Param.Size);
            return -1;
        }
        if (_TextHdlr_load_Ext_file(ChromaAberrationInfo.CaGridTablePath, Ext_File_Param->Ca_Table_Load_Param.Size, Ext_File_Param->Ca_Table_Load_Param.Address) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                    __func__, __LINE__,ChromaAberrationInfo.CaGridTablePath, Ext_File_Param->Ca_Table_Load_Param.Address);
            return -1;
        }
    } else {
        HDLR_DEBF("%s() %d, Ca Disable, Skip Load Process", __func__, __LINE__);
    }
    return 0;
}

static int _TextHldr_Load_Bypass_Ca_Horizontal_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_CHROMA_ABERRATION_BYPASS_s ChromaAberrationInfoByPass;
    AmbaItuner_Get_ChromaAberrationInfoByPass(&ChromaAberrationInfoByPass);

    if (ChromaAberrationInfoByPass.HorzWarpEnable) {
        HDLR_DEBF("%s() %d, Load Bypass Horizontal Ca Table", __func__, __LINE__);
        if (Ext_File_Param == NULL) {
            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
            return -1;
        }

        if (strlen(ChromaAberrationInfoByPass.WarpHorzTablePath) < 4 || Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Address == NULL || Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Max_Size == 0) {
            HDLR_ERRF("%s() %d, Bypass Horizontal Ca_Table_Path = %s, Address = %p, Max_Size = %d",
                    __func__, __LINE__, ChromaAberrationInfoByPass.WarpHorzTablePath, Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Address, Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Max_Size);
            return -1;
        }
        //AMBA_FS_STAT FileInfo;
        struct stat tmp_fileinfo;
        if (stat(ChromaAberrationInfoByPass.WarpHorzTablePath, &tmp_fileinfo) <0) {
            HDLR_WARF("%s() %d, call AmbaFS_Stat(%s) Fail", __func__, __LINE__, ChromaAberrationInfoByPass.WarpHorzTablePath);
            return -1;
        }
        if (tmp_fileinfo.st_size > Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Max_Size) {
            HDLR_WARF("%s() %d, call Invalid File Size", __func__, __LINE__);
            return -1;
        }
        if (_TextHdlr_load_Ext_file(ChromaAberrationInfoByPass.WarpHorzTablePath, tmp_fileinfo.st_size, Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Address) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                    __func__, __LINE__,ChromaAberrationInfoByPass.WarpHorzTablePath, Ext_File_Param->Bypass_Ca_Horizontal_Table_Load_Param.Address);
            return -1;
        }
    } else {
        HDLR_DEBF("%s() %d, Bypass Horizontal Ca Disable, Skip Load Process", __func__, __LINE__);
    }
    return 0;
}
static int _TextHdlr_Load_Bypass_Ca_Vertical_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_CHROMA_ABERRATION_BYPASS_s ChromaAberrationInfoByPass;
    AmbaItuner_Get_ChromaAberrationInfoByPass(&ChromaAberrationInfoByPass);

    if (ChromaAberrationInfoByPass.VertWarpEnable) {
        HDLR_DEBF("%s() %d, Load Bypass Vertical Ca Table", __func__, __LINE__);
        if (Ext_File_Param == NULL) {
            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
            return -1;
        }

        if (strlen(ChromaAberrationInfoByPass.WarpVertTablePath) < 4 || Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Address == NULL || Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Max_Size == 0) {
            HDLR_ERRF("%s() %d, Bypass Vertical Ca_Table_Path = %s, Address = %p, Max_Size = %d",
                    __func__, __LINE__, ChromaAberrationInfoByPass.WarpVertTablePath, Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Address, Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Max_Size);
            return -1;
        }
//        AMBA_FS_STAT FileInfo;
	struct stat tmp_fileinfo;
        if (stat(ChromaAberrationInfoByPass.WarpVertTablePath, &tmp_fileinfo) <0) {
            HDLR_WARF("%s() %d, call AmbaFS_Stat(%s) Fail", __func__, __LINE__, ChromaAberrationInfoByPass.WarpVertTablePath);
            return -1;
        }
        if (tmp_fileinfo.st_size > Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Max_Size) {
            HDLR_WARF("%s() %d, call Invalid File Size", __func__, __LINE__);
            return -1;
        }
        if (_TextHdlr_load_Ext_file(ChromaAberrationInfoByPass.WarpVertTablePath, tmp_fileinfo.st_size, Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Address) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                    __func__, __LINE__,ChromaAberrationInfoByPass.WarpVertTablePath, Ext_File_Param->Bypass_Ca_Vertical_Table_Load_Param.Address);
            return -1;
        }
    } else {
        HDLR_DEBF("%s() %d, Bypass Vertical Ca Disable, Skip Load Process", __func__, __LINE__);
    }
    return 0;
}

static int _TextHdlr_Load_FPN_Map(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_FPN_s StaticBadPixelCorrection;
    AmbaItuner_Get_StaticBadPixelCorrection(&StaticBadPixelCorrection);
    if (StaticBadPixelCorrection.Enable) {
        HDLR_DEBF("%s() %d, Load FPN Map", __func__, __LINE__);
        if (Ext_File_Param == NULL) {
            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
            return -1;
        }
        if (strlen(StaticBadPixelCorrection.MapPath) < 4 || Ext_File_Param->FPN_MAP_Ext_Load_Param.Address == NULL || Ext_File_Param->FPN_MAP_Ext_Load_Param.Size == 0) {
            HDLR_ERRF("%s() %d, FPN_Map_Path = %s, Address = %p, Size = %d",
                    __func__, __LINE__, StaticBadPixelCorrection.MapPath, Ext_File_Param->FPN_MAP_Ext_Load_Param.Address, Ext_File_Param->FPN_MAP_Ext_Load_Param.Size);
            return -1;
        }
        if (_TextHdlr_load_Ext_file(StaticBadPixelCorrection.MapPath, Ext_File_Param->FPN_MAP_Ext_Load_Param.Size, Ext_File_Param->FPN_MAP_Ext_Load_Param.Address) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                    __func__, __LINE__,StaticBadPixelCorrection.MapPath, Ext_File_Param->FPN_MAP_Ext_Load_Param.Address);
            return -1;
        }
    } else {
        HDLR_DEBF("%s() %d, FPN Disable, Skip Load Process", __func__, __LINE__);
    }
    return 0;
}

static int _TextHdlr_Load_Bypass_FPN_Map(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_FPN_BYPASS_s StaticBadPixelCorrectionByPass;
    AmbaItuner_Get_StaticBadPixelCorrectionByPass(&StaticBadPixelCorrectionByPass);
    if (StaticBadPixelCorrectionByPass.Enable) {
        HDLR_DEBF("%s() %d, Load Bypass FPN Map", __func__, __LINE__);
        if (Ext_File_Param == NULL) {
            HDLR_ERRF("%s() %d, Ext_File_Param = NULL", __func__, __LINE__);
            return -1;
        }
        if (strlen(StaticBadPixelCorrectionByPass.MapPath) < 4 || Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Address == NULL || Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Size == 0) {
            HDLR_ERRF("%s() %d, FPN_Map_Path = %s, Address = %p, Size = %d",
                    __func__, __LINE__, StaticBadPixelCorrectionByPass.MapPath, Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Address, Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Size);
            return -1;
        }
        if (_TextHdlr_load_Ext_file(StaticBadPixelCorrectionByPass.MapPath, Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Size, Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Address) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                    __func__, __LINE__,StaticBadPixelCorrectionByPass.MapPath, Ext_File_Param->Bypass_FPN_MAP_Ext_Load_Param.Address);
            return -1;
        }
    } else {
        HDLR_DEBF("%s() %d, Bypass FPN Disable, Skip Load Process", __func__, __LINE__);
    }
    return 0;
}

static int _TextHdlr_Load_CC_Reg(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    ITUNER_COLOR_CORRECTION_s ColorCorrection;
    AmbaItuner_Get_ColorCorrection(&ColorCorrection);
    if (strlen(ColorCorrection.RegPath) < 4 || Ext_File_Param->CC_Reg_Load_Param.Address == NULL || Ext_File_Param->CC_Reg_Load_Param.Size == 0) {
        HDLR_ERRF("%s() %d, CC Reg Path = %s, Address = %p, Size = %d",
                __func__, __LINE__, ColorCorrection.RegPath, Ext_File_Param->CC_Reg_Load_Param.Address, Ext_File_Param->CC_Reg_Load_Param.Size);
        return -1;
    }
    if (_TextHdlr_load_Ext_file(ColorCorrection.RegPath, Ext_File_Param->CC_Reg_Load_Param.Size, Ext_File_Param->CC_Reg_Load_Param.Address) < 0) {
        HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
                __func__, __LINE__,ColorCorrection.RegPath, Ext_File_Param->CC_Reg_Load_Param.Address);
        return -1;
    }
    return 0;
}

static int _TextHdlr_Load_CC_ThreeD(Ituner_Ext_File_Param_s *Ext_File_Param)
{
   ITUNER_COLOR_CORRECTION_s ColorCorrection;
   AmbaItuner_Get_ColorCorrection(&ColorCorrection);
   if (strlen(ColorCorrection.ThreeDPath) < 4 || Ext_File_Param->CC_ThreeD_Load_Param.Address == NULL || Ext_File_Param->CC_ThreeD_Load_Param.Size == 0) {
       HDLR_ERRF("%s() %d, CC 3D Path = %s, Address = %p, Size = %d",
               __func__, __LINE__, ColorCorrection.ThreeDPath, Ext_File_Param->CC_ThreeD_Load_Param.Address, Ext_File_Param->CC_ThreeD_Load_Param.Size);
       return -1;
   }
   if (_TextHdlr_load_Ext_file(ColorCorrection.ThreeDPath, Ext_File_Param->CC_ThreeD_Load_Param.Size, Ext_File_Param->CC_ThreeD_Load_Param.Address) < 0) {
       HDLR_WARF("%s() %d, call _TextHdlr_load_ext_file(%s, Addr : %p) Fail",
               __func__, __LINE__,ColorCorrection.ThreeDPath, Ext_File_Param->CC_ThreeD_Load_Param.Address);
       return -1;
   }
   return 0;
}

static int _TextHdlr_Save_FPN_Map(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    char FilePath[64];
    ITUNER_FPN_s StaticBadPixelCorrection;
    AmbaItuner_Get_StaticBadPixelCorrection(&StaticBadPixelCorrection);
    if (StaticBadPixelCorrection.Enable) {
        amba_img_dsp_sbp_correction_t SbpCorr;
        AmbaItuner_Get_SbpCorr(&SbpCorr);
        if (SbpCorr.CalibSbpInfo.SbpBuffer != NULL) {
            UINT32 FPN_Map_Size = ITUNER_CAL_FPN_MAP_SIZE(StaticBadPixelCorrection.CailbVinWidth, StaticBadPixelCorrection.CailbVinHeight);
            HDLR_DEBF("%s() %d, Dump FPN Map", __func__, __LINE__);
            _TextHdlr_Get_Ext_File_Path(EXT_FILE_FPN_MAP, FilePath);
            strncpy(StaticBadPixelCorrection.MapPath, FilePath, sizeof(StaticBadPixelCorrection.MapPath));
            AmbaItuner_Set_StaticBadPixelCorrection(&StaticBadPixelCorrection);
            HDLR_DEBF("%s() %d, Dump FPN Map Address %s, size %d, to %s", __func__, __LINE__, SbpCorr.CalibSbpInfo.SbpBuffer,  FPN_Map_Size, StaticBadPixelCorrection.MapPath);
            if (_TextHdlr_Save_Ext_File(StaticBadPixelCorrection.MapPath, FPN_Map_Size, SbpCorr.CalibSbpInfo.SbpBuffer) < 0) {
                HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail", __func__, __LINE__, StaticBadPixelCorrection.MapPath, SbpCorr.CalibSbpInfo.SbpBuffer);
                return -1;
            }
        } else {
            HDLR_WARF("%s() %d, EXT_FILE_FPN_MAP, FPN_Map_Addr = NULL", __func__, __LINE__);
        }
    } else {
        HDLR_DEBF("%s() %d, FPN Disable, Skip Dump Process", __func__, __LINE__);
    }
    return 0;
}
static int _TextHdlr_Save_Vignette(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    char FilePath[64];
    ITUNER_VIGNETTE_s VignetteCompensation;
    AmbaItuner_Get_VignetteCompensation(&VignetteCompensation);
    if (VignetteCompensation.Enable) {
        amba_img_dsp_vignette_calc_info_t VignetteCalcInfo;
        AmbaItuner_Get_VignetteCalcInfo(&VignetteCalcInfo);
        if (VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain != NULL && VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenEvenGain != NULL &&
            VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenOddGain != NULL && VignetteCalcInfo.CalibVignetteInfo.pVignetteBlueGain != NULL) {
            _TextHdlr_Get_Ext_File_Path(EXT_FILE_VIGNETTE_GAIN, FilePath);
            strncpy(VignetteCompensation.CalibTablePath, FilePath, sizeof(VignetteCompensation.CalibTablePath));
            AmbaItuner_Set_VignetteCompensation(&VignetteCompensation);
            HDLR_DEBF("%s() %d, Dump Vignette Gain Address %p, size %d * 4, to %s",
                    __func__, __LINE__, VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain,  ITUNER_VIGNETTE_GAIN_MAP_SIZE, VignetteCompensation.CalibTablePath);
            {
                int Fid;
                //char UniFname[64];
                /*if (0 != _TextHdlr_Change_System_Drive(VignetteCompensation.CalibTablePath)) {
                    HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, VignetteCompensation.CalibTablePath);
                    return -1;
                }
                asc_to_uni(VignetteCompensation.CalibTablePath, UniFname);*/
                Fid = open(VignetteCompensation.CalibTablePath, O_WRONLY | O_CREAT, 0666);
                if (Fid == 0) {
                    AmbaPrint("[Error] Ext file open fails!");
                    return -1;
                }
                int i;
                UINT16* SrcAddr[] = {
                    VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain,
                    VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenEvenGain,
                    VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenOddGain,
                    VignetteCalcInfo.CalibVignetteInfo.pVignetteBlueGain
                };
                for (i = 0; i < 4; i++) {
                    if (write(Fid, SrcAddr[i], ITUNER_VIGNETTE_GAIN_MAP_SIZE) <= 0) {
                        HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail",
                            __func__, __LINE__, VignetteCompensation.CalibTablePath, SrcAddr[i]);
                        close(Fid);
                        return -1;
                    }
                }
                close(Fid);
            }
            /*
            if (_TextHdlr_Save_Ext_File(VignetteCompensation.CalibTablePath, ITUNER_VIGNETTE_GAIN_MAP_SIZE, VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain) < 0) {
                HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail",
                        __func__, __LINE__, VignetteCompensation.CalibTablePath, VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain);
                return -1;
            }
            */
        } else {
            HDLR_WARF("%s() %d, EXT_FILE_VIGNETTE_GAIN, VignetteGain Address: %p %p %p %p",
                    __func__, __LINE__,
                    VignetteCalcInfo.CalibVignetteInfo.pVignetteRedGain,
                    VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenEvenGain,
                    VignetteCalcInfo.CalibVignetteInfo.pVignetteGreenOddGain,
                    VignetteCalcInfo.CalibVignetteInfo.pVignetteBlueGain);
        }
    } else {
        HDLR_DEBF("%s() %d, Vignette Disable, Skip Dump Process", __func__, __LINE__);
    }
    return 0;
}
static int _TextHdlr_Save_Warp_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    char FilePath[64];
    ITUNER_WARP_s WarpCompensation;
    AmbaItuner_Get_WarpCompensation(&WarpCompensation);
    if (WarpCompensation.Enable) {
        amba_img_dsp_warp_calc_info_t WarpCalcInfo;
        AmbaItuner_Get_WarpCalcInfo(&WarpCalcInfo);
        if (WarpCalcInfo.CalibWarpInfo.pWarp != NULL) {
            UINT32 Warp_Table_Size = ITUNER_CAL_WARP_TABLE_SIZE(WarpCompensation.HorizontalGridNumber, WarpCompensation.VerticalGridNumber);
            _TextHdlr_Get_Ext_File_Path(EXT_FILE_WARP_TABLE, FilePath);
            strncpy(WarpCompensation.WarpGridTablePath, FilePath, sizeof(WarpCompensation.WarpGridTablePath));
            AmbaItuner_Set_WarpCompensation(&WarpCompensation);
            HDLR_DEBF("%s() %d, Dump Warp Table Address %p, size %d, to %s",
                    __func__, __LINE__, WarpCalcInfo.CalibWarpInfo.pWarp,  Warp_Table_Size, WarpCompensation.WarpGridTablePath);
            if (_TextHdlr_Save_Ext_File(WarpCompensation.WarpGridTablePath, Warp_Table_Size, WarpCalcInfo.CalibWarpInfo.pWarp) < 0) {
                HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail",
                        __func__, __LINE__, WarpCompensation.WarpGridTablePath, WarpCalcInfo.CalibWarpInfo.pWarp);
                return -1;
            }
        } else {
            HDLR_WARF("%s() %d, EXT_FILE_WARP_TABLE, WarpTable Address: NULL", __func__, __LINE__);
        }
    } else {
        HDLR_DEBF("%s() %d, Warp Disable, Skip Dump Process", __func__, __LINE__);
    }
    return 0;
}
static int _TextHdlr_Save_Ca_Table(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    char FilePath[64];
    ITUNER_CHROMA_ABERRATION_s ChromaAberrationInfo;
    AmbaItuner_Get_ChromaAberrationInfo(&ChromaAberrationInfo);
    if (ChromaAberrationInfo.Enable) {
        AMBA_DSP_IMG_CAWARP_CALC_INFO_s CACalcInfo;
        AmbaItuner_Get_CACalcInfo(&CACalcInfo);
        if (CACalcInfo.CalibCaWarpInfo.pCaWarp != NULL) {
            UINT32 CA_Table_Size = ITUNER_CAL_CA_TABLE_SIZE(ChromaAberrationInfo.HorizontalGridNumber, ChromaAberrationInfo.VerticalGridNumber);
            _TextHdlr_Get_Ext_File_Path(EXT_FILE_CA_TABLE, FilePath);
            strncpy(ChromaAberrationInfo.CaGridTablePath, FilePath, sizeof(ChromaAberrationInfo.CaGridTablePath));
            AmbaItuner_Set_ChromaAberrationInfo(&ChromaAberrationInfo);
            HDLR_DEBF("%s() %d, Dump Ca Table Address %p, size %d, to %s",
                    __func__, __LINE__, CACalcInfo.CalibCaWarpInfo.pCaWarp,  CA_Table_Size, ChromaAberrationInfo.CaGridTablePath);
            if (_TextHdlr_Save_Ext_File(ChromaAberrationInfo.CaGridTablePath, CA_Table_Size, CACalcInfo.CalibCaWarpInfo.pCaWarp) < 0) {
                HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail",
                        __func__, __LINE__, ChromaAberrationInfo.CaGridTablePath, CACalcInfo.CalibCaWarpInfo.pCaWarp);
                return -1;
            }
        } else {
            HDLR_WARF("%s() %d, EXT_FILE_CA_TABLE, Ca_Table Address: NULL", __func__, __LINE__);
        }
    } else {
        HDLR_DEBF("%s() %d, Ca Disable, Skip Dump Process", __func__, __LINE__);
    }
    return 0;
}

static int _TextHdlr_Save_CC_Reg(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    char FilePath[64];
    amba_img_dsp_color_correction_reg_t CcReg;
    AmbaItuner_Get_CcReg(&CcReg);
    if (CcReg.RegSettingAddr != 0){
        HDLR_DEBF("%s() %d, Dump CC Reg", __func__, __LINE__);
        // Note: Update ColorCorrection Path
        _TextHdlr_Get_Ext_File_Path(EXT_FILE_CC_REG, FilePath);
        ITUNER_COLOR_CORRECTION_s ColorCorrection;
        AmbaItuner_Get_ColorCorrection(&ColorCorrection);
        strncpy(ColorCorrection.RegPath, FilePath, sizeof(ColorCorrection.RegPath));
        AmbaItuner_Set_ColorCorrection(&ColorCorrection);
        HDLR_DEBF("%s() %d, Dump CC Reg Address %p to %s", __func__, __LINE__,  (void*)CcReg.RegSettingAddr, ColorCorrection.RegPath);
        if (_TextHdlr_Save_Ext_File(ColorCorrection.RegPath, AMBA_DSP_IMG_CC_REG_SIZE, (void*)CcReg.RegSettingAddr) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail", __func__, __LINE__, ColorCorrection.RegPath, (void*)CcReg.RegSettingAddr);
            return -1;
        }

    } else {
        HDLR_WARF("%s() %d, EXT_FILE_CC_REG, RegSettingAddr = NULL", __func__, __LINE__);
    }
    return 0;
}
static int _TextHdlr_Save_CC_ThreeD(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    char FilePath[64];
    amba_img_dsp_color_correction_t CcThreed;
    AmbaItuner_Get_CcThreeD(&CcThreed);
    if (CcThreed.MatrixThreeDTableAddr != 0) {
        _TextHdlr_Get_Ext_File_Path(EXT_FILE_CC_THREED, FilePath);
        ITUNER_COLOR_CORRECTION_s ColorCorrection;
        AmbaItuner_Get_ColorCorrection(&ColorCorrection);
        strncpy(ColorCorrection.ThreeDPath, FilePath, sizeof(ColorCorrection.ThreeDPath));
        AmbaItuner_Set_ColorCorrection(&ColorCorrection);
        HDLR_DEBF("%s() %d, Dump CC ThreeD Address %p to %s", __func__, __LINE__,  (void*)CcThreed.MatrixThreeDTableAddr, ColorCorrection.ThreeDPath);
        if (_TextHdlr_Save_Ext_File(ColorCorrection.ThreeDPath, AMBA_DSP_IMG_CC_3D_SIZE, (void*)CcThreed.MatrixThreeDTableAddr) < 0) {
            HDLR_WARF("%s() %d, call _TextHdlr_Save_Ext_File(%s, Addr : %p) Fail", __func__, __LINE__, ColorCorrection.ThreeDPath, (void*)CcThreed.MatrixThreeDTableAddr);
            return -1;
        }
    }
    return 0;
}

static int _TextHdlr_Save_Y(Save_Data_to_Path_Info_s *Y_Info)
{
    ITUNER_SYSTEM_s System;
    char FilePath[64] = {0};
    char *FileName_Pos;
    char *Ext_Name_Pos;
//    AMBA_FS_FILE *Fd;
    int fd;
    if ((Y_Info->Address == NULL) || (Y_Info->Size == 0)) {
        HDLR_WARF("%s() %d, Y Addr = %p, Size = %d", __func__, __LINE__, Y_Info->Address, Y_Info->Size);
        return -1;
    }
    AmbaItuner_Get_SystemInfo(&System);
    memset(FilePath, 0x0, sizeof(FilePath));
    strncpy(FilePath, Y_Info->Target_File_Path, sizeof(FilePath));
//    if (0 != _TextHdlr_Change_System_Drive(FilePath)) {
//        HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, FilePath);
//        return -1;
//    }
    FileName_Pos = strrchr(FilePath, '\\');
//    if (FileName_Pos == NULL) {
//        HDLR_WARF("%s() %d, FilePath : %s Invalid FileName_Pos: %s", __func__, __LINE__, FilePath, FileName_Pos);
//        return -1;
//    }
    UINT8 Output_Filename_Len = strlen(System.OutputFilename);
    if (Output_Filename_Len) {
        sprintf(FileName_Pos + 1, "%s", System.OutputFilename);
        Ext_Name_Pos = FileName_Pos + 1 + strlen(System.OutputFilename);
    } else {
        Ext_Name_Pos = strrchr(FilePath, '.');
        if (Ext_Name_Pos == NULL) {
            HDLR_WARF("%s() %d, Invalid FilePath : %s", __func__, __LINE__, FilePath);
            return -1;
        }

    }
    sprintf(Ext_Name_Pos, ".y");
//    Fd = AmbaFS_fopen(FilePath, "w");
    fd = open(FilePath, O_WRONLY | O_CREAT, 0666);
    if (fd <0) {
        HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, FilePath);
        return -1;
    }
    write(fd, Y_Info->Address, Y_Info->Size);
    close(fd);
    return 0;
}

static int _TextHdlr_Save_UV(Save_Data_to_Path_Info_s *UV_Info)
{
    ITUNER_SYSTEM_s System;
    char FilePath[64] = {0};
    char *FileName_Pos;
    char *Ext_Name_Pos;
//  AMBA_FS_FILE *Fd;
    int fd;
    if ((UV_Info->Address == NULL) || (UV_Info->Size == 0)) {
        HDLR_WARF("%s() %d, UV Addr = %p, Size = %d", __func__, __LINE__, UV_Info->Address, UV_Info->Size);
        return -1;
    }
    AmbaItuner_Get_SystemInfo(&System);
    memset(FilePath, 0x0, sizeof(FilePath));
    strncpy(FilePath, UV_Info->Target_File_Path, sizeof(FilePath));
//  if (0 != _TextHdlr_Change_System_Drive(FilePath)) {
//      HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s)", __func__, __LINE__, FilePath);
//      return -1;
//  }

  FileName_Pos = strrchr(FilePath, '\\');
//  if (FileName_Pos == NULL) {
//      HDLR_WARF("%s() %d, Invalid FileName_Pos: %s", __func__, __LINE__, FileName_Pos);
//      return -1;
//  }
    UINT8 Output_Filename_Len = strlen(System.OutputFilename);
    if (Output_Filename_Len) {
        sprintf(FileName_Pos + 1, "%s", System.OutputFilename);
        Ext_Name_Pos = FileName_Pos + 1 + strlen(System.OutputFilename);
    } else {
        Ext_Name_Pos = strrchr(FilePath, '.');
        if (Ext_Name_Pos == NULL) {
            HDLR_WARF("%s() %d, Invalid FilePath : %s", __func__, __LINE__, FilePath);
            return -1;
        }

    }
    sprintf(Ext_Name_Pos, ".uv");
//  Fd = AmbaFS_fopen(FilePath, "w");
    fd = open(FilePath, O_WRONLY | O_CREAT, 0666);
    if (fd <0) {
        HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, FilePath);
        return -1;
    }
    write(fd, UV_Info->Address, UV_Info->Size);
    close(fd);
    return 0;
}

static int _TextHdlr_Save_YUV(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    int Ret = 0;
    Ret |= _TextHdlr_Save_Y(&Ext_File_Param->YUV_Save_Param.Y_Info);
    Ret |= _TextHdlr_Save_UV(&Ext_File_Param->YUV_Save_Param.UV_Info);
    return Ret;
}

static int _TextHdlr_Save_and_Load_Dummy(Ituner_Ext_File_Param_s *Ext_File_Param)
{
    HDLR_WARF("%s() %d, Not Yet Implement", __func__, __LINE__);
    return 0;
}

int TextHdlr_Load_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s* Ext_File_Param)
{
    int (*Load_Data_Api_List[EXT_FILE_MAX])(Ituner_Ext_File_Param_s *Ext_File_Param) =
    {
        _TextHdlr_Load_FPN_Map, // EXT_FILE_FPN_MAP
        _TextHdlr_Load_Bypass_FPN_Map,
        _TextHldr_Load_Vignette,
        _TextHldr_Load_Bypass_Vignette,
        _TextHdlr_Load_Warp_Table,
        _TextHdlr_Load_Bypass_Horizontal_Table,
        _TextHdlr_Load_Bypass_Vertical_Table,
        _TextHdlr_Load_Ca_Table,
        _TextHldr_Load_Bypass_Ca_Horizontal_Table,
        _TextHdlr_Load_Bypass_Ca_Vertical_Table,
        _TextHdlr_Load_CC_Reg,
        _TextHdlr_Load_CC_ThreeD,
        _TextHdlr_Load_Raw,
        _TextHdlr_Save_and_Load_Dummy, //EXT_FILE_JPG
        _TextHdlr_Save_and_Load_Dummy, //EXT_FILE_YUV
    };
    if (Ext_File_Type >= EXT_FILE_MAX) {
        HDLR_ERRF("%s() %d, Invalid Ext_File_Type %d", __func__, __LINE__, Ext_File_Type);
        return -1;
    }
    return Load_Data_Api_List[Ext_File_Type](Ext_File_Param);
}

int TextHdlr_Save_Data(Ituner_Ext_File_Type_e Ext_File_Type, Ituner_Ext_File_Param_s* Ext_File_Param)
{
    int (*Save_Data_Api_List[EXT_FILE_MAX])(Ituner_Ext_File_Param_s *Ext_File_Param) =
    {
        _TextHdlr_Save_FPN_Map, // EXT_FILE_FPN_MAP
        _TextHdlr_Save_and_Load_Dummy,//_TextHdlr_Save_Bypass_FPN_Map,
        _TextHdlr_Save_Vignette,
        _TextHdlr_Save_and_Load_Dummy,//_TextHldr_Save_Bypass_Vignette,
        _TextHdlr_Save_Warp_Table,
        _TextHdlr_Save_and_Load_Dummy,//_TextHdlr_Save_Bypass_Horizontal_Table,
        _TextHdlr_Save_and_Load_Dummy,//_TextHdlr_Save_Bypass_Vertical_Table,
        _TextHdlr_Save_Ca_Table,
        _TextHdlr_Save_and_Load_Dummy, //_TextHldr_Save_Bypass_Ca_Horizontal_Table,
        _TextHdlr_Save_and_Load_Dummy, //_TextHdlr_Save_Bypass_Ca_Vertical_Table,
        _TextHdlr_Save_CC_Reg,
        _TextHdlr_Save_CC_ThreeD,
        _TextHdlr_Save_and_Load_Dummy, //_TextHdlr_Save_Raw,
        _TextHdlr_Save_and_Load_Dummy,
        _TextHdlr_Save_YUV,
    };
    if (Ext_File_Type >= EXT_FILE_MAX) {
        HDLR_ERRF("%s() %d, Invalid Ext_File_Type %d", __func__, __LINE__, Ext_File_Type);
        return -1;
    }
    return Save_Data_Api_List[Ext_File_Type](Ext_File_Param);
}


static int _TextHdlr_load_Ext_file(char *FileName, int Size, void *Buf)
{
//    AMBA_FS_FILE *Fid;
    int Fid;
//    char UniFname[64];
    int Ret = 0;
/*    if (0 != _TextHdlr_Change_System_Drive(FileName)) {
        HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, FileName);
        return -1;
    }
    asc_to_uni(FileName, UniFname);*/
//    Fid = AmbaFS_fopen(UniFname, "r");

    Fid = open(FileName, O_RDONLY, 0);
    if (Fid < 0) {
        HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, FileName);
        return -1;
    }
    //if (AmbaFS_fread(Buf, Size, 1, Fid)) {
    if (read(Fid, Buf, Size)!=Size) {
	    HDLR_WARF("%s() %d, call AmbaFS_fread() Fail, Buf: %p, Size: %d", __func__, __LINE__, Buf, Size);
	    Ret = -2;
    }
//    AmbaFS_fclose(Fid);
    close(Fid);
    return Ret;
}

static int _TextHdlr_Save_Ext_File(char *FileName, int Size, void *Buf)
{
//    AMBA_FS_FILE *Fid;
    int Fid;
//    char UniFname[64];
    int Ret = 0;
/*    if (0 != _TextHdlr_Change_System_Drive(FileName)) {
        HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, FileName);
        return -1;
    }
    asc_to_uni(FileName, UniFname);*/
//    Fid = AmbaFS_fopen(UniFname, "w");
    Fid = open(FileName, O_WRONLY | O_CREAT, 0666);
    if (Fid == 0) {
        HDLR_WARF("%s() %d, call AmbaFS_fopen(%s) Fail", __func__, __LINE__, FileName);
        return -1;
    }
//    if (AmbaFS_fwrite(Buf, Size, 1, Fid)) {
    if (write(Fid, Buf, Size)>0) {

    } else {
        HDLR_WARF("%s() %d, call AmbaFS_fwrite() Fail, Buf: %p, Size: %d", __func__, __LINE__, Buf, Size);
        Ret = -2;
    }
//    AmbaFS_fclose(Fid);
    close(Fid);

    return Ret;
}
static int _TextHdlr_Fill_Ext_File_Path(void)
{
    AMBA_ITUNER_VALID_FILTER_t Ituner_Valid;
    AmbaItuner_Get_FilterStatus(&Ituner_Valid);
    // Note: Without Return Fail, Because it should be happen.
    if (Ituner_Valid[ITUNER_COLOR_CORRECTION] == 1) {
        if (0 != TextHdlr_Save_Data(EXT_FILE_CC_REG, NULL)) {
            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_CC_REG) Fail", __func__, __LINE__);
        }
        if (0 != TextHdlr_Save_Data(EXT_FILE_CC_THREED, NULL)) {
            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_CC_THREED) Fail", __func__, __LINE__);
        }
    }
    if (Ituner_Valid[ITUNER_STATIC_BAD_PIXEL_CORRECTION] == 1) {
        if (0 != TextHdlr_Save_Data(EXT_FILE_FPN_MAP, NULL)) {
            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_FPN_MAP) Fail", __func__, __LINE__);
        }
    }
    if (Ituner_Valid[ITUNER_VIGNETTE_COMPENSATION] == 1) {
        if (0 != TextHdlr_Save_Data(EXT_FILE_VIGNETTE_GAIN, NULL)) {
            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_VIGNETTE_GAIN) Fail", __func__, __LINE__);
        }
    }
    if (Ituner_Valid[ITUNER_WARP_COMPENSATION] == 1) {
        if (0 != TextHdlr_Save_Data(EXT_FILE_WARP_TABLE, NULL)) {
            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_WARP_TABLE) Fail", __func__, __LINE__);
        }
    }
    if (Ituner_Valid[ITUNER_CHROMA_ABERRATION_INFO] == 1) {
        if (0 != TextHdlr_Save_Data(EXT_FILE_CA_TABLE, NULL)) {
            HDLR_WARF("%s() %d, call TextHdlr_Save_Data(EXT_FILE_CA_TABLE) Fail", __func__, __LINE__);
        }
    }
    return 0;
}
int TextHdlr_Load_ituner(char* ituner_stream)
{
	char *Buf = NULL;
	int BufSize = 0;

	int RegIndex;
	int ParamIndex;
	int txtdatasize = 0;
	char endofr='\r';
	char endchangelin='\n';
	char endkey ='!';
	REG_s *Reg;
	ITUNER_INFO_s ItunerInfo;


	// Note: Refresh GData, System...
	TextHdlr_Get_ItunerInfo(&ItunerInfo);
	if (0 != _TextHdlr_Update_System_Info(ItunerInfo.TuningAlgoMode)) {
		HDLR_WARF("%s() %d, call _TextHdlr_Update_System_Info() Fail", __func__, __LINE__);
		return -1;
	}
	if (0 != AmbaItuner_Refresh(ItunerInfo.TuningAlgoMode)) {
		HDLR_WARF("%s() %d, call AmbaItuner_Refresh() Fail", __func__, __LINE__);
		return -1;
	}
	if (0 != _TextHdlr_Fill_Ext_File_Path()) {
		HDLR_WARF("%s() %d, call _TextHdlr_Fill_Ext_File_Path() Fail", __func__, __LINE__);
		return -1;
	}

	TUNE_Parser_Set_Reglist_Valid(SKIP_VALID_CHECK, _Ituner.ParserObject);
	TUNER_Parser_Set_Reg_Valid("internal", 0, _Ituner.ParserObject);

	if (0 != TUNE_Parser_Get_LineBuf(_Ituner.ParserObject, &Buf, &BufSize)) {
		HDLR_WARF("%s() %d, call TUNE_Parser_Get_LineBuf() Fail", __func__, __LINE__);
		return -1;
	}

	TUNE_Parser_Set_Opmode(ITUNER_ENC);
	AMBA_ITUNER_VALID_FILTER_t Filter_Status;
	AmbaItuner_Get_FilterStatus(&Filter_Status);
	// TODO : Remove _Ituner.ParserObject->RegCount, use api to get count
	for (RegIndex = 0; RegIndex < _Ituner.ParserObject->RegCount; RegIndex++) {
		Reg = TUNE_Parser_Get_Reg(RegIndex, _Ituner.ParserObject);
		if (Reg == NULL) {
			HDLR_WARF("%s() %d, Reg %d is NULL", __func__, __LINE__, RegIndex);
			continue;
		}

		if (Filter_Status[Reg->Index] == 0) {
			continue;
		}
		for (ParamIndex = 0; ParamIndex < Reg->ParamCount; ParamIndex++) {
			if (0 != TUNE_Parser_Generate_Line(RegIndex, ParamIndex, _Ituner.ParserObject)) {
				continue;
			}

		//	_save_line(Fd, Buf);
			//AmbaPrintColor(YELLOW, "%s", Buf);
			memcpy((ituner_stream+txtdatasize),Buf,strlen(Buf));
			txtdatasize=txtdatasize+strlen(Buf);
			*(ituner_stream+txtdatasize-sizeof(char))=endofr;
			*(ituner_stream+txtdatasize)=endchangelin;
			txtdatasize=txtdatasize+sizeof(char);
		}
	}
	//****endmark of ituner file**************//

//	*(ituner_stream+txtdatasize)=endoft;
//	*(ituner_stream+txtdatasize+sizeof(char))=endoft;
//	*(ituner_stream+txtdatasize+2*sizeof(char))=endoft;
//	*(ituner_stream+txtdatasize+3*sizeof(char))=endofr;
//	*(ituner_stream+txtdatasize+4*sizeof(char))=endchangelin;
	*(ituner_stream+txtdatasize)=endkey;

	printf("ituner file size =%d\n",txtdatasize+1);
	return txtdatasize+1;
}

int TextHdlr_Save_IDSP(amba_img_dsp_mode_cfg_t Mode, char *Filepath)
{
	//char AscFilepath[64];
	FILE *Fd;
	int RegIndex;
	int ParamIndex;
	REG_s *Reg;
	strncpy(Ituner_File_Path, Filepath, sizeof(Ituner_File_Path));
	// Note: Refresh GData, System...
	if (0 != _TextHdlr_Update_System_Info(Mode)) {
	    HDLR_WARF("%s() %d, call _TextHdlr_Update_System_Info() Fail", __func__, __LINE__);
	    return -1;
	}
	if (0 != AmbaItuner_Refresh(Mode)) {
	    HDLR_WARF("%s() %d, call AmbaItuner_Refresh() Fail", __func__, __LINE__);
	    return -1;
	}
	if (0 != _TextHdlr_Fill_Ext_File_Path()) {
	    HDLR_WARF("%s() %d, call _TextHdlr_Fill_Ext_File_Path() Fail", __func__, __LINE__);
	    return -1;
	}
	TUNE_Parser_Set_Reglist_Valid(SKIP_VALID_CHECK, _Ituner.ParserObject);
	//uni_to_asc(Filepath, AscFilepath);
    TUNER_Parser_Set_Reg_Valid("internal", 0, _Ituner.ParserObject);
//	if (0 != _TextHdlr_Change_System_Drive(Filepath)) {
//	    HDLR_WARF("%s() %d, call _TextHdlr_Change_System_Drive(%s) Fail", __func__, __LINE__, Filepath);
//	    return -1;
//	}

    char *Buf = NULL;
    int BufSize = 0;
    if (0 != TUNE_Parser_Get_LineBuf(_Ituner.ParserObject, &Buf, &BufSize)) {
        HDLR_WARF("%s() %d, call TUNE_Parser_Get_LineBuf() Fail", __func__, __LINE__);
        return -1;
    }
    Fd = fopen(Filepath, "w");
    if (Fd == 0) {
        HDLR_WARF("%s() %d, File %s open fail!", __func__, __LINE__, Filepath);
        return -1;
    }
    TUNE_Parser_Set_Opmode(ITUNER_ENC);
    AMBA_ITUNER_VALID_FILTER_t Filter_Status;
    AmbaItuner_Get_FilterStatus(&Filter_Status);
    // TODO : Remove _Ituner.ParserObject->RegCount, use api to get count
    for (RegIndex = 0; RegIndex < _Ituner.ParserObject->RegCount; RegIndex++) {
        Reg = TUNE_Parser_Get_Reg(RegIndex, _Ituner.ParserObject);
        if (Reg == NULL) {
            HDLR_WARF("%s() %d, Reg %d is NULL", __func__, __LINE__, RegIndex);
            continue;
        }
        if (Filter_Status[Reg->Index] == 0) {
                continue;
        }
            for (ParamIndex = 0; ParamIndex < Reg->ParamCount; ParamIndex++) {
            if (0 != TUNE_Parser_Generate_Line(RegIndex, ParamIndex, _Ituner.ParserObject)) {
                continue;
            }
            _save_line(Fd, Buf);
        }
    }
    fclose(Fd);

	return 0;
}




static AMBA_DSP_IMG_PIPE_e _TextHdlr_Get_Imag_Pipe(TUNING_MODE_e TuningMode)
{
    AMBA_DSP_IMG_PIPE_e ImagePipe;

    switch(TuningMode)
    {
    case IMG_MODE_VIDEO:
    case IMG_MODE_PREVIEW:
    case IMG_MODE_HIGH_ISO_VIDEO:
            ImagePipe = AMBA_DSP_IMG_PIPE_VIDEO;
            break;
    case IMG_MODE_STILL:
    case IMG_MODE_LOW_ISO_STILL:
    case IMG_MODE_MID_ISO_STILL:
    case IMG_MODE_HIGH_ISO_STILL:
    case IMG_MODE_NIGHT_PORTRAIT_STILL:
            ImagePipe = AMBA_DSP_IMG_PIPE_STILL;
            break;
        default:
            ImagePipe = AMBA_DSP_IMG_PIPE_VIDEO;
            break;
    }

    return ImagePipe;
}

static AMBA_DSP_IMG_ALGO_MODE_e _TextHdlr_Get_Image_Algo_Mode(TUNING_MODE_e TuningMode)
{
    AMBA_DSP_IMG_ALGO_MODE_e ImageAlgoMode;

    switch(TuningMode)
    {
        case IMG_MODE_PREVIEW:
        case IMG_MODE_VIDEO:
        case IMG_MODE_LOW_ISO_STILL:
            ImageAlgoMode = AMBA_DSP_IMG_ALGO_MODE_LISO;
            break;
        case IMG_MODE_HIGH_ISO_STILL:
        case IMG_MODE_HIGH_ISO_VIDEO:
            ImageAlgoMode = AMBA_DSP_IMG_ALGO_MODE_HISO;
            break;
        case IMG_MODE_STILL:
        case IMG_MODE_MID_ISO_STILL:
        case IMG_MODE_NIGHT_PORTRAIT_STILL:
        default:
            ImageAlgoMode = AMBA_DSP_IMG_ALGO_MODE_FAST;
            break;
    }

    return ImageAlgoMode;

}



