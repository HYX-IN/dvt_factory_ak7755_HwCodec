diff --git a/Documentation/arm/ambarella/self-refresh.txt b/Documentation/arm/ambarella/self-refresh.txt
new file mode 100644
index 0000000..209b8ee
--- /dev/null
+++ b/Documentation/arm/ambarella/self-refresh.txt
@@ -0,0 +1,140 @@
+
+Copyright (C) 2016-2019, Ambarella, Inc.
+Author: Cao Rongrong <rrcao@ambarella.com>
+
+
+Introduction
+============
+
+The kernel supports up to four system sleep states generically.
+From shallowest to deepest, they are:
+1) freeze:   Suspend-To-Idle / ACPI S0
+2) standby:  Standby / Power-On Suspend / ACPI S1
+3) mem:      Suspend-To-RAM / Self-Refresh / STR / ACPI S3
+4) disk:     Suspend-To-Disk / STD / ACPI S4
+
+For details, pelase see Documentation/powr/states.txt
+
+Here we just talk about "mem", i.e., Self-Refresh (abbreviated as SR).
+
+In short words, when system is in SR, all the HWs except for DRAM and PWC are
+powered off.
+
+
+
+SR and DRAM
+============
+
+At present we can support SR with DDR3 and LPDDR3, other DRAM types are not
+tested, yet.
+
+One of the differences between DDR3 and LPDDR3 is that DDR3 has a "RESET" pin
+while LPDDR3 doesn't have. When entering into SR, the "RESET" pin must be pulled
+high. Unfortunately, when in SR state, the SoC will be powered off and pull the
+the "RESET" pin low, so we have to add a workaround with the help of HW design,
+i.e., using a GPIO to control the triode to cut off the "RESET" signal to DRAM.
+
+Different boards design may use different GPIO, and both BST and Kernel need to
+know which GPIO is used to cut off the "RESET" signal.
+1) For BST, we define the GPIO in .ini file by "DRAM_RESET_CTRL_GPIO",
+   please see "ini" section below.
+2) For Kernel, we define the GPIO in .dts file by "ambarella,dram-reset-ctrl",
+   please see "Device Tree" section below.
+
+Note:
+  Although LPDDR3 doesn't have the "RESET" pin, you also need to define the GPIO
+  in .ini file, because this GPIO definition, i.e., "DRAM_RESET_CTRL_GPIO", also
+  acts as another role, that is, tell BST to support SR.
+  In other words, if "DRAM_RESET_CTRL_GPIO" is NOT defined in .ini file, BST will
+  boot system directly, but not check if it's cold boot or resume from SR when
+  powered on.
+  For LPDDR3, you can define "DRAM_RESET_CTRL_GPIO" as any meaningful GPIO as
+  long as this GPIO does not affect system booting.
+
+[!!!IMPORTANT!!!]
+  IF SELF-REFRESH IS NOT USED, "DRAM_RESET_CTRL_GPIO" MUST BE REMOVED FROM .ini
+  FILE, OTHERWISE SYSTEM MAY NOT BOOT UP OR REBOOT SUCCESSFULLY.
+
+
+
+SR and PWC (Power Control)
+==========================
+
+SR must co-work with PWC, and there are two options to use PWC:
+1) internal PWC, but not all SoCs have internal PWC
+2) external PWC (MCU)
+PS: for those SoCs without internal PWC, you have to use external MCU.
+
+If the board design is to use external MCU for power sequence control, the SoC
+needs to communicate with the MCU through a GPIO, and the protocol is:
+1) SoC keeps the GPIO high 100ms to notify MCU to enter self-refresh. After
+100ms, SoC should keep the GPIO low.
+2) MCU notifies SoC the state after powered up:
+2.1) if cold boot, MCU keeps the GPIO high.
+2.2) if resume from SR, MCU keeps the GPIO low.
+
+Different boards design may use different GPIO, and both BST and Kernel need to
+know which GPIO is used to communicate with the external MCU.
+1) For BST, we define the GPIO in .ini file by "MCU_NOTIFY_GPIO",
+   please see "ini" section below.
+2) For Kernel, we define the GPIO in .dts file by "ambarella,gpio-notify-mcu",
+   please see "Device Tree" section below.
+
+Note:
+  It's allowed to either use two separate GPIOs or use one GPIO to communicate
+  between SoC and MCU, it's determined by the MCU firmware.
+
+
+
+Driver Configuration
+====================
+
+Power management options  --->
+         [*] Suspend to RAM and standby
+         [*] User space wakeup sources interface
+         (100) Maximum number of user space wakeup sources (0 = no limit)
+         -*- Device power management core functionality
+
+
+
+Device Tree
+===========
+
+Please see Documentation/devicetree/bindings/arm/ambarella.txt
+               -> 2) - Informational node -> ii) /chosen
+
+
+
+ini
+===
+
+In .ini file, there are two fields related to SR:
+
+1) "DRAM_RESET_CTRL_GPIO", e.g., <DRAM_RESET_CTRL_GPIO value="5"/>
+   No matter DDR3 or LPDDR3, this field has to be set as long as SR is used.
+   Please see the "Note" in "SR and DRAM" section.
+
+2) "MCU_NOTIFY_GPIO", e.g., <MCU_NOTIFY_GPIO value="33"/>
+   This filed need to be set only when external MCU is used. If using internal
+   PWC, this filed must NOT be set.
+
+
+
+Usage
+=====
+
+1) Entering into SR
+root@/#echo mem > /sys/power/state
+
+2) Resume from SR by power button
+Press the button directly
+
+3) Resume from SR by RTC
+root@/#echo enabled > /sys/class/rtc/rtc0/device/power/wakeup
+root@/#rtcwake -s 10 -m mem
+PS: 
+  a) this is available only when using internal PWC.
+  b) rtc,wakeup has to be added into rtc node in DTS.
+
+
+
diff --git a/Documentation/devicetree/bindings/arm/ambarella.txt b/Documentation/devicetree/bindings/arm/ambarella.txt
index 146e1da..8bbbbe7 100644
--- a/Documentation/devicetree/bindings/arm/ambarella.txt
+++ b/Documentation/devicetree/bindings/arm/ambarella.txt
@@ -171,7 +171,10 @@ i) Reference
 Please see Documentation/devicetree/bindings/arm/cpus.txt
 
 ii) Properties
-- cpufreq_tbl: Table of frequencies gclk_cortex and pll_out_core could be transitioned
+- amb,core-div: this prop should be 1 or 2, this specified the divide of gclk_core from pll_out_core,
+  for s2e and s5, this value should be 1; and for s2l, s3l, this should be 2. If you don't add this prop,
+  the divide for gclk_core is 2 as default.
+- cpufreq_tbl: Table of frequencies gclk_cortex and gclk_core could be transitioned
   into, in the unit of nanoseconds.
 - clock-latency: Specify the possible maximum transition latency for clock, in
   unit of nanoseconds.
@@ -295,10 +298,21 @@ Required properties:
 - compatible: should be "ambarella,dma".
 - reg: specifies base physical address and size of the registers.
 - interrupts: the interrupt for the DMA controller.
+- #dma-cells: Must be at least 1. Used to provide DMA controller
+			specific information. See DMA client binding below for
+			more details.
+- dma-channels: 	Number of DMA channels supported by the controller.
+- dma-requests: 	Number of DMA requests signals supported by the
+			controller.
+- dma-trans-type:   specifies the dma channel use type.
+					0 for memcpy, 1 for slave.
 
 Optional properties:
 - amb,copy-align: specifies alignment requirement for previous chips.
 - amb,support-prs: should be specified for SoC that supports PAUSE/RESUME/STOP.
+- dma-channel-sel: should be specified for Soc that support dma channel sel.
+  different value is used for selecting the device.
+  e.g., 0 for ssi0_tx, 1 for ssi0_rx, 10 for i2s_tx, 11 for i2s_rx.
 
 ii) Example
 -----------
@@ -306,6 +320,11 @@ ii) Example
 		compatible = "ambarella,dma";
 		reg = <0xe0005000 0x1000>;
 		interrupts = <15 0x4>;
+		#dma-cells = <2>;
+		dma-channels = <8>;
+		dma-requests = <12>;
+		dma-trans-type = <1 1 0 0 1 1 1 1>; /* 0-memcpy ,1-slave*/
+		dma-channel-sel = <4 5 0 0 8 9 11 10>;
 	};
 
 
@@ -393,7 +412,6 @@ Required properties:
 - reg: specifies base physical address and size of the registers.
 - pinctrl-names: should contain only one value - "default".
 - pinctrl-0: pin control group to be used for this controller.
-- bclk_reverse: control i2s_clk(BCLK) to reverse.
 - amb,i2s-channels: should be one of these values: 2, 4, 6.
 - amb,default-mclk: specifies the initial mclk frequency in HZ.
 
@@ -404,7 +422,6 @@ ii) Example
 		reg = <0xe001a000 0x1000>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&i2s0_pins>;
-		bclk_reverse = <0>;
 		amb,i2s-channels = <2>;
 		amb,default-mclk = <12288000>;
 	};
@@ -487,19 +504,24 @@ Required properties:
 - amb,clk-name: specifies the PLL name of this SD controller, should be one
   of these strings: "gclk_sd", "gclk_sdio", "gclk_sdxc".
 - amb,wait-tmo: specifies the timeout in millisecond to wait for CMD complete.
+- amb,switch-vol-tmo: specifies the timeout to enable clk after switch voltage
+  from 3.3v to 1.8v.
 - amb,max-blk-size: specifies the maximal block size, should be multiple of 4k.
 
 Optional properties:
 - amb,dma-addr-fix: should be specified only for S2.
-- amb,soft-phy: should be specified for SD controllers supporting soft phy.
+- amb,soft-phy: should be specified for SD controllers to adjust timing base on
+  SD phy.
 - amb,phy-timing: an integer array which is used to specify the SD phy timing,
   the size of the array is different according to corresponding phy register
   for each chips or SD controllers, and the values are gotten by SD shmoo in
   Amboot.
-  For the SD controller supporting soft SD phy, like S2E SD0, the array is
-  orgnized as: <mode phy_ctrl0_val latency_ctrl_val>
+  For the SD controller to ajust timing base on SD controller, like S3L and later
+  chip, the array is orgnized as: <mode SD_DELAY_SEL_L SD_DELAY_SEL_H>;
+  For the SD controller to ajust timing base on SD phy, like S2E SD0, S2L, S3L, the
+  array is orgnized as: <mode phy_ctrl0_val latency_ctrl_val>;
   For the SD controller only supporting ms delay mux, like S2E SD1, the array
-  is orgnized as: <mode ms_delay_ctrl_mask ms_delay_ctrl_val>
+  is orgnized as: <mode ms_delay_ctrl_mask ms_delay_ctrl_val>;
   Here mode is the ORed value of SD card working modes like sdr104, ddr50 and
   etc., and the later 2 items are values written to corresponding phy registers.
   Following is the definition of each bits for mode:
@@ -521,6 +543,40 @@ Optional properties:
     #define MMC_TIMING_UHS_DDR50	7
     #define MMC_TIMING_MMC_HS200	8
 
+Example for ajusting timing base sd controller on s3l platform:
+		sdmmc0: sdmmc0@e0002000 {
+			compatible = "ambarella,sdmmc";
+			reg = <0xe0002000 0x1000>,
+			      <0xe0001000 0x80>;/* fio reg address */
+			amb,max-blk-size = <131072>; /* valid value: 4K<<n */
+			amb,soft-phy;
+			amb,phy-timing = <0x00000007 0x00000000 0x00000000>,/*HS 50M and 25M*/
+					/*sdr25 50M,sdr50 100M,sdr104 120M*/
+					<0x00000078 0x10410400 0x00904104>,
+					<0x00000080 0x38E38E00 0x0238E38E>;/*DDR50 50M*/
+			slot@0 {
+
+			};
+		};
+
+
+Example for ajusting timing base sd phy on s3l platform:
+		sdmmc0: sdmmc0@e0002000 {
+			compatible = "ambarella,sdmmc";
+			reg = <0xe0002000 0x1000>,
+			      <0xe0001000 0x80>;/* fio reg address */
+			      <0xec1704c0 0x8>;/*should specify the phy register*/
+
+			amb,soft-phy;
+			amb,phy-timing = <0x00000001 0x04070000 0x00000000>,
+					/*sdr12 24M,sdr25 50M,sdr50 100M*/
+					<0x00000038 0x00000003 0x00001111>,
+					<0x00000040 0x00000005 0x00002222>,/*sdr104 200M*/
+					<0x00000080 0x000C0005 0x00000000>;/*ddr50 50M*/
+			slot@0 {
+
+			};
+		};
 
 iii) Subnode
 ------------
@@ -597,7 +653,11 @@ Optional properties:
 - amb,dump-rx: specifies to dump Rx buffer, for debug purpose.
 - amb,dump-rx-free: specifies to free buffer after dumped.
 - amb,dump-rx-all: specifies to dump all buffers without filter.
-
+- amb,mdio-gpio: specifies using mdio gpio to access phy.
+- amb,clk-src: specifies the clk source for gtx_clk, 0:external clk, 1:internal clk.
+- amb,clk-invert: specifies to invert the clk for ethernet, 0: no invert, 1: invert
+- amb,clk-dir: specifies the ref clk direction from PHY, 1: set direction of xx_enet_clk_rx as output from ambarella chip,
+  0: set direction of xx_enet_clk_rx as output from external phy.
 ii) Example
 -----------
 	mac0: ethernet@e000e000 {
@@ -631,11 +691,15 @@ Required properties:
 - reg: specifies base physical address and size of the registers.
 - interrupts: the interrupt for the SPI controller.
 - amb,clk-freq: specifies the PLL frequence in HZ.
-- amb,dma-used: use dma for TX/RX, should be specified if SPI channel supports dma mode.
-- amb,msb-first-only: HW only supports msb first tx/rx, for A5S/S2/S2E, please set this flag.
+- amb,msb-first-only: HW only supports msb first tx/rx, for A5S/S2/S2E, please
+  set this flag.
+- cs-gpios: gpios chip select. Please see Reference for detailed.
 
 Optional properties:
-- cs-gpios: gpios chip select. Please see Reference for detailed.
+- amb,dma-used: use dma for TX/RX, only can be specified if SPI channel
+  supports dma mode.
+- dmas: specify dma channel
+- dma-names: specify dma channel name.
 
 iii) Subnode
 ------------
@@ -768,8 +832,8 @@ should only have one group node pointed in there.
 Required subnode-properties:
 - reg: Should be the index of the group nodes for same function.
 - amb,pinmux-ids: an integer array. Each integer in the array specifies a pin
-  with given mux function, with pin id and mux and config packed as:
-    config << 16 | mux << 12 | pin id
+  with given mux function, with pin id and mux packed as:
+    mux << 12 | pin id
   Here mux means function of this pin, and pin id is identical to gpio id. For
   the SoC supporting IOMUX, like S2L, the maximal value of mux is 5. However,
   for the SoC not supporting IOMUX, like A5S, S2, the third or fourth function
@@ -777,8 +841,11 @@ Required subnode-properties:
   there is no real hardware pins mapping to the corresponding register address.
   So the registers for the "virtual pins" can be used for the selection of 3rd
   or 4th function for other real pins.
-  Further more, config is used to configure pull up/down and drive strength of
-  the pin, and it's orgnization is:
+- amb,pinconf-ids: an integer array. Each integer in the array specifies a pin
+  with given configuration, with pin id and config packed as:
+    config << 16 | pin id
+  Here config is used to configure pull up/down and drive strength of the pin,
+  and it's orgnization is:
   bit1~0: 00: pull down, 01: pull up, 1x: clear pull up/down
   bit2:   reserved
   bit3:   0: leave pull up/down as default value, 1: config pull up/down
@@ -807,8 +874,9 @@ v) Example
 
 		sdmmc0_pins_4bit: sdmmc0@1 {
 			reg = <1>;
-			amb,pinmux-ids = <0x00092039 0x00b0203a 0x00aa203b 0x0000203c
-					  0x00002049 0x0000204a 0x0000204b 0x0000204c>;
+			amb,pinmux-ids = <0x2039 0x203a 0x203b 0x203c
+							  0x2049 0x204a 0x204b 0x204c>;
+			amb,pinconf-ids = <0x090039 0xb0003a 0xaa003b 0x00003c>;
 		};
 	}
 
@@ -818,7 +886,7 @@ pin40(0x28), i.e., GPIO39 and GPIO40. And, pin39/pin40 use function 1.
 And, sdmmc0_pins_4bit defines a group of pins used by sd0 controller, according
 to the definition, sd0 uses 8 pins. And pin57 enables pull up, pin58 configure
 drive strength to 12mA, pin59 clear pull up/down and configure drive strength
-to 8mA, while other pins leave pull up/down and drive strength as default value.
+to 8mA, pin60 leave pull up/down and drive strength as default value.
 
 
 20) - GPIO node
@@ -940,8 +1008,10 @@ Required properties:
 - amb,i2c-class:
   a) 0x81: normal I2C controller
   b) 0x08: I2C controller dedicated to HDMI
-- amb,bulk-num: the maximal number of data which can be transfered in a
-  single msg, recommended value is 60.
+- amb,turbo-mode: use turbo(FIFO) write mode, batched data will be write into FIFO
+directly, but there're 2 restriction for this mode:
+  1) FIFO mode will ignore device ACK.
+  2) FIFO mode can only write less than or equal to 61 data(FIFO depth) into FIFO at a time.
 - amb,duty-cycle: the duty cycle of clock, and the value can be:
     0 = duty cycle 1:1, this is the default setting.
     1 = duty cycle 2:3.
@@ -970,7 +1040,7 @@ iii) Example
 		pinctrl-0 = <&i2c0_pins>;
 		clock-frequency = <100000>;
 		amb,i2c-class = <0x81>;
-		amb,bulk-num = <60>;
+		amb,turbo-mode;
 		amb,duty-cycle = <0>;
 		status = "ok";
 
@@ -1251,8 +1321,8 @@ It is a waster of power, so we do not use it.
 - amb,codec-dai-name: specifies the DAI name within the codec, it must be consistent with the codec driver.
 - amb,audio-routing: specifies the route map for audio codec.
 usage:
-	amb,audio-routing = "sink", source",/*This is route 0*/
-			 "sink", "source";/*This is route 1*/
+	amb,audio-routing = "sink", source",	/*This is route 0*/
+			    "sink", "source";	/*This is route 1*/
 	sink and source dapm widget should be based on codec driver and our board.
 	dapm widget on board:
 	"Mic internal": board internal Mic, used to connect Mic of codec.
diff --git a/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt b/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt
index a4873e5..e30e184 100644
--- a/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt
+++ b/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt
@@ -38,7 +38,7 @@ dma_apbx: dma-apbx@80024000 {
 		      80 81 68 69
 		      70 71 72 73
 		      74 75 76 77>;
-	interrupt-names = "auart4-rx", "aurat4-tx", "spdif-tx", "empty",
+	interrupt-names = "auart4-rx", "auart4-tx", "spdif-tx", "empty",
 			  "saif0", "saif1", "i2c0", "i2c1",
 			  "auart0-rx", "auart0-tx", "auart1-rx", "auart1-tx",
 			  "auart2-rx", "auart2-tx", "auart3-rx", "auart3-tx";
diff --git a/Documentation/devicetree/bindings/iio/magnetometer/ak8975.txt b/Documentation/devicetree/bindings/iio/magnetometer/ak8975.txt
new file mode 100644
index 0000000..011679f
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/magnetometer/ak8975.txt
@@ -0,0 +1,18 @@
+* AsahiKASEI AK8975 magnetometer sensor
+
+Required properties:
+
+  - compatible : should be "asahi-kasei,ak8975"
+  - reg : the I2C address of the magnetometer
+
+Optional properties:
+
+  - gpios : should be device tree identifier of the magnetometer DRDY pin
+
+Example:
+
+ak8975@0c {
+        compatible = "asahi-kasei,ak8975";
+        reg = <0x0c>;
+        gpios = <&gpj0 7 0>;
+};
diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt
index 01ef408..8faff12 100644
--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt
+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt
@@ -91,5 +91,5 @@ mpp61         61       gpo, dev(wen1), uart1(txd), audio(rclk)
 mpp62         62       gpio, dev(a2), uart1(cts), tdm(drx), pcie(clkreq0),
                        audio(mclk), uart0(cts)
 mpp63         63       gpo, spi0(sck), tclk
-mpp64         64       gpio, spi0(miso), spi0-1(cs1)
-mpp65         65       gpio, spi0(mosi), spi0-1(cs2)
+mpp64         64       gpio, spi0(miso), spi0(cs1)
+mpp65         65       gpio, spi0(mosi), spi0(cs2)
diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt
index bfa0a2e..86dec67 100644
--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt
+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt
@@ -41,15 +41,15 @@ mpp20         20       gpio, ge0(rxd4), ge1(rxd2), lcd(d20), ptp(clk)
 mpp21         21       gpio, ge0(rxd5), ge1(rxd3), lcd(d21), mem(bat)
 mpp22         22       gpio, ge0(rxd6), ge1(rxctl), lcd(d22), sata0(prsnt)
 mpp23         23       gpio, ge0(rxd7), ge1(rxclk), lcd(d23), sata1(prsnt)
-mpp24         24       gpio, lcd(hsync), sata1(prsnt), nf(bootcs-re), tdm(rst)
-mpp25         25       gpio, lcd(vsync), sata0(prsnt), nf(bootcs-we), tdm(pclk)
-mpp26         26       gpio, lcd(clk), tdm(fsync), vdd(cpu1-pd)
+mpp24         24       gpio, lcd(hsync), sata1(prsnt), tdm(rst)
+mpp25         25       gpio, lcd(vsync), sata0(prsnt), tdm(pclk)
+mpp26         26       gpio, lcd(clk), tdm(fsync)
 mpp27         27       gpio, lcd(e), tdm(dtx), ptp(trig)
 mpp28         28       gpio, lcd(pwm), tdm(drx), ptp(evreq)
-mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk), vdd(cpu0-pd)
+mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk)
 mpp30         30       gpio, tdm(int1), sd0(clk)
-mpp31         31       gpio, tdm(int2), sd0(cmd), vdd(cpu0-pd)
-mpp32         32       gpio, tdm(int3), sd0(d0), vdd(cpu1-pd)
+mpp31         31       gpio, tdm(int2), sd0(cmd)
+mpp32         32       gpio, tdm(int3), sd0(d0)
 mpp33         33       gpio, tdm(int4), sd0(d1), mem(bat)
 mpp34         34       gpio, tdm(int5), sd0(d2), sata0(prsnt)
 mpp35         35       gpio, tdm(int6), sd0(d3), sata1(prsnt)
@@ -57,21 +57,18 @@ mpp36         36       gpio, spi(mosi)
 mpp37         37       gpio, spi(miso)
 mpp38         38       gpio, spi(sck)
 mpp39         39       gpio, spi(cs0)
-mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), vdd(cpu1-pd),
-                       pcie(clkreq0)
+mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), pcie(clkreq0)
 mpp41         41       gpio, spi(cs2), uart2(rts), lcd(vga-vsync), sata1(prsnt),
                        pcie(clkreq1)
-mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer),
-                       vdd(cpu0-pd)
-mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout),
-                       vdd(cpu2-3-pd){1}
+mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer)
+mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout)
 mpp44         44       gpio, uart2(cts), uart3(rxd), spi(cs4), pcie(clkreq2),
                        mem(bat)
 mpp45         45       gpio, uart2(rts), uart3(txd), spi(cs5), sata1(prsnt)
 mpp46         46       gpio, uart3(rts), uart1(rts), spi(cs6), sata0(prsnt)
 mpp47         47       gpio, uart3(cts), uart1(cts), spi(cs7), pcie(clkreq3),
                        ref(clkout)
-mpp48         48       gpio, tclk, dev(burst/last)
+mpp48         48       gpio, dev(clkout), dev(burst/last)
 
 * Marvell Armada XP (mv78260 and mv78460 only)
 
@@ -83,9 +80,9 @@ mpp51         51       gpio, dev(ad16)
 mpp52         52       gpio, dev(ad17)
 mpp53         53       gpio, dev(ad18)
 mpp54         54       gpio, dev(ad19)
-mpp55         55       gpio, dev(ad20), vdd(cpu0-pd)
-mpp56         56       gpio, dev(ad21), vdd(cpu1-pd)
-mpp57         57       gpio, dev(ad22), vdd(cpu2-3-pd){1}
+mpp55         55       gpio, dev(ad20)
+mpp56         56       gpio, dev(ad21)
+mpp57         57       gpio, dev(ad22)
 mpp58         58       gpio, dev(ad23)
 mpp59         59       gpio, dev(ad24)
 mpp60         60       gpio, dev(ad25)
@@ -95,6 +92,3 @@ mpp63         63       gpio, dev(ad28)
 mpp64         64       gpio, dev(ad29)
 mpp65         65       gpio, dev(ad30)
 mpp66         66       gpio, dev(ad31)
-
-Notes:
-* {1} vdd(cpu2-3-pd) only available on mv78460.
diff --git a/Documentation/devicetree/bindings/spi/spi_pl022.txt b/Documentation/devicetree/bindings/spi/spi_pl022.txt
index 22ed679..4d1673c 100644
--- a/Documentation/devicetree/bindings/spi/spi_pl022.txt
+++ b/Documentation/devicetree/bindings/spi/spi_pl022.txt
@@ -4,9 +4,9 @@ Required properties:
 - compatible : "arm,pl022", "arm,primecell"
 - reg : Offset and length of the register set for the device
 - interrupts : Should contain SPI controller interrupt
+- num-cs : total number of chipselects
 
 Optional properties:
-- num-cs : total number of chipselects
 - cs-gpios : should specify GPIOs used for chipselects.
   The gpios will be referred to as reg = <index> in the SPI child nodes.
   If unspecified, a single SPI device without a chip select can be used.
diff --git a/Documentation/filesystems/efivarfs.txt b/Documentation/filesystems/efivarfs.txt
index c477af0..686a64b 100644
--- a/Documentation/filesystems/efivarfs.txt
+++ b/Documentation/filesystems/efivarfs.txt
@@ -14,3 +14,10 @@ filesystem.
 efivarfs is typically mounted like this,
 
 	mount -t efivarfs none /sys/firmware/efi/efivars
+
+Due to the presence of numerous firmware bugs where removing non-standard
+UEFI variables causes the system firmware to fail to POST, efivarfs
+files that are not well-known standardized variables are created
+as immutable files.  This doesn't prevent removal - "chattr -i" will work -
+but it does prevent this kind of failure from being accomplished
+accidentally.
diff --git a/Documentation/scsi/scsi_eh.txt b/Documentation/scsi/scsi_eh.txt
index 6ff16b6..c08b62d 100644
--- a/Documentation/scsi/scsi_eh.txt
+++ b/Documentation/scsi/scsi_eh.txt
@@ -255,19 +255,23 @@ scmd->allowed.
 
  3. scmd recovered
     ACTION: scsi_eh_finish_cmd() is invoked to EH-finish scmd
-	- shost->host_failed--
 	- clear scmd->eh_eflags
 	- scsi_setup_cmd_retry()
 	- move from local eh_work_q to local eh_done_q
     LOCKING: none
+    CONCURRENCY: at most one thread per separate eh_work_q to
+		 keep queue manipulation lockless
 
  4. EH completes
     ACTION: scsi_eh_flush_done_q() retries scmds or notifies upper
-	    layer of failure.
+	    layer of failure. May be called concurrently but must have
+	    a no more than one thread per separate eh_work_q to
+	    manipulate the queue locklessly
 	- scmd is removed from eh_done_q and scmd->eh_entry is cleared
 	- if retry is necessary, scmd is requeued using
           scsi_queue_insert()
 	- otherwise, scsi_finish_command() is invoked for scmd
+	- zero shost->host_failed
     LOCKING: queue or finish function performs appropriate locking
 
 
diff --git a/Documentation/sysctl/fs.txt b/Documentation/sysctl/fs.txt
index 88152f2..302b5ed 100644
--- a/Documentation/sysctl/fs.txt
+++ b/Documentation/sysctl/fs.txt
@@ -32,6 +32,8 @@ Currently, these files are in /proc/sys/fs:
 - nr_open
 - overflowuid
 - overflowgid
+- pipe-user-pages-hard
+- pipe-user-pages-soft
 - protected_hardlinks
 - protected_symlinks
 - suid_dumpable
@@ -159,6 +161,27 @@ The default is 65534.
 
 ==============================================================
 
+pipe-user-pages-hard:
+
+Maximum total number of pages a non-privileged user may allocate for pipes.
+Once this limit is reached, no new pipes may be allocated until usage goes
+below the limit again. When set to 0, no limit is applied, which is the default
+setting.
+
+==============================================================
+
+pipe-user-pages-soft:
+
+Maximum total number of pages a non-privileged user may allocate for pipes
+before the pipe size gets limited to a single page. Once this limit is reached,
+new pipes will be limited to a single page in size for this user in order to
+limit total memory usage, and trying to increase them using fcntl() will be
+denied until usage goes below the limit again. The default value allows to
+allocate up to 1024 pipes at their default size. When set to 0, no limit is
+applied.
+
+==============================================================
+
 protected_hardlinks:
 
 A long-standing class of security issues is the hardlink-based
diff --git a/MAINTAINERS b/MAINTAINERS
index 48c7480..29d7d74 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -3032,8 +3032,8 @@ F:	Documentation/x86/efi-stub.txt
 F:	arch/ia64/kernel/efi.c
 F:	arch/x86/boot/compressed/eboot.[ch]
 F:	arch/x86/include/asm/efi.h
-F:	arch/x86/platform/efi/*
-F:	drivers/firmware/efi/*
+F:	arch/x86/platform/efi/
+F:	drivers/firmware/efi/
 F:	include/linux/efi*.h
 
 EFI VARIABLE FILESYSTEM
diff --git a/Makefile b/Makefile
index b112909..f6a2cbd 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,6 @@
 VERSION = 3
 PATCHLEVEL = 10
-SUBLEVEL = 73
+SUBLEVEL = 104
 EXTRAVERSION =
 NAME = TOSSUG Baby Fish
 
@@ -241,7 +241,7 @@ CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
 
 HOSTCC       = gcc
 HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89
 HOSTCXXFLAGS = -O2
 
 # Decide whether to build built-in, modular, or both.
@@ -373,7 +373,9 @@ KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
 		   -fno-strict-aliasing -fno-common \
 		   -Werror-implicit-function-declaration \
 		   -Wno-format-security \
-		   -fno-delete-null-pointer-checks
+		   -fno-delete-null-pointer-checks \
+		   -std=gnu89
+
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
 KBUILD_AFLAGS   := -D__ASSEMBLY__
diff --git a/arch/alpha/mm/fault.c b/arch/alpha/mm/fault.c
index 98838a0..9d0ac09 100644
--- a/arch/alpha/mm/fault.c
+++ b/arch/alpha/mm/fault.c
@@ -156,6 +156,8 @@ retry:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/arc/include/asm/cmpxchg.h b/arch/arc/include/asm/cmpxchg.h
index 03cd689..90de5c5 100644
--- a/arch/arc/include/asm/cmpxchg.h
+++ b/arch/arc/include/asm/cmpxchg.h
@@ -25,10 +25,11 @@ __cmpxchg(volatile void *ptr, unsigned long expected, unsigned long new)
 	"	scond   %3, [%1]	\n"
 	"	bnz     1b		\n"
 	"2:				\n"
-	: "=&r"(prev)
-	: "r"(ptr), "ir"(expected),
-	  "r"(new) /* can't be "ir". scond can't take limm for "b" */
-	: "cc");
+	: "=&r"(prev)	/* Early clobber, to prevent reg reuse */
+	: "r"(ptr),	/* Not "m": llock only supports reg direct addr mode */
+	  "ir"(expected),
+	  "r"(new)	/* can't be "ir". scond can't take LIMM for "b" */
+	: "cc", "memory"); /* so that gcc knows memory is being written here */
 
 	return prev;
 }
diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 2046a89..7848549 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -83,7 +83,7 @@ struct callee_regs {
 	long r13;
 };
 
-#define instruction_pointer(regs)	((regs)->ret)
+#define instruction_pointer(regs)	(unsigned long)((regs)->ret)
 #define profile_pc(regs)		instruction_pointer(regs)
 
 /* return 1 if user mode or 0 if kernel mode */
diff --git a/arch/arc/kernel/signal.c b/arch/arc/kernel/signal.c
index 7e95e1a..6763654 100644
--- a/arch/arc/kernel/signal.c
+++ b/arch/arc/kernel/signal.c
@@ -131,6 +131,15 @@ SYSCALL_DEFINE0(rt_sigreturn)
 	/* Don't restart from sigreturn */
 	syscall_wont_restart(regs);
 
+	/*
+	 * Ensure that sigreturn always returns to user mode (in case the
+	 * regs saved on user stack got fudged between save and sigreturn)
+	 * Otherwise it is easy to panic the kernel with a custom
+	 * signal handler and/or restorer which clobberes the status32/ret
+	 * to return to a bogus location in kernel mode.
+	 */
+	regs->status32 |= STATUS_U_MASK;
+
 	return regs->r0;
 
 badframe:
@@ -234,8 +243,11 @@ setup_rt_frame(int signo, struct k_sigaction *ka, siginfo_t *info,
 
 	/*
 	 * handler returns using sigreturn stub provided already by userpsace
+	 * If not, nuke the process right away
 	 */
-	BUG_ON(!(ka->sa.sa_flags & SA_RESTORER));
+	if(!(ka->sa.sa_flags & SA_RESTORER))
+		return 1;
+
 	regs->blink = (unsigned long)ka->sa.sa_restorer;
 
 	/* User Stack for signal handler will be above the frame just carved */
@@ -302,12 +314,12 @@ handle_signal(unsigned long sig, struct k_sigaction *ka, siginfo_t *info,
 	      struct pt_regs *regs)
 {
 	sigset_t *oldset = sigmask_to_save();
-	int ret;
+	int failed;
 
 	/* Set up the stack frame */
-	ret = setup_rt_frame(sig, ka, info, oldset, regs);
+	failed = setup_rt_frame(sig, ka, info, oldset, regs);
 
-	if (ret)
+	if (failed)
 		force_sigsegv(sig, current);
 	else
 		signal_delivered(sig, info, ka, regs, 0);
diff --git a/arch/arc/kernel/stacktrace.c b/arch/arc/kernel/stacktrace.c
index ca0207b..06997ad 100644
--- a/arch/arc/kernel/stacktrace.c
+++ b/arch/arc/kernel/stacktrace.c
@@ -131,7 +131,7 @@ arc_unwind_core(struct task_struct *tsk, struct pt_regs *regs,
 	 * prelogue is setup (callee regs saved and then fp set and not other
 	 * way around
 	 */
-	pr_warn("CONFIG_ARC_DW2_UNWIND needs to be enabled\n");
+	pr_warn_once("CONFIG_ARC_DW2_UNWIND needs to be enabled\n");
 	return 0;
 
 #endif
diff --git a/arch/arc/kernel/unwind.c b/arch/arc/kernel/unwind.c
index a8d0222..14558a9 100644
--- a/arch/arc/kernel/unwind.c
+++ b/arch/arc/kernel/unwind.c
@@ -984,42 +984,13 @@ int arc_unwind(struct unwind_frame_info *frame)
 							    (const u8 *)(fde +
 									 1) +
 							    *fde, ptrType);
-				if (pc >= endLoc)
+				if (pc >= endLoc) {
 					fde = NULL;
-			} else
-				fde = NULL;
-		}
-		if (fde == NULL) {
-			for (fde = table->address, tableSize = table->size;
-			     cie = NULL, tableSize > sizeof(*fde)
-			     && tableSize - sizeof(*fde) >= *fde;
-			     tableSize -= sizeof(*fde) + *fde,
-			     fde += 1 + *fde / sizeof(*fde)) {
-				cie = cie_for_fde(fde, table);
-				if (cie == &bad_cie) {
 					cie = NULL;
-					break;
 				}
-				if (cie == NULL
-				    || cie == &not_fde
-				    || (ptrType = fde_pointer_type(cie)) < 0)
-					continue;
-				ptr = (const u8 *)(fde + 2);
-				startLoc = read_pointer(&ptr,
-							(const u8 *)(fde + 1) +
-							*fde, ptrType);
-				if (!startLoc)
-					continue;
-				if (!(ptrType & DW_EH_PE_indirect))
-					ptrType &=
-					    DW_EH_PE_FORM | DW_EH_PE_signed;
-				endLoc =
-				    startLoc + read_pointer(&ptr,
-							    (const u8 *)(fde +
-									 1) +
-							    *fde, ptrType);
-				if (pc >= startLoc && pc < endLoc)
-					break;
+			} else {
+				fde = NULL;
+				cie = NULL;
 			}
 		}
 	}
diff --git a/arch/arc/mm/fault.c b/arch/arc/mm/fault.c
index 50533b7..08f65bc 100644
--- a/arch/arc/mm/fault.c
+++ b/arch/arc/mm/fault.c
@@ -160,6 +160,8 @@ good_area:
 	/* TBD: switch to pagefault_out_of_memory() */
 	if (fault & VM_FAULT_OOM)
 		goto out_of_memory;
+	else if (fault & VM_FAULT_SIGSEGV)
+		goto bad_area;
 	else if (fault & VM_FAULT_SIGBUS)
 		goto do_sigbus;
 
diff --git a/arch/arc/mm/tlbex.S b/arch/arc/mm/tlbex.S
index 3357d26..74691e6 100644
--- a/arch/arc/mm/tlbex.S
+++ b/arch/arc/mm/tlbex.S
@@ -219,7 +219,7 @@ ex_saved_reg1:
 #ifdef CONFIG_SMP
 	sr  r0, [ARC_REG_SCRATCH_DATA0]	; freeup r0 to code with
 	GET_CPU_ID  r0			; get to per cpu scratch mem,
-	lsl r0, r0, L1_CACHE_SHIFT	; cache line wide per cpu
+	asl r0, r0, L1_CACHE_SHIFT	; cache line wide per cpu
 	add r0, @ex_saved_reg1, r0
 #else
 	st    r0, [@ex_saved_reg1]
@@ -239,7 +239,7 @@ ex_saved_reg1:
 .macro TLBMISS_RESTORE_REGS
 #ifdef CONFIG_SMP
 	GET_CPU_ID  r0			; get to per cpu scratch mem
-	lsl r0, r0, L1_CACHE_SHIFT	; each is cache line wide
+	asl r0, r0, L1_CACHE_SHIFT	; each is cache line wide
 	add r0, @ex_saved_reg1, r0
 	ld_s  r3, [r0,12]
 	ld_s  r2, [r0, 8]
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 224f75d..3d8fbe2 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -58,6 +58,14 @@ endif
 
 comma = ,
 
+#
+# The Scalar Replacement of Aggregates (SRA) optimization pass in GCC 4.9 and
+# later may result in code being generated that handles signed short and signed
+# char struct members incorrectly. So disable it.
+# (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65932)
+#
+KBUILD_CFLAGS	+= $(call cc-option,-fno-ipa-sra)
+
 # This selects which instruction set is used.
 # Note that GCC does not numerically define an architecture version
 # macro, but instead defines a whole series of macros which makes
diff --git a/arch/arm/boot/dts/ambarella-a5s.dtsi b/arch/arm/boot/dts/ambarella-a5s.dtsi
index 2dd1d73..9c19118 100644
--- a/arch/arm/boot/dts/ambarella-a5s.dtsi
+++ b/arch/arm/boot/dts/ambarella-a5s.dtsi
@@ -17,6 +17,7 @@
 		serial0 = &uart0;
 		serial1 = &uart1;
 		nand = &nand0;
+		emmc = &sdmmc0;
 		i2c0 = &i2c0;
 		i2c1 = &i2c1;
 		spi0 = &spi0;
@@ -97,7 +98,6 @@
 			pinctrl-0 = <&i2c0_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x81>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -111,7 +111,6 @@
 			pinctrl-0 = <&i2c1_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x08>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -351,10 +350,14 @@
 			      <0x60010000 0x1000>;
 		};
 
-		dma@60005000 {
+		dma: dma@60005000 {
 			compatible = "ambarella,dma";
 			reg = <0x60005000 0x1000>;
 			interrupts = <15 0x4>;
+			#dma-cells = <2>;
+			dma-channels = <4>;
+			dma-requests = <4>;
+			dma-trans-type = <0 1 1 0>; /* 0-memcpy ,1-slave*/
 			amb,copy-align = <3>;
 		};
 
@@ -381,9 +384,11 @@
 			reg = <0x6000a000 0x1000>;
 			pinctrl-names = "default";
 			pinctrl-0 = <&i2s0_pins>;
-			bclk_reverse = <0>;
 			amb,i2s-channels = <2>;
 			amb,default-mclk = <12288000>;
+			dmas = <&dma 1 1>,
+				   <&dma 0 1>;
+			dma-names = "tx", "rx";
 		};
 
 		udc@60006000 {
@@ -393,7 +398,7 @@
 			amb,usbphy = <&usbphy>;
 		};
 
-		sdmmc0@60002000 {
+		sdmmc0: sdmmc0@60002000 {
 			compatible = "ambarella,sdmmc";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -401,7 +406,8 @@
 			      <0x60001000 0x80>; /* fio reg address */
 			interrupts = <18 0x4>;
 			amb,clk-name = "gclk_sd";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <20>;
 			amb,max-blk-size = <524288>; /* valid value: 4K<<n */
 			status = "disabled";
 
@@ -461,9 +467,17 @@
 		};
 	};
 
+	iav {
+		compatible = "ambarella,iav";
+	};
+
 	bogus_bus {
 		compatible = "simple-bus";
 		#address-cells = <1>;
 		#size-cells = <0>;
+
+		dummycodec: codec@0 {
+			compatible = "ambarella,dummycodec";
+		};
 	};
 };
diff --git a/arch/arm/boot/dts/ambarella-s2.dtsi b/arch/arm/boot/dts/ambarella-s2.dtsi
index 949af1a..d9674e2 100644
--- a/arch/arm/boot/dts/ambarella-s2.dtsi
+++ b/arch/arm/boot/dts/ambarella-s2.dtsi
@@ -19,6 +19,8 @@
 		serial2 = &uart2;
 		serial3 = &uart3;
 		nand = &nand0;
+		sd0 = &sdmmc0;
+		sd1 = &sdmmc1;
 		i2c0 = &i2c0;
 		i2c1 = &i2c1;
 		i2c2 = &i2c2;
@@ -136,7 +138,6 @@
 			pinctrl-0 = <&i2c0_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x81>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -150,7 +151,6 @@
 			pinctrl-0 = <&i2c1_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x08>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -164,7 +164,6 @@
 			pinctrl-0 = <&i2c2_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x81>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -398,10 +397,14 @@
 		reg = <0x60000000 0x01000000>;
 		ranges;
 
-		dma@60005000 {
+		dma: dma@60005000 {
 			compatible = "ambarella,dma";
 			reg = <0x60005000 0x1000>;
 			interrupts = <0 15 0x4>;
+			#dma-cells = <2>;
+			dma-channels = <5>;
+			dma-requests = <5>;
+			dma-trans-type = <0 1 1 1 1>; /* 0-memcpy ,1-slave*/
 			amb,copy-align = <3>;
 		};
 
@@ -426,9 +429,11 @@
 			reg = <0x6000a000 0x1000>;
 			pinctrl-names = "default";
 			pinctrl-0 = <&i2s0_pins>;
-			bclk_reverse = <0>;
 			amb,i2s-channels = <2>;
 			amb,default-mclk = <12288000>;
+			dmas = <&dma 1 1>,
+				   <&dma 0 1>;
+			dma-names = "tx", "rx";
 		};
 
 		udc@60006000 {
@@ -454,7 +459,7 @@
 			status = "disabled";
 		};
 
-		sdmmc0@60002000 {
+		sdmmc0: sdmmc0@60002000 {
 			compatible = "ambarella,sdmmc";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -463,7 +468,8 @@
 			      <0x701701d0 0x4>;
 			interrupts = <0 18 0x4>;
 			amb,clk-name = "gclk_sd";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <20>;
 			amb,max-blk-size = <524288>; /* valid value: 4K<<n */
 			amb,phy-timing = <0x00000001 0xe3e0e3e0 0x00000000>,
 					 <0x00000080 0xe3e0e3e0 0x00071c00>;
@@ -480,7 +486,7 @@
 			};
 		};
 
-		sdmmc1@6000c000 {
+		sdmmc1: sdmmc1@6000c000 {
 			compatible = "ambarella,sdmmc";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -490,7 +496,8 @@
 			interrupts = <0 52 0x4>;
 			amb,dma-addr-fix;
 			amb,clk-name = "gclk_sdio";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <20>;
 			amb,max-blk-size = <524288>; /* valid value: 4K<<n */
 			amb,phy-timing = <0x00000001 0x1c1f1c1f 0x00000000>,
 					 <0x00000080 0x1c1f1c1f 0x00e0e000>;
@@ -554,6 +561,10 @@
 		};
 	};
 
+	iav {
+		compatible = "ambarella,iav";
+	};
+
 	bogus_bus {
 		compatible = "simple-bus";
 		#address-cells = <1>;
diff --git a/arch/arm/boot/dts/ambarella-s2e.dtsi b/arch/arm/boot/dts/ambarella-s2e.dtsi
index cfc05ba..cfd40da 100644
--- a/arch/arm/boot/dts/ambarella-s2e.dtsi
+++ b/arch/arm/boot/dts/ambarella-s2e.dtsi
@@ -19,6 +19,8 @@
 		serial2 = &uart2;
 		serial3 = &uart3;
 		nand = &nand0;
+		sd0 = &sdmmc0;
+		sd1 = &sdmmc1;
 		i2c0 = &i2c0;
 		i2c1 = &i2c1;
 		i2c2 = &i2c2;
@@ -41,6 +43,7 @@
 	cpus {
 		#address-cells = <1>;
 		#size-cells = <0>;
+		amb,core-div = <1>;
 		clock-latency = <100000>;
 		/* the highest frequency is gotten in runtime */
 		cpufreq_tbl = < /*core_clk	cortex_clk*/
@@ -138,7 +141,6 @@
 			pinctrl-0 = <&i2c0_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x81>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -152,7 +154,6 @@
 			pinctrl-0 = <&i2c1_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x08>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -166,7 +167,6 @@
 			pinctrl-0 = <&i2c2_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x81>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -182,18 +182,6 @@
 			amb,msb-first-only;
 		};
 
-		spi1: spi@7000f000 {
-			compatible = "ambarella,spi";
-			#address-cells = <1>;
-			#size-cells = <0>;
-			reg = <0x7000f000 0x1000>;
-			interrupts = <53 0x4>;
-			pinctrl-names = "default";
-			pinctrl-0 = <&spi1_pins>;
-			amb,clk-freq = <54000000>;
-			status = "disabled";
-		};
-
 		spi_slave@7001e000 {
 			compatible = "ambarella,spi-slave";
 			reg = <0x7001e000 0x1000>;
@@ -228,6 +216,7 @@
 		rtc@7000d000 {
 			compatible = "ambarella,rtc";
 			reg = <0x7000d000 0x1000>;
+			rtc,wakeup;
 		};
 
 		pwm: pwm@70004000 {
@@ -431,10 +420,14 @@
 			      <0x6001c000 0x1000>;
 		};
 
-		dma@60005000 {
+		dma: dma@60005000 {
 			compatible = "ambarella,dma";
 			reg = <0x60005000 0x1000>;
 			interrupts = <15 0x4>;
+			#dma-cells = <2>;
+			dma-channels = <8>;
+			dma-requests = <8>;
+			dma-trans-type = <1 1 1 1 1 1 1 1>; /* 0-memcpy ,1-slave*/
 			amb,copy-align = <0>;
 			/* support pause/resume/stop */
 			amb,support-prs;
@@ -464,14 +457,28 @@
 			status = "disabled";
 		};
 
+		spi1: spi@6001f000 {
+			compatible = "ambarella,spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x6001f000 0x1000>;
+			interrupts = <53 0x4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi1_pins>;
+			amb,clk-freq = <54000000>;
+			status = "disabled";
+		};
+
 		i2s0: i2s@6000a000 {
 			compatible = "ambarella,i2s";
 			reg = <0x6000a000 0x1000>;
 			pinctrl-names = "default";
 			pinctrl-0 = <&i2s0_pins>;
-			bclk_reverse = <0>;
 			amb,i2s-channels = <2>;
 			amb,default-mclk = <12288000>;
+			dmas = <&dma 2 1>,
+				   <&dma 1 1>;
+			dma-names = "tx", "rx";
 		};
 
 		udc@60006000 {
@@ -495,7 +502,7 @@
 			amb,usbphy = <&usbphy>;
 		};
 
-		sdmmc0@60002000 {
+		sdmmc0: sdmmc0@60002000 {
 			compatible = "ambarella,sdmmc";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -504,11 +511,13 @@
 			      <0x70170340 0x8>;
 			interrupts = <18 0x4>;
 			amb,clk-name = "gclk_sd";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <20>;
 			amb,max-blk-size = <524288>; /* valid value: 4K<<n */
-			amb,soft-phy;
+			amb,auto-tuning;
+			amb,phy-type = <0>;/*0:rct phy, 1: sd controller phy, 2: for s2e*/
 			amb,phy-timing = <0x00000001 0x04070000 0x00000000>,
-					 <0x000000a0 0x00000005 0x00001111>,
+					 <0x000000a4 0x00000005 0x00001111>,
 					 <0x00000040 0x00000001 0x00001111>;
 			pinctrl-names = "default";
 			pinctrl-0 = <&sdmmc0_pins>;
@@ -519,12 +528,11 @@
 				max-frequency = <50000000>;
 				bus-width = <8>;
 				amb,caps-adma;
-				amb,caps-ddr;
 				cap-sdio-irq;
 			};
 		};
 
-		sdmmc1@6000c000 {
+		sdmmc1: sdmmc1@6000c000 {
 			compatible = "ambarella,sdmmc";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -533,8 +541,11 @@
 			      <0x701701d0 0x4>;
 			interrupts = <52 0x4>;
 			amb,clk-name = "gclk_sdio";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <20>;
 			amb,max-blk-size = <524288>; /* valid value: 4K<<n */
+			amb,auto-tuning;
+			amb,phy-type = <2>;/*0:rct phy, 1: sd controller phy, 2: for s2e*/
 			amb,phy-timing = <0x00000001 0x1c1f1c1f 0x00000000>,
 					 <0x00000080 0x1c1f1c1f 0x00e0e000>;
 			pinctrl-names = "default";
@@ -546,7 +557,6 @@
 				max-frequency = <50000000>;
 				bus-width = <4>;
 				amb,caps-adma;
-				amb,caps-ddr;
 				cap-sdio-irq;
 			};
 		};
@@ -582,6 +592,14 @@
 			amb,data-swap;
 			amb,reg-64bit;
 		};
+		l2-cache@f0002000 {
+			compatible = "arm,pl310-cache";
+			reg = <0xf0002000 0x1000>;
+			cache-unified;
+			cache-level = <2>;
+			arm,tag_latency = <3 3 3>;
+			arm,data_latency = <3 3 3>;
+		};
 	};
 
 	rct@70170000 {
@@ -594,10 +612,14 @@
 		usbphy: usbphy@70170050 {
 			compatible = "ambarella,usbphy";
 			reg = <0x70170050 0x4 0x6001b00c 0x4 0x70170088 0x4>;
-			amb,host-phy-num = <2>;
+			amb,host-phy-num = <1>;
 		};
 	};
 
+	iav {
+		compatible = "ambarella,iav";
+	};
+
 	bogus_bus {
 		compatible = "simple-bus";
 		#address-cells = <1>;
diff --git a/arch/arm/boot/dts/ambarella-s2l.dtsi b/arch/arm/boot/dts/ambarella-s2l.dtsi
index 83b6973..50fa4cb 100644
--- a/arch/arm/boot/dts/ambarella-s2l.dtsi
+++ b/arch/arm/boot/dts/ambarella-s2l.dtsi
@@ -17,7 +17,11 @@
 		serial0 = &uart0;
 		serial1 = &uart1;
 		nand = &nand0;
+		sd0 = &sdmmc0;
+		sd1 = &sdmmc1;
+		sd2 = &sdmmc2;
 		spinor = &spinor0;
+		spinand = &spinand0;
 		i2c0 = &i2c0;
 		i2c1 = &i2c1;
 		i2c2 = &i2c2;
@@ -46,7 +50,7 @@
 		clock-latency = <100000>;
 		/* the highest frequency is gotten in runtime */
 		cpufreq_tbl = < /*core_clk	cortex_clk*/
-				24000		24000
+				24000		96000
 				108000		504000>;
 
 		cpu@0 {
@@ -97,7 +101,6 @@
 			pinctrl-0 = <&i2c0_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x81>;
-			amb,bulk-num = <60>;
 			/* amb,duty-cycle = <0>; */
 			status = "disabled";
 	        };
@@ -112,7 +115,6 @@
 			pinctrl-0 = <&i2c1_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x08>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -126,7 +128,6 @@
 			pinctrl-0 = <&i2c2_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x81>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -155,6 +156,7 @@
 		rtc@e8015000 {
 			compatible = "ambarella,rtc";
 			reg = <0xe8015000 0x1000>;
+			rtc,wakeup;
 		};
 
 		pwm: pwm@e8008000 {
@@ -257,54 +259,79 @@
 						  0x3047>;
 			};
 
+			sdmmc0_cd_pin: sdmmc0_cd@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x203b>;
+			};
+
+			sdmmc0_wp_pin: sdmmc0_wp@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x203c>;
+			};
+
 			sdmmc0_pins_1bit: sdmmc0@0 {
 				reg = <0>;
-				amb,pinmux-ids = <0x2039 0x203a 0x203b 0x203c
-						  0x2049>;
+				amb,pinmux-ids = <0x2039 0x203a 0x2049>;
 			};
 
 			sdmmc0_pins_4bit: sdmmc0@1 {
 				reg = <1>;
-				amb,pinmux-ids = <0x2039 0x203a 0x203b 0x203c
-						  0x2049 0x204a 0x204b 0x204c>;
+				amb,pinmux-ids = <0x2039 0x203a 0x2049
+						  0x204a 0x204b 0x204c>;
 			};
 
 			sdmmc0_pins_8bit: sdmmc0@2 {
 				reg = <2>;
-				amb,pinmux-ids = <0x2039 0x203a 0x203b 0x203c
-						  0x2049 0x204a 0x204b 0x204c
-						  0x204d 0x204e 0x204f 0x2050>;
+				amb,pinmux-ids = <0x2039 0x203a 0x2049 0x204a 0x204b
+						  0x204c 0x204d 0x204e 0x204f 0x2050>;
+			};
+
+			sdmmc1_cd_pin: sdmmc1_cd@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x2057>;
+			};
+
+			sdmmc1_wp_pin: sdmmc1_wp@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x2058>;
 			};
 
 			sdmmc1_pins_1bit: sdmmc1@0 {
 				reg = <0>;
-				amb,pinmux-ids = <0x2051 0x2052 0x2053 0x2057
-						  0x2058>;
+				amb,pinmux-ids = <0x2051 0x2052 0x2053>;
 			};
 
 			sdmmc1_pins_4bit: sdmmc1@1 {
 				reg = <1>;
-				amb,pinmux-ids = <0x2051 0x2052 0x2053 0x2054
-						  0x2055 0x2056 0x2057 0x2058>;
+				amb,pinmux-ids = <0x2051 0x2052 0x2053
+						  0x2054 0x2055 0x2056>;
+			};
+
+			sdmmc2_cd_pin: sdmmc2_cd@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x5008>;
+			};
+
+			sdmmc2_wp_pin: sdmmc2_wp@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x5009>;
 			};
 
 			sdmmc2_pins_1bit: sdmmc2@0 {
 				reg = <0>;
-				amb,pinmux-ids = <0x5007 0x5008 0x5009 0x500a
-						  0x5012>;
+				amb,pinmux-ids = <0x5007 0x500a 0x5012>;
 			};
 
 			sdmmc2_pins_4bit: sdmmc2@1 {
 				reg = <1>;
-				amb,pinmux-ids = <0x5007 0x5008 0x5009 0x500a
-						  0x500b 0x500c 0x500d 0x5012>;
+				amb,pinmux-ids = <0x5007 0x500a 0x500b
+						  0x500c 0x500d 0x5012>;
 			};
 
 			sdmmc2_pins_8bit: sdmmc2@2 {
 				reg = <2>;
-				amb,pinmux-ids = <0x5007 0x5008 0x5009 0x500a
-						  0x500b 0x500c 0x500d 0x500e
-						  0x500f 0x5010 0x5011 0x5012>;
+				amb,pinmux-ids = <0x5007 0x500a 0x500b 0x500c 0x500d
+						  0x500e 0x500f 0x5010 0x5011 0x5012>;
 			};
 
 			eth_pins: eth0@0 {
@@ -457,10 +484,14 @@
 			      <0xe001c000 0x1000>;
 		};
 
-		dma@e0005000 {
+		dma: dma@e0005000 {
 			compatible = "ambarella,dma";
 			reg = <0xe0005000 0x1000>;
 			interrupts = <15 0x4>;
+			#dma-cells = <2>;
+			dma-channels = <8>;
+			dma-requests = <12>;
+			dma-trans-type = <1 1 0 0 1 1 1 1>; /* 0-memcpy ,1-slave*/
 			amb,copy-align = <0>;
 		};
 
@@ -490,6 +521,15 @@
 			status = "disabled";
 		};
 
+		spinand0: spinand@e0031000 {
+			compatible = "ambarella,spinand";
+			reg = <0xe0031000 0x2ff>, /* spi nor controller */
+			      <0xe0005300 0x20>;  /* dma reg */
+			pinctrl-names = "default";
+			pinctrl-0 = <&spinor0_pins>;
+			status = "disabled";
+		};
+
 		uart1: uart@e0032000 {
 			compatible = "ambarella,uart";
 			reg = <0xe0032000 0x1000>;
@@ -509,9 +549,11 @@
 			reg = <0xe001a000 0x1000>;
 			pinctrl-names = "default";
 			pinctrl-0 = <&i2s0_pins>;
-			bclk_reverse = <0>;
 			amb,i2s-channels = <2>;
 			amb,default-mclk = <12288000>;
+			dmas = <&dma 5 1>,
+				   <&dma 4 1>;
+			dma-names = "tx", "rx";
 		};
 
 		udc@e0006000 {
@@ -535,7 +577,7 @@
 			amb,usbphy = <&usbphy>;
 		};
 
-		sdmmc0@e0002000 {
+		sdmmc0: sdmmc0@e0002000 {
 			compatible = "ambarella,sdmmc";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -544,13 +586,16 @@
 			      <0xec1704c0 0x8>;
 			interrupts = <18 0x4>;
 			amb,clk-name = "gclk_sd";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <20>;
 			amb,max-blk-size = <131072>; /* valid value: 4K<<n */
-			amb,soft-phy;
+			amb,auto-tuning;
+			amb,phy-type = <0>;/*0:rct phy, 1: sd controller phy, 2: for s2e*/
 			amb,phy-timing = <0x00000001 0x04070000 0x00000000>,
-					 <0x000000e0 0x00000001 0x00001111>;
+					<0x00000040 0x00000001 0x00001111>,/*for sdr104 200M*/
+					<0x000000A4 0x00000005 0x00001111>;
 			pinctrl-names = "default";
-			pinctrl-0 = <&sdmmc0_pins_8bit>;
+			pinctrl-0 = <&sdmmc0_pins_8bit &sdmmc0_cd_pin &sdmmc0_wp_pin>;
 
 			slot@0 {
 				reg = <0>;
@@ -558,11 +603,12 @@
 				max-frequency = <50000000>;
 				bus-width = <8>;
 				amb,caps-adma;
+				amb,caps-ddr;
 				cap-sdio-irq;
 			};
 		};
 
-		sdmmc1@e000c000 {
+		sdmmc1: sdmmc1@e000c000 {
 			compatible = "ambarella,sdmmc";
 			reg = <0xe000c000 0x1000>,
 			      <0xe0001000 0x80>; /* fio reg address */
@@ -570,10 +616,11 @@
 			#size-cells = <0>;
 			interrupts = <52 0x4>;
 			amb,clk-name = "gclk_sdio";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <20>;
 			amb,max-blk-size = <131072>; /* valid value: 4K<<n */
 			pinctrl-names = "default";
-			pinctrl-0 = <&sdmmc1_pins_4bit>;
+			pinctrl-0 = <&sdmmc1_pins_4bit &sdmmc1_cd_pin &sdmmc1_wp_pin>;
 			status = "disabled";
 
 			slot@0 {
@@ -586,7 +633,7 @@
 			};
 		};
 
-		sdmmc2@e001f000 {
+		sdmmc2: sdmmc2@e001f000 {
 			compatible = "ambarella,sdmmc";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -594,10 +641,11 @@
 			      <0xe0001000 0x80>; /* fio reg address */
 			interrupts = <20 0x4>;
 			amb,clk-name = "gclk_sdxc";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <20>;
 			amb,max-blk-size = <131072>; /* valid value: 4K<<n */
 			pinctrl-names = "default";
-			pinctrl-0 = <&sdmmc2_pins_8bit>;
+			pinctrl-0 = <&sdmmc2_pins_8bit &sdmmc2_cd_pin &sdmmc2_wp_pin>;
 			status = "disabled";
 
 			slot@0 {
@@ -634,6 +682,9 @@
 			pinctrl-0 = <&spi0_pins>;
 			amb,clk-freq = <54000000>;
 			amb,dma-used;
+			dmas = <&dma 0 1>,
+				   <&dma 1 1>;
+			dma-names = "tx", "rx";
 		};
 
 		spi1: spi@e0021000 {
@@ -674,6 +725,15 @@
 			amb,data-swap;
 			amb,reg-64bit;
 		};
+		l2-cache@f0002000 {
+			compatible = "arm,pl310-cache";
+			reg = <0xf0002000 0x1000>;
+			cache-unified;
+			cache-level = <2>;
+			/* l2 cache latency use default setting */
+			/* arm,tag_latency = <1 2 1>; */
+			/* arm,data_latency = <1 3 1>; */
+		};
 	};
 
 	rct@ec170000 {
@@ -692,6 +752,10 @@
 		};
 	};
 
+	iav {
+		compatible = "ambarella,iav";
+	};
+
 	bogus_bus {
 		compatible = "simple-bus";
 		#address-cells = <1>;
@@ -701,4 +765,12 @@
 			compatible = "ambarella,dummycodec";
 		};
 	};
+
+	amba_lens {
+		compatible = "ambarella,lens";
+		interrupts = <12 0x1>,	/* zoom_timer_irq */
+			   <13 0x1>,		/* focus_timer_irq */
+			   <14 0x1>;		/* iris_timer_irq */
+	};
+
 };
diff --git a/arch/arm/boot/dts/ambarella-s3.dtsi b/arch/arm/boot/dts/ambarella-s3.dtsi
index dcbeffa..7d2e6d5 100644
--- a/arch/arm/boot/dts/ambarella-s3.dtsi
+++ b/arch/arm/boot/dts/ambarella-s3.dtsi
@@ -18,6 +18,9 @@
 		serial1 = &uart1;
 		nand = &nand0;
 		spinor = &spinor0;
+		sd0 = &sdmmc0;
+		sd1 = &sdmmc1;
+		sd2 = &sdmmc2;
 		i2c0 = &i2c0;
 		i2c1 = &i2c1;
 		i2c2 = &i2c2;
@@ -101,7 +104,6 @@
 			pinctrl-0 = <&i2c0_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x81>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -115,7 +117,6 @@
 			pinctrl-0 = <&i2c1_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x08>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -129,7 +130,6 @@
 			pinctrl-0 = <&i2c2_pins>;
 			clock-frequency = <100000>;
 			amb,i2c-class = <0x81>;
-			amb,bulk-num = <60>;
 			status = "disabled";
 	        };
 
@@ -442,10 +442,15 @@
 			      <0xe0011000 0x1000>;
 		};
 
-		dma@e0005000 {
+		dma: dma@e0005000 {
 			compatible = "ambarella,dma";
 			reg = <0xe0005000 0x1000>;
 			interrupts = <69 0x4>;
+			#dma-cells = <2>;
+			dma-channels = <8>;
+			dma-requests = <14>;
+			dma-trans-type = <1 1 0 0 1 1 1 1>; /* 0-memcpy ,1-slave*/
+			dma-channel-sel = <0 1 0 0 8 9 11 10>;
 			amb,copy-align = <0>;
 			/* support pause/resume/stop */
 			amb,support-prs;
@@ -496,9 +501,11 @@
 			reg = <0xe001a000 0x1000>;
 			pinctrl-names = "default";
 			pinctrl-0 = <&i2s0_pins>;
-			bclk_reverse = <0>;
 			amb,i2s-channels = <2>;
 			amb,default-mclk = <12288000>;
+			dmas = <&dma 5 1>,
+				   <&dma 4 1>;
+			dma-names = "tx", "rx";
 		};
 
 		udc@e0006000 {
@@ -522,7 +529,7 @@
 			amb,usbphy = <&usbphy>;
 		};
 
-		sdmmc0@e0002000 {
+		sdmmc0: sdmmc0@e0002000 {
 			compatible = "ambarella,sdmmc";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -530,7 +537,8 @@
 			      <0xe0001000 0x80>; /* fio reg address */
 			interrupts = <77 0x4>;
 			amb,clk-name = "gclk_sd";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <100>;
 			amb,max-blk-size = <131072>; /* valid value: 4K<<n */
 			pinctrl-names = "default";
 			pinctrl-0 = <&sdmmc0_pins_8bit>;
@@ -545,7 +553,7 @@
 			};
 		};
 
-		sdmmc1@e000c000 {
+		sdmmc1: sdmmc1@e000c000 {
 			compatible = "ambarella,sdmmc";
 			reg = <0xe000c000 0x1000>,
 			      <0xe0001000 0x80>; /* fio reg address */
@@ -553,7 +561,8 @@
 			#size-cells = <0>;
 			interrupts = <76 0x4>;
 			amb,clk-name = "gclk_sdio";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <100>;
 			amb,max-blk-size = <131072>; /* valid value: 4K<<n */
 			pinctrl-names = "default";
 			pinctrl-0 = <&sdmmc1_pins_4bit>;
@@ -569,7 +578,7 @@
 			};
 		};
 
-		sdmmc2@e001f000 {
+		sdmmc2: sdmmc2@e001f000 {
 			compatible = "ambarella,sdmmc";
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -577,7 +586,8 @@
 			      <0xe0001000 0x80>; /* fio reg address */
 			interrupts = <75 0x4>;
 			amb,clk-name = "gclk_sdxc";
-			amb,wait-tmo = <2500>; /* in millisecond */
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <100>;
 			amb,max-blk-size = <131072>; /* valid value: 4K<<n */
 			pinctrl-names = "default";
 			pinctrl-0 = <&sdmmc2_pins_8bit>;
@@ -616,6 +626,9 @@
 			pinctrl-names = "default";
 			pinctrl-0 = <&spi0_pins>;
 			amb,clk-freq = <54000000>;
+			dmas = <&dma 0 1>,
+				   <&dma 1 1>;
+			dma-names = "tx", "rx";
 		};
 
 		spi1: spi@e0021000 {
@@ -674,6 +687,10 @@
 		};
 	};
 
+	iav {
+		compatible = "ambarella,iav";
+	};
+
 	bogus_bus {
 		compatible = "simple-bus";
 		#address-cells = <1>;
diff --git a/arch/arm/boot/dts/ambarella-supercam.dtsi b/arch/arm/boot/dts/ambarella-supercam.dtsi
new file mode 100644
index 0000000..a0758f7
--- /dev/null
+++ b/arch/arm/boot/dts/ambarella-supercam.dtsi
@@ -0,0 +1,701 @@
+/*
+ * Copyright (C) 2013 Ambarella,Inc. - http://www.ambarella.com/
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/include/ "skeleton.dtsi"
+
+/ {
+	compatible = "ambarella,s3";
+	interrupt-parent = <&intc>;
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+		nand = &nand0;
+		spinor = &spinor0;
+		emmc = &sdmmc0;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		ethernet0 = &mac0;
+	};
+
+	/* the memory node will be overwritten in Amboot,
+	 * here is just the default value. */
+	memory {
+		device_type = "memory";
+		reg = <0x00200000 0x07e00000>; /* 126M */
+	};
+
+	chosen {
+		linux,stdout-path = &uart0;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		cpu@a00 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0xa00>;
+		};
+		cpu@a01 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0xa01>;
+		};
+	};
+
+	apb@e8000000 {	/* APB */
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0xe8000000 0x01000000>;
+		ranges;
+
+		timer7: timer@e800b064 {
+			compatible = "ambarella,clock-source";
+			reg = <0xe800b064 0x10 0xe800b030 0x4>;
+			interrupts = <13 0x1>;
+			ctrl-offset = <24>; /* bit offset in timer-ctrl reg */
+		};
+
+		timer8: timer@e800b074 {
+			compatible = "ambarella,clock-event";
+			reg = <0xe800b074 0x10 0xe800b030 0x4>;
+			interrupts = <14 0x1>;
+			ctrl-offset = <28>; /* bit offset in timer-ctrl reg */
+		};
+
+		/* timer06 and timer16 */
+		local_timer: timer@e800b054 {
+			compatible = "ambarella,local-clock-event";
+			reg = <0xe800b054 0x10 0xe800b030 0x4 0xe800f054 0x10 0xe800f030 0x4>;
+			interrupts = <12 0x1 28 0x1>;
+			ctrl-offset = <20 20>; /* bit offset in timer-ctrl reg */
+		};
+
+		uart0: uart@e8005000 {
+			compatible = "ambarella,uart";
+			reg = <0xe8005000 0x1000>;
+			interrupts = <108 0x4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&uart0_pins>;
+			status = "ok";
+			/* amb,tx-fifo-fix; */
+		};
+
+		i2c0: i2c@e8003000 {
+			compatible = "ambarella,i2c";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe8003000 0x1000>;
+			interrupts = <85 0x4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c0_pins>;
+			clock-frequency = <100000>;
+			amb,i2c-class = <0x81>;
+			amb,bulk-num = <60>;
+			status = "disabled";
+	        };
+
+		i2c1: i2c@e8001000 {
+			compatible = "ambarella,i2c";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe8001000 0x1000>;
+			interrupts = <84 0x4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c1_pins>;
+			clock-frequency = <100000>;
+			amb,i2c-class = <0x08>;
+			amb,bulk-num = <60>;
+			status = "disabled";
+	        };
+
+		i2c2: i2c@e8007000 {
+			compatible = "ambarella,i2c";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe8007000 0x1000>;
+			interrupts = <83 0x4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c2_pins>;
+			clock-frequency = <100000>;
+			amb,i2c-class = <0x81>;
+			amb,bulk-num = <60>;
+			status = "disabled";
+	        };
+
+		adc@e801d000 {
+			compatible = "ambarella,adc";
+			reg = <0xe801d000 0x1000>;
+			interrupts = <103 0x4>;
+			clock-frequency = <3000000>;
+		};
+
+		ir@e8006000 {
+			compatible = "ambarella,ir";
+			reg = <0xe8006000 0x1000>;
+			interrupts = <86 0x4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&ir_pins>;
+		};
+
+		wdt@e800c000 {
+			compatible = "ambarella,wdt";
+			reg = <0xe800c000 0x1000>;
+			/* interrupts = <105 0x4>; */
+			timeout-sec = <15>;
+		};
+
+		rtc@e8015000 {
+			compatible = "ambarella,rtc";
+			reg = <0xe8015000 0x1000>;
+		};
+
+		pwm: pwm@e8008000 {
+			compatible = "ambarella,pwm";
+			reg = <0xe8008000 0x1000>;
+			#pwm-cells = <3>;
+		};
+
+		pinctrl: pinctrl@e8009000 {
+			compatible = "ambarella,pinctrl", "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe8009000 0x1000>,
+			      <0xe800a000 0x1000>,
+			      <0xe800e000 0x1000>,
+			      <0xe8010000 0x1000>,
+			      <0xe8011000 0x1000>,
+			      <0xe800d000 0x1000>,
+			      <0xe8014000 0x1000>,
+			      <0xe8016000 0x1000>;
+			reg-names = "gpio0", "gpio1", "gpio2", "gpio3",
+				    "gpio4", "gpio5", "gpio6", "iomux";
+			#gpio-range-cells = <3>;
+
+			gpio: gpio@0 {
+				compatible = "ambarella,gpio";
+				/* gpio interrupts to vic */
+				interrupts = <124 0x4>, <123 0x4>, <122 0x4>,
+					     <121 0x4>, <120 0x4>, <119 0x4>,
+					     <118 0x4>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				gpio-ranges = <&pinctrl 0 0 224>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			uart0_pins: uart0@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x1024 0x1025>;
+			};
+
+			uart1_pins_a: uart1@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x2008 0x2009>;
+			};
+
+			uart1_pins_b: uart1@1 {
+				reg = <1>;
+				amb,pinmux-ids = <0x301b 0x301c>;
+			};
+
+			uart1_pins_c: uart1@2 {
+				reg = <2>;
+				amb,pinmux-ids = <0x10c3 0x10c4>;
+			};
+
+			uart1_flow_pins_a: uart1_flow@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x200a 0x200b>;
+			};
+
+			uart1_flow_pins_b: uart1_flow@1 {
+				reg = <1>;
+				amb,pinmux-ids = <0x301d 0x301e>;
+			};
+
+			uart1_flow_pins_c: uart1_flow@2 {
+				reg = <2>;
+				amb,pinmux-ids = <0x10c5 0x10c6>;
+			};
+
+			nand0_pins: nand0@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x2073 0x2074 0x2075 0x207a
+						  0x207b 0x207c 0x207d 0x207e
+						  0x207f 0x2080 0x2081 0x2082
+						  0x2083 0x2084 0x2085>;
+			};
+
+			spinor0_pins: spinor0@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x3076 0x3077 0x3078 0x3079
+						  0x307d 0x307e 0x307f 0x3080
+						  0x3081 0x3082 0x3083 0x3084
+						  0x3086 0x3087 0x3088 0x3089
+						  0x308c>;
+			};
+
+			sdmmc0_pins_1bit: sdmmc0@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x2076 0x2077 0x2078 0x2079
+						  0x2086 0x209a>;
+			};
+
+			sdmmc0_pins_4bit: sdmmc0@1 {
+				reg = <1>;
+				amb,pinmux-ids = <0x2076 0x2077 0x2078 0x2079
+						  0x2086 0x2087 0x2088 0x2089
+						  0x209a>;
+			};
+
+			sdmmc0_pins_8bit: sdmmc0@2 {
+				reg = <2>;
+				amb,pinmux-ids = <0x2076 0x2077 0x2078 0x2079
+						  0x2086 0x2087 0x2088 0x2089
+						  0x208a 0x208b 0x208c 0x208d
+						  0x209a>;
+			};
+
+			sdmmc1_pins_1bit: sdmmc1@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x5000 0x5001 0x5002 0x5003
+						  0x5004>;
+			};
+
+			sdmmc1_pins_4bit: sdmmc1@1 {
+				reg = <1>;
+				amb,pinmux-ids = <0x5000 0x5001 0x5002 0x5003
+						  0x5004 0x5005 0x5006 0x5007>;
+			};
+
+			sdmmc2_pins_1bit: sdmmc2@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x208e 0x208f 0x2090 0x2094
+						  0x2095 0x209b>;
+			};
+
+			sdmmc2_pins_4bit: sdmmc2@1 {
+				reg = <1>;
+				amb,pinmux-ids = <0x208e 0x208f 0x2090 0x2091
+						  0x2092 0x2093 0x2094 0x2095
+						  0x209b>;
+			};
+
+			sdmmc2_pins_8bit: sdmmc2@2 {
+				reg = <2>;
+				amb,pinmux-ids = <0x208e 0x208f 0x2090 0x2091
+						  0x2092 0x2093 0x2094 0x2095
+						  0x2096 0x2097 0x2098 0x2099
+						  0x209b>;
+			};
+
+			eth_gmii_pins: eth0@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x102b 0x102c 0x102d 0x102e 0x102f
+						  0x1030 0x1031 0x1032 0x1033 0x1034
+						  0x1035 0x1036 0x1037 0x1038 0x1039
+						  0x103a 0x103b 0x103c 0x103d 0x103e
+						  0x103f 0x1040 0x1041 0x1042 0x1043
+						  0x1044 0x1045 0x1046>;
+			};
+
+			eth_mii_pins: eth0@1 {
+				reg = <1>;
+				amb,pinmux-ids = <0x202b 0x202c 0x202d 0x202e 0x202f
+						  0x2030 0x2035 0x2036 0x2037 0x2038
+						  0x203d 0x203e 0x203f 0x2040 0x2041
+						  0x2042 0x2043 0x2044 0x2045 0x2046>;
+			};
+
+			eth_rmii_pins: eth0@2 {
+				reg = <2>;
+				amb,pinmux-ids = <0x302b 0x302d 0x302e 0x3035 0x3036
+						  0x303f 0x3041 0x3042 0x3043 0x3044
+						  0x3045 0x3046>;
+			};
+
+			eth_rgmii_pins: eth0@3 {
+				reg = <3>;
+				amb,pinmux-ids = <0x402b 0x402d 0x402e 0x402f 0x4030
+						  0x4035 0x4036 0x4037 0x4038 0x403f
+						  0x4043 0x4044 0x4045 0x4046>;
+			};
+
+			i2c0_pins: i2c0@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x1014 0x1015>;
+			};
+
+			i2c1_pins: i2c1@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x1016 0x1017>;
+			};
+
+			i2c2_pins: i2c2@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x1018 0x1019>;
+			};
+
+			spi0_pins: spi0@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x101b 0x101c 0x101d>;
+			};
+
+			spi1_pins_a: spi1@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x2000 0x2001 0x2002>;
+			};
+
+			spi1_pins_b: spi1@1 {
+				reg = <1>;
+				amb,pinmux-ids = <0x20c3 0x20c4 0x20c5>;
+			};
+
+			spi_slave_pins: spi_slave@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x1020 0x1021 0x1022 0x1023>;
+			};
+
+			ir_pins: ir0@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x101a>;
+			};
+
+			i2s0_pins: i2s0@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x1026 0x1027 0x1028 0x1029 0x102a>;
+			};
+
+			usb_host0_pins_a: uhc0@0 { /* USB0: host/device configurable */
+				reg = <0>;
+				amb,pinmux-ids = <0x300c 0x300e>;
+			};
+
+			usb_host0_pins_b: uhc0@1 { /* USB0: host/device configurable */
+				reg = <1>;
+				amb,pinmux-ids = <0x204b 0x204d>;
+			};
+
+			usb_host1_pins_a: uhc1@0 { /* USB1: host only */
+				reg = <0>;
+				amb,pinmux-ids = <0x300d 0x300f>;
+			};
+
+			usb_host1_pins_b: uhc1@1 { /* USB1: host only */
+				reg = <1>;
+				amb,pinmux-ids = <0x204c 0x204e>;
+			};
+
+			pwm0_pins_a: pwm0@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x4004>;
+			};
+
+			pwm0_pins_b: pwm0@1 {
+				reg = <1>;
+				amb,pinmux-ids = <0x10bc>;
+			};
+
+			pwm1_pins: pwm1@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x4005>;
+			};
+
+			pwm2_pins: pwm2@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x4006>;
+			};
+
+			pwm3_pins: pwm3@0 {
+				reg = <0>;
+				amb,pinmux-ids = <0x4007>;
+			};
+		};
+	};
+
+	ahb@e0000000 {	/* AHB */
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0xe0000000 0x01000000>;
+		ranges;
+
+		intc: interrupt-controller@e0003000 {
+			compatible = "ambarella,vic";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			reg = <0xe0003000 0x1000>,
+			      <0xe0010000 0x1000>,
+			      <0xe001c000 0x1000>,
+			      <0xe0011000 0x1000>;
+		};
+
+		dma: dma@e0005000 {
+			compatible = "ambarella,dma";
+			reg = <0xe0005000 0x1000>;
+			interrupts = <69 0x4>;
+			#dma-cells = <2>;
+			dma-channels = <8>;
+			dma-requests = <14>;
+			dma-trans-type = <1 1 0 0 1 1 1 1>; /* 0-memcpy ,1-slave*/
+			amb,copy-align = <0>;
+			/* support pause/resume/stop */
+			amb,support-prs;
+		};
+
+		nand0: nand@e0001000 {
+			compatible = "ambarella,nand";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0xe0001000 0x1000>, /* fio reg address */
+			      <0xe0012000 0x1000>, /* fdma reg address */
+			      <0xe0000000 0x4>;    /* fifo base */
+			interrupts = <72 0x4>,	/* fio_cmd_irq */
+				     <73 0x4>,	/* fio_dma_irq */
+				     <70 0x4>;	/* fdma_irq */
+			pinctrl-names = "default";
+			pinctrl-0 = <&nand0_pins>;
+			nand-on-flash-bbt;
+			amb,enable-wp;
+			/* amb,soft-ecc = <1>; */
+		};
+
+		spinor0: spinor@e0031000 {
+			compatible = "ambarella,spinor";
+			reg = <0xe0031000 0x2ff>, /* spi nor controller */
+			      <0xe0005300 0x20>;  /* dma reg */
+			pinctrl-names = "default";
+			pinctrl-0 = <&spinor0_pins>;
+			status = "disabled";
+		};
+
+		uart1: uart@e0032000 {
+			compatible = "ambarella,uart";
+			reg = <0xe0032000 0x1000>;
+			interrupts = <82 0x4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&uart1_pins_c &uart1_flow_pins_c>;
+			status = "disabled";
+			amb,msr-used;	/* use Modem Status Register */
+			amb,txdma-used;
+			amb,rxdma-used;
+			/* amb,tx-fifo-fix; */
+			/* need to select pinctrl setup in board dts */
+		};
+
+		i2s0: i2s@e001a000 {
+			compatible = "ambarella,i2s";
+			reg = <0xe001a000 0x1000>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s0_pins>;
+			amb,i2s-channels = <2>;
+			amb,default-mclk = <12288000>;
+		};
+
+		udc@e0006000 {
+			compatible = "ambarella,udc";
+			reg = <0xe0006000 0x2000 0xec1702cc 0x4>;
+			interrupts = <68 0x4>;
+			amb,usbphy = <&usbphy>;
+		};
+
+		ehci@e0018000 {
+			compatible = "ambarella,ehci";
+			reg = <0xe0018000 0x1000>;
+			interrupts = <66 0x4>;
+			amb,usbphy = <&usbphy>;
+		};
+
+		ohci@e0019000 {
+			compatible = "ambarella,ohci";
+			reg = <0xe0019000 0x1000>;
+			interrupts = <67 0x4>;
+			amb,usbphy = <&usbphy>;
+		};
+
+		sdmmc0: sdmmc0@e0002000 {
+			compatible = "ambarella,sdmmc";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe0002000 0x1000>,
+			      <0xe0001000 0x80>; /* fio reg address */
+			interrupts = <77 0x4>;
+			amb,clk-name = "gclk_sd";
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <100>;
+			amb,max-blk-size = <131072>; /* valid value: 4K<<n */
+			pinctrl-names = "default";
+			pinctrl-0 = <&sdmmc0_pins_8bit>;
+			status = "disabled";
+
+			slot@0 {
+				reg = <0>;
+				global-id = <0>;
+				max-frequency = <48000000>;
+				bus-width = <8>;
+				amb,caps-adma;
+				cap-sdio-irq;
+			};
+		};
+
+		sdmmc1: sdmmc1@e000c000 {
+			compatible = "ambarella,sdmmc";
+			reg = <0xe000c000 0x1000>,
+			      <0xe0001000 0x80>; /* fio reg address */
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <76 0x4>;
+			amb,clk-name = "gclk_sdio";
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <100>;
+			amb,max-blk-size = <131072>; /* valid value: 4K<<n */
+			pinctrl-names = "default";
+			pinctrl-0 = <&sdmmc1_pins_4bit>;
+			status = "disabled";
+
+			slot@0 {
+				reg = <0>;
+				global-id = <1>;
+				max-frequency = <48000000>;
+				bus-width = <4>;
+				amb,caps-adma;
+				cap-sdio-irq;
+			};
+		};
+
+		sdmmc2: sdmmc2@e001f000 {
+			compatible = "ambarella,sdmmc";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe001f000 0x1000>,
+			      <0xe0001000 0x80>; /* fio reg address */
+			interrupts = <75 0x4>;
+			amb,clk-name = "gclk_sdxc";
+			amb,wait-tmo = <10000>; /* in millisecond */
+			amb,switch_vol_tmo = <100>;
+			amb,max-blk-size = <131072>; /* valid value: 4K<<n */
+			pinctrl-names = "default";
+			pinctrl-0 = <&sdmmc2_pins_8bit>;
+			status = "disabled";
+
+			slot@0 {
+				reg = <0>;
+				global-id = <2>;
+				max-frequency = <12000000>;
+				bus-width = <8>;
+				amb,caps-adma;
+				cap-sdio-irq;
+			};
+		};
+
+		mac0: ethernet@e000e000 {
+			compatible = "ambarella,eth";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe000e000 0x2000>;
+			interrupts = <65 0x4>;
+			amb,tx-ring-size = <32>;
+			amb,rx-ring-size = <64>;
+			amb,ipc-tx;
+			amb,ipc-rx;
+			pinctrl-names = "default";
+			pinctrl-0 = <&eth_gmii_pins>;
+		};
+
+		spi0: spi@e0020000 {
+			compatible = "ambarella,spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe0020000 0x1000>;
+			interrupts = <80 0x4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0_pins>;
+			amb,clk-freq = <54000000>;
+			dmas = <&dma 0 1>,
+				   <&dma 1 1>;
+			dma-names = "tx", "rx";
+		};
+
+		spi1: spi@e0021000 {
+			compatible = "ambarella,spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0xe0021000 0x1000>;
+			interrupts = <79 0x4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi1_pins_b>;
+			amb,clk-freq = <54000000>;
+			status = "ok";
+		};
+
+		spi_slave@e0026000 {
+			compatible = "ambarella,spi-slave";
+			reg = <0xe0026000 0x1000>;
+			interrupts = <81 0x4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi_slave_pins>;
+			status = "disabled";
+		};
+	};
+
+	axi@f0000000 {	/* AXI */
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0xf0000000 0x00030000>;
+		ranges;
+
+		crypto@f0020000 {
+			compatible = "ambarella,crypto";
+			reg = <0xf0020000 0x8000>;
+			interrupts = <111 0x1>, <112 0x1>, <113 0x1>, <110 0x1>;
+			interrupt-names = "aes-irq", "des-irq", "md5-irq", "sha1-irq";
+			amb,cap-md5-sha1;
+			amb,data-swap;
+			amb,reg-64bit;
+		};
+	};
+
+	rct@ec170000 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0xec170000 0x1000>;
+		ranges;
+
+		usbphy: usbphy@ec170050 {
+			compatible = "ambarella,usbphy";
+			reg = <0xec170050 0x4 0xe001b00c 0x4 0xec1702c0 0x4>;
+			amb,host-phy-num = <2>;
+			amb,owner-mask;
+			amb,owner-invert;
+		};
+	};
+
+	iav {
+		compatible = "ambarella,iav";
+	};
+
+	bogus_bus {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		dummycodec: codec@0 {
+			compatible = "ambarella,dummycodec";
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts b/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts
index 9746d0e..5dfb3d3 100644
--- a/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts
+++ b/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts
@@ -32,6 +32,10 @@
 			  0xf0000000 0 0xf0000000 0x8000000     /* Device Bus, NOR 128MiB   */>;
 
 		internal-regs {
+			rtc@10300 {
+				/* No crystal connected to the internal RTC */
+				status = "disabled";
+			};
 			serial@12000 {
 				clock-frequency = <250000000>;
 				status = "okay";
diff --git a/arch/arm/boot/dts/dove.dtsi b/arch/arm/boot/dts/dove.dtsi
index 6cab468..d1e4709 100644
--- a/arch/arm/boot/dts/dove.dtsi
+++ b/arch/arm/boot/dts/dove.dtsi
@@ -75,7 +75,7 @@
 
 		uart2: serial@12200 {
 			compatible = "ns16550a";
-			reg = <0x12000 0x100>;
+			reg = <0x12200 0x100>;
 			reg-shift = <2>;
 			interrupts = <9>;
 			clocks = <&core_clk 0>;
@@ -84,7 +84,7 @@
 
 		uart3: serial@12300 {
 			compatible = "ns16550a";
-			reg = <0x12100 0x100>;
+			reg = <0x12300 0x100>;
 			reg-shift = <2>;
 			interrupts = <10>;
 			clocks = <&core_clk 0>;
diff --git a/arch/arm/boot/dts/imx23-olinuxino.dts b/arch/arm/boot/dts/imx23-olinuxino.dts
index d107c4a..6fef544 100644
--- a/arch/arm/boot/dts/imx23-olinuxino.dts
+++ b/arch/arm/boot/dts/imx23-olinuxino.dts
@@ -89,6 +89,7 @@
 
 	ahb@80080000 {
 		usb0: usb@80080000 {
+			dr_mode = "host";
 			vbus-supply = <&reg_usb0_vbus>;
 			status = "okay";
 		};
diff --git a/arch/arm/boot/dts/imx25.dtsi b/arch/arm/boot/dts/imx25.dtsi
index 97d1a55..2a571bc 100644
--- a/arch/arm/boot/dts/imx25.dtsi
+++ b/arch/arm/boot/dts/imx25.dtsi
@@ -393,6 +393,7 @@
 
 			pwm4: pwm@53fc8000 {
 				compatible = "fsl,imx25-pwm", "fsl,imx27-pwm";
+				#pwm-cells = <2>;
 				reg = <0x53fc8000 0x4000>;
 				clocks = <&clks 108>, <&clks 52>;
 				clock-names = "ipg", "per";
diff --git a/arch/arm/boot/dts/imx27.dtsi b/arch/arm/boot/dts/imx27.dtsi
index 75bd113..77730a3 100644
--- a/arch/arm/boot/dts/imx27.dtsi
+++ b/arch/arm/boot/dts/imx27.dtsi
@@ -290,7 +290,7 @@
 
 			fec: ethernet@1002b000 {
 				compatible = "fsl,imx27-fec";
-				reg = <0x1002b000 0x4000>;
+				reg = <0x1002b000 0x1000>;
 				interrupts = <50>;
 				clocks = <&clks 48>, <&clks 67>, <&clks 0>;
 				clock-names = "ipg", "ahb", "ptp";
diff --git a/arch/arm/boot/dts/imx28.dtsi b/arch/arm/boot/dts/imx28.dtsi
index 4c10a19..2e76b84 100644
--- a/arch/arm/boot/dts/imx28.dtsi
+++ b/arch/arm/boot/dts/imx28.dtsi
@@ -691,7 +691,7 @@
 					      80 81 68 69
 					      70 71 72 73
 					      74 75 76 77>;
-				interrupt-names = "auart4-rx", "aurat4-tx", "spdif-tx", "empty",
+				interrupt-names = "auart4-rx", "auart4-tx", "spdif-tx", "empty",
 						  "saif0", "saif1", "i2c0", "i2c1",
 						  "auart0-rx", "auart0-tx", "auart1-rx", "auart1-tx",
 						  "auart2-rx", "auart2-tx", "auart3-rx", "auart3-tx";
diff --git a/arch/arm/common/icst.c b/arch/arm/common/icst.c
index 2dc6da70..d7ed252 100644
--- a/arch/arm/common/icst.c
+++ b/arch/arm/common/icst.c
@@ -16,7 +16,7 @@
  */
 #include <linux/module.h>
 #include <linux/kernel.h>
-
+#include <asm/div64.h>
 #include <asm/hardware/icst.h>
 
 /*
@@ -29,7 +29,11 @@ EXPORT_SYMBOL(icst525_s2div);
 
 unsigned long icst_hz(const struct icst_params *p, struct icst_vco vco)
 {
-	return p->ref * 2 * (vco.v + 8) / ((vco.r + 2) * p->s2div[vco.s]);
+	u64 dividend = p->ref * 2 * (u64)(vco.v + 8);
+	u32 divisor = (vco.r + 2) * p->s2div[vco.s];
+
+	do_div(dividend, divisor);
+	return (unsigned long)dividend;
 }
 
 EXPORT_SYMBOL(icst_hz);
@@ -58,6 +62,7 @@ icst_hz_to_vco(const struct icst_params *p, unsigned long freq)
 
 		if (f > p->vco_min && f <= p->vco_max)
 			break;
+		i++;
 	} while (i < 8);
 
 	if (i >= 8)
diff --git a/arch/arm/configs/ambarella_s2_cortex_defconfig b/arch/arm/configs/ambarella_s2_cortex_defconfig
index b184907..1f57a22 100644
--- a/arch/arm/configs/ambarella_s2_cortex_defconfig
+++ b/arch/arm/configs/ambarella_s2_cortex_defconfig
@@ -116,7 +116,7 @@ CONFIG_NAMESPACES=y
 # CONFIG_IPC_NS is not set
 # CONFIG_USER_NS is not set
 # CONFIG_PID_NS is not set
-# CONFIG_NET_NS is not set
+CONFIG_NET_NS=y
 CONFIG_UIDGID_CONVERTED=y
 # CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
 # CONFIG_SCHED_AUTOGROUP is not set
diff --git a/arch/arm/configs/ambarella_s2e_defconfig b/arch/arm/configs/ambarella_s2e_defconfig
index ab3a2bf..791f367 100644
--- a/arch/arm/configs/ambarella_s2e_defconfig
+++ b/arch/arm/configs/ambarella_s2e_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated file; DO NOT EDIT.
-# Linux/arm 3.10.71 Kernel Configuration
+# Linux/arm 3.10.73 Kernel Configuration
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -116,7 +116,7 @@ CONFIG_NAMESPACES=y
 # CONFIG_IPC_NS is not set
 # CONFIG_USER_NS is not set
 # CONFIG_PID_NS is not set
-# CONFIG_NET_NS is not set
+CONFIG_NET_NS=y
 CONFIG_UIDGID_CONVERTED=y
 # CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
 # CONFIG_SCHED_AUTOGROUP is not set
@@ -377,12 +377,13 @@ CONFIG_PLAT_AMBARELLA_S2E=y
 # CONFIG_PLAT_AMBARELLA_A8_CORTEX is not set
 # CONFIG_PLAT_AMBARELLA_S2L is not set
 # CONFIG_PLAT_AMBARELLA_S3 is not set
+# CONFIG_PLAT_AMBARELLA_S3L is not set
 
 #
 # Generic Platform Configuration
 #
+# CONFIG_AMBARELLA_CALC_PLL is not set
 # CONFIG_AMBARELLA_RAW_BOOT is not set
-# CONFIG_AMBARELLA_SUPPORT_BAPI is not set
 # CONFIG_AMBARELLA_PMUSERENR_EN is not set
 CONFIG_PLAT_AMBARELLA_SUPPORT_GDMA=y
 
@@ -390,7 +391,6 @@ CONFIG_PLAT_AMBARELLA_SUPPORT_GDMA=y
 # Sys file system support
 #
 CONFIG_AMBARELLA_SYS_CACHE_CALL=y
-# CONFIG_AMBARELLA_SYS_BAPI_CALL is not set
 
 #
 # Proc file system support
@@ -412,6 +412,7 @@ CONFIG_AMBARELLA_TIMER_HZ=100
 CONFIG_AMBARELLA_TIMER_HIGHRES=y
 CONFIG_AMBARELLA_EXT_IRQ_NUM=16
 CONFIG_AMBARELLA_EXT_GPIO_NUM=16
+# CONFIG_AMBARELLA_SREF_FIFO_EXEC is not set
 CONFIG_GPIO_PCA953X=y
 # CONFIG_KEYBOARD_GPIO_POLLED is not set
 # CONFIG_PLAT_SPEAR is not set
@@ -470,11 +471,11 @@ CONFIG_PL310_ERRATA_727915=y
 # CONFIG_ARM_ERRATA_743622 is not set
 # CONFIG_ARM_ERRATA_751472 is not set
 # CONFIG_PL310_ERRATA_753970 is not set
-# CONFIG_ARM_ERRATA_754322 is not set
+CONFIG_ARM_ERRATA_754322=y
 # CONFIG_ARM_ERRATA_754327 is not set
 CONFIG_ARM_ERRATA_764369=y
 # CONFIG_PL310_ERRATA_769419 is not set
-# CONFIG_ARM_ERRATA_775420 is not set
+CONFIG_ARM_ERRATA_775420=y
 # CONFIG_ARM_ERRATA_798181 is not set
 
 #
@@ -799,7 +800,7 @@ CONFIG_FW_LOADER_USER_HELPER=y
 CONFIG_REGMAP=y
 CONFIG_REGMAP_I2C=m
 CONFIG_REGMAP_SPI=m
-# CONFIG_DMA_SHARED_BUFFER is not set
+CONFIG_DMA_SHARED_BUFFER=y
 # CONFIG_CMA is not set
 
 #
@@ -879,6 +880,8 @@ CONFIG_MTD_NAND_BCH=y
 CONFIG_MTD_NAND_ECC_BCH=y
 # CONFIG_MTD_SM_COMMON is not set
 CONFIG_MTD_NAND_AMBARELLA=y
+# CONFIG_MTD_SPINAND_AMBARELLA is not set
+# CONFIG_MTD_SPINAND_ONDIEECC is not set
 # CONFIG_MTD_NAND_DENALI is not set
 # CONFIG_MTD_NAND_GPIO is not set
 CONFIG_MTD_NAND_IDS=y
@@ -1542,7 +1545,156 @@ CONFIG_BCMA_POSSIBLE=y
 # CONFIG_MFD_WM8350_I2C is not set
 # CONFIG_MFD_WM8994 is not set
 # CONFIG_REGULATOR is not set
-# CONFIG_MEDIA_SUPPORT is not set
+CONFIG_MEDIA_SUPPORT=m
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_RC_SUPPORT is not set
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=m
+# CONFIG_VIDEO_V4L2_SUBDEV_API is not set
+CONFIG_VIDEO_V4L2=m
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEOBUF2_CORE=m
+CONFIG_VIDEOBUF2_MEMOPS=m
+CONFIG_VIDEOBUF2_VMALLOC=m
+# CONFIG_VIDEO_V4L2_INT_DEVICE is not set
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Media drivers
+#
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_JL2005BCD is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SE401 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TOPRO is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_USB_SN9C102 is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_V4L_PLATFORM_DRIVERS is not set
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+# CONFIG_VIDEO_MEM2MEM_DEINTERLACE is not set
+# CONFIG_VIDEO_SH_VEU is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+# CONFIG_CYPRESS_FIRMWARE is not set
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, frontends)
+#
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Miscelaneous helper chips
+#
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
 
 #
 # Graphics support
@@ -1651,21 +1803,21 @@ CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
 CONFIG_SND_AMBARELLA_SOC=m
 CONFIG_SND_AMBARELLA_SOC_I2S=m
 CONFIG_SND_AMBARELLA_BOARD=m
-CONFIG_AMBEVK_AK4951_BOARD=m
 CONFIG_AMBA_BOARD=m
-# CONFIG_S3LOTUS_BOARD is not set
 CONFIG_SND_AMBARELLA_CODEC=m
 CONFIG_SND_SOC_AK4642_AMB=m
 CONFIG_SND_SOC_AK4951_AMB=m
 # CONFIG_SND_SOC_AK4954_AMB is not set
 # CONFIG_SND_SOC_AK7719_DSP is not set
+# CONFIG_SND_SOC_AK7755 is not set
+# CONFIG_SND_SOC_TLV320ADC3xxx is not set
 # CONFIG_SND_SOC_ES8388 is not set
 # CONFIG_SND_SOC_WM8974_AMB is not set
 # CONFIG_SND_SOC_WM8940_AMB is not set
+CONFIG_SND_SOC_AMBARELLA_DUMMY=m
 # CONFIG_SND_ATMEL_SOC is not set
 CONFIG_SND_SOC_I2C_AND_SPI=m
 # CONFIG_SND_SOC_ALL_CODECS is not set
-CONFIG_SND_SOC_AMBARELLA_DUMMY=m
 # CONFIG_SND_SIMPLE_CARD is not set
 # CONFIG_SOUND_PRIME is not set
 
@@ -1774,7 +1926,7 @@ CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
 CONFIG_USB_EHCI_HCD=m
 CONFIG_USB_EHCI_ROOT_HUB_TT=y
 CONFIG_USB_EHCI_TT_NEWSCHED=y
-CONFIG_USB_EHCI_AMBARELLA=y
+CONFIG_USB_EHCI_AMBARELLA=m
 # CONFIG_USB_EHCI_HCD_PLATFORM is not set
 # CONFIG_USB_OXU210HP_HCD is not set
 # CONFIG_USB_ISP116X_HCD is not set
@@ -1971,6 +2123,7 @@ CONFIG_USB_G_MULTI_RNDIS=y
 # CONFIG_USB_G_MULTI_CDC is not set
 # CONFIG_USB_G_HID is not set
 # CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
 CONFIG_MMC=m
 # CONFIG_MMC_DEBUG is not set
 # CONFIG_MMC_UNSAFE_RESUME is not set
@@ -1989,6 +2142,7 @@ CONFIG_MMC_BLOCK_MINORS=32
 # MMC/SD/SDIO Host Controller Drivers
 #
 CONFIG_MMC_AMBARELLA=m
+# CONFIG_AMBARELLA_EMMC_BOOT is not set
 # CONFIG_MMC_SDHCI is not set
 # CONFIG_MMC_SPI is not set
 # CONFIG_MMC_DW is not set
@@ -2024,7 +2178,7 @@ CONFIG_RTC_INTF_DEV_UIE_EMUL=y
 # CONFIG_RTC_DRV_MAX6900 is not set
 # CONFIG_RTC_DRV_RS5C372 is not set
 # CONFIG_RTC_DRV_ISL1208 is not set
-CONFIG_RTC_DRV_ISL12022=y
+# CONFIG_RTC_DRV_ISL12022 is not set
 # CONFIG_RTC_DRV_X1205 is not set
 # CONFIG_RTC_DRV_PCF8523 is not set
 # CONFIG_RTC_DRV_PCF8563 is not set
diff --git a/arch/arm/configs/ambarella_s2l_defconfig b/arch/arm/configs/ambarella_s2l_defconfig
index c1004d3..96a94ff 100644
--- a/arch/arm/configs/ambarella_s2l_defconfig
+++ b/arch/arm/configs/ambarella_s2l_defconfig
@@ -111,7 +111,7 @@ CONFIG_NAMESPACES=y
 # CONFIG_IPC_NS is not set
 # CONFIG_USER_NS is not set
 # CONFIG_PID_NS is not set
-# CONFIG_NET_NS is not set
+CONFIG_NET_NS=y
 CONFIG_UIDGID_CONVERTED=y
 # CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
 # CONFIG_SCHED_AUTOGROUP is not set
@@ -402,6 +402,7 @@ CONFIG_AMBARELLA_TIMER_HZ=100
 CONFIG_AMBARELLA_TIMER_HIGHRES=y
 CONFIG_AMBARELLA_EXT_IRQ_NUM=16
 CONFIG_AMBARELLA_EXT_GPIO_NUM=16
+CONFIG_AMBARELLA_SREF_FIFO_EXEC=y
 CONFIG_GPIO_PCA953X=y
 # CONFIG_KEYBOARD_GPIO_POLLED is not set
 # CONFIG_PLAT_SPEAR is not set
diff --git a/arch/arm/configs/ambarella_s3_defconfig b/arch/arm/configs/ambarella_s3_defconfig
index a74113f..c1b2215 100644
--- a/arch/arm/configs/ambarella_s3_defconfig
+++ b/arch/arm/configs/ambarella_s3_defconfig
@@ -115,7 +115,7 @@ CONFIG_NAMESPACES=y
 # CONFIG_IPC_NS is not set
 # CONFIG_USER_NS is not set
 # CONFIG_PID_NS is not set
-# CONFIG_NET_NS is not set
+CONFIG_NET_NS=y
 CONFIG_UIDGID_CONVERTED=y
 # CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
 # CONFIG_SCHED_AUTOGROUP is not set
diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h
index 56211f2..ce6e306 100644
--- a/arch/arm/include/asm/elf.h
+++ b/arch/arm/include/asm/elf.h
@@ -116,7 +116,7 @@ int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs);
    the loader.  We need to make sure that it is out of the way of the program
    that it will "exec", and that there is sufficient room for the brk.  */
 
-#define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)
+#define ELF_ET_DYN_BASE	(TASK_SIZE / 3 * 2)
 
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
diff --git a/arch/arm/include/asm/ftrace.h b/arch/arm/include/asm/ftrace.h
index f89515a..bfe2a2f 100644
--- a/arch/arm/include/asm/ftrace.h
+++ b/arch/arm/include/asm/ftrace.h
@@ -45,22 +45,14 @@ void *return_address(unsigned int);
 
 #else
 
-extern inline void *return_address(unsigned int level)
+static inline void *return_address(unsigned int level)
 {
 	return NULL;
 }
 
 #endif
 
-#define HAVE_ARCH_CALLER_ADDR
-
-#define CALLER_ADDR0 ((unsigned long)__builtin_return_address(0))
-#define CALLER_ADDR1 ((unsigned long)return_address(1))
-#define CALLER_ADDR2 ((unsigned long)return_address(2))
-#define CALLER_ADDR3 ((unsigned long)return_address(3))
-#define CALLER_ADDR4 ((unsigned long)return_address(4))
-#define CALLER_ADDR5 ((unsigned long)return_address(5))
-#define CALLER_ADDR6 ((unsigned long)return_address(6))
+#define ftrace_return_address(n) return_address(n)
 
 #endif /* ifndef __ASSEMBLY__ */
 
diff --git a/arch/arm/kernel/entry-armv.S b/arch/arm/kernel/entry-armv.S
index 32640ae..03a1e26 100644
--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
@@ -358,7 +358,8 @@ ENDPROC(__pabt_svc)
 	.endm
 
 	.macro	kuser_cmpxchg_check
-#if !defined(CONFIG_CPU_32v6K) && !defined(CONFIG_NEEDS_SYSCALL_FOR_CMPXCHG)
+#if !defined(CONFIG_CPU_32v6K) && defined(CONFIG_KUSER_HELPERS) && \
+    !defined(CONFIG_NEEDS_SYSCALL_FOR_CMPXCHG)
 #ifndef CONFIG_MMU
 #warning "NPTL on non MMU needs fixing"
 #else
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index 4bc816a..f264693 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -32,7 +32,9 @@ ret_fast_syscall:
  UNWIND(.fnstart	)
  UNWIND(.cantunwind	)
 	disable_irq				@ disable interrupts
-	ldr	r1, [tsk, #TI_FLAGS]
+	ldr	r1, [tsk, #TI_FLAGS]		@ re-check for syscall tracing
+	tst	r1, #_TIF_SYSCALL_WORK
+	bne	__sys_trace_return
 	tst	r1, #_TIF_WORK_MASK
 	bne	fast_work_pending
 	asm_trace_hardirqs_on
diff --git a/arch/arm/kernel/fiq.c b/arch/arm/kernel/fiq.c
index 25442f4..918875d 100644
--- a/arch/arm/kernel/fiq.c
+++ b/arch/arm/kernel/fiq.c
@@ -84,17 +84,14 @@ int show_fiq_list(struct seq_file *p, int prec)
 
 void set_fiq_handler(void *start, unsigned int length)
 {
-#if defined(CONFIG_CPU_USE_DOMAINS)
-	void *base = (void *)0xffff0000;
-#else
 	void *base = vectors_page;
-#endif
 	unsigned offset = FIQ_OFFSET;
 
 	memcpy(base + offset, start, length);
+	if (!cache_is_vipt_nonaliasing())
+		flush_icache_range((unsigned long)base + offset, offset +
+				   length);
 	flush_icache_range(0xffff0000 + offset, 0xffff0000 + offset + length);
-	if (!vectors_high())
-		flush_icache_range(offset, offset + length);
 }
 
 int claim_fiq(struct fiq_handler *f)
diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index ac4c2e5..943660c 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -223,6 +223,14 @@ void machine_power_off(void)
 
 	if (pm_power_off)
 		pm_power_off();
+
+	/* Give a grace period for failure to restart of 1s */
+	mdelay(1000);
+
+	/* A workaround for power off failed */
+	printk("Power off -- System halted\n");
+	local_irq_disable();
+	while (1);
 }
 
 /*
diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index 03deeff..4e2110d 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -733,8 +733,8 @@ static int vfp_set(struct task_struct *target,
 	if (ret)
 		return ret;
 
-	vfp_flush_hwstate(thread);
 	thread->vfpstate.hard = new_vfp;
+	vfp_flush_hwstate(thread);
 
 	return 0;
 }
diff --git a/arch/arm/kernel/return_address.c b/arch/arm/kernel/return_address.c
index ec49912..3a861fc 100644
--- a/arch/arm/kernel/return_address.c
+++ b/arch/arm/kernel/return_address.c
@@ -64,11 +64,6 @@ void *return_address(unsigned int level)
 /* #warning "TODO: return_address should use unwind tables" */
 #endif
 
-void *return_address(unsigned int level)
-{
-	return NULL;
-}
-
 #endif /* if defined(CONFIG_FRAME_POINTER) && !defined(CONFIG_ARM_UNWIND) / else */
 
 EXPORT_SYMBOL_GPL(return_address);
diff --git a/arch/arm/kernel/sys_oabi-compat.c b/arch/arm/kernel/sys_oabi-compat.c
index 3e94811..a0aee80 100644
--- a/arch/arm/kernel/sys_oabi-compat.c
+++ b/arch/arm/kernel/sys_oabi-compat.c
@@ -275,8 +275,12 @@ asmlinkage long sys_oabi_epoll_wait(int epfd,
 	mm_segment_t fs;
 	long ret, err, i;
 
-	if (maxevents <= 0 || maxevents > (INT_MAX/sizeof(struct epoll_event)))
+	if (maxevents <= 0 ||
+			maxevents > (INT_MAX/sizeof(*kbuf)) ||
+			maxevents > (INT_MAX/sizeof(*events)))
 		return -EINVAL;
+	if (!access_ok(VERIFY_WRITE, events, sizeof(*events) * maxevents))
+		return -EFAULT;
 	kbuf = kmalloc(sizeof(*kbuf) * maxevents, GFP_KERNEL);
 	if (!kbuf)
 		return -ENOMEM;
@@ -313,6 +317,8 @@ asmlinkage long sys_oabi_semtimedop(int semid,
 
 	if (nsops < 1 || nsops > SEMOPM)
 		return -EINVAL;
+	if (!access_ok(VERIFY_READ, tsops, sizeof(*tsops) * nsops))
+		return -EFAULT;
 	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
 	if (!sops)
 		return -ENOMEM;
diff --git a/arch/arm/kvm/interrupts.S b/arch/arm/kvm/interrupts.S
index 16cd4ba..bb117ab 100644
--- a/arch/arm/kvm/interrupts.S
+++ b/arch/arm/kvm/interrupts.S
@@ -159,13 +159,9 @@ __kvm_vcpu_return:
 	@ Don't trap coprocessor accesses for host kernel
 	set_hstr vmexit
 	set_hdcr vmexit
-	set_hcptr vmexit, (HCPTR_TTA | HCPTR_TCP(10) | HCPTR_TCP(11))
+	set_hcptr vmexit, (HCPTR_TTA | HCPTR_TCP(10) | HCPTR_TCP(11)), after_vfp_restore
 
 #ifdef CONFIG_VFPv3
-	@ Save floating point registers we if let guest use them.
-	tst	r2, #(HCPTR_TCP(10) | HCPTR_TCP(11))
-	bne	after_vfp_restore
-
 	@ Switch VFP/NEON hardware state to the host's
 	add	r7, vcpu, #VCPU_VFP_GUEST
 	store_vfp_state r7
@@ -177,6 +173,8 @@ after_vfp_restore:
 	@ Restore FPEXC_EN which we clobbered on entry
 	pop	{r2}
 	VFPFMXR FPEXC, r2
+#else
+after_vfp_restore:
 #endif
 
 	@ Reset Hyp-role
@@ -458,7 +456,7 @@ switch_to_guest_vfp:
 	push	{r3-r7}
 
 	@ NEON/VFP used.  Turn on VFP access.
-	set_hcptr vmexit, (HCPTR_TCP(10) | HCPTR_TCP(11))
+	set_hcptr vmtrap, (HCPTR_TCP(10) | HCPTR_TCP(11))
 
 	@ Switch VFP/NEON hardware state to the guest's
 	add	r7, r0, #VCPU_VFP_HOST
diff --git a/arch/arm/kvm/interrupts_head.S b/arch/arm/kvm/interrupts_head.S
index 6f18695..b6f6137 100644
--- a/arch/arm/kvm/interrupts_head.S
+++ b/arch/arm/kvm/interrupts_head.S
@@ -570,8 +570,13 @@ vcpu	.req	r0		@ vcpu pointer always in r0
 .endm
 
 /* Configures the HCPTR (Hyp Coprocessor Trap Register) on entry/return
- * (hardware reset value is 0). Keep previous value in r2. */
-.macro set_hcptr operation, mask
+ * (hardware reset value is 0). Keep previous value in r2.
+ * An ISB is emited on vmexit/vmtrap, but executed on vmexit only if
+ * VFP wasn't already enabled (always executed on vmtrap).
+ * If a label is specified with vmexit, it is branched to if VFP wasn't
+ * enabled.
+ */
+.macro set_hcptr operation, mask, label = none
 	mrc	p15, 4, r2, c1, c1, 2
 	ldr	r3, =\mask
 	.if \operation == vmentry
@@ -580,6 +585,17 @@ vcpu	.req	r0		@ vcpu pointer always in r0
 	bic	r3, r2, r3		@ Don't trap defined coproc-accesses
 	.endif
 	mcr	p15, 4, r3, c1, c1, 2
+	.if \operation != vmentry
+	.if \operation == vmexit
+	tst	r2, #(HCPTR_TCP(10) | HCPTR_TCP(11))
+	beq	1f
+	.endif
+	isb
+	.if \label != none
+	b	\label
+	.endif
+1:
+	.endif
 .endm
 
 /* Configures the HDCR (Hyp Debug Configuration Register) on entry/return
diff --git a/arch/arm/mach-ambarella/Kconfig b/arch/arm/mach-ambarella/Kconfig
index 74e23de..6a7911a 100644
--- a/arch/arm/mach-ambarella/Kconfig
+++ b/arch/arm/mach-ambarella/Kconfig
@@ -206,6 +206,7 @@ config PLAT_AMBARELLA_S2E
 	select PLAT_AMBARELLA_CORTEX_SMP
 	select PLAT_AMBARELLA_LOCAL_TIMERS if LOCAL_TIMERS
 	select PLAT_AMBARELLA_SUPPORT_PM if PM
+	select AMBARELLA_SREF_FIFO_EXEC	if PM
 	select PLAT_AMBARELLA_MEM_START_LOW
 	select PLAT_AMBARELLA_SUPPORT_MMAP_AXI
 	select PLAT_AMBARELLA_SUPPORT_MMAP_DRAMC
@@ -213,7 +214,9 @@ config PLAT_AMBARELLA_S2E
 	select PLAT_AMBARELLA_SUPPORT_HW_CRYPTO
 	select USB_ARCH_HAS_EHCI if USB_SUPPORT
 	select USB_ARCH_HAS_OHCI if USB_SUPPORT
+	select ARM_ERRATA_754322
 	select ARM_ERRATA_764369 if SMP
+	select ARM_ERRATA_775420
 	select PL310_ERRATA_588369 if CACHE_PL310
 	select PL310_ERRATA_727915 if CACHE_PL310
 	help
@@ -260,6 +263,7 @@ config PLAT_AMBARELLA_S2L
 	select PLAT_AMBARELLA_SUPPORT_PM if PM
 	select PLAT_AMBARELLA_MEM_START_LOW
 	select PLAT_AMBARELLA_AHB_APB_HIGH
+	select AMBARELLA_SREF_FIFO_EXEC if PM
 	select PLAT_AMBARELLA_SUPPORT_MMAP_AXI
 	select PLAT_AMBARELLA_SUPPORT_MMAP_DRAMC
 	select PLAT_AMBARELLA_SUPPORT_MMAP_DBGBUS
@@ -293,10 +297,36 @@ config PLAT_AMBARELLA_S3
 	help
 	  Say Y here if you are using Ambarella S3.
 
+config PLAT_AMBARELLA_S3L
+	bool "S3L"
+	select PLAT_AMBARELLA_CORTEX
+	select PLAT_AMBARELLA_SUPPORT_PM if PM
+	select AMBARELLA_SREF_FIFO_EXEC	if PM
+	select PLAT_AMBARELLA_MEM_START_LOW
+	select PLAT_AMBARELLA_AHB_APB_HIGH
+	select PLAT_AMBARELLA_SUPPORT_MMAP_AXI
+	select PLAT_AMBARELLA_SUPPORT_MMAP_DRAMC
+	select PLAT_AMBARELLA_SUPPORT_MMAP_DBGBUS
+	select PLAT_AMBARELLA_SUPPORT_VIC
+	select PLAT_AMBARELLA_SUPPORT_HW_CRYPTO
+	select USB_ARCH_HAS_EHCI if USB_SUPPORT
+	select USB_ARCH_HAS_OHCI if USB_SUPPORT
+	select PL310_ERRATA_588369 if CACHE_PL310
+	select PL310_ERRATA_727915 if CACHE_PL310
+	help
+	  Say Y here if you are using Ambarella S3L.
+
 endchoice
 
 menu "Generic Platform Configuration"
 
+config AMBARELLA_CALC_PLL
+	bool "Setup PLL by Calculation"
+	select RATIONAL
+	default n
+	help
+	  If you are not sure, say N here.
+
 config AMBARELLA_RAW_BOOT
 	bool "Raw boot mode"
 	default n
@@ -310,13 +340,6 @@ config PLAT_AMBARELLA_LOWER_ARM_PLL
 	help
 	  If you are not sure, say N here.
 
-config AMBARELLA_SUPPORT_BAPI
-	bool "Suport BAPI"
-	depends on !AMBARELLA_RAW_BOOT
-	default n
-	help
-	  If you are not sure, say N here.
-
 config AMBARELLA_PMUSERENR_EN
 	bool "Enable userspcae access to PMU"
 	default n
@@ -338,12 +361,6 @@ config AMBARELLA_SYS_CACHE_CALL
 	help
 	  If you are not sure, say N here.
 
-config AMBARELLA_SYS_BAPI_CALL
-	bool "Support BAPI Configuration"
-	default n
-	help
-	  If you are not sure, say N here.
-
 endmenu
 
 menu "Proc file system support"
@@ -452,6 +469,12 @@ config AMBARELLA_EXT_GPIO_NUM
 	help
 	  Depends on your HW design.
 
+config AMBARELLA_SREF_FIFO_EXEC
+	bool "Self refresh code executed in FIO fifo"
+	default n
+	depends on PLAT_AMBARELLA_SUPPORT_PM
+	help
+		Self refresh 2nd solution.
 endmenu
 
 endif
diff --git a/arch/arm/mach-ambarella/Makefile b/arch/arm/mach-ambarella/Makefile
index 7fc8b0f0..b8238cb 100644
--- a/arch/arm/mach-ambarella/Makefile
+++ b/arch/arm/mach-ambarella/Makefile
@@ -22,7 +22,12 @@
 
 obj-y						+= fio.o
 obj-y						+= init.o
-obj-y						+= pll.o clk.o clk_table.o
+obj-y						+= clk.o
+ifeq ($(CONFIG_AMBARELLA_CALC_PLL),y)
+obj-y						+= clk_calc.o
+else
+obj-y						+= clk_table.o
+endif
 obj-$(CONFIG_PLAT_AMBARELLA_SUPPORT_PM)		+= pm.o
 obj-$(CONFIG_PLAT_AMBARELLA_SUPPORT_PM)		+= sleep.o
 obj-y						+= timer.o
diff --git a/arch/arm/mach-ambarella/clk.c b/arch/arm/mach-ambarella/clk.c
index f5fddbf..d06365f 100644
--- a/arch/arm/mach-ambarella/clk.c
+++ b/arch/arm/mach-ambarella/clk.c
@@ -20,334 +20,67 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  */
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
 #include <linux/list.h>
-#include <linux/errno.h>
-#include <linux/err.h>
-#include <linux/platform_device.h>
+#include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/spinlock.h>
 #include <linux/io.h>
-#include <linux/export.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/clk.h>
 #include <asm/uaccess.h>
 #include <mach/hardware.h>
+#include <plat/iav_helper.h>
+#include <plat/sd.h>
 #include <plat/clk.h>
 
 /* ==========================================================================*/
 static LIST_HEAD(ambarella_all_clocks);
 DEFINE_SPINLOCK(ambarella_clock_lock);
+struct ambarella_service pll_service;
 
 /* ==========================================================================*/
 static unsigned int ambarella_clk_ref_freq = REF_CLK_FREQ;
 
-u32 ambarella_rct_find_pll_table_index(unsigned long rate, u32 pre_scaler,
-	const struct pll_table *table, u32 table_size)
+unsigned int ambarella_clk_get_ref_freq(void)
 {
-	u64 dividend;
-	u64 divider;
-	u32 start;
-	u32 middle;
-	u32 end;
-	u32 index_limit;
-	u64 diff = 0;
-	u64 diff_low = 0xFFFFFFFFFFFFFFFF;
-	u64 diff_high = 0xFFFFFFFFFFFFFFFF;
-
-	pr_debug("pre_scaler = [0x%08X]\n", pre_scaler);
-
-	dividend = rate;
-	dividend *= pre_scaler;
-	dividend *= (1000 * 1000 * 1000);
-	divider = ambarella_clk_ref_freq / (1000 * 1000);
-	AMBCLK_DO_DIV(dividend, divider);
-
-	index_limit = (table_size - 1);
-	start = 0;
-	end = index_limit;
-	middle = table_size / 2;
-	while (table[middle].multiplier != dividend) {
-		if (table[middle].multiplier < dividend) {
-			start = middle;
-		} else {
-			end = middle;
-		}
-		middle = (start + end) / 2;
-		if (middle == start || middle == end) {
-			break;
-		}
-	}
-	if ((middle > 0) && ((middle + 1) <= index_limit)) {
-		if (table[middle - 1].multiplier < dividend) {
-			diff_low = dividend - table[middle - 1].multiplier;
-		} else {
-			diff_low = table[middle - 1].multiplier - dividend;
-		}
-		if (table[middle].multiplier < dividend) {
-			diff = dividend - table[middle].multiplier;
-		} else {
-			diff = table[middle].multiplier - dividend;
-		}
-		if (table[middle + 1].multiplier < dividend) {
-			diff_high = dividend - table[middle + 1].multiplier;
-		} else {
-			diff_high = table[middle + 1].multiplier - dividend;
-		}
-		pr_debug("multiplier[%u] = [%llu]\n", (middle - 1),
-			table[middle - 1].multiplier);
-		pr_debug("multiplier[%u] = [%llu]\n", (middle),
-			table[middle].multiplier);
-		pr_debug("multiplier[%u] = [%llu]\n", (middle + 1),
-			table[middle + 1].multiplier);
-	} else if ((middle == 0) && ((middle + 1) <= index_limit)) {
-		if (table[middle].multiplier < dividend) {
-			diff = dividend - table[middle].multiplier;
-		} else {
-			diff = table[middle].multiplier - dividend;
-		}
-		if (table[middle + 1].multiplier < dividend) {
-			diff_high = dividend - table[middle + 1].multiplier;
-		} else {
-			diff_high = table[middle + 1].multiplier - dividend;
-		}
-		pr_debug("multiplier[%u] = [%llu]\n", (middle),
-			table[middle].multiplier);
-		pr_debug("multiplier[%u] = [%llu]\n", (middle + 1),
-			table[middle + 1].multiplier);
-	} else if ((middle > 0) && ((middle + 1) > index_limit)) {
-		if (table[middle - 1].multiplier < dividend) {
-			diff_low = dividend - table[middle - 1].multiplier;
-		} else {
-			diff_low = table[middle - 1].multiplier - dividend;
-		}
-		if (table[middle].multiplier < dividend) {
-			diff = dividend - table[middle].multiplier;
-		} else {
-			diff = table[middle].multiplier - dividend;
-		}
-		pr_debug("multiplier[%u] = [%llu]\n", (middle - 1),
-			table[middle - 1].multiplier);
-		pr_debug("multiplier[%u] = [%llu]\n", (middle),
-			table[middle].multiplier);
-	}
-	pr_debug("diff_low = [%llu]\n", diff_low);
-	pr_debug("diff = [%llu]\n", diff);
-	pr_debug("diff_high = [%llu]\n", diff_high);
-	if (diff_low < diff) {
-		if (middle) {
-			middle--;
-		}
-	}
-	if (diff_high < diff) {
-		middle++;
-		if (middle > index_limit) {
-			middle = index_limit;
-		}
-	}
-	pr_debug("middle = [%u]\n", middle);
-
-	return middle;
+	return ambarella_clk_ref_freq;
 }
-EXPORT_SYMBOL(ambarella_rct_find_pll_table_index);
+EXPORT_SYMBOL(ambarella_clk_get_ref_freq);
 
 /* ==========================================================================*/
-unsigned long ambarella_rct_clk_get_rate(struct clk *c)
-{
-	u32 pre_scaler, post_scaler, intp, sdiv, sout;
-	u64 dividend, divider, frac;
-	union ctrl_reg_u ctrl_reg;
-	union frac_reg_u frac_reg;
-
-	BUG_ON(c->ctrl_reg == -1 || c->frac_reg == -1);
-
-	ctrl_reg.w = amba_rct_readl(c->ctrl_reg);
-	if ((ctrl_reg.s.power_down == 1) || (ctrl_reg.s.halt_vco == 1)) {
-		c->rate = 0;
-		return c->rate;
-	}
-
-	frac_reg.w = amba_rct_readl(c->frac_reg);
-
-	if (c->pres_reg != -1) {
-		pre_scaler = amba_rct_readl(c->pres_reg);
-		if (c->extra_scaler == 1) {
-			pre_scaler >>= 4;
-			pre_scaler++;
-		}
-	} else {
-		pre_scaler = 1;
-	}
-
-	if (c->post_reg != -1) {
-		post_scaler = amba_rct_readl(c->post_reg);
-		if (c->extra_scaler == 1) {
-			post_scaler >>= 4;
-			post_scaler++;
-		}
-	} else {
-		post_scaler = 1;
-	}
-
-	if (ctrl_reg.s.bypass || ctrl_reg.s.force_bypass) {
-		c->rate = ambarella_clk_ref_freq / pre_scaler / post_scaler;
-		return c->rate;
-	}
-
-	intp = ctrl_reg.s.intp;
-	sdiv = ctrl_reg.s.sdiv;
-	sout = ctrl_reg.s.sout;
-
-	dividend = (u64)ambarella_clk_ref_freq;
-	dividend *= (u64)(intp + 1);
-	dividend *= (u64)(sdiv + 1);
-	if (ctrl_reg.s.frac_mode) {
-		if (frac_reg.s.nega) {
-			/* Negative */
-			frac = (0x80000000 - frac_reg.s.frac);
-			frac = (ambarella_clk_ref_freq * frac * (sdiv + 1));
-			frac >>= 32;
-			dividend = dividend - frac;
-		} else {
-			/* Positive */
-			frac = frac_reg.s.frac;
-			frac = (ambarella_clk_ref_freq * frac * (sdiv + 1));
-			frac >>= 32;
-			dividend = dividend + frac;
-		}
-	}
-
-	divider = (pre_scaler * (sout + 1) * post_scaler);
-	if (c->divider)
-		divider *= c->divider;
 
-	if (divider == 0) {
-		c->rate = 0;
-		return c->rate;
-	}
-
-	AMBCLK_DO_DIV(dividend, divider);
-	c->rate = dividend;
-
-	return c->rate;
-}
-EXPORT_SYMBOL(ambarella_rct_clk_get_rate);
-
-int ambarella_rct_clk_set_rate(struct clk *c, unsigned long rate)
-{
-	u32 pre_scaler, post_scaler, middle;
-	u32 intp, sdiv, sout, post, ctrl2, ctrl3;
-	u64 dividend, divider, diff;
-	union ctrl_reg_u ctrl_reg;
-	union frac_reg_u frac_reg;
-
-	if (!rate)
-		return -1;
-
-	BUG_ON(c->ctrl_reg == -1 || c->ctrl2_reg == -1 || c->ctrl3_reg == -1);
-	BUG_ON(c->post_reg != -1 && !c->max_divider);
-	BUG_ON(!c->table || c->table_size == 0);
-#if 0
-	if (c->divider)
-		rate *= c->divider;
-#endif
-	if (c->pres_reg != -1) {
-		if (c->pres_val) {
-			pre_scaler = c->pres_val;
-			if (c->extra_scaler == 1)
-				amba_rct_writel_en(c->pres_reg, (pre_scaler - 1) << 4);
-			else
-				amba_rct_writel(c->pres_reg, pre_scaler);
-		} else {
-			pre_scaler = amba_rct_readl(c->pres_reg);
-			if (c->extra_scaler == 1) {
-				pre_scaler >>= 4;
-				pre_scaler++;
-			}
-		}
-	} else {
-		pre_scaler = 1;
-	}
-
-	middle = ambarella_rct_find_pll_table_index(rate,
-			pre_scaler, c->table, c->table_size);
-	intp = c->table[middle].intp;
-	sdiv = c->table[middle].sdiv;
-	sout = c->table[middle].sout;
-	post = c->post_val ? c->post_val : c->table[middle].post;
-
-	ctrl_reg.w = amba_rct_readl(c->ctrl_reg);
-	ctrl_reg.s.intp = intp;
-	ctrl_reg.s.sdiv = sdiv;
-	ctrl_reg.s.sout = sout;
-	ctrl_reg.s.bypass = 0;
-	ctrl_reg.s.frac_mode = 0;
-	ctrl_reg.s.force_reset = 0;
-	ctrl_reg.s.power_down = 0;
-	ctrl_reg.s.halt_vco = 0;
-	ctrl_reg.s.tristate = 0;
-	ctrl_reg.s.force_lock = 1;
-	ctrl_reg.s.force_bypass = 0;
-	ctrl_reg.s.write_enable = 0;
-	amba_rct_writel_en(c->ctrl_reg, ctrl_reg.w);
-
-	if (c->post_reg != -1) {
-		post_scaler = min(post, c->max_divider);
-		if (c->extra_scaler == 1)
-			amba_rct_writel_en(c->post_reg, (post_scaler - 1) << 4);
-		else
-			amba_rct_writel(c->post_reg, post_scaler);
-	}
-
-	if (c->frac_mode) {
-		c->rate = ambarella_rct_clk_get_rate(c);
-		if (c->rate < rate)
-			diff = rate - c->rate;
-		else
-			diff = c->rate - rate;
-
-		dividend = diff * pre_scaler * (sout + 1) * post;
-		if (c->divider)
-			dividend *= c->divider;
-		dividend = dividend << 32;
-		divider = (u64)ambarella_clk_ref_freq * (sdiv + 1);
-		AMBCLK_DO_DIV_ROUND(dividend, divider);
-		if (c->rate <= rate) {
-			frac_reg.s.nega	= 0;
-			frac_reg.s.frac	= dividend;
-		} else {
-			frac_reg.s.nega	= 1;
-			frac_reg.s.frac	= 0x80000000 - dividend;
-		}
-		amba_rct_writel(c->frac_reg, frac_reg.w);
-
-		ctrl_reg.w = amba_rct_readl(c->ctrl_reg);
-		if (diff)
-			ctrl_reg.s.frac_mode = 1;
-		else
-			ctrl_reg.s.frac_mode = 0;
-
-		ctrl_reg.s.force_lock = 1;
-		ctrl_reg.s.write_enable = 1;
-		amba_rct_writel(c->ctrl_reg, ctrl_reg.w);
-
-		ctrl_reg.s.write_enable	= 0;
-		amba_rct_writel(c->ctrl_reg, ctrl_reg.w);
-	}
-
-	ctrl2 = c->ctrl2_val ? c->ctrl2_val : 0x3f770000;
-	ctrl3 = c->ctrl3_val ? c->ctrl3_val : ctrl_reg.s.frac_mode ? 0x00069300 : 0x00068300;
-	amba_rct_writel(c->ctrl2_reg, ctrl2);
-	amba_rct_writel(c->ctrl3_reg, ctrl3);
-
-	c->rate = ambarella_rct_clk_get_rate(c);
+struct clk_ops ambarella_rct_scaler_ops = {
+	.enable		= NULL,
+	.disable	= NULL,
+	.get_rate	= ambarella_rct_scaler_get_rate,
+	.round_rate	= NULL,
+	.set_rate	= ambarella_rct_scaler_set_rate,
+	.set_parent	= NULL,
+};
+EXPORT_SYMBOL(ambarella_rct_scaler_ops);
+
+struct clk_ops ambarella_rct_pll_ops = {
+	.enable		= ambarella_rct_clk_enable,
+	.disable	= ambarella_rct_clk_disable,
+	.get_rate	= ambarella_rct_clk_get_rate,
+	.round_rate	= NULL,
+	.set_rate	= ambarella_rct_clk_set_rate,
+	.set_parent	= NULL,
+};
+EXPORT_SYMBOL(ambarella_rct_pll_ops);
+
+struct clk_ops ambarella_rct_adj_ops = {
+	.enable		= ambarella_rct_clk_enable,
+	.disable	= ambarella_rct_clk_disable,
+	.get_rate	= ambarella_rct_clk_get_rate,
+	.round_rate	= NULL,
+	.set_rate	= ambarella_rct_clk_adj_rate,
+	.set_parent	= NULL,
+};
+EXPORT_SYMBOL(ambarella_rct_adj_ops);
 
-	return 0;
-}
-EXPORT_SYMBOL(ambarella_rct_clk_set_rate);
+/* ==========================================================================*/
 
 int ambarella_rct_clk_enable(struct clk *c)
 {
@@ -402,7 +135,7 @@ unsigned long ambarella_rct_scaler_get_rate(struct clk *c)
 	u32 parent_rate, divider;
 
 	if (!c->parent || !c->parent->ops || !c->parent->ops->get_rate)
-		parent_rate = ambarella_clk_ref_freq;
+		parent_rate = ambarella_clk_get_ref_freq();
 	else
 		parent_rate = c->parent->ops->get_rate(c->parent);
 
@@ -435,7 +168,7 @@ int ambarella_rct_scaler_set_rate(struct clk *c, unsigned long rate)
 	BUG_ON(c->post_reg == -1 || !c->max_divider);
 
 	if (!c->parent || !c->parent->ops || !c->parent->ops->get_rate)
-		parent_rate = ambarella_clk_ref_freq;
+		parent_rate = ambarella_clk_get_ref_freq();
 	else
 		parent_rate = c->parent->ops->get_rate(c->parent);
 
@@ -461,6 +194,147 @@ int ambarella_rct_scaler_set_rate(struct clk *c, unsigned long rate)
 }
 EXPORT_SYMBOL(ambarella_rct_scaler_set_rate);
 
+unsigned long ambarella_rct_clk_get_rate(struct clk *c)
+{
+	u32 pre_scaler, post_scaler, intp, sdiv, sout;
+	u64 dividend, divider, frac;
+	union ctrl_reg_u ctrl_reg;
+	union frac_reg_u frac_reg;
+
+	BUG_ON(c->ctrl_reg == -1 || c->frac_reg == -1);
+
+	ctrl_reg.w = amba_rct_readl(c->ctrl_reg);
+	if ((ctrl_reg.s.power_down == 1) || (ctrl_reg.s.halt_vco == 1)) {
+		c->rate = 0;
+		return c->rate;
+	}
+
+	frac_reg.w = amba_rct_readl(c->frac_reg);
+
+	if (c->pres_reg != -1) {
+		pre_scaler = amba_rct_readl(c->pres_reg);
+		if (c->extra_scaler == 1) {
+			pre_scaler >>= 4;
+			pre_scaler++;
+		}
+	} else {
+		pre_scaler = 1;
+	}
+
+	if (c->post_reg != -1) {
+		post_scaler = amba_rct_readl(c->post_reg);
+		if (c->extra_scaler == 1) {
+			post_scaler >>= 4;
+			post_scaler++;
+		}
+	} else {
+		post_scaler = 1;
+	}
+
+	if (ctrl_reg.s.bypass || ctrl_reg.s.force_bypass) {
+		c->rate = ambarella_clk_get_ref_freq() / pre_scaler / post_scaler;
+		return c->rate;
+	}
+
+	intp = ctrl_reg.s.intp + 1;
+	sdiv = ctrl_reg.s.sdiv + 1;
+	sout = ctrl_reg.s.sout + 1;
+
+	dividend = (u64)ambarella_clk_get_ref_freq();
+	dividend *= (u64)intp;
+	dividend *= (u64)sdiv;
+	if (ctrl_reg.s.frac_mode) {
+		if (frac_reg.s.nega) {
+			/* Negative */
+			frac = (0x80000000 - frac_reg.s.frac);
+			frac = (ambarella_clk_get_ref_freq() * frac * sdiv);
+			frac >>= 32;
+			dividend = dividend - frac;
+		} else {
+			/* Positive */
+			frac = frac_reg.s.frac;
+			frac = (ambarella_clk_get_ref_freq() * frac * sdiv);
+			frac >>= 32;
+			dividend = dividend + frac;
+		}
+	}
+
+	divider = pre_scaler * sout * post_scaler;
+	if (c->divider)
+		divider *= c->divider;
+
+	if (divider == 0) {
+		c->rate = 0;
+		return c->rate;
+	}
+
+	AMBCLK_DO_DIV(dividend, divider);
+	c->rate = dividend;
+
+	return c->rate;
+}
+EXPORT_SYMBOL(ambarella_rct_clk_get_rate);
+
+
+int ambarella_rct_clk_adj_rate(struct clk *c, unsigned long rate)
+{
+	union ctrl_reg_u ctrl_reg;
+	u32 curr_rate;
+	u32 IntStepPllOut24MHz;
+	u32 TargetIntp;
+
+	/* get current PLL control registers' values */
+	ctrl_reg.w = amba_rct_readl(c->ctrl_reg);
+
+	if (ctrl_reg.s.sdiv >= ctrl_reg.s.sout) {
+		while (ctrl_reg.s.sdiv > ctrl_reg.s.sout) {
+			ctrl_reg.s.sdiv--;
+			amba_rct_writel(c->ctrl_reg, ctrl_reg.w);
+		}
+		IntStepPllOut24MHz = 1;
+	} else {
+		IntStepPllOut24MHz = (ctrl_reg.s.sout + 1) / (ctrl_reg.s.sdiv + 1);
+	}
+
+	curr_rate = ambarella_rct_clk_get_rate(c);
+	TargetIntp = rate * (ctrl_reg.s.sout + 1) / ((ctrl_reg.s.sdiv + 1) * REF_CLK_FREQ) - 1;
+
+	if (curr_rate > rate) {
+		/* decrease the frequency */
+		while (curr_rate > rate && ctrl_reg.s.intp > 0) {
+			if (ctrl_reg.s.intp - TargetIntp >= IntStepPllOut24MHz)
+				ctrl_reg.s.intp -= IntStepPllOut24MHz;
+			else
+				ctrl_reg.s.intp--;
+
+			amba_rct_writel_en(c->ctrl_reg, ctrl_reg.w);
+			curr_rate = ambarella_rct_clk_get_rate(c);
+		}
+	} else {
+		/* increase the frequency */
+		if (TargetIntp > 123)
+			TargetIntp = 123;
+
+		while (curr_rate < rate && ctrl_reg.s.intp < 123) {
+			if (TargetIntp - ctrl_reg.s.intp >= IntStepPllOut24MHz)
+				ctrl_reg.s.intp += IntStepPllOut24MHz;
+			else
+				ctrl_reg.s.intp++;
+
+			amba_rct_writel_en(c->ctrl_reg, ctrl_reg.w);
+			curr_rate = ambarella_rct_clk_get_rate(c);
+		}
+
+		if (curr_rate > rate && ctrl_reg.s.intp > 6) {
+			/* decrease the frequency so that is it is just below expected */
+			ctrl_reg.s.intp--;
+			amba_rct_writel_en(c->ctrl_reg, ctrl_reg.w);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ambarella_rct_clk_adj_rate);
 
 /* ==========================================================================*/
 struct clk *clk_get_sys(const char *dev_id, const char *con_id)
@@ -628,7 +502,19 @@ EXPORT_SYMBOL(clk_set_parent);
 
 int ambarella_clk_add(struct clk *clk)
 {
+	struct clk *p;
+
+	if (IS_ERR(clk) || (clk == NULL))
+		return -EINVAL;
+
 	spin_lock(&ambarella_clock_lock);
+	list_for_each_entry(p, &ambarella_all_clocks, list) {
+		if (clk == p) {
+			pr_err("clk %s is existed\n", clk->name);
+			spin_unlock(&ambarella_clock_lock);
+			return -EEXIST;
+		}
+	}
 	list_add(&clk->list, &ambarella_all_clocks);
 	spin_unlock(&ambarella_clock_lock);
 
@@ -654,6 +540,40 @@ static int ambarella_clock_proc_show(struct seq_file *m, void *v)
 	return retlen;
 }
 
+static int ambarella_clock_proc_write(struct file *file,
+	const char __user *buffer, size_t count, loff_t *ppos)
+{
+	struct clk *gclk;
+	char *buf, clk_name[32];
+	int freq, rval = count;
+
+	pr_warn("!!!DANGEROUS!!! You must know what you are doning!\n");
+
+	buf = kmalloc(count, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, buffer, count)) {
+		rval = -EFAULT;
+		goto exit;
+	}
+
+	sscanf(buf, "%s %d", clk_name, &freq);
+
+	gclk = clk_get(NULL, clk_name);
+	if (IS_ERR(gclk)) {
+		pr_err("Invalid clk name\n");
+		rval = -EINVAL;
+		goto exit;
+	}
+
+	clk_set_rate(gclk, freq);
+
+exit:
+	kfree(buf);
+	return rval;
+}
+
 static int ambarella_clock_proc_open(struct inode *inode, struct file *file)
 {
 	return single_open(file, ambarella_clock_proc_show, PDE_DATA(inode));
@@ -663,6 +583,7 @@ static const struct file_operations proc_clock_fops = {
 	.open = ambarella_clock_proc_open,
 	.read = seq_read,
 	.llseek = seq_lseek,
+	.write = ambarella_clock_proc_write,
 };
 #endif
 
@@ -671,7 +592,6 @@ int __init ambarella_clk_init(void)
 {
 	int ret_val = 0;
 
-	ambarella_clk_ref_freq = REF_CLK_FREQ;
 #if defined(CONFIG_AMBARELLA_PLL_PROC)
 	proc_create_data("clock", S_IRUGO, get_ambarella_proc_dir(),
 		&proc_clock_fops, NULL);
@@ -681,9 +601,632 @@ int __init ambarella_clk_init(void)
 }
 
 /* ==========================================================================*/
-unsigned int ambarella_clk_get_ref_freq(void)
+
+static struct clk pll_out_core = {
+	.parent		= NULL,
+	.name		= "pll_out_core",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= PLL_CORE_CTRL_REG,
+	.pres_reg	= -1,
+	.post_reg	= -1,
+	.frac_reg	= PLL_CORE_FRAC_REG,
+	.ctrl2_reg	= PLL_CORE_CTRL2_REG,
+	.ctrl3_reg	= PLL_CORE_CTRL3_REG,
+	.lock_reg	= PLL_LOCK_REG,
+	.lock_bit	= 6,
+	.divider	= 0,
+	.max_divider	= 0,
+	.extra_scaler	= 0,
+	.table		= ambarella_pll_int_table,
+	.table_size	= ARRAY_SIZE(ambarella_pll_int_table),
+	.ops		= &ambarella_rct_adj_ops,
+};
+
+static struct clk gclk_core = {
+	.parent		= &pll_out_core,
+	.name		= "gclk_core",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+#if ((CHIP_REV == A5S) || (CHIP_REV == S2) || (CHIP_REV == S2E))
+	.post_reg	= SCALER_CORE_POST_REG,
+#else
+	.post_reg	= -1,
+#endif
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+#if ((CHIP_REV == A5S) || (CHIP_REV == S2) || (CHIP_REV == S2E))
+	.divider	= 0,
+	.max_divider	= (1 << 4) - 1,
+#else
+	.divider	= 2,
+	.max_divider	= 0,
+#endif
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+
+static struct clk gclk_ahb = {
+	.parent		= &gclk_core,
+	.name		= "gclk_ahb",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= -1,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+#if (CHIP_REV == A5S)
+	.divider	= 1,
+#else
+	.divider	= 2,
+#endif
+	.max_divider	= 0,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+
+static struct clk gclk_apb = {
+	.parent		= &gclk_ahb,
+	.name		= "gclk_apb",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= -1,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 2,
+	.max_divider	= 0,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+
+static struct clk gclk_ddr = {
+	.parent		= NULL,
+	.name		= "gclk_ddr",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= PLL_DDR_CTRL_REG,
+	.pres_reg	= -1,
+	.post_reg	= -1,
+	.frac_reg	= PLL_DDR_FRAC_REG,
+	.ctrl2_reg	= PLL_DDR_CTRL2_REG,
+	.ctrl3_reg	= PLL_DDR_CTRL3_REG,
+	.lock_reg	= PLL_LOCK_REG,
+	.lock_bit	= 5,
+	.divider	= 2,
+	.max_divider	= 0,
+	.extra_scaler	= 0,
+	.table		= ambarella_pll_int_table,
+	.table_size	= ARRAY_SIZE(ambarella_pll_int_table),
+	.ops		= &ambarella_rct_adj_ops,
+};
+
+/* ==========================================================================*/
+#if defined(CONFIG_PLAT_AMBARELLA_CORTEX)
+static struct clk gclk_cortex = {
+	.parent		= NULL,
+	.name		= "gclk_cortex",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= PLL_CORTEX_CTRL_REG,
+	.pres_reg	= -1,
+	.post_reg	= -1,
+	.frac_reg	= PLL_CORTEX_FRAC_REG,
+	.ctrl2_reg	= PLL_CORTEX_CTRL2_REG,
+	.ctrl3_reg	= PLL_CORTEX_CTRL3_REG,
+	.lock_reg	= PLL_LOCK_REG,
+	.lock_bit	= 2,
+	.divider	= 0,
+	.max_divider	= 0,
+	.extra_scaler	= 0,
+	.table		= ambarella_pll_int_table,
+	.table_size	= ARRAY_SIZE(ambarella_pll_int_table),
+	.ops		= &ambarella_rct_adj_ops,
+};
+static struct clk gclk_axi = {
+	.parent		= &gclk_cortex,
+	.name		= "gclk_axi",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= -1,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 3,
+	.max_divider	= 0,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+#if defined(CONFIG_HAVE_ARM_TWD)
+static struct clk clk_smp_twd = {
+	.parent		= &gclk_axi,
+	.name		= "smp_twd",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= -1,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 1,
+	.max_divider	= 0,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+#endif
+#endif
+
+static struct clk gclk_idsp = {
+	.parent		= NULL,
+	.name		= "gclk_idsp",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= PLL_IDSP_CTRL_REG,
+	.pres_reg	= -1,
+	.post_reg	= SCALER_IDSP_POST_REG,
+	.frac_reg	= PLL_IDSP_FRAC_REG,
+	.ctrl2_reg	= PLL_IDSP_CTRL2_REG,
+	.ctrl3_reg	= PLL_IDSP_CTRL3_REG,
+	.lock_reg	= PLL_LOCK_REG,
+	.lock_bit	= 4,
+	.divider	= 0,
+	.max_divider	= (1 << 4) - 1,
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+	.extra_scaler	= 1,
+#else
+	.extra_scaler	= 0,
+#endif
+	.table		= ambarella_pll_int_table,
+	.table_size	= ARRAY_SIZE(ambarella_pll_int_table),
+	.ops		= &ambarella_rct_pll_ops,
+};
+
+#ifdef CONFIG_AMBARELLA_CALC_PLL
+static struct clk gclk_so = {
+	.parent		= NULL,
+	.name		= "gclk_so",
+	.rate		= 0,
+	.frac_mode	= 1,
+	.ctrl_reg	= PLL_SENSOR_CTRL_REG,
+	.pres_reg	= SCALER_SENSOR_PRE_REG,
+	.post_reg	= SCALER_SENSOR_POST_REG,
+	.frac_reg	= PLL_SENSOR_FRAC_REG,
+	.ctrl2_reg	= PLL_SENSOR_CTRL2_REG,
+	.ctrl3_reg	= PLL_SENSOR_CTRL3_REG,
+	.lock_reg	= PLL_LOCK_REG,
+	.lock_bit	= 3,
+	.divider	= 0,
+	.max_divider	= (1 << 4) - 1,
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+	.max_divider	= (1 << 4) - 1,
+	.extra_scaler	= 1,
+#else
+	.max_divider	= (1 << 16) - 1,
+	.extra_scaler	= 0,
+#endif
+	.ops		= &ambarella_rct_pll_ops,
+};
+
+static struct clk gclk_vo = {
+	.parent		= NULL,
+	.name		= "gclk_vo",
+	.rate		= 0,
+	.frac_mode	= 1,
+	.ctrl_reg	= PLL_HDMI_CTRL_REG,
+	.pres_reg	= SCALER_HDMI_PRE_REG,
+	.post_reg	= -1,
+	.frac_reg	= PLL_HDMI_FRAC_REG,
+	.ctrl2_reg	= PLL_HDMI_CTRL2_REG,
+#if (CHIP_REV == S2E) || (CHIP_REV == S3L)
+	.ctrl2_val	= 0x3f770b00,
+#endif
+	.ctrl3_reg	= PLL_HDMI_CTRL3_REG,
+	.lock_reg	= PLL_LOCK_REG,
+	.lock_bit	= 8,
+	.divider	= 10,
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+	.max_divider	= (1 << 4) - 1,
+	.extra_scaler	= 1,
+#else
+	.max_divider	= (1 << 16) - 1,
+	.extra_scaler	= 0,
+#endif
+	.ops		= &ambarella_rct_pll_ops,
+};
+
+static struct clk gclk_vo2 = {
+	.parent		= NULL,
+	.name		= "gclk_vo2",
+	.rate		= 0,
+	.frac_mode	= 1,
+	.ctrl_reg	= PLL_VIDEO2_CTRL_REG,
+	.pres_reg	= SCALER_VIDEO2_PRE_REG,
+	.post_reg	= SCALER_VIDEO2_POST_REG,
+	.frac_reg	= PLL_VIDEO2_FRAC_REG,
+	.ctrl2_reg	= PLL_VIDEO2_CTRL2_REG,
+	.ctrl3_reg	= PLL_VIDEO2_CTRL3_REG,
+	.lock_reg	= PLL_LOCK_REG,
+	.lock_bit	= 0,
+	.divider	= 0,
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+	.max_divider	= (1 << 4) - 1,
+	.extra_scaler	= 1,
+#else
+	.max_divider	= (1 << 16) - 1,
+	.extra_scaler	= 0,
+#endif
+	.ops		= &ambarella_rct_pll_ops,
+};
+#endif
+
+static struct clk gclk_uart = {
+#if (CHIP_REV == S2E)
+	.parent		= &gclk_idsp,
+#else
+	.parent		= NULL,
+#endif
+	.name		= "gclk_uart",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= CG_UART_REG,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 0,
+	.max_divider	= (1 << 24) - 1,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+
+static struct clk gclk_audio = {
+	.parent		= NULL,
+	.name		= "gclk_audio",
+	.rate		= 0,
+	.frac_mode	= 1,
+	.ctrl_reg	= PLL_AUDIO_CTRL_REG,
+	.pres_reg	= SCALER_AUDIO_PRE_REG,
+	.post_reg	= SCALER_AUDIO_POST_REG,
+	.frac_reg	= PLL_AUDIO_FRAC_REG,
+	.ctrl2_reg	= PLL_AUDIO_CTRL2_REG,
+	.ctrl3_reg	= PLL_AUDIO_CTRL3_REG,
+	.lock_reg	= PLL_LOCK_REG,
+	.lock_bit	= 7,
+	.divider	= 0,
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+	.max_divider	= (1 << 4) - 1,
+	.extra_scaler	= 1,
+#else
+	.max_divider	= (1 << 16) - 1,
+	.extra_scaler	= 0,
+#endif
+	.table		= ambarella_pll_frac_table,
+	.table_size	= ARRAY_SIZE(ambarella_pll_frac_table),
+	.ops		= &ambarella_rct_pll_ops,
+};
+
+#if (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+static struct clk pll_out_sd = {
+	.parent		= NULL,
+	.name		= "pll_out_sd",
+	.rate		= 0,
+	.frac_mode	= 1,
+	.ctrl_reg	= PLL_SD_CTRL_REG,
+	.pres_reg	= -1,
+	.post_reg	= -1,
+	.frac_reg	= PLL_SD_FRAC_REG,
+	.ctrl2_reg	= PLL_SD_CTRL2_REG,
+	.ctrl3_reg	= PLL_SD_CTRL3_REG,
+	.lock_reg	= PLL_LOCK_REG,
+	.lock_bit	= 12,
+	.divider	= 0,
+	.max_divider	= 0,
+	.extra_scaler	= 0,
+	.table		= ambarella_pll_int_table,
+	.table_size	= ARRAY_SIZE(ambarella_pll_int_table),
+	.ops		= &ambarella_rct_pll_ops,
+};
+#endif
+
+#if (SD_SUPPORT_SDXC == 1)
+static struct clk gclk_sdxc = {
+	.parent		= &pll_out_sd,
+	.name		= "gclk_sdxc",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= SCALER_SDXC_REG,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 0,
+	.max_divider	= (1 << 16) - 1,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+#endif
+
+#if (SD_SUPPORT_SDIO == 1)
+static struct clk gclk_sdio = {
+#if (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
+	.parent		= &pll_out_sd,
+#else
+	.parent		= &pll_out_core,
+#endif
+	.name		= "gclk_sdio",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= SCALER_SDIO_REG,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 0,
+	.max_divider	= (1 << 16) - 1,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+#endif
+
+static struct clk gclk_sd = {
+#if (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+	.parent		= &pll_out_sd,
+#else
+	.parent		= &pll_out_core,
+#endif
+	.name		= "gclk_sd",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= SCALER_SD48_REG,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 0,
+	.max_divider	= (1 << 16) - 1,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+
+static struct clk gclk_ir = {
+	.parent		= NULL,
+	.name		= "gclk_ir",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= CG_IR_REG,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 0,
+	.max_divider	= (1 << 24) - 1,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+
+static struct clk gclk_adc = {
+	.parent		= NULL,
+	.name		= "gclk_adc",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= SCALER_ADC_REG,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 2,
+	.max_divider	= (1 << 16) - 1,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+
+static struct clk gclk_ssi = {	/* for SSI master */
+#if (CHIP_REV == A5S) || (CHIP_REV == S2) || (CHIP_REV == S2E)
+	.parent		= &gclk_apb,
+#else
+	.parent		= &pll_out_core,
+#endif
+	.name		= "gclk_ssi",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= CG_SSI_REG,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 0,
+	.max_divider	= (1 << 24) - 1,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+
+static struct clk gclk_ssi2 = {	/* for SSI slave */
+#if (CHIP_REV == A5S) || (CHIP_REV == S2) || (CHIP_REV == S2E)
+	.parent		= &gclk_apb,
+#else
+	.parent		= &pll_out_core,
+#endif
+	.name		= "gclk_ssi2",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= CG_SSI2_REG,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 0,
+	.max_divider	= (1 << 24) - 1,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+static struct clk gclk_ssi3 = {	/* for SPINOR */
+	/* TODO: parent is determined by CLK_REF_SSI3_REG */
+	.parent		= &pll_out_core,
+	.name		= "gclk_ssi3",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= CG_SSI3_REG,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 0,
+	.max_divider	= (1 << 24) - 1,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+#endif
+
+static struct clk gclk_pwm = {
+	.parent		= &gclk_apb,
+	.name		= "gclk_pwm",
+	.rate		= 0,
+	.frac_mode	= 0,
+	.ctrl_reg	= -1,
+	.pres_reg	= -1,
+	.post_reg	= CG_PWM_REG,
+	.frac_reg	= -1,
+	.ctrl2_reg	= -1,
+	.ctrl3_reg	= -1,
+	.lock_reg	= -1,
+	.lock_bit	= 0,
+	.divider	= 0,
+	.max_divider	= (1 << 24) - 1,
+	.extra_scaler	= 0,
+	.ops		= &ambarella_rct_scaler_ops,
+};
+
+static int ambarella_pll_service(void *arg, void *result)
 {
-	return ambarella_clk_ref_freq;
+	struct ambsvc_pll *pll_svc = arg;
+	struct clk *clk;
+	int rval = 0;
+
+	BUG_ON(!pll_svc || !pll_svc->name);
+
+	clk = clk_get(NULL, pll_svc->name);
+	if (IS_ERR(clk)) {
+		pr_err("%s: ERR get %s\n", __func__, pll_svc->name);
+		return -EINVAL;
+	}
+
+	switch (pll_svc->svc_id) {
+	case AMBSVC_PLL_GET_RATE:
+		pll_svc->rate = clk_get_rate(clk);
+		break;
+	case AMBSVC_PLL_SET_RATE:
+		clk_set_rate(clk, pll_svc->rate);
+		break;
+
+	default:
+		pr_err("%s: Invalid pll service (%d)\n", __func__, pll_svc->svc_id);
+		rval = -EINVAL;
+		break;
+	}
+
+	return rval;
+}
+
+void ambarella_init_early(void)
+{
+	ambarella_clk_add(&pll_out_core);
+#if (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+	ambarella_clk_add(&pll_out_sd);
+#endif
+#if defined(CONFIG_PLAT_AMBARELLA_CORTEX)
+	ambarella_clk_add(&gclk_cortex);
+	ambarella_clk_add(&gclk_axi);
+#if defined(CONFIG_HAVE_ARM_TWD)
+	ambarella_clk_add(&clk_smp_twd);
+#endif
+#endif
+	ambarella_clk_add(&gclk_ddr);
+	ambarella_clk_add(&gclk_core);
+	ambarella_clk_add(&gclk_ahb);
+	ambarella_clk_add(&gclk_apb);
+	ambarella_clk_add(&gclk_idsp);
+#ifdef CONFIG_AMBARELLA_CALC_PLL
+	amba_rct_writel(CLK_SI_INPUT_MODE_REG, 0x0);
+#if (CHIP_REV == S2E)
+	amba_rct_setbitsl(HDMI_CLOCK_CTRL_REG, 0x1);
+#endif
+	ambarella_clk_add(&gclk_so);
+	ambarella_clk_add(&gclk_vo2);	/* for lcd */
+	ambarella_clk_add(&gclk_vo);	/* for tv */
+#endif
+#if (CHIP_REV == S2E)
+	amba_rct_writel(UART_CLK_SRC_SEL_REG, UART_CLK_SRC_IDSP);
+#endif
+	ambarella_clk_add(&gclk_uart);
+	ambarella_clk_add(&gclk_audio);
+#if (SD_SUPPORT_SDXC == 1)
+	ambarella_clk_add(&gclk_sdxc);
+#endif
+#if (SD_SUPPORT_SDIO == 1)
+	ambarella_clk_add(&gclk_sdio);
+#endif
+	ambarella_clk_add(&gclk_sd);
+	ambarella_clk_add(&gclk_ir);
+	ambarella_clk_add(&gclk_adc);
+	ambarella_clk_add(&gclk_ssi);
+	ambarella_clk_add(&gclk_ssi2);
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+	ambarella_clk_add(&gclk_ssi3);
+#endif
+	ambarella_clk_add(&gclk_pwm);
+
+	/* register ambarella clk service for private operation */
+	pll_service.service = AMBARELLA_SERVICE_PLL;
+	pll_service.func = ambarella_pll_service;
+	ambarella_register_service(&pll_service);
 }
-EXPORT_SYMBOL(ambarella_clk_get_ref_freq);
 
diff --git a/arch/arm/mach-ambarella/clk_calc.c b/arch/arm/mach-ambarella/clk_calc.c
new file mode 100644
index 0000000..790e445
--- /dev/null
+++ b/arch/arm/mach-ambarella/clk_calc.c
@@ -0,0 +1,162 @@
+/*
+ * arch/arm/mach-ambarella/pll_calc.c
+ *
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ *
+ * Copyright (C) 2012-2016, Ambarella, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/rational.h>
+#include <mach/init.h>
+#include <plat/clk.h>
+#include <plat/fio.h>
+#include <plat/sd.h>
+#include <plat/spi.h>
+
+/* these two tables are actually not used */
+struct pll_table ambarella_pll_frac_table[AMBARELLA_PLL_FRAC_TABLE_SIZE];
+struct pll_table ambarella_pll_int_table[AMBARELLA_PLL_INT_TABLE_SIZE];
+
+int ambarella_rct_clk_set_rate(struct clk *c, unsigned long rate)
+{
+	unsigned long rate_int, pre_scaler = 1, post_scaler = 1;
+	unsigned long intp, sdiv = 1, sout = 1;
+	u32 ctrl2, ctrl3, fix_divider = c->divider ? c->divider : 1;
+	u64 dividend, divider, diff;
+	union ctrl_reg_u ctrl_reg;
+	union frac_reg_u frac_reg;
+
+	BUG_ON(c->ctrl_reg == -1 || c->ctrl2_reg == -1 || c->ctrl3_reg == -1);
+
+	rate *= fix_divider;
+
+	if (rate < REF_CLK_FREQ && c->post_reg != -1) {
+		rate *= 16;
+		post_scaler = 16;
+	}
+
+	if (rate < REF_CLK_FREQ) {
+		pr_err("Error: target rate is too slow: %ld!\n", rate);
+		return -1;
+	}
+
+	//TODO: temporary solution for s3l 4Kp30 hdmi vout
+	if(rate == (PLL_CLK_296_703MHZ * fix_divider)){
+		pre_scaler = 4;
+		intp = 0x63;
+		sdiv = 5;
+		sout = 1;
+		c->frac_mode = 0;
+	}else{
+                /* fvco should be less than 1.5GHz, so we use 64 as max_numerator,
+                 * although the actual bit width of pll_intp is 7 */
+                rational_best_approximation(rate, REF_CLK_FREQ, 64, 16, &intp, &sout);
+
+                /* fvco should be faster than 700MHz, otherwise pll out is not stable */
+                while (REF_CLK_FREQ / 1000000 * intp * sdiv / pre_scaler < 700) {
+                        if (sout > 8 || intp > 64)
+                                break;
+                        intp *= 2;
+                        sout *= 2;
+                }
+
+                BUG_ON(pre_scaler > 16 || post_scaler > 16);
+                BUG_ON(intp > 64 || sdiv > 16 || sout > 16 || sdiv > 16);
+        }
+
+	if (c->pres_reg != -1) {
+		if (c->extra_scaler == 1)
+			amba_rct_writel_en(c->pres_reg, (pre_scaler - 1) << 4);
+		else
+			amba_rct_writel(c->pres_reg, pre_scaler);
+	}
+
+	if (c->post_reg != -1) {
+		if (c->extra_scaler == 1)
+			amba_rct_writel_en(c->post_reg, (post_scaler - 1) << 4);
+		else
+			amba_rct_writel(c->post_reg, post_scaler);
+	}
+
+	ctrl_reg.w = amba_rct_readl(c->ctrl_reg);
+	ctrl_reg.s.intp = intp - 1;
+	ctrl_reg.s.sdiv = sdiv - 1;
+	ctrl_reg.s.sout = sout - 1;
+	ctrl_reg.s.bypass = 0;
+	ctrl_reg.s.frac_mode = 0;
+	ctrl_reg.s.force_reset = 0;
+	ctrl_reg.s.power_down = 0;
+	ctrl_reg.s.halt_vco = 0;
+	ctrl_reg.s.tristate = 0;
+	ctrl_reg.s.force_lock = 1;
+	ctrl_reg.s.force_bypass = 0;
+	ctrl_reg.s.write_enable = 0;
+	amba_rct_writel_en(c->ctrl_reg, ctrl_reg.w);
+
+	if (c->frac_mode) {
+		rate_int = ambarella_rct_clk_get_rate(c) * fix_divider * post_scaler;
+		if (rate_int <= rate)
+			diff = rate - rate_int;
+		else
+			diff = rate_int - rate;
+
+		if (diff) {
+			dividend = diff * pre_scaler * sout;
+			dividend = dividend << 32;
+			divider = (u64)sdiv * REF_CLK_FREQ;
+			dividend = DIV_ROUND_CLOSEST_ULL(dividend, divider);
+			if (rate_int <= rate) {
+				frac_reg.s.nega	= 0;
+				frac_reg.s.frac	= dividend;
+			} else {
+				frac_reg.s.nega	= 1;
+				frac_reg.s.frac	= 0x80000000 - dividend;
+			}
+			amba_rct_writel(c->frac_reg, frac_reg.w);
+
+			ctrl_reg.s.frac_mode = 1;
+		}
+
+		amba_rct_writel_en(c->ctrl_reg, ctrl_reg.w);
+	}
+
+	ctrl2 = c->ctrl2_val ? c->ctrl2_val : 0x3f770000;
+	ctrl3 = c->ctrl3_val ? c->ctrl3_val : ctrl_reg.s.frac_mode ? 0x00069300 : 0x00068300;
+	if(rate == (PLL_CLK_296_703MHZ * fix_divider)){
+		ctrl2 = 0x3f700e00;
+		ctrl3 = 0x00068306;
+	}
+	amba_rct_writel(c->ctrl2_reg, ctrl2);
+	amba_rct_writel(c->ctrl3_reg, ctrl3);
+
+	c->rate = ambarella_rct_clk_get_rate(c);
+
+	/* check if result rate is precise or not */
+	if (abs(c->rate - rate / fix_divider / post_scaler) > 10) {
+		pr_warn("%s: rate is not very precise: %lld, %ld\n",
+			c->name, c->rate, rate / fix_divider / post_scaler);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ambarella_rct_clk_set_rate);
+
diff --git a/arch/arm/mach-ambarella/clk_table.c b/arch/arm/mach-ambarella/clk_table.c
index 2887df5..9d7e325 100644
--- a/arch/arm/mach-ambarella/clk_table.c
+++ b/arch/arm/mach-ambarella/clk_table.c
@@ -21,8 +21,233 @@
  *
  */
 #include <linux/module.h>
+#include <linux/io.h>
 #include <plat/clk.h>
 
+int ambarella_rct_clk_set_rate(struct clk *c, unsigned long rate)
+{
+	u32 pre_scaler, post_scaler, middle;
+	u32 intp, sdiv, sout, post, ctrl2, ctrl3;
+	u64 dividend, divider, diff;
+	union ctrl_reg_u ctrl_reg;
+	union frac_reg_u frac_reg;
+
+	if (!rate)
+		return -1;
+
+	BUG_ON(c->ctrl_reg == -1 || c->ctrl2_reg == -1 || c->ctrl3_reg == -1);
+	BUG_ON(c->post_reg != -1 && !c->max_divider);
+	BUG_ON(!c->table || c->table_size == 0);
+#if 0
+	if (c->divider)
+		rate *= c->divider;
+#endif
+	if (c->pres_reg != -1) {
+		if (c->pres_val) {
+			pre_scaler = c->pres_val;
+			if (c->extra_scaler == 1)
+				amba_rct_writel_en(c->pres_reg, (pre_scaler - 1) << 4);
+			else
+				amba_rct_writel(c->pres_reg, pre_scaler);
+		} else {
+			pre_scaler = amba_rct_readl(c->pres_reg);
+			if (c->extra_scaler == 1) {
+				pre_scaler >>= 4;
+				pre_scaler++;
+			}
+		}
+	} else {
+		pre_scaler = 1;
+	}
+
+	middle = ambarella_rct_find_pll_table_index(rate,
+			pre_scaler, c->table, c->table_size);
+	intp = c->table[middle].intp;
+	sdiv = c->table[middle].sdiv;
+	sout = c->table[middle].sout;
+	post = c->post_val ? c->post_val : c->table[middle].post;
+
+	ctrl_reg.w = amba_rct_readl(c->ctrl_reg);
+	ctrl_reg.s.intp = intp;
+	ctrl_reg.s.sdiv = sdiv;
+	ctrl_reg.s.sout = sout;
+	ctrl_reg.s.bypass = 0;
+	ctrl_reg.s.frac_mode = 0;
+	ctrl_reg.s.force_reset = 0;
+	ctrl_reg.s.power_down = 0;
+	ctrl_reg.s.halt_vco = 0;
+	ctrl_reg.s.tristate = 0;
+	ctrl_reg.s.force_lock = 1;
+	ctrl_reg.s.force_bypass = 0;
+	ctrl_reg.s.write_enable = 0;
+	amba_rct_writel_en(c->ctrl_reg, ctrl_reg.w);
+
+	if (c->post_reg != -1) {
+		post_scaler = min(post, c->max_divider);
+		if (c->extra_scaler == 1)
+			amba_rct_writel_en(c->post_reg, (post_scaler - 1) << 4);
+		else
+			amba_rct_writel(c->post_reg, post_scaler);
+	}
+
+	if (c->frac_mode) {
+		c->rate = ambarella_rct_clk_get_rate(c);
+		if (c->rate < rate)
+			diff = rate - c->rate;
+		else
+			diff = c->rate - rate;
+
+		dividend = diff * pre_scaler * (sout + 1) * post;
+		if (c->divider)
+			dividend *= c->divider;
+		dividend = dividend << 32;
+		divider = (u64)ambarella_clk_get_ref_freq() * (sdiv + 1);
+		AMBCLK_DO_DIV_ROUND(dividend, divider);
+		if (c->rate <= rate) {
+			frac_reg.s.nega	= 0;
+			frac_reg.s.frac	= dividend;
+		} else {
+			frac_reg.s.nega	= 1;
+			frac_reg.s.frac	= 0x80000000 - dividend;
+		}
+		amba_rct_writel(c->frac_reg, frac_reg.w);
+
+		ctrl_reg.w = amba_rct_readl(c->ctrl_reg);
+		if (diff)
+			ctrl_reg.s.frac_mode = 1;
+		else
+			ctrl_reg.s.frac_mode = 0;
+
+		ctrl_reg.s.force_lock = 1;
+		ctrl_reg.s.write_enable = 1;
+		amba_rct_writel(c->ctrl_reg, ctrl_reg.w);
+
+		ctrl_reg.s.write_enable	= 0;
+		amba_rct_writel(c->ctrl_reg, ctrl_reg.w);
+	}
+
+	ctrl2 = c->ctrl2_val ? c->ctrl2_val : 0x3f770000;
+	ctrl3 = c->ctrl3_val ? c->ctrl3_val : ctrl_reg.s.frac_mode ? 0x00069300 : 0x00068300;
+	amba_rct_writel(c->ctrl2_reg, ctrl2);
+	amba_rct_writel(c->ctrl3_reg, ctrl3);
+
+	c->rate = ambarella_rct_clk_get_rate(c);
+
+	return 0;
+}
+EXPORT_SYMBOL(ambarella_rct_clk_set_rate);
+
+u32 ambarella_rct_find_pll_table_index(unsigned long rate, u32 pre_scaler,
+	const struct pll_table *table, u32 table_size)
+{
+	u64 dividend;
+	u64 divider;
+	u32 start;
+	u32 middle;
+	u32 end;
+	u32 index_limit;
+	u64 diff = 0;
+	u64 diff_low = 0xFFFFFFFFFFFFFFFF;
+	u64 diff_high = 0xFFFFFFFFFFFFFFFF;
+
+	pr_debug("pre_scaler = [0x%08X]\n", pre_scaler);
+
+	dividend = rate;
+	dividend *= pre_scaler;
+	dividend *= (1000 * 1000 * 1000);
+	divider = ambarella_clk_get_ref_freq() / (1000 * 1000);
+	AMBCLK_DO_DIV(dividend, divider);
+
+	index_limit = (table_size - 1);
+	start = 0;
+	end = index_limit;
+	middle = table_size / 2;
+	while (table[middle].multiplier != dividend) {
+		if (table[middle].multiplier < dividend) {
+			start = middle;
+		} else {
+			end = middle;
+		}
+		middle = (start + end) / 2;
+		if (middle == start || middle == end) {
+			break;
+		}
+	}
+	if ((middle > 0) && ((middle + 1) <= index_limit)) {
+		if (table[middle - 1].multiplier < dividend) {
+			diff_low = dividend - table[middle - 1].multiplier;
+		} else {
+			diff_low = table[middle - 1].multiplier - dividend;
+		}
+		if (table[middle].multiplier < dividend) {
+			diff = dividend - table[middle].multiplier;
+		} else {
+			diff = table[middle].multiplier - dividend;
+		}
+		if (table[middle + 1].multiplier < dividend) {
+			diff_high = dividend - table[middle + 1].multiplier;
+		} else {
+			diff_high = table[middle + 1].multiplier - dividend;
+		}
+		pr_debug("multiplier[%u] = [%llu]\n", (middle - 1),
+			table[middle - 1].multiplier);
+		pr_debug("multiplier[%u] = [%llu]\n", (middle),
+			table[middle].multiplier);
+		pr_debug("multiplier[%u] = [%llu]\n", (middle + 1),
+			table[middle + 1].multiplier);
+	} else if ((middle == 0) && ((middle + 1) <= index_limit)) {
+		if (table[middle].multiplier < dividend) {
+			diff = dividend - table[middle].multiplier;
+		} else {
+			diff = table[middle].multiplier - dividend;
+		}
+		if (table[middle + 1].multiplier < dividend) {
+			diff_high = dividend - table[middle + 1].multiplier;
+		} else {
+			diff_high = table[middle + 1].multiplier - dividend;
+		}
+		pr_debug("multiplier[%u] = [%llu]\n", (middle),
+			table[middle].multiplier);
+		pr_debug("multiplier[%u] = [%llu]\n", (middle + 1),
+			table[middle + 1].multiplier);
+	} else if ((middle > 0) && ((middle + 1) > index_limit)) {
+		if (table[middle - 1].multiplier < dividend) {
+			diff_low = dividend - table[middle - 1].multiplier;
+		} else {
+			diff_low = table[middle - 1].multiplier - dividend;
+		}
+		if (table[middle].multiplier < dividend) {
+			diff = dividend - table[middle].multiplier;
+		} else {
+			diff = table[middle].multiplier - dividend;
+		}
+		pr_debug("multiplier[%u] = [%llu]\n", (middle - 1),
+			table[middle - 1].multiplier);
+		pr_debug("multiplier[%u] = [%llu]\n", (middle),
+			table[middle].multiplier);
+	}
+	pr_debug("diff_low = [%llu]\n", diff_low);
+	pr_debug("diff = [%llu]\n", diff);
+	pr_debug("diff_high = [%llu]\n", diff_high);
+	if (diff_low < diff) {
+		if (middle) {
+			middle--;
+		}
+	}
+	if (diff_high < diff) {
+		middle++;
+		if (middle > index_limit) {
+			middle = index_limit;
+		}
+	}
+	pr_debug("middle = [%u]\n", middle);
+
+	return middle;
+}
+EXPORT_SYMBOL(ambarella_rct_find_pll_table_index);
+
+/* ==========================================================================*/
+
 struct pll_table ambarella_pll_int_table[AMBARELLA_PLL_INT_TABLE_SIZE] =
 {
 	{    1000000000000000,   13,    0,   13,    1},
diff --git a/arch/arm/mach-ambarella/fio.c b/arch/arm/mach-ambarella/fio.c
index f2d24fa..aa1071d 100644
--- a/arch/arm/mach-ambarella/fio.c
+++ b/arch/arm/mach-ambarella/fio.c
@@ -31,11 +31,14 @@
 #include <asm/io.h>
 #include <asm/setup.h>
 #include <mach/hardware.h>
+#include <asm/cacheflush.h>
 #include <plat/fio.h>
 #include <plat/sd.h>
 #include <plat/nand.h>
 #include <plat/rct.h>
 
+static void *fio_4k_vaddr = NULL;
+
 #if (FIO_INDEPENDENT_SD == 0)
 
 static DECLARE_WAIT_QUEUE_HEAD(fio_wait);
@@ -52,6 +55,7 @@ static u32 fio_default_owner = SELECT_FIO_SD;
 static u32 fio_sd_int = 0;
 static u32 fio_sdio_int = 0;
 
+
 static int __init fio_default_owner_init(char *p)
 {
 	fio_default_owner = simple_strtoul(p, NULL, 0);
@@ -243,6 +247,27 @@ void fio_amb_sdio0_set_int(u32 mask, u32 on)
 EXPORT_SYMBOL(fio_amb_sdio0_set_int);
 #endif
 
+void ambarella_fio_prepare(void)
+{
+	fio_4k_vaddr = __arm_ioremap_exec(FIO_4K_PHYS_BASE, 0x1000, false);
+	if (!fio_4k_vaddr)
+		pr_warning("__arm_ioremap_exec for FIFO failed!\n");
+}
+
+void *ambarella_fio_push(void *func, u32 size)
+{
+	BUG_ON(!fio_4k_vaddr || (size > 0x1000));
+
+	amba_writel(FIO_CTR_REG, (amba_readl(FIO_CTR_REG) | FIO_CTR_RR));
+	memcpy(fio_4k_vaddr, func, size);
+
+	flush_icache_range((unsigned long)(fio_4k_vaddr),
+			(unsigned long)(fio_4k_vaddr) + (size));
+
+	return fio_4k_vaddr;
+}
+EXPORT_SYMBOL(ambarella_fio_push);
+
 void ambarella_fio_rct_reset(void)
 {
 	amba_rct_writel(FIO_RESET_REG, FIO_RESET_FIO_RST);
@@ -255,6 +280,8 @@ EXPORT_SYMBOL(ambarella_fio_rct_reset);
 /* ==========================================================================*/
 int __init ambarella_init_fio(void)
 {
+	/* ioremap for self refresh */
+	ambarella_fio_prepare();
 #if defined(CONFIG_AMBARELLA_RAW_BOOT)
 	amba_rct_writel(FIO_RESET_REG, (FIO_RESET_FIO_RST | FIO_RESET_CF_RST |
 		FIO_RESET_XD_RST | FIO_RESET_FLASH_RST));
diff --git a/arch/arm/mach-ambarella/hibernate.c b/arch/arm/mach-ambarella/hibernate.c
index a73b49b..9dfd5dc 100644
--- a/arch/arm/mach-ambarella/hibernate.c
+++ b/arch/arm/mach-ambarella/hibernate.c
@@ -26,6 +26,7 @@
 #include <asm/memory.h>
 #include <asm/sections.h>
 #include <linux/mtd/mtd.h>
+#include <linux/vmalloc.h>
 
 #define HIBERNATE_MTD_NAME  "swp"
 
@@ -33,6 +34,68 @@ static int mtd_page_offset = 0;
 
 extern const void __nosave_begin, __nosave_end;
 
+static const unsigned int crc32_tab[] = {
+	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+	0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+	0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+	0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+	0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+};
+
+static unsigned int __crc32(unsigned int crc, const void *buf, unsigned int size)
+{
+	const unsigned char *p;
+	unsigned int __crc = crc;
+
+	p = buf;
+
+	while (size > 0) {
+		__crc = crc32_tab[(__crc ^ *p++) & 0xff] ^ (__crc >> 8);
+		size--;
+	}
+
+	return __crc ^ ~0U;
+}
+
+
 int pfn_is_nosave(unsigned long pfn)
 {
 	return 0;
@@ -121,15 +184,16 @@ struct mtd_info *mtd_probe_dev(void)
 		printk("SWP: mtd dev no found!\n");
 		return NULL;
 	}else{
-
-		/* Makesure the swp partition has 64M at least */
-		if(info->size < 0x4000000)
+		/* Makesure the swp partition has 32M at least */
+		if(info->size < 0x2000000){
+			printk("ERR: swp partition size is less than 32M\n");
 			return NULL;
+		}
 
-		printk("MTD name: %s\n", 		info->name);
-		printk("MTD size: 0x%llx\n", 	info->size);
+		printk("MTD name: %s\n",	info->name);
+		printk("MTD size: 0x%llx\n",	info->size);
 		printk("MTD blocksize: 0x%x\n", info->erasesize);
-		printk("MTD pagesize: 0x%x\n", 	info->writesize);
+		printk("MTD pagesize: 0x%x\n",	info->writesize);
 	}
 	return info;
 }
@@ -186,11 +250,13 @@ int hibernate_write_page(struct mtd_info *mtd, void *buf)
 	return 0;
 }
 
-int hibernate_save_image(struct mtd_info *mtd, struct snapshot_handle *snapshot)
+int hibernate_save_image(struct mtd_info *mtd, struct snapshot_handle *snapshot,
+		struct swsusp_info *header)
 {
 
 	int ret;
 	int nr_pages = 0;
+	unsigned int crc = 0;
 
 	while (1) {
 		ret = snapshot_read_next(snapshot);
@@ -202,14 +268,24 @@ int hibernate_save_image(struct mtd_info *mtd, struct snapshot_handle *snapshot)
 			break;
 
 		nr_pages++;
+
+		if (nr_pages > nr_meta_pages)
+			crc = __crc32(crc, data_of(*snapshot), PAGE_SIZE);
 	}
 
 	if(!ret)
-		printk("SWP: %d pages have been saved\n",  nr_pages);
+		printk("LINUX:	%d pages, crc = %08x.\n", nr_pages - nr_meta_pages, crc);
 
 	if(!nr_pages)
 		ret = -EINVAL;
 
+	header->crc32 = crc;
+	header->lzo_enable = 0;
+
+	/* save the header */
+	mtd_page_offset = 0;
+	hibernate_write_page(mtd, header);
+
 	return ret;
 }
 
@@ -217,9 +293,13 @@ int hibernate_mtd_write(struct mtd_info *mtd)
 {
 
 	int error = 0;
-	struct swsusp_info *header;
+	struct swsusp_info *header, *copy;
 	struct snapshot_handle snapshot;
 
+	copy = vmalloc(sizeof(struct swsusp_info));
+	if (!copy)
+		return -ENOMEM;
+
 	memset(&snapshot, 0, sizeof(struct snapshot_handle));
 
 	if(nr_meta_pages <= 0)
@@ -231,14 +311,30 @@ int hibernate_mtd_write(struct mtd_info *mtd)
 			error = -EFAULT;
 		goto out_finish;
 	}
+	
 	header = (struct swsusp_info *)data_of(snapshot);
-	error = hibernate_write_page(mtd, header);
-
-	if (!error) {
-		error = hibernate_save_image(mtd, &snapshot);
+	memcpy(copy, header, sizeof(struct swsusp_info));
+
+	/*
+	 * Skip saving the header. the header is copied and
+	 * will be save after the CRC of the kernel snapshot
+	 * has been generated. The mtd_page_offset should be
+	 * set at meta data offset.
+	 *
+	 * */
+	mtd_page_offset ++;
+
+	/* TODO: SWP partition space size check */
+	if (header->pages * 0x1000 > mtd->size){
+		printk("ERR: swp partition[0x%llx] has not enough space for the \
+				kernel snapshot[0x%lx]\n", mtd->size, header->pages * 0x1000);
+			return -ENOMEM;
 	}
 
+	error = hibernate_save_image(mtd, &snapshot, copy);
+
 out_finish:
+	vfree(copy);
 	return error;
 
 }
diff --git a/arch/arm/mach-ambarella/include/mach/hardware.h b/arch/arm/mach-ambarella/include/mach/hardware.h
index df35e06..595bb79 100644
--- a/arch/arm/mach-ambarella/include/mach/hardware.h
+++ b/arch/arm/mach-ambarella/include/mach/hardware.h
@@ -35,12 +35,6 @@
 #if defined(CONFIG_PLAT_AMBARELLA_CORTEX)
 #include <plat/cortex.h>
 #endif
-
-/* ==========================================================================*/
-#define	AMBA_DEV_MAJOR			(248)
-#define	AMBA_DEV_MINOR_PUBLIC_START	(128)
-#define	AMBA_DEV_MINOR_PUBLIC_END	(240)
-
 /* ==========================================================================*/
 #ifndef __ASSEMBLER__
 
diff --git a/arch/arm/mach-ambarella/include/plat/adc.h b/arch/arm/mach-ambarella/include/plat/adc.h
index 96a927d..a9d450a 100644
--- a/arch/arm/mach-ambarella/include/plat/adc.h
+++ b/arch/arm/mach-ambarella/include/plat/adc.h
@@ -37,16 +37,16 @@
 #define ADC_NUM_CHANNELS		4
 #endif
 
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define ADC_SUPPORT_THRESHOLD_INT	1
-#define ADC_SUPPORT_SLOT		1
-#else
+#if (CHIP_REV == A5S)
 #define ADC_SUPPORT_THRESHOLD_INT	0
 #define ADC_SUPPORT_SLOT		0
+#else
+#define ADC_SUPPORT_THRESHOLD_INT	1
+#define ADC_SUPPORT_SLOT		1
 #endif
 
 /* ==========================================================================*/
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define ADC_OFFSET			0x1D000
 #else
 #define ADC_OFFSET			0xD000
@@ -55,44 +55,41 @@
 #define ADC_REG(x)			(ADC_BASE + (x))
 
 /* ==========================================================================*/
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define ADC_CONTROL_TYPE		1
-#define ADC_CONTROL_OFFSET		0x04
-#define ADC_ENABLE_OFFSET		ADC_CONTROL_OFFSET
-#else
+#if (CHIP_REV == A5S)
 #define ADC_CONTROL_TYPE		0
 #define ADC_CONTROL_OFFSET		0x00
 #define ADC_ENABLE_OFFSET		0x18
+#else
+#define ADC_CONTROL_TYPE		1
+#define ADC_CONTROL_OFFSET		0x04
+#define ADC_ENABLE_OFFSET		ADC_CONTROL_OFFSET
 #endif
 
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define ADC_DATA0_OFFSET		0x150
-#define ADC_DATA1_OFFSET		0x154
-#define ADC_DATA2_OFFSET		0x158
-#define ADC_DATA3_OFFSET		0x15c
-#else
+#if (CHIP_REV == A5S)
+/* NOTE: ADC channel is re-order for A5S to make life easier */
 #define ADC_DATA0_OFFSET		0x04
 #define ADC_DATA1_OFFSET		0x08
 #define ADC_DATA2_OFFSET		0x0c
 #define ADC_DATA3_OFFSET		0x10
+#else
+#define ADC_DATA0_OFFSET		0x150
+#define ADC_DATA1_OFFSET		0x154
+#define ADC_DATA2_OFFSET		0x158
+#define ADC_DATA3_OFFSET		0x15c
 #endif
 
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
 #define ADC_COUNTER_OFFSET		0x008
-#else
-#define ADC_COUNTER_OFFSET		0x14	/* A7 */
-#endif
 
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define ADC_CHAN0_INTR_OFFSET		0x120
-#define ADC_CHAN1_INTR_OFFSET		0x124
-#define ADC_CHAN2_INTR_OFFSET		0x128
-#define ADC_CHAN3_INTR_OFFSET		0x12c
-#else
+#if (CHIP_REV == A5S)
 #define ADC_CHAN0_INTR_OFFSET		0x44
 #define ADC_CHAN1_INTR_OFFSET		0x48
 #define ADC_CHAN2_INTR_OFFSET		0x4c
 #define ADC_CHAN3_INTR_OFFSET		0x50
+#else
+#define ADC_CHAN0_INTR_OFFSET		0x120
+#define ADC_CHAN1_INTR_OFFSET		0x124
+#define ADC_CHAN2_INTR_OFFSET		0x128
+#define ADC_CHAN3_INTR_OFFSET		0x12c
 #endif
 
 #if (CHIP_REV == A7L)
@@ -223,8 +220,7 @@
 #define ADC_DATA5_SAMPLE2_REG		ADC_REG(ADC_DATA5_SAMPLE2_OFFSET)
 #define ADC_DATA5_SAMPLE3_REG		ADC_REG(ADC_DATA5_SAMPLE3_OFFSET)
 
-
-/* S2, S2L and S3 */
+/* valid only for S2/S2E/S2L/S3/S3L */
 #define ADC_STATUS_REG			ADC_REG(ADC_STATUS_OFFSET)
 #define ADC_SLOT_NUM_REG		ADC_REG(ADC_SLOT_NUM_OFFSET)
 #define ADC_SLOT_PERIOD_REG		ADC_REG(ADC_SLOT_PERIOD_OFFSET)
@@ -284,7 +280,7 @@
 /* ADC_CONTROL_REG */
 #define ADC_CONTROL_GYRO_SAMPLE_MODE	0x08
 
-/* valid only for S2/S2E/S2L/S3 */
+/* valid only for S2/S2E/S2L/S3/S3L */
 #define ADC_CONTROL_RESET		0x01
 #define ADC_FIFO_OVER_INT_EN		(0x1 << 31)
 #define ADC_FIFO_UNDR_INT_EN		(0x1 << 30)
@@ -299,35 +295,32 @@
 #define ADC_CTRL_POWERDOWN		0x2
 #define ADC_CTRL_CLK_SOURCE_SCALER	0x0
 #define ADC_CTRL_CLK_SOURCE_AUDIO	0x1
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define ADC_CONTROL_ENABLE		0x04
-#define ADC_CONTROL_MODE		0x02
-#define ADC_CONTROL_START		0x08
-#else
-#define ADC_CONTROL_ENABLE		0x01
+
+#if (CHIP_REV == A5S)
 #define ADC_CONTROL_MODE		0x04
+#define ADC_CONTROL_ENABLE		0x01
 #define ADC_CONTROL_START		0x02
+#else
+#define ADC_CONTROL_MODE		0x02
+#define ADC_CONTROL_ENABLE		0x04
+#define ADC_CONTROL_START		0x08
 #endif
 #define ADC_CONTROL_STATUS		0x01
 
 #if (CHIP_REV == A5S)
 #define ADC_EN_HI(x)			((x) << 31)
 #define ADC_EN_LO(x)			((x) << 30)
-#elif (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
+#else
 #define ADC_EN_HI(x)			((x) << 31)
 #define ADC_EN_LO(x)			((x) << 31)
-#else
-#define ADC_HI_THRESHOLD_EN		(0x1 << 31)
-#define ADC_LO_THRESHOLD_EN		(0x1 << 30)
 #endif
 
 #define ADC_VAL_HI(x)			(((x) & 0xfff) << 16)
 #define ADC_VAL_LO(x)			((x) & 0xfff)
 /* ==========================================================================*/
 
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
 #define ADC_MAX_SLOT_NUMBER		8
-#endif
+
 #define ADC_CH0				(1 << 0)
 #define ADC_CH1				(1 << 1)
 #define ADC_CH2				(1 << 2)
diff --git a/arch/arm/mach-ambarella/include/plat/ambcache.h b/arch/arm/mach-ambarella/include/plat/ambcache.h
index 5f0e7cf..5520f67 100644
--- a/arch/arm/mach-ambarella/include/plat/ambcache.h
+++ b/arch/arm/mach-ambarella/include/plat/ambcache.h
@@ -24,27 +24,8 @@
 #ifndef __PLAT_AMBARELLA_CACHE_H
 #define __PLAT_AMBARELLA_CACHE_H
 
-/* ==========================================================================*/
 #ifndef __ASSEMBLER__
 
-extern void ambcache_clean_range(void *addr, unsigned int size);
-extern void ambcache_inv_range(void *addr, unsigned int size);
-extern void ambcache_flush_range(void *addr, unsigned int size);
-extern void ambcache_pli_range(void *addr, unsigned int size);
-#ifdef CONFIG_OUTER_CACHE
-extern int ambcache_l2_enable(void);
-extern int ambcache_l2_disable(void);
-extern void ambcache_l2_enable_raw(void);
-extern void ambcache_l2_disable_raw(void);
-#else
-static inline int ambcache_l2_enable(void) { return -1; }
-static inline int ambcache_l2_disable(void) { return 0; }
-static inline void ambcache_l2_enable_raw(void) { }
-static inline void ambcache_l2_disable_raw(void) { }
-#endif
-
 #endif /* __ASSEMBLER__ */
-/* ==========================================================================*/
-
 #endif
 
diff --git a/arch/arm/mach-ambarella/include/plat/audio.h b/arch/arm/mach-ambarella/include/plat/audio.h
index 30fbc46..47ee21a 100644
--- a/arch/arm/mach-ambarella/include/plat/audio.h
+++ b/arch/arm/mach-ambarella/include/plat/audio.h
@@ -25,7 +25,7 @@
 #define __PLAT_AMBARELLA_AUDIO_H__
 
 /* ==========================================================================*/
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define I2S_OFFSET			0x1A000
 #else
 #define I2S_OFFSET			0xA000
@@ -88,47 +88,53 @@
 #define I2S_RX_DATA_DMA_REG			I2S_REG_PHYS(0x80)
 #define I2S_TX_LEFT_DATA_DMA_REG		I2S_REG_PHYS(0xc0)
 
-#define I2S_TX_FIFO_RESET_BIT		(1 << 4)
-#define I2S_RX_FIFO_RESET_BIT		(1 << 3)
-#define I2S_TX_ENABLE_BIT		(1 << 2)
-#define I2S_RX_ENABLE_BIT		(1 << 1)
-#define I2S_FIFO_RESET_BIT		(1 << 0)
-
-#define I2S_RX_LOOPBACK_BIT		(1 << 3)
-#define I2S_RX_ORDER_BIT		(1 << 2)
-#define I2S_RX_WS_MST_BIT		(1 << 1)
-#define I2S_RX_WS_INV_BIT		(1 << 0)
-
-#define I2S_TX_LOOPBACK_BIT		(1 << 7)
-#define I2S_TX_ORDER_BIT		(1 << 6)
-#define I2S_TX_WS_MST_BIT		(1 << 5)
-#define I2S_TX_WS_INV_BIT		(1 << 4)
-#define I2S_TX_UNISON_BIT		(1 << 3)
-#define I2S_TX_MUTE_BIT			(1 << 2)
-#define I2S_TX_MONO_MASK		0xfffffffc
-#define I2S_TX_MONO_RIGHT		(1 << 1)
-#define I2S_TX_MONO_LEFT		(1 << 0)
-
-#define I2S_CLK_WS_OUT_EN		(1 << 9)
-#define I2S_CLK_BCLK_OUT_EN		(1 << 8)
-#define I2S_CLK_BCLK_OUTPUT		(1 << 7)
-#define I2S_CLK_MASTER_MODE		(I2S_CLK_WS_OUT_EN	|	\
-					 I2S_CLK_BCLK_OUT_EN	|	\
-					 I2S_CLK_BCLK_OUTPUT)
-#define I2S_CLK_TX_PO_FALL		(1 << 6)
-#define I2S_CLK_RX_PO_FALL		(1 << 5)
-#define I2S_CLK_DIV_MASK		0xffffffe0
-
-#define I2S_RX_SHIFT_ENB		(1 << 1)
-#define I2S_TX_SHIFT_ENB		(1 << 0)
-
-#define I2S_2CHANNELS_ENB		0x00
-#define I2S_4CHANNELS_ENB		0x01
-#define I2S_6CHANNELS_ENB		0x02
-
-#define I2S_FIFO_THRESHOLD_INTRPT	0x08
-#define I2S_FIFO_FULL_INTRPT		0x02
-#define I2S_FIFO_EMPTY_INTRPT		0x01
+#define I2S_LEFT_JUSTIFIED_MODE			0x0
+#define I2S_RIGHT_JUSTIFIED_MODE		0x1
+#define I2S_MSB_EXTEND_MODE			0x2
+#define I2S_I2S_MODE				0x4
+#define I2S_DSP_MODE				0x6
+
+#define I2S_TX_FIFO_RESET_BIT			(1 << 4)
+#define I2S_RX_FIFO_RESET_BIT			(1 << 3)
+#define I2S_TX_ENABLE_BIT			(1 << 2)
+#define I2S_RX_ENABLE_BIT			(1 << 1)
+#define I2S_FIFO_RESET_BIT			(1 << 0)
+
+#define I2S_RX_LOOPBACK_BIT			(1 << 3)
+#define I2S_RX_ORDER_BIT			(1 << 2)
+#define I2S_RX_WS_MST_BIT			(1 << 1)
+#define I2S_RX_WS_INV_BIT			(1 << 0)
+
+#define I2S_TX_LOOPBACK_BIT			(1 << 7)
+#define I2S_TX_ORDER_BIT			(1 << 6)
+#define I2S_TX_WS_MST_BIT			(1 << 5)
+#define I2S_TX_WS_INV_BIT			(1 << 4)
+#define I2S_TX_UNISON_BIT			(1 << 3)
+#define I2S_TX_MUTE_BIT				(1 << 2)
+#define I2S_TX_MONO_MASK			0xfffffffc
+#define I2S_TX_MONO_RIGHT			(1 << 1)
+#define I2S_TX_MONO_LEFT			(1 << 0)
+
+#define I2S_CLK_WS_OUT_EN			(1 << 9)
+#define I2S_CLK_BCLK_OUT_EN			(1 << 8)
+#define I2S_CLK_BCLK_OUTPUT			(1 << 7)
+#define I2S_CLK_MASTER_MODE			(I2S_CLK_WS_OUT_EN	|	\
+						 I2S_CLK_BCLK_OUT_EN	|	\
+						 I2S_CLK_BCLK_OUTPUT)
+#define I2S_CLK_TX_PO_FALL			(1 << 6)
+#define I2S_CLK_RX_PO_FALL			(1 << 5)
+#define I2S_CLK_DIV_MASK			0xffffffe0
+
+#define I2S_RX_SHIFT_ENB			(1 << 1)
+#define I2S_TX_SHIFT_ENB			(1 << 0)
+
+#define I2S_2CHANNELS_ENB			0x00
+#define I2S_4CHANNELS_ENB			0x01
+#define I2S_6CHANNELS_ENB			0x02
+
+#define I2S_FIFO_THRESHOLD_INTRPT		0x08
+#define I2S_FIFO_FULL_INTRPT			0x02
+#define I2S_FIFO_EMPTY_INTRPT			0x01
 
 /* I2S_24BITMUX_MODE_REG */
 #define I2S_24BITMUX_MODE_ENABLE		0x1
@@ -137,9 +143,9 @@
 #define I2S_24BITMUX_MODE_DMA_BOOTSEL		0x8
 
 /* ==========================================================================*/
-#define DAI_CLOCK_MASK			0x0000001f
+#define DAI_CLOCK_MASK				0x0000001f
 
-#define MAX_MCLK_IDX_NUM		15
+#define MAX_MCLK_IDX_NUM			15
 
 /* ==========================================================================*/
 #ifndef __ASSEMBLER__
@@ -147,64 +153,22 @@
 struct notifier_block;
 
 struct ambarella_i2s_interface {
-	u8 state;
-	u8 mode;
-	u8 sfreq;
+	u32 state;
+	u32 mode;
 	u32 clksrc;
-	u8 ms_mode;
 	u32 mclk;
-	u8 ch;
-	u8 oversample;
-	u8 word_order;
-	u8 word_len;
-	u8 word_pos;
-	u8 slots;
-};
-
-#define MAX_OVERSAMPLE_IDX_NUM	9
-enum AudioCodec_OverSample {
-	AudioCodec_128xfs = 0,
-	AudioCodec_256xfs = 1,
-	AudioCodec_384xfs = 2,
-	AudioCodec_512xfs = 3,
-	AudioCodec_768xfs = 4,
-	AudioCodec_1024xfs = 5,
-	AudioCodec_1152xfs = 6,
-	AudioCodec_1536xfs = 7,
-	AudioCodec_2304xfs = 8
-};
-
-enum AudioCodec_MCLK {
-	AudioCodec_18_432M = 0,
-	AudioCodec_16_9344M = 1,
-	AudioCodec_12_288M = 2,
-	AudioCodec_11_2896M = 3,
-	AudioCodec_9_216M = 4,
-	AudioCodec_8_4672M = 5,
-	AudioCodec_8_192M = 6,
-	AudioCodec_6_144 = 7,
-	AudioCodec_5_6448M = 8,
-	AudioCodec_4_608M = 9,
-	AudioCodec_4_2336M = 10,
-	AudioCodec_4_096M = 11,
-	AudioCodec_3_072M = 12,
-	AudioCodec_2_8224M = 13,
-	AudioCodec_2_048M = 14
-};
-
-enum audio_in_freq_e
-{
-	AUDIO_SF_reserved = 0,
-	AUDIO_SF_96000,
-	AUDIO_SF_48000,
-	AUDIO_SF_44100,
-	AUDIO_SF_32000,
-	AUDIO_SF_24000,
-	AUDIO_SF_22050,
-	AUDIO_SF_16000,
-	AUDIO_SF_12000,
-	AUDIO_SF_11025,
-	AUDIO_SF_8000,
+	u32 div;
+	u32 sfreq;
+	u32 channels;
+	u32 word_len;
+	u32 word_pos;
+	u32 slots;
+	u32 rx_ctrl;
+	u32 tx_ctrl;
+	u32 rx_fifo_len;
+	u32 tx_fifo_len;
+	u32 multi24;
+	u32 shift;
 };
 
 enum Audio_Notify_Type
@@ -215,61 +179,13 @@ enum Audio_Notify_Type
 	AUDIO_NOTIFY_REMOVE
 };
 
-enum DAI_Mode
-{
-	DAI_leftJustified_Mode = 0,
-	DAI_rightJustified_Mode = 1,
-	DAI_MSBExtend_Mode = 2,
-	DAI_I2S_Mode = 4,
-	DAI_DSP_Mode = 6
-};
-
-enum DAI_MS_MODE
-{
-	DAI_SLAVE = 0,
-	DAI_MASTER = 1
-};
-
-enum DAI_resolution
-{
-	DAI_16bits = 0,
-	DAI_18bits = 1,
-	DAI_20bits = 2,
-	DAI_24bits = 3,
-	DAI_32bits = 4
-
-};
-
-enum DAI_ifunion
-{
-	DAI_union = 0,
-	DAI_nonunion = 1
-};
-
-enum DAI_WordOrder
-{
-	DAI_MSB_FIRST = 0,
-	DAI_LSB_FIRST = 1
-};
-
-enum DAI_INIT_CTL
-{
-	DAI_FIFO_RST = 1,
-	DAI_RX_EN = 2,
-	DAI_TX_EN = 4
-};
-
-#define DAI_32slots	32
-#define DAI_64slots	64
-#define DAI_48slots	48
-
 #define AMBARELLA_CLKSRC_ONCHIP			0x0
 #define AMBARELLA_CLKSRC_SP_CLK			0x1
 #define AMBARELLA_CLKSRC_CLK_SI			0x2
 #define AMBARELLA_CLKSRC_EXTERNAL		0x3
 #define AMBARELLA_CLKSRC_LVDS_IDSP_SCLK		0x4
 
-#define AMBARELLA_CLKDIV_LRCLK	0
+#define AMBARELLA_CLKDIV_LRCLK			0
 
 /* ==========================================================================*/
 extern int ambarella_init_audio(void);
diff --git a/arch/arm/mach-ambarella/include/plat/chip.h b/arch/arm/mach-ambarella/include/plat/chip.h
index 4c87678..64683e0 100644
--- a/arch/arm/mach-ambarella/include/plat/chip.h
+++ b/arch/arm/mach-ambarella/include/plat/chip.h
@@ -32,6 +32,8 @@
 #define S2E		(9100)
 #define S2L		(12000)
 #define S3		(11000)
+#define S3L		(13000)
+#define S5		(15000)
 
 #define CHIP_ID(x)	((x / 1000))
 #define CHIP_MAJOR(x)	((x / 100) % 10)
@@ -51,6 +53,10 @@
 #define CHIP_REV	S2L
 #elif defined(CONFIG_PLAT_AMBARELLA_S3)
 #define CHIP_REV	S3
+#elif defined(CONFIG_PLAT_AMBARELLA_S3L)
+#define CHIP_REV	S3L
+#elif defined(CONFIG_ARCH_AMBARELLA_S5)
+#define CHIP_REV	S5
 #else
 #error "Undefined CHIP_REV"
 #endif
@@ -63,5 +69,15 @@
 #endif
 
 /* ==========================================================================*/
+#if (CHIP_REV == A5S) || (CHIP_REV == A7L)
+#define	CHIP_BROKEN_UNALIGNED_ACCESS	1
+#endif
+
+#if (CHIP_REV == S3)
+#define	CHIP_FIX_2NDCORTEX_BOOT	1
+#endif
+
+/* ==========================================================================*/
+
 #endif /* __PLAT_AMBARELLA_CHIP_H__ */
 
diff --git a/arch/arm/mach-ambarella/include/plat/clk.h b/arch/arm/mach-ambarella/include/plat/clk.h
index a8140f0f..e4fcc82 100644
--- a/arch/arm/mach-ambarella/include/plat/clk.h
+++ b/arch/arm/mach-ambarella/include/plat/clk.h
@@ -222,6 +222,12 @@ union frac_reg_u {
 extern struct clk_ops ambarella_rct_pll_ops;
 extern struct clk_ops ambarella_rct_scaler_ops;
 
+#ifdef CONFIG_AMBARELLA_CALC_PLL
+#define AMBARELLA_PLL_FRAC_TABLE_SIZE		(0)
+extern struct pll_table ambarella_pll_frac_table[AMBARELLA_PLL_FRAC_TABLE_SIZE];
+#define AMBARELLA_PLL_INT_TABLE_SIZE		(0)
+extern struct pll_table ambarella_pll_int_table[AMBARELLA_PLL_INT_TABLE_SIZE];
+#else
 #define AMBARELLA_PLL_FRAC_TABLE_SIZE		(590)
 extern struct pll_table ambarella_pll_frac_table[AMBARELLA_PLL_FRAC_TABLE_SIZE];
 #define AMBARELLA_PLL_INT_TABLE_SIZE		(93)
@@ -230,12 +236,14 @@ extern struct pll_table ambarella_pll_int_table[AMBARELLA_PLL_INT_TABLE_SIZE];
 extern struct pll_table ambarella_pll_vout_table[AMBARELLA_PLL_VOUT_TABLE_SIZE];
 #define AMBARELLA_PLL_VOUT2_TABLE_SIZE		(793)
 extern struct pll_table ambarella_pll_vout2_table[AMBARELLA_PLL_VOUT2_TABLE_SIZE];
+#endif
 
 extern u32 ambarella_rct_find_pll_table_index(unsigned long rate,
 		u32 pre_scaler, const struct pll_table *table, u32 table_size);
 
 extern unsigned long ambarella_rct_clk_get_rate(struct clk *c);
 extern int ambarella_rct_clk_set_rate(struct clk *c, unsigned long rate);
+extern int ambarella_rct_clk_adj_rate(struct clk *c, unsigned long rate);
 extern int ambarella_rct_clk_enable(struct clk *c);
 extern int ambarella_rct_clk_disable(struct clk *c);
 
diff --git a/arch/arm/mach-ambarella/include/plat/dma.h b/arch/arm/mach-ambarella/include/plat/dma.h
index 59fd4cc..0833aa6 100644
--- a/arch/arm/mach-ambarella/include/plat/dma.h
+++ b/arch/arm/mach-ambarella/include/plat/dma.h
@@ -27,10 +27,10 @@
 /* ==========================================================================*/
 #if (CHIP_REV == A5S) || (CHIP_REV == A7L)
 #define NUM_DMA_CHANNELS 		4
-#elif (CHIP_REV == S2L) || (CHIP_REV == S2E) || (CHIP_REV == S3)
-#define NUM_DMA_CHANNELS 		8
-#else
+#elif (CHIP_REV == S2)
 #define NUM_DMA_CHANNELS 		5
+#else
+#define NUM_DMA_CHANNELS 		8
 #endif
 
 #define DMA_OFFSET			0x5000
@@ -41,6 +41,7 @@
 #define FDMA_BASE			(AHB_BASE + FDMA_OFFSET)
 #define FDMA_REG(x)			(FDMA_BASE + (x))
 
+/* ==========================================================================*/
 
 #define INVALID_DMA_CHAN		0xFF
 
@@ -59,7 +60,7 @@
 #define SLIM_TX_DMA_CHAN		INVALID_DMA_CHAN
 #define SLIM_RX_DMA_CHAN		INVALID_DMA_CHAN
 
-#elif (CHIP_REV == S3)
+#elif (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define NOR_SPI_TX_DMA_CHAN		0
 #define NOR_SPI_RX_DMA_CHAN		1
 #define SSI1_TX_DMA_CHAN		2
@@ -197,7 +198,7 @@
 #define DMA_DSM_SPJP_64B                0x00000004
 #define DMA_DSM_SPJP_128B               0x00000005
 
-#if (CHIP_REV == S3)
+#if (CHIP_REV == S3) || (CHIP_REV == S2E) || (CHIP_REV == S3L)
 #define DMA_NODC_MN_BURST_SIZE	(DMA_CHANX_CTR_BLK_512B | DMA_CHANX_CTR_TS_8B)
 #define DMA_NODC_SP_BURST_SIZE	(DMA_CHANX_CTR_BLK_16B | DMA_CHANX_CTR_TS_8B)
 #define DMA_DESC_MN_BURST_SIZE	(DMA_DESC_BLK_512B | DMA_DESC_TS_8B)
diff --git a/arch/arm/mach-ambarella/include/plat/eth.h b/arch/arm/mach-ambarella/include/plat/eth.h
index c4a45bb..7764ca52 100644
--- a/arch/arm/mach-ambarella/include/plat/eth.h
+++ b/arch/arm/mach-ambarella/include/plat/eth.h
@@ -39,8 +39,24 @@
 
 #if (CHIP_REV == S3)
 #define ETH_ENHANCED 1
+struct ambeth_desc {
+	u32				status;
+	u32				length;
+	u32				buffer1;
+	u32				buffer2;
+	u32				des4;
+	u32				des5;
+	u32				des6;
+	u32				des7;
+} __attribute((packed));
 #else
 #define ETH_ENHANCED 0
+struct ambeth_desc {
+	u32				status;
+	u32				length;
+	u32				buffer1;
+	u32				buffer2;
+} __attribute((packed));
 #endif
 /* ==========================================================================*/
 #define ETH_OFFSET			0xE000
@@ -319,12 +335,21 @@
 
 /* Receive Descriptor 1 (RDES1) */
 #define ETH_RDES1_DIC			0x80000000
+#if (CHIP_REV == S3)
+#define ETH_RDES1_RER			0x00008000
+#define ETH_RDES1_RCH			0x00004000
+#define ETH_RDES1_RBS2(v)		(((v) & 0x1FFF0000) >> 16)
+#define ETH_RDES1_RBS1(v)		((v) & 0x00001FFF)
+#define ETH_RDES1_RBS2x(x)		(((x) << 16) & 0x1FFF0000)
+#define ETH_RDES1_RBS1x(x)		((x) & 0x00001FFF)
+#else
 #define ETH_RDES1_RER			0x02000000
 #define ETH_RDES1_RCH			0x01000000
 #define ETH_RDES1_RBS2(v)		(((v) & 0x003ff800) >> 11)	/* Receive Buffer 2 Size */
 #define ETH_RDES1_RBS1(v)		((v) & 0x000007ff)		/* Receive Buffer 1 Size */
 #define ETH_RDES1_RBS2x(x)		(((x) << 11) & 0x003ff800)	/* Receive Buffer 2 Size */
 #define ETH_RDES1_RBS1x(x)		((x) & 0x000007ff)		/* Receive Buffer 1 Size */
+#endif
 
 /* Transmit Descriptor 0 (TDES0) */
 #define ETH_TDES0_OWN			0x80000000
@@ -359,41 +384,18 @@
 #define ETH_TDES1_TER			0x02000000
 #define ETH_TDES1_TCH			0x01000000
 #define ETH_TDES1_DP			0x00800000
+#if (CHIP_REV == S3)
+#define ETH_TDES1_TBS2(v)		(((v) & 0x1FFF0000) >> 16)
+#define ETH_TDES1_TBS1(v)		((v) & 0x00001FFF)
+#define ETH_TDES1_TBS2x(x)		(((x) << 16) & 0x1FFF0000)
+#define ETH_TDES1_TBS1x(x)		((x) & 0x00001FFF)
+#else
 #define ETH_TDES1_TBS2(v)		(((v) & 0x003ff800) >> 11)
 #define ETH_TDES1_TBS1(v)		((v) & 0x000007ff)
 #define ETH_TDES1_TBS2x(x)		(((x) << 11) & 0x003ff800)
 #define ETH_TDES1_TBS1x(x)		((x) & 0x000007ff)
-
+#endif
 /* ==========================================================================*/
-#define ETH_ENHANCED_RDES0_OWN		0x80000000
-#define ETH_ENHANCED_RDES0_AFM		0x40000000
-#define ETH_ENHANCED_RDES0_FL(v)	(((v) & 0x3FFF0000) >> 16)
-#define ETH_ENHANCED_RDES0_ES		0x00008000
-#define ETH_ENHANCED_RDES0_DE		0x00004000
-#define ETH_ENHANCED_RDES0_SAF		0x00002000
-#define ETH_ENHANCED_RDES0_LE		0x00001000
-#define ETH_ENHANCED_RDES0_OE		0x00000800
-#define ETH_ENHANCED_RDES0_VLAN		0x00000400
-#define ETH_ENHANCED_RDES0_FS		0x00000200
-#define ETH_ENHANCED_RDES0_LS		0x00000100
-#define ETH_ENHANCED_RDES0_IPC		0x00000080
-#define ETH_ENHANCED_RDES0_LC		0x00000040
-#define ETH_ENHANCED_RDES0_FT		0x00000020
-#define ETH_ENHANCED_RDES0_RWT		0x00000010
-#define ETH_ENHANCED_RDES0_RE		0x00000008
-#define ETH_ENHANCED_RDES0_DBE		0x00000004
-#define ETH_ENHANCED_RDES0_CE		0x00000002
-#define ETH_ENHANCED_RDES0_RX		0x00000001
-
-#define ETH_ENHANCED_RDES1_DIC		0x80000000
-#define ETH_ENHANCED_RDES1_RER		0x00008000
-#define ETH_ENHANCED_RDES1_RCH		0x00004000
-#define ETH_ENHANCED_RDES1_RBS2(v)	(((v) & 0x1FFF0000) >> 16)
-#define ETH_ENHANCED_RDES1_RBS1(v)	((v) & 0x00001FFF)
-#define ETH_ENHANCED_RDES1_RBS2x(x)	(((x) << 16) & 0x1FFF0000)
-#define ETH_ENHANCED_RDES1_RBS1x(x)	((x) & 0x00001FFF)
-
-#define ETH_ENHANCED_TDES0_OWN		0x80000000
 #define ETH_ENHANCED_TDES0_IC		0x40000000
 #define ETH_ENHANCED_TDES0_LS		0x20000000
 #define ETH_ENHANCED_TDES0_FS		0x10000000
@@ -405,39 +407,18 @@
 #define ETH_ENHANCED_TDES0_CIC_HDR	0x00400000
 #define ETH_ENHANCED_TDES0_TER		0x00200000
 #define ETH_ENHANCED_TDES0_TCH		0x00100000
-#define ETH_ENHANCED_TDES0_TTSS		0x00020000
-#define ETH_ENHANCED_TDES0_IHE		0x00010000
-#define ETH_ENHANCED_TDES0_ES		0x00008000
-#define ETH_ENHANCED_TDES0_JT		0x00004000
-#define ETH_ENHANCED_TDES0_FF		0x00002000
-#define ETH_ENHANCED_TDES0_IPE		0x00001000
-#define ETH_ENHANCED_TDES0_LCA		0x00000800
-#define ETH_ENHANCED_TDES0_NC		0x00000400
-#define ETH_ENHANCED_TDES0_LCO		0x00000200
-#define ETH_ENHANCED_TDES0_EC		0x00000100
-#define ETH_ENHANCED_TDES0_VF		0x00000080
-#define ETH_ENHANCED_TDES0_CC(v)	(((v) & 0x00000078) >> 3)
-#define ETH_ENHANCED_TDES0_ED		0x00000004
-#define ETH_ENHANCED_TDES0_UF		0x00000002
-#define ETH_ENHANCED_TDES0_DB		0x00000001
-#define ETH_ENHANCED_TDES0_ES_MASK	(ETH_ENHANCED_TDES0_UF | \
-					ETH_ENHANCED_TDES0_ED | \
-					ETH_ENHANCED_TDES0_EC | \
-					ETH_ENHANCED_TDES0_LCO | \
-					ETH_ENHANCED_TDES0_NC | \
-					ETH_ENHANCED_TDES0_LCA | \
-					ETH_ENHANCED_TDES0_FF | \
-					ETH_ENHANCED_TDES0_JT | \
-					ETH_ENHANCED_TDES0_ES)
 
 #define ETH_ENHANCED_TDES1_SAIC_MAC1	0x80000000
 #define ETH_ENHANCED_TDES1_SAIC_REPLACE	0x40000000
 #define ETH_ENHANCED_TDES1_SAIC_INCLUDE	0x20000000
-#define ETH_ENHANCED_TDES1_TBS2(v)	(((v) & 0x1FFF0000) >> 16)
-#define ETH_ENHANCED_TDES1_TBS1(v)	((v) & 0x00001FFF)
-#define ETH_ENHANCED_TDES1_TBS2x(x)	(((x) << 16) & 0x1FFF0000)
-#define ETH_ENHANCED_TDES1_TBS1x(x)	((x) & 0x00001FFF)
 
+/*Different Bit of Descriptor*/
+#define ETH_TDES_IC	0x1
+#define ETH_TDES_LS	0x2
+#define ETH_TDES_FS	0x4
+#define ETH_TDES_DC	0x8
+#define ETH_TDES_TCH	0x10
+#define ETH_TDES_CIC	0x20
 /* ==========================================================================*/
 #define AMBARELLA_ETH_FC_AUTONEG	(1 << 0)
 #define AMBARELLA_ETH_FC_RX		(1 << 1)
@@ -447,7 +428,7 @@
 #define SYS_CONFIG_ETH_ENABLE		0xffffffff
 #elif (CHIP_REV == S2) || (CHIP_REV == S2E)
 #define SYS_CONFIG_ETH_ENABLE		0x00800000
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3)
+#elif (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define SYS_CONFIG_ETH_ENABLE		0x00000001
 #else
 #define SYS_CONFIG_ETH_ENABLE		0x00000080
diff --git a/arch/arm/mach-ambarella/include/plat/fb.h b/arch/arm/mach-ambarella/include/plat/fb.h
index 8e3e5c3..f0f4e9f 100644
--- a/arch/arm/mach-ambarella/include/plat/fb.h
+++ b/arch/arm/mach-ambarella/include/plat/fb.h
@@ -143,9 +143,6 @@ extern struct ambarella_platform_fb *ambfb_data_ptr[];
 /* ==========================================================================*/
 extern int ambarella_fb_get_platform_info(u32, struct ambarella_platform_fb *);
 extern int ambarella_fb_set_iav_info(u32, struct ambarella_fb_iav_info *);
-extern int ambarella_fb_update_info(u32 fb_id, int xres, int yres,
-	int xvirtual, int yvirtual, int format, u32 bits_per_pixel,
-	u32 smem_start, u32 smem_len);
 
 #endif /* __ASSEMBLER__ */
 /* ==========================================================================*/
diff --git a/arch/arm/mach-ambarella/include/plat/fio.h b/arch/arm/mach-ambarella/include/plat/fio.h
index f158fbd..ee31d42 100644
--- a/arch/arm/mach-ambarella/include/plat/fio.h
+++ b/arch/arm/mach-ambarella/include/plat/fio.h
@@ -31,44 +31,35 @@
 #define	FIO_USE_2X_FREQ			0
 #endif
 
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define	NAND_READ_ID5			1
-#define SYS_CONFIG_NAND_PAGE_SIZE	0x00000010
-#define SYS_CONFIG_NAND_READ_CONFIRM	0x00000020
-#define SYS_CONFIG_NAND_ECC_BCH_EN	0x00000400
-#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00000800
-
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define	NAND_READ_ID5			1
-#define SYS_CONFIG_NAND_PAGE_SIZE	0x00040000
-#define SYS_CONFIG_NAND_READ_CONFIRM	0x00020000
-#define SYS_CONFIG_NAND_ECC_BCH_EN	0x00010000
-#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00008000
-
-#else
+#if (CHIP_REV == A5S)
 #define	NAND_READ_ID5			0
-#define SYS_CONFIG_NAND_PAGE_SIZE	0x00000020
-#define SYS_CONFIG_NAND_READ_CONFIRM	0x00000040
-#define SYS_CONFIG_NAND_ECC_BCH_EN	0x00000000
-#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00000000
-
+#else
+#define	NAND_READ_ID5			1
 #endif
 
-#if (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define	FIO_INDEPENDENT_SD		1
-#else
+#if (CHIP_REV == A5S) || (CHIP_REV == S2)
 #define	FIO_INDEPENDENT_SD		0
+#else
+#define	FIO_INDEPENDENT_SD		1
 #endif
 
-#if (CHIP_REV == S2E)
-#define NAND_ECC_RPT_NUM_SUPPORT	1
+/* For BCH mode */
+#if (CHIP_REV == S3L)
+#define FIO_SUPPORT_SKIP_BLANK_ECC	1
 #else
-#define NAND_ECC_RPT_NUM_SUPPORT	0
+#define FIO_SUPPORT_SKIP_BLANK_ECC	0
 #endif
+
 /* ==========================================================================*/
 #define FIO_FIFO_OFFSET			0x0000
 #define FIO_OFFSET			0x1000
+#if (CHIP_REV == S2E)
+#define FIO_4K_OFFSET			0x1e000
+#else
 #define FIO_4K_OFFSET			0x30000
+#endif
+
+#define FIO_4K_PHYS_BASE		(AHB_PHYS_BASE + FIO_4K_OFFSET)
 
 #define FIO_FIFO_BASE			(AHB_BASE + FIO_FIFO_OFFSET)
 #define FIO_BASE			(AHB_BASE + FIO_OFFSET)
@@ -97,6 +88,11 @@
 #define FIO_CTR_DA			0x00020000
 #define FIO_CTR_DR			0x00010000
 #define FIO_CTR_SX			0x00000100
+#if (FIO_SUPPORT_SKIP_BLANK_ECC == 1)
+#define FIO_CTR_SKIP_BLANK		0x00000080
+#else
+#define FIO_CTR_SKIP_BLANK		0x00000000
+#endif
 #define FIO_CTR_ECC_8BIT		0x00000060
 #define FIO_CTR_ECC_6BIT		0x00000040
 #define FIO_CTR_RS			0x00000010
@@ -183,6 +179,8 @@ extern void fio_amb_sdio0_set_int(u32 mask, u32 on);
 extern int ambarella_init_fio(void);
 extern void ambarella_fio_rct_reset(void);
 
+extern void *ambarella_fio_push(void *func, u32 size);
+
 #endif /* __ASSEMBLER__ */
 /* ==========================================================================*/
 
diff --git a/arch/arm/mach-ambarella/include/plat/gpio.h b/arch/arm/mach-ambarella/include/plat/gpio.h
index 34b1014..ee2b64e 100644
--- a/arch/arm/mach-ambarella/include/plat/gpio.h
+++ b/arch/arm/mach-ambarella/include/plat/gpio.h
@@ -37,9 +37,9 @@
 #elif (CHIP_REV == A8)
 #define GPIO_INSTANCES			1
 #define GPIO_MAX_LINES			16
-#elif (CHIP_REV == S2L)
+#elif (CHIP_REV == S2L) || (CHIP_REV == S3L)
 #define GPIO_INSTANCES			4
-#define GPIO_MAX_LINES			113
+#define GPIO_MAX_LINES			114
 #elif (CHIP_REV == S3)
 #define GPIO_INSTANCES			7
 #define GPIO_MAX_LINES			201
@@ -51,12 +51,12 @@
 #define GPIO0_OFFSET			0x9000
 #define GPIO1_OFFSET			0xA000
 #define GPIO2_OFFSET			0xE000
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define GPIO3_OFFSET			0x10000
+#if (CHIP_REV == A5S)
+#define GPIO3_OFFSET			0x1F000
 #elif (CHIP_REV == A7L)
 #define GPIO3_OFFSET			0x1E000
 #else
-#define GPIO3_OFFSET			0x1F000
+#define GPIO3_OFFSET			0x10000
 #endif
 #define GPIO4_OFFSET			0x11000
 #if (CHIP_REV == S3)
@@ -136,7 +136,7 @@
 #define GPIO_ENABLE_OFFSET		0x2c
 
 /* ==========================================================================*/
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define	IOMUX_SUPPORT			1
 #else
 #define	IOMUX_SUPPORT			0
@@ -194,21 +194,6 @@
 /* ==========================================================================*/
 #ifndef __ASSEMBLER__
 
-/* gpio service for private operation */
-enum ambsvc_gpio_service_id {
-	AMBSVC_GPIO_REQUEST = 0,
-	AMBSVC_GPIO_OUTPUT,
-	AMBSVC_GPIO_INPUT,
-	AMBSVC_GPIO_FREE,
-	AMBSVC_GPIO_TO_IRQ,
-};
-
-struct ambsvc_gpio {
-	int svc_id;
-	int gpio;
-	int value;
-};
-
 #endif /* __ASSEMBLER__ */
 /* ==========================================================================*/
 
diff --git a/arch/arm/mach-ambarella/include/plat/iav_helper.h b/arch/arm/mach-ambarella/include/plat/iav_helper.h
new file mode 100644
index 0000000..f74a793
--- /dev/null
+++ b/arch/arm/mach-ambarella/include/plat/iav_helper.h
@@ -0,0 +1,85 @@
+/*
+ * arch/arm/plat-ambarella/include/plat/service.h
+ *
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ *
+ * Copyright (C) 2012-2016, Ambarella, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#ifndef __PLAT_AMBARELLA_SERVICE_H
+#define __PLAT_AMBARELLA_SERVICE_H
+
+#ifndef __ASSEMBLER__
+
+/*===========================================================================*/
+
+/* gpio service for private operation */
+enum ambsvc_gpio_service_id {
+	AMBSVC_GPIO_REQUEST = 0,
+	AMBSVC_GPIO_OUTPUT,
+	AMBSVC_GPIO_INPUT,
+	AMBSVC_GPIO_FREE,
+	AMBSVC_GPIO_TO_IRQ,
+};
+
+struct ambsvc_gpio {
+	int svc_id;
+	int gpio;
+	int value;
+};
+
+/* pll service for private operation */
+enum ambsvc_pll_service_id {
+	AMBSVC_PLL_GET_RATE = 0,
+	AMBSVC_PLL_SET_RATE = 1,
+};
+
+struct ambsvc_pll {
+	int svc_id;
+	char *name;
+	int rate;
+};
+
+enum ambarella_service_id {
+	AMBARELLA_SERVICE_GPIO = 1,
+	AMBARELLA_SERVICE_PLL = 2,
+};
+
+typedef int (*ambarella_service_func)(void *arg, void *result);
+
+struct ambarella_service {
+	int service;
+	ambarella_service_func func;
+	struct list_head node;
+};
+
+extern int ambarella_register_service(struct ambarella_service *amb_svc);
+extern int ambarella_unregister_service(struct ambarella_service *amb_svc);
+extern int ambarella_request_service(int service, void *arg, void *result);
+
+/*===========================================================================*/
+extern void ambcache_clean_all(void *addr, unsigned int size);
+extern void ambcache_clean_range(void *addr, unsigned int size);
+extern void ambcache_inv_range(void *addr, unsigned int size);
+
+/*===========================================================================*/
+
+#endif /* __ASSEMBLER__ */
+
+#endif
+
diff --git a/arch/arm/mach-ambarella/include/plat/idc.h b/arch/arm/mach-ambarella/include/plat/idc.h
index e99ccac..92caff1 100644
--- a/arch/arm/mach-ambarella/include/plat/idc.h
+++ b/arch/arm/mach-ambarella/include/plat/idc.h
@@ -39,7 +39,7 @@
 #define IDC_BASE			(APB_BASE + IDC_OFFSET)
 #define IDC_REG(x)			(IDC_BASE + (x))
 
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define IDC2_OFFSET			0x1000
 #else
 #define IDC2_OFFSET			0x7000
@@ -51,7 +51,7 @@
 #define IDC3_OFFSET			0x13000
 #elif (CHIP_REV == A8)
 #define IDC3_OFFSET			0xE000
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3)
+#elif (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define IDC3_OFFSET			0x7000
 #endif
 #define IDC3_BASE			(APB_BASE + IDC3_OFFSET)
@@ -76,6 +76,9 @@
 #define IDC_CTRL_ACK			(0x01)
 #define IDC_CTRL_CLS			(0x00)
 
+#define IDC_STS_FIFO_EMP		(0x04)
+#define IDC_STS_FIFO_FUL		(0x02)
+
 #define IDC_FIFO_BUF_SIZE		(63)
 
 #define IDC_FMCTRL_STOP			(0x08)
diff --git a/arch/arm/mach-ambarella/include/plat/irq.h b/arch/arm/mach-ambarella/include/plat/irq.h
index cdd8a74..7786c42 100644
--- a/arch/arm/mach-ambarella/include/plat/irq.h
+++ b/arch/arm/mach-ambarella/include/plat/irq.h
@@ -37,7 +37,7 @@
 #define VIC_INSTANCES			(3)
 #define VIC_SUPPORT_CPU_OFFLOAD		(0)
 #define VIC_SUPPORT_REPRIORITIZE	(0)
-#elif (CHIP_REV == S2E)
+#elif (CHIP_REV == S2E) || (CHIP_REV == S3L)
 #define VIC_INSTANCES			(3)
 #define VIC_SUPPORT_CPU_OFFLOAD		(2)
 #define VIC_SUPPORT_REPRIORITIZE	(1)
@@ -70,25 +70,29 @@
 #endif
 #endif
 
-#if (CHIP_REV == S3)
+#if (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define VIC_2NDGEN_BITASSIGNMENT	(1)
 #endif
 
 /* ==========================================================================*/
-#define VIC_OFFSET			0x3000
-#define VIC2_OFFSET			0x10000
-#define VIC3_OFFSET			0x1C000
-#define VIC4_OFFSET			0x11000
+#define VIC0_OFFSET			0x3000
+#define VIC1_OFFSET			0x10000
+#define VIC2_OFFSET			0x1C000
+#define VIC3_OFFSET			0x11000
 
-#define VIC_BASE			(AHB_BASE + VIC_OFFSET)
+#define VIC0_BASE			(AHB_BASE + VIC0_OFFSET)
+#define VIC1_BASE			(AHB_BASE + VIC1_OFFSET)
 #define VIC2_BASE			(AHB_BASE + VIC2_OFFSET)
 #define VIC3_BASE			(AHB_BASE + VIC3_OFFSET)
-#define VIC4_BASE			(AHB_BASE + VIC4_OFFSET)
 
-#define VIC_REG(x)			(VIC_BASE + (x))
+#define VIC0_REG(x)			(VIC0_BASE + (x))
+#define VIC1_REG(x)			(VIC1_BASE + (x))
 #define VIC2_REG(x)			(VIC2_BASE + (x))
 #define VIC3_REG(x)			(VIC3_BASE + (x))
-#define VIC4_REG(x)			(VIC4_BASE + (x))
+#define VIC_REG(irq, x)			((irq) < VIC0_INT_VEC(NR_VIC_IRQ_SIZE) ? VIC0_REG((x)) : \
+					 (irq) < VIC1_INT_VEC(NR_VIC_IRQ_SIZE) ? VIC1_REG((x)) : \
+					 (irq) < VIC2_INT_VEC(NR_VIC_IRQ_SIZE) ? VIC2_REG((x)) : \
+					 VIC3_REG((x)))
 
 /* ==========================================================================*/
 #define NR_VIC_IRQ_SIZE			(32)
@@ -103,10 +107,10 @@
 #define VIC_IRQ(x)			(x)
 #endif
 
-#define VIC_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 0)
-#define VIC2_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 1)
-#define VIC3_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 2)
-#define VIC4_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 3)
+#define VIC0_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 0)
+#define VIC1_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 1)
+#define VIC2_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 2)
+#define VIC3_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 3)
 
 #ifndef NR_SPI_IRQS
 #define NR_VIC_IRQS			(VIC_INSTANCES * NR_VIC_IRQ_SIZE)
@@ -166,220 +170,220 @@
 
 /* ==========================================================================*/
 #if (CHIP_REV == A5S)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define VDSP_IRQ			VIC_INT_VEC(3)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define HIF_ARM1_IRQ			VIC_INT_VEC(5)
-#define HIF_ARM2_IRQ			VIC_INT_VEC(6)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SSI_IRQ				VIC_INT_VEC(20)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define CFCD1_IRQ			VIC_INT_VEC(23)
-#define SD1CD_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define SSI_SLAVE_IRQ			VIC_INT_VEC(26)
-#define ETH_IRQ				VIC_INT_VEC(27)
-#define IDSP_ERROR_IRQ			VIC_INT_VEC(28)
-#define VOUT_SYNC_MISSED_IRQ		VIC_INT_VEC(29)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-#define CFCD2_IRQ			VIC_INT_VEC(31)
-
-#define AUDIO_ORC_IRQ			VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define VOUT1_SYNC_MISSED_IRQ		VIC2_INT_VEC(3)
-#define IDC2_IRQ			VIC2_INT_VEC(4)
-#define IDSP_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_VSYNC_IRQ			VIC2_INT_VEC(6)
-#define IDSP_SENSOR_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define SSI2_IRQ			VIC2_INT_VEC(9)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(12)
-#define AES_IRQ				VIC2_INT_VEC(13)
-#define DES_IRQ				VIC2_INT_VEC(14)
-#define MS_IRQ				VIC2_INT_VEC(15)
-#define GDMA_IRQ			VIC2_INT_VEC(16)
-#define MOTOR_IRQ			VIC2_INT_VEC(17)
-#define PMU_IRQ				VIC2_INT_VEC(31)
+#define USBVBUS_IRQ			VIC0_INT_VEC(0)
+#define VOUT_IRQ			VIC0_INT_VEC(1)
+#define VIN_IRQ				VIC0_INT_VEC(2)
+#define VDSP_IRQ			VIC0_INT_VEC(3)
+#define USBC_IRQ			VIC0_INT_VEC(4)
+#define HIF_ARM1_IRQ			VIC0_INT_VEC(5)
+#define HIF_ARM2_IRQ			VIC0_INT_VEC(6)
+#define I2STX_IRQ			VIC0_INT_VEC(7)
+#define I2SRX_IRQ			VIC0_INT_VEC(8)
+#define UART0_IRQ			VIC0_INT_VEC(9)
+#define GPIO0_IRQ			VIC0_INT_VEC(10)
+#define GPIO1_IRQ			VIC0_INT_VEC(11)
+#define TIMER1_IRQ			VIC0_INT_VEC(12)
+#define TIMER2_IRQ			VIC0_INT_VEC(13)
+#define TIMER3_IRQ			VIC0_INT_VEC(14)
+#define DMA_IRQ				VIC0_INT_VEC(15)
+#define FIOCMD_IRQ			VIC0_INT_VEC(16)
+#define FIODMA_IRQ			VIC0_INT_VEC(17)
+#define SD_IRQ				VIC0_INT_VEC(18)
+#define IDC_IRQ				VIC0_INT_VEC(19)
+#define SSI_IRQ				VIC0_INT_VEC(20)
+#define WDT_IRQ				VIC0_INT_VEC(21)
+#define IRIF_IRQ			VIC0_INT_VEC(22)
+#define CFCD1_IRQ			VIC0_INT_VEC(23)
+#define SD1CD_IRQ			VIC0_INT_VEC(24)
+#define UART1_IRQ			VIC0_INT_VEC(25)
+#define SSI_SLAVE_IRQ			VIC0_INT_VEC(26)
+#define ETH_IRQ				VIC0_INT_VEC(27)
+#define IDSP_ERROR_IRQ			VIC0_INT_VEC(28)
+#define VOUT_SYNC_MISSED_IRQ		VIC0_INT_VEC(29)
+#define GPIO2_IRQ			VIC0_INT_VEC(30)
+#define CFCD2_IRQ			VIC0_INT_VEC(31)
+
+#define AUDIO_ORC_IRQ			VIC1_INT_VEC(0)
+#define DMA_FIOS_IRQ			VIC1_INT_VEC(1)
+#define ADC_LEVEL_IRQ			VIC1_INT_VEC(2)
+#define VOUT1_SYNC_MISSED_IRQ		VIC1_INT_VEC(3)
+#define IDC2_IRQ			VIC1_INT_VEC(4)
+#define IDSP_LAST_PIXEL_IRQ		VIC1_INT_VEC(5)
+#define IDSP_VSYNC_IRQ			VIC1_INT_VEC(6)
+#define IDSP_SENSOR_VSYNC_IRQ		VIC1_INT_VEC(7)
+#define HDMI_IRQ			VIC1_INT_VEC(8)
+#define SSI2_IRQ			VIC1_INT_VEC(9)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(10)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(11)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(12)
+#define AES_IRQ				VIC1_INT_VEC(13)
+#define DES_IRQ				VIC1_INT_VEC(14)
+#define MS_IRQ				VIC1_INT_VEC(15)
+#define GDMA_IRQ			VIC1_INT_VEC(16)
+#define MOTOR_IRQ			VIC1_INT_VEC(17)
+#define PMU_IRQ				VIC1_INT_VEC(31)
 
 /* ==========================================================================*/
 #elif (CHIP_REV == A7L)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define GDMA_IRQ			VIC_INT_VEC(3)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define SD1CD_IRQ			VIC_INT_VEC(5)
-#define VDSP_IRQ			VIC_INT_VEC(6)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SSI_IRQ				VIC_INT_VEC(20)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define CFCD2_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define IDC2_IRQ			VIC_INT_VEC(26)
-#define IDSP_ERROR_IRQ			VIC_INT_VEC(28)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-
-#define PMU_IRQ				VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define IDSP_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_VSYNC_IRQ			VIC2_INT_VEC(6)
-#define IDSP_SENSOR_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define SSI_SLAVE_IRQ			VIC2_INT_VEC(9)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(12)
-#define MS_IRQ				VIC2_INT_VEC(15)
-#define MOTOR_IRQ			VIC2_INT_VEC(17)
-#define GPIO3_IRQ			VIC2_INT_VEC(19)
-#define DRAM_ERROR_IRQ			VIC2_INT_VEC(23)
-#define SD2_IRQ				VIC2_INT_VEC(24)
-#define TIMER4_IRQ			VIC2_INT_VEC(27)
-#define TIMER5_IRQ			VIC2_INT_VEC(28)
-#define TIMER6_IRQ			VIC2_INT_VEC(29)
-#define TIMER7_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
+#define USBVBUS_IRQ			VIC0_INT_VEC(0)
+#define VOUT_IRQ			VIC0_INT_VEC(1)
+#define VIN_IRQ				VIC0_INT_VEC(2)
+#define GDMA_IRQ			VIC0_INT_VEC(3)
+#define USBC_IRQ			VIC0_INT_VEC(4)
+#define SD1CD_IRQ			VIC0_INT_VEC(5)
+#define VDSP_IRQ			VIC0_INT_VEC(6)
+#define I2STX_IRQ			VIC0_INT_VEC(7)
+#define I2SRX_IRQ			VIC0_INT_VEC(8)
+#define UART0_IRQ			VIC0_INT_VEC(9)
+#define GPIO0_IRQ			VIC0_INT_VEC(10)
+#define GPIO1_IRQ			VIC0_INT_VEC(11)
+#define TIMER1_IRQ			VIC0_INT_VEC(12)
+#define TIMER2_IRQ			VIC0_INT_VEC(13)
+#define TIMER3_IRQ			VIC0_INT_VEC(14)
+#define DMA_IRQ				VIC0_INT_VEC(15)
+#define FIOCMD_IRQ			VIC0_INT_VEC(16)
+#define FIODMA_IRQ			VIC0_INT_VEC(17)
+#define SD_IRQ				VIC0_INT_VEC(18)
+#define IDC_IRQ				VIC0_INT_VEC(19)
+#define SSI_IRQ				VIC0_INT_VEC(20)
+#define WDT_IRQ				VIC0_INT_VEC(21)
+#define IRIF_IRQ			VIC0_INT_VEC(22)
+#define CFCD2_IRQ			VIC0_INT_VEC(24)
+#define UART1_IRQ			VIC0_INT_VEC(25)
+#define IDC2_IRQ			VIC0_INT_VEC(26)
+#define IDSP_ERROR_IRQ			VIC0_INT_VEC(28)
+#define GPIO2_IRQ			VIC0_INT_VEC(30)
+
+#define PMU_IRQ				VIC1_INT_VEC(0)
+#define DMA_FIOS_IRQ			VIC1_INT_VEC(1)
+#define ADC_LEVEL_IRQ			VIC1_INT_VEC(2)
+#define IDSP_LAST_PIXEL_IRQ		VIC1_INT_VEC(5)
+#define IDSP_VSYNC_IRQ			VIC1_INT_VEC(6)
+#define IDSP_SENSOR_VSYNC_IRQ		VIC1_INT_VEC(7)
+#define HDMI_IRQ			VIC1_INT_VEC(8)
+#define SSI_SLAVE_IRQ			VIC1_INT_VEC(9)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(10)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(11)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(12)
+#define MS_IRQ				VIC1_INT_VEC(15)
+#define MOTOR_IRQ			VIC1_INT_VEC(17)
+#define GPIO3_IRQ			VIC1_INT_VEC(19)
+#define DRAM_ERROR_IRQ			VIC1_INT_VEC(23)
+#define SD2_IRQ				VIC1_INT_VEC(24)
+#define TIMER4_IRQ			VIC1_INT_VEC(27)
+#define TIMER5_IRQ			VIC1_INT_VEC(28)
+#define TIMER6_IRQ			VIC1_INT_VEC(29)
+#define TIMER7_IRQ			VIC1_INT_VEC(30)
+#define TIMER8_IRQ			VIC1_INT_VEC(31)
 
 /* ==========================================================================*/
 #elif (CHIP_REV == S2)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define USB_CHARGE_IRQ			VIC_INT_VEC(5)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SSI_IRQ				VIC_INT_VEC(20)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define CFCD1_IRQ			VIC_INT_VEC(23)
-#define SD1CD_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define SSI_SLAVE_IRQ			VIC_INT_VEC(26)
-#define ETH_IRQ				VIC_INT_VEC(27)
-#define IDSP_SOFT_IRQ			VIC_INT_VEC(28)
-#define GPIO3_IRQ			VIC_INT_VEC(29)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-
-#define ROLLING_SHUTTER_IRQ		VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define IDSP_VIN_SOFT_IRQ		VIC2_INT_VEC(3)
-#define IDC2_IRQ			VIC2_INT_VEC(4)
-#define IDSP_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_VSYNC_IRQ			VIC2_INT_VEC(6)
-#define IDSP_SENSOR_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define FIOS_ECC_IRQ			VIC2_INT_VEC(9)
-
-#define GPIO4_IRQ			VIC2_INT_VEC(16)
-#define MOTOR_IRQ			VIC2_INT_VEC(17)
-#define GDMA_IRQ			VIC2_INT_VEC(18)
-#define FACE_DET_IRQ			VIC2_INT_VEC(19)
-#define SD2_IRQ				VIC2_INT_VEC(20)
-#define SSI_MASTER_IRQ			VIC2_INT_VEC(21)
-#define IDSP_PROG_IRQ			VIC2_INT_VEC(26)
-
-#define VDSP_PIP_SVSYNC_IRQ		VIC3_INT_VEC(0)
-#define IDSP_PIP_SVSYNC_IRQ		VIC3_INT_VEC(1)
-#define IDSP_PIP_PROG_IRQ		VIC3_INT_VEC(2)
-#define IDSP_PIP_LAST_PIXEL_IRQ		VIC3_INT_VEC(3)
-#define CORTEX_CORE0_IRQ		VIC3_INT_VEC(4)
-#define CORTEX_CORE1_IRQ		VIC3_INT_VEC(5)
-#define ETH_PMT_INTR_IRQ		VIC3_INT_VEC(6)
-#define I2S1_RX_IRQ			VIC3_INT_VEC(7)
-#define I2S1_TX_IRQ			VIC3_INT_VEC(8)
-#define USB_EHCI_IRQ			VIC3_INT_VEC(9)
-#define AXI_SOFT_IRQ(x)			VIC3_INT_VEC((x) + 10)	/* 0 <= x <= 13 */
-#define CORTEX_WDT_IRQ			VIC3_INT_VEC(24)
-#define USB_OHCI_IRQ			VIC3_INT_VEC(25)
-#define IDC3_IRQ			VIC3_INT_VEC(26)
-#define UART2_IRQ			VIC3_INT_VEC(27)
-#define UART3_IRQ			VIC3_INT_VEC(28)
-#define PMU_IRQ				VIC3_INT_VEC(31)
+#define USBVBUS_IRQ			VIC0_INT_VEC(0)
+#define USBC_IRQ			VIC0_INT_VEC(4)
+#define USB_CHARGE_IRQ			VIC0_INT_VEC(5)
+#define I2STX_IRQ			VIC0_INT_VEC(7)
+#define I2SRX_IRQ			VIC0_INT_VEC(8)
+#define UART0_IRQ			VIC0_INT_VEC(9)
+#define GPIO0_IRQ			VIC0_INT_VEC(10)
+#define GPIO1_IRQ			VIC0_INT_VEC(11)
+#define DMA_IRQ				VIC0_INT_VEC(15)
+#define FIOCMD_IRQ			VIC0_INT_VEC(16)
+#define FIODMA_IRQ			VIC0_INT_VEC(17)
+#define SD_IRQ				VIC0_INT_VEC(18)
+#define IDC_IRQ				VIC0_INT_VEC(19)
+#define SSI_IRQ				VIC0_INT_VEC(20)
+#define IRIF_IRQ			VIC0_INT_VEC(22)
+#define CFCD1_IRQ			VIC0_INT_VEC(23)
+#define SD1CD_IRQ			VIC0_INT_VEC(24)
+#define UART1_IRQ			VIC0_INT_VEC(25)
+#define SSI_SLAVE_IRQ			VIC0_INT_VEC(26)
+#define ETH_IRQ				VIC0_INT_VEC(27)
+#define IDSP_SOFT_IRQ			VIC0_INT_VEC(28)
+#define GPIO3_IRQ			VIC0_INT_VEC(29)
+#define GPIO2_IRQ			VIC0_INT_VEC(30)
+
+#define ROLLING_SHUTTER_IRQ		VIC1_INT_VEC(0)
+#define DMA_FIOS_IRQ			VIC1_INT_VEC(1)
+#define ADC_LEVEL_IRQ			VIC1_INT_VEC(2)
+#define IDSP_VIN_SOFT_IRQ		VIC1_INT_VEC(3)
+#define IDC2_IRQ			VIC1_INT_VEC(4)
+#define IDSP_LAST_PIXEL_IRQ		VIC1_INT_VEC(5)
+#define IDSP_VSYNC_IRQ			VIC1_INT_VEC(6)
+#define IDSP_SENSOR_VSYNC_IRQ		VIC1_INT_VEC(7)
+#define HDMI_IRQ			VIC1_INT_VEC(8)
+#define FIOS_ECC_IRQ			VIC1_INT_VEC(9)
+
+#define GPIO4_IRQ			VIC1_INT_VEC(16)
+#define MOTOR_IRQ			VIC1_INT_VEC(17)
+#define GDMA_IRQ			VIC1_INT_VEC(18)
+#define FACE_DET_IRQ			VIC1_INT_VEC(19)
+#define SD2_IRQ				VIC1_INT_VEC(20)
+#define SSI_MASTER_IRQ			VIC1_INT_VEC(21)
+#define IDSP_PROG_IRQ			VIC1_INT_VEC(26)
+
+#define VDSP_PIP_SVSYNC_IRQ		VIC2_INT_VEC(0)
+#define IDSP_PIP_SVSYNC_IRQ		VIC2_INT_VEC(1)
+#define IDSP_PIP_PROG_IRQ		VIC2_INT_VEC(2)
+#define IDSP_PIP_LAST_PIXEL_IRQ		VIC2_INT_VEC(3)
+#define CORTEX_CORE0_IRQ		VIC2_INT_VEC(4)
+#define CORTEX_CORE1_IRQ		VIC2_INT_VEC(5)
+#define ETH_PMT_INTR_IRQ		VIC2_INT_VEC(6)
+#define I2S1_RX_IRQ			VIC2_INT_VEC(7)
+#define I2S1_TX_IRQ			VIC2_INT_VEC(8)
+#define USB_EHCI_IRQ			VIC2_INT_VEC(9)
+#define AXI_SOFT_IRQ(x)			VIC2_INT_VEC((x) + 10)	/* 0 <= x <= 13 */
+#define CORTEX_WDT_IRQ			VIC2_INT_VEC(24)
+#define USB_OHCI_IRQ			VIC2_INT_VEC(25)
+#define IDC3_IRQ			VIC2_INT_VEC(26)
+#define UART2_IRQ			VIC2_INT_VEC(27)
+#define UART3_IRQ			VIC2_INT_VEC(28)
+#define PMU_IRQ				VIC2_INT_VEC(31)
 
 #if defined(CONFIG_ARM_GIC)
-#define VOUT_IRQ			VIC4_INT_VEC(0)
-#define VIN_IRQ				VIC4_INT_VEC(1)
-#define TIMER1_IRQ			VIC4_INT_VEC(2)
-#define TIMER2_IRQ			VIC4_INT_VEC(3)
-#define TIMER3_IRQ			VIC4_INT_VEC(4)
-#define WDT_IRQ				VIC4_INT_VEC(5)
-#define VOUT_TV_SYNC_IRQ		VIC4_INT_VEC(6)
-#define VOUT_LCD_SYNC_IRQ		VIC4_INT_VEC(7)
-#define ORC_VOUT0_IRQ			VIC4_INT_VEC(8)
-#define TIMER4_IRQ			VIC4_INT_VEC(9)
-#define TIMER5_IRQ			VIC4_INT_VEC(10)
-#define TIMER6_IRQ			VIC4_INT_VEC(11)
-#define TIMER7_IRQ			VIC4_INT_VEC(12)
-#define TIMER8_IRQ			VIC4_INT_VEC(13)
-#define CODE_VDSP_0_IRQ			VIC4_INT_VEC(14)
-#define CODE_VDSP_1_IRQ			VIC4_INT_VEC(15)
-#define CODE_VDSP_2_IRQ			VIC4_INT_VEC(16)
-#define CODE_VDSP_3_IRQ			VIC4_INT_VEC(17)
-#define MD5_IRQ				VIC4_INT_VEC(24)
-#define DES_IRQ				VIC4_INT_VEC(25)
-#define AES_IRQ				VIC4_INT_VEC(26)
-#define SHA1_IRQ			VIC4_INT_VEC(27)
+#define VOUT_IRQ			VIC3_INT_VEC(0)
+#define VIN_IRQ				VIC3_INT_VEC(1)
+#define TIMER1_IRQ			VIC3_INT_VEC(2)
+#define TIMER2_IRQ			VIC3_INT_VEC(3)
+#define TIMER3_IRQ			VIC3_INT_VEC(4)
+#define WDT_IRQ				VIC3_INT_VEC(5)
+#define VOUT_TV_SYNC_IRQ		VIC3_INT_VEC(6)
+#define VOUT_LCD_SYNC_IRQ		VIC3_INT_VEC(7)
+#define ORC_VOUT0_IRQ			VIC3_INT_VEC(8)
+#define TIMER4_IRQ			VIC3_INT_VEC(9)
+#define TIMER5_IRQ			VIC3_INT_VEC(10)
+#define TIMER6_IRQ			VIC3_INT_VEC(11)
+#define TIMER7_IRQ			VIC3_INT_VEC(12)
+#define TIMER8_IRQ			VIC3_INT_VEC(13)
+#define CODE_VDSP_0_IRQ			VIC3_INT_VEC(14)
+#define CODE_VDSP_1_IRQ			VIC3_INT_VEC(15)
+#define CODE_VDSP_2_IRQ			VIC3_INT_VEC(16)
+#define CODE_VDSP_3_IRQ			VIC3_INT_VEC(17)
+#define MD5_IRQ				VIC3_INT_VEC(24)
+#define DES_IRQ				VIC3_INT_VEC(25)
+#define AES_IRQ				VIC3_INT_VEC(26)
+#define SHA1_IRQ			VIC3_INT_VEC(27)
 #else
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(14)
-#define TIMER4_IRQ			VIC2_INT_VEC(27)
-#define TIMER5_IRQ			VIC2_INT_VEC(28)
-#define TIMER6_IRQ			VIC2_INT_VEC(29)
-#define TIMER7_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
-#define CODE_VDSP_0_IRQ			VIC_INT_VEC(3)
-#define CODE_VDSP_1_IRQ			VIC2_INT_VEC(24)
-#define CODE_VDSP_2_IRQ			VIC2_INT_VEC(23)
-#define CODE_VDSP_3_IRQ			VIC2_INT_VEC(22)
-#define DES_IRQ				VIC2_INT_VEC(12)
-#define AES_IRQ				VIC2_INT_VEC(13)
-#define MD5_SHA1_IRQ			VIC2_INT_VEC(25)
+#define VOUT_IRQ			VIC0_INT_VEC(1)
+#define VIN_IRQ				VIC0_INT_VEC(2)
+#define TIMER1_IRQ			VIC0_INT_VEC(12)
+#define TIMER2_IRQ			VIC0_INT_VEC(13)
+#define TIMER3_IRQ			VIC0_INT_VEC(14)
+#define WDT_IRQ				VIC0_INT_VEC(21)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(10)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(11)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(14)
+#define TIMER4_IRQ			VIC1_INT_VEC(27)
+#define TIMER5_IRQ			VIC1_INT_VEC(28)
+#define TIMER6_IRQ			VIC1_INT_VEC(29)
+#define TIMER7_IRQ			VIC1_INT_VEC(30)
+#define TIMER8_IRQ			VIC1_INT_VEC(31)
+#define CODE_VDSP_0_IRQ			VIC0_INT_VEC(3)
+#define CODE_VDSP_1_IRQ			VIC1_INT_VEC(24)
+#define CODE_VDSP_2_IRQ			VIC1_INT_VEC(23)
+#define CODE_VDSP_3_IRQ			VIC1_INT_VEC(22)
+#define DES_IRQ				VIC1_INT_VEC(12)
+#define AES_IRQ				VIC1_INT_VEC(13)
+#define MD5_SHA1_IRQ			VIC1_INT_VEC(25)
 #endif
 
 #define GLOBAL_TIMER_IRQ		PPI_INT_VEC(27)
@@ -398,211 +402,211 @@
 
 /* ==========================================================================*/
 #elif (CHIP_REV == S2E)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define CODE_VDSP_0_IRQ			VIC_INT_VEC(3)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define USB_CHARGE_IRQ			VIC_INT_VEC(5)
-#define PMU_IRQ				VIC_INT_VEC(6)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SSI_IRQ				VIC_INT_VEC(20)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define SD1CD_IRQ			VIC_INT_VEC(23)
-#define SD0CD_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define SSI_SLAVE_IRQ			VIC_INT_VEC(26)
-#define ETH_IRQ				VIC_INT_VEC(27)
-#define IDSP_SOFT_IRQ			VIC_INT_VEC(28)
-#define GPIO3_IRQ			VIC_INT_VEC(29)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-#define PMU1_IRQ			VIC_INT_VEC(31)
-
-#define ROLLING_SHUTTER_IRQ		VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define IDSP_VIN_SOFT_IRQ		VIC2_INT_VEC(3)
-#define IDC2_IRQ			VIC2_INT_VEC(4)
-#define IDSP_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_VSYNC_IRQ			VIC2_INT_VEC(6)
-#define IDSP_SENSOR_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define FIOS_ECC_IRQ			VIC2_INT_VEC(9)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define AES_IRQ				VIC2_INT_VEC(12)
-#define DES_IRQ				VIC2_INT_VEC(13)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(14)
-#define MD5_IRQ				VIC2_INT_VEC(15)
-#define GPIO4_IRQ			VIC2_INT_VEC(16)
-#define MOTOR_IRQ			VIC2_INT_VEC(17)
-#define GDMA_IRQ			VIC2_INT_VEC(18)
-#define L2CC_INTR1_IRQ			VIC2_INT_VEC(19)
-#define SD2_IRQ				VIC2_INT_VEC(20)
-#define SSI_MASTER_IRQ			VIC2_INT_VEC(21)
-#define CODE_VDSP_3_IRQ			VIC2_INT_VEC(22)
-#define CODE_VDSP_2_IRQ			VIC2_INT_VEC(23)
-#define CODE_VDSP_1_IRQ			VIC2_INT_VEC(24)
-#define L2CC_INTR_IRQ			VIC2_INT_VEC(25)
-#define IDSP_PROG_IRQ			VIC2_INT_VEC(26)
-#define TIMER4_IRQ			VIC2_INT_VEC(27)
-#define TIMER5_IRQ			VIC2_INT_VEC(28)
-#define TIMER6_IRQ			VIC2_INT_VEC(29)
-#define TIMER7_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
-
-#define VDSP_PIP_SVSYNC_IRQ		VIC3_INT_VEC(0)
-#define IDSP_PIP_SVSYNC_IRQ		VIC3_INT_VEC(1)
-#define IDSP_PIP_PROG_IRQ		VIC3_INT_VEC(2)
-#define IDSP_PIP_LAST_PIXEL_IRQ		VIC3_INT_VEC(3)
-#define CORTEX_CORE0_IRQ		VIC3_INT_VEC(4)
-#define CORTEX_CORE1_IRQ		VIC3_INT_VEC(5)
-#define ETH_PMT_INTR_IRQ		VIC3_INT_VEC(6)
-#define I2S1_RX_IRQ			VIC3_INT_VEC(7)
-#define I2S1_TX_IRQ			VIC3_INT_VEC(8)
-#define USB_EHCI_IRQ			VIC3_INT_VEC(9)
-#define IPI00_IRQ			VIC3_INT_VEC(10)
-#define IPI01_IRQ			VIC3_INT_VEC(11)
-#define IPI02_IRQ			VIC3_INT_VEC(12)
-#define IPI03_IRQ			VIC3_INT_VEC(13)
-#define IPI04_IRQ			VIC3_INT_VEC(14)
-#define IPI05_IRQ			VIC3_INT_VEC(15)
-#define IPI06_IRQ			VIC3_INT_VEC(16)
-#define IPI10_IRQ			VIC3_INT_VEC(17)
-#define IPI11_IRQ			VIC3_INT_VEC(18)
-#define IPI12_IRQ			VIC3_INT_VEC(19)
-#define IPI13_IRQ			VIC3_INT_VEC(20)
-#define IPI14_IRQ			VIC3_INT_VEC(21)
-#define IPI15_IRQ			VIC3_INT_VEC(22)
-#define IPI16_IRQ			VIC3_INT_VEC(23)
-#define SHA1_IRQ			VIC3_INT_VEC(24)
-#define USB_OHCI_IRQ			VIC3_INT_VEC(25)
-#define IDC3_IRQ			VIC3_INT_VEC(26)
-#define UART2_IRQ			VIC3_INT_VEC(27)
-#define UART3_IRQ			VIC3_INT_VEC(28)
+#define USBVBUS_IRQ			VIC0_INT_VEC(0)
+#define VOUT_IRQ			VIC0_INT_VEC(1)
+#define VIN_IRQ				VIC0_INT_VEC(2)
+#define CODE_VDSP_0_IRQ			VIC0_INT_VEC(3)
+#define USBC_IRQ			VIC0_INT_VEC(4)
+#define USB_CHARGE_IRQ			VIC0_INT_VEC(5)
+#define PMU_IRQ				VIC0_INT_VEC(6)
+#define I2STX_IRQ			VIC0_INT_VEC(7)
+#define I2SRX_IRQ			VIC0_INT_VEC(8)
+#define UART0_IRQ			VIC0_INT_VEC(9)
+#define GPIO0_IRQ			VIC0_INT_VEC(10)
+#define GPIO1_IRQ			VIC0_INT_VEC(11)
+#define TIMER1_IRQ			VIC0_INT_VEC(12)
+#define TIMER2_IRQ			VIC0_INT_VEC(13)
+#define TIMER3_IRQ			VIC0_INT_VEC(14)
+#define DMA_IRQ				VIC0_INT_VEC(15)
+#define FIOCMD_IRQ			VIC0_INT_VEC(16)
+#define FIODMA_IRQ			VIC0_INT_VEC(17)
+#define SD_IRQ				VIC0_INT_VEC(18)
+#define IDC_IRQ				VIC0_INT_VEC(19)
+#define SSI_IRQ				VIC0_INT_VEC(20)
+#define WDT_IRQ				VIC0_INT_VEC(21)
+#define IRIF_IRQ			VIC0_INT_VEC(22)
+#define SD1CD_IRQ			VIC0_INT_VEC(23)
+#define SD0CD_IRQ			VIC0_INT_VEC(24)
+#define UART1_IRQ			VIC0_INT_VEC(25)
+#define SSI_SLAVE_IRQ			VIC0_INT_VEC(26)
+#define ETH_IRQ				VIC0_INT_VEC(27)
+#define IDSP_SOFT_IRQ			VIC0_INT_VEC(28)
+#define GPIO3_IRQ			VIC0_INT_VEC(29)
+#define GPIO2_IRQ			VIC0_INT_VEC(30)
+#define PMU1_IRQ			VIC0_INT_VEC(31)
+
+#define ROLLING_SHUTTER_IRQ		VIC1_INT_VEC(0)
+#define DMA_FIOS_IRQ			VIC1_INT_VEC(1)
+#define ADC_LEVEL_IRQ			VIC1_INT_VEC(2)
+#define IDSP_VIN_SOFT_IRQ		VIC1_INT_VEC(3)
+#define IDC2_IRQ			VIC1_INT_VEC(4)
+#define IDSP_LAST_PIXEL_IRQ		VIC1_INT_VEC(5)
+#define IDSP_VSYNC_IRQ			VIC1_INT_VEC(6)
+#define IDSP_SENSOR_VSYNC_IRQ		VIC1_INT_VEC(7)
+#define HDMI_IRQ			VIC1_INT_VEC(8)
+#define FIOS_ECC_IRQ			VIC1_INT_VEC(9)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(10)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(11)
+#define AES_IRQ				VIC1_INT_VEC(12)
+#define DES_IRQ				VIC1_INT_VEC(13)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(14)
+#define MD5_IRQ				VIC1_INT_VEC(15)
+#define GPIO4_IRQ			VIC1_INT_VEC(16)
+#define MOTOR_IRQ			VIC1_INT_VEC(17)
+#define GDMA_IRQ			VIC1_INT_VEC(18)
+#define L2CC_INTR1_IRQ			VIC1_INT_VEC(19)
+#define SD2_IRQ				VIC1_INT_VEC(20)
+#define SSI_MASTER_IRQ			VIC1_INT_VEC(21)
+#define CODE_VDSP_3_IRQ			VIC1_INT_VEC(22)
+#define CODE_VDSP_2_IRQ			VIC1_INT_VEC(23)
+#define CODE_VDSP_1_IRQ			VIC1_INT_VEC(24)
+#define L2CC_INTR_IRQ			VIC1_INT_VEC(25)
+#define IDSP_PROG_IRQ			VIC1_INT_VEC(26)
+#define TIMER4_IRQ			VIC1_INT_VEC(27)
+#define TIMER5_IRQ			VIC1_INT_VEC(28)
+#define TIMER6_IRQ			VIC1_INT_VEC(29)
+#define TIMER7_IRQ			VIC1_INT_VEC(30)
+#define TIMER8_IRQ			VIC1_INT_VEC(31)
+
+#define VDSP_PIP_SVSYNC_IRQ		VIC2_INT_VEC(0)
+#define IDSP_PIP_SVSYNC_IRQ		VIC2_INT_VEC(1)
+#define IDSP_PIP_PROG_IRQ		VIC2_INT_VEC(2)
+#define IDSP_PIP_LAST_PIXEL_IRQ		VIC2_INT_VEC(3)
+#define CORTEX_CORE0_IRQ		VIC2_INT_VEC(4)
+#define CORTEX_CORE1_IRQ		VIC2_INT_VEC(5)
+#define ETH_PMT_INTR_IRQ		VIC2_INT_VEC(6)
+#define I2S1_RX_IRQ			VIC2_INT_VEC(7)
+#define I2S1_TX_IRQ			VIC2_INT_VEC(8)
+#define USB_EHCI_IRQ			VIC2_INT_VEC(9)
+#define IPI00_IRQ			VIC2_INT_VEC(10)
+#define IPI01_IRQ			VIC2_INT_VEC(11)
+#define IPI02_IRQ			VIC2_INT_VEC(12)
+#define IPI03_IRQ			VIC2_INT_VEC(13)
+#define IPI04_IRQ			VIC2_INT_VEC(14)
+#define IPI05_IRQ			VIC2_INT_VEC(15)
+#define IPI06_IRQ			VIC2_INT_VEC(16)
+#define IPI10_IRQ			VIC2_INT_VEC(17)
+#define IPI11_IRQ			VIC2_INT_VEC(18)
+#define IPI12_IRQ			VIC2_INT_VEC(19)
+#define IPI13_IRQ			VIC2_INT_VEC(20)
+#define IPI14_IRQ			VIC2_INT_VEC(21)
+#define IPI15_IRQ			VIC2_INT_VEC(22)
+#define IPI16_IRQ			VIC2_INT_VEC(23)
+#define SHA1_IRQ			VIC2_INT_VEC(24)
+#define USB_OHCI_IRQ			VIC2_INT_VEC(25)
+#define IDC3_IRQ			VIC2_INT_VEC(26)
+#define UART2_IRQ			VIC2_INT_VEC(27)
+#define UART3_IRQ			VIC2_INT_VEC(28)
 
 /* ==========================================================================*/
 #elif (CHIP_REV == A8)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define ROLLING_SHUTTER_IRQ		VIC_INT_VEC(3)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define HIF_ARM1_IRQ			VIC_INT_VEC(5)
-#define HIF_ARM2_IRQ			VIC_INT_VEC(6)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SSI_IRQ				VIC_INT_VEC(20)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define CFCD1_IRQ			VIC_INT_VEC(23)
-#define SD1CD_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define SSI_SLAVE_IRQ			VIC_INT_VEC(26)
-#define ETH_IRQ				VIC_INT_VEC(27)
-#define IDSP_SOFT_IRQ			VIC_INT_VEC(28)
-#define ETH_POWER_IRQ			VIC_INT_VEC(29)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-#define CFCD2_IRQ			VIC_INT_VEC(31)
-
-#define DRAM_AXI_ERROR_IRQ		VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define SSI3_IRQ			VIC2_INT_VEC(3)
-#define IDC2_IRQ			VIC2_INT_VEC(4)
-#define IDSP_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_VSYNC_IRQ			VIC2_INT_VEC(6)
-#define IDSP_SENSOR_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define SSI2_IRQ			VIC2_INT_VEC(9)
-#define AES_IRQ				VIC2_INT_VEC(13)
-#define DES_IRQ				VIC2_INT_VEC(14)
-#define MS_IRQ				VIC2_INT_VEC(15)
-#define USB_EHCI_IRQ			VIC2_INT_VEC(16)
-#define MOTOR_IRQ			VIC2_INT_VEC(17)
-#define MD5_SHA1_IRQ			VIC2_INT_VEC(18)
-#define GPIO3_IRQ			VIC2_INT_VEC(19)
-#define GPIO4_IRQ			VIC2_INT_VEC(20)
-#define GPIO5_IRQ			VIC2_INT_VEC(21)
-#define SATA_IRQ			VIC2_INT_VEC(22)
-#define DRAM_ERROR_IRQ			VIC2_INT_VEC(23)
-#define SD2_IRQ				VIC2_INT_VEC(24)
-#define UART2_IRQ			VIC2_INT_VEC(25)
-#define UART3_IRQ			VIC2_INT_VEC(26)
-
-#define GSSI_IRQ			VIC3_INT_VEC(0)
-#define SSI4_IRQ			VIC3_INT_VEC(1)
-#define PMU_IRQ				VIC3_INT_VEC(2)
-#define SD2CD_IRQ			VIC3_INT_VEC(3)
-#define CORTEX_CORE0_IRQ		VIC3_INT_VEC(4)
-#define CORTEX_CORE1_IRQ		VIC3_INT_VEC(5)
-#define TS_CH1_RX_IRQ			VIC3_INT_VEC(6)
-#define TS_CH0_RX_IRQ			VIC3_INT_VEC(7)
-#define TS_CH1_TX_IRQ			VIC3_INT_VEC(8)
-#define TS_CH0_TX_IRQ			VIC3_INT_VEC(9)
-#define AXI_SOFT_IRQ(x)			VIC3_INT_VEC((x) + 10)	/* 0 <= x <= 13 */
-#define CORTEX_WDT_IRQ			VIC3_INT_VEC(24)
-#define USB_OHCI_IRQ			VIC3_INT_VEC(25)
-#define SPDIF_IRQ			VIC3_INT_VEC(26)
-#define SSI_AHB_IRQ			VIC3_INT_VEC(27)
-#define IDC3_IRQ			VIC3_INT_VEC(28)
+#define USBVBUS_IRQ			VIC0_INT_VEC(0)
+#define ROLLING_SHUTTER_IRQ		VIC0_INT_VEC(3)
+#define USBC_IRQ			VIC0_INT_VEC(4)
+#define HIF_ARM1_IRQ			VIC0_INT_VEC(5)
+#define HIF_ARM2_IRQ			VIC0_INT_VEC(6)
+#define I2STX_IRQ			VIC0_INT_VEC(7)
+#define I2SRX_IRQ			VIC0_INT_VEC(8)
+#define UART0_IRQ			VIC0_INT_VEC(9)
+#define GPIO0_IRQ			VIC0_INT_VEC(10)
+#define GPIO1_IRQ			VIC0_INT_VEC(11)
+#define DMA_IRQ				VIC0_INT_VEC(15)
+#define FIOCMD_IRQ			VIC0_INT_VEC(16)
+#define FIODMA_IRQ			VIC0_INT_VEC(17)
+#define SD_IRQ				VIC0_INT_VEC(18)
+#define IDC_IRQ				VIC0_INT_VEC(19)
+#define SSI_IRQ				VIC0_INT_VEC(20)
+#define IRIF_IRQ			VIC0_INT_VEC(22)
+#define CFCD1_IRQ			VIC0_INT_VEC(23)
+#define SD1CD_IRQ			VIC0_INT_VEC(24)
+#define UART1_IRQ			VIC0_INT_VEC(25)
+#define SSI_SLAVE_IRQ			VIC0_INT_VEC(26)
+#define ETH_IRQ				VIC0_INT_VEC(27)
+#define IDSP_SOFT_IRQ			VIC0_INT_VEC(28)
+#define ETH_POWER_IRQ			VIC0_INT_VEC(29)
+#define GPIO2_IRQ			VIC0_INT_VEC(30)
+#define CFCD2_IRQ			VIC0_INT_VEC(31)
+
+#define DRAM_AXI_ERROR_IRQ		VIC1_INT_VEC(0)
+#define DMA_FIOS_IRQ			VIC1_INT_VEC(1)
+#define ADC_LEVEL_IRQ			VIC1_INT_VEC(2)
+#define SSI3_IRQ			VIC1_INT_VEC(3)
+#define IDC2_IRQ			VIC1_INT_VEC(4)
+#define IDSP_LAST_PIXEL_IRQ		VIC1_INT_VEC(5)
+#define IDSP_VSYNC_IRQ			VIC1_INT_VEC(6)
+#define IDSP_SENSOR_VSYNC_IRQ		VIC1_INT_VEC(7)
+#define HDMI_IRQ			VIC1_INT_VEC(8)
+#define SSI2_IRQ			VIC1_INT_VEC(9)
+#define AES_IRQ				VIC1_INT_VEC(13)
+#define DES_IRQ				VIC1_INT_VEC(14)
+#define MS_IRQ				VIC1_INT_VEC(15)
+#define USB_EHCI_IRQ			VIC1_INT_VEC(16)
+#define MOTOR_IRQ			VIC1_INT_VEC(17)
+#define MD5_SHA1_IRQ			VIC1_INT_VEC(18)
+#define GPIO3_IRQ			VIC1_INT_VEC(19)
+#define GPIO4_IRQ			VIC1_INT_VEC(20)
+#define GPIO5_IRQ			VIC1_INT_VEC(21)
+#define SATA_IRQ			VIC1_INT_VEC(22)
+#define DRAM_ERROR_IRQ			VIC1_INT_VEC(23)
+#define SD2_IRQ				VIC1_INT_VEC(24)
+#define UART2_IRQ			VIC1_INT_VEC(25)
+#define UART3_IRQ			VIC1_INT_VEC(26)
+
+#define GSSI_IRQ			VIC2_INT_VEC(0)
+#define SSI4_IRQ			VIC2_INT_VEC(1)
+#define PMU_IRQ				VIC2_INT_VEC(2)
+#define SD2CD_IRQ			VIC2_INT_VEC(3)
+#define CORTEX_CORE0_IRQ		VIC2_INT_VEC(4)
+#define CORTEX_CORE1_IRQ		VIC2_INT_VEC(5)
+#define TS_CH1_RX_IRQ			VIC2_INT_VEC(6)
+#define TS_CH0_RX_IRQ			VIC2_INT_VEC(7)
+#define TS_CH1_TX_IRQ			VIC2_INT_VEC(8)
+#define TS_CH0_TX_IRQ			VIC2_INT_VEC(9)
+#define AXI_SOFT_IRQ(x)			VIC2_INT_VEC((x) + 10)	/* 0 <= x <= 13 */
+#define CORTEX_WDT_IRQ			VIC2_INT_VEC(24)
+#define USB_OHCI_IRQ			VIC2_INT_VEC(25)
+#define SPDIF_IRQ			VIC2_INT_VEC(26)
+#define SSI_AHB_IRQ			VIC2_INT_VEC(27)
+#define IDC3_IRQ			VIC2_INT_VEC(28)
 
 #if defined(CONFIG_ARM_GIC)
-#define VOUT_IRQ			VIC4_INT_VEC(0)
-#define VIN_IRQ				VIC4_INT_VEC(1)
-#define TIMER1_IRQ			VIC4_INT_VEC(2)
-#define TIMER2_IRQ			VIC4_INT_VEC(3)
-#define TIMER3_IRQ			VIC4_INT_VEC(4)
-#define WDT_IRQ				VIC4_INT_VEC(5)
-#define VOUT_TV_SYNC_IRQ		VIC4_INT_VEC(6)
-#define VOUT_LCD_SYNC_IRQ		VIC4_INT_VEC(7)
-#define ORC_VOUT0_IRQ			VIC4_INT_VEC(8)
-#define TIMER4_IRQ			VIC4_INT_VEC(9)
-#define TIMER5_IRQ			VIC4_INT_VEC(10)
-#define TIMER6_IRQ			VIC4_INT_VEC(11)
-#define TIMER7_IRQ			VIC4_INT_VEC(12)
-#define TIMER8_IRQ			VIC4_INT_VEC(13)
-#define CODING_ORC0_IRQ			VIC4_INT_VEC(14)
-#define CODING_ORC1_IRQ			VIC4_INT_VEC(15)
-#define CODING_ORC2_IRQ			VIC4_INT_VEC(16)
-#define CODING_ORC3_IRQ			VIC4_INT_VEC(17)
+#define VOUT_IRQ			VIC3_INT_VEC(0)
+#define VIN_IRQ				VIC3_INT_VEC(1)
+#define TIMER1_IRQ			VIC3_INT_VEC(2)
+#define TIMER2_IRQ			VIC3_INT_VEC(3)
+#define TIMER3_IRQ			VIC3_INT_VEC(4)
+#define WDT_IRQ				VIC3_INT_VEC(5)
+#define VOUT_TV_SYNC_IRQ		VIC3_INT_VEC(6)
+#define VOUT_LCD_SYNC_IRQ		VIC3_INT_VEC(7)
+#define ORC_VOUT0_IRQ			VIC3_INT_VEC(8)
+#define TIMER4_IRQ			VIC3_INT_VEC(9)
+#define TIMER5_IRQ			VIC3_INT_VEC(10)
+#define TIMER6_IRQ			VIC3_INT_VEC(11)
+#define TIMER7_IRQ			VIC3_INT_VEC(12)
+#define TIMER8_IRQ			VIC3_INT_VEC(13)
+#define CODING_ORC0_IRQ			VIC3_INT_VEC(14)
+#define CODING_ORC1_IRQ			VIC3_INT_VEC(15)
+#define CODING_ORC2_IRQ			VIC3_INT_VEC(16)
+#define CODING_ORC3_IRQ			VIC3_INT_VEC(17)
 #else
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(12)
-#define TIMER4_IRQ			VIC2_INT_VEC(27)
-#define TIMER5_IRQ			VIC2_INT_VEC(28)
-#define TIMER6_IRQ			VIC2_INT_VEC(29)
-#define TIMER7_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
-#define CODING_ORC0_IRQ			VIC3_INT_VEC(28)
-#define CODING_ORC1_IRQ			VIC3_INT_VEC(29)
-#define CODING_ORC2_IRQ			VIC3_INT_VEC(30)
-#define CODING_ORC3_IRQ			VIC3_INT_VEC(31)
+#define VOUT_IRQ			VIC0_INT_VEC(1)
+#define VIN_IRQ				VIC0_INT_VEC(2)
+#define TIMER1_IRQ			VIC0_INT_VEC(12)
+#define TIMER2_IRQ			VIC0_INT_VEC(13)
+#define TIMER3_IRQ			VIC0_INT_VEC(14)
+#define WDT_IRQ				VIC0_INT_VEC(21)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(10)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(11)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(12)
+#define TIMER4_IRQ			VIC1_INT_VEC(27)
+#define TIMER5_IRQ			VIC1_INT_VEC(28)
+#define TIMER6_IRQ			VIC1_INT_VEC(29)
+#define TIMER7_IRQ			VIC1_INT_VEC(30)
+#define TIMER8_IRQ			VIC1_INT_VEC(31)
+#define CODING_ORC0_IRQ			VIC2_INT_VEC(28)
+#define CODING_ORC1_IRQ			VIC2_INT_VEC(29)
+#define CODING_ORC2_IRQ			VIC2_INT_VEC(30)
+#define CODING_ORC3_IRQ			VIC2_INT_VEC(31)
 #endif
 
 #define GLOBAL_TIMER_IRQ		PPI_INT_VEC(27)
@@ -621,217 +625,302 @@
 
 /* ==========================================================================*/
 #elif (CHIP_REV == S2L)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define CODE_VDSP_0_IRQ			VIC_INT_VEC(3)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define USB_CHARGE_IRQ			VIC_INT_VEC(5)
-#define SD2CD_IRQ			VIC_INT_VEC(6)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SD3_IRQ				VIC_INT_VEC(20)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define SD1CD_IRQ			VIC_INT_VEC(23)
-#define SD0CD_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define MOTOR_IRQ			VIC_INT_VEC(26)
-#define ETH_IRQ				VIC_INT_VEC(27)
-#define USB_CONNECT_CHANGE_IRQ		VIC_INT_VEC(28)
-#define GPIO3_IRQ			VIC_INT_VEC(29)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-
-#define ETH_PMT_IRQ			VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define SSI_MASTER0_IRQ			VIC2_INT_VEC(3)
-#define IDC3_IRQ			VIC2_INT_VEC(4)
-#define SSI_MASTER1_IRQ			VIC2_INT_VEC(5)
-#define SSI_SLAVE_IRQ			VIC2_INT_VEC(6)
-#define USB_EHCI_IRQ			VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define FIOS_ECC_IRQ			VIC2_INT_VEC(9)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define USB_OHCI_IRQ			VIC2_INT_VEC(12)
-#define NOR_SPI				VIC2_INT_VEC(13)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(14)
-#define GDMA_IRQ			VIC2_INT_VEC(18)
-#define IDC2_IRQ			VIC2_INT_VEC(19)
-#define SD2_IRQ				VIC2_INT_VEC(20)
-#define IDSP_PIP_VSYNC_IRQ		VIC2_INT_VEC(21)
-#define IDSP_PIP_SOF_IRQ		VIC2_INT_VEC(22)
-#define IDSP_PIP_MVSYNC_IRQ		VIC2_INT_VEC(23)
-#define IDSP_PIP_LAST_PIXEL_IRQ		VIC2_INT_VEC(24)
-#define IDSP_PIP_DVSYNC_IRQ		VIC2_INT_VEC(25)
-#define VDSP_PIP_CODING_IRQ		VIC2_INT_VEC(26)
-#define TIMER4_IRQ			VIC2_INT_VEC(27)
-#define TIMER5_IRQ			VIC2_INT_VEC(28)
-#define TIMER6_IRQ			VIC2_INT_VEC(29)
-#define TIMER7_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
-
-#define IDSP_VIN_MVSYNC_IRQ		VIC3_INT_VEC(0)
-#define IDSP_VIN_VSYNC_IRQ		VIC3_INT_VEC(1)
-#define IDSP_VIN_SOF_IRQ		VIC3_INT_VEC(2)
-#define IDSP_VIN_DVSYNC_IRQ		VIC3_INT_VEC(3)
-#define IDSP_VIN_LAST_PIXEL_IRQ		VIC3_INT_VEC(4)
-#define L2CC_INTR_IRQ			VIC3_INT_VEC(21)
-#define MD5_IRQ				VIC3_INT_VEC(22)
-#define DES_IRQ				VIC3_INT_VEC(23)
-#define AES_IRQ				VIC3_INT_VEC(24)
-#define SHA1_IRQ			VIC3_INT_VEC(25)
-#define USB_DIGITAL_ID_CHANGE_IRQ	VIC3_INT_VEC(27)
-#define PMU_IRQ				VIC3_INT_VEC(28)
-#define L2CC_DECERR_IRQ			VIC3_INT_VEC(29)
-#define L2CC_SLVERR_IRQ			VIC3_INT_VEC(30)
-#define L2CC_ECNTR_IRQ			VIC3_INT_VEC(31)
+#define USBVBUS_IRQ			VIC0_INT_VEC(0)
+#define VOUT_IRQ			VIC0_INT_VEC(1)
+#define VIN_IRQ				VIC0_INT_VEC(2)
+#define CODE_VDSP_0_IRQ			VIC0_INT_VEC(3)
+#define USBC_IRQ			VIC0_INT_VEC(4)
+#define USB_CHARGE_IRQ			VIC0_INT_VEC(5)
+#define SD2CD_IRQ			VIC0_INT_VEC(6)
+#define I2STX_IRQ			VIC0_INT_VEC(7)
+#define I2SRX_IRQ			VIC0_INT_VEC(8)
+#define UART0_IRQ			VIC0_INT_VEC(9)
+#define GPIO0_IRQ			VIC0_INT_VEC(10)
+#define GPIO1_IRQ			VIC0_INT_VEC(11)
+#define TIMER1_IRQ			VIC0_INT_VEC(12)
+#define TIMER2_IRQ			VIC0_INT_VEC(13)
+#define TIMER3_IRQ			VIC0_INT_VEC(14)
+#define DMA_IRQ				VIC0_INT_VEC(15)
+#define FIOCMD_IRQ			VIC0_INT_VEC(16)
+#define FIODMA_IRQ			VIC0_INT_VEC(17)
+#define SD_IRQ				VIC0_INT_VEC(18)
+#define IDC_IRQ				VIC0_INT_VEC(19)
+#define SD3_IRQ				VIC0_INT_VEC(20)
+#define WDT_IRQ				VIC0_INT_VEC(21)
+#define IRIF_IRQ			VIC0_INT_VEC(22)
+#define SD1CD_IRQ			VIC0_INT_VEC(23)
+#define SD0CD_IRQ			VIC0_INT_VEC(24)
+#define UART1_IRQ			VIC0_INT_VEC(25)
+#define MOTOR_IRQ			VIC0_INT_VEC(26)
+#define ETH_IRQ				VIC0_INT_VEC(27)
+#define USB_CONNECT_CHANGE_IRQ		VIC0_INT_VEC(28)
+#define GPIO3_IRQ			VIC0_INT_VEC(29)
+#define GPIO2_IRQ			VIC0_INT_VEC(30)
+
+#define ETH_PMT_IRQ			VIC1_INT_VEC(0)
+#define DMA_FIOS_IRQ			VIC1_INT_VEC(1)
+#define ADC_LEVEL_IRQ			VIC1_INT_VEC(2)
+#define SSI_MASTER0_IRQ			VIC1_INT_VEC(3)
+#define IDC3_IRQ			VIC1_INT_VEC(4)
+#define SSI_MASTER1_IRQ			VIC1_INT_VEC(5)
+#define SSI_SLAVE_IRQ			VIC1_INT_VEC(6)
+#define USB_EHCI_IRQ			VIC1_INT_VEC(7)
+#define HDMI_IRQ			VIC1_INT_VEC(8)
+#define FIOS_ECC_IRQ			VIC1_INT_VEC(9)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(10)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(11)
+#define USB_OHCI_IRQ			VIC1_INT_VEC(12)
+#define NOR_SPI				VIC1_INT_VEC(13)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(14)
+#define GDMA_IRQ			VIC1_INT_VEC(18)
+#define IDC2_IRQ			VIC1_INT_VEC(19)
+#define SD2_IRQ				VIC1_INT_VEC(20)
+#define IDSP_PIP_VSYNC_IRQ		VIC1_INT_VEC(21)
+#define IDSP_PIP_SOF_IRQ		VIC1_INT_VEC(22)
+#define IDSP_PIP_MVSYNC_IRQ		VIC1_INT_VEC(23)
+#define IDSP_PIP_LAST_PIXEL_IRQ		VIC1_INT_VEC(24)
+#define IDSP_PIP_DVSYNC_IRQ		VIC1_INT_VEC(25)
+#define VDSP_PIP_CODING_IRQ		VIC1_INT_VEC(26)
+#define TIMER4_IRQ			VIC1_INT_VEC(27)
+#define TIMER5_IRQ			VIC1_INT_VEC(28)
+#define TIMER6_IRQ			VIC1_INT_VEC(29)
+#define TIMER7_IRQ			VIC1_INT_VEC(30)
+#define TIMER8_IRQ			VIC1_INT_VEC(31)
+
+#define IDSP_VIN_MVSYNC_IRQ		VIC2_INT_VEC(0)
+#define IDSP_VIN_VSYNC_IRQ		VIC2_INT_VEC(1)
+#define IDSP_VIN_SOF_IRQ		VIC2_INT_VEC(2)
+#define IDSP_VIN_DVSYNC_IRQ		VIC2_INT_VEC(3)
+#define IDSP_VIN_LAST_PIXEL_IRQ		VIC2_INT_VEC(4)
+#define L2CC_INTR_IRQ			VIC2_INT_VEC(21)
+#define MD5_IRQ				VIC2_INT_VEC(22)
+#define DES_IRQ				VIC2_INT_VEC(23)
+#define AES_IRQ				VIC2_INT_VEC(24)
+#define SHA1_IRQ			VIC2_INT_VEC(25)
+#define USB_DIGITAL_ID_CHANGE_IRQ	VIC2_INT_VEC(27)
+#define PMU_IRQ				VIC2_INT_VEC(28)
+#define L2CC_DECERR_IRQ			VIC2_INT_VEC(29)
+#define L2CC_SLVERR_IRQ			VIC2_INT_VEC(30)
+#define L2CC_ECNTR_IRQ			VIC2_INT_VEC(31)
 
 /* ==========================================================================*/
 #elif (CHIP_REV == S3)
-#define IPI00_IRQ			VIC_INT_VEC(0)
-#define IPI01_IRQ			VIC_INT_VEC(1)
-#define IPI02_IRQ			VIC_INT_VEC(2)
-#define IPI03_IRQ			VIC_INT_VEC(3)
-#define IPI04_IRQ			VIC_INT_VEC(4)
-#define IPI05_IRQ			VIC_INT_VEC(5)
-#define IPI06_IRQ			VIC_INT_VEC(6)
-#define TIMER1_IRQ			VIC_INT_VEC(7)
-#define TIMER2_IRQ			VIC_INT_VEC(8)
-#define TIMER3_IRQ			VIC_INT_VEC(9)
-#define TIMER4_IRQ			VIC_INT_VEC(10)
-#define TIMER5_IRQ			VIC_INT_VEC(11)
-#define TIMER6_IRQ			VIC_INT_VEC(12)
-#define TIMER7_IRQ			VIC_INT_VEC(13)
-#define TIMER8_IRQ			VIC_INT_VEC(14)
-#define PMU_IRQ				VIC_INT_VEC(15)
-#define IPI10_IRQ			VIC_INT_VEC(16)
-#define IPI11_IRQ			VIC_INT_VEC(17)
-#define IPI12_IRQ			VIC_INT_VEC(18)
-#define IPI13_IRQ			VIC_INT_VEC(19)
-#define IPI14_IRQ			VIC_INT_VEC(20)
-#define IPI15_IRQ			VIC_INT_VEC(21)
-#define IPI16_IRQ			VIC_INT_VEC(22)
-#define TIMER11_IRQ			VIC_INT_VEC(23)
-#define TIMER12_IRQ			VIC_INT_VEC(24)
-#define TIMER13_IRQ			VIC_INT_VEC(25)
-#define TIMER14_IRQ			VIC_INT_VEC(26)
-#define TIMER15_IRQ			VIC_INT_VEC(27)
-#define TIMER16_IRQ			VIC_INT_VEC(28)
-#define TIMER17_IRQ			VIC_INT_VEC(29)
-#define TIMER18_IRQ			VIC_INT_VEC(30)
-#define PMU1_IRQ			VIC_INT_VEC(31)
-
-#define IDSP_VIN_STAT_IRQ		VIC2_INT_VEC(0)
-#define IDSP_VIN_MVSYNC_IRQ		VIC2_INT_VEC(1)
-#define IDSP_VIN_VSYNC_IRQ		VIC2_INT_VEC(2)
-#define IDSP_VIN_SOF_IRQ		VIC2_INT_VEC(3)
-#define IDSP_VIN_DVSYNC_IRQ		VIC2_INT_VEC(4)
-#define IDSP_VIN_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_PIP_STAT_IRQ		VIC2_INT_VEC(6)
-#define IDSP_PIP_MVSYNC_IRQ		VIC2_INT_VEC(7)
-#define IDSP_PIP_VSYNC_IRQ		VIC2_INT_VEC(8)
-#define IDSP_PIP_SOF_IRQ		VIC2_INT_VEC(9)
-#define IDSP_PIP_DVSYNC_IRQ		VIC2_INT_VEC(10)
-#define IDSP_PIP_LAST_PIXEL_IRQ		VIC2_INT_VEC(11)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(12)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(13)
-#define CODE_VDSP_0_IRQ			VIC2_INT_VEC(14)
-#define CODE_VDSP_1_IRQ			VIC2_INT_VEC(15)
-#define CODE_VDSP_2_IRQ			VIC2_INT_VEC(16)
-#define CODE_VDSP_3_IRQ			VIC2_INT_VEC(17)
-#define CODE_VDSP_4_IRQ			VIC2_INT_VEC(18)
-#define CODE_VDSP_5_IRQ			VIC2_INT_VEC(19)
-#define CODE_VDSP_6_IRQ			VIC2_INT_VEC(20)
-#define CODE_VDSP_7_IRQ			VIC2_INT_VEC(21)
-#define VIN_IRQ				VIC2_INT_VEC(22)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(23)
-#define VOUT_IRQ			VIC2_INT_VEC(24)
-#define VDSP_ORC_BKPT_IRQ		VIC2_INT_VEC(25)
-#define VDSP_EORC0_BKPT_IRQ		VIC2_INT_VEC(26)
-#define VDSP_DORC_BRPT_IRQ		VIC2_INT_VEC(27)
-#define VDSP_PIP_CODING_IRQ		VIC2_INT_VEC(28)
-#define FDET_IRQ			VIC2_INT_VEC(29)
-#define TIMER10_IRQ			VIC2_INT_VEC(30)
-#define TIMER9_IRQ			VIC2_INT_VEC(31)
-
-#define CANC_IRQ			VIC3_INT_VEC(0)
-#define ETH_IRQ				VIC3_INT_VEC(1)
-#define USB_EHCI_IRQ			VIC3_INT_VEC(2)
-#define USB_OHCI_IRQ			VIC3_INT_VEC(3)
-#define USBC_IRQ			VIC3_INT_VEC(4)
-#define DMA_IRQ				VIC3_INT_VEC(5)
-#define DMA_FIOS_IRQ			VIC3_INT_VEC(6)
-#define FIOS_ECC_IRQ			VIC3_INT_VEC(7)
-#define FIOCMD_IRQ			VIC3_INT_VEC(8)
-#define FIODMA_IRQ			VIC3_INT_VEC(9)
-#define GDMA_IRQ			VIC3_INT_VEC(10)
-#define SD3_IRQ				VIC3_INT_VEC(11)
-#define SD2_IRQ				VIC3_INT_VEC(12)
-#define SD_IRQ				VIC3_INT_VEC(13)
-#define NOR_SPI				VIC3_INT_VEC(14)
-#define SSI_MASTER1_IRQ			VIC3_INT_VEC(15)
-#define SSI_MASTER0_IRQ			VIC3_INT_VEC(16)
-#define SSI_SLAVE_IRQ			VIC3_INT_VEC(17)
-#define UART1_IRQ			VIC3_INT_VEC(18)
-#define IDC3_IRQ			VIC3_INT_VEC(19)
-#define IDC2_IRQ			VIC3_INT_VEC(20)
-#define IDC_IRQ				VIC3_INT_VEC(21)
-#define IRIF_IRQ			VIC3_INT_VEC(22)
-#define I2STX_IRQ			VIC3_INT_VEC(23)
-#define I2SRX_IRQ			VIC3_INT_VEC(24)
-#define IDC_SLAVE_IRQ			VIC3_INT_VEC(25)
-#define HIF_ARM2_IRQ			VIC3_INT_VEC(26)
-#define HIF_ARM1_IRQ			VIC3_INT_VEC(27)
-#define TS_CH1_RX_IRQ			VIC3_INT_VEC(28)
-#define TS_CH0_RX_IRQ			VIC3_INT_VEC(29)
-#define TS_CH1_TX_IRQ			VIC3_INT_VEC(30)
-#define TS_CH0_TX_IRQ			VIC3_INT_VEC(31)
-
-#define USBVBUS_IRQ			VIC4_INT_VEC(0)
-#define USB_DIGITAL_ID_CHANGE_IRQ	VIC4_INT_VEC(1)
-#define USB_CONNECT_CHANGE_IRQ		VIC4_INT_VEC(2)
-#define USB_CHARGE_IRQ			VIC4_INT_VEC(3)
-#define SD2CD_IRQ			VIC4_INT_VEC(4)
-#define SD1CD_IRQ			VIC4_INT_VEC(5)
-#define SD0CD_IRQ			VIC4_INT_VEC(6)
-#define ADC_LEVEL_IRQ			VIC4_INT_VEC(7)
-#define HDMI_IRQ			VIC4_INT_VEC(8)
-#define WDT_IRQ				VIC4_INT_VEC(9)
-#define SLIM_IRQ			VIC4_INT_VEC(10)
-#define ETH_PMT_IRQ			VIC4_INT_VEC(11)
-#define UART0_IRQ			VIC4_INT_VEC(12)
-#define MOTOR_IRQ			VIC4_INT_VEC(13)
-#define SHA1_IRQ			VIC4_INT_VEC(14)
-#define AES_IRQ				VIC4_INT_VEC(15)
-#define DES_IRQ				VIC4_INT_VEC(16)
-#define MD5_IRQ				VIC4_INT_VEC(17)
-#define L2CC_INTR_IRQ			VIC4_INT_VEC(18)
-#define L2CC_INTR1_IRQ			VIC4_INT_VEC(19)
-#define AXI_SWI_IRQ			VIC4_INT_VEC(20)
-#define AXI_SWI1_IRQ			VIC4_INT_VEC(21)
-#define GPIO6_IRQ			VIC4_INT_VEC(22)
-#define GPIO5_IRQ			VIC4_INT_VEC(23)
-#define GPIO4_IRQ			VIC4_INT_VEC(24)
-#define GPIO3_IRQ			VIC4_INT_VEC(25)
-#define GPIO2_IRQ			VIC4_INT_VEC(26)
-#define GPIO1_IRQ			VIC4_INT_VEC(27)
-#define GPIO0_IRQ			VIC4_INT_VEC(28)
-#define DMIC_IRQ			VIC4_INT_VEC(29)
-#define TIMER20_IRQ			VIC4_INT_VEC(30)
-#define TIMER19_IRQ			VIC4_INT_VEC(31)
+#define IPI00_IRQ			VIC0_INT_VEC(0)
+#define IPI01_IRQ			VIC0_INT_VEC(1)
+#define IPI02_IRQ			VIC0_INT_VEC(2)
+#define IPI03_IRQ			VIC0_INT_VEC(3)
+#define IPI04_IRQ			VIC0_INT_VEC(4)
+#define IPI05_IRQ			VIC0_INT_VEC(5)
+#define IPI06_IRQ			VIC0_INT_VEC(6)
+#define TIMER1_IRQ			VIC0_INT_VEC(7)
+#define TIMER2_IRQ			VIC0_INT_VEC(8)
+#define TIMER3_IRQ			VIC0_INT_VEC(9)
+#define TIMER4_IRQ			VIC0_INT_VEC(10)
+#define TIMER5_IRQ			VIC0_INT_VEC(11)
+#define TIMER6_IRQ			VIC0_INT_VEC(12)
+#define TIMER7_IRQ			VIC0_INT_VEC(13)
+#define TIMER8_IRQ			VIC0_INT_VEC(14)
+#define PMU_IRQ				VIC0_INT_VEC(15)
+#define IPI10_IRQ			VIC0_INT_VEC(16)
+#define IPI11_IRQ			VIC0_INT_VEC(17)
+#define IPI12_IRQ			VIC0_INT_VEC(18)
+#define IPI13_IRQ			VIC0_INT_VEC(19)
+#define IPI14_IRQ			VIC0_INT_VEC(20)
+#define IPI15_IRQ			VIC0_INT_VEC(21)
+#define IPI16_IRQ			VIC0_INT_VEC(22)
+#define TIMER11_IRQ			VIC0_INT_VEC(23)
+#define TIMER12_IRQ			VIC0_INT_VEC(24)
+#define TIMER13_IRQ			VIC0_INT_VEC(25)
+#define TIMER14_IRQ			VIC0_INT_VEC(26)
+#define TIMER15_IRQ			VIC0_INT_VEC(27)
+#define TIMER16_IRQ			VIC0_INT_VEC(28)
+#define TIMER17_IRQ			VIC0_INT_VEC(29)
+#define TIMER18_IRQ			VIC0_INT_VEC(30)
+#define PMU1_IRQ			VIC0_INT_VEC(31)
+
+#define IDSP_VIN_STAT_IRQ		VIC1_INT_VEC(0)
+#define IDSP_VIN_MVSYNC_IRQ		VIC1_INT_VEC(1)
+#define IDSP_VIN_VSYNC_IRQ		VIC1_INT_VEC(2)
+#define IDSP_VIN_SOF_IRQ		VIC1_INT_VEC(3)
+#define IDSP_VIN_DVSYNC_IRQ		VIC1_INT_VEC(4)
+#define IDSP_VIN_LAST_PIXEL_IRQ		VIC1_INT_VEC(5)
+#define IDSP_PIP_STAT_IRQ		VIC1_INT_VEC(6)
+#define IDSP_PIP_MVSYNC_IRQ		VIC1_INT_VEC(7)
+#define IDSP_PIP_VSYNC_IRQ		VIC1_INT_VEC(8)
+#define IDSP_PIP_SOF_IRQ		VIC1_INT_VEC(9)
+#define IDSP_PIP_DVSYNC_IRQ		VIC1_INT_VEC(10)
+#define IDSP_PIP_LAST_PIXEL_IRQ		VIC1_INT_VEC(11)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(12)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(13)
+#define CODE_VDSP_0_IRQ			VIC1_INT_VEC(14)
+#define CODE_VDSP_1_IRQ			VIC1_INT_VEC(15)
+#define CODE_VDSP_2_IRQ			VIC1_INT_VEC(16)
+#define CODE_VDSP_3_IRQ			VIC1_INT_VEC(17)
+#define CODE_VDSP_4_IRQ			VIC1_INT_VEC(18)
+#define CODE_VDSP_5_IRQ			VIC1_INT_VEC(19)
+#define CODE_VDSP_6_IRQ			VIC1_INT_VEC(20)
+#define CODE_VDSP_7_IRQ			VIC1_INT_VEC(21)
+#define VIN_IRQ				VIC1_INT_VEC(22)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(23)
+#define VOUT_IRQ			VIC1_INT_VEC(24)
+#define VDSP_ORC_BKPT_IRQ		VIC1_INT_VEC(25)
+#define VDSP_EORC0_BKPT_IRQ		VIC1_INT_VEC(26)
+#define VDSP_DORC_BRPT_IRQ		VIC1_INT_VEC(27)
+#define VDSP_PIP_CODING_IRQ		VIC1_INT_VEC(28)
+#define FDET_IRQ			VIC1_INT_VEC(29)
+#define TIMER10_IRQ			VIC1_INT_VEC(30)
+#define TIMER9_IRQ			VIC1_INT_VEC(31)
+
+#define CANC_IRQ			VIC2_INT_VEC(0)
+#define ETH_IRQ				VIC2_INT_VEC(1)
+#define USB_EHCI_IRQ			VIC2_INT_VEC(2)
+#define USB_OHCI_IRQ			VIC2_INT_VEC(3)
+#define USBC_IRQ			VIC2_INT_VEC(4)
+#define DMA_IRQ				VIC2_INT_VEC(5)
+#define DMA_FIOS_IRQ			VIC2_INT_VEC(6)
+#define FIOS_ECC_IRQ			VIC2_INT_VEC(7)
+#define FIOCMD_IRQ			VIC2_INT_VEC(8)
+#define FIODMA_IRQ			VIC2_INT_VEC(9)
+#define GDMA_IRQ			VIC2_INT_VEC(10)
+#define SD3_IRQ				VIC2_INT_VEC(11)
+#define SD2_IRQ				VIC2_INT_VEC(12)
+#define SD_IRQ				VIC2_INT_VEC(13)
+#define NOR_SPI				VIC2_INT_VEC(14)
+#define SSI_MASTER1_IRQ			VIC2_INT_VEC(15)
+#define SSI_MASTER0_IRQ			VIC2_INT_VEC(16)
+#define SSI_SLAVE_IRQ			VIC2_INT_VEC(17)
+#define UART1_IRQ			VIC2_INT_VEC(18)
+#define IDC3_IRQ			VIC2_INT_VEC(19)
+#define IDC2_IRQ			VIC2_INT_VEC(20)
+#define IDC_IRQ				VIC2_INT_VEC(21)
+#define IRIF_IRQ			VIC2_INT_VEC(22)
+#define I2STX_IRQ			VIC2_INT_VEC(23)
+#define I2SRX_IRQ			VIC2_INT_VEC(24)
+#define IDC_SLAVE_IRQ			VIC2_INT_VEC(25)
+#define HIF_ARM2_IRQ			VIC2_INT_VEC(26)
+#define HIF_ARM1_IRQ			VIC2_INT_VEC(27)
+#define TS_CH1_RX_IRQ			VIC2_INT_VEC(28)
+#define TS_CH0_RX_IRQ			VIC2_INT_VEC(29)
+#define TS_CH1_TX_IRQ			VIC2_INT_VEC(30)
+#define TS_CH0_TX_IRQ			VIC2_INT_VEC(31)
+
+#define USBVBUS_IRQ			VIC3_INT_VEC(0)
+#define USB_DIGITAL_ID_CHANGE_IRQ	VIC3_INT_VEC(1)
+#define USB_CONNECT_CHANGE_IRQ		VIC3_INT_VEC(2)
+#define USB_CHARGE_IRQ			VIC3_INT_VEC(3)
+#define SD2CD_IRQ			VIC3_INT_VEC(4)
+#define SD1CD_IRQ			VIC3_INT_VEC(5)
+#define SD0CD_IRQ			VIC3_INT_VEC(6)
+#define ADC_LEVEL_IRQ			VIC3_INT_VEC(7)
+#define HDMI_IRQ			VIC3_INT_VEC(8)
+#define WDT_IRQ				VIC3_INT_VEC(9)
+#define SLIM_IRQ			VIC3_INT_VEC(10)
+#define ETH_PMT_IRQ			VIC3_INT_VEC(11)
+#define UART0_IRQ			VIC3_INT_VEC(12)
+#define MOTOR_IRQ			VIC3_INT_VEC(13)
+#define SHA1_IRQ			VIC3_INT_VEC(14)
+#define AES_IRQ				VIC3_INT_VEC(15)
+#define DES_IRQ				VIC3_INT_VEC(16)
+#define MD5_IRQ				VIC3_INT_VEC(17)
+#define L2CC_INTR_IRQ			VIC3_INT_VEC(18)
+#define L2CC_INTR1_IRQ			VIC3_INT_VEC(19)
+#define AXI_SWI_IRQ			VIC3_INT_VEC(20)
+#define AXI_SWI1_IRQ			VIC3_INT_VEC(21)
+#define GPIO6_IRQ			VIC3_INT_VEC(22)
+#define GPIO5_IRQ			VIC3_INT_VEC(23)
+#define GPIO4_IRQ			VIC3_INT_VEC(24)
+#define GPIO3_IRQ			VIC3_INT_VEC(25)
+#define GPIO2_IRQ			VIC3_INT_VEC(26)
+#define GPIO1_IRQ			VIC3_INT_VEC(27)
+#define GPIO0_IRQ			VIC3_INT_VEC(28)
+#define DMIC_IRQ			VIC3_INT_VEC(29)
+#define TIMER20_IRQ			VIC3_INT_VEC(30)
+#define TIMER19_IRQ			VIC3_INT_VEC(31)
+
+/* ==========================================================================*/
+#elif (CHIP_REV == S3L)
+#define TIMER1_IRQ			VIC0_INT_VEC(0)
+#define TIMER2_IRQ			VIC0_INT_VEC(1)
+#define TIMER3_IRQ			VIC0_INT_VEC(2)
+#define TIMER4_IRQ			VIC0_INT_VEC(3)
+#define TIMER5_IRQ			VIC0_INT_VEC(4)
+#define TIMER6_IRQ			VIC0_INT_VEC(5)
+#define TIMER7_IRQ			VIC0_INT_VEC(6)
+#define AXI_SOFT_IRQ(x)			VIC0_INT_VEC((x) + 7)	/* 0 <= x <= 13 */
+#define AXI_SW_IRQ0			VIC0_INT_VEC(21)
+#define AXI_SW_IRQ1			VIC0_INT_VEC(22)
+#define PMU_IRQ				VIC0_INT_VEC(23)
+#define L2CC_INTR_IRQ			VIC0_INT_VEC(24)
+#define L2CC_DECERR_IRQ			VIC0_INT_VEC(25)
+#define L2CC_SLVERR_IRQ			VIC0_INT_VEC(26)
+#define L2CC_ECNTR_IRQ			VIC0_INT_VEC(27)
+#define MD5_IRQ				VIC0_INT_VEC(28)
+#define DES_IRQ				VIC0_INT_VEC(29)
+#define AES_IRQ				VIC0_INT_VEC(30)
+#define SHA1_IRQ			VIC0_INT_VEC(31)
+
+#define IDSP_VIN_MVSYNC_IRQ		VIC1_INT_VEC(0)
+#define IDSP_VIN_VSYNC_IRQ		VIC1_INT_VEC(1)
+#define IDSP_VIN_SOF_IRQ		VIC1_INT_VEC(2)
+#define IDSP_VIN_DVSYNC_IRQ		VIC1_INT_VEC(3)
+#define IDSP_VIN_LAST_PIXEL_IRQ		VIC1_INT_VEC(4)
+#define GDMA_IRQ			VIC1_INT_VEC(5)
+#define IDSP_PIP_MVSYNC_IRQ		VIC1_INT_VEC(6)
+#define IDSP_PIP_VSYNC_IRQ		VIC1_INT_VEC(7)
+#define IDSP_PIP_SOF_IRQ		VIC1_INT_VEC(8)
+#define IDSP_PIP_DVSYNC_IRQ		VIC1_INT_VEC(9)
+#define IDSP_PIP_LAST_PIXEL_IRQ		VIC1_INT_VEC(10)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(11)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(12)
+#define CODE_VDSP_0_IRQ			VIC1_INT_VEC(13)
+#define CODE_VDSP_1_IRQ			VIC1_INT_VEC(14)
+#define CODE_VDSP_2_IRQ			VIC1_INT_VEC(15)
+#define CODE_VDSP_3_IRQ			VIC1_INT_VEC(16)
+#define GPIO3_IRQ			VIC1_INT_VEC(17)
+#define GPIO2_IRQ			VIC1_INT_VEC(18)
+#define GPIO1_IRQ			VIC1_INT_VEC(19)
+#define GPIO0_IRQ			VIC1_INT_VEC(20)
+#define VIN_IRQ				VIC1_INT_VEC(21)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(22)
+#define VOUT_IRQ			VIC1_INT_VEC(23)
+#define VDSP_PIP_CODING_IRQ		VIC1_INT_VEC(24)
+#define ADC_LEVEL_IRQ			VIC1_INT_VEC(25)
+#define HDMI_IRQ			VIC1_INT_VEC(26)
+#define WDT_IRQ				VIC1_INT_VEC(27)
+#define ETH_PMT_IRQ			VIC1_INT_VEC(28)
+#define UART0_IRQ			VIC1_INT_VEC(29)
+#define MOTOR_IRQ			VIC1_INT_VEC(30)
+#define TIMER8_IRQ			VIC1_INT_VEC(31)
+
+#define PWC_ALRAM			VIC2_INT_VEC(0)
+#define ETH_IRQ				VIC2_INT_VEC(1)
+#define USB_EHCI_IRQ			VIC2_INT_VEC(2)
+#define USB_OHCI_IRQ			VIC2_INT_VEC(3)
+#define USBC_IRQ			VIC2_INT_VEC(4)
+#define DMA_IRQ				VIC2_INT_VEC(5)
+#define DMA_FIOS_IRQ			VIC2_INT_VEC(6)
+#define FIOS_ECC_IRQ			VIC2_INT_VEC(7)
+#define FIOCMD_IRQ			VIC2_INT_VEC(8)
+#define FIODMA_IRQ			VIC2_INT_VEC(9)
+#define SD2_IRQ				VIC2_INT_VEC(10) /* SDXC rather than SDIO */
+#define SD_IRQ				VIC2_INT_VEC(11)
+#define NOR_SPI				VIC2_INT_VEC(12)
+#define SSI_MASTER1_IRQ			VIC2_INT_VEC(13)
+#define SSI_MASTER0_IRQ			VIC2_INT_VEC(14)
+#define SSI_SLAVE_IRQ			VIC2_INT_VEC(15)
+#define UART1_IRQ			VIC2_INT_VEC(16)
+#define IDC3_IRQ			VIC2_INT_VEC(17)
+#define IDC2_IRQ			VIC2_INT_VEC(18)
+#define IDC_IRQ				VIC2_INT_VEC(19)
+#define IRIF_IRQ			VIC2_INT_VEC(20)
+#define I2STX_IRQ			VIC2_INT_VEC(21)
+#define I2SRX_IRQ			VIC2_INT_VEC(22)
+#define USBVBUS_IRQ			VIC2_INT_VEC(23)
+#define USB_DIGITAL_ID_CHANGE_IRQ	VIC2_INT_VEC(24)
+#define USB_CONNECT_CHANGE_IRQ		VIC2_INT_VEC(25)
+#define USB_CHARGE_IRQ			VIC2_INT_VEC(26)
+#define SD2CD_IRQ			VIC2_INT_VEC(27) /* SDXC rather than SDIO */
+#define SD0CD_IRQ			VIC2_INT_VEC(28)
 
 /* ==========================================================================*/
 #else
diff --git a/arch/arm/mach-ambarella/include/plat/nand.h b/arch/arm/mach-ambarella/include/plat/nand.h
index ed7e799..3cb9e38 100644
--- a/arch/arm/mach-ambarella/include/plat/nand.h
+++ b/arch/arm/mach-ambarella/include/plat/nand.h
@@ -25,6 +25,14 @@
 #define __PLAT_AMBARELLA_NAND_H__
 
 /* ==========================================================================*/
+
+#if (CHIP_REV == S2E) || (CHIP_REV == S3L)
+#define NAND_ECC_RPT_NUM_SUPPORT	1
+#else
+#define NAND_ECC_RPT_NUM_SUPPORT	0
+#endif
+
+/* ==========================================================================*/
 #define FLASH_CTR_OFFSET		0x120
 #define FLASH_CMD_OFFSET		0x124
 #define FLASH_TIM0_OFFSET		0x128
@@ -40,38 +48,46 @@
 #define FLASH_INT_OFFSET		0x150
 #define FLASH_EX_CTR_OFFSET		0x15c
 #define FLASH_EX_ID_OFFSET		0x160
-
-#define FLASH_CTR_REG			FIO_REG(0x120)
-#define FLASH_CMD_REG			FIO_REG(0x124)
-#define FLASH_TIM0_REG			FIO_REG(0x128)
-#define FLASH_TIM1_REG			FIO_REG(0x12c)
-#define FLASH_TIM2_REG			FIO_REG(0x130)
-#define FLASH_TIM3_REG			FIO_REG(0x134)
-#define FLASH_TIM4_REG			FIO_REG(0x138)
-#define FLASH_TIM5_REG			FIO_REG(0x13c)
-#define FLASH_STA_REG			FIO_REG(0x140)
-#define FLASH_ID_REG			FIO_REG(0x144)
-#define FLASH_CFI_REG			FIO_REG(0x148)
-#define FLASH_LEN_REG			FIO_REG(0x14c)
-#define FLASH_INT_REG			FIO_REG(0x150)
-#define FLASH_EXT_CTR_REG		FIO_REG(0x15c)
-#define FLASH_EXT_ID5_REG		FIO_REG(0x160)
-
-#define NAND_CTR_REG			FLASH_CTR_REG
-#define NAND_CMD_REG			FLASH_CMD_REG
-#define NAND_TIM0_REG			FLASH_TIM0_REG
-#define NAND_TIM1_REG			FLASH_TIM1_REG
-#define NAND_TIM2_REG			FLASH_TIM2_REG
-#define NAND_TIM3_REG			FLASH_TIM3_REG
-#define NAND_TIM4_REG			FLASH_TIM4_REG
-#define NAND_TIM5_REG			FLASH_TIM5_REG
-#define NAND_STA_REG			FLASH_STA_REG
-#define NAND_ID_REG			FLASH_ID_REG
-#define NAND_COPY_ADDR_REG		FLASH_CFI_REG
-#define NAND_LEN_REG			FLASH_LEN_REG
-#define NAND_INT_REG			FLASH_INT_REG
-#define NAND_EXT_CTR_REG		FLASH_EXT_CTR_REG
-#define NAND_EXT_ID5_REG		FLASH_EXT_ID5_REG
+/* followings are for customer command, start from S3L */
+#define FLASH_TIM6_OFFSET		0x164
+#define FLASH_CC_OFFSET			0x170
+#define FLASH_CC_WORD_OFFSET		0x174
+#define FLASH_CC_DATA0_OFFSET		0x180
+#define FLASH_CC_DATA1_OFFSET		0x184
+#define FLASH_CC_DATA2_OFFSET		0x188
+#define FLASH_CC_DATA3_OFFSET		0x18c
+#define FLASH_CC_DATA4_OFFSET		0x190
+#define FLASH_CC_DATA5_OFFSET		0x194
+#define FLASH_CC_DATA6_OFFSET		0x198
+#define FLASH_CC_DATA7_OFFSET		0x19c
+
+#define NAND_CTR_REG			FIO_REG(0x120)
+#define NAND_CMD_REG			FIO_REG(0x124)
+#define NAND_TIM0_REG			FIO_REG(0x128)
+#define NAND_TIM1_REG			FIO_REG(0x12c)
+#define NAND_TIM2_REG			FIO_REG(0x130)
+#define NAND_TIM3_REG			FIO_REG(0x134)
+#define NAND_TIM4_REG			FIO_REG(0x138)
+#define NAND_TIM5_REG			FIO_REG(0x13c)
+#define NAND_STA_REG			FIO_REG(0x140)
+#define NAND_ID_REG			FIO_REG(0x144)
+#define NAND_COPY_ADDR_REG		FIO_REG(0x148)
+#define NAND_LEN_REG			FIO_REG(0x14c)
+#define NAND_INT_REG			FIO_REG(0x150)
+#define NAND_EXT_CTR_REG		FIO_REG(0x15c)
+#define NAND_EXT_ID5_REG		FIO_REG(0x160)
+/* followings are for customer command, start from S3L */
+#define NAND_TIM6_REG			FIO_REG(0x164)
+#define NAND_CC_REG			FIO_REG(0x170)
+#define NAND_CC_WORD_REG		FIO_REG(0x174)
+#define NAND_CC_DATA0_REG		FIO_REG(0x180)
+#define NAND_CC_DATA1_REG		FIO_REG(0x184)
+#define NAND_CC_DATA2_REG		FIO_REG(0x188)
+#define NAND_CC_DATA3_REG		FIO_REG(0x18c)
+#define NAND_CC_DATA4_REG		FIO_REG(0x190)
+#define NAND_CC_DATA5_REG		FIO_REG(0x194)
+#define NAND_CC_DATA6_REG		FIO_REG(0x198)
+#define NAND_CC_DATA7_REG		FIO_REG(0x19c)
 
 #define NAND_READ_CMDWORD_REG		FIO_REG(0x154)
 #define NAND_PROG_CMDWORD_REG		FIO_REG(0x158)
@@ -144,42 +160,42 @@
 #define NAND_AMB_CMD_READ		0xe
 #define NAND_AMB_CMD_PROGRAM		0xf
 
-/* FLASH_TIM0_REG (NAND mode) */
+/* NAND_TIM0_REG (NAND mode) */
 #define NAND_TIM0_TCLS(x)		((x) << 24)
 #define NAND_TIM0_TALS(x)		((x) << 16)
 #define NAND_TIM0_TCS(x)		((x) << 8)
 #define NAND_TIM0_TDS(x)		(x)
 
-/* FLASH_TIM1_REG (NAND mode) */
+/* NAND_TIM1_REG (NAND mode) */
 #define NAND_TIM1_TCLH(x)		((x) << 24)
 #define NAND_TIM1_TALH(x)		((x) << 16)
 #define NAND_TIM1_TCH(x)		((x) << 8)
 #define NAND_TIM1_TDH(x)		(x)
 
-/* FLASH_TIM2_REG (NAND mode) */
+/* NAND_TIM2_REG (NAND mode) */
 #define NAND_TIM2_TWP(x)		((x) << 24)
 #define NAND_TIM2_TWH(x)		((x) << 16)
 #define NAND_TIM2_TWB(x)		((x) << 8)
 #define NAND_TIM2_TRR(x)		(x)
 
-/* FLASH_TIM3_REG (NAND mode) */
+/* NAND_TIM3_REG (NAND mode) */
 #define NAND_TIM3_TRP(x)		((x) << 24)
 #define NAND_TIM3_TREH(x)		((x) << 16)
 #define NAND_TIM3_TRB(x)		((x) << 8)
 #define NAND_TIM3_TCEH(x)		(x)
 
-/* FLASH_TIM4_REG (NAND mode) */
+/* NAND_TIM4_REG (NAND mode) */
 #define NAND_TIM4_TRDELAY(x)		((x) << 24)
 #define NAND_TIM4_TCLR(x)		((x) << 16)
 #define NAND_TIM4_TWHR(x)		((x) << 8)
 #define NAND_TIM4_TIR(x)		(x)
 
-/* FLASH_TIM5_REG (NAND mode) */
+/* NAND_TIM5_REG (NAND mode) */
 #define NAND_TIM5_TWW(x)		((x) << 16)
 #define NAND_TIM5_TRHZ(x)		((x) << 8)
 #define NAND_TIM5_TAR(x)		(x)
 
-/* FLASH_INT_REG (NAND mode) */
+/* NAND_INT_REG (NAND mode) */
 #define NAND_INT_DI			0x1
 
 /* NAND_EXT_CTR_REG */
diff --git a/arch/arm/mach-ambarella/include/plat/pm.h b/arch/arm/mach-ambarella/include/plat/pm.h
index d4f2f1d..110b488 100644
--- a/arch/arm/mach-ambarella/include/plat/pm.h
+++ b/arch/arm/mach-ambarella/include/plat/pm.h
@@ -36,6 +36,12 @@
 extern int ambarella_init_pm(void);
 extern int ambarella_finish_suspend(unsigned long);
 extern void ambarella_cpu_resume(void);
+
+#ifdef CONFIG_AMBARELLA_SREF_FIFO_EXEC
+extern int ambarella_optimize_suspend(unsigned long);
+extern int ambarella_optimize_suspend_sz;
+#endif /* CONFIG_AMBARELLA_SREF_FIFO_EXEC */
+
 #else
 static inline int ambarella_init_pm(void){return 0;}
 #endif
diff --git a/arch/arm/mach-ambarella/include/plat/ptb.h b/arch/arm/mach-ambarella/include/plat/ptb.h
index 3e56bcb..99c4f25 100644
--- a/arch/arm/mach-ambarella/include/plat/ptb.h
+++ b/arch/arm/mach-ambarella/include/plat/ptb.h
@@ -104,6 +104,17 @@ typedef struct fldev_s
 	u32	magic;		/**< Magic number */
 } __attribute__((packed)) fldev_t;
 
+/*The header of PTB*/
+#define PTB_HEADER_SIZE		64
+#define PTB_HEADER_PAD_SIZE	(PTB_HEADER_SIZE - sizeof(u32) * 4)
+typedef struct ptb_header_s
+{
+	u32	magic;
+	u32	crc32;
+	u32	version;
+	u32	dev;
+	u8	rsv[PTB_HEADER_PAD_SIZE];
+} __attribute__((packed)) ptb_header_t;
 
 #define PTB_SIZE		4096
 #define PTB_PAD_SIZE		\
@@ -117,7 +128,6 @@ typedef struct flpart_table_s
 	u8		rsv[PTB_PAD_SIZE];	/**< Padding to 2048 bytes */
 } __attribute__((packed)) flpart_table_t;
 
-
 /**
  * The meta data table is a region in flash after partition table.
  * The data need by dual boot are stored.
@@ -128,20 +138,19 @@ typedef struct flpart_table_s
 #define PTB_META_MAGIC2		0x4432a0ce
 #define PTB_META_MAGIC3		0x42405891
 #define PART_NAME_LEN		8
-#define PTB_META_ACTURAL_LEN	((sizeof(u32) * 2 + PART_NAME_LEN + \
-				sizeof(u32)) * PART_MAX + sizeof(u32) + \
-				sizeof(u32) + FW_MODEL_NAME_SIZE)
+#define PTB_META_ACTURAL_LEN	(sizeof(u32) + (sizeof(u32) * 3 + PART_NAME_LEN) * PART_MAX + \
+				FW_MODEL_NAME_SIZE)
 #define PTB_META_SIZE		2048
 #define PTB_META_PAD_SIZE	(PTB_META_SIZE - PTB_META_ACTURAL_LEN)
 typedef struct flpart_meta_s
 {
+	u32		magic;
 	struct {
 		u32	sblk;
 		u32	nblk;
+		u32	dev;
 		char	name[PART_NAME_LEN];
 	} part_info[PART_MAX];
-	u32		magic;
-	u32		part_dev[PART_MAX];
 	u8		model_name[FW_MODEL_NAME_SIZE];
 	u8 		rsv[PTB_META_PAD_SIZE];
 	/* This meta crc32 doesn't include itself. */
diff --git a/arch/arm/mach-ambarella/include/plat/pwm.h b/arch/arm/mach-ambarella/include/plat/pwm.h
index ff0851d..a27c6b4 100644
--- a/arch/arm/mach-ambarella/include/plat/pwm.h
+++ b/arch/arm/mach-ambarella/include/plat/pwm.h
@@ -26,7 +26,7 @@
 
 #if (CHIP_REV == A8)
 #define PWM_INSTANCES			0
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3)
+#elif (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define PWM_INSTANCES			4
 #else
 #define PWM_INSTANCES			5
@@ -47,28 +47,24 @@
 #define PWM_MODE_OFFSET			0x08
 #define PWM_CONTROL1_OFFSET		0x0c
 
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
-
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define PWM_B0_ENABLE_OFFSET		0x04
 #define PWM_B1_ENABLE_OFFSET		0x0c
 #define PWM_C0_ENABLE_OFFSET		0x14
 #define PWM_C1_ENABLE_OFFSET		0x1c
-#define PWM_B0_DATA1_OFFSET			0x20
-#define PWM_B1_DATA1_OFFSET			0x24
-#define PWM_C0_DATA1_OFFSET			0x28
-#define PWM_C1_DATA1_OFFSET			0x2c
-
+#define PWM_B0_DATA1_OFFSET		0x20
+#define PWM_B1_DATA1_OFFSET		0x24
+#define PWM_C0_DATA1_OFFSET		0x28
+#define PWM_C1_DATA1_OFFSET		0x2c
 #else
-
 #define PWM_B0_ENABLE_OFFSET		0x304
 #define PWM_B1_ENABLE_OFFSET		0x30c
 #define PWM_C0_ENABLE_OFFSET		0x314
 #define PWM_C1_ENABLE_OFFSET		0x31c
-#define PWM_B0_DATA1_OFFSET			0x320
-#define PWM_B1_DATA1_OFFSET			0x324
-#define PWM_C0_DATA1_OFFSET			0x328
-#define PWM_C1_DATA1_OFFSET			0x32c
-
+#define PWM_B0_DATA1_OFFSET		0x320
+#define PWM_B1_DATA1_OFFSET		0x324
+#define PWM_C0_DATA1_OFFSET		0x328
+#define PWM_C1_DATA1_OFFSET		0x32c
 #endif
 
 #define PWM_CLK_SRC_BIT			(0x1 << 31)
@@ -77,7 +73,7 @@
 #define PWM_PWM_EN_BIT			(0x1)
 
 #define PWM_PWM_TICKS_MAX_BITS		16
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define PWM_ST_TICKS_MAX_BITS		16
 #else
 #define PWM_ST_TICKS_MAX_BITS		10
diff --git a/arch/arm/mach-ambarella/include/plat/rct.h b/arch/arm/mach-ambarella/include/plat/rct.h
index cf3b3ca..9d3f5be 100644
--- a/arch/arm/mach-ambarella/include/plat/rct.h
+++ b/arch/arm/mach-ambarella/include/plat/rct.h
@@ -26,12 +26,14 @@
 
 /* ==========================================================================*/
 #define RCT_OFFSET			0x170000
-#if (CHIP_REV == A8) || (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == A8) || (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define RCT_BASE			(DBGBUS_BASE + RCT_OFFSET)
-#define RCT_PHYS_BASE			(DBGBUS_PHYS_BASE + RCT_OFFSET)
+#define RCT_PHYS_BASE		(DBGBUS_PHYS_BASE + RCT_OFFSET)
+#define	RCT_BUS_BASE		DBGBUS_BASE
 #else
 #define RCT_BASE			(APB_BASE + RCT_OFFSET)
-#define RCT_PHYS_BASE			(APB_PHYS_BASE + RCT_OFFSET)
+#define RCT_PHYS_BASE		(APB_PHYS_BASE + RCT_OFFSET)
+#define	RCT_BUS_BASE		APB_BASE
 #endif
 #define RCT_REG(x)			(RCT_BASE + (x))
 
@@ -41,7 +43,6 @@
 
 #define PLL_LOCK_REG			RCT_REG(PLL_LOCK_OFFSET)
 #define SOFT_OR_DLL_RESET_REG		RCT_REG(SOFT_OR_DLL_RESET_OFFSET)
-#define SOFT_RESET_REG			RCT_REG(SOFT_OR_DLL_RESET_OFFSET)
 
 /* ==========================================================================*/
 #define FIO_RESET_OFFSET		0x74
@@ -53,22 +54,22 @@
 
 /* ==========================================================================*/
 #if (CHIP_REV == A5S) || (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define USBC_CTRL_OFFSET		0xFFF /* non-existed */
 #define USBP1_CTRL_OFFSET		0x88
-#define USB0_IS_HOST_MASK		0x00000020
-#define UDC_SOFT_RESET			0x20000000
+#define UDC_SOFT_RESET_OFFSET		USBP1_CTRL_OFFSET
+#define UDC_SOFT_RESET_MASK		0x20000000
 #else
-#define USBC_CTRL_OFFSET		0x2CC
-#define USBP1_CTRL_OFFSET		0x45c
-#define USB0_IS_HOST_MASK		0x00000002
-#define UDC_SOFT_RESET			0x2
+#define USBC_CTRL_OFFSET		0x2cc
+#define UDC_SOFT_RESET_OFFSET		USBC_CTRL_OFFSET
+#define UDC_SOFT_RESET_MASK		0x2
 #endif
-#define USBC_CTRL_REG			RCT_REG(USBC_CTRL_OFFSET)
-#define USBP1_CTRL_REG			RCT_REG(USBP1_CTRL_OFFSET)
+#define UDC_SOFT_RESET_REG		RCT_REG(UDC_SOFT_RESET_OFFSET)
 
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2) || (CHIP_REV == S2E)
+#define USB0_IS_HOST_MASK		0x00000020
+#else
 #define USBP0_SEL_OFFSET		0x2c0
 #define USBP0_SEL_REG			RCT_REG(USBP0_SEL_OFFSET)
+#define USB0_IS_HOST_MASK		0x00000002
 #endif
 
 /* ==========================================================================*/
@@ -113,6 +114,7 @@
 #define CG_HOST_OFFSET			0x48
 #define CG_PWM_OFFSET			0x84
 #define CG_SSI2_OFFSET			0xEC
+#define CLK_REF_SSI_OFFSET		0x19c
 #define CG_SSI3_OFFSET			0x518
 #define CLK_REF_SSI3_OFFSET		0x51c
 
@@ -124,6 +126,7 @@
 #define CG_PWM_REG			RCT_REG(CG_PWM_OFFSET)
 #define CG_SSI2_REG			RCT_REG(CG_SSI2_OFFSET)
 #define CG_SSI3_REG			RCT_REG(CG_SSI3_OFFSET)
+#define CLK_REF_SSI_REG			RCT_REG(CLK_REF_SSI_OFFSET)
 #define CLK_REF_SSI3_REG		RCT_REG(CLK_REF_SSI3_OFFSET)
 
 #define UART_CLK_SRC_CLK_REF		0x00
@@ -141,16 +144,19 @@
 #define PLL_CORE_FRAC_OFFSET		0x04
 #define PLL_CORE_CTRL2_OFFSET		0x100
 #define PLL_CORE_CTRL3_OFFSET		0x104
-#define SCALER_CORE_POST_OFFSET		0x118
-
 #define PLL_CORE_CTRL_REG		RCT_REG(PLL_CORE_CTRL_OFFSET)
 #define PLL_CORE_FRAC_REG		RCT_REG(PLL_CORE_FRAC_OFFSET)
 #define PLL_CORE_CTRL2_REG		RCT_REG(PLL_CORE_CTRL2_OFFSET)
 #define PLL_CORE_CTRL3_REG		RCT_REG(PLL_CORE_CTRL3_OFFSET)
-#define SCALER_CORE_POST_REG		RCT_REG(SCALER_CORE_POST_OFFSET)
 
+#if ((CHIP_REV == A5S) || (CHIP_REV == S2) || (CHIP_REV == S2E))
+#define SCALER_CORE_POST_OFFSET		0x118
 #define CORE_CLK_RATIO_1X_OFFSET	0x24C
+#define SCALER_CORE_POST_REG		RCT_REG(SCALER_CORE_POST_OFFSET)
 #define CORE_CLK_RATIO_1X_REG		RCT_REG(CORE_CLK_RATIO_1X_OFFSET)
+#endif
+
+/* ==========================================================================*/
 
 #define PLL_HDMILC_CTRL_OFFSET		0x404
 #define PLL_HDMILC_FRAC_OFFSET		0x408
@@ -164,12 +170,14 @@
 #define PLL_HDMILC_CTRL4_REG		RCT_REG(PLL_HDMILC_CTRL4_OFFSET)
 
 /* ==========================================================================*/
+#define CKEN_CLUSTER_REG_OFFSET		0x8C
 #define PLL_IDSP_CTRL_OFFSET		0xE4
 #define PLL_IDSP_FRAC_OFFSET		0xE8
 #define PLL_IDSP_CTRL2_OFFSET		0x108
 #define PLL_IDSP_CTRL3_OFFSET		0x10C
 #define SCALER_IDSP_POST_OFFSET		0x1F4
 
+#define CKEN_CLUSTER_REG		RCT_REG(CKEN_CLUSTER_REG_OFFSET)
 #define PLL_IDSP_CTRL_REG		RCT_REG(PLL_IDSP_CTRL_OFFSET)
 #define PLL_IDSP_FRAC_REG		RCT_REG(PLL_IDSP_FRAC_OFFSET)
 #define PLL_IDSP_CTRL2_REG		RCT_REG(PLL_IDSP_CTRL2_OFFSET)
@@ -195,6 +203,7 @@
 #define SCALER_SENSOR_PRE_OFFSET	0x4C
 #define SCALER_SENSOR_POST_OFFSET	0x30
 #define CLK_SI_INPUT_MODE_OFFSET	0xBC
+#define SCALER_SENSOR_VIN_OFFSET	0x230
 
 #define PLL_SENSOR_CTRL_REG		RCT_REG(PLL_SENSOR_CTRL_OFFSET)
 #define PLL_SENSOR_FRAC_REG		RCT_REG(PLL_SENSOR_FRAC_OFFSET)
@@ -203,6 +212,7 @@
 #define SCALER_SENSOR_PRE_REG		RCT_REG(SCALER_SENSOR_PRE_OFFSET)
 #define SCALER_SENSOR_POST_REG		RCT_REG(SCALER_SENSOR_POST_OFFSET)
 #define CLK_SI_INPUT_MODE_REG		RCT_REG(CLK_SI_INPUT_MODE_OFFSET)
+#define SCALER_SENSOR_VIN_REG		RCT_REG(SCALER_SENSOR_VIN_OFFSET)
 
 /* ==========================================================================*/
 
@@ -268,7 +278,7 @@
 #define SCALER_ARM_ASYNC_REG		RCT_REG(SCALER_ARM_ASYNC_OFFSET)
 
 /* ==========================================================================*/
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define PLL_CORTEX_CTRL_OFFSET		0x264
 #define PLL_CORTEX_FRAC_OFFSET		0x268
 #define PLL_CORTEX_CTRL2_OFFSET		0x26C
@@ -285,14 +295,19 @@
 #define PLL_CORTEX_CTRL2_REG		RCT_REG(PLL_CORTEX_CTRL2_OFFSET)
 #define PLL_CORTEX_CTRL3_REG		RCT_REG(PLL_CORTEX_CTRL3_OFFSET)
 
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define SCALER_GTX_POST_OFFSET		0x2C8
-#define ENET_GTXCLK_SRC_OFFSET		0x2CC
+/* ==========================================================================*/
+
+#if (CHIP_REV == S3L)
+#define ENET_CLK_SRC_SEL_OFFSET		0x544
+#define ENET_CLK_SRC_SEL_REG		RCT_REG(ENET_CLK_SRC_SEL_OFFSET)
+#elif (CHIP_REV == S2E || CHIP_REV == S2)
+#define ENET_CLK_SRC_SEL_OFFSET		0x2CC
+#define ENET_CLK_SRC_SEL_REG		RCT_REG(ENET_CLK_SRC_SEL_OFFSET)
+#else
+#define ENET_CLK_SRC_SEL_REG		0
 #endif
-#define SCALER_GTX_POST_REG		RCT_REG(SCALER_GTX_POST_OFFSET)
-#define ENET_GTXCLK_SRC_REG		RCT_REG(ENET_GTXCLK_SRC_OFFSET)
 
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define PLL_ENET_CTRL_OFFSET		0x520
 #define PLL_ENET_FRAC_OFFSET		0x524
 #define PLL_ENET_CTRL2_OFFSET		0x528
@@ -319,7 +334,7 @@
 #define SCALER_SDXC_OFFSET		0x434
 #define SCALER_SDXC_REG			RCT_REG(SCALER_SDXC_OFFSET)
 
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define PLL_SD_CTRL_OFFSET		0x4AC
 #define PLL_SD_FRAC_OFFSET		0x4B0
 #define PLL_SD_CTRL2_OFFSET		0x4B4
@@ -350,6 +365,7 @@
 #define SD_PHY_RX_CLK_POL		1 << 19
 #define SD_PHY_DATA_CMD_BYPASS		1 << 18
 #define SD_PHY_DLL_BYPASS		1 << 17
+
 #if (CHIP_REV == S2E)
 #define SD_PHY_CTRL_0_OFFSET		0x340
 #define SD_PHY_CTRL_1_OFFSET		0x344
@@ -362,6 +378,16 @@
 #define SD_PHY_CTRL_0_REG		RCT_REG(SD_PHY_CTRL_0_OFFSET)
 #define SD_PHY_CTRL_1_REG		RCT_REG(SD_PHY_CTRL_1_OFFSET)
 #define SD_PHY_OBSV_REG			RCT_REG(SD_PHY_OBSV_OFFSET)
+
+#if (CHIP_REV == S3L)
+#define SDXC_PHY_CTRL_0_OFFSET		0x4C8
+#define SDXC_PHY_CTRL_1_OFFSET		0x4CC
+#define SDXC_PHY_OBSV_OFFSET		0x4F0
+#define SDXC_PHY_CTRL_0_REG		RCT_REG(SDXC_PHY_CTRL_0_OFFSET)
+#define SDXC_PHY_CTRL_1_REG		RCT_REG(SDXC_PHY_CTRL_1_OFFSET)
+#define SDXC_PHY_OBSV_REG		RCT_REG(SDXC_PHY_OBSV_OFFSET)
+#endif
+
 #else
 #define MS_DELAY_CTRL_OFFSET		0x1D0
 #define MS_DELAY_CTRL_REG		RCT_REG(MS_DELAY_CTRL_OFFSET)
@@ -421,16 +447,16 @@
 #define SDXC_PULL_CTRL_OFFSET		0x2F8
 #define SDXC_PULL_CTRL_REG		RCT_REG(SDXC_PULL_CTRL_OFFSET)
 
-#if (CHIP_REV == A5S) || (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define IOCTRL_DRIVE_STRENGTH_2MA	0x0
-#define IOCTRL_DRIVE_STRENGTH_8MA	0x1
-#define IOCTRL_DRIVE_STRENGTH_4MA	0x2
-#define IOCTRL_DRIVE_STRENGTH_12MA	0x3
-#else
+#if (CHIP_REV == S2) || (CHIP_REV == S2E)
 #define IOCTRL_DRIVE_STRENGTH_3MA	0x0
 #define IOCTRL_DRIVE_STRENGTH_12MA	0x1
 #define IOCTRL_DRIVE_STRENGTH_6MA	0x2
 #define IOCTRL_DRIVE_STRENGTH_18MA	0x3
+#else
+#define IOCTRL_DRIVE_STRENGTH_2MA	0x0
+#define IOCTRL_DRIVE_STRENGTH_8MA	0x1
+#define IOCTRL_DRIVE_STRENGTH_4MA	0x2
+#define IOCTRL_DRIVE_STRENGTH_12MA	0x3
 #endif
 
 #if (CHIP_REV == A5S)
@@ -500,27 +526,45 @@
 
 /* ==========================================================================*/
 
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+#define AHB_MISC_OFFSET			0x21c
+#endif
+#define AHB_MISC_REG			RCT_REG(AHB_MISC_OFFSET)
+
+/* ==========================================================================*/
+
 /* Secure and Scratchpad */
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
 #define AHB_SCRATCHPAD_OFFSET		0x1B000
 #define AHB_SECURE_OFFSET		0x1D000
-#else
-#define AHB_SCRATCHPAD_OFFSET		0x19000
-#define AHB_SECURE_OFFSET		0x1F000
-#endif
 #define AHB_SCRATCHPAD_BASE		(AHB_BASE + AHB_SCRATCHPAD_OFFSET)
 #define AHB_SECURE_BASE			(AHB_BASE + AHB_SECURE_OFFSET)
 #define AHB_SCRATCHPAD_REG(x)		(AHB_SCRATCHPAD_BASE + (x))
 #define AHB_SECURE_REG(x)		(AHB_SECURE_BASE + (x))
 
-#if (CHIP_REV == S3)
+#if (CHIP_REV == S3L)
+#define AHBSP_PRI_IRQ_C0_OFFSET		0x38
+#define AHBSP_PRI_IRQ_C1_OFFSET		-1 /* not supported */
+#else
+#define AHBSP_PRI_IRQ_C0_OFFSET		0x3C
+#define AHBSP_PRI_IRQ_C1_OFFSET		0x40
+#endif
+#define AHBSP_PRI_IRQ_C0_REG		AHB_SCRATCHPAD_REG(AHBSP_PRI_IRQ_C0_OFFSET)
+#define AHBSP_PRI_IRQ_C1_REG		AHB_SCRATCHPAD_REG(AHBSP_PRI_IRQ_C1_OFFSET)
+
+/* ==========================================================================*/
+
+#if (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define DMA_SUPPORT_SELECT_CHANNEL	1
 #else
 #define DMA_SUPPORT_SELECT_CHANNEL	0
 #endif
 
+#if (CHIP_REV == S3)
 #define AHBSP_DMA_CHANNEL_SEL_OFFSET	0x30
-#define AHBSP_DMA_CHANNEL_SEL_REG	AHB_SCRATCHPAD_REG(0x30)
+#elif (CHIP_REV == S3L)
+#define AHBSP_DMA_CHANNEL_SEL_OFFSET	0x2C
+#endif
+#define AHBSP_DMA_CHANNEL_SEL_REG	AHB_SCRATCHPAD_REG(AHBSP_DMA_CHANNEL_SEL_OFFSET)
 
 #define SSI0_TX_DMA_REQ_IDX		0
 #define SSI0_RX_DMA_REQ_IDX		1
@@ -537,5 +581,111 @@
 #define SLIM_TX_DMA_REQ_IDX		12
 #define SLIM_RX_DMA_REQ_IDX		13
 
+/* ==========================================================================*/
+#if (CHIP_REV == A5S) || (CHIP_REV == A7L)
+#define	POC_BOOT_MAP_TYPE		0
+#define POC_BOOT_FROM_MASK		0x00010500
+#define POC_BOOT_FROM_USB		0x00000000
+#define POC_BOOT_FROM_BYPASS		0x00000100
+#define POC_BOOT_FROM_NAND		0x00000400
+#define POC_BOOT_FROM_EMMC		0xFFFFFFFF /* not supported */
+#define POC_BOOT_FROM_SPINOR		0xFFFFFFFF /* not supported */
+#define POC_BOOT_FROM_HIF		0xFFFFFFFF /* not supported */
+#elif (CHIP_REV == S2) || (CHIP_REV == S2E)
+#define	POC_BOOT_MAP_TYPE		0
+#define POC_BOOT_FROM_MASK		0x00003140
+#define POC_BOOT_FROM_BYPASS		0x00000040
+#define POC_BOOT_FROM_USB		0x00000000
+#define POC_BOOT_FROM_NAND		0x00000100
+#define POC_BOOT_FROM_SPINOR		0x00001000 /* not supported on S2 */
+#define POC_BOOT_FROM_EMMC		0x00002000
+#define POC_BOOT_FROM_HIF		0xFFFFFFFF /* not supported */
+#elif (CHIP_REV == S3)
+#define	POC_BOOT_MAP_TYPE		1
+#define POC_BOOT_FROM_MASK		0x00000570
+#define POC_BOOT_FROM_BYPASS		0x00000100
+#define POC_BOOT_FROM_USB		0x00000400
+#define POC_BOOT_FROM_SPINOR		0x00000000
+#define POC_BOOT_FROM_NAND		0x00000010
+#define POC_BOOT_FROM_EMMC		0x00000020
+#define POC_BOOT_FROM_HIF		0x00000040
+#elif (CHIP_REV == S2L) || (CHIP_REV == S3L)
+#define	POC_BOOT_MAP_TYPE		1
+#define POC_BOOT_FROM_MASK		0x00000530
+#define POC_BOOT_FROM_BYPASS		0x00000100
+#define POC_BOOT_FROM_USB		0x00000400
+#define POC_BOOT_FROM_SPINOR		0x00000000
+#define POC_BOOT_FROM_NAND		0x00000010
+#define POC_BOOT_FROM_EMMC		0x00000020
+#define POC_BOOT_FROM_HIF		0xFFFFFFFF /* not supported */
+#endif
+
+#define RCT_BOOT_FROM_BYPASS		0x80000000
+#define RCT_BOOT_FROM_NAND		0x00000001
+#define RCT_BOOT_FROM_USB		0x00000002
+#define RCT_BOOT_FROM_EMMC		0x00000004
+#define RCT_BOOT_FROM_SPINOR		0x00000008
+#define RCT_BOOT_FROM_HIF		0x00000010
+
+/* ==========================================================================*/
+#if (CHIP_REV == A5S)
+#define SYS_CONFIG_NAND_PAGE_SIZE	0x00000020
+#define SYS_CONFIG_NAND_READ_CONFIRM	0x00000040
+#define SYS_CONFIG_NAND_ECC_BCH_EN	0x00000000
+#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00000000
+#elif (CHIP_REV == S2) || (CHIP_REV == S2E)
+#define SYS_CONFIG_NAND_PAGE_SIZE	0x00000010
+#define SYS_CONFIG_NAND_READ_CONFIRM	0x00000020
+#define SYS_CONFIG_NAND_ECC_BCH_EN	0x00000400
+#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00000800
+#else
+#define SYS_CONFIG_NAND_PAGE_SIZE	0x00040000
+#define SYS_CONFIG_NAND_READ_CONFIRM	0x00020000
+#define SYS_CONFIG_NAND_ECC_BCH_EN	0x00010000
+#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00008000
+#endif
+
+/* these definition are used by software */
+#define RCT_BOOT_NAND_AUTO		0x00000000
+#define RCT_BOOT_NAND_PAGE_SIZE		0x00000001
+#define RCT_BOOT_NAND_READ_CONFIRM	0x00000002
+#define RCT_BOOT_NAND_ECC_BCH_EN	0x00000004
+#define RCT_BOOT_NAND_ECC_SPARE_2X	0x00000008
+
+/* ==========================================================================*/
+#if (CHIP_REV == S2)
+#define SYS_CONFIG_MMC_HS		0x00010000
+#define SYS_CONFIG_MMC_DDR		0x00020000
+#define SYS_CONFIG_MMC_4BIT		0x00040000
+#define SYS_CONFIG_MMC_8BIT		0x00080000
+#elif (CHIP_REV == S2E)
+#define SYS_CONFIG_MMC_HS		0x00010000
+#define SYS_CONFIG_MMC_DDR		0x00000000 /* not supported */
+#define SYS_CONFIG_MMC_4BIT		0x00040000
+#define SYS_CONFIG_MMC_8BIT		0x00080000
+#elif (CHIP_REV == S2L) || (CHIP_REV == S3)
+#define SYS_CONFIG_MMC_HS		0x00008000
+#define SYS_CONFIG_MMC_DDR		0x00004000
+#define SYS_CONFIG_MMC_4BIT		0x00020000
+#define SYS_CONFIG_MMC_8BIT		0x00010000
+#elif (CHIP_REV == S3L)
+#define SYS_CONFIG_MMC_HS		0x00000000
+#define SYS_CONFIG_MMC_DDR		0x00000000
+#define SYS_CONFIG_MMC_4BIT		0x00010000
+#define SYS_CONFIG_MMC_8BIT		0x00008000
+#else
+#define SYS_CONFIG_MMC_HS		0x00000000
+#define SYS_CONFIG_MMC_DDR		0x00000000
+#define SYS_CONFIG_MMC_4BIT		0x00000000
+#define SYS_CONFIG_MMC_8BIT		0x00000000
+#endif
+
+/* these definition are used by software */
+#define RCT_BOOT_EMMC_AUTO		0x00000000
+#define RCT_BOOT_EMMC_HS		0x00000001
+#define RCT_BOOT_EMMC_DDR		0x00000002
+#define RCT_BOOT_EMMC_4BIT		0x00000004
+#define RCT_BOOT_EMMC_8BIT		0x00000008
+
 #endif /* __PLAT_AMBARELLA_RCT_H__ */
 
diff --git a/arch/arm/mach-ambarella/include/plat/rtc.h b/arch/arm/mach-ambarella/include/plat/rtc.h
index 5a9d99b..6d7c638 100644
--- a/arch/arm/mach-ambarella/include/plat/rtc.h
+++ b/arch/arm/mach-ambarella/include/plat/rtc.h
@@ -38,7 +38,7 @@
 #endif
 
 /* ==========================================================================*/
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define RTC_OFFSET			0x15000
 #else
 #define RTC_OFFSET			0xD000
diff --git a/arch/arm/mach-ambarella/include/plat/sd.h b/arch/arm/mach-ambarella/include/plat/sd.h
index fe9ba19..f6561d1 100644
--- a/arch/arm/mach-ambarella/include/plat/sd.h
+++ b/arch/arm/mach-ambarella/include/plat/sd.h
@@ -25,7 +25,7 @@
 #define __PLAT_AMBARELLA_SD_H__
 
 /* ==========================================================================*/
-#if (CHIP_REV == A7L) || (CHIP_REV == S2) || (CHIP_REV == S2E)
+#if (CHIP_REV == A7L) || (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S3L)
 #define SD_INSTANCES			2
 #elif (CHIP_REV == S2L) || (CHIP_REV == S3)
 #define SD_INSTANCES			3
@@ -33,6 +33,18 @@
 #define SD_INSTANCES			1
 #endif
 
+#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
+#define SD_SUPPORT_SDIO			1
+#else
+#define SD_SUPPORT_SDIO			0
+#endif
+
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+#define SD_SUPPORT_SDXC			1
+#else
+#define SD_SUPPORT_SDXC			0
+#endif
+
 /* ==========================================================================*/
 #define SD0_OFFSET			0x2000
 #define SD1_OFFSET			0xC000
@@ -84,6 +96,8 @@
 #define SD_BOOT_CTR_OFFSET		0x070
 #define SD_BOOT_STA_OFFSET		0x074
 #define SD_VOL_SW_OFFSET		0x07C
+#define SD_DELAY_SEL_L			0x0D8
+#define SD_DELAY_SEL_H			0x0DC
 #define SD_LAT_CTRL_OFFSET		0x0F8
 #define SD_SIST_OFFSET			0x0FC	/* Half word */
 #define SD_VER_OFFSET			0x0FE	/* Half word */
@@ -347,13 +361,19 @@
 
 /* ==========================================================================*/
 #if (CHIP_REV == A5S)
-#define AMBA_SD_MAX_SLOT_NUM			(2)
+#define AMBA_SD_MAX_SLOT_NUM		(2)
+#else
+#define AMBA_SD_MAX_SLOT_NUM		(1)
+#endif
+
+#if (CHIP_REV == S3L)
+#define sd_slot_is_valid(slot)		((slot) == 0 || (slot) == 2)
 #else
-#define AMBA_SD_MAX_SLOT_NUM			(1)
+#define sd_slot_is_valid(slot)		((slot) < SD_INSTANCES)
 #endif
 
 #if (CHIP_REV == A5S) || (CHIP_REV == A7L) || (CHIP_REV == S2)
-#define sd_addr_is_unlign(addr)		(unlikely((addr) & 0x3))
+#define sd_addr_is_unlign(addr)		((addr) & 0x3)
 #else
 #define sd_addr_is_unlign(addr)		0
 #endif
diff --git a/arch/arm/mach-ambarella/include/plat/spi.h b/arch/arm/mach-ambarella/include/plat/spi.h
index 9077b5d..e04a18f 100644
--- a/arch/arm/mach-ambarella/include/plat/spi.h
+++ b/arch/arm/mach-ambarella/include/plat/spi.h
@@ -42,11 +42,11 @@
 #define SPI_SLAVE_INSTANCES			1
 #define SPI_AHB_SLAVE_INSTANCES			0
 #elif (CHIP_REV == S2E)
-#define SPI_INSTANCES				2
-#define SPI_AHB_INSTANCES			0
+#define SPI_INSTANCES				1
+#define SPI_AHB_INSTANCES			1
 #define SPI_SLAVE_INSTANCES			1
 #define SPI_AHB_SLAVE_INSTANCES			0
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3)
+#elif (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define SPI_INSTANCES				0
 #define SPI_AHB_INSTANCES			2
 #define SPI_SLAVE_INSTANCES			0
@@ -73,7 +73,7 @@
 #define SPI_SUPPORT_NSM_SHAKE_START_BIT_CHSANGE	1 // S2 and S2L is not explain this in PRM
 #endif
 
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define SPI_TARGET_FRAME	1
 #else
 #define SPI_TARGET_FRAME	0
@@ -118,6 +118,12 @@
 #define SSI_DMA_OFFSET			0xD000
 #define SSI_DMA_BASE			(AHB_BASE + SSI_DMA_OFFSET)
 #define SSI_DMA_REG(x)			(SSI_DMA_BASE + (x))
+
+#if (SPI_INSTANCES == 1)
+#define SPI2_OFFSET			0x1F000
+#define SPI2_BASE			(AHB_BASE + SPI2_OFFSET)
+#define SPI2_REG(x)			(SPI2_BASE + (x))
+#endif
 #endif
 
 #if (SPI_AHB_INSTANCES == 2)
diff --git a/arch/arm/mach-ambarella/include/plat/timer.h b/arch/arm/mach-ambarella/include/plat/timer.h
index 33de25a..8da1710 100644
--- a/arch/arm/mach-ambarella/include/plat/timer.h
+++ b/arch/arm/mach-ambarella/include/plat/timer.h
@@ -34,13 +34,12 @@
 #define TIMER1_REG(x)			(TIMER1_BASE + (x))
 
 /* ==========================================================================*/
-#if (CHIP_REV == A7L) || (CHIP_REV == S2) || (CHIP_REV == S2E) || \
-		(CHIP_REV == A8) || (CHIP_REV == S2L)
-#define INTERVAL_TIMER_INSTANCES		8
+#if (CHIP_REV == A5S)
+#define INTERVAL_TIMER_INSTANCES		3
 #elif (CHIP_REV == S3)
 #define INTERVAL_TIMER_INSTANCES		20
 #else
-#define INTERVAL_TIMER_INSTANCES		3
+#define INTERVAL_TIMER_INSTANCES		8
 #endif
 
 /* ==========================================================================*/
diff --git a/arch/arm/mach-ambarella/include/plat/uart.h b/arch/arm/mach-ambarella/include/plat/uart.h
index 288ea38..7c49754 100644
--- a/arch/arm/mach-ambarella/include/plat/uart.h
+++ b/arch/arm/mach-ambarella/include/plat/uart.h
@@ -25,17 +25,15 @@
 #define __PLAT_AMBARELLA_UART_H__
 
 /* ==========================================================================*/
-#if (CHIP_REV == A5S) || (CHIP_REV == A7L) || (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define	UART_INSTANCES			2
-#elif (CHIP_REV == A8) || (CHIP_REV == S2) || (CHIP_REV == S2E)
+#if (CHIP_REV == A8) || (CHIP_REV == S2) || (CHIP_REV == S2E)
 #define	UART_INSTANCES			4
 #else
-#define	UART_INSTANCES			1
+#define	UART_INSTANCES			2
 #endif
 
 /* ==========================================================================*/
 #define UART_OFFSET			0x5000
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define UART1_OFFSET			0x32000
 #else
 #define UART1_OFFSET			0x1F000
@@ -49,7 +47,7 @@
 #endif
 
 #define UART0_BASE			(APB_BASE + UART_OFFSET)
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 #define UART1_BASE			(AHB_BASE + UART1_OFFSET)
 #else
 #define UART1_BASE			(APB_BASE + UART1_OFFSET)
diff --git a/arch/arm/mach-ambarella/init.c b/arch/arm/mach-ambarella/init.c
index 737900b..1023492 100644
--- a/arch/arm/mach-ambarella/init.c
+++ b/arch/arm/mach-ambarella/init.c
@@ -35,18 +35,13 @@
 #include <asm/mach/map.h>
 #include <mach/hardware.h>
 #include <mach/init.h>
-#include <plat/debug.h>
-#include <plat/bapi.h>
 #include <plat/clk.h>
-#include <plat/ambcache.h>
+#include <asm/hardware/cache-l2x0.h>
 
 /* ==========================================================================*/
 u64 ambarella_dmamask = DMA_BIT_MASK(32);
 EXPORT_SYMBOL(ambarella_dmamask);
 
-u32 ambarella_debug_level = AMBA_DEBUG_NULL;
-EXPORT_SYMBOL(ambarella_debug_level);
-
 /* ==========================================================================*/
 enum {
 	AMBARELLA_IO_DESC_AHB_ID = 0,
@@ -329,31 +324,14 @@ void __init ambarella_init_machine(void)
 
 	ret_val = ambarella_init_audio();
 	BUG_ON(ret_val != 0);
-
-#ifdef CONFIG_OUTER_CACHE
-	ambcache_l2_enable();
-#endif
+	l2x0_of_init((1 << L2X0_AUX_CTRL_DATA_PREFETCH_SHIFT)
+			| (1 << L2X0_AUX_CTRL_INSTR_PREFETCH_SHIFT),  ~0);
 
 	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
 }
 
 void ambarella_restart_machine(char mode, const char *cmd)
 {
-#if defined(CONFIG_AMBARELLA_SUPPORT_BAPI)
-	struct ambarella_bapi_reboot_info_s	reboot_info;
-
-	reboot_info.magic = DEFAULT_BAPI_REBOOT_MAGIC;
-	reboot_info.mode = AMBARELLA_BAPI_CMD_REBOOT_NORMAL;
-	if (cmd) {
-		if(strcmp(cmd, "recovery") == 0) {
-			reboot_info.mode = AMBARELLA_BAPI_CMD_REBOOT_RECOVERY;
-		} else if(strcmp(cmd, "fastboot") == 0) {
-			reboot_info.mode = AMBARELLA_BAPI_CMD_REBOOT_FASTBOOT;
-		}
-	}
-	ambarella_bapi_cmd(AMBARELLA_BAPI_CMD_SET_REBOOT_INFO, &reboot_info);
-#endif
-
 	local_irq_disable();
 	local_fiq_disable();
 	flush_cache_all();
diff --git a/arch/arm/mach-ambarella/misc/Makefile b/arch/arm/mach-ambarella/misc/Makefile
index ae4c5e0..69224ee 100644
--- a/arch/arm/mach-ambarella/misc/Makefile
+++ b/arch/arm/mach-ambarella/misc/Makefile
@@ -24,14 +24,12 @@ obj-y						+= hwlock.o
 obj-y						+= audio.o
 obj-$(CONFIG_PLAT_AMBARELLA_SUPPORT_GDMA)	+= gdma.o
 obj-y						+= ambasyncproc.o
-obj-y						+= ambcache.o
 obj-$(CONFIG_AMBARELLA_SUPPORT_AMBENCH)		+= ambench.o
 obj-y						+= ambevent.o
 obj-y						+= ambfb.o
 obj-y						+= ambsyncproc.o
-obj-$(CONFIG_AMBARELLA_SUPPORT_BAPI)		+= bapi.o
 obj-y						+= event.o
-obj-y						+= service.o
+obj-y						+= iav_helper.o
 obj-$(CONFIG_AMBARELLA_TIMER_HIGHRES)		+= highres_timer.o
 obj-y						+= pmu.o
 
diff --git a/arch/arm/mach-ambarella/misc/ambfb.c b/arch/arm/mach-ambarella/misc/ambfb.c
index 9c51e38..4683653 100644
--- a/arch/arm/mach-ambarella/misc/ambfb.c
+++ b/arch/arm/mach-ambarella/misc/ambfb.c
@@ -207,36 +207,6 @@ int ambarella_fb_set_iav_info(u32 fb_id, struct ambarella_fb_iav_info *iav)
 }
 EXPORT_SYMBOL(ambarella_fb_set_iav_info);
 
-int ambarella_fb_update_info(u32 fb_id, int xres, int yres,
-		int xvirtual, int yvirtual, int format, u32 bits_per_pixel,
-		u32 smem_start, u32 smem_len)
-{
-	struct ambarella_platform_fb *ambfb_data;
-
-	if (fb_id > ARRAY_SIZE(ambfb_data_ptr))
-		return -EPERM;
-
-	ambfb_data = ambfb_data_ptr[fb_id];
-
-	mutex_lock(&ambfb_data->lock);
-	ambfb_data->screen_var.xres = xres;
-	ambfb_data->screen_var.yres = yres;
-	ambfb_data->screen_var.xres_virtual = xvirtual;
-	ambfb_data->screen_var.yres_virtual = yvirtual;
-	ambfb_data->screen_var.bits_per_pixel = bits_per_pixel;
-	ambfb_data->color_format = format;
-	ambfb_data->use_prealloc = 1;
-	ambfb_data->screen_fix.smem_start = smem_start;
-	ambfb_data->screen_fix.smem_len = smem_len;
-	mutex_unlock(&ambfb_data->lock);
-
-	pr_debug("%s %d: %dx%d %dx%d %d %d 0x%08x:0x%08x\n", __func__, fb_id,
-		xres, yres, xvirtual, yvirtual,
-		format, bits_per_pixel, smem_start, smem_len);
-
-	return 0;
-}
-
 int __init ambarella_init_fb(void)
 {
 	struct ambarella_platform_fb *ambfb_data;
diff --git a/arch/arm/mach-ambarella/misc/gdma.c b/arch/arm/mach-ambarella/misc/gdma.c
index 95c5c68..81c0bc67 100644
--- a/arch/arm/mach-ambarella/misc/gdma.c
+++ b/arch/arm/mach-ambarella/misc/gdma.c
@@ -28,11 +28,9 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
-
 #include <mach/hardware.h>
 #include <mach/init.h>
-
-#include <plat/ambcache.h>
+#include <plat/iav_helper.h>
 #include <plat/gdma.h>
 
 #define TRANSFER_2D_WIDTH		(1 << 12 )		/* 4096 */
diff --git a/arch/arm/mach-ambarella/misc/iav_helper.c b/arch/arm/mach-ambarella/misc/iav_helper.c
new file mode 100644
index 0000000..85fcbfa
--- /dev/null
+++ b/arch/arm/mach-ambarella/misc/iav_helper.c
@@ -0,0 +1,211 @@
+/*
+ * arch/arm/plat-ambarella/misc/service.c
+ *
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ *
+ * Copyright (C) 2012-2016, Ambarella, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <plat/iav_helper.h>
+#include <mach/init.h>
+
+
+
+/*===========================================================================*/
+
+static LIST_HEAD(ambarella_svc_list);
+
+int ambarella_register_service(struct ambarella_service *amb_svc)
+{
+	struct ambarella_service *svc;
+
+	if (!amb_svc || !amb_svc->func)
+		return -EINVAL;
+
+	list_for_each_entry(svc, &ambarella_svc_list, node) {
+		if (svc->service == amb_svc->service) {
+			pr_err("%s: service (%d) is already existed\n",
+					__func__, amb_svc->service);
+			return -EEXIST;
+		}
+	}
+
+	list_add_tail(&amb_svc->node, &ambarella_svc_list);
+
+	return 0;
+}
+EXPORT_SYMBOL(ambarella_register_service);
+
+int ambarella_unregister_service(struct ambarella_service *amb_svc)
+{
+	struct ambarella_service *svc;
+
+	if (!amb_svc)
+		return -EINVAL;
+
+	list_for_each_entry(svc, &ambarella_svc_list, node) {
+		if (svc->service == amb_svc->service) {
+			list_del(&svc->node);
+			break;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ambarella_unregister_service);
+
+int ambarella_request_service(int service, void *arg, void *result)
+{
+	struct ambarella_service *svc;
+	int found = 0;
+
+	list_for_each_entry(svc, &ambarella_svc_list, node) {
+		if (svc->service == service) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (found == 0) {
+		pr_err("%s: no such service (%d)\n", __func__, service);
+		return -ENODEV;
+	}
+
+	return svc->func(arg, result);
+}
+EXPORT_SYMBOL(ambarella_request_service);
+
+/*===========================================================================*/
+
+#define CACHE_LINE_SIZE		32
+#define CACHE_LINE_MASK		~(CACHE_LINE_SIZE - 1)
+
+void ambcache_clean_all(void *addr, unsigned int size)
+{
+	u32					vstart;
+	u32					vend;
+#ifdef CONFIG_OUTER_CACHE
+	u32					pstart;
+#endif
+	//u32					addr_tmp;
+        u32 set, way;
+        u32 reg_data;
+        u32 sscidr = 0;
+        u32 value_set = 0,value_way = 0;
+
+	vstart = (u32)addr & CACHE_LINE_MASK;
+	vend = ((u32)addr + size + CACHE_LINE_SIZE - 1) & CACHE_LINE_MASK;
+
+#ifdef CONFIG_OUTER_CACHE
+	pstart = ambarella_virt_to_phys(vstart);
+#endif
+
+        /*format of SSCIDR*/
+        /* |31 |30  |29|28 |27-13    |12-3 |2-0    |*/
+        /* |WT|WB|RA|WA|NumSets|Ways|Linsize|*/
+        asm volatile("mrc p15, 1, %0, c0, c0, 0" : "=r" (sscidr));
+        value_set = ((sscidr & 0x0FFFE000)>>13);
+        value_way =((sscidr & 0x00001FF8)>>3);
+        //printk("\033[31m[%s][%d]  cache SSCIDR (0x%x), Set(%d),Way(%d)\033[0m\n",__FILE__,__LINE__,sscidr,value_set,value_way);
+
+        /* Cache level 1 */
+        for (way = 0; way <= value_way; way++) {
+                /* Way, bits[31:30], the number of the way to operate on. */
+                for (set = 0; set <=value_set; set++) {
+                        /* Set, bits[13:6], the number of the set to operate on. */
+                        /* clean cache lines in all ways */
+                        reg_data = (way << 30) | (set << 5);
+                        __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 2"
+                        :
+                        : "r" (reg_data)
+                        : );
+                }
+        }
+        dsb();
+
+#ifdef CONFIG_OUTER_CACHE
+	outer_clean_range(pstart, (pstart + size));
+#endif
+}
+
+void ambcache_clean_range(void *addr, unsigned int size)
+{
+	u32					vstart;
+	u32					vend;
+#ifdef CONFIG_OUTER_CACHE
+	u32					pstart;
+#endif
+	u32					addr_tmp;
+
+	vstart = (u32)addr & CACHE_LINE_MASK;
+	vend = ((u32)addr + size + CACHE_LINE_SIZE - 1) & CACHE_LINE_MASK;
+
+#ifdef CONFIG_OUTER_CACHE
+	pstart = ambarella_virt_to_phys(vstart);
+#endif
+	for (addr_tmp = vstart; addr_tmp < vend; addr_tmp += CACHE_LINE_SIZE) {
+		__asm__ __volatile__ (
+			"mcr p15, 0, %0, c7, c10, 1" : : "r" (addr_tmp));
+	}
+	dsb();
+
+#ifdef CONFIG_OUTER_CACHE
+	outer_clean_range(pstart, (pstart + size));
+#endif
+}
+EXPORT_SYMBOL(ambcache_clean_range);
+EXPORT_SYMBOL(ambcache_clean_all);
+
+void ambcache_inv_range(void *addr, unsigned int size)
+{
+	u32					vstart;
+	u32					vend;
+#ifdef CONFIG_OUTER_CACHE
+	u32					pstart;
+#endif
+	u32					addr_tmp;
+
+	vstart = (u32)addr & CACHE_LINE_MASK;
+	vend = ((u32)addr + size + CACHE_LINE_SIZE - 1) & CACHE_LINE_MASK;
+
+#ifdef CONFIG_OUTER_CACHE
+	pstart = ambarella_virt_to_phys(vstart);
+	outer_inv_range(pstart, (pstart + size));
+#endif
+
+	for (addr_tmp = vstart; addr_tmp < vend; addr_tmp += CACHE_LINE_SIZE) {
+		__asm__ __volatile__ (
+			"mcr p15, 0, %0, c7, c6, 1" : : "r" (addr_tmp));
+	}
+	dsb();
+
+#ifdef CONFIG_OUTER_CACHE
+	outer_inv_range(pstart, (pstart + size));
+
+	for (addr_tmp = vstart; addr_tmp < vend; addr_tmp += CACHE_LINE_SIZE) {
+		__asm__ __volatile__ (
+			"mcr p15, 0, %0, c7, c6, 1" : : "r" (addr_tmp));
+	}
+	dsb();
+#endif
+}
+EXPORT_SYMBOL(ambcache_inv_range);
+
+
diff --git a/arch/arm/mach-ambarella/pm.c b/arch/arm/mach-ambarella/pm.c
index d99d3be..13c22dd 100644
--- a/arch/arm/mach-ambarella/pm.c
+++ b/arch/arm/mach-ambarella/pm.c
@@ -40,34 +40,27 @@
 #include <mach/init.h>
 #include <plat/drctl.h>
 #include <plat/rtc.h>
-#include <plat/ambcache.h>
+#include <plat/fio.h>
 
 #define SREF_MAGIC_PATTERN		0x43525230
+#define SREF_CPU_JUMP_ADDR		0x000f1000
 
 static int dram_reset_ctrl = -1;
+static int gpio_notify_mcu = -1;
+static int hibernate_gpio_notify_mcu = -1;
+extern int ambarella_suspend_trigger_signal[];
 
-/* ==========================================================================*/
-void ambarella_power_off(void)
-{
-	amba_rct_setbitsl(ANA_PWR_REG, ANA_PWR_POWER_DOWN);
-}
-
-void ambarella_power_off_prepare(void)
-{
-}
+u32 gpio_regbase[] = {GPIO0_BASE, GPIO1_BASE, GPIO2_BASE, GPIO3_BASE,
+	GPIO4_BASE, GPIO5_BASE, GPIO6_BASE};
 
+static unsigned long ambarella_gpio_setup(int);
 /* ==========================================================================*/
-static void ambarella_disconnect_dram_reset(void)
+void ambarella_pm_gpiomux(int gpio)
 {
 	u32 bank, offset;
-	u32 gpio_regbase[] = {GPIO0_BASE, GPIO1_BASE, GPIO2_BASE, GPIO3_BASE,
-				GPIO4_BASE, GPIO5_BASE, GPIO6_BASE};
 
-	if (dram_reset_ctrl == -1)
-		return;
-
-	bank = PINID_TO_BANK(dram_reset_ctrl);
-	offset = PINID_TO_OFFSET(dram_reset_ctrl);
+	bank = PINID_TO_BANK(gpio);
+	offset = PINID_TO_OFFSET(gpio);
 
 #if (IOMUX_SUPPORT > 0)
 	/* configure the pin as GPIO mode */
@@ -78,12 +71,88 @@ static void ambarella_disconnect_dram_reset(void)
 	amba_writel(IOMUX_REG(IOMUX_CTRL_SET_OFFSET), 0x0);
 #endif
 
-	/* pull low the gpio */
+}
+void ambarella_pm_gpio_output(int gpio, int value)
+{
+	u32 bank, offset;
+
+	bank = PINID_TO_BANK(gpio);
+	offset = PINID_TO_OFFSET(gpio);
+
 	amba_writel(gpio_regbase[bank] + GPIO_ENABLE_OFFSET, 0xffffffff);
 	amba_clrbitsl(gpio_regbase[bank] + GPIO_AFSEL_OFFSET, 0x1 << offset);
 	amba_setbitsl(gpio_regbase[bank] + GPIO_MASK_OFFSET, 0x1 << offset);
 	amba_setbitsl(gpio_regbase[bank] + GPIO_DIR_OFFSET, 0x1 << offset);
-	amba_clrbitsl(gpio_regbase[bank] + GPIO_DATA_OFFSET, 0x1 << offset);
+
+	if (!!value)
+		amba_setbitsl(gpio_regbase[bank] + GPIO_DATA_OFFSET, 0x1 << offset);
+	else
+		amba_clrbitsl(gpio_regbase[bank] + GPIO_DATA_OFFSET, 0x1 << offset);
+}
+
+void ambarella_pm_gpio_input(int gpio, int *value)
+{
+	u32 bank, offset;
+
+	bank = PINID_TO_BANK(gpio);
+	offset = PINID_TO_OFFSET(gpio);
+
+	amba_writel(gpio_regbase[bank] + GPIO_ENABLE_OFFSET, 0xffffffff);
+	amba_clrbitsl(gpio_regbase[bank] + GPIO_AFSEL_OFFSET, 0x1 << offset);
+	amba_setbitsl(gpio_regbase[bank] + GPIO_MASK_OFFSET, 0x1 << offset);
+	amba_clrbitsl(gpio_regbase[bank] + GPIO_DIR_OFFSET, 0x1 << offset);
+
+	*value = !!(amba_readl(gpio_regbase[bank] + GPIO_DATA_OFFSET) & 0x1 << offset);
+}
+
+/* ==========================================================================*/
+void ambarella_power_off(void)
+{
+	if (!ambarella_gpio_setup(hibernate_gpio_notify_mcu))
+		return;
+
+	ambarella_pm_gpio_output(hibernate_gpio_notify_mcu, 1);
+	mdelay(100);
+	ambarella_pm_gpio_output(hibernate_gpio_notify_mcu, 0);
+
+	amba_rct_setbitsl(ANA_PWR_REG, ANA_PWR_POWER_DOWN);
+}
+
+void ambarella_power_off_prepare(void)
+{
+
+}
+
+/* ==========================================================================*/
+static void ambarella_disconnect_dram_reset(void)
+{
+
+	if (dram_reset_ctrl == -1)
+		return;
+
+	ambarella_pm_gpiomux(dram_reset_ctrl);
+
+	ambarella_pm_gpio_output(dram_reset_ctrl, 0);
+}
+
+static unsigned long ambarella_gpio_setup(int gpio)
+{
+	unsigned long gpio_info;
+	u32 bank, offset;
+
+	if (gpio == -1)
+		return 0;
+
+	bank = PINID_TO_BANK(gpio);
+	offset = PINID_TO_OFFSET(gpio);
+
+	gpio_info = gpio_regbase[bank] | offset;
+
+	/* Mux GPIO output mode */
+	ambarella_pm_gpio_output(gpio, !ambarella_suspend_trigger_signal[0]);
+	ambarella_pm_gpiomux(gpio);
+
+	return gpio_info;
 }
 
 static void ambarella_set_cpu_jump(int cpu, void *jump_fn)
@@ -92,7 +161,7 @@ static void ambarella_set_cpu_jump(int cpu, void *jump_fn)
 	u32 *addr_virt;
 
 	/* must keep consistent with self_refresh.c in bst. */
-	addr_phys = get_ambarella_ppm_phys() + 0x000f1000;
+	addr_phys = get_ambarella_ppm_phys() + SREF_CPU_JUMP_ADDR;
 	addr_virt = (u32 *)ambarella_phys_to_virt(addr_phys);
 	*addr_virt++ = SREF_MAGIC_PATTERN;
 	*addr_virt = virt_to_phys(jump_fn);
@@ -113,37 +182,99 @@ static int ambarella_pm_enter_standby(void)
 	return 0;
 }
 
-static int ambarella_pm_enter_mem(void)
+static void ambarella_pm_rtc_flush(void)
 {
-	u32 l2_enabled;
+	unsigned int alarm;
+	unsigned int time;
 
-	ambarella_disconnect_dram_reset();
+	alarm = amba_readl(RTC_REG(RTC_ALAT_OFFSET));
+	amba_writel(RTC_REG(RTC_PWC_ALAT_OFFSET), alarm);
+	time  = amba_readl(RTC_REG(RTC_CURT_OFFSET));
+	amba_writel(RTC_REG(RTC_PWC_CURT_OFFSET), time);
+}
 
+static unsigned long ambarella_pm_pwc_trigger(void)
+{
 	/* ensure the power for DRAM keeps on when power off PWC */
 	amba_writel(RTC_REG(RTC_PWC_ENP3_OFFSET), 0x1);
+	amba_writel(RTC_REG(RTC_POS0_OFFSET), 0x10);
+	amba_writel(RTC_REG(RTC_POS1_OFFSET), 0x10);
+	amba_writel(RTC_REG(RTC_POS2_OFFSET), 0x10);
+	amba_writel(RTC_REG(RTC_POS3_OFFSET), 0x10);
 	amba_setbitsl(RTC_REG(RTC_PWC_SET_STATUS_OFFSET), 0x04);
+
+	ambarella_pm_rtc_flush();
+
 	amba_writel(RTC_REG(RTC_RESET_OFFSET), 0x1);
 	mdelay(3);
 	amba_writel(RTC_REG(RTC_RESET_OFFSET), 0x0);
 
-	ambarella_set_cpu_jump(0, ambarella_cpu_resume);
-
-	l2_enabled = outer_is_enabled();
-	if (l2_enabled)
-		ambcache_l2_disable_raw();
-
-	cpu_suspend(0, ambarella_finish_suspend);
-
-	if (l2_enabled)
-		ambcache_l2_enable_raw();
-
+	return 0;
+}
+static void ambarella_pm_pwc_resume(void)
+{
 	/* ensure to power off all powers when power off PWC */
 	amba_writel(RTC_REG(RTC_PWC_ENP3_OFFSET), 0x0);
 	amba_clrbitsl(RTC_REG(RTC_PWC_SET_STATUS_OFFSET), 0x04);
+
+	ambarella_pm_rtc_flush();
+
 	amba_writel(RTC_REG(RTC_RESET_OFFSET), 0x1);
 	while(amba_readl(RTC_REG(RTC_PWC_REG_STA_OFFSET)) & 0x04);
 	amba_writel(RTC_REG(RTC_RESET_OFFSET), 0x0);
 
+}
+
+static unsigned long ambarella_pm_io_trigger(void)
+{
+	/* FIXME: flush internel rtc on chips, even though it is disabled. Because
+	 * it has no unexpected effect on system */
+	ambarella_pm_rtc_flush();
+
+	return ambarella_gpio_setup(gpio_notify_mcu);
+}
+
+static void ambarella_pm_io_resume(void)
+{
+	ambarella_pm_rtc_flush();
+}
+
+static int ambarella_pm_enter_mem(void)
+{
+	unsigned long arg = 0;
+#ifdef CONFIG_AMBARELLA_SREF_FIFO_EXEC
+	void *ambarella_suspend_exec = NULL;
+#endif
+
+	ambarella_disconnect_dram_reset();
+
+	if (gpio_notify_mcu == -1)
+		arg = ambarella_pm_pwc_trigger();
+	else
+		arg = ambarella_pm_io_trigger();
+
+	ambarella_set_cpu_jump(0, ambarella_cpu_resume);
+
+#ifdef CONFIG_AMBARELLA_SREF_FIFO_EXEC
+	ambarella_suspend_exec = ambarella_fio_push(ambarella_optimize_suspend,
+			ambarella_optimize_suspend_sz);
+#endif
+	outer_flush_all();
+	outer_disable();
+
+#ifdef CONFIG_AMBARELLA_SREF_FIFO_EXEC
+	cpu_suspend(arg, ambarella_suspend_exec);
+#else
+	cpu_suspend(0, ambarella_finish_suspend);
+#endif
+
+	outer_resume();
+
+	if (gpio_notify_mcu == -1)
+		ambarella_pm_pwc_resume();
+	else
+		ambarella_pm_io_resume();
+
 	return 0;
 }
 
@@ -200,7 +331,16 @@ int __init ambarella_init_pm(void)
 	suspend_set_ops(&ambarella_pm_suspend_ops);
 
 	of_property_read_u32(of_chosen, "ambarella,dram-reset-ctrl", &dram_reset_ctrl);
-	WARN(dram_reset_ctrl >= GPIO_MAX_LINES, "Invalid GPIO: %d\n", dram_reset_ctrl);
+	of_property_read_u32(of_chosen, "ambarella,gpio-notify-mcu", &gpio_notify_mcu);
+	of_property_read_u32(of_chosen, "ambarella,hibernate-gpio-notify-mcu", &hibernate_gpio_notify_mcu);
+	ambarella_suspend_trigger_signal[0] = !!of_find_property(of_chosen,
+			"ambarella,gpio-trigger-high", NULL);
+
+	WARN(dram_reset_ctrl >= GPIO_MAX_LINES, "Invalid DRAM RESET GPIO: %d\n", dram_reset_ctrl);
+	WARN(gpio_notify_mcu >= GPIO_MAX_LINES, "Invalid MCU NOTIFY GPIO: %d\n", gpio_notify_mcu);
+
+	pr_info("Ambarella power management: Wed Aug 10 2016 %s\n",
+			(gpio_notify_mcu == -1) ? "": ambarella_suspend_trigger_signal[0] ? "[positive edge]":"[negative edge]");
 
 	return 0;
 }
diff --git a/arch/arm/mach-ambarella/sleep.S b/arch/arm/mach-ambarella/sleep.S
index 7d53dc4..b799c78 100644
--- a/arch/arm/mach-ambarella/sleep.S
+++ b/arch/arm/mach-ambarella/sleep.S
@@ -32,20 +32,90 @@
 	.text
 
 ENTRY(ambarella_finish_suspend)
-	/*
-	 * Execute DSB and ISB instruction to ensure that all of the
-	 * memory accesses have been completed.
+	isb
+	dsb
+	mov r0, #0
+	ldr	r1, =(DRAMC_BASE + DRAM_DDRC_OFFSET)
+	ldr	r2, =ANA_PWR_REG
+
+	teq	r0, r0
+	bl _ambarella_finish_suspend
+	teq	pc,	r0
+	bl _ambarella_finish_suspend
+
+ENDPROC(ambarella_finish_suspend)
+
+	/* _ambarella_finish_suspend will be called twice. first is to makesure the
+	 * instructions loading in the I-Cache, and the second is to disconnect cpu
+	 * with dram, enter self refresh, and power down PWC.
 	 */
+ENTRY(_ambarella_finish_suspend)
+	ldrne	r3, [r1, #DDRC_CTL_OFFSET]
+	bicne	r3, r3, #0x1
+	strne	r3, [r1, #DDRC_CTL_OFFSET]
+	movne	r3, #0x80000000
+	strne	r3, [r1, #DDRC_SELF_REF_OFFSET]
+
+	movne	r3, #ANA_PWR_POWER_DOWN
+	strne	r3, [r2]
+	moveq	pc, lr
+	b		.
+
+ENDPROC(_ambarella_finish_suspend)
+
+ENTRY(ambarella_optimize_suspend)
 	dsb
 	isb
-	nop
 
-	/*
-	 * Following codes have to run from cache since
-	 * the DRAM is going to self refresh mode
-	 */
-	.align	L1_CACHE_SHIFT
-	ldr	r0, =(DRAMC_BASE + DRAM_DDRC_OFFSET)
+	mov	r1, #0
+	cmp	r0, r1
+	beq	suspend_with_pwc
+
+	mov	r1, r0
+	mov	r2, #0x1f
+	bic	r0, r2			/* r0 gpio bank base */
+	and	r1, r2			/* r1 gpio offset */
+
+	ldr	r2, ambarella_suspend_trigger_signal
+	lsl	r2, r1
+	str	r2, [r0, #0]
+
+	/* delay 100ms: 0x249F00 is about 0x250000 */
+	mov	r3, #0x250000
+
+	mov	r4,	#RCT_BUS_BASE
+	orr	r4, #RCT_OFFSET
+	orr	r4,	#RCT_TIMER_OFFSET
+	ldr	r5,	[r4]
+	add	r5, r5, r3
+rct_time_loop:
+	ldr	r6,	[r4]
+	cmp	r5, r6
+	bhi	rct_time_loop
+
+	ldr	r2, ambarella_suspend_trigger_signal
+	eor r2, r2, #1
+	lsl	r2, r1
+	str	r2, [r0, #0]
+
+	b	self_refresh
+
+suspend_with_pwc:
+	mov	r0,	#RCT_BUS_BASE
+	orr	r0, #RCT_OFFSET
+	orr	r0, #ANA_PWR_OFFSET
+
+	/* Generate the PD signal */
+	mov	r1, #ANA_PWR_POWER_DOWN
+	str	r1, [r0]
+
+self_refresh:
+	/* CPU use the delay interval between power-down signal PD
+	   and PWC_RSTOB to execute the following code */
+
+	mov	r0, #DRAMC_BASE
+	orr	r0, r0, #DRAM_DDRC_OFFSET
+
 	ldr	r1, [r0, #DDRC_CTL_OFFSET]
 	bic	r1, r1, #0x1
 	str	r1, [r0, #DDRC_CTL_OFFSET]
@@ -56,15 +126,17 @@ ENTRY(ambarella_finish_suspend)
 	tst	r1, #0x10000000
 	beq	1b
 
-	/* now turn off PWC */
-	ldr	r0, =ANA_PWR_REG
-	mov	r1, #ANA_PWR_POWER_DOWN
-	str	r1, [r0]
+	/* Wait for PWC_RSTOB signal to power down cpu */
+	b	.
 
-	/* never get here */
-2:	b	2b
+ENDPROC(ambarella_optimize_suspend)
 
-ENDPROC(ambarella_finish_suspend)
+.globl ambarella_suspend_trigger_signal
+ambarella_suspend_trigger_signal:
+	.word	0x00000000
+
+ENTRY(ambarella_optimize_suspend_sz)
+	.word 	. - ambarella_optimize_suspend
 
 #if (CHIP_REV == S3)
 #define	IOMUX_UART0_PIN_CFG	0x00000030
@@ -121,6 +193,13 @@ ENTRY(ambarella_cpu_resume)
 	ldr	r1, [r0, #GPIO_AFSEL_OFFSET]
 	orr	r1, #0x0000c000
 	str	r1, [r0, #GPIO_AFSEL_OFFSET]
+
+#if (CHIP_REV == S2E)
+	ldr	r0, =RCT_PHYS_BASE
+	mov r1, #UART_CLK_SRC_IDSP
+	str	r1, [r0, #UART_CLK_SRC_SEL_OFFSET]
+#endif
+
 #endif
 	/* jump to generic resume */
 	b	cpu_resume
diff --git a/arch/arm/mach-ambarella/smp/smp.c b/arch/arm/mach-ambarella/smp/smp.c
index 1188b53..138bd80 100644
--- a/arch/arm/mach-ambarella/smp/smp.c
+++ b/arch/arm/mach-ambarella/smp/smp.c
@@ -44,6 +44,7 @@ static DEFINE_SPINLOCK(boot_lock);
 
 static u32 *cpux_jump_virt = NULL;
 extern void ambarella_secondary_startup(void);
+extern void ambvic_smp_softirq_init(void);
 
 
 /* Write pen_release in a way that is guaranteed to be visible to all
@@ -63,8 +64,8 @@ static void write_cpux_jump_addr(unsigned int cpu, int addr)
 	smp_wmb();
 	__cpuc_flush_dcache_area(
 		&cpux_jump_virt[cpu], sizeof(cpux_jump_virt[cpu]));
-	outer_clean_range(
-		__pa(&cpux_jump_virt[cpu]), __pa(&cpux_jump_virt[cpu] + 1));
+	outer_clean_range(ambarella_virt_to_phys((u32)&cpux_jump_virt[cpu]),
+			ambarella_virt_to_phys((u32)&cpux_jump_virt[cpu] + 1));
 }
 
 /* running on CPU1 */
@@ -78,7 +79,6 @@ static void __cpuinit ambarella_smp_secondary_init(unsigned int cpu)
 	spin_lock(&boot_lock);
 	spin_unlock(&boot_lock);
 }
-
 /* running on CPU0 */
 static int __cpuinit ambarella_smp_boot_secondary(unsigned int cpu,
 	struct task_struct *idle)
@@ -88,6 +88,8 @@ static int __cpuinit ambarella_smp_boot_secondary(unsigned int cpu,
 
 	BUG_ON(cpux_jump_virt == NULL);
 
+	scu_enable(scu_base);
+
 	/* Set synchronisation state between this boot processor
 	 * and the secondary one */
 	spin_lock(&boot_lock);
@@ -100,13 +102,19 @@ static int __cpuinit ambarella_smp_boot_secondary(unsigned int cpu,
 	 * "cpu" is Linux's internal ID. */
 	write_pen_release(phys_cpu);
 
+	write_cpux_jump_addr(cpu, virt_to_phys(ambarella_secondary_startup));
+
+#ifdef CONFIG_PLAT_AMBARELLA_SUPPORT_VIC
+	/* IPI interrupt on CPU1 may be unmasked, so this init is necessary */
+	ambvic_smp_softirq_init();
+#endif
+
 	/* Send the secondary CPU a soft interrupt, thereby causing
 	 * the boot monitor to read the system wide flags register,
 	 * and branch to the address found there. */
 	timeout = jiffies + (1 * HZ);
 	while (time_before(jiffies, timeout)) {
 		smp_rmb();
-		write_cpux_jump_addr(cpu, virt_to_phys(ambarella_secondary_startup));
 
 		arch_send_wakeup_ipi_mask(cpumask_of(cpu));
 
@@ -209,7 +217,7 @@ static inline void platform_do_lowpower(unsigned int cpu, int *spurious)
 	for (;;) {
 		wfi();
 
-		if (pen_release == cpu) {
+		if (pen_release == cpu_logical_map(cpu)) {
 			/* OK, proper wakeup, we're done */
 			break;
 		}
diff --git a/arch/arm/mach-ambarella/soc/Makefile b/arch/arm/mach-ambarella/soc/Makefile
index 2ecca26..0e32c6f 100644
--- a/arch/arm/mach-ambarella/soc/Makefile
+++ b/arch/arm/mach-ambarella/soc/Makefile
@@ -26,4 +26,5 @@ obj-$(CONFIG_PLAT_AMBARELLA_S2_CORTEX)			+= s2-cortex.o
 obj-$(CONFIG_PLAT_AMBARELLA_S2E)			+= s2e.o
 obj-$(CONFIG_PLAT_AMBARELLA_S2L)			+= s2l.o
 obj-$(CONFIG_PLAT_AMBARELLA_S3)				+= s3.o
+obj-$(CONFIG_PLAT_AMBARELLA_S3L)			+= s3l.o
 
diff --git a/arch/arm/mach-ambarella/timer.c b/arch/arm/mach-ambarella/timer.c
index 3bd5f46..167c9f7 100644
--- a/arch/arm/mach-ambarella/timer.c
+++ b/arch/arm/mach-ambarella/timer.c
@@ -112,10 +112,13 @@ static void ambarella_timer_resume(u32 is_ce)
 
 	amb_timer_pm->clk_rate = clk_rate;
 
-	if (is_ce)
+	if (is_ce) {
 		clockevents_update_freq(clkevt, clk_rate);
-	else
+	} else {
+		clocksource_change_rating(clksrc, 0);
 		__clocksource_updatefreq_hz(clksrc, clk_rate);
+		clocksource_change_rating(clksrc, AMBARELLA_TIMER_RATING);
+	}
 
 resume_exit:
 	amba_setbitsl(ctrl_reg, amb_timer_pm->ctrl_reg << ctrl_offset);
@@ -306,13 +309,11 @@ static int ambarella_timer_system_event(struct notifier_block *nb,
 
 	case AMBA_EVENT_POST_CPUFREQ:
 		local_irq_save(flags);
-		/* I try to update timer using clockevents_update_freq(&ambarella_clkevt, AMBARELLA_TIMER_FREQ)
-		 * and __clocksource_updatefreq_hz(&ambarella_clksrc, AMBARELLA_TIMER_FREQ), but they both can not work,
-		 * So I try the clocksource_unregister(), and then call clocksource_register_hz(), it seems like it is
-		 * ok for updating the timer.
-		 */
-		clocksource_unregister(&ambarella_clksrc);
-		clocksource_register_hz(&ambarella_clksrc, AMBARELLA_TIMER_FREQ);
+		clockevents_update_freq(&ambarella_clkevt, AMBARELLA_TIMER_FREQ);
+
+		clocksource_change_rating(&ambarella_clksrc, 0);
+		__clocksource_updatefreq_hz(&ambarella_clksrc, AMBARELLA_TIMER_FREQ);
+		clocksource_change_rating(&ambarella_clksrc, AMBARELLA_TIMER_RATING);
 		local_irq_restore(flags);
 		up(&(amba_timer_notifier.system_event_sem));
 		break;
diff --git a/arch/arm/mach-dove/common.c b/arch/arm/mach-dove/common.c
index e2b5da0..8d4f5dc 100644
--- a/arch/arm/mach-dove/common.c
+++ b/arch/arm/mach-dove/common.c
@@ -226,7 +226,7 @@ void __init dove_init_early(void)
 	orion_time_set_base(TIMER_VIRT_BASE);
 	mvebu_mbus_init("marvell,dove-mbus",
 			BRIDGE_WINS_BASE, BRIDGE_WINS_SZ,
-			DOVE_MC_WINS_BASE, DOVE_MC_WINS_SZ);
+			DOVE_MC_WINS_BASE, DOVE_MC_WINS_SZ, 0);
 }
 
 static int __init dove_find_tclk(void)
diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index 2acaded..ed00c9e 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -515,7 +515,7 @@ int __init mx6q_clocks_init(void)
 	clk[gpmi_io]      = imx_clk_gate2("gpmi_io",       "enfc",              base + 0x78, 28);
 	clk[gpmi_apb]     = imx_clk_gate2("gpmi_apb",      "usdhc3",            base + 0x78, 30);
 	clk[rom]          = imx_clk_gate2("rom",           "ahb",               base + 0x7c, 0);
-	clk[sata]         = imx_clk_gate2("sata",          "ipg",               base + 0x7c, 4);
+	clk[sata]         = imx_clk_gate2("sata",          "ahb",               base + 0x7c, 4);
 	clk[sdma]         = imx_clk_gate2("sdma",          "ahb",               base + 0x7c, 6);
 	clk[spba]         = imx_clk_gate2("spba",          "ipg",               base + 0x7c, 12);
 	clk[ssi1_ipg]     = imx_clk_gate2("ssi1_ipg",      "ipg",               base + 0x7c, 18);
diff --git a/arch/arm/mach-kirkwood/common.c b/arch/arm/mach-kirkwood/common.c
index f389228..4f6831e 100644
--- a/arch/arm/mach-kirkwood/common.c
+++ b/arch/arm/mach-kirkwood/common.c
@@ -530,7 +530,7 @@ void __init kirkwood_init_early(void)
 
 	mvebu_mbus_init("marvell,kirkwood-mbus",
 			BRIDGE_WINS_BASE, BRIDGE_WINS_SZ,
-			DDR_WINDOW_CPU_BASE, DDR_WINDOW_CPU_SZ);
+			DDR_WINDOW_CPU_BASE, DDR_WINDOW_CPU_SZ, 0);
 }
 
 int kirkwood_tclk;
diff --git a/arch/arm/mach-mv78xx0/common.c b/arch/arm/mach-mv78xx0/common.c
index 749a7f8..4722c98 100644
--- a/arch/arm/mach-mv78xx0/common.c
+++ b/arch/arm/mach-mv78xx0/common.c
@@ -337,11 +337,11 @@ void __init mv78xx0_init_early(void)
 	if (mv78xx0_core_index() == 0)
 		mvebu_mbus_init("marvell,mv78xx0-mbus",
 				BRIDGE_WINS_CPU0_BASE, BRIDGE_WINS_SZ,
-				DDR_WINDOW_CPU0_BASE, DDR_WINDOW_CPU_SZ);
+				DDR_WINDOW_CPU0_BASE, DDR_WINDOW_CPU_SZ, 0);
 	else
 		mvebu_mbus_init("marvell,mv78xx0-mbus",
 				BRIDGE_WINS_CPU1_BASE, BRIDGE_WINS_SZ,
-				DDR_WINDOW_CPU1_BASE, DDR_WINDOW_CPU_SZ);
+				DDR_WINDOW_CPU1_BASE, DDR_WINDOW_CPU_SZ, 0);
 }
 
 void __init_refok mv78xx0_timer_init(void)
diff --git a/arch/arm/mach-mvebu/armada-370-xp.c b/arch/arm/mach-mvebu/armada-370-xp.c
index 1c48890..4377c34 100644
--- a/arch/arm/mach-mvebu/armada-370-xp.c
+++ b/arch/arm/mach-mvebu/armada-370-xp.c
@@ -66,7 +66,8 @@ void __init armada_370_xp_init_early(void)
 			ARMADA_370_XP_MBUS_WINS_BASE,
 			ARMADA_370_XP_MBUS_WINS_SIZE,
 			ARMADA_370_XP_SDRAM_WINS_BASE,
-			ARMADA_370_XP_SDRAM_WINS_SIZE);
+			ARMADA_370_XP_SDRAM_WINS_SIZE,
+			coherency_available());
 
 #ifdef CONFIG_CACHE_L2X0
 	l2x0_of_init(0, ~0UL);
diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c
index 3ee701f..ea26ebb 100644
--- a/arch/arm/mach-mvebu/coherency.c
+++ b/arch/arm/mach-mvebu/coherency.c
@@ -137,6 +137,20 @@ static struct notifier_block mvebu_hwcc_platform_nb = {
 	.notifier_call = mvebu_hwcc_platform_notifier,
 };
 
+/*
+ * Keep track of whether we have IO hardware coherency enabled or not.
+ * On Armada 370's we will not be using it for example. We need to make
+ * that available [through coherency_available()] so the mbus controller
+ * doesn't enable the IO coherency bit in the attribute bits of the
+ * chip selects.
+ */
+static int coherency_enabled;
+
+int coherency_available(void)
+{
+	return coherency_enabled;
+}
+
 int __init coherency_init(void)
 {
 	struct device_node *np;
@@ -170,6 +184,7 @@ int __init coherency_init(void)
 		coherency_base = of_iomap(np, 0);
 		coherency_cpu_base = of_iomap(np, 1);
 		set_cpu_coherent(cpu_logical_map(smp_processor_id()), 0);
+		coherency_enabled = 1;
 		bus_register_notifier(&platform_bus_type,
 					&mvebu_hwcc_platform_nb);
 	}
diff --git a/arch/arm/mach-mvebu/coherency.h b/arch/arm/mach-mvebu/coherency.h
index 2f42813..1501a4e 100644
--- a/arch/arm/mach-mvebu/coherency.h
+++ b/arch/arm/mach-mvebu/coherency.h
@@ -19,6 +19,7 @@ int coherency_get_cpu_count(void);
 #endif
 
 int set_cpu_coherent(int cpu_id, int smp_group_id);
+int coherency_available(void);
 int coherency_init(void);
 
 #endif	/* __MACH_370_XP_COHERENCY_H */
diff --git a/arch/arm/mach-omap2/cpuidle34xx.c b/arch/arm/mach-omap2/cpuidle34xx.c
index e18709d..38e1bdc 100644
--- a/arch/arm/mach-omap2/cpuidle34xx.c
+++ b/arch/arm/mach-omap2/cpuidle34xx.c
@@ -34,6 +34,7 @@
 #include "pm.h"
 #include "control.h"
 #include "common.h"
+#include "soc.h"
 
 /* Mach specific information to be recorded in the C-state driver_data */
 struct omap3_idle_statedata {
@@ -322,6 +323,69 @@ static struct cpuidle_driver omap3_idle_driver = {
 	.safe_state_index = 0,
 };
 
+/*
+ * Numbers based on measurements made in October 2009 for PM optimized kernel
+ * with CPU freq enabled on device Nokia N900. Assumes OPP2 (main idle OPP,
+ * and worst case latencies).
+ */
+static struct cpuidle_driver omap3430_idle_driver = {
+	.name             = "omap3430_idle",
+	.owner            = THIS_MODULE,
+	.states = {
+		{
+			.enter		  = omap3_enter_idle_bm,
+			.exit_latency	  = 110 + 162,
+			.target_residency = 5,
+			.name		  = "C1",
+			.desc		  = "MPU ON + CORE ON",
+		},
+		{
+			.enter		  = omap3_enter_idle_bm,
+			.exit_latency	  = 106 + 180,
+			.target_residency = 309,
+			.name		  = "C2",
+			.desc		  = "MPU ON + CORE ON",
+		},
+		{
+			.enter		  = omap3_enter_idle_bm,
+			.exit_latency	  = 107 + 410,
+			.target_residency = 46057,
+			.name		  = "C3",
+			.desc		  = "MPU RET + CORE ON",
+		},
+		{
+			.enter		  = omap3_enter_idle_bm,
+			.exit_latency	  = 121 + 3374,
+			.target_residency = 46057,
+			.name		  = "C4",
+			.desc		  = "MPU OFF + CORE ON",
+		},
+		{
+			.enter		  = omap3_enter_idle_bm,
+			.exit_latency	  = 855 + 1146,
+			.target_residency = 46057,
+			.name		  = "C5",
+			.desc		  = "MPU RET + CORE RET",
+		},
+		{
+			.enter		  = omap3_enter_idle_bm,
+			.exit_latency	  = 7580 + 4134,
+			.target_residency = 484329,
+			.name		  = "C6",
+			.desc		  = "MPU OFF + CORE RET",
+		},
+		{
+			.enter		  = omap3_enter_idle_bm,
+			.exit_latency	  = 7505 + 15274,
+			.target_residency = 484329,
+			.name		  = "C7",
+			.desc		  = "MPU OFF + CORE OFF",
+		},
+	},
+	.state_count = ARRAY_SIZE(omap3_idle_data),
+	.safe_state_index = 0,
+};
+
 /* Public functions */
 
 /**
@@ -340,5 +404,8 @@ int __init omap3_idle_init(void)
 	if (!mpu_pd || !core_pd || !per_pd || !cam_pd)
 		return -ENODEV;
 
-	return cpuidle_register(&omap3_idle_driver, NULL);
+	if (cpu_is_omap3430())
+		return cpuidle_register(&omap3430_idle_driver, NULL);
+	else
+		return cpuidle_register(&omap3_idle_driver, NULL);
 }
diff --git a/arch/arm/mach-omap2/sleep34xx.S b/arch/arm/mach-omap2/sleep34xx.S
index d1dedc8..eafd120 100644
--- a/arch/arm/mach-omap2/sleep34xx.S
+++ b/arch/arm/mach-omap2/sleep34xx.S
@@ -203,23 +203,8 @@ save_context_wfi:
 	 */
 	ldr	r1, kernel_flush
 	blx	r1
-	/*
-	 * The kernel doesn't interwork: v7_flush_dcache_all in particluar will
-	 * always return in Thumb state when CONFIG_THUMB2_KERNEL is enabled.
-	 * This sequence switches back to ARM.  Note that .align may insert a
-	 * nop: bx pc needs to be word-aligned in order to work.
-	 */
- THUMB(	.thumb		)
- THUMB(	.align		)
- THUMB(	bx	pc	)
- THUMB(	nop		)
-	.arm
-
 	b	omap3_do_wfi
-
-/*
- * Local variables
- */
+ENDPROC(omap34xx_cpu_suspend)
 omap3_do_wfi_sram_addr:
 	.word omap3_do_wfi_sram
 kernel_flush:
@@ -364,10 +349,7 @@ exit_nonoff_modes:
  * ===================================
  */
 	ldmfd	sp!, {r4 - r11, pc}	@ restore regs and return
-
-/*
- * Local variables
- */
+ENDPROC(omap3_do_wfi)
 sdrc_power:
 	.word	SDRC_POWER_V
 cm_idlest1_core:
diff --git a/arch/arm/mach-orion5x/common.c b/arch/arm/mach-orion5x/common.c
index f8a6db9..04877392 100644
--- a/arch/arm/mach-orion5x/common.c
+++ b/arch/arm/mach-orion5x/common.c
@@ -213,7 +213,7 @@ void __init orion5x_init_early(void)
 		mbus_soc_name = NULL;
 	mvebu_mbus_init(mbus_soc_name, ORION5X_BRIDGE_WINS_BASE,
 			ORION5X_BRIDGE_WINS_SZ,
-			ORION5X_DDR_WINS_BASE, ORION5X_DDR_WINS_SZ);
+			ORION5X_DDR_WINS_BASE, ORION5X_DDR_WINS_SZ, 0);
 }
 
 void orion5x_setup_wins(void)
diff --git a/arch/arm/mach-realview/include/mach/memory.h b/arch/arm/mach-realview/include/mach/memory.h
index 2022e09..db09170 100644
--- a/arch/arm/mach-realview/include/mach/memory.h
+++ b/arch/arm/mach-realview/include/mach/memory.h
@@ -56,6 +56,8 @@
 #define PAGE_OFFSET1	(PAGE_OFFSET + 0x10000000)
 #define PAGE_OFFSET2	(PAGE_OFFSET + 0x30000000)
 
+#define PHYS_OFFSET PLAT_PHYS_OFFSET
+
 #define __phys_to_virt(phys)						\
 	((phys) >= 0x80000000 ?	(phys) - 0x80000000 + PAGE_OFFSET2 :	\
 	 (phys) >= 0x20000000 ?	(phys) - 0x20000000 + PAGE_OFFSET1 :	\
diff --git a/arch/arm/mach-s3c64xx/crag6410.h b/arch/arm/mach-s3c64xx/crag6410.h
index 4c3c999..81dc722 100644
--- a/arch/arm/mach-s3c64xx/crag6410.h
+++ b/arch/arm/mach-s3c64xx/crag6410.h
@@ -14,6 +14,7 @@
 #include <linux/gpio.h>
 
 #define GLENFARCLAS_PMIC_IRQ_BASE	IRQ_BOARD_START
+#define BANFF_PMIC_IRQ_BASE		(IRQ_BOARD_START + 64)
 
 #define PCA935X_GPIO_BASE		GPIO_BOARD_START
 #define CODEC_GPIO_BASE			(GPIO_BOARD_START + 8)
diff --git a/arch/arm/mach-s3c64xx/mach-crag6410.c b/arch/arm/mach-s3c64xx/mach-crag6410.c
index 8ad88ac..5fa9ac9 100644
--- a/arch/arm/mach-s3c64xx/mach-crag6410.c
+++ b/arch/arm/mach-s3c64xx/mach-crag6410.c
@@ -558,6 +558,7 @@ static struct wm831x_touch_pdata touch_pdata = {
 
 static struct wm831x_pdata crag_pmic_pdata = {
 	.wm831x_num = 1,
+	.irq_base = BANFF_PMIC_IRQ_BASE,
 	.gpio_base = BANFF_PMIC_GPIO_BASE,
 	.soft_shutdown = true,
 
diff --git a/arch/arm/mach-socfpga/headsmp.S b/arch/arm/mach-socfpga/headsmp.S
index 9004bfb..a6f5519 100644
--- a/arch/arm/mach-socfpga/headsmp.S
+++ b/arch/arm/mach-socfpga/headsmp.S
@@ -12,6 +12,7 @@
 
 	__CPUINIT
 	.arch	armv7-a
+	.arm
 
 ENTRY(secondary_trampoline)
 	movw	r2, #:lower16:cpu1start_addr
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 8ca636c..1a00c33 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -1355,12 +1355,19 @@ static int arm_iommu_mmap_attrs(struct device *dev, struct vm_area_struct *vma,
 	unsigned long uaddr = vma->vm_start;
 	unsigned long usize = vma->vm_end - vma->vm_start;
 	struct page **pages = __iommu_get_pages(cpu_addr, attrs);
+	unsigned long nr_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;
+	unsigned long off = vma->vm_pgoff;
 
 	vma->vm_page_prot = __get_dma_pgprot(attrs, vma->vm_page_prot);
 
 	if (!pages)
 		return -ENXIO;
 
+	if (off >= nr_pages || (usize >> PAGE_SHIFT) > nr_pages - off)
+		return -ENXIO;
+
+	pages += off;
+
 	do {
 		int ret = vm_insert_page(vma, uaddr, *pages++);
 		if (ret) {
diff --git a/arch/arm/plat-orion/common.c b/arch/arm/plat-orion/common.c
index c019b7a..553e00a43 100644
--- a/arch/arm/plat-orion/common.c
+++ b/arch/arm/plat-orion/common.c
@@ -498,7 +498,7 @@ void __init orion_ge00_switch_init(struct dsa_platform_data *d, int irq)
 
 	d->netdev = &orion_ge00.dev;
 	for (i = 0; i < d->nr_chips; i++)
-		d->chip[i].mii_bus = &orion_ge00_shared.dev;
+		d->chip[i].mii_bus = &orion_ge_mvmdio.dev;
 	orion_switch_device.dev.platform_data = d;
 
 	platform_device_register(&orion_switch_device);
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 0677ff4..661ccf8 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -56,6 +56,10 @@ config NO_IOPORT
 config STACKTRACE_SUPPORT
 	def_bool y
 
+config ILLEGAL_POINTER_VALUE
+	hex
+	default 0xdead000000000000
+
 config LOCKDEP_SUPPORT
 	def_bool y
 
diff --git a/arch/arm64/include/asm/ptrace.h b/arch/arm64/include/asm/ptrace.h
index 41a71ee..7257c36 100644
--- a/arch/arm64/include/asm/ptrace.h
+++ b/arch/arm64/include/asm/ptrace.h
@@ -70,14 +70,14 @@
 #define compat_sp	regs[13]
 #define compat_lr	regs[14]
 #define compat_sp_hyp	regs[15]
-#define compat_sp_irq	regs[16]
-#define compat_lr_irq	regs[17]
-#define compat_sp_svc	regs[18]
-#define compat_lr_svc	regs[19]
-#define compat_sp_abt	regs[20]
-#define compat_lr_abt	regs[21]
-#define compat_sp_und	regs[22]
-#define compat_lr_und	regs[23]
+#define compat_lr_irq	regs[16]
+#define compat_sp_irq	regs[17]
+#define compat_lr_svc	regs[18]
+#define compat_sp_svc	regs[19]
+#define compat_lr_abt	regs[20]
+#define compat_sp_abt	regs[21]
+#define compat_lr_und	regs[22]
+#define compat_sp_und	regs[23]
 #define compat_r8_fiq	regs[24]
 #define compat_r9_fiq	regs[25]
 #define compat_r10_fiq	regs[26]
diff --git a/arch/arm64/include/asm/timex.h b/arch/arm64/include/asm/timex.h
index b24a31a..81a076e 100644
--- a/arch/arm64/include/asm/timex.h
+++ b/arch/arm64/include/asm/timex.h
@@ -16,14 +16,14 @@
 #ifndef __ASM_TIMEX_H
 #define __ASM_TIMEX_H
 
+#include <asm/arch_timer.h>
+
 /*
  * Use the current timer as a cycle counter since this is what we use for
  * the delay loop.
  */
-#define get_cycles()	({ cycles_t c; read_current_timer(&c); c; })
+#define get_cycles()	arch_counter_get_cntvct()
 
 #include <asm-generic/timex.h>
 
-#define ARCH_HAS_READ_CURRENT_TIMER
-
 #endif
diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S
index 53dcae4..f480e7d 100644
--- a/arch/arm64/kernel/head.S
+++ b/arch/arm64/kernel/head.S
@@ -184,6 +184,11 @@ ENTRY(el2_setup)
 	msr	hstr_el2, xzr			// Disable CP15 traps to EL2
 #endif
 
+	/* EL2 debug */
+	mrs	x0, pmcr_el0			// Disable debug access traps
+	ubfx	x0, x0, #11, #5			// to EL2 and allow access to
+	msr	mdcr_el2, x0			// all PMU counters from EL1
+
 	/* Stage-2 translation */
 	msr	vttbr_el2, xzr
 
diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c
index 33a74fc..dfad98f 100644
--- a/arch/arm64/kernel/ptrace.c
+++ b/arch/arm64/kernel/ptrace.c
@@ -51,6 +51,12 @@
  */
 void ptrace_disable(struct task_struct *child)
 {
+	/*
+	 * This would be better off in core code, but PTRACE_DETACH has
+	 * grown its fair share of arch-specific worts and changing it
+	 * is likely to cause regressions on obscure architectures.
+	 */
+	user_disable_single_step(child);
 }
 
 /*
diff --git a/arch/arm64/kernel/signal32.c b/arch/arm64/kernel/signal32.c
index 3d47810..1e60acc 100644
--- a/arch/arm64/kernel/signal32.c
+++ b/arch/arm64/kernel/signal32.c
@@ -193,7 +193,8 @@ int copy_siginfo_to_user32(compat_siginfo_t __user *to, siginfo_t *from)
 		 * Other callers might not initialize the si_lsb field,
 		 * so check explicitely for the right codes here.
 		 */
-		if (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO)
+		if (from->si_signo == SIGBUS &&
+		    (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO))
 			err |= __put_user(from->si_addr_lsb, &to->si_addr_lsb);
 #endif
 		break;
@@ -220,8 +221,6 @@ int copy_siginfo_to_user32(compat_siginfo_t __user *to, siginfo_t *from)
 
 int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
 {
-	memset(to, 0, sizeof *to);
-
 	if (copy_from_user(to, from, __ARCH_SI_PREAMBLE_SIZE) ||
 	    copy_from_user(to->_sifields._pad,
 			   from->_sifields._pad, SI_PAD_SIZE))
@@ -232,14 +231,32 @@ int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
 
 /*
  * VFP save/restore code.
+ *
+ * We have to be careful with endianness, since the fpsimd context-switch
+ * code operates on 128-bit (Q) register values whereas the compat ABI
+ * uses an array of 64-bit (D) registers. Consequently, we need to swap
+ * the two halves of each Q register when running on a big-endian CPU.
  */
+union __fpsimd_vreg {
+	__uint128_t	raw;
+	struct {
+#ifdef __AARCH64EB__
+		u64	hi;
+		u64	lo;
+#else
+		u64	lo;
+		u64	hi;
+#endif
+	};
+};
+
 static int compat_preserve_vfp_context(struct compat_vfp_sigframe __user *frame)
 {
 	struct fpsimd_state *fpsimd = &current->thread.fpsimd_state;
 	compat_ulong_t magic = VFP_MAGIC;
 	compat_ulong_t size = VFP_STORAGE_SIZE;
 	compat_ulong_t fpscr, fpexc;
-	int err = 0;
+	int i, err = 0;
 
 	/*
 	 * Save the hardware registers to the fpsimd_state structure.
@@ -255,10 +272,15 @@ static int compat_preserve_vfp_context(struct compat_vfp_sigframe __user *frame)
 	/*
 	 * Now copy the FP registers. Since the registers are packed,
 	 * we can copy the prefix we want (V0-V15) as it is.
-	 * FIXME: Won't work if big endian.
 	 */
-	err |= __copy_to_user(&frame->ufp.fpregs, fpsimd->vregs,
-			      sizeof(frame->ufp.fpregs));
+	for (i = 0; i < ARRAY_SIZE(frame->ufp.fpregs); i += 2) {
+		union __fpsimd_vreg vreg = {
+			.raw = fpsimd->vregs[i >> 1],
+		};
+
+		__put_user_error(vreg.lo, &frame->ufp.fpregs[i], err);
+		__put_user_error(vreg.hi, &frame->ufp.fpregs[i + 1], err);
+	}
 
 	/* Create an AArch32 fpscr from the fpsr and the fpcr. */
 	fpscr = (fpsimd->fpsr & VFP_FPSCR_STAT_MASK) |
@@ -283,7 +305,7 @@ static int compat_restore_vfp_context(struct compat_vfp_sigframe __user *frame)
 	compat_ulong_t magic = VFP_MAGIC;
 	compat_ulong_t size = VFP_STORAGE_SIZE;
 	compat_ulong_t fpscr;
-	int err = 0;
+	int i, err = 0;
 
 	__get_user_error(magic, &frame->magic, err);
 	__get_user_error(size, &frame->size, err);
@@ -293,12 +315,14 @@ static int compat_restore_vfp_context(struct compat_vfp_sigframe __user *frame)
 	if (magic != VFP_MAGIC || size != VFP_STORAGE_SIZE)
 		return -EINVAL;
 
-	/*
-	 * Copy the FP registers into the start of the fpsimd_state.
-	 * FIXME: Won't work if big endian.
-	 */
-	err |= __copy_from_user(fpsimd.vregs, frame->ufp.fpregs,
-				sizeof(frame->ufp.fpregs));
+	/* Copy the FP registers into the start of the fpsimd_state. */
+	for (i = 0; i < ARRAY_SIZE(frame->ufp.fpregs); i += 2) {
+		union __fpsimd_vreg vreg;
+
+		__get_user_error(vreg.lo, &frame->ufp.fpregs[i], err);
+		__get_user_error(vreg.hi, &frame->ufp.fpregs[i + 1], err);
+		fpsimd.vregs[i >> 1] = vreg.raw;
+	}
 
 	/* Extract the fpsr and the fpcr from the fpscr */
 	__get_user_error(fpscr, &frame->ufp.fpscr, err);
diff --git a/arch/arm64/kernel/stacktrace.c b/arch/arm64/kernel/stacktrace.c
index 048334b..d25459f 100644
--- a/arch/arm64/kernel/stacktrace.c
+++ b/arch/arm64/kernel/stacktrace.c
@@ -48,11 +48,7 @@ int unwind_frame(struct stackframe *frame)
 
 	frame->sp = fp + 0x10;
 	frame->fp = *(unsigned long *)(fp);
-	/*
-	 * -4 here because we care about the PC at time of bl,
-	 * not where the return will go.
-	 */
-	frame->pc = *(unsigned long *)(fp + 8) - 4;
+	frame->pc = *(unsigned long *)(fp + 8);
 
 	return 0;
 }
diff --git a/arch/arm64/kernel/time.c b/arch/arm64/kernel/time.c
index a551f88..03dc371 100644
--- a/arch/arm64/kernel/time.c
+++ b/arch/arm64/kernel/time.c
@@ -68,12 +68,6 @@ unsigned long long notrace sched_clock(void)
 	return arch_timer_read_counter() * sched_clock_mult;
 }
 
-int read_current_timer(unsigned long *timer_value)
-{
-	*timer_value = arch_timer_read_counter();
-	return 0;
-}
-
 void __init time_init(void)
 {
 	u32 arch_timer_rate;
diff --git a/arch/arm64/kernel/vdso/Makefile b/arch/arm64/kernel/vdso/Makefile
index 6d20b7d..fdda6dd 100644
--- a/arch/arm64/kernel/vdso/Makefile
+++ b/arch/arm64/kernel/vdso/Makefile
@@ -15,6 +15,10 @@ ccflags-y := -shared -fno-common -fno-builtin
 ccflags-y += -nostdlib -Wl,-soname=linux-vdso.so.1 \
 		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
 
+# Workaround for bare-metal (ELF) toolchains that neglect to pass -shared
+# down to collect2, resulting in silent corruption of the vDSO image.
+ccflags-y += -Wl,-shared
+
 obj-y += vdso.o
 extra-y += vdso.lds vdso-offsets.h
 CPPFLAGS_vdso.lds += -P -C -U$(ARCH)
diff --git a/arch/arm64/mm/context.c b/arch/arm64/mm/context.c
index baa758d..76c1e6c 100644
--- a/arch/arm64/mm/context.c
+++ b/arch/arm64/mm/context.c
@@ -92,6 +92,14 @@ static void reset_context(void *info)
 	unsigned int cpu = smp_processor_id();
 	struct mm_struct *mm = current->active_mm;
 
+	/*
+	 * current->active_mm could be init_mm for the idle thread immediately
+	 * after secondary CPU boot or hotplug. TTBR0_EL1 is already set to
+	 * the reserved value, so no need to reset any context.
+	 */
+	if (mm == &init_mm)
+		return;
+
 	smp_rmb();
 	asid = cpu_last_asid + cpu;
 
diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c
index b5d4587..2503190 100644
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@ -278,6 +278,7 @@ retry:
 			 * starvation.
 			 */
 			mm_flags &= ~FAULT_FLAG_ALLOW_RETRY;
+			mm_flags |= FAULT_FLAG_TRIED;
 			goto retry;
 		}
 	}
diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c
index f497ca7..5c55166 100644
--- a/arch/arm64/mm/init.c
+++ b/arch/arm64/mm/init.c
@@ -262,7 +262,7 @@ static void __init free_unused_memmap(void)
 		 * memmap entries are valid from the bank end aligned to
 		 * MAX_ORDER_NR_PAGES.
 		 */
-		prev_end = ALIGN(start + __phys_to_pfn(reg->size),
+		prev_end = ALIGN(__phys_to_pfn(reg->base + reg->size),
 				 MAX_ORDER_NR_PAGES);
 	}
 
diff --git a/arch/arm64/mm/mmap.c b/arch/arm64/mm/mmap.c
index 7c7be78..8aaf073 100644
--- a/arch/arm64/mm/mmap.c
+++ b/arch/arm64/mm/mmap.c
@@ -47,22 +47,14 @@ static int mmap_is_legacy(void)
 	return sysctl_legacy_va_layout;
 }
 
-/*
- * Since get_random_int() returns the same value within a 1 jiffy window, we
- * will almost always get the same randomisation for the stack and mmap
- * region. This will mean the relative distance between stack and mmap will be
- * the same.
- *
- * To avoid this we can shift the randomness by 1 bit.
- */
 static unsigned long mmap_rnd(void)
 {
 	unsigned long rnd = 0;
 
 	if (current->flags & PF_RANDOMIZE)
-		rnd = (long)get_random_int() & (STACK_RND_MASK >> 1);
+		rnd = (long)get_random_int() & STACK_RND_MASK;
 
-	return rnd << (PAGE_SHIFT + 1);
+	return rnd << PAGE_SHIFT;
 }
 
 static unsigned long mmap_base(void)
diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c
index ba7477e..5b77586 100644
--- a/arch/arm64/mm/mmu.c
+++ b/arch/arm64/mm/mmu.c
@@ -348,6 +348,9 @@ void __init paging_init(void)
 
 	empty_zero_page = virt_to_page(zero_page);
 
+	/* Ensure the zero page is visible to the page table walker */
+	dsb();
+
 	/*
 	 * TTBR0 is only used for the identity mapping at this stage. Make it
 	 * point to zero page to avoid speculatively fetching new entries.
diff --git a/arch/avr32/mm/fault.c b/arch/avr32/mm/fault.c
index 0eca933..d223a8b 100644
--- a/arch/avr32/mm/fault.c
+++ b/arch/avr32/mm/fault.c
@@ -142,6 +142,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/blackfin/include/asm/ftrace.h b/arch/blackfin/include/asm/ftrace.h
index 8a02950..2f1c3c2 100644
--- a/arch/blackfin/include/asm/ftrace.h
+++ b/arch/blackfin/include/asm/ftrace.h
@@ -66,16 +66,7 @@ extern inline void *return_address(unsigned int level)
 
 #endif /* CONFIG_FRAME_POINTER */
 
-#define HAVE_ARCH_CALLER_ADDR
-
-/* inline function or macro may lead to unexpected result */
-#define CALLER_ADDR0 ((unsigned long)__builtin_return_address(0))
-#define CALLER_ADDR1 ((unsigned long)return_address(1))
-#define CALLER_ADDR2 ((unsigned long)return_address(2))
-#define CALLER_ADDR3 ((unsigned long)return_address(3))
-#define CALLER_ADDR4 ((unsigned long)return_address(4))
-#define CALLER_ADDR5 ((unsigned long)return_address(5))
-#define CALLER_ADDR6 ((unsigned long)return_address(6))
+#define ftrace_return_address(n) return_address(n)
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/arch/c6x/kernel/time.c b/arch/c6x/kernel/time.c
index 356ee84..04845aa 100644
--- a/arch/c6x/kernel/time.c
+++ b/arch/c6x/kernel/time.c
@@ -49,7 +49,7 @@ u64 sched_clock(void)
 	return (tsc * sched_clock_multiplier) >> SCHED_CLOCK_SHIFT;
 }
 
-void time_init(void)
+void __init time_init(void)
 {
 	u64 tmp = (u64)NSEC_PER_SEC << SCHED_CLOCK_SHIFT;
 
diff --git a/arch/cris/mm/fault.c b/arch/cris/mm/fault.c
index 1790f22..2686a7a 100644
--- a/arch/cris/mm/fault.c
+++ b/arch/cris/mm/fault.c
@@ -176,6 +176,8 @@ retry:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/frv/mm/fault.c b/arch/frv/mm/fault.c
index 9a66372..ec4917d 100644
--- a/arch/frv/mm/fault.c
+++ b/arch/frv/mm/fault.c
@@ -168,6 +168,8 @@ asmlinkage void do_page_fault(int datammu, unsigned long esr0, unsigned long ear
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/ia64/mm/fault.c b/arch/ia64/mm/fault.c
index 7225dad..ba5ba7a 100644
--- a/arch/ia64/mm/fault.c
+++ b/arch/ia64/mm/fault.c
@@ -172,6 +172,8 @@ retry:
 		 */
 		if (fault & VM_FAULT_OOM) {
 			goto out_of_memory;
+		} else if (fault & VM_FAULT_SIGSEGV) {
+			goto bad_area;
 		} else if (fault & VM_FAULT_SIGBUS) {
 			signal = SIGBUS;
 			goto bad_area;
diff --git a/arch/m32r/kernel/setup.c b/arch/m32r/kernel/setup.c
index 0392112..a5ecef7 100644
--- a/arch/m32r/kernel/setup.c
+++ b/arch/m32r/kernel/setup.c
@@ -81,7 +81,10 @@ static struct resource code_resource = {
 };
 
 unsigned long memory_start;
+EXPORT_SYMBOL(memory_start);
+
 unsigned long memory_end;
+EXPORT_SYMBOL(memory_end);
 
 void __init setup_arch(char **);
 int get_cpuinfo(char *);
diff --git a/arch/m32r/mm/fault.c b/arch/m32r/mm/fault.c
index e9c6a80..e3d4d48901 100644
--- a/arch/m32r/mm/fault.c
+++ b/arch/m32r/mm/fault.c
@@ -200,6 +200,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/m68k/include/asm/linkage.h b/arch/m68k/include/asm/linkage.h
index 5a822bb..066e74f 100644
--- a/arch/m68k/include/asm/linkage.h
+++ b/arch/m68k/include/asm/linkage.h
@@ -4,4 +4,34 @@
 #define __ALIGN .align 4
 #define __ALIGN_STR ".align 4"
 
+/*
+ * Make sure the compiler doesn't do anything stupid with the
+ * arguments on the stack - they are owned by the *caller*, not
+ * the callee. This just fools gcc into not spilling into them,
+ * and keeps it from doing tailcall recursion and/or using the
+ * stack slots for temporaries, since they are live and "used"
+ * all the way to the end of the function.
+ */
+#define asmlinkage_protect(n, ret, args...) \
+	__asmlinkage_protect##n(ret, ##args)
+#define __asmlinkage_protect_n(ret, args...) \
+	__asm__ __volatile__ ("" : "=r" (ret) : "0" (ret), ##args)
+#define __asmlinkage_protect0(ret) \
+	__asmlinkage_protect_n(ret)
+#define __asmlinkage_protect1(ret, arg1) \
+	__asmlinkage_protect_n(ret, "m" (arg1))
+#define __asmlinkage_protect2(ret, arg1, arg2) \
+	__asmlinkage_protect_n(ret, "m" (arg1), "m" (arg2))
+#define __asmlinkage_protect3(ret, arg1, arg2, arg3) \
+	__asmlinkage_protect_n(ret, "m" (arg1), "m" (arg2), "m" (arg3))
+#define __asmlinkage_protect4(ret, arg1, arg2, arg3, arg4) \
+	__asmlinkage_protect_n(ret, "m" (arg1), "m" (arg2), "m" (arg3), \
+			      "m" (arg4))
+#define __asmlinkage_protect5(ret, arg1, arg2, arg3, arg4, arg5) \
+	__asmlinkage_protect_n(ret, "m" (arg1), "m" (arg2), "m" (arg3), \
+			      "m" (arg4), "m" (arg5))
+#define __asmlinkage_protect6(ret, arg1, arg2, arg3, arg4, arg5, arg6) \
+	__asmlinkage_protect_n(ret, "m" (arg1), "m" (arg2), "m" (arg3), \
+			      "m" (arg4), "m" (arg5), "m" (arg6))
+
 #endif
diff --git a/arch/m68k/include/asm/uaccess_mm.h b/arch/m68k/include/asm/uaccess_mm.h
index 472c891..15901db 100644
--- a/arch/m68k/include/asm/uaccess_mm.h
+++ b/arch/m68k/include/asm/uaccess_mm.h
@@ -90,7 +90,7 @@ asm volatile ("\n"					\
 		__put_user_asm(__pu_err, __pu_val, ptr, b, d, -EFAULT);	\
 		break;							\
 	case 2:								\
-		__put_user_asm(__pu_err, __pu_val, ptr, w, d, -EFAULT);	\
+		__put_user_asm(__pu_err, __pu_val, ptr, w, r, -EFAULT);	\
 		break;							\
 	case 4:								\
 		__put_user_asm(__pu_err, __pu_val, ptr, l, r, -EFAULT);	\
@@ -158,7 +158,7 @@ asm volatile ("\n"					\
 		__get_user_asm(__gu_err, x, ptr, u8, b, d, -EFAULT);	\
 		break;							\
 	case 2:								\
-		__get_user_asm(__gu_err, x, ptr, u16, w, d, -EFAULT);	\
+		__get_user_asm(__gu_err, x, ptr, u16, w, r, -EFAULT);	\
 		break;							\
 	case 4:								\
 		__get_user_asm(__gu_err, x, ptr, u32, l, r, -EFAULT);	\
@@ -245,7 +245,7 @@ __constant_copy_from_user(void *to, const void __user *from, unsigned long n)
 		__get_user_asm(res, *(u8 *)to, (u8 __user *)from, u8, b, d, 1);
 		break;
 	case 2:
-		__get_user_asm(res, *(u16 *)to, (u16 __user *)from, u16, w, d, 2);
+		__get_user_asm(res, *(u16 *)to, (u16 __user *)from, u16, w, r, 2);
 		break;
 	case 3:
 		__constant_copy_from_user_asm(res, to, from, tmp, 3, w, b,);
@@ -326,7 +326,7 @@ __constant_copy_to_user(void __user *to, const void *from, unsigned long n)
 		__put_user_asm(res, *(u8 *)from, (u8 __user *)to, b, d, 1);
 		break;
 	case 2:
-		__put_user_asm(res, *(u16 *)from, (u16 __user *)to, w, d, 2);
+		__put_user_asm(res, *(u16 *)from, (u16 __user *)to, w, r, 2);
 		break;
 	case 3:
 		__constant_copy_to_user_asm(res, to, from, tmp, 3, w, b,);
diff --git a/arch/m68k/lib/uaccess.c b/arch/m68k/lib/uaccess.c
index 5e97f2e..35d1442 100644
--- a/arch/m68k/lib/uaccess.c
+++ b/arch/m68k/lib/uaccess.c
@@ -52,7 +52,7 @@ unsigned long __generic_copy_from_user(void *to, const void __user *from,
 		"	.long	3b,30b\n"
 		"	.long	5b,50b\n"
 		"	.previous"
-		: "=d" (res), "+a" (from), "+a" (to), "=&r" (tmp)
+		: "=d" (res), "+a" (from), "+a" (to), "=&d" (tmp)
 		: "0" (n / 4), "d" (n & 3));
 
 	return res;
@@ -96,7 +96,7 @@ unsigned long __generic_copy_to_user(void __user *to, const void *from,
 		"	.long	7b,50b\n"
 		"	.long	8b,50b\n"
 		"	.previous"
-		: "=d" (res), "+a" (from), "+a" (to), "=&r" (tmp)
+		: "=d" (res), "+a" (from), "+a" (to), "=&d" (tmp)
 		: "0" (n / 4), "d" (n & 3));
 
 	return res;
@@ -141,7 +141,7 @@ unsigned long __clear_user(void __user *to, unsigned long n)
 		"	.long	7b,40b\n"
 		"	.previous"
 		: "=d" (res), "+a" (to)
-		: "r" (0), "0" (n / 4), "d" (n & 3));
+		: "d" (0), "0" (n / 4), "d" (n & 3));
 
     return res;
 }
diff --git a/arch/m68k/mm/fault.c b/arch/m68k/mm/fault.c
index eb1d61f..f0eef04 100644
--- a/arch/m68k/mm/fault.c
+++ b/arch/m68k/mm/fault.c
@@ -153,6 +153,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto map_err;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto bus_err;
 		BUG();
diff --git a/arch/metag/include/asm/cmpxchg_lnkget.h b/arch/metag/include/asm/cmpxchg_lnkget.h
index 0154e28..2369ad3 100644
--- a/arch/metag/include/asm/cmpxchg_lnkget.h
+++ b/arch/metag/include/asm/cmpxchg_lnkget.h
@@ -73,7 +73,7 @@ static inline unsigned long __cmpxchg_u32(volatile int *m, unsigned long old,
 		      "	DCACHE	[%2], %0\n"
 #endif
 		      "2:\n"
-		      : "=&d" (temp), "=&da" (retval)
+		      : "=&d" (temp), "=&d" (retval)
 		      : "da" (m), "bd" (old), "da" (new)
 		      : "cc"
 		      );
diff --git a/arch/metag/mm/fault.c b/arch/metag/mm/fault.c
index 332680e..2de5dc6 100644
--- a/arch/metag/mm/fault.c
+++ b/arch/metag/mm/fault.c
@@ -141,6 +141,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/microblaze/mm/fault.c b/arch/microblaze/mm/fault.c
index fa4cf52..d46a5eb 100644
--- a/arch/microblaze/mm/fault.c
+++ b/arch/microblaze/mm/fault.c
@@ -224,6 +224,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/mips/ath79/early_printk.c b/arch/mips/ath79/early_printk.c
index b955faf..d1adc59 100644
--- a/arch/mips/ath79/early_printk.c
+++ b/arch/mips/ath79/early_printk.c
@@ -31,13 +31,15 @@ static inline void prom_putchar_wait(void __iomem *reg, u32 mask, u32 val)
 	} while (1);
 }
 
+#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
+
 static void prom_putchar_ar71xx(unsigned char ch)
 {
 	void __iomem *base = (void __iomem *)(KSEG1ADDR(AR71XX_UART_BASE));
 
-	prom_putchar_wait(base + UART_LSR * 4, UART_LSR_THRE, UART_LSR_THRE);
+	prom_putchar_wait(base + UART_LSR * 4, BOTH_EMPTY, BOTH_EMPTY);
 	__raw_writel(ch, base + UART_TX * 4);
-	prom_putchar_wait(base + UART_LSR * 4, UART_LSR_THRE, UART_LSR_THRE);
+	prom_putchar_wait(base + UART_LSR * 4, BOTH_EMPTY, BOTH_EMPTY);
 }
 
 static void prom_putchar_ar933x(unsigned char ch)
diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h
index 4d6fa0b..883a162 100644
--- a/arch/mips/include/asm/kvm_host.h
+++ b/arch/mips/include/asm/kvm_host.h
@@ -349,6 +349,7 @@ struct kvm_mips_tlb {
 #define KVM_MIPS_GUEST_TLB_SIZE     64
 struct kvm_vcpu_arch {
 	void *host_ebase, *guest_ebase;
+	int (*vcpu_run)(struct kvm_run *run, struct kvm_vcpu *vcpu);
 	unsigned long host_stack;
 	unsigned long host_gp;
 
diff --git a/arch/mips/include/asm/mach-generic/spaces.h b/arch/mips/include/asm/mach-generic/spaces.h
index 5b2f2e6..503eb6c 100644
--- a/arch/mips/include/asm/mach-generic/spaces.h
+++ b/arch/mips/include/asm/mach-generic/spaces.h
@@ -90,7 +90,11 @@
 #endif
 
 #ifndef FIXADDR_TOP
+#ifdef CONFIG_KVM_GUEST
+#define FIXADDR_TOP		((unsigned long)(long)(int)0x7ffe0000)
+#else
 #define FIXADDR_TOP		((unsigned long)(long)(int)0xfffe0000)
 #endif
+#endif
 
 #endif /* __ASM_MACH_GENERIC_SPACES_H */
diff --git a/arch/mips/include/asm/pgtable.h b/arch/mips/include/asm/pgtable.h
index 8b8f6b3..e821de7 100644
--- a/arch/mips/include/asm/pgtable.h
+++ b/arch/mips/include/asm/pgtable.h
@@ -150,8 +150,39 @@ static inline void set_pte(pte_t *ptep, pte_t pteval)
 		 * Make sure the buddy is global too (if it's !none,
 		 * it better already be global)
 		 */
+#ifdef CONFIG_SMP
+		/*
+		 * For SMP, multiple CPUs can race, so we need to do
+		 * this atomically.
+		 */
+#ifdef CONFIG_64BIT
+#define LL_INSN "lld"
+#define SC_INSN "scd"
+#else /* CONFIG_32BIT */
+#define LL_INSN "ll"
+#define SC_INSN "sc"
+#endif
+		unsigned long page_global = _PAGE_GLOBAL;
+		unsigned long tmp;
+
+		__asm__ __volatile__ (
+			"	.set	push\n"
+			"	.set	noreorder\n"
+			"1:	" LL_INSN "	%[tmp], %[buddy]\n"
+			"	bnez	%[tmp], 2f\n"
+			"	 or	%[tmp], %[tmp], %[global]\n"
+			"	" SC_INSN "	%[tmp], %[buddy]\n"
+			"	beqz	%[tmp], 1b\n"
+			"	 nop\n"
+			"2:\n"
+			"	.set pop"
+			: [buddy] "+m" (buddy->pte),
+			  [tmp] "=&r" (tmp)
+			: [global] "r" (page_global));
+#else /* !CONFIG_SMP */
 		if (pte_none(*buddy))
 			pte_val(*buddy) = pte_val(*buddy) | _PAGE_GLOBAL;
+#endif /* CONFIG_SMP */
 	}
 #endif
 }
diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h
index 1470b7b..a7e7174 100644
--- a/arch/mips/include/asm/processor.h
+++ b/arch/mips/include/asm/processor.h
@@ -51,7 +51,7 @@ extern unsigned int vced_count, vcei_count;
  * User space process size: 2GB. This is hardcoded into a few places,
  * so don't change it unless you know what you are doing.
  */
-#define TASK_SIZE	0x7fff8000UL
+#define TASK_SIZE	0x80000000UL
 #endif
 
 #ifdef __KERNEL__
diff --git a/arch/mips/include/uapi/asm/siginfo.h b/arch/mips/include/uapi/asm/siginfo.h
index 6a87141..b5f77f7 100644
--- a/arch/mips/include/uapi/asm/siginfo.h
+++ b/arch/mips/include/uapi/asm/siginfo.h
@@ -45,13 +45,13 @@ typedef struct siginfo {
 
 		/* kill() */
 		struct {
-			pid_t _pid;		/* sender's pid */
+			__kernel_pid_t _pid;	/* sender's pid */
 			__ARCH_SI_UID_T _uid;	/* sender's uid */
 		} _kill;
 
 		/* POSIX.1b timers */
 		struct {
-			timer_t _tid;		/* timer id */
+			__kernel_timer_t _tid;	/* timer id */
 			int _overrun;		/* overrun count */
 			char _pad[sizeof( __ARCH_SI_UID_T) - sizeof(int)];
 			sigval_t _sigval;	/* same as below */
@@ -60,26 +60,26 @@ typedef struct siginfo {
 
 		/* POSIX.1b signals */
 		struct {
-			pid_t _pid;		/* sender's pid */
+			__kernel_pid_t _pid;	/* sender's pid */
 			__ARCH_SI_UID_T _uid;	/* sender's uid */
 			sigval_t _sigval;
 		} _rt;
 
 		/* SIGCHLD */
 		struct {
-			pid_t _pid;		/* which child */
+			__kernel_pid_t _pid;	/* which child */
 			__ARCH_SI_UID_T _uid;	/* sender's uid */
 			int _status;		/* exit code */
-			clock_t _utime;
-			clock_t _stime;
+			__kernel_clock_t _utime;
+			__kernel_clock_t _stime;
 		} _sigchld;
 
 		/* IRIX SIGCHLD */
 		struct {
-			pid_t _pid;		/* which child */
-			clock_t _utime;
+			__kernel_pid_t _pid;	/* which child */
+			__kernel_clock_t _utime;
 			int _status;		/* exit code */
-			clock_t _stime;
+			__kernel_clock_t _stime;
 		} _irix_sigchld;
 
 		/* SIGILL, SIGFPE, SIGSEGV, SIGBUS */
diff --git a/arch/mips/kernel/irq.c b/arch/mips/kernel/irq.c
index d1fea7a..7479d8d 100644
--- a/arch/mips/kernel/irq.c
+++ b/arch/mips/kernel/irq.c
@@ -110,7 +110,7 @@ void __init init_IRQ(void)
 #endif
 }
 
-#ifdef DEBUG_STACKOVERFLOW
+#ifdef CONFIG_DEBUG_STACKOVERFLOW
 static inline void check_stack_overflow(void)
 {
 	unsigned long sp;
diff --git a/arch/mips/kernel/mips-mt-fpaff.c b/arch/mips/kernel/mips-mt-fpaff.c
index fd814e0..0f3e030 100644
--- a/arch/mips/kernel/mips-mt-fpaff.c
+++ b/arch/mips/kernel/mips-mt-fpaff.c
@@ -154,7 +154,7 @@ asmlinkage long mipsmt_sys_sched_getaffinity(pid_t pid, unsigned int len,
 				      unsigned long __user *user_mask_ptr)
 {
 	unsigned int real_len;
-	cpumask_t mask;
+	cpumask_t allowed, mask;
 	int retval;
 	struct task_struct *p;
 
@@ -173,7 +173,8 @@ asmlinkage long mipsmt_sys_sched_getaffinity(pid_t pid, unsigned int len,
 	if (retval)
 		goto out_unlock;
 
-	cpumask_and(&mask, &p->thread.user_cpus_allowed, cpu_possible_mask);
+	cpumask_or(&allowed, &p->thread.user_cpus_allowed, &p->cpus_allowed);
+	cpumask_and(&mask, &allowed, cpu_active_mask);
 
 out_unlock:
 	read_unlock(&tasklist_lock);
diff --git a/arch/mips/kernel/scall64-n32.S b/arch/mips/kernel/scall64-n32.S
index cab1507..b657fbe 100644
--- a/arch/mips/kernel/scall64-n32.S
+++ b/arch/mips/kernel/scall64-n32.S
@@ -349,7 +349,7 @@ EXPORT(sysn32_call_table)
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key
 	PTR	sys_request_key
-	PTR	sys_keyctl			/* 6245 */
+	PTR	compat_sys_keyctl		/* 6245 */
 	PTR	sys_set_thread_area
 	PTR	sys_inotify_init
 	PTR	sys_inotify_add_watch
diff --git a/arch/mips/kernel/scall64-o32.S b/arch/mips/kernel/scall64-o32.S
index 37605dc..bf56d7e 100644
--- a/arch/mips/kernel/scall64-o32.S
+++ b/arch/mips/kernel/scall64-o32.S
@@ -474,7 +474,7 @@ sys_call_table:
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key			/* 4280 */
 	PTR	sys_request_key
-	PTR	sys_keyctl
+	PTR	compat_sys_keyctl
 	PTR	sys_set_thread_area
 	PTR	sys_inotify_init
 	PTR	sys_inotify_add_watch		/* 4285 */
diff --git a/arch/mips/kernel/signal32.c b/arch/mips/kernel/signal32.c
index 57de8b7..41f8708 100644
--- a/arch/mips/kernel/signal32.c
+++ b/arch/mips/kernel/signal32.c
@@ -368,8 +368,6 @@ int copy_siginfo_to_user32(compat_siginfo_t __user *to, siginfo_t *from)
 
 int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)
 {
-	memset(to, 0, sizeof *to);
-
 	if (copy_from_user(to, from, 3*sizeof(int)) ||
 	    copy_from_user(to->_sifields._pad,
 			   from->_sifields._pad, SI_PAD_SIZE32))
diff --git a/arch/mips/kvm/kvm_locore.S b/arch/mips/kvm/kvm_locore.S
index 920b632..73553cd 100644
--- a/arch/mips/kvm/kvm_locore.S
+++ b/arch/mips/kvm/kvm_locore.S
@@ -156,9 +156,11 @@ FEXPORT(__kvm_mips_vcpu_run)
 
 FEXPORT(__kvm_mips_load_asid)
     /* Set the ASID for the Guest Kernel */
-    sll         t0, t0, 1                       /* with kseg0 @ 0x40000000, kernel */
-                                                /* addresses shift to 0x80000000 */
-    bltz        t0, 1f                          /* If kernel */
+    PTR_L	t0, VCPU_COP0(k1)
+    LONG_L	t0, COP0_STATUS(t0)
+    andi	t0, KSU_USER | ST0_ERL | ST0_EXL
+    xori	t0, KSU_USER
+    bnez	t0, 1f		/* If kernel */
 	addiu       t1, k1, VCPU_GUEST_KERNEL_ASID  /* (BD)  */
     addiu       t1, k1, VCPU_GUEST_USER_ASID    /* else user */
 1:
@@ -225,6 +227,7 @@ FEXPORT(__kvm_mips_load_k0k1)
     /* Jump to guest */
 	eret
 	.set	pop
+EXPORT(__kvm_mips_vcpu_run_end)
 
 VECTOR(MIPSX(exception), unknown)
 /*
@@ -442,9 +445,11 @@ __kvm_mips_return_to_guest:
 	mtc0		t0, CP0_EPC
 
     /* Set the ASID for the Guest Kernel */
-    sll         t0, t0, 1                       /* with kseg0 @ 0x40000000, kernel */
-                                                /* addresses shift to 0x80000000 */
-    bltz        t0, 1f                          /* If kernel */
+    PTR_L	t0, VCPU_COP0(k1)
+    LONG_L	t0, COP0_STATUS(t0)
+    andi	t0, KSU_USER | ST0_ERL | ST0_EXL
+    xori	t0, KSU_USER
+    bnez	t0, 1f		/* If kernel */
 	addiu       t1, k1, VCPU_GUEST_KERNEL_ASID  /* (BD)  */
     addiu       t1, k1, VCPU_GUEST_USER_ASID    /* else user */
 1:
diff --git a/arch/mips/kvm/kvm_mips.c b/arch/mips/kvm/kvm_mips.c
index 843ec38..97a181a 100644
--- a/arch/mips/kvm/kvm_mips.c
+++ b/arch/mips/kvm/kvm_mips.c
@@ -308,7 +308,7 @@ struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)
 
 	if (!gebase) {
 		err = -ENOMEM;
-		goto out_free_cpu;
+		goto out_uninit_cpu;
 	}
 	kvm_info("Allocated %d bytes for KVM Exception Handlers @ %p\n",
 		 ALIGN(size, PAGE_SIZE), gebase);
@@ -343,6 +343,15 @@ struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)
 	memcpy(gebase + offset, mips32_GuestException,
 	       mips32_GuestExceptionEnd - mips32_GuestException);
 
+#ifdef MODULE
+	offset += mips32_GuestExceptionEnd - mips32_GuestException;
+	memcpy(gebase + offset, (char *)__kvm_mips_vcpu_run,
+	       __kvm_mips_vcpu_run_end - (char *)__kvm_mips_vcpu_run);
+	vcpu->arch.vcpu_run = gebase + offset;
+#else
+	vcpu->arch.vcpu_run = __kvm_mips_vcpu_run;
+#endif
+
 	/* Invalidate the icache for these ranges */
 	mips32_SyncICache((unsigned long) gebase, ALIGN(size, PAGE_SIZE));
 
@@ -368,6 +377,9 @@ struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)
 out_free_gebase:
 	kfree(gebase);
 
+out_uninit_cpu:
+	kvm_vcpu_uninit(vcpu);
+
 out_free_cpu:
 	kfree(vcpu);
 
@@ -423,7 +435,7 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)
 
 	kvm_guest_enter();
 
-	r = __kvm_mips_vcpu_run(run, vcpu);
+	r = vcpu->arch.vcpu_run(run, vcpu);
 
 	kvm_guest_exit();
 	local_irq_enable();
diff --git a/arch/mips/kvm/kvm_mips_emul.c b/arch/mips/kvm/kvm_mips_emul.c
index e75ef82..9f76438 100644
--- a/arch/mips/kvm/kvm_mips_emul.c
+++ b/arch/mips/kvm/kvm_mips_emul.c
@@ -935,7 +935,7 @@ kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc, uint32_t cause,
 
 	base = (inst >> 21) & 0x1f;
 	op_inst = (inst >> 16) & 0x1f;
-	offset = inst & 0xffff;
+	offset = (int16_t)inst;
 	cache = (inst >> 16) & 0x3;
 	op = (inst >> 18) & 0x7;
 
@@ -972,8 +972,13 @@ kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc, uint32_t cause,
 	preempt_disable();
 	if (KVM_GUEST_KSEGX(va) == KVM_GUEST_KSEG0) {
 
-		if (kvm_mips_host_tlb_lookup(vcpu, va) < 0) {
-			kvm_mips_handle_kseg0_tlb_fault(va, vcpu);
+		if (kvm_mips_host_tlb_lookup(vcpu, va) < 0 &&
+		    kvm_mips_handle_kseg0_tlb_fault(va, vcpu)) {
+			kvm_err("%s: handling mapped kseg0 tlb fault for %lx, vcpu: %p, ASID: %#lx\n",
+				__func__, va, vcpu, read_c0_entryhi());
+			er = EMULATE_FAIL;
+			preempt_enable();
+			goto done;
 		}
 	} else if ((KVM_GUEST_KSEGX(va) < KVM_GUEST_KSEG0) ||
 		   KVM_GUEST_KSEGX(va) == KVM_GUEST_KSEG23) {
@@ -1006,11 +1011,16 @@ kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc, uint32_t cause,
 								run, vcpu);
 				preempt_enable();
 				goto dont_update_pc;
-			} else {
-				/* We fault an entry from the guest tlb to the shadow host TLB */
-				kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,
-								     NULL,
-								     NULL);
+			}
+			/* We fault an entry from the guest tlb to the shadow host TLB */
+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,
+								 NULL, NULL)) {
+				kvm_err("%s: handling mapped seg tlb fault for %lx, index: %u, vcpu: %p, ASID: %#lx\n",
+					__func__, va, index, vcpu,
+					read_c0_entryhi());
+				er = EMULATE_FAIL;
+				preempt_enable();
+				goto done;
 			}
 		}
 	} else {
@@ -1626,7 +1636,7 @@ kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu, struct kvm_run *run)
 		if (vcpu->mmio_needed == 2)
 			*gpr = *(int16_t *) run->mmio.data;
 		else
-			*gpr = *(int16_t *) run->mmio.data;
+			*gpr = *(uint16_t *)run->mmio.data;
 
 		break;
 	case 1:
@@ -1821,8 +1831,13 @@ kvm_mips_handle_tlbmiss(unsigned long cause, uint32_t *opc,
 			     tlb->tlb_hi, tlb->tlb_lo0, tlb->tlb_lo1);
 #endif
 			/* OK we have a Guest TLB entry, now inject it into the shadow host TLB */
-			kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb, NULL,
-							     NULL);
+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,
+								 NULL, NULL)) {
+				kvm_err("%s: handling mapped seg tlb fault for %lx, index: %u, vcpu: %p, ASID: %#lx\n",
+					__func__, va, index, vcpu,
+					read_c0_entryhi());
+				er = EMULATE_FAIL;
+			}
 		}
 	}
 
diff --git a/arch/mips/kvm/kvm_mips_int.h b/arch/mips/kvm/kvm_mips_int.h
index 20da7d2..bf41ea3 100644
--- a/arch/mips/kvm/kvm_mips_int.h
+++ b/arch/mips/kvm/kvm_mips_int.h
@@ -27,6 +27,8 @@
 #define MIPS_EXC_MAX                12
 /* XXXSL More to follow */
 
+extern char __kvm_mips_vcpu_run_end[];
+
 #define C_TI        (_ULCAST_(1) << 30)
 
 #define KVM_MIPS_IRQ_DELIVER_ALL_AT_ONCE (0)
diff --git a/arch/mips/kvm/kvm_tlb.c b/arch/mips/kvm/kvm_tlb.c
index c777dd3..8a47bd9 100644
--- a/arch/mips/kvm/kvm_tlb.c
+++ b/arch/mips/kvm/kvm_tlb.c
@@ -182,7 +182,7 @@ static int kvm_mips_map_page(struct kvm *kvm, gfn_t gfn)
         srcu_idx = srcu_read_lock(&kvm->srcu);
 	pfn = kvm_mips_gfn_to_pfn(kvm, gfn);
 
-	if (kvm_mips_is_error_pfn(pfn)) {
+	if (is_error_noslot_pfn(pfn)) {
 		kvm_err("Couldn't get pfn for gfn %#" PRIx64 "!\n", gfn);
 		err = -EFAULT;
 		goto out;
@@ -312,7 +312,7 @@ int kvm_mips_handle_kseg0_tlb_fault(unsigned long badvaddr,
 	}
 
 	gfn = (KVM_GUEST_CPHYSADDR(badvaddr) >> PAGE_SHIFT);
-	if (gfn >= kvm->arch.guest_pmap_npages) {
+	if ((gfn | 1) >= kvm->arch.guest_pmap_npages) {
 		kvm_err("%s: Invalid gfn: %#llx, BadVaddr: %#lx\n", __func__,
 			gfn, badvaddr);
 		kvm_mips_dump_host_tlbs();
@@ -397,21 +397,38 @@ kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,
 	unsigned long entryhi = 0, entrylo0 = 0, entrylo1 = 0;
 	struct kvm *kvm = vcpu->kvm;
 	pfn_t pfn0, pfn1;
+	gfn_t gfn0, gfn1;
+	long tlb_lo[2];
+
+	tlb_lo[0] = tlb->tlb_lo0;
+	tlb_lo[1] = tlb->tlb_lo1;
+
+	/*
+	 * The commpage address must not be mapped to anything else if the guest
+	 * TLB contains entries nearby, or commpage accesses will break.
+	 */
+	if (!((tlb->tlb_hi ^ KVM_GUEST_COMMPAGE_ADDR) &
+			VPN2_MASK & (PAGE_MASK << 1)))
+		tlb_lo[(KVM_GUEST_COMMPAGE_ADDR >> PAGE_SHIFT) & 1] = 0;
+
+	gfn0 = mips3_tlbpfn_to_paddr(tlb_lo[0]) >> PAGE_SHIFT;
+	gfn1 = mips3_tlbpfn_to_paddr(tlb_lo[1]) >> PAGE_SHIFT;
+	if (gfn0 >= kvm->arch.guest_pmap_npages ||
+	    gfn1 >= kvm->arch.guest_pmap_npages) {
+		kvm_err("%s: Invalid gfn: [%#llx, %#llx], EHi: %#lx\n",
+			__func__, gfn0, gfn1, tlb->tlb_hi);
+		kvm_mips_dump_guest_tlbs(vcpu);
+		return -1;
+	}
 
+	if (kvm_mips_map_page(kvm, gfn0) < 0)
+		return -1;
 
-	if ((tlb->tlb_hi & VPN2_MASK) == 0) {
-		pfn0 = 0;
-		pfn1 = 0;
-	} else {
-		if (kvm_mips_map_page(kvm, mips3_tlbpfn_to_paddr(tlb->tlb_lo0) >> PAGE_SHIFT) < 0)
-			return -1;
-
-		if (kvm_mips_map_page(kvm, mips3_tlbpfn_to_paddr(tlb->tlb_lo1) >> PAGE_SHIFT) < 0)
-			return -1;
+	if (kvm_mips_map_page(kvm, gfn1) < 0)
+		return -1;
 
-		pfn0 = kvm->arch.guest_pmap[mips3_tlbpfn_to_paddr(tlb->tlb_lo0) >> PAGE_SHIFT];
-		pfn1 = kvm->arch.guest_pmap[mips3_tlbpfn_to_paddr(tlb->tlb_lo1) >> PAGE_SHIFT];
-	}
+	pfn0 = kvm->arch.guest_pmap[gfn0];
+	pfn1 = kvm->arch.guest_pmap[gfn1];
 
 	if (hpa0)
 		*hpa0 = pfn0 << PAGE_SHIFT;
@@ -423,9 +440,9 @@ kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,
 	entryhi = (tlb->tlb_hi & VPN2_MASK) | (KVM_GUEST_KERNEL_MODE(vcpu) ?
 			kvm_mips_get_kernel_asid(vcpu) : kvm_mips_get_user_asid(vcpu));
 	entrylo0 = mips3_paddr_to_tlbpfn(pfn0 << PAGE_SHIFT) | (0x3 << 3) |
-			(tlb->tlb_lo0 & MIPS3_PG_D) | (tlb->tlb_lo0 & MIPS3_PG_V);
+			(tlb_lo[0] & MIPS3_PG_D) | (tlb_lo[0] & MIPS3_PG_V);
 	entrylo1 = mips3_paddr_to_tlbpfn(pfn1 << PAGE_SHIFT) | (0x3 << 3) |
-			(tlb->tlb_lo1 & MIPS3_PG_D) | (tlb->tlb_lo1 & MIPS3_PG_V);
+			(tlb_lo[1] & MIPS3_PG_D) | (tlb_lo[1] & MIPS3_PG_V);
 
 #ifdef DEBUG
 	kvm_debug("@ %#lx tlb_lo0: 0x%08lx tlb_lo1: 0x%08lx\n", vcpu->arch.pc,
@@ -909,10 +926,16 @@ uint32_t kvm_get_inst(uint32_t *opc, struct kvm_vcpu *vcpu)
 				local_irq_restore(flags);
 				return KVM_INVALID_INST;
 			}
-			kvm_mips_handle_mapped_seg_tlb_fault(vcpu,
-							     &vcpu->arch.
-							     guest_tlb[index],
-							     NULL, NULL);
+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu,
+						&vcpu->arch.guest_tlb[index],
+						NULL, NULL)) {
+				kvm_err("%s: handling mapped seg tlb fault failed for %p, index: %u, vcpu: %p, ASID: %#lx\n",
+					__func__, opc, index, vcpu,
+					read_c0_entryhi());
+				kvm_mips_dump_guest_tlbs(vcpu);
+				local_irq_restore(flags);
+				return KVM_INVALID_INST;
+			}
 			inst = *(opc);
 		}
 		local_irq_restore(flags);
diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c
index f03771900..3d492a8 100644
--- a/arch/mips/math-emu/cp1emu.c
+++ b/arch/mips/math-emu/cp1emu.c
@@ -684,9 +684,11 @@ static int isBranchInstr(struct pt_regs *regs, struct mm_decoded_insn dec_insn,
 	case spec_op:
 		switch (insn.r_format.func) {
 		case jalr_op:
-			regs->regs[insn.r_format.rd] =
-				regs->cp0_epc + dec_insn.pc_inc +
-				dec_insn.next_pc_inc;
+			if (insn.r_format.rd != 0) {
+				regs->regs[insn.r_format.rd] =
+					regs->cp0_epc + dec_insn.pc_inc +
+					dec_insn.next_pc_inc;
+			}
 			/* Fall through */
 		case jr_op:
 			*contpc = regs->regs[insn.r_format.rs];
diff --git a/arch/mips/mm/dma-default.c b/arch/mips/mm/dma-default.c
index 23129d1..5fa55b8 100644
--- a/arch/mips/mm/dma-default.c
+++ b/arch/mips/mm/dma-default.c
@@ -91,7 +91,7 @@ static gfp_t massage_gfp_flags(const struct device *dev, gfp_t gfp)
 	else
 #endif
 #if defined(CONFIG_ZONE_DMA) && !defined(CONFIG_ZONE_DMA32)
-	     if (dev->coherent_dma_mask < DMA_BIT_MASK(64))
+	     if (dev->coherent_dma_mask < DMA_BIT_MASK(sizeof(phys_addr_t) * 8))
 		dma_flag = __GFP_DMA;
 	else
 #endif
diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c
index 0214a43..c40a8d1 100644
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@ -157,6 +157,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/mips/power/cpu.c b/arch/mips/power/cpu.c
index 521e596..2129e67 100644
--- a/arch/mips/power/cpu.c
+++ b/arch/mips/power/cpu.c
@@ -7,7 +7,7 @@
  * Author: Hu Hongbing <huhb@lemote.com>
  *	   Wu Zhangjin <wuzhangjin@gmail.com>
  */
-#include <asm/suspend.h>
+#include <asm/sections.h>
 #include <asm/fpu.h>
 #include <asm/dsp.h>
 
diff --git a/arch/mips/power/hibernate.S b/arch/mips/power/hibernate.S
index 32a7c82..e7567c8 100644
--- a/arch/mips/power/hibernate.S
+++ b/arch/mips/power/hibernate.S
@@ -30,6 +30,8 @@ LEAF(swsusp_arch_suspend)
 END(swsusp_arch_suspend)
 
 LEAF(swsusp_arch_resume)
+	/* Avoid TLB mismatch during and after kernel resume */
+	jal local_flush_tlb_all
 	PTR_L t0, restore_pblist
 0:
 	PTR_L t1, PBE_ADDRESS(t0)   /* source */
@@ -43,7 +45,6 @@ LEAF(swsusp_arch_resume)
 	bne t1, t3, 1b
 	PTR_L t0, PBE_NEXT(t0)
 	bnez t0, 0b
-	jal local_flush_tlb_all /* Avoid TLB mismatch after kernel resume */
 	PTR_LA t0, saved_regs
 	PTR_L ra, PT_R31(t0)
 	PTR_L sp, PT_R29(t0)
diff --git a/arch/mn10300/Kconfig b/arch/mn10300/Kconfig
index 428da17..31b9160 100644
--- a/arch/mn10300/Kconfig
+++ b/arch/mn10300/Kconfig
@@ -2,6 +2,7 @@ config MN10300
 	def_bool y
 	select HAVE_OPROFILE
 	select HAVE_GENERIC_HARDIRQS
+	select HAVE_UID16
 	select GENERIC_IRQ_SHOW
 	select ARCH_WANT_IPC_PARSE_VERSION
 	select HAVE_ARCH_TRACEHOOK
@@ -37,9 +38,6 @@ config HIGHMEM
 config NUMA
 	def_bool n
 
-config UID16
-	def_bool y
-
 config RWSEM_GENERIC_SPINLOCK
 	def_bool y
 
diff --git a/arch/mn10300/mm/fault.c b/arch/mn10300/mm/fault.c
index 3516cbd..0c2cc5d 100644
--- a/arch/mn10300/mm/fault.c
+++ b/arch/mn10300/mm/fault.c
@@ -262,6 +262,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/openrisc/Kconfig b/arch/openrisc/Kconfig
index 1072bfd..f4dd44a 100644
--- a/arch/openrisc/Kconfig
+++ b/arch/openrisc/Kconfig
@@ -17,6 +17,7 @@ config OPENRISC
 	select GENERIC_IRQ_SHOW
 	select GENERIC_IOMAP
 	select GENERIC_CPU_DEVICES
+	select HAVE_UID16
 	select GENERIC_ATOMIC64
 	select GENERIC_CLOCKEVENTS
 	select GENERIC_STRNCPY_FROM_USER
@@ -29,9 +30,6 @@ config MMU
 config HAVE_DMA_ATTRS
 	def_bool y
 
-config UID16
-	def_bool y
-
 config RWSEM_GENERIC_SPINLOCK
 	def_bool y
 
diff --git a/arch/openrisc/mm/fault.c b/arch/openrisc/mm/fault.c
index 0703acf..230ac20 100644
--- a/arch/openrisc/mm/fault.c
+++ b/arch/openrisc/mm/fault.c
@@ -171,6 +171,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/parisc/include/asm/ftrace.h b/arch/parisc/include/asm/ftrace.h
index 72c0faf..544ed8e 100644
--- a/arch/parisc/include/asm/ftrace.h
+++ b/arch/parisc/include/asm/ftrace.h
@@ -24,15 +24,7 @@ extern void return_to_handler(void);
 
 extern unsigned long return_address(unsigned int);
 
-#define HAVE_ARCH_CALLER_ADDR
-
-#define CALLER_ADDR0 ((unsigned long)__builtin_return_address(0))
-#define CALLER_ADDR1 return_address(1)
-#define CALLER_ADDR2 return_address(2)
-#define CALLER_ADDR3 return_address(3)
-#define CALLER_ADDR4 return_address(4)
-#define CALLER_ADDR5 return_address(5)
-#define CALLER_ADDR6 return_address(6)
+#define ftrace_return_address(n) return_address(n)
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/arch/parisc/include/uapi/asm/mman.h b/arch/parisc/include/uapi/asm/mman.h
index 294d251..2ae13ce5 100644
--- a/arch/parisc/include/uapi/asm/mman.h
+++ b/arch/parisc/include/uapi/asm/mman.h
@@ -46,16 +46,6 @@
 #define MADV_DONTFORK	10		/* don't inherit across fork */
 #define MADV_DOFORK	11		/* do inherit across fork */
 
-/* The range 12-64 is reserved for page size specification. */
-#define MADV_4K_PAGES   12              /* Use 4K pages  */
-#define MADV_16K_PAGES  14              /* Use 16K pages */
-#define MADV_64K_PAGES  16              /* Use 64K pages */
-#define MADV_256K_PAGES 18              /* Use 256K pages */
-#define MADV_1M_PAGES   20              /* Use 1 Megabyte pages */
-#define MADV_4M_PAGES   22              /* Use 4 Megabyte pages */
-#define MADV_16M_PAGES  24              /* Use 16 Megabyte pages */
-#define MADV_64M_PAGES  26              /* Use 64 Megabyte pages */
-
 #define MADV_MERGEABLE   65		/* KSM may merge identical pages */
 #define MADV_UNMERGEABLE 66		/* KSM may not merge identical pages */
 
diff --git a/arch/parisc/include/uapi/asm/siginfo.h b/arch/parisc/include/uapi/asm/siginfo.h
index d703472..1c75565 100644
--- a/arch/parisc/include/uapi/asm/siginfo.h
+++ b/arch/parisc/include/uapi/asm/siginfo.h
@@ -1,6 +1,10 @@
 #ifndef _PARISC_SIGINFO_H
 #define _PARISC_SIGINFO_H
 
+#if defined(__LP64__)
+#define __ARCH_SI_PREAMBLE_SIZE   (4 * sizeof(int))
+#endif
+
 #include <asm-generic/siginfo.h>
 
 #undef NSIGTRAP
diff --git a/arch/parisc/kernel/irq.c b/arch/parisc/kernel/irq.c
index 2e6443b..c32a37e 100644
--- a/arch/parisc/kernel/irq.c
+++ b/arch/parisc/kernel/irq.c
@@ -524,8 +524,8 @@ void do_cpu_irq_mask(struct pt_regs *regs)
 	struct pt_regs *old_regs;
 	unsigned long eirr_val;
 	int irq, cpu = smp_processor_id();
-#ifdef CONFIG_SMP
 	struct irq_desc *desc;
+#ifdef CONFIG_SMP
 	cpumask_t dest;
 #endif
 
@@ -538,8 +538,12 @@ void do_cpu_irq_mask(struct pt_regs *regs)
 		goto set_out;
 	irq = eirr_to_irq(eirr_val);
 
-#ifdef CONFIG_SMP
+	/* Filter out spurious interrupts, mostly from serial port at bootup */
 	desc = irq_to_desc(irq);
+	if (unlikely(!desc->action))
+		goto set_out;
+
+#ifdef CONFIG_SMP
 	cpumask_copy(&dest, desc->irq_data.affinity);
 	if (irqd_is_per_cpu(&desc->irq_data) &&
 	    !cpu_isset(smp_processor_id(), dest)) {
diff --git a/arch/parisc/kernel/parisc_ksyms.c b/arch/parisc/kernel/parisc_ksyms.c
index 568b2c6..3cad8aa 100644
--- a/arch/parisc/kernel/parisc_ksyms.c
+++ b/arch/parisc/kernel/parisc_ksyms.c
@@ -47,11 +47,11 @@ EXPORT_SYMBOL(__cmpxchg_u64);
 EXPORT_SYMBOL(lclear_user);
 EXPORT_SYMBOL(lstrnlen_user);
 
-/* Global fixups */
-extern void fixup_get_user_skip_1(void);
-extern void fixup_get_user_skip_2(void);
-extern void fixup_put_user_skip_1(void);
-extern void fixup_put_user_skip_2(void);
+/* Global fixups - defined as int to avoid creation of function pointers */
+extern int fixup_get_user_skip_1;
+extern int fixup_get_user_skip_2;
+extern int fixup_put_user_skip_1;
+extern int fixup_put_user_skip_2;
 EXPORT_SYMBOL(fixup_get_user_skip_1);
 EXPORT_SYMBOL(fixup_get_user_skip_2);
 EXPORT_SYMBOL(fixup_put_user_skip_1);
diff --git a/arch/parisc/kernel/signal.c b/arch/parisc/kernel/signal.c
index 940188d..ae9aa83 100644
--- a/arch/parisc/kernel/signal.c
+++ b/arch/parisc/kernel/signal.c
@@ -449,6 +449,55 @@ handle_signal(unsigned long sig, siginfo_t *info, struct k_sigaction *ka,
 		regs->gr[28]);
 }
 
+/*
+ * Check how the syscall number gets loaded into %r20 within
+ * the delay branch in userspace and adjust as needed.
+ */
+
+static void check_syscallno_in_delay_branch(struct pt_regs *regs)
+{
+	u32 opcode, source_reg;
+	u32 __user *uaddr;
+	int err;
+
+	/* Usually we don't have to restore %r20 (the system call number)
+	 * because it gets loaded in the delay slot of the branch external
+	 * instruction via the ldi instruction.
+	 * In some cases a register-to-register copy instruction might have
+	 * been used instead, in which case we need to copy the syscall
+	 * number into the source register before returning to userspace.
+	 */
+
+	/* A syscall is just a branch, so all we have to do is fiddle the
+	 * return pointer so that the ble instruction gets executed again.
+	 */
+	regs->gr[31] -= 8; /* delayed branching */
+
+	/* Get assembler opcode of code in delay branch */
+	uaddr = (unsigned int *) ((regs->gr[31] & ~3) + 4);
+	err = get_user(opcode, uaddr);
+	if (err)
+		return;
+
+	/* Check if delay branch uses "ldi int,%r20" */
+	if ((opcode & 0xffff0000) == 0x34140000)
+		return;	/* everything ok, just return */
+
+	/* Check if delay branch uses "nop" */
+	if (opcode == INSN_NOP)
+		return;
+
+	/* Check if delay branch uses "copy %rX,%r20" */
+	if ((opcode & 0xffe0ffff) == 0x08000254) {
+		source_reg = (opcode >> 16) & 31;
+		regs->gr[source_reg] = regs->gr[20];
+		return;
+	}
+
+	pr_warn("syscall restart: %s (pid %d): unexpected opcode 0x%08x\n",
+		current->comm, task_pid_nr(current), opcode);
+}
+
 static inline void
 syscall_restart(struct pt_regs *regs, struct k_sigaction *ka)
 {
@@ -471,10 +520,7 @@ syscall_restart(struct pt_regs *regs, struct k_sigaction *ka)
 		}
 		/* fallthrough */
 	case -ERESTARTNOINTR:
-		/* A syscall is just a branch, so all
-		 * we have to do is fiddle the return pointer.
-		 */
-		regs->gr[31] -= 8; /* delayed branching */
+		check_syscallno_in_delay_branch(regs);
 		break;
 	}
 }
@@ -523,15 +569,9 @@ insert_restart_trampoline(struct pt_regs *regs)
 	}
 	case -ERESTARTNOHAND:
 	case -ERESTARTSYS:
-	case -ERESTARTNOINTR: {
-		/* Hooray for delayed branching.  We don't
-		 * have to restore %r20 (the system call
-		 * number) because it gets loaded in the delay
-		 * slot of the branch external instruction.
-		 */
-		regs->gr[31] -= 8;
+	case -ERESTARTNOINTR:
+		check_syscallno_in_delay_branch(regs);
 		return;
-	}
 	default:
 		break;
 	}
diff --git a/arch/parisc/kernel/traps.c b/arch/parisc/kernel/traps.c
index b3f87a3..0c329b2 100644
--- a/arch/parisc/kernel/traps.c
+++ b/arch/parisc/kernel/traps.c
@@ -811,6 +811,9 @@ void notrace handle_interruption(int code, struct pt_regs *regs)
 
 	    if (fault_space == 0 && !in_atomic())
 	    {
+		/* Clean up and return if in exception table. */
+		if (fixup_exception(regs))
+			return;
 		pdc_chassis_send_status(PDC_CHASSIS_DIRECT_PANIC);
 		parisc_terminate("Kernel Fault", regs, code, fault_address);
 	    }
diff --git a/arch/parisc/kernel/unaligned.c b/arch/parisc/kernel/unaligned.c
index d7c0acb..8d49614 100644
--- a/arch/parisc/kernel/unaligned.c
+++ b/arch/parisc/kernel/unaligned.c
@@ -666,7 +666,7 @@ void handle_unaligned(struct pt_regs *regs)
 		break;
 	}
 
-	if (modify && R1(regs->iir))
+	if (ret == 0 && modify && R1(regs->iir))
 		regs->gr[R1(regs->iir)] = newbase;
 
 
@@ -677,6 +677,14 @@ void handle_unaligned(struct pt_regs *regs)
 
 	if (ret)
 	{
+		/*
+		 * The unaligned handler failed.
+		 * If we were called by __get_user() or __put_user() jump
+		 * to it's exception fixup handler instead of crashing.
+		 */
+		if (!user_mode(regs) && fixup_exception(regs))
+			return;
+
 		printk(KERN_CRIT "Unaligned handler failed, ret = %d\n", ret);
 		die_if_kernel("Unaligned data reference", regs, 28);
 
diff --git a/arch/parisc/mm/fault.c b/arch/parisc/mm/fault.c
index d10d27a..c45130f5 100644
--- a/arch/parisc/mm/fault.c
+++ b/arch/parisc/mm/fault.c
@@ -220,6 +220,8 @@ good_area:
 		 */
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto bad_area;
 		BUG();
diff --git a/arch/powerpc/boot/dts/fsl/pq3-etsec2-0.dtsi b/arch/powerpc/boot/dts/fsl/pq3-etsec2-0.dtsi
index 1382fec..7fcb1ac 100644
--- a/arch/powerpc/boot/dts/fsl/pq3-etsec2-0.dtsi
+++ b/arch/powerpc/boot/dts/fsl/pq3-etsec2-0.dtsi
@@ -50,6 +50,7 @@ ethernet@b0000 {
 	fsl,num_tx_queues = <0x8>;
 	fsl,magic-packet;
 	local-mac-address = [ 00 00 00 00 00 00 ];
+	ranges;
 
 	queue-group@b0000 {
 		#address-cells = <1>;
diff --git a/arch/powerpc/boot/dts/fsl/pq3-etsec2-1.dtsi b/arch/powerpc/boot/dts/fsl/pq3-etsec2-1.dtsi
index 221cd2e..9f25427 100644
--- a/arch/powerpc/boot/dts/fsl/pq3-etsec2-1.dtsi
+++ b/arch/powerpc/boot/dts/fsl/pq3-etsec2-1.dtsi
@@ -50,6 +50,7 @@ ethernet@b1000 {
 	fsl,num_tx_queues = <0x8>;
 	fsl,magic-packet;
 	local-mac-address = [ 00 00 00 00 00 00 ];
+	ranges;
 
 	queue-group@b1000 {
 		#address-cells = <1>;
diff --git a/arch/powerpc/boot/dts/fsl/pq3-etsec2-2.dtsi b/arch/powerpc/boot/dts/fsl/pq3-etsec2-2.dtsi
index 61456c3..cd7c318 100644
--- a/arch/powerpc/boot/dts/fsl/pq3-etsec2-2.dtsi
+++ b/arch/powerpc/boot/dts/fsl/pq3-etsec2-2.dtsi
@@ -49,6 +49,7 @@ ethernet@b2000 {
 	fsl,num_tx_queues = <0x8>;
 	fsl,magic-packet;
 	local-mac-address = [ 00 00 00 00 00 00 ];
+	ranges;
 
 	queue-group@b2000 {
 		#address-cells = <1>;
diff --git a/arch/powerpc/include/asm/cmpxchg.h b/arch/powerpc/include/asm/cmpxchg.h
index e245aab..95b5151 100644
--- a/arch/powerpc/include/asm/cmpxchg.h
+++ b/arch/powerpc/include/asm/cmpxchg.h
@@ -18,12 +18,12 @@ __xchg_u32(volatile void *p, unsigned long val)
 	unsigned long prev;
 
 	__asm__ __volatile__(
-	PPC_RELEASE_BARRIER
+	PPC_ATOMIC_ENTRY_BARRIER
 "1:	lwarx	%0,0,%2 \n"
 	PPC405_ERR77(0,%2)
 "	stwcx.	%3,0,%2 \n\
 	bne-	1b"
-	PPC_ACQUIRE_BARRIER
+	PPC_ATOMIC_EXIT_BARRIER
 	: "=&r" (prev), "+m" (*(volatile unsigned int *)p)
 	: "r" (p), "r" (val)
 	: "cc", "memory");
@@ -61,12 +61,12 @@ __xchg_u64(volatile void *p, unsigned long val)
 	unsigned long prev;
 
 	__asm__ __volatile__(
-	PPC_RELEASE_BARRIER
+	PPC_ATOMIC_ENTRY_BARRIER
 "1:	ldarx	%0,0,%2 \n"
 	PPC405_ERR77(0,%2)
 "	stdcx.	%3,0,%2 \n\
 	bne-	1b"
-	PPC_ACQUIRE_BARRIER
+	PPC_ATOMIC_EXIT_BARRIER
 	: "=&r" (prev), "+m" (*(volatile unsigned long *)p)
 	: "r" (p), "r" (val)
 	: "cc", "memory");
@@ -152,14 +152,14 @@ __cmpxchg_u32(volatile unsigned int *p, unsigned long old, unsigned long new)
 	unsigned int prev;
 
 	__asm__ __volatile__ (
-	PPC_RELEASE_BARRIER
+	PPC_ATOMIC_ENTRY_BARRIER
 "1:	lwarx	%0,0,%2		# __cmpxchg_u32\n\
 	cmpw	0,%0,%3\n\
 	bne-	2f\n"
 	PPC405_ERR77(0,%2)
 "	stwcx.	%4,0,%2\n\
 	bne-	1b"
-	PPC_ACQUIRE_BARRIER
+	PPC_ATOMIC_EXIT_BARRIER
 	"\n\
 2:"
 	: "=&r" (prev), "+m" (*p)
@@ -198,13 +198,13 @@ __cmpxchg_u64(volatile unsigned long *p, unsigned long old, unsigned long new)
 	unsigned long prev;
 
 	__asm__ __volatile__ (
-	PPC_RELEASE_BARRIER
+	PPC_ATOMIC_ENTRY_BARRIER
 "1:	ldarx	%0,0,%2		# __cmpxchg_u64\n\
 	cmpd	0,%0,%3\n\
 	bne-	2f\n\
 	stdcx.	%4,0,%2\n\
 	bne-	1b"
-	PPC_ACQUIRE_BARRIER
+	PPC_ATOMIC_EXIT_BARRIER
 	"\n\
 2:"
 	: "=&r" (prev), "+m" (*p)
diff --git a/arch/powerpc/include/asm/pgtable-ppc64.h b/arch/powerpc/include/asm/pgtable-ppc64.h
index e3d55f6f..6fbb2b4 100644
--- a/arch/powerpc/include/asm/pgtable-ppc64.h
+++ b/arch/powerpc/include/asm/pgtable-ppc64.h
@@ -130,7 +130,19 @@
 #define pte_iterate_hashed_end() } while(0)
 
 #ifdef CONFIG_PPC_HAS_HASH_64K
-#define pte_pagesize_index(mm, addr, pte)	get_slice_psize(mm, addr)
+/*
+ * We expect this to be called only for user addresses or kernel virtual
+ * addresses other than the linear mapping.
+ */
+#define pte_pagesize_index(mm, addr, pte)			\
+	({							\
+		unsigned int psize;				\
+		if (is_kernel_addr(addr))			\
+			psize = MMU_PAGE_4K;			\
+		else						\
+			psize = get_slice_psize(mm, addr);	\
+		psize;						\
+	})
 #else
 #define pte_pagesize_index(mm, addr, pte)	MMU_PAGE_4K
 #endif
diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h
index 795f677..469d771 100644
--- a/arch/powerpc/include/asm/reg.h
+++ b/arch/powerpc/include/asm/reg.h
@@ -108,6 +108,7 @@
 #define MSR_TS_T	__MASK(MSR_TS_T_LG)	/*  Transaction Transactional */
 #define MSR_TS_MASK	(MSR_TS_T | MSR_TS_S)   /* Transaction State bits */
 #define MSR_TM_ACTIVE(x) (((x) & MSR_TS_MASK) != 0) /* Transaction active? */
+#define MSR_TM_RESV(x) (((x) & MSR_TS_MASK) == MSR_TS_MASK) /* Reserved */
 #define MSR_TM_TRANSACTIONAL(x)	(((x) & MSR_TS_MASK) == MSR_TS_T)
 #define MSR_TM_SUSPENDED(x)	(((x) & MSR_TS_MASK) == MSR_TS_S)
 
@@ -642,7 +643,7 @@
 #define   MMCR0_FCWAIT	0x00000002UL /* freeze counter in WAIT state */
 #define   MMCR0_FCHV	0x00000001UL /* freeze conditions in hypervisor mode */
 #define SPRN_MMCR1	798
-#define SPRN_MMCR2	769
+#define SPRN_MMCR2	785
 #define SPRN_MMCRA	0x312
 #define   MMCRA_SDSYNC	0x80000000UL /* SDAR synced with SIAR */
 #define   MMCRA_SDAR_DCACHE_MISS 0x40000000UL
@@ -676,13 +677,13 @@
 #define SPRN_PMC6	792
 #define SPRN_PMC7	793
 #define SPRN_PMC8	794
-#define SPRN_SIAR	780
-#define SPRN_SDAR	781
 #define SPRN_SIER	784
 #define   SIER_SIPR		0x2000000	/* Sampled MSR_PR */
 #define   SIER_SIHV		0x1000000	/* Sampled MSR_HV */
 #define   SIER_SIAR_VALID	0x0400000	/* SIAR contents valid */
 #define   SIER_SDAR_VALID	0x0200000	/* SDAR contents valid */
+#define SPRN_SIAR	796
+#define SPRN_SDAR	797
 
 #define SPRN_PA6T_MMCR0 795
 #define   PA6T_MMCR0_EN0	0x0000000000000001UL
diff --git a/arch/powerpc/include/asm/rtas.h b/arch/powerpc/include/asm/rtas.h
index 34fd704..c5d5cb3 100644
--- a/arch/powerpc/include/asm/rtas.h
+++ b/arch/powerpc/include/asm/rtas.h
@@ -255,6 +255,7 @@ extern void rtas_power_off(void);
 extern void rtas_halt(void);
 extern void rtas_os_term(char *str);
 extern int rtas_get_sensor(int sensor, int index, int *state);
+extern int rtas_get_sensor_fast(int sensor, int index, int *state);
 extern int rtas_get_power_level(int powerdomain, int *level);
 extern int rtas_set_power_level(int powerdomain, int level, int *setlevel);
 extern bool rtas_indicator_present(int token, int *maxindex);
diff --git a/arch/powerpc/include/asm/synch.h b/arch/powerpc/include/asm/synch.h
index e682a71..c508686 100644
--- a/arch/powerpc/include/asm/synch.h
+++ b/arch/powerpc/include/asm/synch.h
@@ -44,7 +44,7 @@ static inline void isync(void)
 	MAKE_LWSYNC_SECTION_ENTRY(97, __lwsync_fixup);
 #define PPC_ACQUIRE_BARRIER	 "\n" stringify_in_c(__PPC_ACQUIRE_BARRIER)
 #define PPC_RELEASE_BARRIER	 stringify_in_c(LWSYNC) "\n"
-#define PPC_ATOMIC_ENTRY_BARRIER "\n" stringify_in_c(LWSYNC) "\n"
+#define PPC_ATOMIC_ENTRY_BARRIER "\n" stringify_in_c(sync) "\n"
 #define PPC_ATOMIC_EXIT_BARRIER	 "\n" stringify_in_c(sync) "\n"
 #else
 #define PPC_ACQUIRE_BARRIER
diff --git a/arch/powerpc/include/uapi/asm/cputable.h b/arch/powerpc/include/uapi/asm/cputable.h
index de2c0e4..67de80a 100644
--- a/arch/powerpc/include/uapi/asm/cputable.h
+++ b/arch/powerpc/include/uapi/asm/cputable.h
@@ -31,6 +31,7 @@
 #define PPC_FEATURE_PSERIES_PERFMON_COMPAT \
 					0x00000040
 
+/* Reserved - do not use		0x00000004 */
 #define PPC_FEATURE_TRUE_LE		0x00000002
 #define PPC_FEATURE_PPC_LE		0x00000001
 
diff --git a/arch/powerpc/kernel/exceptions-64s.S b/arch/powerpc/kernel/exceptions-64s.S
index 902ca3c..3ac1d3a 100644
--- a/arch/powerpc/kernel/exceptions-64s.S
+++ b/arch/powerpc/kernel/exceptions-64s.S
@@ -857,11 +857,6 @@ hv_facility_unavailable_relon_trampoline:
 #endif
 	STD_RELON_EXCEPTION_PSERIES(0x5700, 0x1700, altivec_assist)
 
-	/* Other future vectors */
-	.align	7
-	.globl	__end_interrupts
-__end_interrupts:
-
 	.align	7
 system_call_entry_direct:
 #if defined(CONFIG_RELOCATABLE)
@@ -1191,6 +1186,17 @@ __end_handlers:
 	STD_RELON_EXCEPTION_PSERIES_OOL(0xf60, facility_unavailable)
 	STD_RELON_EXCEPTION_HV_OOL(0xf80, hv_facility_unavailable)
 
+	/*
+	 * The __end_interrupts marker must be past the out-of-line (OOL)
+	 * handlers, so that they are copied to real address 0x100 when running
+	 * a relocatable kernel. This ensures they can be reached from the short
+	 * trampoline handlers (like 0x4f00, 0x4f20, etc.) which branch
+	 * directly, without using LOAD_HANDLER().
+	 */
+	.align	7
+	.globl	__end_interrupts
+__end_interrupts:
+
 #if defined(CONFIG_PPC_PSERIES) || defined(CONFIG_PPC_POWERNV)
 /*
  * Data area reserved for FWNMI option.
diff --git a/arch/powerpc/kernel/module_64.c b/arch/powerpc/kernel/module_64.c
index 6ee59a0..48b4cf6 100644
--- a/arch/powerpc/kernel/module_64.c
+++ b/arch/powerpc/kernel/module_64.c
@@ -192,7 +192,7 @@ static void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)
 		if (syms[i].st_shndx == SHN_UNDEF) {
 			char *name = strtab + syms[i].st_name;
 			if (name[0] == '.')
-				memmove(name, name+1, strlen(name));
+				syms[i].st_name++;
 		}
 	}
 }
diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c
index 8b6f7a9..e8c45b7 100644
--- a/arch/powerpc/kernel/prom.c
+++ b/arch/powerpc/kernel/prom.c
@@ -159,7 +159,7 @@ static struct ibm_pa_feature {
 	{CPU_FTR_NOEXECUTE, 0, 0,	0, 6, 0},
 	{CPU_FTR_NODSISRALIGN, 0, 0,	1, 1, 1},
 	{0, MMU_FTR_CI_LARGE_PAGE, 0,	1, 2, 0},
-	{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},
+	{CPU_FTR_REAL_LE, 0, PPC_FEATURE_TRUE_LE, 5, 0, 0},
 };
 
 static void __init scan_features(unsigned long node, unsigned char *ftrs,
diff --git a/arch/powerpc/kernel/rtas.c b/arch/powerpc/kernel/rtas.c
index 52add6f..8d3722a 100644
--- a/arch/powerpc/kernel/rtas.c
+++ b/arch/powerpc/kernel/rtas.c
@@ -584,6 +584,23 @@ int rtas_get_sensor(int sensor, int index, int *state)
 }
 EXPORT_SYMBOL(rtas_get_sensor);
 
+int rtas_get_sensor_fast(int sensor, int index, int *state)
+{
+	int token = rtas_token("get-sensor-state");
+	int rc;
+
+	if (token == RTAS_UNKNOWN_SERVICE)
+		return -ENOENT;
+
+	rc = rtas_call(token, 2, 2, state, sensor, index);
+	WARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&
+				    rc <= RTAS_EXTENDED_DELAY_MAX));
+
+	if (rc < 0)
+		return rtas_error_rc(rc);
+	return rc;
+}
+
 bool rtas_indicator_present(int token, int *maxindex)
 {
 	int proplen, count, i;
@@ -1024,6 +1041,9 @@ asmlinkage int ppc_rtas(struct rtas_args __user *uargs)
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+	if (!rtas.entry)
+		return -EINVAL;
+
 	if (copy_from_user(&args, uargs, 3 * sizeof(u32)) != 0)
 		return -EFAULT;
 
diff --git a/arch/powerpc/kernel/signal_32.c b/arch/powerpc/kernel/signal_32.c
index 81f929f..8220ae8 100644
--- a/arch/powerpc/kernel/signal_32.c
+++ b/arch/powerpc/kernel/signal_32.c
@@ -858,6 +858,15 @@ static long restore_tm_user_regs(struct pt_regs *regs,
 		return 1;
 #endif /* CONFIG_SPE */
 
+	/* Get the top half of the MSR from the user context */
+	if (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))
+		return 1;
+	msr_hi <<= 32;
+	/* If TM bits are set to the reserved value, it's an invalid context */
+	if (MSR_TM_RESV(msr_hi))
+		return 1;
+	/* Pull in the MSR TM bits from the user context */
+	regs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);
 	/* Now, recheckpoint.  This loads up all of the checkpointed (older)
 	 * registers, including FP and V[S]Rs.  After recheckpointing, the
 	 * transactional versions should be loaded.
@@ -867,11 +876,6 @@ static long restore_tm_user_regs(struct pt_regs *regs,
 	current->thread.tm_texasr |= TEXASR_FS;
 	/* This loads the checkpointed FP/VEC state, if used */
 	tm_recheckpoint(&current->thread, msr);
-	/* Get the top half of the MSR */
-	if (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))
-		return 1;
-	/* Pull in MSR TM from user context */
-	regs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK);
 
 	/* This loads the speculative FP/VEC state, if used */
 	if (msr & MSR_FP) {
@@ -949,8 +953,6 @@ int copy_siginfo_to_user32(struct compat_siginfo __user *d, siginfo_t *s)
 
 int copy_siginfo_from_user32(siginfo_t *to, struct compat_siginfo __user *from)
 {
-	memset(to, 0, sizeof *to);
-
 	if (copy_from_user(to, from, 3*sizeof(int)) ||
 	    copy_from_user(to->_sifields._pad,
 			   from->_sifields._pad, SI_PAD_SIZE32))
diff --git a/arch/powerpc/kernel/signal_64.c b/arch/powerpc/kernel/signal_64.c
index 74d9615..2419c17 100644
--- a/arch/powerpc/kernel/signal_64.c
+++ b/arch/powerpc/kernel/signal_64.c
@@ -416,6 +416,10 @@ static long restore_tm_sigcontexts(struct pt_regs *regs,
 
 	/* get MSR separately, transfer the LE bit if doing signal return */
 	err |= __get_user(msr, &sc->gp_regs[PT_MSR]);
+	/* Don't allow reserved mode. */
+	if (MSR_TM_RESV(msr))
+		return -EINVAL;
+
 	/* pull in MSR TM from user context */
 	regs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK);
 
diff --git a/arch/powerpc/kernel/suspend.c b/arch/powerpc/kernel/suspend.c
index 0167d53..a531154 100644
--- a/arch/powerpc/kernel/suspend.c
+++ b/arch/powerpc/kernel/suspend.c
@@ -9,9 +9,7 @@
 
 #include <linux/mm.h>
 #include <asm/page.h>
-
-/* References to section boundaries */
-extern const void __nosave_begin, __nosave_end;
+#include <asm/sections.h>
 
 /*
  *	pfn_is_nosave - check if given pfn is in the 'nosave' section
diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S
index f096e72..1db6851 100644
--- a/arch/powerpc/kernel/vmlinux.lds.S
+++ b/arch/powerpc/kernel/vmlinux.lds.S
@@ -213,6 +213,7 @@ SECTIONS
 		*(.opd)
 	}
 
+	. = ALIGN(256);
 	.got : AT(ADDR(.got) - LOAD_OFFSET) {
 		__toc_start = .;
 #ifndef CONFIG_RELOCATABLE
diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c
index 102ad8a..466fbd5 100644
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@ -160,6 +160,12 @@ void kvmppc_core_vcpu_put(struct kvm_vcpu *vcpu)
 
 void kvmppc_set_msr(struct kvm_vcpu *vcpu, u64 msr)
 {
+	/*
+	 * Check for illegal transactional state bit combination
+	 * and if we find it, force the TS field to a safe state.
+	 */
+	if ((msr & MSR_TS_MASK) == MSR_TS_MASK)
+		msr &= ~MSR_TS_MASK;
 	vcpu->arch.shregs.msr = msr;
 	kvmppc_end_cede(vcpu);
 }
diff --git a/arch/powerpc/mm/fault.c b/arch/powerpc/mm/fault.c
index d9196c9..d51a0c1 100644
--- a/arch/powerpc/mm/fault.c
+++ b/arch/powerpc/mm/fault.c
@@ -425,6 +425,8 @@ good_area:
 	 */
 	fault = handle_mm_fault(mm, vma, address, flags);
 	if (unlikely(fault & (VM_FAULT_RETRY|VM_FAULT_ERROR))) {
+		if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		rc = mm_fault_error(regs, address, fault);
 		if (rc >= MM_FAULT_RETURN)
 			goto bail;
diff --git a/arch/powerpc/perf/callchain.c b/arch/powerpc/perf/callchain.c
index 2396dda..ead5535 100644
--- a/arch/powerpc/perf/callchain.c
+++ b/arch/powerpc/perf/callchain.c
@@ -243,7 +243,7 @@ static void perf_callchain_user_64(struct perf_callchain_entry *entry,
 	sp = regs->gpr[1];
 	perf_callchain_store(entry, next_ip);
 
-	for (;;) {
+	while (entry->nr < PERF_MAX_STACK_DEPTH) {
 		fp = (unsigned long __user *) sp;
 		if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))
 			return;
diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c
index 846861a..b63dc80 100644
--- a/arch/powerpc/perf/core-book3s.c
+++ b/arch/powerpc/perf/core-book3s.c
@@ -112,7 +112,16 @@ static inline void power_pmu_bhrb_read(struct cpu_hw_events *cpuhw) {}
 
 static bool regs_use_siar(struct pt_regs *regs)
 {
-	return !!regs->result;
+	/*
+	 * When we take a performance monitor exception the regs are setup
+	 * using perf_read_regs() which overloads some fields, in particular
+	 * regs->result to tell us whether to use SIAR.
+	 *
+	 * However if the regs are from another exception, eg. a syscall, then
+	 * they have not been setup using perf_read_regs() and so regs->result
+	 * is something random.
+	 */
+	return ((TRAP(regs) == 0xf00) && regs->result);
 }
 
 /*
diff --git a/arch/powerpc/platforms/cell/spu_fault.c b/arch/powerpc/platforms/cell/spu_fault.c
index 641e727..62f3e4e 100644
--- a/arch/powerpc/platforms/cell/spu_fault.c
+++ b/arch/powerpc/platforms/cell/spu_fault.c
@@ -75,7 +75,7 @@ int spu_handle_mm_fault(struct mm_struct *mm, unsigned long ea,
 		if (*flt & VM_FAULT_OOM) {
 			ret = -ENOMEM;
 			goto out_unlock;
-		} else if (*flt & VM_FAULT_SIGBUS) {
+		} else if (*flt & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV)) {
 			ret = -EFAULT;
 			goto out_unlock;
 		}
diff --git a/arch/powerpc/platforms/cell/spufs/inode.c b/arch/powerpc/platforms/cell/spufs/inode.c
index 35f77a4..c5c5788 100644
--- a/arch/powerpc/platforms/cell/spufs/inode.c
+++ b/arch/powerpc/platforms/cell/spufs/inode.c
@@ -164,7 +164,7 @@ static void spufs_prune_dir(struct dentry *dir)
 	struct dentry *dentry, *tmp;
 
 	mutex_lock(&dir->d_inode->i_mutex);
-	list_for_each_entry_safe(dentry, tmp, &dir->d_subdirs, d_u.d_child) {
+	list_for_each_entry_safe(dentry, tmp, &dir->d_subdirs, d_child) {
 		spin_lock(&dentry->d_lock);
 		if (!(d_unhashed(dentry)) && dentry->d_inode) {
 			dget_dlock(dentry);
diff --git a/arch/powerpc/platforms/powernv/pci.c b/arch/powerpc/platforms/powernv/pci.c
index 8ee842c..0473d31 100644
--- a/arch/powerpc/platforms/powernv/pci.c
+++ b/arch/powerpc/platforms/powernv/pci.c
@@ -106,6 +106,7 @@ static void pnv_teardown_msi_irqs(struct pci_dev *pdev)
 	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
 	struct pnv_phb *phb = hose->private_data;
 	struct msi_desc *entry;
+	irq_hw_number_t hwirq;
 
 	if (WARN_ON(!phb))
 		return;
@@ -113,10 +114,10 @@ static void pnv_teardown_msi_irqs(struct pci_dev *pdev)
 	list_for_each_entry(entry, &pdev->msi_list, list) {
 		if (entry->irq == NO_IRQ)
 			continue;
+		hwirq = virq_to_hw(entry->irq);
 		irq_set_msi_desc(entry->irq, NULL);
-		msi_bitmap_free_hwirqs(&phb->msi_bmp,
-			virq_to_hw(entry->irq) - phb->msi_base, 1);
 		irq_dispose_mapping(entry->irq);
+		msi_bitmap_free_hwirqs(&phb->msi_bmp, hwirq - phb->msi_base, 1);
 	}
 }
 #endif /* CONFIG_PCI_MSI */
diff --git a/arch/powerpc/platforms/pseries/eeh_pseries.c b/arch/powerpc/platforms/pseries/eeh_pseries.c
index 68f97d5..dc0278e 100644
--- a/arch/powerpc/platforms/pseries/eeh_pseries.c
+++ b/arch/powerpc/platforms/pseries/eeh_pseries.c
@@ -551,29 +551,50 @@ static int pseries_eeh_configure_bridge(struct eeh_pe *pe)
 {
 	int config_addr;
 	int ret;
+	/* Waiting 0.2s maximum before skipping configuration */
+	int max_wait = 200;
 
 	/* Figure out the PE address */
 	config_addr = pe->config_addr;
 	if (pe->addr)
 		config_addr = pe->addr;
 
-	/* Use new configure-pe function, if supported */
-	if (ibm_configure_pe != RTAS_UNKNOWN_SERVICE) {
-		ret = rtas_call(ibm_configure_pe, 3, 1, NULL,
-				config_addr, BUID_HI(pe->phb->buid),
-				BUID_LO(pe->phb->buid));
-	} else if (ibm_configure_bridge != RTAS_UNKNOWN_SERVICE) {
-		ret = rtas_call(ibm_configure_bridge, 3, 1, NULL,
-				config_addr, BUID_HI(pe->phb->buid),
-				BUID_LO(pe->phb->buid));
-	} else {
-		return -EFAULT;
-	}
+	while (max_wait > 0) {
+		/* Use new configure-pe function, if supported */
+		if (ibm_configure_pe != RTAS_UNKNOWN_SERVICE) {
+			ret = rtas_call(ibm_configure_pe, 3, 1, NULL,
+					config_addr, BUID_HI(pe->phb->buid),
+					BUID_LO(pe->phb->buid));
+		} else if (ibm_configure_bridge != RTAS_UNKNOWN_SERVICE) {
+			ret = rtas_call(ibm_configure_bridge, 3, 1, NULL,
+					config_addr, BUID_HI(pe->phb->buid),
+					BUID_LO(pe->phb->buid));
+		} else {
+			return -EFAULT;
+		}
 
-	if (ret)
-		pr_warning("%s: Unable to configure bridge PHB#%d-PE#%x (%d)\n",
-			__func__, pe->phb->global_number, pe->addr, ret);
+		if (!ret)
+			return ret;
+
+		/*
+		 * If RTAS returns a delay value that's above 100ms, cut it
+		 * down to 100ms in case firmware made a mistake.  For more
+		 * on how these delay values work see rtas_busy_delay_time
+		 */
+		if (ret > RTAS_EXTENDED_DELAY_MIN+2 &&
+		    ret <= RTAS_EXTENDED_DELAY_MAX)
+			ret = RTAS_EXTENDED_DELAY_MIN+2;
+
+		max_wait -= rtas_busy_delay_time(ret);
+
+		if (max_wait < 0)
+			break;
+
+		rtas_busy_delay(ret);
+	}
 
+	pr_warn("%s: Unable to configure bridge PHB#%d-PE#%x (%d)\n",
+		__func__, pe->phb->global_number, pe->addr, ret);
 	return ret;
 }
 
diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.c
index 86ae364..4013691 100644
--- a/arch/powerpc/platforms/pseries/iommu.c
+++ b/arch/powerpc/platforms/pseries/iommu.c
@@ -858,7 +858,8 @@ machine_arch_initcall(pseries, find_existing_ddw_windows);
 static int query_ddw(struct pci_dev *dev, const u32 *ddw_avail,
 			struct ddw_query_response *query)
 {
-	struct eeh_dev *edev;
+	struct device_node *dn;
+	struct pci_dn *pdn;
 	u32 cfg_addr;
 	u64 buid;
 	int ret;
@@ -869,11 +870,10 @@ static int query_ddw(struct pci_dev *dev, const u32 *ddw_avail,
 	 * Retrieve them from the pci device, not the node with the
 	 * dma-window property
 	 */
-	edev = pci_dev_to_eeh_dev(dev);
-	cfg_addr = edev->config_addr;
-	if (edev->pe_config_addr)
-		cfg_addr = edev->pe_config_addr;
-	buid = edev->phb->buid;
+	dn = pci_device_to_OF_node(dev);
+	pdn = PCI_DN(dn);
+	buid = pdn->phb->buid;
+	cfg_addr = ((pdn->busno << 16) | (pdn->devfn << 8));
 
 	ret = rtas_call(ddw_avail[0], 3, 5, (u32 *)query,
 		  cfg_addr, BUID_HI(buid), BUID_LO(buid));
@@ -887,7 +887,8 @@ static int create_ddw(struct pci_dev *dev, const u32 *ddw_avail,
 			struct ddw_create_response *create, int page_shift,
 			int window_shift)
 {
-	struct eeh_dev *edev;
+	struct device_node *dn;
+	struct pci_dn *pdn;
 	u32 cfg_addr;
 	u64 buid;
 	int ret;
@@ -898,11 +899,10 @@ static int create_ddw(struct pci_dev *dev, const u32 *ddw_avail,
 	 * Retrieve them from the pci device, not the node with the
 	 * dma-window property
 	 */
-	edev = pci_dev_to_eeh_dev(dev);
-	cfg_addr = edev->config_addr;
-	if (edev->pe_config_addr)
-		cfg_addr = edev->pe_config_addr;
-	buid = edev->phb->buid;
+	dn = pci_device_to_OF_node(dev);
+	pdn = PCI_DN(dn);
+	buid = pdn->phb->buid;
+	cfg_addr = ((pdn->busno << 16) | (pdn->devfn << 8));
 
 	do {
 		/* extra outputs are LIOBN and dma-addr (hi, lo) */
diff --git a/arch/powerpc/platforms/pseries/ras.c b/arch/powerpc/platforms/pseries/ras.c
index c4dfccd..2338e6e 100644
--- a/arch/powerpc/platforms/pseries/ras.c
+++ b/arch/powerpc/platforms/pseries/ras.c
@@ -187,7 +187,8 @@ static irqreturn_t ras_epow_interrupt(int irq, void *dev_id)
 	int state;
 	int critical;
 
-	status = rtas_get_sensor(EPOW_SENSOR_TOKEN, EPOW_SENSOR_INDEX, &state);
+	status = rtas_get_sensor_fast(EPOW_SENSOR_TOKEN, EPOW_SENSOR_INDEX,
+				      &state);
 
 	if (state > 3)
 		critical = 1;		/* Time Critical */
diff --git a/arch/powerpc/sysdev/fsl_msi.c b/arch/powerpc/sysdev/fsl_msi.c
index ab02db3..6616fa6 100644
--- a/arch/powerpc/sysdev/fsl_msi.c
+++ b/arch/powerpc/sysdev/fsl_msi.c
@@ -108,15 +108,16 @@ static void fsl_teardown_msi_irqs(struct pci_dev *pdev)
 {
 	struct msi_desc *entry;
 	struct fsl_msi *msi_data;
+	irq_hw_number_t hwirq;
 
 	list_for_each_entry(entry, &pdev->msi_list, list) {
 		if (entry->irq == NO_IRQ)
 			continue;
+		hwirq = virq_to_hw(entry->irq);
 		msi_data = irq_get_chip_data(entry->irq);
 		irq_set_msi_desc(entry->irq, NULL);
-		msi_bitmap_free_hwirqs(&msi_data->bitmap,
-				       virq_to_hw(entry->irq), 1);
 		irq_dispose_mapping(entry->irq);
+		msi_bitmap_free_hwirqs(&msi_data->bitmap, hwirq, 1);
 	}
 
 	return;
diff --git a/arch/powerpc/sysdev/mpic_pasemi_msi.c b/arch/powerpc/sysdev/mpic_pasemi_msi.c
index 38e6238..9e14d82 100644
--- a/arch/powerpc/sysdev/mpic_pasemi_msi.c
+++ b/arch/powerpc/sysdev/mpic_pasemi_msi.c
@@ -74,6 +74,7 @@ static int pasemi_msi_check_device(struct pci_dev *pdev, int nvec, int type)
 static void pasemi_msi_teardown_msi_irqs(struct pci_dev *pdev)
 {
 	struct msi_desc *entry;
+	irq_hw_number_t hwirq;
 
 	pr_debug("pasemi_msi_teardown_msi_irqs, pdev %p\n", pdev);
 
@@ -81,10 +82,11 @@ static void pasemi_msi_teardown_msi_irqs(struct pci_dev *pdev)
 		if (entry->irq == NO_IRQ)
 			continue;
 
+		hwirq = virq_to_hw(entry->irq);
 		irq_set_msi_desc(entry->irq, NULL);
-		msi_bitmap_free_hwirqs(&msi_mpic->msi_bitmap,
-				       virq_to_hw(entry->irq), ALLOC_CHUNK);
 		irq_dispose_mapping(entry->irq);
+		msi_bitmap_free_hwirqs(&msi_mpic->msi_bitmap,
+				       hwirq, ALLOC_CHUNK);
 	}
 
 	return;
diff --git a/arch/powerpc/sysdev/mpic_u3msi.c b/arch/powerpc/sysdev/mpic_u3msi.c
index 9a7aa0e..dfc3486 100644
--- a/arch/powerpc/sysdev/mpic_u3msi.c
+++ b/arch/powerpc/sysdev/mpic_u3msi.c
@@ -124,15 +124,16 @@ static int u3msi_msi_check_device(struct pci_dev *pdev, int nvec, int type)
 static void u3msi_teardown_msi_irqs(struct pci_dev *pdev)
 {
 	struct msi_desc *entry;
+	irq_hw_number_t hwirq;
 
         list_for_each_entry(entry, &pdev->msi_list, list) {
 		if (entry->irq == NO_IRQ)
 			continue;
 
+		hwirq = virq_to_hw(entry->irq);
 		irq_set_msi_desc(entry->irq, NULL);
-		msi_bitmap_free_hwirqs(&msi_mpic->msi_bitmap,
-				       virq_to_hw(entry->irq), 1);
 		irq_dispose_mapping(entry->irq);
+		msi_bitmap_free_hwirqs(&msi_mpic->msi_bitmap, hwirq, 1);
 	}
 
 	return;
diff --git a/arch/powerpc/sysdev/ppc4xx_msi.c b/arch/powerpc/sysdev/ppc4xx_msi.c
index 43948da..c3e6512 100644
--- a/arch/powerpc/sysdev/ppc4xx_msi.c
+++ b/arch/powerpc/sysdev/ppc4xx_msi.c
@@ -121,16 +121,17 @@ void ppc4xx_teardown_msi_irqs(struct pci_dev *dev)
 {
 	struct msi_desc *entry;
 	struct ppc4xx_msi *msi_data = &ppc4xx_msi;
+	irq_hw_number_t hwirq;
 
 	dev_dbg(&dev->dev, "PCIE-MSI: tearing down msi irqs\n");
 
 	list_for_each_entry(entry, &dev->msi_list, list) {
 		if (entry->irq == NO_IRQ)
 			continue;
+		hwirq = virq_to_hw(entry->irq);
 		irq_set_msi_desc(entry->irq, NULL);
-		msi_bitmap_free_hwirqs(&msi_data->bitmap,
-				virq_to_hw(entry->irq), 1);
 		irq_dispose_mapping(entry->irq);
+		msi_bitmap_free_hwirqs(&msi_data->bitmap, hwirq, 1);
 	}
 }
 
diff --git a/arch/s390/crypto/ghash_s390.c b/arch/s390/crypto/ghash_s390.c
index 7940dc9..b258110 100644
--- a/arch/s390/crypto/ghash_s390.c
+++ b/arch/s390/crypto/ghash_s390.c
@@ -16,11 +16,12 @@
 #define GHASH_DIGEST_SIZE	16
 
 struct ghash_ctx {
-	u8 icv[16];
-	u8 key[16];
+	u8 key[GHASH_BLOCK_SIZE];
 };
 
 struct ghash_desc_ctx {
+	u8 icv[GHASH_BLOCK_SIZE];
+	u8 key[GHASH_BLOCK_SIZE];
 	u8 buffer[GHASH_BLOCK_SIZE];
 	u32 bytes;
 };
@@ -28,8 +29,10 @@ struct ghash_desc_ctx {
 static int ghash_init(struct shash_desc *desc)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
+	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);
 
 	memset(dctx, 0, sizeof(*dctx));
+	memcpy(dctx->key, ctx->key, GHASH_BLOCK_SIZE);
 
 	return 0;
 }
@@ -45,7 +48,6 @@ static int ghash_setkey(struct crypto_shash *tfm,
 	}
 
 	memcpy(ctx->key, key, GHASH_BLOCK_SIZE);
-	memset(ctx->icv, 0, GHASH_BLOCK_SIZE);
 
 	return 0;
 }
@@ -54,7 +56,6 @@ static int ghash_update(struct shash_desc *desc,
 			 const u8 *src, unsigned int srclen)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
-	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);
 	unsigned int n;
 	u8 *buf = dctx->buffer;
 	int ret;
@@ -70,7 +71,7 @@ static int ghash_update(struct shash_desc *desc,
 		src += n;
 
 		if (!dctx->bytes) {
-			ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf,
+			ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf,
 					      GHASH_BLOCK_SIZE);
 			if (ret != GHASH_BLOCK_SIZE)
 				return -EIO;
@@ -79,7 +80,7 @@ static int ghash_update(struct shash_desc *desc,
 
 	n = srclen & ~(GHASH_BLOCK_SIZE - 1);
 	if (n) {
-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, src, n);
+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, src, n);
 		if (ret != n)
 			return -EIO;
 		src += n;
@@ -94,7 +95,7 @@ static int ghash_update(struct shash_desc *desc,
 	return 0;
 }
 
-static int ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)
+static int ghash_flush(struct ghash_desc_ctx *dctx)
 {
 	u8 *buf = dctx->buffer;
 	int ret;
@@ -104,24 +105,24 @@ static int ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)
 
 		memset(pos, 0, dctx->bytes);
 
-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf, GHASH_BLOCK_SIZE);
+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf, GHASH_BLOCK_SIZE);
 		if (ret != GHASH_BLOCK_SIZE)
 			return -EIO;
+
+		dctx->bytes = 0;
 	}
 
-	dctx->bytes = 0;
 	return 0;
 }
 
 static int ghash_final(struct shash_desc *desc, u8 *dst)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
-	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);
 	int ret;
 
-	ret = ghash_flush(ctx, dctx);
+	ret = ghash_flush(dctx);
 	if (!ret)
-		memcpy(dst, ctx->icv, GHASH_BLOCK_SIZE);
+		memcpy(dst, dctx->icv, GHASH_BLOCK_SIZE);
 	return ret;
 }
 
diff --git a/arch/s390/include/asm/syscall.h b/arch/s390/include/asm/syscall.h
index cd29d2f..749313b 100644
--- a/arch/s390/include/asm/syscall.h
+++ b/arch/s390/include/asm/syscall.h
@@ -54,7 +54,7 @@ static inline void syscall_set_return_value(struct task_struct *task,
 					    struct pt_regs *regs,
 					    int error, long val)
 {
-	regs->gprs[2] = error ? -error : val;
+	regs->gprs[2] = error ? error : val;
 }
 
 static inline void syscall_get_arguments(struct task_struct *task,
diff --git a/arch/s390/kernel/sclp.S b/arch/s390/kernel/sclp.S
index 29bd7be..1ecd47b 100644
--- a/arch/s390/kernel/sclp.S
+++ b/arch/s390/kernel/sclp.S
@@ -276,6 +276,8 @@ ENTRY(_sclp_print_early)
 	jno	.Lesa2
 	ahi	%r15,-80
 	stmh	%r6,%r15,96(%r15)		# store upper register halves
+	basr	%r13,0
+	lmh	%r0,%r15,.Lzeroes-.(%r13)	# clear upper register halves
 .Lesa2:
 #endif
 	lr	%r10,%r2			# save string pointer
@@ -299,6 +301,8 @@ ENTRY(_sclp_print_early)
 #endif
 	lm	%r6,%r15,120(%r15)		# restore registers
 	br	%r14
+.Lzeroes:
+	.fill	64,4,0
 
 .LwritedataS4:
 	.long	0x00760005			# SCLP command for write data
diff --git a/arch/s390/kernel/suspend.c b/arch/s390/kernel/suspend.c
index c479d2f..58cbb75 100644
--- a/arch/s390/kernel/suspend.c
+++ b/arch/s390/kernel/suspend.c
@@ -9,12 +9,9 @@
 #include <linux/pfn.h>
 #include <linux/suspend.h>
 #include <linux/mm.h>
+#include <asm/sections.h>
 #include <asm/ctl_reg.h>
-
-/*
- * References to section boundaries
- */
-extern const void __nosave_begin, __nosave_end;
+#include <asm/ipl.h>
 
 /*
  * The restore of the saved pages in an hibernation image will set
@@ -138,6 +135,8 @@ int pfn_is_nosave(unsigned long pfn)
 {
 	unsigned long nosave_begin_pfn = PFN_DOWN(__pa(&__nosave_begin));
 	unsigned long nosave_end_pfn = PFN_DOWN(__pa(&__nosave_end));
+	unsigned long eshared_pfn = PFN_DOWN(__pa(&_eshared)) - 1;
+	unsigned long stext_pfn = PFN_DOWN(__pa(&_stext));
 
 	/* Always save lowcore pages (LC protection might be enabled). */
 	if (pfn <= LC_PAGES)
@@ -145,6 +144,8 @@ int pfn_is_nosave(unsigned long pfn)
 	if (pfn >= nosave_begin_pfn && pfn < nosave_end_pfn)
 		return 1;
 	/* Skip memory holes and read-only pages (NSS, DCSS, ...). */
+	if (pfn >= stext_pfn && pfn <= eshared_pfn)
+		return ipl_info.type == IPL_TYPE_NSS ? 1 : 0;
 	if (tprot(PFN_PHYS(pfn)))
 		return 1;
 	return 0;
diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c
index 6bbd7b5..0220c2b 100644
--- a/arch/s390/kvm/priv.c
+++ b/arch/s390/kvm/priv.c
@@ -328,6 +328,7 @@ static void handle_stsi_3_2_2(struct kvm_vcpu *vcpu, struct sysinfo_3_2_2 *mem)
 	for (n = mem->count - 1; n > 0 ; n--)
 		memcpy(&mem->vm[n], &mem->vm[n - 1], sizeof(mem->vm[0]));
 
+	memset(&mem->vm[0], 0, sizeof(mem->vm[0]));
 	mem->vm[0].cpus_total = cpus;
 	mem->vm[0].cpus_configured = cpus;
 	mem->vm[0].cpus_standby = 0;
diff --git a/arch/s390/mm/extable.c b/arch/s390/mm/extable.c
index 4d1ee88..18c8b81 100644
--- a/arch/s390/mm/extable.c
+++ b/arch/s390/mm/extable.c
@@ -52,12 +52,16 @@ void sort_extable(struct exception_table_entry *start,
 	int i;
 
 	/* Normalize entries to being relative to the start of the section */
-	for (p = start, i = 0; p < finish; p++, i += 8)
+	for (p = start, i = 0; p < finish; p++, i += 8) {
 		p->insn += i;
+		p->fixup += i + 4;
+	}
 	sort(start, finish - start, sizeof(*start), cmp_ex, NULL);
 	/* Denormalize all entries */
-	for (p = start, i = 0; p < finish; p++, i += 8)
+	for (p = start, i = 0; p < finish; p++, i += 8) {
 		p->insn -= i;
+		p->fixup -= i + 4;
+	}
 }
 
 #ifdef CONFIG_MODULES
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index 416face..d214321 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -244,6 +244,12 @@ static noinline void do_fault_error(struct pt_regs *regs, int fault)
 				do_no_context(regs);
 			else
 				pagefault_out_of_memory();
+		} else if (fault & VM_FAULT_SIGSEGV) {
+			/* Kernel mode? Handle exceptions or die */
+			if (!user_mode(regs))
+				do_no_context(regs);
+			else
+				do_sigsegv(regs, SEGV_MAPERR);
 		} else if (fault & VM_FAULT_SIGBUS) {
 			/* Kernel mode? Handle exceptions or die */
 			if (!user_mode(regs))
diff --git a/arch/score/mm/fault.c b/arch/score/mm/fault.c
index 52238983..6860beb 100644
--- a/arch/score/mm/fault.c
+++ b/arch/score/mm/fault.c
@@ -114,6 +114,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/sh/include/asm/ftrace.h b/arch/sh/include/asm/ftrace.h
index 13e9966..e79fb6e 100644
--- a/arch/sh/include/asm/ftrace.h
+++ b/arch/sh/include/asm/ftrace.h
@@ -40,15 +40,7 @@ static inline unsigned long ftrace_call_adjust(unsigned long addr)
 /* arch/sh/kernel/return_address.c */
 extern void *return_address(unsigned int);
 
-#define HAVE_ARCH_CALLER_ADDR
-
-#define CALLER_ADDR0 ((unsigned long)__builtin_return_address(0))
-#define CALLER_ADDR1 ((unsigned long)return_address(1))
-#define CALLER_ADDR2 ((unsigned long)return_address(2))
-#define CALLER_ADDR3 ((unsigned long)return_address(3))
-#define CALLER_ADDR4 ((unsigned long)return_address(4))
-#define CALLER_ADDR5 ((unsigned long)return_address(5))
-#define CALLER_ADDR6 ((unsigned long)return_address(6))
+#define ftrace_return_address(n) return_address(n)
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/arch/sh/include/asm/sections.h b/arch/sh/include/asm/sections.h
index 1b61997..7a99e6a 100644
--- a/arch/sh/include/asm/sections.h
+++ b/arch/sh/include/asm/sections.h
@@ -3,7 +3,6 @@
 
 #include <asm-generic/sections.h>
 
-extern long __nosave_begin, __nosave_end;
 extern long __machvec_start, __machvec_end;
 extern char __uncached_start, __uncached_end;
 extern char __start_eh_frame[], __stop_eh_frame[];
diff --git a/arch/sh/include/uapi/asm/unistd_64.h b/arch/sh/include/uapi/asm/unistd_64.h
index e6820c8..47ebd5b 100644
--- a/arch/sh/include/uapi/asm/unistd_64.h
+++ b/arch/sh/include/uapi/asm/unistd_64.h
@@ -278,7 +278,7 @@
 #define __NR_fsetxattr		256
 #define __NR_getxattr		257
 #define __NR_lgetxattr		258
-#define __NR_fgetxattr		269
+#define __NR_fgetxattr		259
 #define __NR_listxattr		260
 #define __NR_llistxattr		261
 #define __NR_flistxattr		262
diff --git a/arch/sh/mm/fault.c b/arch/sh/mm/fault.c
index 541dc61..a58fec9 100644
--- a/arch/sh/mm/fault.c
+++ b/arch/sh/mm/fault.c
@@ -353,6 +353,8 @@ mm_fault_error(struct pt_regs *regs, unsigned long error_code,
 	} else {
 		if (fault & VM_FAULT_SIGBUS)
 			do_sigbus(regs, error_code, address);
+		else if (fault & VM_FAULT_SIGSEGV)
+			bad_area(regs, error_code, address);
 		else
 			BUG();
 	}
diff --git a/arch/sparc/crypto/aes_glue.c b/arch/sparc/crypto/aes_glue.c
index ded4cee3..dc78cdd 100644
--- a/arch/sparc/crypto/aes_glue.c
+++ b/arch/sparc/crypto/aes_glue.c
@@ -433,6 +433,7 @@ static struct crypto_alg algs[] = { {
 		.blkcipher = {
 			.min_keysize	= AES_MIN_KEY_SIZE,
 			.max_keysize	= AES_MAX_KEY_SIZE,
+			.ivsize		= AES_BLOCK_SIZE,
 			.setkey		= aes_set_key,
 			.encrypt	= cbc_encrypt,
 			.decrypt	= cbc_decrypt,
@@ -452,6 +453,7 @@ static struct crypto_alg algs[] = { {
 		.blkcipher = {
 			.min_keysize	= AES_MIN_KEY_SIZE,
 			.max_keysize	= AES_MAX_KEY_SIZE,
+			.ivsize		= AES_BLOCK_SIZE,
 			.setkey		= aes_set_key,
 			.encrypt	= ctr_crypt,
 			.decrypt	= ctr_crypt,
diff --git a/arch/sparc/crypto/camellia_glue.c b/arch/sparc/crypto/camellia_glue.c
index 641f55c..eb87d6d 100644
--- a/arch/sparc/crypto/camellia_glue.c
+++ b/arch/sparc/crypto/camellia_glue.c
@@ -274,6 +274,7 @@ static struct crypto_alg algs[] = { {
 		.blkcipher = {
 			.min_keysize	= CAMELLIA_MIN_KEY_SIZE,
 			.max_keysize	= CAMELLIA_MAX_KEY_SIZE,
+			.ivsize		= CAMELLIA_BLOCK_SIZE,
 			.setkey		= camellia_set_key,
 			.encrypt	= cbc_encrypt,
 			.decrypt	= cbc_decrypt,
diff --git a/arch/sparc/crypto/des_glue.c b/arch/sparc/crypto/des_glue.c
index d115009..1359bfc 100644
--- a/arch/sparc/crypto/des_glue.c
+++ b/arch/sparc/crypto/des_glue.c
@@ -429,6 +429,7 @@ static struct crypto_alg algs[] = { {
 		.blkcipher = {
 			.min_keysize	= DES_KEY_SIZE,
 			.max_keysize	= DES_KEY_SIZE,
+			.ivsize		= DES_BLOCK_SIZE,
 			.setkey		= des_set_key,
 			.encrypt	= cbc_encrypt,
 			.decrypt	= cbc_decrypt,
@@ -485,6 +486,7 @@ static struct crypto_alg algs[] = { {
 		.blkcipher = {
 			.min_keysize	= DES3_EDE_KEY_SIZE,
 			.max_keysize	= DES3_EDE_KEY_SIZE,
+			.ivsize		= DES3_EDE_BLOCK_SIZE,
 			.setkey		= des3_ede_set_key,
 			.encrypt	= cbc3_encrypt,
 			.decrypt	= cbc3_decrypt,
diff --git a/arch/sparc/include/asm/visasm.h b/arch/sparc/include/asm/visasm.h
index 39ca301..50d6f16 100644
--- a/arch/sparc/include/asm/visasm.h
+++ b/arch/sparc/include/asm/visasm.h
@@ -28,18 +28,20 @@
  * Must preserve %o5 between VISEntryHalf and VISExitHalf */
 
 #define VISEntryHalf					\
+	VISEntry
+
+#define VISExitHalf					\
+	VISExit
+
+#define VISEntryHalfFast(fail_label)			\
 	rd		%fprs, %o5;			\
 	andcc		%o5, FPRS_FEF, %g0;		\
 	be,pt		%icc, 297f;			\
-	 sethi		%hi(298f), %g7;			\
-	sethi		%hi(VISenterhalf), %g1;		\
-	jmpl		%g1 + %lo(VISenterhalf), %g0;	\
-	 or		%g7, %lo(298f), %g7;		\
-	clr		%o5;				\
-297:	wr		%o5, FPRS_FEF, %fprs;		\
-298:
+	 nop;						\
+	ba,a,pt		%xcc, fail_label;		\
+297:	wr		%o5, FPRS_FEF, %fprs;
 
-#define VISExitHalf					\
+#define VISExitHalfFast					\
 	wr		%o5, 0, %fprs;
 
 #ifndef __ASSEMBLY__
diff --git a/arch/sparc/kernel/ldc.c b/arch/sparc/kernel/ldc.c
index fa4c900..62983d7 100644
--- a/arch/sparc/kernel/ldc.c
+++ b/arch/sparc/kernel/ldc.c
@@ -2306,7 +2306,7 @@ void *ldc_alloc_exp_dring(struct ldc_channel *lp, unsigned int len,
 	if (len & (8UL - 1))
 		return ERR_PTR(-EINVAL);
 
-	buf = kzalloc(len, GFP_KERNEL);
+	buf = kzalloc(len, GFP_ATOMIC);
 	if (!buf)
 		return ERR_PTR(-ENOMEM);
 
diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c
index be8db9b..666510b 100644
--- a/arch/sparc/kernel/sys_sparc_64.c
+++ b/arch/sparc/kernel/sys_sparc_64.c
@@ -416,7 +416,7 @@ out:
 
 SYSCALL_DEFINE1(sparc64_personality, unsigned long, personality)
 {
-	int ret;
+	long ret;
 
 	if (personality(current->personality) == PER_LINUX32 &&
 	    personality(personality) == PER_LINUX)
diff --git a/arch/sparc/lib/NG4memcpy.S b/arch/sparc/lib/NG4memcpy.S
index 9cf2ee0..83aeeb1 100644
--- a/arch/sparc/lib/NG4memcpy.S
+++ b/arch/sparc/lib/NG4memcpy.S
@@ -41,6 +41,10 @@
 #endif
 #endif
 
+#if !defined(EX_LD) && !defined(EX_ST)
+#define NON_USER_COPY
+#endif
+
 #ifndef EX_LD
 #define EX_LD(x)	x
 #endif
@@ -197,9 +201,13 @@ FUNC_NAME:	/* %o0=dst, %o1=src, %o2=len */
 	 mov		EX_RETVAL(%o3), %o0
 
 .Llarge_src_unaligned:
+#ifdef NON_USER_COPY
+	VISEntryHalfFast(.Lmedium_vis_entry_fail)
+#else
+	VISEntryHalf
+#endif
 	andn		%o2, 0x3f, %o4
 	sub		%o2, %o4, %o2
-	VISEntryHalf
 	alignaddr	%o1, %g0, %g1
 	add		%o1, %o4, %o1
 	EX_LD(LOAD(ldd, %g1 + 0x00, %f0))
@@ -232,14 +240,21 @@ FUNC_NAME:	/* %o0=dst, %o1=src, %o2=len */
 	add		%o0, 0x40, %o0
 	bne,pt		%icc, 1b
 	 LOAD(prefetch, %g1 + 0x200, #n_reads_strong)
+#ifdef NON_USER_COPY
+	VISExitHalfFast
+#else
 	VISExitHalf
-
+#endif
 	brz,pn		%o2, .Lexit
 	 cmp		%o2, 19
 	ble,pn		%icc, .Lsmall_unaligned
 	 nop
 	ba,a,pt		%icc, .Lmedium_unaligned
 
+#ifdef NON_USER_COPY
+.Lmedium_vis_entry_fail:
+	 or		%o0, %o1, %g2
+#endif
 .Lmedium:
 	LOAD(prefetch, %o1 + 0x40, #n_reads_strong)
 	andcc		%g2, 0x7, %g0
diff --git a/arch/sparc/lib/VISsave.S b/arch/sparc/lib/VISsave.S
index b320ae9..a063d84 100644
--- a/arch/sparc/lib/VISsave.S
+++ b/arch/sparc/lib/VISsave.S
@@ -44,9 +44,8 @@ vis1:	ldub		[%g6 + TI_FPSAVED], %g3
 
 	 stx		%g3, [%g6 + TI_GSR]
 2:	add		%g6, %g1, %g3
-	cmp		%o5, FPRS_DU
-	be,pn		%icc, 6f
-	 sll		%g1, 3, %g1
+	mov		FPRS_DU | FPRS_DL | FPRS_FEF, %o5
+	sll		%g1, 3, %g1
 	stb		%o5, [%g3 + TI_FPSAVED]
 	rd		%gsr, %g2
 	add		%g6, %g1, %g3
@@ -80,65 +79,3 @@ vis1:	ldub		[%g6 + TI_FPSAVED], %g3
 	.align		32
 80:	jmpl		%g7 + %g0, %g0
 	 nop
-
-6:	ldub		[%g3 + TI_FPSAVED], %o5
-	or		%o5, FPRS_DU, %o5
-	add		%g6, TI_FPREGS+0x80, %g2
-	stb		%o5, [%g3 + TI_FPSAVED]
-
-	sll		%g1, 5, %g1
-	add		%g6, TI_FPREGS+0xc0, %g3
-	wr		%g0, FPRS_FEF, %fprs
-	membar		#Sync
-	stda		%f32, [%g2 + %g1] ASI_BLK_P
-	stda		%f48, [%g3 + %g1] ASI_BLK_P
-	membar		#Sync
-	ba,pt		%xcc, 80f
-	 nop
-
-	.align		32
-80:	jmpl		%g7 + %g0, %g0
-	 nop
-
-	.align		32
-VISenterhalf:
-	ldub		[%g6 + TI_FPDEPTH], %g1
-	brnz,a,pn	%g1, 1f
-	 cmp		%g1, 1
-	stb		%g0, [%g6 + TI_FPSAVED]
-	stx		%fsr, [%g6 + TI_XFSR]
-	clr		%o5
-	jmpl		%g7 + %g0, %g0
-	 wr		%g0, FPRS_FEF, %fprs
-
-1:	bne,pn		%icc, 2f
-	 srl		%g1, 1, %g1
-	ba,pt		%xcc, vis1
-	 sub		%g7, 8, %g7
-2:	addcc		%g6, %g1, %g3
-	sll		%g1, 3, %g1
-	andn		%o5, FPRS_DU, %g2
-	stb		%g2, [%g3 + TI_FPSAVED]
-
-	rd		%gsr, %g2
-	add		%g6, %g1, %g3
-	stx		%g2, [%g3 + TI_GSR]
-	add		%g6, %g1, %g2
-	stx		%fsr, [%g2 + TI_XFSR]
-	sll		%g1, 5, %g1
-3:	andcc		%o5, FPRS_DL, %g0
-	be,pn		%icc, 4f
-	 add		%g6, TI_FPREGS, %g2
-
-	add		%g6, TI_FPREGS+0x40, %g3
-	membar		#Sync
-	stda		%f0, [%g2 + %g1] ASI_BLK_P
-	stda		%f16, [%g3 + %g1] ASI_BLK_P
-	membar		#Sync
-	ba,pt		%xcc, 4f
-	 nop
-
-	.align		32
-4:	and		%o5, FPRS_DU, %o5
-	jmpl		%g7 + %g0, %g0
-	 wr		%o5, FPRS_FEF, %fprs
diff --git a/arch/sparc/lib/ksyms.c b/arch/sparc/lib/ksyms.c
index 323335b..ac094de 100644
--- a/arch/sparc/lib/ksyms.c
+++ b/arch/sparc/lib/ksyms.c
@@ -126,10 +126,6 @@ EXPORT_SYMBOL(copy_user_page);
 void VISenter(void);
 EXPORT_SYMBOL(VISenter);
 
-/* CRYPTO code needs this */
-void VISenterhalf(void);
-EXPORT_SYMBOL(VISenterhalf);
-
 extern void xor_vis_2(unsigned long, unsigned long *, unsigned long *);
 extern void xor_vis_3(unsigned long, unsigned long *, unsigned long *,
 		unsigned long *);
diff --git a/arch/sparc/mm/fault_32.c b/arch/sparc/mm/fault_32.c
index 59dbd46..163c787 100644
--- a/arch/sparc/mm/fault_32.c
+++ b/arch/sparc/mm/fault_32.c
@@ -252,6 +252,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/sparc/mm/fault_64.c b/arch/sparc/mm/fault_64.c
index 3841a08..ac2db92 100644
--- a/arch/sparc/mm/fault_64.c
+++ b/arch/sparc/mm/fault_64.c
@@ -443,6 +443,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/sparc/power/hibernate.c b/arch/sparc/power/hibernate.c
index 42b0b8c..17bd2e1 100644
--- a/arch/sparc/power/hibernate.c
+++ b/arch/sparc/power/hibernate.c
@@ -9,11 +9,9 @@
 #include <asm/hibernate.h>
 #include <asm/visasm.h>
 #include <asm/page.h>
+#include <asm/sections.h>
 #include <asm/tlb.h>
 
-/* References to section boundaries */
-extern const void __nosave_begin, __nosave_end;
-
 struct saved_context saved_context;
 
 /*
diff --git a/arch/tile/kernel/setup.c b/arch/tile/kernel/setup.c
index 7a5aa1a..5ebe936 100644
--- a/arch/tile/kernel/setup.c
+++ b/arch/tile/kernel/setup.c
@@ -1064,7 +1064,7 @@ static void __init load_hv_initrd(void)
 
 void __init free_initrd_mem(unsigned long begin, unsigned long end)
 {
-	free_bootmem(__pa(begin), end - begin);
+	free_bootmem_late(__pa(begin), end - begin);
 }
 
 #else
diff --git a/arch/tile/mm/fault.c b/arch/tile/mm/fault.c
index 3ff289f..12b732f 100644
--- a/arch/tile/mm/fault.c
+++ b/arch/tile/mm/fault.c
@@ -446,6 +446,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/um/kernel/trap.c b/arch/um/kernel/trap.c
index 5c3aef7..06ab0eb 100644
--- a/arch/um/kernel/trap.c
+++ b/arch/um/kernel/trap.c
@@ -80,6 +80,8 @@ good_area:
 		if (unlikely(fault & VM_FAULT_ERROR)) {
 			if (fault & VM_FAULT_OOM) {
 				goto out_of_memory;
+			} else if (fault & VM_FAULT_SIGSEGV) {
+				goto out;
 			} else if (fault & VM_FAULT_SIGBUS) {
 				err = -EACCES;
 				goto out;
diff --git a/arch/um/os-Linux/start_up.c b/arch/um/os-Linux/start_up.c
index 337518c..b412c62 100644
--- a/arch/um/os-Linux/start_up.c
+++ b/arch/um/os-Linux/start_up.c
@@ -95,6 +95,8 @@ static int start_ptraced_child(void)
 {
 	int pid, n, status;
 
+	fflush(stdout);
+
 	pid = fork();
 	if (pid == 0)
 		ptrace_child();
diff --git a/arch/unicore32/include/mach/pm.h b/arch/unicore32/include/mach/pm.h
index 4dcd34a..77b5226 100644
--- a/arch/unicore32/include/mach/pm.h
+++ b/arch/unicore32/include/mach/pm.h
@@ -36,8 +36,5 @@ extern int puv3_pm_enter(suspend_state_t state);
 /* Defined in hibernate_asm.S */
 extern int restore_image(pgd_t *resume_pg_dir, struct pbe *restore_pblist);
 
-/* References to section boundaries */
-extern const void __nosave_begin, __nosave_end;
-
 extern struct pbe *restore_pblist;
 #endif
diff --git a/arch/unicore32/kernel/hibernate.c b/arch/unicore32/kernel/hibernate.c
index d75ef8b..9969ec3 100644
--- a/arch/unicore32/kernel/hibernate.c
+++ b/arch/unicore32/kernel/hibernate.c
@@ -18,6 +18,7 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
+#include <asm/sections.h>
 #include <asm/suspend.h>
 
 #include "mach/pm.h"
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 4e5b80d..105ae30 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -154,7 +154,7 @@ config SBUS
 
 config NEED_DMA_MAP_STATE
 	def_bool y
-	depends on X86_64 || INTEL_IOMMU || DMA_API_DEBUG
+	depends on X86_64 || INTEL_IOMMU || DMA_API_DEBUG || SWIOTLB
 
 config NEED_SG_DMA_LENGTH
 	def_bool y
diff --git a/arch/x86/boot/Makefile b/arch/x86/boot/Makefile
index 6cf0111..368f358 100644
--- a/arch/x86/boot/Makefile
+++ b/arch/x86/boot/Makefile
@@ -168,6 +168,9 @@ isoimage: $(obj)/bzImage
 	for i in lib lib64 share end ; do \
 		if [ -f /usr/$$i/syslinux/isolinux.bin ] ; then \
 			cp /usr/$$i/syslinux/isolinux.bin $(obj)/isoimage ; \
+			if [ -f /usr/$$i/syslinux/ldlinux.c32 ]; then \
+				cp /usr/$$i/syslinux/ldlinux.c32 $(obj)/isoimage ; \
+			fi ; \
 			break ; \
 		fi ; \
 		if [ $$i = end ] ; then exit 1 ; fi ; \
diff --git a/arch/x86/boot/compressed/head_32.S b/arch/x86/boot/compressed/head_32.S
index abb988a..3b28eff 100644
--- a/arch/x86/boot/compressed/head_32.S
+++ b/arch/x86/boot/compressed/head_32.S
@@ -54,7 +54,7 @@ ENTRY(efi_pe_entry)
 	call	reloc
 reloc:
 	popl	%ecx
-	subl	reloc, %ecx
+	subl	$reloc, %ecx
 	movl	%ecx, BP_code32_start(%eax)
 
 	sub	$0x4, %esp
diff --git a/arch/x86/crypto/ghash-clmulni-intel_glue.c b/arch/x86/crypto/ghash-clmulni-intel_glue.c
index a8d6f69..4bcf841 100644
--- a/arch/x86/crypto/ghash-clmulni-intel_glue.c
+++ b/arch/x86/crypto/ghash-clmulni-intel_glue.c
@@ -291,6 +291,7 @@ static struct ahash_alg ghash_async_alg = {
 			.cra_name		= "ghash",
 			.cra_driver_name	= "ghash-clmulni",
 			.cra_priority		= 400,
+			.cra_ctxsize		= sizeof(struct ghash_async_ctx),
 			.cra_flags		= CRYPTO_ALG_TYPE_AHASH | CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= GHASH_BLOCK_SIZE,
 			.cra_type		= &crypto_ahash_type,
diff --git a/arch/x86/ia32/ia32entry.S b/arch/x86/ia32/ia32entry.S
index c9305ef..e73982b 100644
--- a/arch/x86/ia32/ia32entry.S
+++ b/arch/x86/ia32/ia32entry.S
@@ -422,6 +422,7 @@ ENTRY(ia32_syscall)
 	/*CFI_REL_OFFSET	cs,CS-RIP*/
 	CFI_REL_OFFSET	rip,RIP-RIP
 	PARAVIRT_ADJUST_EXCEPTION_FRAME
+	ASM_CLAC			/* Do this early to minimize exposure */
 	SWAPGS
 	/*
 	 * No need to follow this irqs on/off section: the syscall
diff --git a/arch/x86/include/asm/boot.h b/arch/x86/include/asm/boot.h
index 4fa687a..6b8d6e8 100644
--- a/arch/x86/include/asm/boot.h
+++ b/arch/x86/include/asm/boot.h
@@ -27,7 +27,7 @@
 #define BOOT_HEAP_SIZE             0x400000
 #else /* !CONFIG_KERNEL_BZIP2 */
 
-#define BOOT_HEAP_SIZE	0x8000
+#define BOOT_HEAP_SIZE	0x10000
 
 #endif /* !CONFIG_KERNEL_BZIP2 */
 
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 4c481e7..b76c1bf 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -59,7 +59,7 @@
 	(~(unsigned long)(X86_CR4_VME | X86_CR4_PVI | X86_CR4_TSD | X86_CR4_DE\
 			  | X86_CR4_PSE | X86_CR4_PAE | X86_CR4_MCE     \
 			  | X86_CR4_PGE | X86_CR4_PCE | X86_CR4_OSFXSR | X86_CR4_PCIDE \
-			  | X86_CR4_OSXSAVE | X86_CR4_SMEP | X86_CR4_RDWRGSFS \
+			  | X86_CR4_OSXSAVE | X86_CR4_SMEP | X86_CR4_FSGSBASE \
 			  | X86_CR4_OSXMMEXCPT | X86_CR4_VMXE))
 
 #define CR8_RESERVED_BITS (~(unsigned long)X86_CR8_TPR)
@@ -541,7 +541,7 @@ struct kvm_arch {
 	struct kvm_pic *vpic;
 	struct kvm_ioapic *vioapic;
 	struct kvm_pit *vpit;
-	int vapics_in_nmi_mode;
+	atomic_t vapics_in_nmi_mode;
 	struct mutex apic_map_lock;
 	struct kvm_apic_map *apic_map;
 
diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h
index be12c53..29a3d1b 100644
--- a/arch/x86/include/asm/mmu_context.h
+++ b/arch/x86/include/asm/mmu_context.h
@@ -42,7 +42,34 @@ static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 #endif
 		cpumask_set_cpu(cpu, mm_cpumask(next));
 
-		/* Re-load page tables */
+		/*
+		 * Re-load page tables.
+		 *
+		 * This logic has an ordering constraint:
+		 *
+		 *  CPU 0: Write to a PTE for 'next'
+		 *  CPU 0: load bit 1 in mm_cpumask.  if nonzero, send IPI.
+		 *  CPU 1: set bit 1 in next's mm_cpumask
+		 *  CPU 1: load from the PTE that CPU 0 writes (implicit)
+		 *
+		 * We need to prevent an outcome in which CPU 1 observes
+		 * the new PTE value and CPU 0 observes bit 1 clear in
+		 * mm_cpumask.  (If that occurs, then the IPI will never
+		 * be sent, and CPU 0's TLB will contain a stale entry.)
+		 *
+		 * The bad outcome can occur if either CPU's load is
+		 * reordered before that CPU's store, so both CPUs must
+		 * execute full barriers to prevent this from happening.
+		 *
+		 * Thus, switch_mm needs a full barrier between the
+		 * store to mm_cpumask and any operation that could load
+		 * from next->pgd.  TLB fills are special and can happen
+		 * due to instruction fetches or for no reason at all,
+		 * and neither LOCK nor MFENCE orders them.
+		 * Fortunately, load_cr3() is serializing and gives the
+		 * ordering guarantee we need.
+		 *
+		 */
 		load_cr3(next->pgd);
 
 		/* Stop flush ipis for the previous mm */
@@ -65,10 +92,14 @@ static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 			 * schedule, protecting us from simultaneous changes.
 			 */
 			cpumask_set_cpu(cpu, mm_cpumask(next));
+
 			/*
 			 * We were in lazy tlb mode and leave_mm disabled
 			 * tlb flush IPI delivery. We must reload CR3
 			 * to make sure to use no freed page tables.
+			 *
+			 * As above, load_cr3() is serializing and orders TLB
+			 * fills with respect to the mm_cpumask write.
 			 */
 			load_cr3(next->pgd);
 			load_LDT_nolock(&next->context);
diff --git a/arch/x86/include/asm/segment.h b/arch/x86/include/asm/segment.h
index c48a950..4dde707 100644
--- a/arch/x86/include/asm/segment.h
+++ b/arch/x86/include/asm/segment.h
@@ -212,8 +212,19 @@
 #define TLS_SIZE (GDT_ENTRY_TLS_ENTRIES * 8)
 
 #ifdef __KERNEL__
+
+/*
+ * early_idt_handler_array is an array of entry points referenced in the
+ * early IDT.  For simplicity, it's a real array with one entry point
+ * every nine bytes.  That leaves room for an optional 'push $0' if the
+ * vector has no error code (two bytes), a 'push $vector_number' (two
+ * bytes), and a jump to the common entry code (up to five bytes).
+ */
+#define EARLY_IDT_HANDLER_SIZE 9
+
 #ifndef __ASSEMBLY__
-extern const char early_idt_handlers[NUM_EXCEPTION_VECTORS][2+2+5];
+
+extern const char early_idt_handler_array[NUM_EXCEPTION_VECTORS][EARLY_IDT_HANDLER_SIZE];
 
 /*
  * Load a segment. Fall back on loading the zero
diff --git a/arch/x86/include/asm/uaccess_64.h b/arch/x86/include/asm/uaccess_64.h
index 142810c..34df5c2 100644
--- a/arch/x86/include/asm/uaccess_64.h
+++ b/arch/x86/include/asm/uaccess_64.h
@@ -77,11 +77,10 @@ int copy_to_user(void __user *dst, const void *src, unsigned size)
 }
 
 static __always_inline __must_check
-int __copy_from_user(void *dst, const void __user *src, unsigned size)
+int __copy_from_user_nocheck(void *dst, const void __user *src, unsigned size)
 {
 	int ret = 0;
 
-	might_fault();
 	if (!__builtin_constant_p(size))
 		return copy_user_generic(dst, (__force void *)src, size);
 	switch (size) {
@@ -121,11 +120,17 @@ int __copy_from_user(void *dst, const void __user *src, unsigned size)
 }
 
 static __always_inline __must_check
-int __copy_to_user(void __user *dst, const void *src, unsigned size)
+int __copy_from_user(void *dst, const void __user *src, unsigned size)
+{
+	might_fault();
+	return __copy_from_user_nocheck(dst, src, size);
+}
+
+static __always_inline __must_check
+int __copy_to_user_nocheck(void __user *dst, const void *src, unsigned size)
 {
 	int ret = 0;
 
-	might_fault();
 	if (!__builtin_constant_p(size))
 		return copy_user_generic((__force void *)dst, src, size);
 	switch (size) {
@@ -165,6 +170,13 @@ int __copy_to_user(void __user *dst, const void *src, unsigned size)
 }
 
 static __always_inline __must_check
+int __copy_to_user(void __user *dst, const void *src, unsigned size)
+{
+	might_fault();
+	return __copy_to_user_nocheck(dst, src, size);
+}
+
+static __always_inline __must_check
 int __copy_in_user(void __user *dst, const void __user *src, unsigned size)
 {
 	int ret = 0;
@@ -220,13 +232,13 @@ int __copy_in_user(void __user *dst, const void __user *src, unsigned size)
 static __must_check __always_inline int
 __copy_from_user_inatomic(void *dst, const void __user *src, unsigned size)
 {
-	return copy_user_generic(dst, (__force const void *)src, size);
+	return __copy_from_user_nocheck(dst, (__force const void *)src, size);
 }
 
 static __must_check __always_inline int
 __copy_to_user_inatomic(void __user *dst, const void *src, unsigned size)
 {
-	return copy_user_generic((__force void *)dst, src, size);
+	return __copy_to_user_nocheck((__force void *)dst, src, size);
 }
 
 extern long __copy_user_nocache(void *dst, const void __user *src,
diff --git a/arch/x86/include/asm/xen/hypervisor.h b/arch/x86/include/asm/xen/hypervisor.h
index 125f344..8ac93f0 100644
--- a/arch/x86/include/asm/xen/hypervisor.h
+++ b/arch/x86/include/asm/xen/hypervisor.h
@@ -71,4 +71,6 @@ static inline bool xen_x2apic_para_available(void)
 }
 #endif
 
+extern void xen_set_iopl_mask(unsigned mask);
+
 #endif /* _ASM_X86_XEN_HYPERVISOR_H */
diff --git a/arch/x86/include/uapi/asm/processor-flags.h b/arch/x86/include/uapi/asm/processor-flags.h
index b16e6d2..180a0c3 100644
--- a/arch/x86/include/uapi/asm/processor-flags.h
+++ b/arch/x86/include/uapi/asm/processor-flags.h
@@ -2,75 +2,129 @@
 #define _UAPI_ASM_X86_PROCESSOR_FLAGS_H
 /* Various flags defined: can be included from assembler. */
 
+#include <linux/const.h>
+
 /*
  * EFLAGS bits
  */
-#define X86_EFLAGS_CF	0x00000001 /* Carry Flag */
-#define X86_EFLAGS_FIXED 0x00000002 /* Bit 1 - always on */
-#define X86_EFLAGS_PF	0x00000004 /* Parity Flag */
-#define X86_EFLAGS_AF	0x00000010 /* Auxiliary carry Flag */
-#define X86_EFLAGS_ZF	0x00000040 /* Zero Flag */
-#define X86_EFLAGS_SF	0x00000080 /* Sign Flag */
-#define X86_EFLAGS_TF	0x00000100 /* Trap Flag */
-#define X86_EFLAGS_IF	0x00000200 /* Interrupt Flag */
-#define X86_EFLAGS_DF	0x00000400 /* Direction Flag */
-#define X86_EFLAGS_OF	0x00000800 /* Overflow Flag */
-#define X86_EFLAGS_IOPL	0x00003000 /* IOPL mask */
-#define X86_EFLAGS_NT	0x00004000 /* Nested Task */
-#define X86_EFLAGS_RF	0x00010000 /* Resume Flag */
-#define X86_EFLAGS_VM	0x00020000 /* Virtual Mode */
-#define X86_EFLAGS_AC	0x00040000 /* Alignment Check */
-#define X86_EFLAGS_VIF	0x00080000 /* Virtual Interrupt Flag */
-#define X86_EFLAGS_VIP	0x00100000 /* Virtual Interrupt Pending */
-#define X86_EFLAGS_ID	0x00200000 /* CPUID detection flag */
+#define X86_EFLAGS_CF_BIT	0 /* Carry Flag */
+#define X86_EFLAGS_CF		_BITUL(X86_EFLAGS_CF_BIT)
+#define X86_EFLAGS_FIXED_BIT	1 /* Bit 1 - always on */
+#define X86_EFLAGS_FIXED	_BITUL(X86_EFLAGS_FIXED_BIT)
+#define X86_EFLAGS_PF_BIT	2 /* Parity Flag */
+#define X86_EFLAGS_PF		_BITUL(X86_EFLAGS_PF_BIT)
+#define X86_EFLAGS_AF_BIT	4 /* Auxiliary carry Flag */
+#define X86_EFLAGS_AF		_BITUL(X86_EFLAGS_AF_BIT)
+#define X86_EFLAGS_ZF_BIT	6 /* Zero Flag */
+#define X86_EFLAGS_ZF		_BITUL(X86_EFLAGS_ZF_BIT)
+#define X86_EFLAGS_SF_BIT	7 /* Sign Flag */
+#define X86_EFLAGS_SF		_BITUL(X86_EFLAGS_SF_BIT)
+#define X86_EFLAGS_TF_BIT	8 /* Trap Flag */
+#define X86_EFLAGS_TF		_BITUL(X86_EFLAGS_TF_BIT)
+#define X86_EFLAGS_IF_BIT	9 /* Interrupt Flag */
+#define X86_EFLAGS_IF		_BITUL(X86_EFLAGS_IF_BIT)
+#define X86_EFLAGS_DF_BIT	10 /* Direction Flag */
+#define X86_EFLAGS_DF		_BITUL(X86_EFLAGS_DF_BIT)
+#define X86_EFLAGS_OF_BIT	11 /* Overflow Flag */
+#define X86_EFLAGS_OF		_BITUL(X86_EFLAGS_OF_BIT)
+#define X86_EFLAGS_IOPL_BIT	12 /* I/O Privilege Level (2 bits) */
+#define X86_EFLAGS_IOPL		(_AC(3,UL) << X86_EFLAGS_IOPL_BIT)
+#define X86_EFLAGS_NT_BIT	14 /* Nested Task */
+#define X86_EFLAGS_NT		_BITUL(X86_EFLAGS_NT_BIT)
+#define X86_EFLAGS_RF_BIT	16 /* Resume Flag */
+#define X86_EFLAGS_RF		_BITUL(X86_EFLAGS_RF_BIT)
+#define X86_EFLAGS_VM_BIT	17 /* Virtual Mode */
+#define X86_EFLAGS_VM		_BITUL(X86_EFLAGS_VM_BIT)
+#define X86_EFLAGS_AC_BIT	18 /* Alignment Check/Access Control */
+#define X86_EFLAGS_AC		_BITUL(X86_EFLAGS_AC_BIT)
+#define X86_EFLAGS_AC_BIT	18 /* Alignment Check/Access Control */
+#define X86_EFLAGS_AC		_BITUL(X86_EFLAGS_AC_BIT)
+#define X86_EFLAGS_VIF_BIT	19 /* Virtual Interrupt Flag */
+#define X86_EFLAGS_VIF		_BITUL(X86_EFLAGS_VIF_BIT)
+#define X86_EFLAGS_VIP_BIT	20 /* Virtual Interrupt Pending */
+#define X86_EFLAGS_VIP		_BITUL(X86_EFLAGS_VIP_BIT)
+#define X86_EFLAGS_ID_BIT	21 /* CPUID detection */
+#define X86_EFLAGS_ID		_BITUL(X86_EFLAGS_ID_BIT)
 
 /*
  * Basic CPU control in CR0
  */
-#define X86_CR0_PE	0x00000001 /* Protection Enable */
-#define X86_CR0_MP	0x00000002 /* Monitor Coprocessor */
-#define X86_CR0_EM	0x00000004 /* Emulation */
-#define X86_CR0_TS	0x00000008 /* Task Switched */
-#define X86_CR0_ET	0x00000010 /* Extension Type */
-#define X86_CR0_NE	0x00000020 /* Numeric Error */
-#define X86_CR0_WP	0x00010000 /* Write Protect */
-#define X86_CR0_AM	0x00040000 /* Alignment Mask */
-#define X86_CR0_NW	0x20000000 /* Not Write-through */
-#define X86_CR0_CD	0x40000000 /* Cache Disable */
-#define X86_CR0_PG	0x80000000 /* Paging */
+#define X86_CR0_PE_BIT		0 /* Protection Enable */
+#define X86_CR0_PE		_BITUL(X86_CR0_PE_BIT)
+#define X86_CR0_MP_BIT		1 /* Monitor Coprocessor */
+#define X86_CR0_MP		_BITUL(X86_CR0_MP_BIT)
+#define X86_CR0_EM_BIT		2 /* Emulation */
+#define X86_CR0_EM		_BITUL(X86_CR0_EM_BIT)
+#define X86_CR0_TS_BIT		3 /* Task Switched */
+#define X86_CR0_TS		_BITUL(X86_CR0_TS_BIT)
+#define X86_CR0_ET_BIT		4 /* Extension Type */
+#define X86_CR0_ET		_BITUL(X86_CR0_ET_BIT)
+#define X86_CR0_NE_BIT		5 /* Numeric Error */
+#define X86_CR0_NE		_BITUL(X86_CR0_NE_BIT)
+#define X86_CR0_WP_BIT		16 /* Write Protect */
+#define X86_CR0_WP		_BITUL(X86_CR0_WP_BIT)
+#define X86_CR0_AM_BIT		18 /* Alignment Mask */
+#define X86_CR0_AM		_BITUL(X86_CR0_AM_BIT)
+#define X86_CR0_NW_BIT		29 /* Not Write-through */
+#define X86_CR0_NW		_BITUL(X86_CR0_NW_BIT)
+#define X86_CR0_CD_BIT		30 /* Cache Disable */
+#define X86_CR0_CD		_BITUL(X86_CR0_CD_BIT)
+#define X86_CR0_PG_BIT		31 /* Paging */
+#define X86_CR0_PG		_BITUL(X86_CR0_PG_BIT)
 
 /*
  * Paging options in CR3
  */
-#define X86_CR3_PWT	0x00000008 /* Page Write Through */
-#define X86_CR3_PCD	0x00000010 /* Page Cache Disable */
-#define X86_CR3_PCID_MASK 0x00000fff /* PCID Mask */
+#define X86_CR3_PWT_BIT		3 /* Page Write Through */
+#define X86_CR3_PWT		_BITUL(X86_CR3_PWT_BIT)
+#define X86_CR3_PCD_BIT		4 /* Page Cache Disable */
+#define X86_CR3_PCD		_BITUL(X86_CR3_PCD_BIT)
+#define X86_CR3_PCID_MASK	_AC(0x00000fff,UL) /* PCID Mask */
 
 /*
  * Intel CPU features in CR4
  */
-#define X86_CR4_VME	0x00000001 /* enable vm86 extensions */
-#define X86_CR4_PVI	0x00000002 /* virtual interrupts flag enable */
-#define X86_CR4_TSD	0x00000004 /* disable time stamp at ipl 3 */
-#define X86_CR4_DE	0x00000008 /* enable debugging extensions */
-#define X86_CR4_PSE	0x00000010 /* enable page size extensions */
-#define X86_CR4_PAE	0x00000020 /* enable physical address extensions */
-#define X86_CR4_MCE	0x00000040 /* Machine check enable */
-#define X86_CR4_PGE	0x00000080 /* enable global pages */
-#define X86_CR4_PCE	0x00000100 /* enable performance counters at ipl 3 */
-#define X86_CR4_OSFXSR	0x00000200 /* enable fast FPU save and restore */
-#define X86_CR4_OSXMMEXCPT 0x00000400 /* enable unmasked SSE exceptions */
-#define X86_CR4_VMXE	0x00002000 /* enable VMX virtualization */
-#define X86_CR4_RDWRGSFS 0x00010000 /* enable RDWRGSFS support */
-#define X86_CR4_PCIDE	0x00020000 /* enable PCID support */
-#define X86_CR4_OSXSAVE 0x00040000 /* enable xsave and xrestore */
-#define X86_CR4_SMEP	0x00100000 /* enable SMEP support */
-#define X86_CR4_SMAP	0x00200000 /* enable SMAP support */
+#define X86_CR4_VME_BIT		0 /* enable vm86 extensions */
+#define X86_CR4_VME		_BITUL(X86_CR4_VME_BIT)
+#define X86_CR4_PVI_BIT		1 /* virtual interrupts flag enable */
+#define X86_CR4_PVI		_BITUL(X86_CR4_PVI_BIT)
+#define X86_CR4_TSD_BIT		2 /* disable time stamp at ipl 3 */
+#define X86_CR4_TSD		_BITUL(X86_CR4_TSD_BIT)
+#define X86_CR4_DE_BIT		3 /* enable debugging extensions */
+#define X86_CR4_DE		_BITUL(X86_CR4_DE_BIT)
+#define X86_CR4_PSE_BIT		4 /* enable page size extensions */
+#define X86_CR4_PSE		_BITUL(X86_CR4_PSE_BIT)
+#define X86_CR4_PAE_BIT		5 /* enable physical address extensions */
+#define X86_CR4_PAE		_BITUL(X86_CR4_PAE_BIT)
+#define X86_CR4_MCE_BIT		6 /* Machine check enable */
+#define X86_CR4_MCE		_BITUL(X86_CR4_MCE_BIT)
+#define X86_CR4_PGE_BIT		7 /* enable global pages */
+#define X86_CR4_PGE		_BITUL(X86_CR4_PGE_BIT)
+#define X86_CR4_PCE_BIT		8 /* enable performance counters at ipl 3 */
+#define X86_CR4_PCE		_BITUL(X86_CR4_PCE_BIT)
+#define X86_CR4_OSFXSR_BIT	9 /* enable fast FPU save and restore */
+#define X86_CR4_OSFXSR		_BITUL(X86_CR4_OSFXSR_BIT)
+#define X86_CR4_OSXMMEXCPT_BIT	10 /* enable unmasked SSE exceptions */
+#define X86_CR4_OSXMMEXCPT	_BITUL(X86_CR4_OSXMMEXCPT_BIT)
+#define X86_CR4_VMXE_BIT	13 /* enable VMX virtualization */
+#define X86_CR4_VMXE		_BITUL(X86_CR4_VMXE_BIT)
+#define X86_CR4_SMXE_BIT	14 /* enable safer mode (TXT) */
+#define X86_CR4_SMXE		_BITUL(X86_CR4_SMXE_BIT)
+#define X86_CR4_FSGSBASE_BIT	16 /* enable RDWRFSGS support */
+#define X86_CR4_FSGSBASE	_BITUL(X86_CR4_FSGSBASE_BIT)
+#define X86_CR4_PCIDE_BIT	17 /* enable PCID support */
+#define X86_CR4_PCIDE		_BITUL(X86_CR4_PCIDE_BIT)
+#define X86_CR4_OSXSAVE_BIT	18 /* enable xsave and xrestore */
+#define X86_CR4_OSXSAVE		_BITUL(X86_CR4_OSXSAVE_BIT)
+#define X86_CR4_SMEP_BIT	20 /* enable SMEP support */
+#define X86_CR4_SMEP		_BITUL(X86_CR4_SMEP_BIT)
+#define X86_CR4_SMAP_BIT	21 /* enable SMAP support */
+#define X86_CR4_SMAP		_BITUL(X86_CR4_SMAP_BIT)
 
 /*
  * x86-64 Task Priority Register, CR8
  */
-#define X86_CR8_TPR	0x0000000F /* task priority register */
+#define X86_CR8_TPR		_AC(0x0000000f,UL) /* task priority register */
 
 /*
  * AMD and Transmeta use MSRs for configuration; see <asm/msr-index.h>
diff --git a/arch/x86/kernel/acpi/sleep.c b/arch/x86/kernel/acpi/sleep.c
index ec94e11..ca08056 100644
--- a/arch/x86/kernel/acpi/sleep.c
+++ b/arch/x86/kernel/acpi/sleep.c
@@ -16,6 +16,7 @@
 #include <asm/cacheflush.h>
 #include <asm/realmode.h>
 
+#include <linux/ftrace.h>
 #include "../../realmode/rm/wakeup.h"
 #include "sleep.h"
 
@@ -96,7 +97,13 @@ int acpi_suspend_lowlevel(void)
        saved_magic = 0x123456789abcdef0L;
 #endif /* CONFIG_64BIT */
 
+	/*
+	 * Pause/unpause graph tracing around do_suspend_lowlevel as it has
+	 * inconsistent call/return info after it jumps to the wakeup vector.
+	 */
+	pause_graph_tracing();
 	do_suspend_lowlevel();
+	unpause_graph_tracing();
 	return 0;
 }
 
diff --git a/arch/x86/kernel/amd_nb.c b/arch/x86/kernel/amd_nb.c
index 59554dc..e6a3b1e 100644
--- a/arch/x86/kernel/amd_nb.c
+++ b/arch/x86/kernel/amd_nb.c
@@ -67,8 +67,8 @@ int amd_cache_northbridges(void)
 	while ((misc = next_northbridge(misc, amd_nb_misc_ids)) != NULL)
 		i++;
 
-	if (i == 0)
-		return 0;
+	if (!i)
+		return -ENODEV;
 
 	nb = kzalloc(i * sizeof(struct amd_northbridge), GFP_KERNEL);
 	if (!nb)
diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c
index 033eb44..9620d18 100644
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@ -350,6 +350,13 @@ static void __setup_APIC_LVTT(unsigned int clocks, int oneshot, int irqen)
 	apic_write(APIC_LVTT, lvtt_value);
 
 	if (lvtt_value & APIC_LVT_TIMER_TSCDEADLINE) {
+		/*
+		 * See Intel SDM: TSC-Deadline Mode chapter. In xAPIC mode,
+		 * writing to the APIC LVTT and TSC_DEADLINE MSR isn't serialized.
+		 * According to Intel, MFENCE can do the serialization here.
+		 */
+		asm volatile("mfence" : : : "memory");
+
 		printk_once(KERN_DEBUG "TSC deadline timer enabled\n");
 		return;
 	}
diff --git a/arch/x86/kernel/apm_32.c b/arch/x86/kernel/apm_32.c
index 53a4e27..3ab0343 100644
--- a/arch/x86/kernel/apm_32.c
+++ b/arch/x86/kernel/apm_32.c
@@ -392,7 +392,7 @@ static struct cpuidle_device apm_cpuidle_device;
 /*
  * Local variables
  */
-static struct {
+__visible struct {
 	unsigned long	offset;
 	unsigned short	segment;
 } apm_bios_entry;
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 5641401..81e0fe4 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -280,10 +280,9 @@ __setup("nosmap", setup_disable_smap);
 
 static __always_inline void setup_smap(struct cpuinfo_x86 *c)
 {
-	unsigned long eflags;
+	unsigned long eflags = native_save_fl();
 
 	/* This should have been cleared long ago */
-	raw_local_save_flags(eflags);
 	BUG_ON(eflags & X86_EFLAGS_AC);
 
 	if (cpu_has(c, X86_FEATURE_SMAP)) {
diff --git a/arch/x86/kernel/cpu/perf_event.h b/arch/x86/kernel/cpu/perf_event.h
index ba9aadf..5fd0bbe 100644
--- a/arch/x86/kernel/cpu/perf_event.h
+++ b/arch/x86/kernel/cpu/perf_event.h
@@ -665,6 +665,8 @@ void intel_pmu_lbr_init_atom(void);
 
 void intel_pmu_lbr_init_snb(void);
 
+void intel_pmu_pebs_data_source_nhm(void);
+
 int intel_pmu_setup_lbr_filter(struct perf_event *event);
 
 int p4_pmu_init(void);
diff --git a/arch/x86/kernel/cpu/perf_event_amd.c b/arch/x86/kernel/cpu/perf_event_amd.c
index 7e28d94..4cbe032 100644
--- a/arch/x86/kernel/cpu/perf_event_amd.c
+++ b/arch/x86/kernel/cpu/perf_event_amd.c
@@ -648,48 +648,48 @@ static __initconst const struct x86_pmu amd_pmu = {
 	.cpu_dead		= amd_pmu_cpu_dead,
 };
 
-static int setup_event_constraints(void)
+static int __init amd_core_pmu_init(void)
 {
-	if (boot_cpu_data.x86 == 0x15)
+	if (!cpu_has_perfctr_core)
+		return 0;
+
+	switch (boot_cpu_data.x86) {
+	case 0x15:
+		pr_cont("Fam15h ");
 		x86_pmu.get_event_constraints = amd_get_event_constraints_f15h;
-	return 0;
-}
+		break;
 
-static int setup_perfctr_core(void)
-{
-	if (!cpu_has_perfctr_core) {
-		WARN(x86_pmu.get_event_constraints == amd_get_event_constraints_f15h,
-		     KERN_ERR "Odd, counter constraints enabled but no core perfctrs detected!");
+	default:
+		pr_err("core perfctr but no constraints; unknown hardware!\n");
 		return -ENODEV;
 	}
 
-	WARN(x86_pmu.get_event_constraints == amd_get_event_constraints,
-	     KERN_ERR "hw perf events core counters need constraints handler!");
-
 	/*
 	 * If core performance counter extensions exists, we must use
 	 * MSR_F15H_PERF_CTL/MSR_F15H_PERF_CTR msrs. See also
-	 * x86_pmu_addr_offset().
+	 * amd_pmu_addr_offset().
 	 */
 	x86_pmu.eventsel	= MSR_F15H_PERF_CTL;
 	x86_pmu.perfctr		= MSR_F15H_PERF_CTR;
 	x86_pmu.num_counters	= AMD64_NUM_COUNTERS_CORE;
 
-	printk(KERN_INFO "perf: AMD core performance counters detected\n");
-
+	pr_cont("core perfctr, ");
 	return 0;
 }
 
 __init int amd_pmu_init(void)
 {
+	int ret;
+
 	/* Performance-monitoring supported from K7 and later: */
 	if (boot_cpu_data.x86 < 6)
 		return -ENODEV;
 
 	x86_pmu = amd_pmu;
 
-	setup_event_constraints();
-	setup_perfctr_core();
+	ret = amd_core_pmu_init();
+	if (ret)
+		return ret;
 
 	/* Events are common for all AMDs */
 	memcpy(hw_cache_event_ids, amd_hw_cache_event_ids,
diff --git a/arch/x86/kernel/cpu/perf_event_intel.c b/arch/x86/kernel/cpu/perf_event_intel.c
index 6d6bb6f..a181544 100644
--- a/arch/x86/kernel/cpu/perf_event_intel.c
+++ b/arch/x86/kernel/cpu/perf_event_intel.c
@@ -2088,6 +2088,7 @@ __init int intel_pmu_init(void)
 		intel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =
 			X86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);
 
+		intel_pmu_pebs_data_source_nhm();
 		x86_add_quirk(intel_nehalem_quirk);
 
 		pr_cont("Nehalem events, ");
@@ -2133,6 +2134,7 @@ __init int intel_pmu_init(void)
 		intel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =
 			X86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);
 
+		intel_pmu_pebs_data_source_nhm();
 		pr_cont("Westmere events, ");
 		break;
 
@@ -2239,13 +2241,16 @@ __init int intel_pmu_init(void)
 		 * counter, so do not extend mask to generic counters
 		 */
 		for_each_event_constraint(c, x86_pmu.event_constraints) {
-			if (c->cmask != X86_RAW_EVENT_MASK
-			    || c->idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES) {
+			if (c->cmask == X86_RAW_EVENT_MASK
+			    && c->idxmsk64 == INTEL_PMC_MSK_FIXED_REF_CYCLES) {
+				c->idxmsk64 |= (1ULL << x86_pmu.num_counters) - 1;
 				continue;
 			}
 
-			c->idxmsk64 |= (1ULL << x86_pmu.num_counters) - 1;
-			c->weight += x86_pmu.num_counters;
+			c->idxmsk64 &=
+				~(~0ULL << (INTEL_PMC_IDX_FIXED + x86_pmu.num_counters_fixed));
+			c->weight = hweight64(c->idxmsk64);
+
 		}
 	}
 
diff --git a/arch/x86/kernel/cpu/perf_event_intel_ds.c b/arch/x86/kernel/cpu/perf_event_intel_ds.c
index 60250f6..17b090a 100644
--- a/arch/x86/kernel/cpu/perf_event_intel_ds.c
+++ b/arch/x86/kernel/cpu/perf_event_intel_ds.c
@@ -50,7 +50,8 @@ union intel_x86_pebs_dse {
 #define OP_LH (P(OP, LOAD) | P(LVL, HIT))
 #define SNOOP_NONE_MISS (P(SNOOP, NONE) | P(SNOOP, MISS))
 
-static const u64 pebs_data_source[] = {
+/* Version for Sandy Bridge and later */
+static u64 pebs_data_source[] = {
 	P(OP, LOAD) | P(LVL, MISS) | P(LVL, L3) | P(SNOOP, NA),/* 0x00:ukn L3 */
 	OP_LH | P(LVL, L1)  | P(SNOOP, NONE),	/* 0x01: L1 local */
 	OP_LH | P(LVL, LFB) | P(SNOOP, NONE),	/* 0x02: LFB hit */
@@ -69,6 +70,14 @@ static const u64 pebs_data_source[] = {
 	OP_LH | P(LVL, UNC) | P(SNOOP, NONE), /* 0x0f: uncached */
 };
 
+/* Patch up minor differences in the bits */
+void __init intel_pmu_pebs_data_source_nhm(void)
+{
+	pebs_data_source[0x05] = OP_LH | P(LVL, L3)  | P(SNOOP, HIT);
+	pebs_data_source[0x06] = OP_LH | P(LVL, L3)  | P(SNOOP, HITM);
+	pebs_data_source[0x07] = OP_LH | P(LVL, L3)  | P(SNOOP, HITM);
+}
+
 static u64 precise_store_data(u64 status)
 {
 	union intel_x86_pebs_dse dse;
diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
index 55b6761..3b861b7 100644
--- a/arch/x86/kernel/head64.c
+++ b/arch/x86/kernel/head64.c
@@ -162,7 +162,7 @@ void __init x86_64_start_kernel(char * real_mode_data)
 	clear_bss();
 
 	for (i = 0; i < NUM_EXCEPTION_VECTORS; i++)
-		set_intr_gate(i, &early_idt_handlers[i]);
+		set_intr_gate(i, &early_idt_handler_array[i]);
 	load_idt((const struct desc_ptr *)&idt_descr);
 
 	copy_bootdata(__va(real_mode_data));
diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S
index df63cae..8060c8b 100644
--- a/arch/x86/kernel/head_32.S
+++ b/arch/x86/kernel/head_32.S
@@ -499,21 +499,22 @@ check_x87:
 __INIT
 setup_once:
 	/*
-	 * Set up a idt with 256 entries pointing to ignore_int,
-	 * interrupt gates. It doesn't actually load idt - that needs
-	 * to be done on each CPU. Interrupts are enabled elsewhere,
-	 * when we can be relatively sure everything is ok.
+	 * Set up a idt with 256 interrupt gates that push zero if there
+	 * is no error code and then jump to early_idt_handler_common.
+	 * It doesn't actually load the idt - that needs to be done on
+	 * each CPU. Interrupts are enabled elsewhere, when we can be
+	 * relatively sure everything is ok.
 	 */
 
 	movl $idt_table,%edi
-	movl $early_idt_handlers,%eax
+	movl $early_idt_handler_array,%eax
 	movl $NUM_EXCEPTION_VECTORS,%ecx
 1:
 	movl %eax,(%edi)
 	movl %eax,4(%edi)
 	/* interrupt gate, dpl=0, present */
 	movl $(0x8E000000 + __KERNEL_CS),2(%edi)
-	addl $9,%eax
+	addl $EARLY_IDT_HANDLER_SIZE,%eax
 	addl $8,%edi
 	loop 1b
 
@@ -545,26 +546,28 @@ setup_once:
 	andl $0,setup_once_ref	/* Once is enough, thanks */
 	ret
 
-ENTRY(early_idt_handlers)
+ENTRY(early_idt_handler_array)
 	# 36(%esp) %eflags
 	# 32(%esp) %cs
 	# 28(%esp) %eip
 	# 24(%rsp) error code
 	i = 0
 	.rept NUM_EXCEPTION_VECTORS
-	.if (EXCEPTION_ERRCODE_MASK >> i) & 1
-	ASM_NOP2
-	.else
+	.ifeq (EXCEPTION_ERRCODE_MASK >> i) & 1
 	pushl $0		# Dummy error code, to make stack frame uniform
 	.endif
 	pushl $i		# 20(%esp) Vector number
-	jmp early_idt_handler
+	jmp early_idt_handler_common
 	i = i + 1
+	.fill early_idt_handler_array + i*EARLY_IDT_HANDLER_SIZE - ., 1, 0xcc
 	.endr
-ENDPROC(early_idt_handlers)
+ENDPROC(early_idt_handler_array)
 	
-	/* This is global to keep gas from relaxing the jumps */
-ENTRY(early_idt_handler)
+early_idt_handler_common:
+	/*
+	 * The stack is the hardware frame, an error code or zero, and the
+	 * vector number.
+	 */
 	cld
 
 	cmpl $2,(%esp)		# X86_TRAP_NMI
@@ -624,7 +627,7 @@ ex_entry:
 is_nmi:
 	addl $8,%esp		/* drop vector number and error code */
 	iret
-ENDPROC(early_idt_handler)
+ENDPROC(early_idt_handler_common)
 
 /* This is the default interrupt "handler" :-) */
 	ALIGN
diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S
index f2a9a2a..54bf9c2 100644
--- a/arch/x86/kernel/head_64.S
+++ b/arch/x86/kernel/head_64.S
@@ -65,6 +65,9 @@ startup_64:
 	 * tables and then reload them.
 	 */
 
+	/* Sanitize CPU configuration */
+	call verify_cpu
+
 	/*
 	 * Compute the delta between the address I am compiled to run at and the
 	 * address I am actually running at.
@@ -174,6 +177,9 @@ ENTRY(secondary_startup_64)
 	 * after the boot processor executes this code.
 	 */
 
+	/* Sanitize CPU configuration */
+	call verify_cpu
+
 	movq	$(init_level4_pgt - __START_KERNEL_map), %rax
 1:
 
@@ -288,6 +294,8 @@ ENTRY(secondary_startup_64)
 	pushq	%rax		# target address in negative space
 	lretq
 
+#include "verify_cpu.S"
+
 #ifdef CONFIG_HOTPLUG_CPU
 /*
  * Boot CPU0 entry point. It's called from play_dead(). Everything has been set
@@ -321,26 +329,28 @@ bad_address:
 	jmp bad_address
 
 	__INIT
-	.globl early_idt_handlers
-early_idt_handlers:
+ENTRY(early_idt_handler_array)
 	# 104(%rsp) %rflags
 	#  96(%rsp) %cs
 	#  88(%rsp) %rip
 	#  80(%rsp) error code
 	i = 0
 	.rept NUM_EXCEPTION_VECTORS
-	.if (EXCEPTION_ERRCODE_MASK >> i) & 1
-	ASM_NOP2
-	.else
+	.ifeq (EXCEPTION_ERRCODE_MASK >> i) & 1
 	pushq $0		# Dummy error code, to make stack frame uniform
 	.endif
 	pushq $i		# 72(%rsp) Vector number
-	jmp early_idt_handler
+	jmp early_idt_handler_common
 	i = i + 1
+	.fill early_idt_handler_array + i*EARLY_IDT_HANDLER_SIZE - ., 1, 0xcc
 	.endr
+ENDPROC(early_idt_handler_array)
 
-/* This is global to keep gas from relaxing the jumps */
-ENTRY(early_idt_handler)
+early_idt_handler_common:
+	/*
+	 * The stack is the hardware frame, an error code or zero, and the
+	 * vector number.
+	 */
 	cld
 
 	cmpl $2,(%rsp)		# X86_TRAP_NMI
@@ -412,7 +422,7 @@ ENTRY(early_idt_handler)
 is_nmi:
 	addq $16,%rsp		# drop vector number and error code
 	INTERRUPT_RETURN
-ENDPROC(early_idt_handler)
+ENDPROC(early_idt_handler_common)
 
 	__INITDATA
 
diff --git a/arch/x86/kernel/ioport.c b/arch/x86/kernel/ioport.c
index 4ddaf66..792621a 100644
--- a/arch/x86/kernel/ioport.c
+++ b/arch/x86/kernel/ioport.c
@@ -96,9 +96,14 @@ asmlinkage long sys_ioperm(unsigned long from, unsigned long num, int turn_on)
 SYSCALL_DEFINE1(iopl, unsigned int, level)
 {
 	struct pt_regs *regs = current_pt_regs();
-	unsigned int old = (regs->flags >> 12) & 3;
 	struct thread_struct *t = &current->thread;
 
+	/*
+	 * Careful: the IOPL bits in regs->flags are undefined under Xen PV
+	 * and changing them has no effect.
+	 */
+	unsigned int old = t->iopl >> X86_EFLAGS_IOPL_BIT;
+
 	if (level > 3)
 		return -EINVAL;
 	/* Trying to gain more privileges? */
@@ -106,8 +111,9 @@ SYSCALL_DEFINE1(iopl, unsigned int, level)
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
 	}
-	regs->flags = (regs->flags & ~X86_EFLAGS_IOPL) | (level << 12);
-	t->iopl = level << 12;
+	regs->flags = (regs->flags & ~X86_EFLAGS_IOPL) |
+		(level << X86_EFLAGS_IOPL_BIT);
+	t->iopl = level << X86_EFLAGS_IOPL_BIT;
 	set_iopl_mask(t->iopl);
 
 	return 0;
diff --git a/arch/x86/kernel/kprobes/core.c b/arch/x86/kernel/kprobes/core.c
index 0c6c07c..766aa3b 100644
--- a/arch/x86/kernel/kprobes/core.c
+++ b/arch/x86/kernel/kprobes/core.c
@@ -908,7 +908,19 @@ int __kprobes kprobe_fault_handler(struct pt_regs *regs, int trapnr)
 		 * normal page fault.
 		 */
 		regs->ip = (unsigned long)cur->addr;
+		/*
+		 * Trap flag (TF) has been set here because this fault
+		 * happened where the single stepping will be done.
+		 * So clear it by resetting the current kprobe:
+		 */
+		regs->flags &= ~X86_EFLAGS_TF;
+
+		/*
+		 * If the TF flag was set before the kprobe hit,
+		 * don't touch it:
+		 */
 		regs->flags |= kcb->kprobe_old_flags;
+
 		if (kcb->kprobe_status == KPROBE_REENTER)
 			restore_previous_kprobe(kcb);
 		else
diff --git a/arch/x86/kernel/microcode_intel_early.c b/arch/x86/kernel/microcode_intel_early.c
index 2e9e128..a883942 100644
--- a/arch/x86/kernel/microcode_intel_early.c
+++ b/arch/x86/kernel/microcode_intel_early.c
@@ -321,7 +321,7 @@ get_matching_model_microcode(int cpu, unsigned long start,
 	unsigned int mc_saved_count = mc_saved_data->mc_saved_count;
 	int i;
 
-	while (leftover) {
+	while (leftover && mc_saved_count < ARRAY_SIZE(mc_saved_tmp)) {
 		mc_header = (struct microcode_header_intel *)ucode_ptr;
 
 		mc_size = get_totalsize(mc_header);
diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
index 7099ab1..580001c 100644
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -49,6 +49,7 @@
 #include <asm/syscalls.h>
 #include <asm/debugreg.h>
 #include <asm/switch_to.h>
+#include <asm/xen/hypervisor.h>
 
 asmlinkage extern void ret_from_fork(void);
 
@@ -412,6 +413,17 @@ __switch_to(struct task_struct *prev_p, struct task_struct *next_p)
 		     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))
 		__switch_to_xtra(prev_p, next_p, tss);
 
+#ifdef CONFIG_XEN
+	/*
+	 * On Xen PV, IOPL bits in pt_regs->flags have no effect, and
+	 * current_pt_regs()->flags may not match the current task's
+	 * intended IOPL.  We need to switch it manually.
+	 */
+	if (unlikely(xen_pv_domain() &&
+		     prev->iopl != next->iopl))
+		xen_set_iopl_mask(next->iopl);
+#endif
+
 	return prev_p;
 }
 
diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c
index 90fd119..abfc89b 100644
--- a/arch/x86/kernel/reboot.c
+++ b/arch/x86/kernel/reboot.c
@@ -366,6 +366,14 @@ static struct dmi_system_id __initdata reboot_dmi_table[] = {
 			DMI_MATCH(DMI_BOARD_NAME, "P4S800"),
 		},
 	},
+	{	/* Handle problems with rebooting on the iMac10,1. */
+		.callback = set_pci_reboot,
+		.ident = "Apple iMac10,1",
+		.matches = {
+		    DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
+		    DMI_MATCH(DMI_PRODUCT_NAME, "iMac10,1"),
+		},
+	},
 
 	{	/* Handle reboot issue on Acer Aspire one */
 		.callback = set_kbd_reboot,
diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index 91964c6..935aff3 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -1156,6 +1156,14 @@ void __init setup_arch(char **cmdline_p)
 	clone_pgd_range(initial_page_table + KERNEL_PGD_BOUNDARY,
 			swapper_pg_dir     + KERNEL_PGD_BOUNDARY,
 			KERNEL_PGD_PTRS);
+
+	/*
+	 * sync back low identity map too.  It is used for example
+	 * in the 32-bit EFI stub.
+	 */
+	clone_pgd_range(initial_page_table,
+			swapper_pg_dir     + KERNEL_PGD_BOUNDARY,
+			min(KERNEL_PGD_PTRS, KERNEL_PGD_BOUNDARY));
 #endif
 
 	tboot_probe();
diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c
index 66deef4..f11fd59 100644
--- a/arch/x86/kernel/signal.c
+++ b/arch/x86/kernel/signal.c
@@ -686,12 +686,15 @@ handle_signal(struct ksignal *ksig, struct pt_regs *regs)
 	signal_setup_done(failed, ksig, test_thread_flag(TIF_SINGLESTEP));
 }
 
-#ifdef CONFIG_X86_32
-#define NR_restart_syscall	__NR_restart_syscall
-#else /* !CONFIG_X86_32 */
-#define NR_restart_syscall	\
-	test_thread_flag(TIF_IA32) ? __NR_ia32_restart_syscall : __NR_restart_syscall
-#endif /* CONFIG_X86_32 */
+static inline unsigned long get_nr_restart_syscall(const struct pt_regs *regs)
+{
+#if defined(CONFIG_X86_32) || !defined(CONFIG_X86_64)
+	return __NR_restart_syscall;
+#else /* !CONFIG_X86_32 && CONFIG_X86_64 */
+	return test_thread_flag(TIF_IA32) ? __NR_ia32_restart_syscall :
+		__NR_restart_syscall | (regs->orig_ax & __X32_SYSCALL_BIT);
+#endif /* CONFIG_X86_32 || !CONFIG_X86_64 */
+}
 
 /*
  * Note that 'init' is a special process: it doesn't get signals it doesn't
@@ -720,7 +723,7 @@ static void do_signal(struct pt_regs *regs)
 			break;
 
 		case -ERESTART_RESTARTBLOCK:
-			regs->ax = NR_restart_syscall;
+			regs->ax = get_nr_restart_syscall(regs);
 			regs->ip -= 2;
 			break;
 		}
diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index 27e3a14..9714a7a 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -20,6 +20,7 @@
 #include <asm/hypervisor.h>
 #include <asm/nmi.h>
 #include <asm/x86_init.h>
+#include <asm/geode.h>
 
 unsigned int __read_mostly cpu_khz;	/* TSC clocks / usec, not used here */
 EXPORT_SYMBOL(cpu_khz);
@@ -806,15 +807,17 @@ EXPORT_SYMBOL_GPL(mark_tsc_unstable);
 
 static void __init check_system_tsc_reliable(void)
 {
-#ifdef CONFIG_MGEODE_LX
-	/* RTSC counts during suspend */
+#if defined(CONFIG_MGEODEGX1) || defined(CONFIG_MGEODE_LX) || defined(CONFIG_X86_GENERIC)
+	if (is_geode_lx()) {
+		/* RTSC counts during suspend */
 #define RTSC_SUSP 0x100
-	unsigned long res_low, res_high;
+		unsigned long res_low, res_high;
 
-	rdmsr_safe(MSR_GEODE_BUSCONT_CONF0, &res_low, &res_high);
-	/* Geode_LX - the OLPC CPU has a very reliable TSC */
-	if (res_low & RTSC_SUSP)
-		tsc_clocksource_reliable = 1;
+		rdmsr_safe(MSR_GEODE_BUSCONT_CONF0, &res_low, &res_high);
+		/* Geode_LX - the OLPC CPU has a very reliable TSC */
+		if (res_low & RTSC_SUSP)
+			tsc_clocksource_reliable = 1;
+	}
 #endif
 	if (boot_cpu_has(X86_FEATURE_TSC_RELIABLE))
 		tsc_clocksource_reliable = 1;
diff --git a/arch/x86/kernel/verify_cpu.S b/arch/x86/kernel/verify_cpu.S
index b9242ba..4cf401f 100644
--- a/arch/x86/kernel/verify_cpu.S
+++ b/arch/x86/kernel/verify_cpu.S
@@ -34,10 +34,11 @@
 #include <asm/msr-index.h>
 
 verify_cpu:
-	pushfl				# Save caller passed flags
-	pushl	$0			# Kill any dangerous flags
-	popfl
+	pushf				# Save caller passed flags
+	push	$0			# Kill any dangerous flags
+	popf
 
+#ifndef __x86_64__
 	pushfl				# standard way to check for cpuid
 	popl	%eax
 	movl	%eax,%ebx
@@ -48,6 +49,7 @@ verify_cpu:
 	popl	%eax
 	cmpl	%eax,%ebx
 	jz	verify_cpu_no_longmode	# cpu has no cpuid
+#endif
 
 	movl	$0x0,%eax		# See if cpuid 1 is implemented
 	cpuid
@@ -130,10 +132,10 @@ verify_cpu_sse_test:
 	jmp	verify_cpu_sse_test	# try again
 
 verify_cpu_no_longmode:
-	popfl				# Restore caller passed flags
+	popf				# Restore caller passed flags
 	movl $1,%eax
 	ret
 verify_cpu_sse_ok:
-	popfl				# Restore caller passed flags
+	popf				# Restore caller passed flags
 	xorl %eax, %eax
 	ret
diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index af88fa2..ddad189 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -2450,7 +2450,7 @@ static int em_sysenter(struct x86_emulate_ctxt *ctxt)
 	 * Not recognized on AMD in compat mode (but is recognized in legacy
 	 * mode).
 	 */
-	if ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)
+	if ((ctxt->mode != X86EMUL_MODE_PROT64) && (efer & EFER_LMA)
 	    && !vendor_intel(ctxt))
 		return emulate_ud(ctxt);
 
@@ -2463,25 +2463,13 @@ static int em_sysenter(struct x86_emulate_ctxt *ctxt)
 	setup_syscalls_segments(ctxt, &cs, &ss);
 
 	ops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);
-	switch (ctxt->mode) {
-	case X86EMUL_MODE_PROT32:
-		if ((msr_data & 0xfffc) == 0x0)
-			return emulate_gp(ctxt, 0);
-		break;
-	case X86EMUL_MODE_PROT64:
-		if (msr_data == 0x0)
-			return emulate_gp(ctxt, 0);
-		break;
-	default:
-		break;
-	}
+	if ((msr_data & 0xfffc) == 0x0)
+		return emulate_gp(ctxt, 0);
 
 	ctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);
-	cs_sel = (u16)msr_data;
-	cs_sel &= ~SELECTOR_RPL_MASK;
+	cs_sel = (u16)msr_data & ~SELECTOR_RPL_MASK;
 	ss_sel = cs_sel + 8;
-	ss_sel &= ~SELECTOR_RPL_MASK;
-	if (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {
+	if (efer & EFER_LMA) {
 		cs.d = 0;
 		cs.l = 1;
 	}
@@ -2490,10 +2478,11 @@ static int em_sysenter(struct x86_emulate_ctxt *ctxt)
 	ops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);
 
 	ops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);
-	ctxt->_eip = msr_data;
+	ctxt->_eip = (efer & EFER_LMA) ? msr_data : (u32)msr_data;
 
 	ops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);
-	*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;
+	*reg_write(ctxt, VCPU_REGS_RSP) = (efer & EFER_LMA) ? msr_data :
+							      (u32)msr_data;
 
 	return X86EMUL_CONTINUE;
 }
diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c
index 298781d..b0a706d 100644
--- a/arch/x86/kvm/i8254.c
+++ b/arch/x86/kvm/i8254.c
@@ -244,7 +244,7 @@ static void kvm_pit_ack_irq(struct kvm_irq_ack_notifier *kian)
 		 * PIC is being reset.  Handle it gracefully here
 		 */
 		atomic_inc(&ps->pending);
-	else if (value > 0)
+	else if (value > 0 && ps->reinject)
 		/* in this case, we had multiple outstanding pit interrupts
 		 * that we needed to inject.  Reinject
 		 */
@@ -287,7 +287,9 @@ static void pit_do_work(struct kthread_work *work)
 	 * last one has been acked.
 	 */
 	spin_lock(&ps->inject_lock);
-	if (ps->irq_ack) {
+	if (!ps->reinject)
+		inject = 1;
+	else if (ps->irq_ack) {
 		ps->irq_ack = 0;
 		inject = 1;
 	}
@@ -305,7 +307,7 @@ static void pit_do_work(struct kthread_work *work)
 		 * LVT0 to NMI delivery. Other PIC interrupts are just sent to
 		 * VCPU0, and only if its LVT0 is in EXTINT mode.
 		 */
-		if (kvm->arch.vapics_in_nmi_mode > 0)
+		if (atomic_read(&kvm->arch.vapics_in_nmi_mode) > 0)
 			kvm_for_each_vcpu(i, vcpu, kvm)
 				kvm_apic_nmi_wd_deliver(vcpu);
 	}
@@ -316,10 +318,10 @@ static enum hrtimer_restart pit_timer_fn(struct hrtimer *data)
 	struct kvm_kpit_state *ps = container_of(data, struct kvm_kpit_state, timer);
 	struct kvm_pit *pt = ps->kvm->arch.vpit;
 
-	if (ps->reinject || !atomic_read(&ps->pending)) {
+	if (ps->reinject)
 		atomic_inc(&ps->pending);
-		queue_kthread_work(&pt->worker, &pt->expired);
-	}
+
+	queue_kthread_work(&pt->worker, &pt->expired);
 
 	if (ps->is_periodic) {
 		hrtimer_add_expires_ns(&ps->timer, ps->period);
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 681e4e2..ff28020 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -1123,10 +1123,10 @@ static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)
 		if (!nmi_wd_enabled) {
 			apic_debug("Receive NMI setting on APIC_LVT0 "
 				   "for cpu %d\n", apic->vcpu->vcpu_id);
-			apic->vcpu->kvm->arch.vapics_in_nmi_mode++;
+			atomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);
 		}
 	} else if (nmi_wd_enabled)
-		apic->vcpu->kvm->arch.vapics_in_nmi_mode--;
+		atomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);
 }
 
 static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h
index c8b0d0d..fc87568 100644
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@ -165,7 +165,7 @@ static inline u16 apic_logical_id(struct kvm_apic_map *map, u32 ldr)
 
 static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)
 {
-	return vcpu->arch.apic->pending_events;
+	return kvm_vcpu_has_lapic(vcpu) && vcpu->arch.apic->pending_events;
 }
 
 bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector);
diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c
index e14b1f8..5a75ebf 100644
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@ -3975,7 +3975,7 @@ void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,
 	++vcpu->kvm->stat.mmu_pte_write;
 	kvm_mmu_audit(vcpu, AUDIT_PRE_PTE_WRITE);
 
-	mask.cr0_wp = mask.cr4_pae = mask.nxe = 1;
+	mask.cr0_wp = mask.cr4_pae = mask.nxe = mask.smep_andnot_wp = 1;
 	for_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {
 		if (detect_write_misaligned(sp, gpa, bytes) ||
 		      detect_write_flooding(sp)) {
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index 8bf40a2..3deddd7 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -495,8 +495,10 @@ static void skip_emulated_instruction(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_svm *svm = to_svm(vcpu);
 
-	if (svm->vmcb->control.next_rip != 0)
+	if (svm->vmcb->control.next_rip != 0) {
+		WARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));
 		svm->next_rip = svm->vmcb->control.next_rip;
+	}
 
 	if (!svm->next_rip) {
 		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
@@ -4229,7 +4231,9 @@ static int svm_check_intercept(struct kvm_vcpu *vcpu,
 		break;
 	}
 
-	vmcb->control.next_rip  = info->next_rip;
+	/* TODO: Advertise NRIPS to guest hypervisor unconditionally */
+	if (static_cpu_has(X86_FEATURE_NRIPS))
+		vmcb->control.next_rip  = info->next_rip;
 	vmcb->control.exit_code = icpt_info.exit_code;
 	vmexit = nested_svm_exit_handled(svm);
 
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 04cc2fa..335fe70 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -1487,6 +1487,13 @@ static void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,
 			return;
 		}
 		break;
+	case MSR_IA32_PEBS_ENABLE:
+		/* PEBS needs a quiescent period after being disabled (to write
+		 * a record).  Disabling PEBS through VMX MSR swapping doesn't
+		 * provide that period, so a CPU could write host's record into
+		 * guest's memory.
+		 */
+		wrmsrl(MSR_IA32_PEBS_ENABLE, 0);
 	}
 
 	for (i = 0; i < m->nr; ++i)
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 41ba726..8e57771 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -626,7 +626,7 @@ int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
 	if (!guest_cpuid_has_smep(vcpu) && (cr4 & X86_CR4_SMEP))
 		return 1;
 
-	if (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_RDWRGSFS))
+	if (!guest_cpuid_has_fsgsbase(vcpu) && (cr4 & X86_CR4_FSGSBASE))
 		return 1;
 
 	if (is_long_mode(vcpu)) {
@@ -1941,6 +1941,8 @@ static void accumulate_steal_time(struct kvm_vcpu *vcpu)
 
 static void record_steal_time(struct kvm_vcpu *vcpu)
 {
+	accumulate_steal_time(vcpu);
+
 	if (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))
 		return;
 
@@ -2074,12 +2076,6 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 		if (!(data & KVM_MSR_ENABLED))
 			break;
 
-		vcpu->arch.st.last_steal = current->sched_info.run_delay;
-
-		preempt_disable();
-		accumulate_steal_time(vcpu);
-		preempt_enable();
-
 		kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);
 
 		break;
@@ -2758,7 +2754,6 @@ void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 		vcpu->cpu = cpu;
 	}
 
-	accumulate_steal_time(vcpu);
 	kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);
 }
 
@@ -2971,6 +2966,11 @@ static int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,
 	if (dbgregs->flags)
 		return -EINVAL;
 
+	if (dbgregs->dr6 & ~0xffffffffull)
+		return -EINVAL;
+	if (dbgregs->dr7 & ~0xffffffffull)
+		return -EINVAL;
+
 	memcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));
 	vcpu->arch.dr6 = dbgregs->dr6;
 	vcpu->arch.dr7 = dbgregs->dr7;
diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index d8b1ff6..e4780b0 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -812,11 +812,8 @@ do_sigbus(struct pt_regs *regs, unsigned long error_code, unsigned long address,
 	  unsigned int fault)
 {
 	struct task_struct *tsk = current;
-	struct mm_struct *mm = tsk->mm;
 	int code = BUS_ADRERR;
 
-	up_read(&mm->mmap_sem);
-
 	/* Kernel mode? Handle exceptions or die: */
 	if (!(error_code & PF_USER)) {
 		no_context(regs, error_code, address, SIGBUS, BUS_ADRERR);
@@ -847,7 +844,6 @@ mm_fault_error(struct pt_regs *regs, unsigned long error_code,
 	       unsigned long address, unsigned int fault)
 {
 	if (fatal_signal_pending(current) && !(error_code & PF_USER)) {
-		up_read(&current->mm->mmap_sem);
 		no_context(regs, error_code, address, 0, 0);
 		return;
 	}
@@ -855,14 +851,11 @@ mm_fault_error(struct pt_regs *regs, unsigned long error_code,
 	if (fault & VM_FAULT_OOM) {
 		/* Kernel mode? Handle exceptions or die: */
 		if (!(error_code & PF_USER)) {
-			up_read(&current->mm->mmap_sem);
 			no_context(regs, error_code, address,
 				   SIGSEGV, SEGV_MAPERR);
 			return;
 		}
 
-		up_read(&current->mm->mmap_sem);
-
 		/*
 		 * We ran out of memory, call the OOM killer, and return the
 		 * userspace (which will retry the fault, or kill us if we got
@@ -873,6 +866,8 @@ mm_fault_error(struct pt_regs *regs, unsigned long error_code,
 		if (fault & (VM_FAULT_SIGBUS|VM_FAULT_HWPOISON|
 			     VM_FAULT_HWPOISON_LARGE))
 			do_sigbus(regs, error_code, address, fault);
+		else if (fault & VM_FAULT_SIGSEGV)
+			bad_area_nosemaphore(regs, error_code, address);
 		else
 			BUG();
 	}
@@ -1193,6 +1188,7 @@ good_area:
 		return;
 
 	if (unlikely(fault & VM_FAULT_ERROR)) {
+		up_read(&mm->mmap_sem);
 		mm_fault_error(regs, error_code, address, fault);
 		return;
 	}
diff --git a/arch/x86/mm/init_32.c b/arch/x86/mm/init_32.c
index 3ac7e31..6a70f0e 100644
--- a/arch/x86/mm/init_32.c
+++ b/arch/x86/mm/init_32.c
@@ -137,6 +137,7 @@ page_table_range_init_count(unsigned long start, unsigned long end)
 
 	vaddr = start;
 	pgd_idx = pgd_index(vaddr);
+	pmd_idx = pmd_index(vaddr);
 
 	for ( ; (pgd_idx < PTRS_PER_PGD) && (vaddr != end); pgd_idx++) {
 		for (; (pmd_idx < PTRS_PER_PMD) && (vaddr != end);
diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c
index 2db3f30..b04e502 100644
--- a/arch/x86/mm/init_64.c
+++ b/arch/x86/mm/init_64.c
@@ -1163,7 +1163,7 @@ void mark_rodata_ro(void)
 	 * has been zapped already via cleanup_highmem().
 	 */
 	all_end = roundup((unsigned long)_brk_end, PMD_SIZE);
-	set_memory_nx(rodata_start, (all_end - rodata_start) >> PAGE_SHIFT);
+	set_memory_nx(text_end, (all_end - text_end) >> PAGE_SHIFT);
 
 	rodata_test();
 
diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c
index 282375f..c26b610 100644
--- a/arch/x86/mm/tlb.c
+++ b/arch/x86/mm/tlb.c
@@ -149,7 +149,9 @@ void flush_tlb_current_task(void)
 
 	preempt_disable();
 
+	/* This is an implicit full barrier that synchronizes with switch_mm. */
 	local_flush_tlb();
+
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)
 		flush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);
 	preempt_enable();
@@ -188,11 +190,19 @@ void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
 	unsigned act_entries, tlb_entries = 0;
 
 	preempt_disable();
-	if (current->active_mm != mm)
+	if (current->active_mm != mm) {
+		/* Synchronize with switch_mm. */
+		smp_mb();
+
 		goto flush_all;
+	}
 
 	if (!current->mm) {
 		leave_mm(smp_processor_id());
+
+		/* Synchronize with switch_mm. */
+		smp_mb();
+
 		goto flush_all;
 	}
 
@@ -242,10 +252,18 @@ void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)
 	preempt_disable();
 
 	if (current->active_mm == mm) {
-		if (current->mm)
+		if (current->mm) {
+			/*
+			 * Implicit full barrier (INVLPG) that synchronizes
+			 * with switch_mm.
+			 */
 			__flush_tlb_one(start);
-		else
+		} else {
 			leave_mm(smp_processor_id());
+
+			/* Synchronize with switch_mm. */
+			smp_mb();
+		}
 	}
 
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)
diff --git a/arch/x86/net/bpf_jit_comp.c b/arch/x86/net/bpf_jit_comp.c
index 0c966fe..5479d67 100644
--- a/arch/x86/net/bpf_jit_comp.c
+++ b/arch/x86/net/bpf_jit_comp.c
@@ -176,7 +176,12 @@ void bpf_jit_compile(struct sk_filter *fp)
 	}
 	cleanup_addr = proglen; /* epilogue address */
 
-	for (pass = 0; pass < 10; pass++) {
+	/* JITed image shrinks with every pass and the loop iterates
+	 * until the image stops shrinking. Very large bpf programs
+	 * may converge on the last pass. In such case do one more
+	 * pass to emit the final image
+	 */
+	for (pass = 0; pass < 10 || image; pass++) {
 		u8 seen_or_pass0 = (pass == 0) ? (SEEN_XREG | SEEN_DATAREF | SEEN_MEM) : seen;
 		/* no prologue/epilogue for trivial filters (RET something) */
 		proglen = 0;
diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c
index 3e72425..a3b0265 100644
--- a/arch/x86/pci/acpi.c
+++ b/arch/x86/pci/acpi.c
@@ -84,6 +84,17 @@ static const struct dmi_system_id pci_crs_quirks[] __initconst = {
 			DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies, LTD"),
 		},
 	},
+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/931368 */
+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/1033299 */
+	{
+		.callback = set_use_crs,
+		.ident = "Foxconn K8M890-8237A",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Foxconn"),
+			DMI_MATCH(DMI_BOARD_NAME, "K8M890-8237A"),
+			DMI_MATCH(DMI_BIOS_VENDOR, "Phoenix Technologies, LTD"),
+		},
+	},
 
 	/* Now for the blacklist.. */
 
diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c
index 6033be9..3c8bffd 100644
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@ -250,12 +250,19 @@ static efi_status_t __init phys_efi_set_virtual_address_map(
 	efi_memory_desc_t *virtual_map)
 {
 	efi_status_t status;
+	unsigned long flags;
 
 	efi_call_phys_prelog();
+
+	/* Disable interrupts around EFI calls: */
+	local_irq_save(flags);
 	status = efi_call_phys4(efi_phys.set_virtual_address_map,
 				memory_map_size, descriptor_size,
 				descriptor_version, virtual_map);
+	local_irq_restore(flags);
+
 	efi_call_phys_epilog();
+
 	return status;
 }
 
diff --git a/arch/x86/platform/efi/efi_32.c b/arch/x86/platform/efi/efi_32.c
index 40e4469..bebbee0 100644
--- a/arch/x86/platform/efi/efi_32.c
+++ b/arch/x86/platform/efi/efi_32.c
@@ -33,19 +33,16 @@
 
 /*
  * To make EFI call EFI runtime service in physical addressing mode we need
- * prelog/epilog before/after the invocation to disable interrupt, to
- * claim EFI runtime service handler exclusively and to duplicate a memory in
- * low memory space say 0 - 3G.
+ * prolog/epilog before/after the invocation to claim the EFI runtime service
+ * handler exclusively and to duplicate a memory mapping in low memory space,
+ * say 0 - 3G.
  */
 
-static unsigned long efi_rt_eflags;
 
 void efi_call_phys_prelog(void)
 {
 	struct desc_ptr gdt_descr;
 
-	local_irq_save(efi_rt_eflags);
-
 	load_cr3(initial_page_table);
 	__flush_tlb_all();
 
@@ -64,6 +61,4 @@ void efi_call_phys_epilog(void)
 
 	load_cr3(swapper_pg_dir);
 	__flush_tlb_all();
-
-	local_irq_restore(efi_rt_eflags);
 }
diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c
index 39a0e7f..2f6c1a9 100644
--- a/arch/x86/platform/efi/efi_64.c
+++ b/arch/x86/platform/efi/efi_64.c
@@ -40,7 +40,6 @@
 #include <asm/fixmap.h>
 
 static pgd_t *save_pgd __initdata;
-static unsigned long efi_flags __initdata;
 
 static void __init early_code_mapping_set_exec(int executable)
 {
@@ -66,7 +65,6 @@ void __init efi_call_phys_prelog(void)
 	int n_pgds;
 
 	early_code_mapping_set_exec(1);
-	local_irq_save(efi_flags);
 
 	n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT), PGDIR_SIZE);
 	save_pgd = kmalloc(n_pgds * sizeof(pgd_t), GFP_KERNEL);
@@ -90,7 +88,6 @@ void __init efi_call_phys_epilog(void)
 		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), save_pgd[pgd]);
 	kfree(save_pgd);
 	__flush_tlb_all();
-	local_irq_restore(efi_flags);
 	early_code_mapping_set_exec(0);
 }
 
diff --git a/arch/x86/power/hibernate_32.c b/arch/x86/power/hibernate_32.c
index 7d28c88..291226b 100644
--- a/arch/x86/power/hibernate_32.c
+++ b/arch/x86/power/hibernate_32.c
@@ -13,13 +13,11 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/mmzone.h>
+#include <asm/sections.h>
 
 /* Defined in hibernate_asm_32.S */
 extern int restore_image(void);
 
-/* References to section boundaries */
-extern const void __nosave_begin, __nosave_end;
-
 /* Pointer to the temporary resume page tables */
 pgd_t *resume_pg_dir;
 
diff --git a/arch/x86/power/hibernate_64.c b/arch/x86/power/hibernate_64.c
index a0fde91..8ecaed1 100644
--- a/arch/x86/power/hibernate_64.c
+++ b/arch/x86/power/hibernate_64.c
@@ -17,11 +17,9 @@
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/mtrr.h>
+#include <asm/sections.h>
 #include <asm/suspend.h>
 
-/* References to section boundaries */
-extern const void __nosave_begin, __nosave_end;
-
 /* Defined in hibernate_asm_64.S */
 extern int restore_image(void);
 
diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c
index a492be2..34511cf 100644
--- a/arch/x86/xen/enlighten.c
+++ b/arch/x86/xen/enlighten.c
@@ -33,6 +33,10 @@
 #include <linux/memblock.h>
 #include <linux/edd.h>
 
+#ifdef CONFIG_KEXEC
+#include <linux/kexec.h>
+#endif
+
 #include <xen/xen.h>
 #include <xen/events.h>
 #include <xen/interface/xen.h>
@@ -481,6 +485,7 @@ static void set_aliased_prot(void *v, pgprot_t prot)
 	pte_t pte;
 	unsigned long pfn;
 	struct page *page;
+	unsigned char dummy;
 
 	ptep = lookup_address((unsigned long)v, &level);
 	BUG_ON(ptep == NULL);
@@ -490,6 +495,32 @@ static void set_aliased_prot(void *v, pgprot_t prot)
 
 	pte = pfn_pte(pfn, prot);
 
+	/*
+	 * Careful: update_va_mapping() will fail if the virtual address
+	 * we're poking isn't populated in the page tables.  We don't
+	 * need to worry about the direct map (that's always in the page
+	 * tables), but we need to be careful about vmap space.  In
+	 * particular, the top level page table can lazily propagate
+	 * entries between processes, so if we've switched mms since we
+	 * vmapped the target in the first place, we might not have the
+	 * top-level page table entry populated.
+	 *
+	 * We disable preemption because we want the same mm active when
+	 * we probe the target and when we issue the hypercall.  We'll
+	 * have the same nominal mm, but if we're a kernel thread, lazy
+	 * mm dropping could change our pgd.
+	 *
+	 * Out of an abundance of caution, this uses __get_user() to fault
+	 * in the target address just in case there's some obscure case
+	 * in which the target address isn't readable.
+	 */
+
+	preempt_disable();
+
+	pagefault_disable();	/* Avoid warnings due to being atomic. */
+	__get_user(dummy, (unsigned char __user __force *)v);
+	pagefault_enable();
+
 	if (HYPERVISOR_update_va_mapping((unsigned long)v, pte, 0))
 		BUG();
 
@@ -501,6 +532,8 @@ static void set_aliased_prot(void *v, pgprot_t prot)
 				BUG();
 	} else
 		kmap_flush_unused();
+
+	preempt_enable();
 }
 
 static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)
@@ -508,6 +541,17 @@ static void xen_alloc_ldt(struct desc_struct *ldt, unsigned entries)
 	const unsigned entries_per_page = PAGE_SIZE / LDT_ENTRY_SIZE;
 	int i;
 
+	/*
+	 * We need to mark the all aliases of the LDT pages RO.  We
+	 * don't need to call vm_flush_aliases(), though, since that's
+	 * only responsible for flushing aliases out the TLBs, not the
+	 * page tables, and Xen will flush the TLB for us if needed.
+	 *
+	 * To avoid confusing future readers: none of this is necessary
+	 * to load the LDT.  The hypervisor only checks this when the
+	 * LDT is faulted in due to subsequent descriptor access.
+	 */
+
 	for(i = 0; i < entries; i += entries_per_page)
 		set_aliased_prot(ldt + i, PAGE_KERNEL_RO);
 }
@@ -908,7 +952,7 @@ static void xen_load_sp0(struct tss_struct *tss,
 	xen_mc_issue(PARAVIRT_LAZY_CPU);
 }
 
-static void xen_set_iopl_mask(unsigned mask)
+void xen_set_iopl_mask(unsigned mask)
 {
 	struct physdev_set_iopl set_iopl;
 
@@ -1704,6 +1748,21 @@ static struct notifier_block xen_hvm_cpu_notifier __cpuinitdata = {
 	.notifier_call	= xen_hvm_cpu_notify,
 };
 
+#ifdef CONFIG_KEXEC
+static void xen_hvm_shutdown(void)
+{
+	native_machine_shutdown();
+	if (kexec_in_progress)
+		xen_reboot(SHUTDOWN_soft_reset);
+}
+
+static void xen_hvm_crash_shutdown(struct pt_regs *regs)
+{
+	native_machine_crash_shutdown(regs);
+	xen_reboot(SHUTDOWN_soft_reset);
+}
+#endif
+
 static void __init xen_hvm_guest_init(void)
 {
 	init_hvm_pv_info();
@@ -1718,6 +1777,10 @@ static void __init xen_hvm_guest_init(void)
 	x86_init.irqs.intr_init = xen_init_IRQ;
 	xen_hvm_init_time_ops();
 	xen_hvm_init_mmu_ops();
+#ifdef CONFIG_KEXEC
+	machine_ops.shutdown = xen_hvm_shutdown;
+	machine_ops.crash_shutdown = xen_hvm_crash_shutdown;
+#endif
 }
 
 static bool __init xen_hvm_platform(void)
diff --git a/arch/x86/xen/suspend.c b/arch/x86/xen/suspend.c
index 45329c8..39e12c1 100644
--- a/arch/x86/xen/suspend.c
+++ b/arch/x86/xen/suspend.c
@@ -30,7 +30,8 @@ void xen_arch_hvm_post_suspend(int suspend_cancelled)
 {
 #ifdef CONFIG_XEN_PVHVM
 	int cpu;
-	xen_hvm_init_shared_info();
+	if (!suspend_cancelled)
+	    xen_hvm_init_shared_info();
 	xen_callback_vector();
 	xen_unplug_emulated_devices();
 	if (xen_feature(XENFEAT_hvm_safe_pvclock)) {
diff --git a/arch/xtensa/Kconfig b/arch/xtensa/Kconfig
index 0a1b95f..c1656c8 100644
--- a/arch/xtensa/Kconfig
+++ b/arch/xtensa/Kconfig
@@ -17,6 +17,7 @@ config XTENSA
 	select CLONE_BACKWARDS
 	select IRQ_DOMAIN
 	select HAVE_OPROFILE
+	select HAVE_FUNCTION_TRACER
 	help
 	  Xtensa processors are 32-bit RISC machines designed by Tensilica
 	  primarily for embedded systems.  These processors are both
@@ -287,6 +288,36 @@ menu "Executable file formats"
 
 source "fs/Kconfig.binfmt"
 
+config XTFPGA_LCD
+	bool "Enable XTFPGA LCD driver"
+	depends on XTENSA_PLATFORM_XTFPGA
+	default n
+	help
+	  There's a 2x16 LCD on most of XTFPGA boards, kernel may output
+	  progress messages there during bootup/shutdown. It may be useful
+	  during board bringup.
+
+	  If unsure, say N.
+
+config XTFPGA_LCD_BASE_ADDR
+	hex "XTFPGA LCD base address"
+	depends on XTFPGA_LCD
+	default "0x0d0c0000"
+	help
+	  Base address of the LCD controller inside KIO region.
+	  Different boards from XTFPGA family have LCD controller at different
+	  addresses. Please consult prototyping user guide for your board for
+	  the correct address. Wrong address here may lead to hardware lockup.
+
+config XTFPGA_LCD_8BIT_ACCESS
+	bool "Use 8-bit access to XTFPGA LCD"
+	depends on XTFPGA_LCD
+	default n
+	help
+	  LCD may be connected with 4- or 8-bit interface, 8-bit access may
+	  only be used with 8-bit interface. Please consult prototyping user
+	  guide for your board for the correct interface width.
+
 endmenu
 
 source "net/Kconfig"
diff --git a/arch/xtensa/Makefile b/arch/xtensa/Makefile
index 136224b..81250ec 100644
--- a/arch/xtensa/Makefile
+++ b/arch/xtensa/Makefile
@@ -55,10 +55,10 @@ ifneq ($(CONFIG_LD_NO_RELAX),)
 LDFLAGS := --no-relax
 endif
 
-ifeq ($(shell echo -e __XTENSA_EB__ | $(CC) -E - | grep -v "\#"),1)
+ifeq ($(shell echo __XTENSA_EB__ | $(CC) -E - | grep -v "\#"),1)
 CHECKFLAGS += -D__XTENSA_EB__
 endif
-ifeq ($(shell echo -e __XTENSA_EL__ | $(CC) -E - | grep -v "\#"),1)
+ifeq ($(shell echo __XTENSA_EL__ | $(CC) -E - | grep -v "\#"),1)
 CHECKFLAGS += -D__XTENSA_EL__
 endif
 
diff --git a/arch/xtensa/boot/Makefile b/arch/xtensa/boot/Makefile
index 64ffc4b..ca20a89 100644
--- a/arch/xtensa/boot/Makefile
+++ b/arch/xtensa/boot/Makefile
@@ -12,7 +12,7 @@
 KBUILD_CFLAGS	+= -fno-builtin -Iarch/$(ARCH)/boot/include
 HOSTFLAGS	+= -Iarch/$(ARCH)/boot/include
 
-BIG_ENDIAN	:= $(shell echo -e __XTENSA_EB__ | $(CC) -E - | grep -v "\#")
+BIG_ENDIAN	:= $(shell echo __XTENSA_EB__ | $(CC) -E - | grep -v "\#")
 
 export ccflags-y
 export BIG_ENDIAN
diff --git a/arch/xtensa/boot/lib/Makefile b/arch/xtensa/boot/lib/Makefile
index ad8952e..6868f2c 100644
--- a/arch/xtensa/boot/lib/Makefile
+++ b/arch/xtensa/boot/lib/Makefile
@@ -7,6 +7,13 @@ zlib	:= inffast.c inflate.c inftrees.c
 lib-y	+= $(zlib:.c=.o) zmem.o
 
 ccflags-y	:= -Ilib/zlib_inflate
+ifdef CONFIG_FUNCTION_TRACER
+CFLAGS_REMOVE_inflate.o = -pg
+CFLAGS_REMOVE_zmem.o = -pg
+CFLAGS_REMOVE_inftrees.o = -pg
+CFLAGS_REMOVE_inffast.o = -pg
+endif
+
 
 quiet_cmd_copy_zlib = COPY    $@
       cmd_copy_zlib = cat $< > $@
diff --git a/arch/xtensa/include/asm/ftrace.h b/arch/xtensa/include/asm/ftrace.h
index 36dc7a6..6c6d9a9 100644
--- a/arch/xtensa/include/asm/ftrace.h
+++ b/arch/xtensa/include/asm/ftrace.h
@@ -12,22 +12,29 @@
 
 #include <asm/processor.h>
 
-#define HAVE_ARCH_CALLER_ADDR
-#define CALLER_ADDR0 ({ unsigned long a0, a1; \
+#ifndef __ASSEMBLY__
+#define ftrace_return_address0 ({ unsigned long a0, a1; \
 		__asm__ __volatile__ ( \
 			"mov %0, a0\n" \
 			"mov %1, a1\n" \
-			: "=r"(a0), "=r"(a1) : : ); \
+			: "=r"(a0), "=r"(a1)); \
 		MAKE_PC_FROM_RA(a0, a1); })
+
 #ifdef CONFIG_FRAME_POINTER
 extern unsigned long return_address(unsigned level);
-#define CALLER_ADDR1 return_address(1)
-#define CALLER_ADDR2 return_address(2)
-#define CALLER_ADDR3 return_address(3)
-#else
-#define CALLER_ADDR1 (0)
-#define CALLER_ADDR2 (0)
-#define CALLER_ADDR3 (0)
+#define ftrace_return_address(n) return_address(n)
 #endif
+#endif /* __ASSEMBLY__ */
+
+#ifdef CONFIG_FUNCTION_TRACER
+
+#define MCOUNT_ADDR ((unsigned long)(_mcount))
+#define MCOUNT_INSN_SIZE 3
+
+#ifndef __ASSEMBLY__
+extern void _mcount(void);
+#define mcount _mcount
+#endif /* __ASSEMBLY__ */
+#endif /* CONFIG_FUNCTION_TRACER */
 
 #endif /* _XTENSA_FTRACE_H */
diff --git a/arch/xtensa/include/asm/traps.h b/arch/xtensa/include/asm/traps.h
index f2faa58..03d02df 100644
--- a/arch/xtensa/include/asm/traps.h
+++ b/arch/xtensa/include/asm/traps.h
@@ -24,30 +24,39 @@ static inline void spill_registers(void)
 {
 #if XCHAL_NUM_AREGS > 16
 	__asm__ __volatile__ (
-		"	call12	1f\n"
+		"	call8	1f\n"
 		"	_j	2f\n"
 		"	retw\n"
 		"	.align	4\n"
 		"1:\n"
+#if XCHAL_NUM_AREGS == 32
+		"	_entry	a1, 32\n"
+		"	addi	a8, a0, 3\n"
+		"	_entry	a1, 16\n"
+		"	mov	a12, a12\n"
+		"	retw\n"
+#else
 		"	_entry	a1, 48\n"
-		"	addi	a12, a0, 3\n"
-#if XCHAL_NUM_AREGS > 32
-		"	.rept	(" __stringify(XCHAL_NUM_AREGS) " - 32) / 12\n"
+		"	call12	1f\n"
+		"	retw\n"
+		"	.align	4\n"
+		"1:\n"
+		"	.rept	(" __stringify(XCHAL_NUM_AREGS) " - 16) / 12\n"
 		"	_entry	a1, 48\n"
 		"	mov	a12, a0\n"
 		"	.endr\n"
-#endif
-		"	_entry	a1, 48\n"
+		"	_entry	a1, 16\n"
 #if XCHAL_NUM_AREGS % 12 == 0
-		"	mov	a8, a8\n"
-#elif XCHAL_NUM_AREGS % 12 == 4
 		"	mov	a12, a12\n"
-#elif XCHAL_NUM_AREGS % 12 == 8
+#elif XCHAL_NUM_AREGS % 12 == 4
 		"	mov	a4, a4\n"
+#elif XCHAL_NUM_AREGS % 12 == 8
+		"	mov	a8, a8\n"
 #endif
 		"	retw\n"
+#endif
 		"2:\n"
-		: : : "a12", "a13", "memory");
+		: : : "a8", "a9", "memory");
 #else
 	__asm__ __volatile__ (
 		"	mov	a12, a12\n"
diff --git a/arch/xtensa/include/uapi/asm/unistd.h b/arch/xtensa/include/uapi/asm/unistd.h
index 513effd..d07c188 100644
--- a/arch/xtensa/include/uapi/asm/unistd.h
+++ b/arch/xtensa/include/uapi/asm/unistd.h
@@ -715,7 +715,7 @@ __SYSCALL(323, sys_process_vm_writev, 6)
 __SYSCALL(324, sys_name_to_handle_at, 5)
 #define __NR_open_by_handle_at			325
 __SYSCALL(325, sys_open_by_handle_at, 3)
-#define __NR_sync_file_range			326
+#define __NR_sync_file_range2			326
 __SYSCALL(326, sys_sync_file_range2, 6)
 #define __NR_perf_event_open			327
 __SYSCALL(327, sys_perf_event_open, 5)
diff --git a/arch/xtensa/kernel/Makefile b/arch/xtensa/kernel/Makefile
index 1e7fc87..f90265e 100644
--- a/arch/xtensa/kernel/Makefile
+++ b/arch/xtensa/kernel/Makefile
@@ -11,6 +11,7 @@ obj-y := align.o coprocessor.o entry.o irq.o pci-dma.o platform.o process.o \
 obj-$(CONFIG_KGDB) += xtensa-stub.o
 obj-$(CONFIG_PCI) += pci.o
 obj-$(CONFIG_MODULES) += xtensa_ksyms.o module.o
+obj-$(CONFIG_FUNCTION_TRACER) += mcount.o
 
 AFLAGS_head.o += -mtext-section-literals
 
diff --git a/arch/xtensa/kernel/entry.S b/arch/xtensa/kernel/entry.S
index 6e53174..b268d3cc 100644
--- a/arch/xtensa/kernel/entry.S
+++ b/arch/xtensa/kernel/entry.S
@@ -549,12 +549,13 @@ user_exception_exit:
 	 *	 (if we have restored WSBITS-1 frames).
 	 */
 
+2:
 #if XCHAL_HAVE_THREADPTR
 	l32i	a3, a1, PT_THREADPTR
 	wur	a3, threadptr
 #endif
 
-2:	j	common_exception_exit
+	j	common_exception_exit
 
 	/* This is the kernel exception exit.
 	 * We avoided to do a MOVSP when we entered the exception, but we
@@ -1933,7 +1934,7 @@ ENDPROC(system_call)
 	mov	a12, a0
 	.endr
 #endif
-	_entry	a1, 48
+	_entry	a1, 16
 #if XCHAL_NUM_AREGS % 12 == 0
 	mov	a8, a8
 #elif XCHAL_NUM_AREGS % 12 == 4
@@ -1957,7 +1958,7 @@ ENDPROC(system_call)
 
 ENTRY(_switch_to)
 
-	entry	a1, 16
+	entry	a1, 48
 
 	mov	a11, a3			# and 'next' (a3)
 
diff --git a/arch/xtensa/kernel/head.S b/arch/xtensa/kernel/head.S
index 7d740eb..bb12d77 100644
--- a/arch/xtensa/kernel/head.S
+++ b/arch/xtensa/kernel/head.S
@@ -118,7 +118,7 @@ ENTRY(_startup)
 	wsr	a0, icountlevel
 
 	.set	_index, 0
-	.rept	XCHAL_NUM_DBREAK - 1
+	.rept	XCHAL_NUM_DBREAK
 	wsr	a0, SREG_DBREAKC + _index
 	.set	_index, _index + 1
 	.endr
diff --git a/arch/xtensa/kernel/mcount.S b/arch/xtensa/kernel/mcount.S
new file mode 100644
index 0000000..0eeda2e
--- /dev/null
+++ b/arch/xtensa/kernel/mcount.S
@@ -0,0 +1,50 @@
+/*
+ * arch/xtensa/kernel/mcount.S
+ *
+ * Xtensa specific mcount support
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2013 Tensilica Inc.
+ */
+
+#include <linux/linkage.h>
+#include <asm/ftrace.h>
+
+/*
+ * Entry condition:
+ *
+ *   a2:	a0 of the caller
+ */
+
+ENTRY(_mcount)
+
+	entry	a1, 16
+
+	movi	a4, ftrace_trace_function
+	l32i	a4, a4, 0
+	movi	a3, ftrace_stub
+	bne	a3, a4, 1f
+	retw
+
+1: 	xor	a7, a2, a1
+	movi	a3, 0x3fffffff
+	and	a7, a7, a3
+	xor	a7, a7, a1
+
+	xor	a6, a0, a1
+	and	a6, a6, a3
+	xor	a6, a6, a1
+	addi	a6, a6, -MCOUNT_INSN_SIZE
+	callx4	a4
+
+	retw
+
+ENDPROC(_mcount)
+
+ENTRY(ftrace_stub)
+	entry	a1, 16
+	retw
+ENDPROC(ftrace_stub)
diff --git a/arch/xtensa/kernel/xtensa_ksyms.c b/arch/xtensa/kernel/xtensa_ksyms.c
index 42c53c87..d8507f8 100644
--- a/arch/xtensa/kernel/xtensa_ksyms.c
+++ b/arch/xtensa/kernel/xtensa_ksyms.c
@@ -124,3 +124,7 @@ extern long common_exception_return;
 extern long _spill_registers;
 EXPORT_SYMBOL(common_exception_return);
 EXPORT_SYMBOL(_spill_registers);
+
+#ifdef CONFIG_FUNCTION_TRACER
+EXPORT_SYMBOL(_mcount);
+#endif
diff --git a/arch/xtensa/mm/fault.c b/arch/xtensa/mm/fault.c
index 70fa7bc..3827833 100644
--- a/arch/xtensa/mm/fault.c
+++ b/arch/xtensa/mm/fault.c
@@ -117,6 +117,8 @@ good_area:
 	if (unlikely(fault & VM_FAULT_ERROR)) {
 		if (fault & VM_FAULT_OOM)
 			goto out_of_memory;
+		else if (fault & VM_FAULT_SIGSEGV)
+			goto bad_area;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
 		BUG();
diff --git a/arch/xtensa/platforms/iss/console.c b/arch/xtensa/platforms/iss/console.c
index 70cb408..92d785f 100644
--- a/arch/xtensa/platforms/iss/console.c
+++ b/arch/xtensa/platforms/iss/console.c
@@ -100,21 +100,23 @@ static void rs_poll(unsigned long priv)
 {
 	struct tty_port *port = (struct tty_port *)priv;
 	int i = 0;
+	int rd = 1;
 	unsigned char c;
 
 	spin_lock(&timer_lock);
 
 	while (simc_poll(0)) {
-		simc_read(0, &c, 1);
+		rd = simc_read(0, &c, 1);
+		if (rd <= 0)
+			break;
 		tty_insert_flip_char(port, c, TTY_NORMAL);
 		i++;
 	}
 
 	if (i)
 		tty_flip_buffer_push(port);
-
-
-	mod_timer(&serial_timer, jiffies + SERIAL_TIMER_VALUE);
+	if (rd)
+		mod_timer(&serial_timer, jiffies + SERIAL_TIMER_VALUE);
 	spin_unlock(&timer_lock);
 }
 
diff --git a/arch/xtensa/platforms/xtfpga/Makefile b/arch/xtensa/platforms/xtfpga/Makefile
index b9ae206..7839d38 100644
--- a/arch/xtensa/platforms/xtfpga/Makefile
+++ b/arch/xtensa/platforms/xtfpga/Makefile
@@ -6,4 +6,5 @@
 #
 # Note 2! The CFLAGS definitions are in the main makefile...
 
-obj-y			= setup.o lcd.o
+obj-y			+= setup.o
+obj-$(CONFIG_XTFPGA_LCD) += lcd.o
diff --git a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h
index 4416773..b39fbcf 100644
--- a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h
+++ b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h
@@ -44,9 +44,6 @@
 
 /* UART */
 #define DUART16552_PADDR	(XCHAL_KIO_PADDR + 0x0D050020)
-/* LCD instruction and data addresses. */
-#define LCD_INSTR_ADDR		((char *)IOADDR(0x0D040000))
-#define LCD_DATA_ADDR		((char *)IOADDR(0x0D040004))
 
 /* Misc. */
 #define XTFPGA_FPGAREGS_VADDR	IOADDR(0x0D020000)
diff --git a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h
index 0e43564..4c8541e 100644
--- a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h
+++ b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h
@@ -11,10 +11,25 @@
 #ifndef __XTENSA_XTAVNET_LCD_H
 #define __XTENSA_XTAVNET_LCD_H
 
+#ifdef CONFIG_XTFPGA_LCD
 /* Display string STR at position POS on the LCD. */
 void lcd_disp_at_pos(char *str, unsigned char pos);
 
 /* Shift the contents of the LCD display left or right. */
 void lcd_shiftleft(void);
 void lcd_shiftright(void);
+#else
+static inline void lcd_disp_at_pos(char *str, unsigned char pos)
+{
+}
+
+static inline void lcd_shiftleft(void)
+{
+}
+
+static inline void lcd_shiftright(void)
+{
+}
+#endif
+
 #endif
diff --git a/arch/xtensa/platforms/xtfpga/lcd.c b/arch/xtensa/platforms/xtfpga/lcd.c
index 2872301..4dc0c1b 100644
--- a/arch/xtensa/platforms/xtfpga/lcd.c
+++ b/arch/xtensa/platforms/xtfpga/lcd.c
@@ -1,50 +1,63 @@
 /*
- * Driver for the LCD display on the Tensilica LX60 Board.
+ * Driver for the LCD display on the Tensilica XTFPGA board family.
+ * http://www.mytechcorp.com/cfdata/productFile/File1/MOC-16216B-B-A0A04.pdf
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
  * Copyright (C) 2001, 2006 Tensilica Inc.
+ * Copyright (C) 2015 Cadence Design Systems Inc.
  */
 
-/*
- *
- * FIXME: this code is from the examples from the LX60 user guide.
- *
- * The lcd_pause function does busy waiting, which is probably not
- * great. Maybe the code could be changed to use kernel timers, or
- * change the hardware to not need to wait.
- */
-
+#include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/io.h>
 
 #include <platform/hardware.h>
 #include <platform/lcd.h>
-#include <linux/delay.h>
 
-#define LCD_PAUSE_ITERATIONS	4000
+/* LCD instruction and data addresses. */
+#define LCD_INSTR_ADDR		((char *)IOADDR(CONFIG_XTFPGA_LCD_BASE_ADDR))
+#define LCD_DATA_ADDR		(LCD_INSTR_ADDR + 4)
+
 #define LCD_CLEAR		0x1
 #define LCD_DISPLAY_ON		0xc
 
 /* 8bit and 2 lines display */
 #define LCD_DISPLAY_MODE8BIT	0x38
+#define LCD_DISPLAY_MODE4BIT	0x28
 #define LCD_DISPLAY_POS		0x80
 #define LCD_SHIFT_LEFT		0x18
 #define LCD_SHIFT_RIGHT		0x1c
 
+static void lcd_put_byte(u8 *addr, u8 data)
+{
+#ifdef CONFIG_XTFPGA_LCD_8BIT_ACCESS
+	ACCESS_ONCE(*addr) = data;
+#else
+	ACCESS_ONCE(*addr) = data & 0xf0;
+	ACCESS_ONCE(*addr) = (data << 4) & 0xf0;
+#endif
+}
+
 static int __init lcd_init(void)
 {
-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;
+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;
 	mdelay(5);
-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;
+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;
 	udelay(200);
-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;
+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;
+	udelay(50);
+#ifndef CONFIG_XTFPGA_LCD_8BIT_ACCESS
+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE4BIT;
+	udelay(50);
+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_MODE4BIT);
 	udelay(50);
-	*LCD_INSTR_ADDR = LCD_DISPLAY_ON;
+#endif
+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_ON);
 	udelay(50);
-	*LCD_INSTR_ADDR = LCD_CLEAR;
+	lcd_put_byte(LCD_INSTR_ADDR, LCD_CLEAR);
 	mdelay(10);
 	lcd_disp_at_pos("XTENSA LINUX", 0);
 	return 0;
@@ -52,10 +65,10 @@ static int __init lcd_init(void)
 
 void lcd_disp_at_pos(char *str, unsigned char pos)
 {
-	*LCD_INSTR_ADDR = LCD_DISPLAY_POS | pos;
+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_POS | pos);
 	udelay(100);
 	while (*str != 0) {
-		*LCD_DATA_ADDR = *str;
+		lcd_put_byte(LCD_DATA_ADDR, *str);
 		udelay(200);
 		str++;
 	}
@@ -63,13 +76,13 @@ void lcd_disp_at_pos(char *str, unsigned char pos)
 
 void lcd_shiftleft(void)
 {
-	*LCD_INSTR_ADDR = LCD_SHIFT_LEFT;
+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_LEFT);
 	udelay(50);
 }
 
 void lcd_shiftright(void)
 {
-	*LCD_INSTR_ADDR = LCD_SHIFT_RIGHT;
+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_RIGHT);
 	udelay(50);
 }
 
diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c
index 1ff8e97..8c4e81a 100644
--- a/block/blk-cgroup.c
+++ b/block/blk-cgroup.c
@@ -720,8 +720,12 @@ int blkg_conf_prep(struct blkcg *blkcg, const struct blkcg_policy *pol,
 		return -EINVAL;
 
 	disk = get_gendisk(MKDEV(major, minor), &part);
-	if (!disk || part)
+	if (!disk)
 		return -EINVAL;
+	if (part) {
+		put_disk(disk);
+		return -EINVAL;
+	}
 
 	rcu_read_lock();
 	spin_lock_irq(disk->queue->queue_lock);
diff --git a/block/blk-core.c b/block/blk-core.c
index 5a750b1..9ae84ae 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -3097,6 +3097,9 @@ int blk_pre_runtime_suspend(struct request_queue *q)
 {
 	int ret = 0;
 
+	if (!q->dev)
+		return ret;
+
 	spin_lock_irq(q->queue_lock);
 	if (q->nr_pending) {
 		ret = -EBUSY;
@@ -3124,6 +3127,9 @@ EXPORT_SYMBOL(blk_pre_runtime_suspend);
  */
 void blk_post_runtime_suspend(struct request_queue *q, int err)
 {
+	if (!q->dev)
+		return;
+
 	spin_lock_irq(q->queue_lock);
 	if (!err) {
 		q->rpm_status = RPM_SUSPENDED;
@@ -3148,6 +3154,9 @@ EXPORT_SYMBOL(blk_post_runtime_suspend);
  */
 void blk_pre_runtime_resume(struct request_queue *q)
 {
+	if (!q->dev)
+		return;
+
 	spin_lock_irq(q->queue_lock);
 	q->rpm_status = RPM_RESUMING;
 	spin_unlock_irq(q->queue_lock);
@@ -3170,6 +3179,9 @@ EXPORT_SYMBOL(blk_pre_runtime_resume);
  */
 void blk_post_runtime_resume(struct request_queue *q, int err)
 {
+	if (!q->dev)
+		return;
+
 	spin_lock_irq(q->queue_lock);
 	if (!err) {
 		q->rpm_status = RPM_ACTIVE;
diff --git a/block/genhd.c b/block/genhd.c
index 7694dff..7af2f6a 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -422,9 +422,9 @@ int blk_alloc_devt(struct hd_struct *part, dev_t *devt)
 	/* allocate ext devt */
 	idr_preload(GFP_KERNEL);
 
-	spin_lock(&ext_devt_lock);
+	spin_lock_bh(&ext_devt_lock);
 	idx = idr_alloc(&ext_devt_idr, part, 0, NR_EXT_DEVT, GFP_NOWAIT);
-	spin_unlock(&ext_devt_lock);
+	spin_unlock_bh(&ext_devt_lock);
 
 	idr_preload_end();
 	if (idx < 0)
@@ -449,9 +449,9 @@ void blk_free_devt(dev_t devt)
 		return;
 
 	if (MAJOR(devt) == BLOCK_EXT_MAJOR) {
-		spin_lock(&ext_devt_lock);
+		spin_lock_bh(&ext_devt_lock);
 		idr_remove(&ext_devt_idr, blk_mangle_minor(MINOR(devt)));
-		spin_unlock(&ext_devt_lock);
+		spin_unlock_bh(&ext_devt_lock);
 	}
 }
 
@@ -691,13 +691,13 @@ struct gendisk *get_gendisk(dev_t devt, int *partno)
 	} else {
 		struct hd_struct *part;
 
-		spin_lock(&ext_devt_lock);
+		spin_lock_bh(&ext_devt_lock);
 		part = idr_find(&ext_devt_idr, blk_mangle_minor(MINOR(devt)));
 		if (part && get_disk(part_to_disk(part))) {
 			*partno = part->partno;
 			disk = part_to_disk(part);
 		}
-		spin_unlock(&ext_devt_lock);
+		spin_unlock_bh(&ext_devt_lock);
 	}
 
 	return disk;
@@ -829,6 +829,7 @@ static void disk_seqf_stop(struct seq_file *seqf, void *v)
 	if (iter) {
 		class_dev_iter_exit(iter);
 		kfree(iter);
+		seqf->private = NULL;
 	}
 }
 
diff --git a/block/partitions/ambptb.c b/block/partitions/ambptb.c
index ca00da1..528482a 100644
--- a/block/partitions/ambptb.c
+++ b/block/partitions/ambptb.c
@@ -24,24 +24,39 @@
 #include "check.h"
 #include "ambptb.h"
 #include <plat/ptb.h>
+#include <linux/of.h>
+
+//#define ambptb_prt
+
+#ifdef ambptb_prt
+#define ambptb_prt printk
+#else
+#define ambptb_prt(format, arg...) do {} while (0)
+#endif
 
 int ambptb_partition(struct parsed_partitions *state)
 {
-	int i;
-	int slot = 1;
+	int i, val, slot = 1;
 	unsigned char *data;
 	Sector sect;
-	u32 sect_size;
-	u32 sect_address;
-	u32 sect_offset;
+	u32 sect_size, sect_offset, sect_address, ptb_address;
 	flpart_meta_t *ptb_meta;
 	char ptb_tmp[1 + BDEVNAME_SIZE + 1];
 	int result = 0;
+	struct device_node * np;
 
 	sect_size = bdev_logical_block_size(state->bdev);
-	sect_address = (2048 + sizeof(flpart_table_t)) / sect_size;
-	sect_offset = sizeof(flpart_table_t) % sect_size;
+	sect_offset = (sizeof(ptb_header_t) + sizeof(flpart_table_t)) % sect_size;
+
+	np = of_find_node_with_property(NULL, "amb,ptb_address");
+	if(!np)
+		return -1;
 
+	val = of_property_read_u32(np, "amb,ptb_address", &ptb_address);
+	if(val < 0)
+		return -1;
+
+	sect_address = (ptb_address * sect_size + sizeof(ptb_header_t) + sizeof(flpart_table_t)) / sect_size;
 	data = read_part_sector(state, sect_address, &sect);
 	if (!data) {
 		result = -1;
@@ -49,12 +64,13 @@ int ambptb_partition(struct parsed_partitions *state)
 	}
 
 	ptb_meta = (flpart_meta_t *)(data + sect_offset);
-	pr_info("%s: magic[0x%08X]\n", __func__, ptb_meta->magic);
+	ambptb_prt("%s: magic[0x%08X]\n", __func__, ptb_meta->magic);
 	if (ptb_meta->magic == PTB_META_MAGIC3) {
 		for (i = 0; i < PART_MAX; i++) {
 			if (slot >= state->limit)
 				break;
-			if (((ptb_meta->part_dev[i] & PART_DEV_EMMC) ==
+
+			if (((ptb_meta->part_info[i].dev & PART_DEV_EMMC) ==
 				PART_DEV_EMMC) &&
 				(ptb_meta->part_info[i].nblk)) {
 				state->parts[slot].from =
@@ -64,7 +80,7 @@ int ambptb_partition(struct parsed_partitions *state)
 				snprintf(ptb_tmp, sizeof(ptb_tmp), " %s",
 					ptb_meta->part_info[i].name);
 				strlcat(state->pp_buf, ptb_tmp, PAGE_SIZE);
-				pr_info("%s: %s [p%d]\n", __func__,
+				ambptb_prt("%s: %s [p%d]\n", __func__,
 					ptb_meta->part_info[i].name, slot);
 				slot++;
 			}
@@ -76,7 +92,7 @@ int ambptb_partition(struct parsed_partitions *state)
 		for (i = 0; i < PART_MAX; i++) {
 			if (slot >= state->limit)
 				break;
-			if ((ptb_meta->part_dev[i] == BOOT_DEV_SM) &&
+			if ((ptb_meta->part_info[i].dev == BOOT_DEV_SM) &&
 				(ptb_meta->part_info[i].nblk)) {
 				state->parts[slot].from =
 					ptb_meta->part_info[i].sblk;
@@ -85,7 +101,7 @@ int ambptb_partition(struct parsed_partitions *state)
 				snprintf(ptb_tmp, sizeof(ptb_tmp), " %s",
 					ptb_meta->part_info[i].name);
 				strlcat(state->pp_buf, ptb_tmp, PAGE_SIZE);
-				pr_info("%s: %s [p%d]\n", __func__,
+				ambptb_prt("%s: %s [p%d]\n", __func__,
 					ptb_meta->part_info[i].name, slot);
 				slot++;
 			}
diff --git a/block/partitions/mac.c b/block/partitions/mac.c
index 76d8ba6..bd5b914 100644
--- a/block/partitions/mac.c
+++ b/block/partitions/mac.c
@@ -32,7 +32,7 @@ int mac_partition(struct parsed_partitions *state)
 	Sector sect;
 	unsigned char *data;
 	int slot, blocks_in_map;
-	unsigned secsize;
+	unsigned secsize, datasize, partoffset;
 #ifdef CONFIG_PPC_PMAC
 	int found_root = 0;
 	int found_root_goodness = 0;
@@ -50,10 +50,14 @@ int mac_partition(struct parsed_partitions *state)
 	}
 	secsize = be16_to_cpu(md->block_size);
 	put_dev_sector(sect);
-	data = read_part_sector(state, secsize/512, &sect);
+	datasize = round_down(secsize, 512);
+	data = read_part_sector(state, datasize / 512, &sect);
 	if (!data)
 		return -1;
-	part = (struct mac_partition *) (data + secsize%512);
+	partoffset = secsize % 512;
+	if (partoffset + sizeof(*part) > datasize)
+		return -1;
+	part = (struct mac_partition *) (data + partoffset);
 	if (be16_to_cpu(part->signature) != MAC_PARTITION_MAGIC) {
 		put_dev_sector(sect);
 		return 0;		/* not a MacOS disk */
diff --git a/crypto/ablkcipher.c b/crypto/ablkcipher.c
index 7d4a8d2..ebcec74 100644
--- a/crypto/ablkcipher.c
+++ b/crypto/ablkcipher.c
@@ -700,7 +700,7 @@ struct crypto_ablkcipher *crypto_alloc_ablkcipher(const char *alg_name,
 err:
 		if (err != -EAGAIN)
 			break;
-		if (signal_pending(current)) {
+		if (fatal_signal_pending(current)) {
 			err = -EINTR;
 			break;
 		}
diff --git a/crypto/af_alg.c b/crypto/af_alg.c
index 6ef6e2a..1aaa555 100644
--- a/crypto/af_alg.c
+++ b/crypto/af_alg.c
@@ -247,10 +247,8 @@ int af_alg_accept(struct sock *sk, struct socket *newsock)
 	security_sk_clone(sk, sk2);
 
 	err = type->accept(ask->private, sk2);
-	if (err) {
-		sk_free(sk2);
+	if (err)
 		goto unlock;
-	}
 
 	sk2->sk_family = PF_ALG;
 
diff --git a/crypto/ahash.c b/crypto/ahash.c
index 793a27f..bcd5efc 100644
--- a/crypto/ahash.c
+++ b/crypto/ahash.c
@@ -64,8 +64,9 @@ static int hash_walk_new_entry(struct crypto_hash_walk *walk)
 	struct scatterlist *sg;
 
 	sg = walk->sg;
-	walk->pg = sg_page(sg);
 	walk->offset = sg->offset;
+	walk->pg = sg_page(walk->sg) + (walk->offset >> PAGE_SHIFT);
+	walk->offset = offset_in_page(walk->offset);
 	walk->entrylen = sg->length;
 
 	if (walk->entrylen > walk->total)
@@ -462,7 +463,8 @@ static int ahash_prepare_alg(struct ahash_alg *alg)
 	struct crypto_alg *base = &alg->halg.base;
 
 	if (alg->halg.digestsize > PAGE_SIZE / 8 ||
-	    alg->halg.statesize > PAGE_SIZE / 8)
+	    alg->halg.statesize > PAGE_SIZE / 8 ||
+	    alg->halg.statesize == 0)
 		return -EINVAL;
 
 	base->cra_type = &crypto_ahash_type;
diff --git a/crypto/algapi.c b/crypto/algapi.c
index 00d8d93..daf2f65 100644
--- a/crypto/algapi.c
+++ b/crypto/algapi.c
@@ -325,7 +325,7 @@ static void crypto_wait_for_test(struct crypto_larval *larval)
 		crypto_alg_tested(larval->alg.cra_driver_name, 0);
 	}
 
-	err = wait_for_completion_interruptible(&larval->completion);
+	err = wait_for_completion_killable(&larval->completion);
 	WARN_ON(err);
 
 out:
diff --git a/crypto/algif_hash.c b/crypto/algif_hash.c
index 8502462..c542c0d8 100644
--- a/crypto/algif_hash.c
+++ b/crypto/algif_hash.c
@@ -51,7 +51,8 @@ static int hash_sendmsg(struct kiocb *unused, struct socket *sock,
 
 	lock_sock(sk);
 	if (!ctx->more) {
-		err = crypto_ahash_init(&ctx->req);
+		err = af_alg_wait_for_completion(crypto_ahash_init(&ctx->req),
+						&ctx->completion);
 		if (err)
 			goto unlock;
 	}
@@ -131,6 +132,7 @@ static ssize_t hash_sendpage(struct socket *sock, struct page *page,
 	} else {
 		if (!ctx->more) {
 			err = crypto_ahash_init(&ctx->req);
+			err = af_alg_wait_for_completion(err, &ctx->completion);
 			if (err)
 				goto unlock;
 		}
@@ -192,9 +194,14 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
 	struct sock *sk2;
 	struct alg_sock *ask2;
 	struct hash_ctx *ctx2;
+	bool more;
 	int err;
 
-	err = crypto_ahash_export(req, state);
+	lock_sock(sk);
+	more = ctx->more;
+	err = more ? crypto_ahash_export(req, state) : 0;
+	release_sock(sk);
+
 	if (err)
 		return err;
 
@@ -205,7 +212,10 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags)
 	sk2 = newsock->sk;
 	ask2 = alg_sk(sk2);
 	ctx2 = ask2->private;
-	ctx2->more = 1;
+	ctx2->more = more;
+
+	if (!more)
+		return err;
 
 	err = crypto_ahash_import(&ctx2->req, state);
 	if (err) {
diff --git a/crypto/api.c b/crypto/api.c
index 335abea..36a0d46 100644
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -172,7 +172,7 @@ static struct crypto_alg *crypto_larval_wait(struct crypto_alg *alg)
 	struct crypto_larval *larval = (void *)alg;
 	long timeout;
 
-	timeout = wait_for_completion_interruptible_timeout(
+	timeout = wait_for_completion_killable_timeout(
 		&larval->completion, 60 * HZ);
 
 	alg = larval->adult;
@@ -435,7 +435,7 @@ struct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask)
 err:
 		if (err != -EAGAIN)
 			break;
-		if (signal_pending(current)) {
+		if (fatal_signal_pending(current)) {
 			err = -EINTR;
 			break;
 		}
@@ -552,7 +552,7 @@ void *crypto_alloc_tfm(const char *alg_name,
 err:
 		if (err != -EAGAIN)
 			break;
-		if (signal_pending(current)) {
+		if (fatal_signal_pending(current)) {
 			err = -EINTR;
 			break;
 		}
diff --git a/crypto/crypto_user.c b/crypto/crypto_user.c
index 43665d0..a3dfc0d 100644
--- a/crypto/crypto_user.c
+++ b/crypto/crypto_user.c
@@ -361,7 +361,7 @@ static struct crypto_alg *crypto_user_aead_alg(const char *name, u32 type,
 		err = PTR_ERR(alg);
 		if (err != -EAGAIN)
 			break;
-		if (signal_pending(current)) {
+		if (fatal_signal_pending(current)) {
 			err = -EINTR;
 			break;
 		}
@@ -477,6 +477,7 @@ static int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		if (link->dump == NULL)
 			return -EINVAL;
 
+		down_read(&crypto_alg_sem);
 		list_for_each_entry(alg, &crypto_alg_list, cra_list)
 			dump_alloc += CRYPTO_REPORT_MAXSIZE;
 
@@ -486,8 +487,11 @@ static int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 				.done = link->done,
 				.min_dump_alloc = dump_alloc,
 			};
-			return netlink_dump_start(crypto_nlsk, skb, nlh, &c);
+			err = netlink_dump_start(crypto_nlsk, skb, nlh, &c);
 		}
+		up_read(&crypto_alg_sem);
+
+		return err;
 	}
 
 	err = nlmsg_parse(nlh, crypto_msg_min[type], attrs, CRYPTOCFGA_MAX,
diff --git a/crypto/gcm.c b/crypto/gcm.c
index b4c2520..451e420 100644
--- a/crypto/gcm.c
+++ b/crypto/gcm.c
@@ -716,7 +716,9 @@ static struct crypto_instance *crypto_gcm_alloc_common(struct rtattr **tb,
 
 	ghash_alg = crypto_find_alg(ghash_name, &crypto_ahash_type,
 				    CRYPTO_ALG_TYPE_HASH,
-				    CRYPTO_ALG_TYPE_AHASH_MASK);
+				    CRYPTO_ALG_TYPE_AHASH_MASK |
+				    crypto_requires_sync(algt->type,
+							 algt->mask));
 	if (IS_ERR(ghash_alg))
 		return ERR_CAST(ghash_alg);
 
@@ -1173,6 +1175,9 @@ static struct aead_request *crypto_rfc4543_crypt(struct aead_request *req,
 	aead_request_set_tfm(subreq, ctx->child);
 	aead_request_set_callback(subreq, req->base.flags, crypto_rfc4543_done,
 				  req);
+	if (!enc)
+		aead_request_set_callback(subreq, req->base.flags,
+					  req->base.complete, req->base.data);
 	aead_request_set_crypt(subreq, cipher, cipher, enc ? 0 : authsize, iv);
 	aead_request_set_assoc(subreq, assoc, assoclen);
 
diff --git a/crypto/scatterwalk.c b/crypto/scatterwalk.c
index 7281b8a..79cbbbf 100644
--- a/crypto/scatterwalk.c
+++ b/crypto/scatterwalk.c
@@ -68,7 +68,8 @@ static void scatterwalk_pagedone(struct scatter_walk *walk, int out,
 
 void scatterwalk_done(struct scatter_walk *walk, int out, int more)
 {
-	if (!(scatterwalk_pagelen(walk) & (PAGE_SIZE - 1)) || !more)
+	if (!more || walk->offset >= walk->sg->offset + walk->sg->length ||
+	    !(walk->offset & (PAGE_SIZE - 1)))
 		scatterwalk_pagedone(walk, out, more);
 }
 EXPORT_SYMBOL_GPL(scatterwalk_done);
diff --git a/drivers/acpi/acpica/acmacros.h b/drivers/acpi/acpica/acmacros.h
index 53666bd..32b0bf3 100644
--- a/drivers/acpi/acpica/acmacros.h
+++ b/drivers/acpi/acpica/acmacros.h
@@ -63,19 +63,15 @@
 #define ACPI_SET64(ptr, val)            (*ACPI_CAST64 (ptr) = (u64) (val))
 
 /*
- * printf() format helpers
+ * printf() format helper. This macros is a workaround for the difficulties
+ * with emitting 64-bit integers and 64-bit pointers with the same code
+ * for both 32-bit and 64-bit hosts.
  */
 
 /* Split 64-bit integer into two 32-bit values. Use with %8.8X%8.8X */
 
 #define ACPI_FORMAT_UINT64(i)           ACPI_HIDWORD(i), ACPI_LODWORD(i)
 
-#if ACPI_MACHINE_WIDTH == 64
-#define ACPI_FORMAT_NATIVE_UINT(i)      ACPI_FORMAT_UINT64(i)
-#else
-#define ACPI_FORMAT_NATIVE_UINT(i)      0, (i)
-#endif
-
 /*
  * Macros for moving data around to/from buffers that are possibly unaligned.
  * If the hardware supports the transfer of unaligned data, just do the store.
diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index a9ffd44..2184259 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -267,6 +267,9 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 				obj_desc->method.mutex->mutex.
 				    original_sync_level =
 				    obj_desc->method.mutex->mutex.sync_level;
+
+				obj_desc->method.mutex->mutex.thread_id =
+				    acpi_os_get_thread_id();
 			}
 		}
 
diff --git a/drivers/acpi/acpica/dsopcode.c b/drivers/acpi/acpica/dsopcode.c
index ee6367b..46a37ae 100644
--- a/drivers/acpi/acpica/dsopcode.c
+++ b/drivers/acpi/acpica/dsopcode.c
@@ -446,7 +446,7 @@ acpi_ds_eval_region_operands(struct acpi_walk_state *walk_state,
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "RgnObj %p Addr %8.8X%8.8X Len %X\n",
 			  obj_desc,
-			  ACPI_FORMAT_NATIVE_UINT(obj_desc->region.address),
+			  ACPI_FORMAT_UINT64(obj_desc->region.address),
 			  obj_desc->region.length));
 
 	/* Now the address and length are valid for this opregion */
@@ -539,13 +539,12 @@ acpi_ds_eval_table_region_operands(struct acpi_walk_state *walk_state,
 		return_ACPI_STATUS(AE_NOT_EXIST);
 	}
 
-	obj_desc->region.address =
-	    (acpi_physical_address) ACPI_TO_INTEGER(table);
+	obj_desc->region.address = ACPI_PTR_TO_PHYSADDR(table);
 	obj_desc->region.length = table->length;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "RgnObj %p Addr %8.8X%8.8X Len %X\n",
 			  obj_desc,
-			  ACPI_FORMAT_NATIVE_UINT(obj_desc->region.address),
+			  ACPI_FORMAT_UINT64(obj_desc->region.address),
 			  obj_desc->region.length));
 
 	/* Now the address and length are valid for this opregion */
diff --git a/drivers/acpi/acpica/evregion.c b/drivers/acpi/acpica/evregion.c
index 8fab926..ad69889 100644
--- a/drivers/acpi/acpica/evregion.c
+++ b/drivers/acpi/acpica/evregion.c
@@ -276,7 +276,7 @@ acpi_ev_address_space_dispatch(union acpi_operand_object *region_obj,
 	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
 			  "Handler %p (@%p) Address %8.8X%8.8X [%s]\n",
 			  &region_obj->region.handler->address_space, handler,
-			  ACPI_FORMAT_NATIVE_UINT(address),
+			  ACPI_FORMAT_UINT64(address),
 			  acpi_ut_get_region_name(region_obj->region.
 						  space_id)));
 
diff --git a/drivers/acpi/acpica/exdump.c b/drivers/acpi/acpica/exdump.c
index e5a3c24..7e6a56f 100644
--- a/drivers/acpi/acpica/exdump.c
+++ b/drivers/acpi/acpica/exdump.c
@@ -621,8 +621,8 @@ void acpi_ex_dump_operand(union acpi_operand_object *obj_desc, u32 depth)
 			acpi_os_printf("\n");
 		} else {
 			acpi_os_printf(" base %8.8X%8.8X Length %X\n",
-				       ACPI_FORMAT_NATIVE_UINT(obj_desc->region.
-							       address),
+				       ACPI_FORMAT_UINT64(obj_desc->region.
+							  address),
 				       obj_desc->region.length);
 		}
 		break;
diff --git a/drivers/acpi/acpica/exfldio.c b/drivers/acpi/acpica/exfldio.c
index c84ee95..dc210c3 100644
--- a/drivers/acpi/acpica/exfldio.c
+++ b/drivers/acpi/acpica/exfldio.c
@@ -269,17 +269,15 @@ acpi_ex_access_region(union acpi_operand_object *obj_desc,
 	}
 
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_BFIELD,
-			      " Region [%s:%X], Width %X, ByteBase %X, Offset %X at %p\n",
+			      " Region [%s:%X], Width %X, ByteBase %X, Offset %X at %8.8X%8.8X\n",
 			      acpi_ut_get_region_name(rgn_desc->region.
 						      space_id),
 			      rgn_desc->region.space_id,
 			      obj_desc->common_field.access_byte_width,
 			      obj_desc->common_field.base_byte_offset,
-			      field_datum_byte_offset, ACPI_CAST_PTR(void,
-								     (rgn_desc->
-								      region.
-								      address +
-								      region_offset))));
+			      field_datum_byte_offset,
+			      ACPI_FORMAT_UINT64(rgn_desc->region.address +
+						 region_offset)));
 
 	/* Invoke the appropriate address_space/op_region handler */
 
diff --git a/drivers/acpi/acpica/exregion.c b/drivers/acpi/acpica/exregion.c
index 182abaf..e90c59d 100644
--- a/drivers/acpi/acpica/exregion.c
+++ b/drivers/acpi/acpica/exregion.c
@@ -176,7 +176,7 @@ acpi_ex_system_memory_space_handler(u32 function,
 		if (!mem_info->mapped_logical_address) {
 			ACPI_ERROR((AE_INFO,
 				    "Could not map memory at 0x%8.8X%8.8X, size %u",
-				    ACPI_FORMAT_NATIVE_UINT(address),
+				    ACPI_FORMAT_UINT64(address),
 				    (u32) map_length));
 			mem_info->mapped_length = 0;
 			return_ACPI_STATUS(AE_NO_MEMORY);
@@ -197,8 +197,7 @@ acpi_ex_system_memory_space_handler(u32 function,
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "System-Memory (width %u) R/W %u Address=%8.8X%8.8X\n",
-			  bit_width, function,
-			  ACPI_FORMAT_NATIVE_UINT(address)));
+			  bit_width, function, ACPI_FORMAT_UINT64(address)));
 
 	/*
 	 * Perform the memory read or write
@@ -300,8 +299,7 @@ acpi_ex_system_io_space_handler(u32 function,
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "System-IO (width %u) R/W %u Address=%8.8X%8.8X\n",
-			  bit_width, function,
-			  ACPI_FORMAT_NATIVE_UINT(address)));
+			  bit_width, function, ACPI_FORMAT_UINT64(address)));
 
 	/* Decode the function parameter */
 
diff --git a/drivers/acpi/acpica/hwvalid.c b/drivers/acpi/acpica/hwvalid.c
index eab70d5..fae5758 100644
--- a/drivers/acpi/acpica/hwvalid.c
+++ b/drivers/acpi/acpica/hwvalid.c
@@ -142,17 +142,17 @@ acpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)
 	byte_width = ACPI_DIV_8(bit_width);
 	last_address = address + byte_width - 1;
 
-	ACPI_DEBUG_PRINT((ACPI_DB_IO, "Address %p LastAddress %p Length %X",
-			  ACPI_CAST_PTR(void, address), ACPI_CAST_PTR(void,
-								      last_address),
-			  byte_width));
+	ACPI_DEBUG_PRINT((ACPI_DB_IO,
+			  "Address %8.8X%8.8X LastAddress %8.8X%8.8X Length %X",
+			  ACPI_FORMAT_UINT64(address),
+			  ACPI_FORMAT_UINT64(last_address), byte_width));
 
 	/* Maximum 16-bit address in I/O space */
 
 	if (last_address > ACPI_UINT16_MAX) {
 		ACPI_ERROR((AE_INFO,
-			    "Illegal I/O port address/length above 64K: %p/0x%X",
-			    ACPI_CAST_PTR(void, address), byte_width));
+			    "Illegal I/O port address/length above 64K: %8.8X%8.8X/0x%X",
+			    ACPI_FORMAT_UINT64(address), byte_width));
 		return_ACPI_STATUS(AE_LIMIT);
 	}
 
@@ -181,8 +181,8 @@ acpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)
 
 			if (acpi_gbl_osi_data >= port_info->osi_dependency) {
 				ACPI_DEBUG_PRINT((ACPI_DB_IO,
-						  "Denied AML access to port 0x%p/%X (%s 0x%.4X-0x%.4X)",
-						  ACPI_CAST_PTR(void, address),
+						  "Denied AML access to port 0x%8.8X%8.8X/%X (%s 0x%.4X-0x%.4X)",
+						  ACPI_FORMAT_UINT64(address),
 						  byte_width, port_info->name,
 						  port_info->start,
 						  port_info->end));
diff --git a/drivers/acpi/acpica/nsdump.c b/drivers/acpi/acpica/nsdump.c
index ce6e973..20ae5b9 100644
--- a/drivers/acpi/acpica/nsdump.c
+++ b/drivers/acpi/acpica/nsdump.c
@@ -258,12 +258,11 @@ acpi_ns_dump_one_object(acpi_handle obj_handle,
 		switch (type) {
 		case ACPI_TYPE_PROCESSOR:
 
-			acpi_os_printf("ID %02X Len %02X Addr %p\n",
+			acpi_os_printf("ID %02X Len %02X Addr %8.8X%8.8X\n",
 				       obj_desc->processor.proc_id,
 				       obj_desc->processor.length,
-				       ACPI_CAST_PTR(void,
-						     obj_desc->processor.
-						     address));
+				       ACPI_FORMAT_UINT64(obj_desc->processor.
+							  address));
 			break;
 
 		case ACPI_TYPE_DEVICE:
@@ -334,8 +333,9 @@ acpi_ns_dump_one_object(acpi_handle obj_handle,
 							       space_id));
 			if (obj_desc->region.flags & AOPOBJ_DATA_VALID) {
 				acpi_os_printf(" Addr %8.8X%8.8X Len %.4X\n",
-					       ACPI_FORMAT_NATIVE_UINT
-					       (obj_desc->region.address),
+					       ACPI_FORMAT_UINT64(obj_desc->
+								  region.
+								  address),
 					       obj_desc->region.length);
 			} else {
 				acpi_os_printf
diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index e57cd38..0d23515 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -301,8 +301,7 @@ struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
 			ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
 					"%4.4s %p Attempted physical table override failed",
 					table_header->signature,
-					ACPI_CAST_PTR(void,
-						      table_desc->address)));
+					ACPI_PHYSADDR_TO_PTR(table_desc->address)));
 			return (NULL);
 		}
 
@@ -318,7 +317,7 @@ struct acpi_table_header *acpi_tb_table_override(struct acpi_table_header
 	ACPI_INFO((AE_INFO,
 		   "%4.4s %p %s table override, new table: %p",
 		   table_header->signature,
-		   ACPI_CAST_PTR(void, table_desc->address),
+		   ACPI_PHYSADDR_TO_PTR(table_desc->address),
 		   override_type, new_table));
 
 	/* We can now unmap/delete the original table (if fully mapped) */
diff --git a/drivers/acpi/acpica/tbutils.c b/drivers/acpi/acpica/tbutils.c
index ce3d5db..5c67b28 100644
--- a/drivers/acpi/acpica/tbutils.c
+++ b/drivers/acpi/acpica/tbutils.c
@@ -246,16 +246,12 @@ acpi_tb_print_table_header(acpi_physical_address address,
 {
 	struct acpi_table_header local_header;
 
-	/*
-	 * The reason that the Address is cast to a void pointer is so that we
-	 * can use %p which will work properly on both 32-bit and 64-bit hosts.
-	 */
 	if (ACPI_COMPARE_NAME(header->signature, ACPI_SIG_FACS)) {
 
 		/* FACS only has signature and length fields */
 
-		ACPI_INFO((AE_INFO, "%4.4s %p %05X",
-			   header->signature, ACPI_CAST_PTR(void, address),
+		ACPI_INFO((AE_INFO, "%4.4s 0x%8.8X%8.8X %05X",
+			   header->signature, ACPI_FORMAT_UINT64(address),
 			   header->length));
 	} else if (ACPI_COMPARE_NAME(header->signature, ACPI_SIG_RSDP)) {
 
@@ -266,8 +262,8 @@ acpi_tb_print_table_header(acpi_physical_address address,
 					  header)->oem_id, ACPI_OEM_ID_SIZE);
 		acpi_tb_fix_string(local_header.oem_id, ACPI_OEM_ID_SIZE);
 
-		ACPI_INFO((AE_INFO, "RSDP %p %05X (v%.2d %6.6s)",
-			   ACPI_CAST_PTR (void, address),
+		ACPI_INFO((AE_INFO, "RSDP 0x%8.8X%8.8X %05X (v%.2d %6.6s)",
+			   ACPI_FORMAT_UINT64(address),
 			   (ACPI_CAST_PTR(struct acpi_table_rsdp, header)->
 			    revision >
 			    0) ? ACPI_CAST_PTR(struct acpi_table_rsdp,
@@ -281,8 +277,8 @@ acpi_tb_print_table_header(acpi_physical_address address,
 		acpi_tb_cleanup_table_header(&local_header, header);
 
 		ACPI_INFO((AE_INFO,
-			   "%4.4s %p %05X (v%.2d %6.6s %8.8s %08X %4.4s %08X)",
-			   local_header.signature, ACPI_CAST_PTR(void, address),
+			   "%-4.4s 0x%8.8X%8.8X %05X (v%.2d %-6.6s %-8.8s %08X %-4.4s %08X)",
+			   local_header.signature, ACPI_FORMAT_UINT64(address),
 			   local_header.length, local_header.revision,
 			   local_header.oem_id, local_header.oem_table_id,
 			   local_header.oem_revision,
@@ -474,8 +470,8 @@ acpi_tb_install_table(acpi_physical_address address,
 	table = acpi_os_map_memory(address, sizeof(struct acpi_table_header));
 	if (!table) {
 		ACPI_ERROR((AE_INFO,
-			    "Could not map memory for table [%s] at %p",
-			    signature, ACPI_CAST_PTR(void, address)));
+			    "Could not map memory for table [%s] at %8.8X%8.8X",
+			    signature, ACPI_FORMAT_UINT64(address)));
 		return;
 	}
 
diff --git a/drivers/acpi/acpica/tbxfroot.c b/drivers/acpi/acpica/tbxfroot.c
index 7c2ecfb..e124860 100644
--- a/drivers/acpi/acpica/tbxfroot.c
+++ b/drivers/acpi/acpica/tbxfroot.c
@@ -118,7 +118,7 @@ static acpi_status acpi_tb_validate_rsdp(struct acpi_table_rsdp *rsdp)
  *
  ******************************************************************************/
 
-acpi_status acpi_find_root_pointer(acpi_size *table_address)
+acpi_status acpi_find_root_pointer(acpi_physical_address * table_address)
 {
 	u8 *table_ptr;
 	u8 *mem_rover;
@@ -176,7 +176,8 @@ acpi_status acpi_find_root_pointer(acpi_size *table_address)
 			physical_address +=
 			    (u32) ACPI_PTR_DIFF(mem_rover, table_ptr);
 
-			*table_address = physical_address;
+			*table_address =
+			    (acpi_physical_address) physical_address;
 			return_ACPI_STATUS(AE_OK);
 		}
 	}
@@ -209,7 +210,7 @@ acpi_status acpi_find_root_pointer(acpi_size *table_address)
 		    (ACPI_HI_RSDP_WINDOW_BASE +
 		     ACPI_PTR_DIFF(mem_rover, table_ptr));
 
-		*table_address = physical_address;
+		*table_address = (acpi_physical_address) physical_address;
 		return_ACPI_STATUS(AE_OK);
 	}
 
diff --git a/drivers/acpi/acpica/utaddress.c b/drivers/acpi/acpica/utaddress.c
index e0a2e27..3c7770d 100644
--- a/drivers/acpi/acpica/utaddress.c
+++ b/drivers/acpi/acpica/utaddress.c
@@ -107,10 +107,10 @@ acpi_ut_add_address_range(acpi_adr_space_type space_id,
 	acpi_gbl_address_range_list[space_id] = range_info;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
-			  "\nAdded [%4.4s] address range: 0x%p-0x%p\n",
+			  "\nAdded [%4.4s] address range: 0x%8.8X%8.8X-0x%8.8X%8.8X\n",
 			  acpi_ut_get_node_name(range_info->region_node),
-			  ACPI_CAST_PTR(void, address),
-			  ACPI_CAST_PTR(void, range_info->end_address)));
+			  ACPI_FORMAT_UINT64(address),
+			  ACPI_FORMAT_UINT64(range_info->end_address)));
 
 	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS(AE_OK);
@@ -160,15 +160,13 @@ acpi_ut_remove_address_range(acpi_adr_space_type space_id,
 			}
 
 			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
-					  "\nRemoved [%4.4s] address range: 0x%p-0x%p\n",
+					  "\nRemoved [%4.4s] address range: 0x%8.8X%8.8X-0x%8.8X%8.8X\n",
 					  acpi_ut_get_node_name(range_info->
 								region_node),
-					  ACPI_CAST_PTR(void,
-							range_info->
-							start_address),
-					  ACPI_CAST_PTR(void,
-							range_info->
-							end_address)));
+					  ACPI_FORMAT_UINT64(range_info->
+							     start_address),
+					  ACPI_FORMAT_UINT64(range_info->
+							     end_address)));
 
 			ACPI_FREE(range_info);
 			return_VOID;
@@ -244,9 +242,9 @@ acpi_ut_check_address_range(acpi_adr_space_type space_id,
 								  region_node);
 
 				ACPI_WARNING((AE_INFO,
-					      "0x%p-0x%p %s conflicts with Region %s %d",
-					      ACPI_CAST_PTR(void, address),
-					      ACPI_CAST_PTR(void, end_address),
+					      "0x%8.8X%8.8X-0x%8.8X%8.8X %s conflicts with Region %s %d",
+					      ACPI_FORMAT_UINT64(address),
+					      ACPI_FORMAT_UINT64(end_address),
 					      acpi_ut_get_region_name(space_id),
 					      pathname, overlap_count));
 				ACPI_FREE(pathname);
diff --git a/drivers/acpi/acpica/utxfinit.c b/drivers/acpi/acpica/utxfinit.c
index 41ebaaf..ee58a62 100644
--- a/drivers/acpi/acpica/utxfinit.c
+++ b/drivers/acpi/acpica/utxfinit.c
@@ -165,10 +165,12 @@ acpi_status acpi_enable_subsystem(u32 flags)
 	 * Obtain a permanent mapping for the FACS. This is required for the
 	 * Global Lock and the Firmware Waking Vector
 	 */
-	status = acpi_tb_initialize_facs();
-	if (ACPI_FAILURE(status)) {
-		ACPI_WARNING((AE_INFO, "Could not map the FACS table"));
-		return_ACPI_STATUS(status);
+	if (!(flags & ACPI_NO_FACS_INIT)) {
+		status = acpi_tb_initialize_facs();
+		if (ACPI_FAILURE(status)) {
+			ACPI_WARNING((AE_INFO, "Could not map the FACS table"));
+			return_ACPI_STATUS(status);
+		}
 	}
 #endif				/* !ACPI_REDUCED_HARDWARE */
 
diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index e721863..11441ad 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -173,7 +173,7 @@ static void __init acpi_request_region (struct acpi_generic_address *gas,
 		request_mem_region(addr, length, desc);
 }
 
-static int __init acpi_reserve_resources(void)
+static void __init acpi_reserve_resources(void)
 {
 	acpi_request_region(&acpi_gbl_FADT.xpm1a_event_block, acpi_gbl_FADT.pm1_event_length,
 		"ACPI PM1a_EVT_BLK");
@@ -202,10 +202,7 @@ static int __init acpi_reserve_resources(void)
 	if (!(acpi_gbl_FADT.gpe1_block_length & 0x1))
 		acpi_request_region(&acpi_gbl_FADT.xgpe1_block,
 			       acpi_gbl_FADT.gpe1_block_length, "ACPI GPE1_BLK");
-
-	return 0;
 }
-device_initcall(acpi_reserve_resources);
 
 void acpi_os_printf(const char *fmt, ...)
 {
@@ -1727,6 +1724,7 @@ acpi_status __init acpi_os_initialize(void)
 
 acpi_status __init acpi_os_initialize1(void)
 {
+	acpi_reserve_resources();
 	kacpid_wq = alloc_workqueue("kacpid", 0, 1);
 	kacpi_notify_wq = alloc_workqueue("kacpi_notify", 0, 1);
 	kacpi_hotplug_wq = alloc_workqueue("kacpi_hotplug", 0, 1);
diff --git a/drivers/acpi/pci_root.c b/drivers/acpi/pci_root.c
index a02a91c..c5e3dd9 100644
--- a/drivers/acpi/pci_root.c
+++ b/drivers/acpi/pci_root.c
@@ -385,6 +385,7 @@ static int acpi_pci_root_add(struct acpi_device *device,
 	int result;
 	struct acpi_pci_root *root;
 	u32 flags, base_flags;
+	bool no_aspm = false, clear_aspm = false;
 
 	root = kzalloc(sizeof(struct acpi_pci_root), GFP_KERNEL);
 	if (!root)
@@ -445,31 +446,10 @@ static int acpi_pci_root_add(struct acpi_device *device,
 	flags = base_flags = OSC_PCI_SEGMENT_GROUPS_SUPPORT;
 	acpi_pci_osc_support(root, flags);
 
-	/*
-	 * TBD: Need PCI interface for enumeration/configuration of roots.
-	 */
-
 	mutex_lock(&acpi_pci_root_lock);
 	list_add_tail(&root->node, &acpi_pci_roots);
 	mutex_unlock(&acpi_pci_root_lock);
 
-	/*
-	 * Scan the Root Bridge
-	 * --------------------
-	 * Must do this prior to any attempt to bind the root device, as the
-	 * PCI namespace does not get created until this call is made (and
-	 * thus the root bridge's pci_dev does not exist).
-	 */
-	root->bus = pci_acpi_scan_root(root);
-	if (!root->bus) {
-		printk(KERN_ERR PREFIX
-			    "Bus %04x:%02x not present in PCI namespace\n",
-			    root->segment, (unsigned int)root->secondary.start);
-		result = -ENODEV;
-		goto out_del_root;
-	}
-
-	/* Indicate support for various _OSC capabilities. */
 	if (pci_ext_cfg_avail())
 		flags |= OSC_EXT_PCI_CONFIG_SUPPORT;
 	if (pcie_aspm_support_enabled()) {
@@ -483,7 +463,7 @@ static int acpi_pci_root_add(struct acpi_device *device,
 		if (ACPI_FAILURE(status)) {
 			dev_info(&device->dev, "ACPI _OSC support "
 				"notification failed, disabling PCIe ASPM\n");
-			pcie_no_aspm();
+			no_aspm = true;
 			flags = base_flags;
 		}
 	}
@@ -515,7 +495,7 @@ static int acpi_pci_root_add(struct acpi_device *device,
 				 * We have ASPM control, but the FADT indicates
 				 * that it's unsupported. Clear it.
 				 */
-				pcie_clear_aspm(root->bus);
+				clear_aspm = true;
 			}
 		} else {
 			dev_info(&device->dev,
@@ -524,7 +504,14 @@ static int acpi_pci_root_add(struct acpi_device *device,
 				acpi_format_exception(status), flags);
 			pr_info("ACPI _OSC control for PCIe not granted, "
 				"disabling ASPM\n");
-			pcie_no_aspm();
+			/*
+			 * We want to disable ASPM here, but aspm_disabled
+			 * needs to remain in its state from boot so that we
+			 * properly handle PCIe 1.1 devices.  So we set this
+			 * flag here, to defer the action until after the ACPI
+			 * root scan.
+			 */
+			no_aspm = true;
 		}
 	} else {
 		dev_info(&device->dev,
@@ -532,6 +519,33 @@ static int acpi_pci_root_add(struct acpi_device *device,
 			 "(_OSC support mask: 0x%02x)\n", flags);
 	}
 
+	/*
+	 * TBD: Need PCI interface for enumeration/configuration of roots.
+	 */
+
+	/*
+	 * Scan the Root Bridge
+	 * --------------------
+	 * Must do this prior to any attempt to bind the root device, as the
+	 * PCI namespace does not get created until this call is made (and
+	 * thus the root bridge's pci_dev does not exist).
+	 */
+	root->bus = pci_acpi_scan_root(root);
+	if (!root->bus) {
+		dev_err(&device->dev,
+			"Bus %04x:%02x not present in PCI namespace\n",
+			root->segment, (unsigned int)root->secondary.start);
+		result = -ENODEV;
+		goto end;
+	}
+
+	if (clear_aspm) {
+		dev_info(&device->dev, "Disabling ASPM (FADT indicates it is unsupported)\n");
+		pcie_clear_aspm(root->bus);
+	}
+	if (no_aspm)
+		pcie_no_aspm();
+
 	pci_acpi_add_bus_pm_notifier(device, root->bus);
 	if (device->wakeup.flags.run_wake)
 		device_set_run_wake(root->bus->bridge, true);
@@ -548,11 +562,6 @@ static int acpi_pci_root_add(struct acpi_device *device,
 	pci_bus_add_devices(root->bus);
 	return 1;
 
-out_del_root:
-	mutex_lock(&acpi_pci_root_lock);
-	list_del(&root->node);
-	mutex_unlock(&acpi_pci_root_lock);
-
 end:
 	kfree(root);
 	return result;
diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
index a888941..c991fe68 100644
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@ -978,7 +978,7 @@ static int acpi_processor_setup_cpuidle_states(struct acpi_processor *pr)
 		return -EINVAL;
 
 	drv->safe_state_index = -1;
-	for (i = 0; i < CPUIDLE_STATE_MAX; i++) {
+	for (i = CPUIDLE_DRIVER_STATE_START; i < CPUIDLE_STATE_MAX; i++) {
 		drv->states[i].name[0] = '\0';
 		drv->states[i].desc[0] = '\0';
 	}
diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index fcae5fa..95b6371 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -492,23 +492,22 @@ static void acpi_global_event_handler(u32 event_type, acpi_handle device,
 static int get_status(u32 index, acpi_event_status *status,
 		      acpi_handle *handle)
 {
-	int result = 0;
+	int result;
 
 	if (index >= num_gpes + ACPI_NUM_FIXED_EVENTS)
-		goto end;
+		return -EINVAL;
 
 	if (index < num_gpes) {
 		result = acpi_get_gpe_device(index, handle);
 		if (result) {
 			ACPI_EXCEPTION((AE_INFO, AE_NOT_FOUND,
 					"Invalid GPE 0x%x", index));
-			goto end;
+			return result;
 		}
 		result = acpi_get_gpe_status(*handle, index, status);
 	} else if (index < (num_gpes + ACPI_NUM_FIXED_EVENTS))
 		result = acpi_get_event_status(index - num_gpes, status);
 
-end:
 	return result;
 }
 
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 9064a2f..cb10693 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -247,6 +247,26 @@ static const struct pci_device_id ahci_pci_tbl[] = {
 	{ PCI_VDEVICE(INTEL, 0x3b2b), board_ahci }, /* PCH RAID */
 	{ PCI_VDEVICE(INTEL, 0x3b2c), board_ahci }, /* PCH RAID */
 	{ PCI_VDEVICE(INTEL, 0x3b2f), board_ahci }, /* PCH AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19b0), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19b1), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19b2), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19b3), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19b4), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19b5), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19b6), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19b7), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19bE), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19bF), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19c0), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19c1), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19c2), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19c3), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19c4), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19c5), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19c6), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19c7), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19cE), board_ahci }, /* DNV AHCI */
+	{ PCI_VDEVICE(INTEL, 0x19cF), board_ahci }, /* DNV AHCI */
 	{ PCI_VDEVICE(INTEL, 0x1c02), board_ahci }, /* CPT AHCI */
 	{ PCI_VDEVICE(INTEL, 0x1c03), board_ahci }, /* CPT AHCI */
 	{ PCI_VDEVICE(INTEL, 0x1c04), board_ahci }, /* CPT RAID */
diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c
index 8905e03..d04f5c8 100644
--- a/drivers/ata/libahci.c
+++ b/drivers/ata/libahci.c
@@ -486,8 +486,8 @@ void ahci_save_initial_config(struct device *dev,
 		}
 	}
 
-	/* fabricate port_map from cap.nr_ports */
-	if (!port_map) {
+	/* fabricate port_map from cap.nr_ports for < AHCI 1.3 */
+	if (!port_map && vers < 0x10300) {
 		port_map = (1 << ahci_nr_ports(cap)) - 1;
 		dev_warn(dev, "forcing PORTS_IMPL to 0x%x\n", port_map);
 
@@ -1244,6 +1244,15 @@ static int ahci_exec_polled_cmd(struct ata_port *ap, int pmp,
 	ata_tf_to_fis(tf, pmp, is_cmd, fis);
 	ahci_fill_cmd_slot(pp, 0, cmd_fis_len | flags | (pmp << 12));
 
+	/* set port value for softreset of Port Multiplier */
+	if (pp->fbs_enabled && pp->fbs_last_dev != pmp) {
+		tmp = readl(port_mmio + PORT_FBS);
+		tmp &= ~(PORT_FBS_DEV_MASK | PORT_FBS_DEC);
+		tmp |= pmp << PORT_FBS_DEV_OFFSET;
+		writel(tmp, port_mmio + PORT_FBS);
+		pp->fbs_last_dev = pmp;
+	}
+
 	/* issue & wait */
 	writel(1, port_mmio + PORT_CMD_ISSUE);
 
@@ -1684,8 +1693,7 @@ static void ahci_handle_port_interrupt(struct ata_port *ap,
 	if (unlikely(resetting))
 		status &= ~PORT_IRQ_BAD_PMP;
 
-	/* if LPM is enabled, PHYRDY doesn't mean anything */
-	if (ap->link.lpm_policy > ATA_LPM_MAX_POWER) {
+	if (sata_lpm_ignore_phy_events(&ap->link)) {
 		status &= ~PORT_IRQ_PHYRDY;
 		ahci_scr_write(&ap->link, SCR_ERROR, SERR_PHYRDY_CHG);
 	}
diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c
index ca7c23d..53d35b6 100644
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -4150,9 +4150,10 @@ static const struct ata_blacklist_entry ata_device_blacklist [] = {
 	{ "ST3320[68]13AS",	"SD1[5-9]",	ATA_HORKAGE_NONCQ |
 						ATA_HORKAGE_FIRMWARE_WARN },
 
-	/* Seagate Momentus SpinPoint M8 seem to have FPMDA_AA issues */
+	/* drives which fail FPDMA_AA activation (some may freeze afterwards) */
 	{ "ST1000LM024 HN-M101MBB", "2AR10001",	ATA_HORKAGE_BROKEN_FPDMA_AA },
 	{ "ST1000LM024 HN-M101MBB", "2BA30001",	ATA_HORKAGE_BROKEN_FPDMA_AA },
+	{ "VB0250EAVER",	"HPG7",		ATA_HORKAGE_BROKEN_FPDMA_AA },
 
 	/* Blacklist entries taken from Silicon Image 3124/3132
 	   Windows driver .inf file - also several Linux problem reports */
@@ -4200,6 +4201,9 @@ static const struct ata_blacklist_entry ata_device_blacklist [] = {
 	{ "PIONEER DVD-RW  DVR-212D",	NULL,	ATA_HORKAGE_NOSETXFER },
 	{ "PIONEER DVD-RW  DVR-216D",	NULL,	ATA_HORKAGE_NOSETXFER },
 
+	/* devices that don't properly handle TRIM commands */
+	{ "SuperSSpeed S238*",		NULL,	ATA_HORKAGE_NOTRIM, },
+
 	/*
 	 * Some WD SATA-I drives spin up and down erratically when the link
 	 * is put into the slumber mode.  We don't have full list of the
@@ -4504,7 +4508,8 @@ static unsigned int ata_dev_set_xfermode(struct ata_device *dev)
 	else /* In the ancient relic department - skip all of this */
 		return 0;
 
-	err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);
+	/* On some disks, this command causes spin-up, so we need longer timeout */
+	err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 15000);
 
 	DPRINTK("EXIT, err_mask=%x\n", err_mask);
 	return err_mask;
@@ -6800,6 +6805,38 @@ u32 ata_wait_register(struct ata_port *ap, void __iomem *reg, u32 mask, u32 val,
 	return tmp;
 }
 
+/**
+ *	sata_lpm_ignore_phy_events - test if PHY event should be ignored
+ *	@link: Link receiving the event
+ *
+ *	Test whether the received PHY event has to be ignored or not.
+ *
+ *	LOCKING:
+ *	None:
+ *
+ *	RETURNS:
+ *	True if the event has to be ignored.
+ */
+bool sata_lpm_ignore_phy_events(struct ata_link *link)
+{
+	unsigned long lpm_timeout = link->last_lpm_change +
+				    msecs_to_jiffies(ATA_TMOUT_SPURIOUS_PHY);
+
+	/* if LPM is enabled, PHYRDY doesn't mean anything */
+	if (link->lpm_policy > ATA_LPM_MAX_POWER)
+		return true;
+
+	/* ignore the first PHY event after the LPM policy changed
+	 * as it is might be spurious
+	 */
+	if ((link->flags & ATA_LFLAG_CHANGED) &&
+	    time_before(jiffies, lpm_timeout))
+		return true;
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(sata_lpm_ignore_phy_events);
+
 /*
  * Dummy port_ops
  */
diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c
index 370462f..126eb86 100644
--- a/drivers/ata/libata-eh.c
+++ b/drivers/ata/libata-eh.c
@@ -604,7 +604,7 @@ void ata_scsi_error(struct Scsi_Host *host)
 	ata_scsi_port_error_handler(host, ap);
 
 	/* finish or retry handled scmd's and clean up */
-	WARN_ON(host->host_failed || !list_empty(&eh_work_q));
+	WARN_ON(!list_empty(&eh_work_q));
 
 	DPRINTK("EXIT\n");
 }
@@ -3481,6 +3481,9 @@ static int ata_eh_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,
 		}
 	}
 
+	link->last_lpm_change = jiffies;
+	link->flags |= ATA_LFLAG_CHANGED;
+
 	return 0;
 
 fail:
diff --git a/drivers/ata/libata-pmp.c b/drivers/ata/libata-pmp.c
index 7ccc084..85aa761 100644
--- a/drivers/ata/libata-pmp.c
+++ b/drivers/ata/libata-pmp.c
@@ -460,6 +460,13 @@ static void sata_pmp_quirks(struct ata_port *ap)
 				       ATA_LFLAG_NO_SRST |
 				       ATA_LFLAG_ASSUME_ATA;
 		}
+	} else if (vendor == 0x11ab && devid == 0x4140) {
+		/* Marvell 4140 quirks */
+		ata_for_each_link(link, ap, EDGE) {
+			/* port 4 is for SEMB device and it doesn't like SRST */
+			if (link->pmp == 4)
+				link->flags |= ATA_LFLAG_DISABLED;
+		}
 	}
 }
 
diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c
index 9933b4d..f3f0801 100644
--- a/drivers/ata/libata-scsi.c
+++ b/drivers/ata/libata-scsi.c
@@ -673,19 +673,18 @@ static int ata_ioc32(struct ata_port *ap)
 int ata_sas_scsi_ioctl(struct ata_port *ap, struct scsi_device *scsidev,
 		     int cmd, void __user *arg)
 {
-	int val = -EINVAL, rc = -EINVAL;
+	unsigned long val;
+	int rc = -EINVAL;
 	unsigned long flags;
 
 	switch (cmd) {
-	case ATA_IOC_GET_IO32:
+	case HDIO_GET_32BIT:
 		spin_lock_irqsave(ap->lock, flags);
 		val = ata_ioc32(ap);
 		spin_unlock_irqrestore(ap->lock, flags);
-		if (copy_to_user(arg, &val, 1))
-			return -EFAULT;
-		return 0;
+		return put_user(val, (unsigned long __user *)arg);
 
-	case ATA_IOC_SET_IO32:
+	case HDIO_SET_32BIT:
 		val = (unsigned long) arg;
 		rc = 0;
 		spin_lock_irqsave(ap->lock, flags);
@@ -2512,7 +2511,8 @@ static unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf)
 		rbuf[14] = (lowest_aligned >> 8) & 0x3f;
 		rbuf[15] = lowest_aligned;
 
-		if (ata_id_has_trim(args->id)) {
+		if (ata_id_has_trim(args->id) &&
+		    !(dev->horkage & ATA_HORKAGE_NOTRIM)) {
 			rbuf[14] |= 0x80; /* TPE */
 
 			if (ata_id_has_zero_after_trim(args->id))
diff --git a/drivers/ata/libata-sff.c b/drivers/ata/libata-sff.c
index 136803c..96e5ed1 100644
--- a/drivers/ata/libata-sff.c
+++ b/drivers/ata/libata-sff.c
@@ -997,12 +997,9 @@ static inline int ata_hsm_ok_in_wq(struct ata_port *ap,
 static void ata_hsm_qc_complete(struct ata_queued_cmd *qc, int in_wq)
 {
 	struct ata_port *ap = qc->ap;
-	unsigned long flags;
 
 	if (ap->ops->error_handler) {
 		if (in_wq) {
-			spin_lock_irqsave(ap->lock, flags);
-
 			/* EH might have kicked in while host lock is
 			 * released.
 			 */
@@ -1014,8 +1011,6 @@ static void ata_hsm_qc_complete(struct ata_queued_cmd *qc, int in_wq)
 				} else
 					ata_port_freeze(ap);
 			}
-
-			spin_unlock_irqrestore(ap->lock, flags);
 		} else {
 			if (likely(!(qc->err_mask & AC_ERR_HSM)))
 				ata_qc_complete(qc);
@@ -1024,10 +1019,8 @@ static void ata_hsm_qc_complete(struct ata_queued_cmd *qc, int in_wq)
 		}
 	} else {
 		if (in_wq) {
-			spin_lock_irqsave(ap->lock, flags);
 			ata_sff_irq_on(ap);
 			ata_qc_complete(qc);
-			spin_unlock_irqrestore(ap->lock, flags);
 		} else
 			ata_qc_complete(qc);
 	}
@@ -1048,9 +1041,10 @@ int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
 {
 	struct ata_link *link = qc->dev->link;
 	struct ata_eh_info *ehi = &link->eh_info;
-	unsigned long flags = 0;
 	int poll_next;
 
+	lockdep_assert_held(ap->lock);
+
 	WARN_ON_ONCE((qc->flags & ATA_QCFLAG_ACTIVE) == 0);
 
 	/* Make sure ata_sff_qc_issue() does not throw things
@@ -1112,14 +1106,6 @@ fsm_start:
 			}
 		}
 
-		/* Send the CDB (atapi) or the first data block (ata pio out).
-		 * During the state transition, interrupt handler shouldn't
-		 * be invoked before the data transfer is complete and
-		 * hsm_task_state is changed. Hence, the following locking.
-		 */
-		if (in_wq)
-			spin_lock_irqsave(ap->lock, flags);
-
 		if (qc->tf.protocol == ATA_PROT_PIO) {
 			/* PIO data out protocol.
 			 * send first data block.
@@ -1135,9 +1121,6 @@ fsm_start:
 			/* send CDB */
 			atapi_send_cdb(ap, qc);
 
-		if (in_wq)
-			spin_unlock_irqrestore(ap->lock, flags);
-
 		/* if polling, ata_sff_pio_task() handles the rest.
 		 * otherwise, interrupt handler takes over from here.
 		 */
@@ -1361,12 +1344,14 @@ static void ata_sff_pio_task(struct work_struct *work)
 	u8 status;
 	int poll_next;
 
+	spin_lock_irq(ap->lock);
+
 	BUG_ON(ap->sff_pio_task_link == NULL);
 	/* qc can be NULL if timeout occurred */
 	qc = ata_qc_from_tag(ap, link->active_tag);
 	if (!qc) {
 		ap->sff_pio_task_link = NULL;
-		return;
+		goto out_unlock;
 	}
 
 fsm_start:
@@ -1381,11 +1366,14 @@ fsm_start:
 	 */
 	status = ata_sff_busy_wait(ap, ATA_BUSY, 5);
 	if (status & ATA_BUSY) {
+		spin_unlock_irq(ap->lock);
 		ata_msleep(ap, 2);
+		spin_lock_irq(ap->lock);
+
 		status = ata_sff_busy_wait(ap, ATA_BUSY, 10);
 		if (status & ATA_BUSY) {
 			ata_sff_queue_pio_task(link, ATA_SHORT_PAUSE);
-			return;
+			goto out_unlock;
 		}
 	}
 
@@ -1402,6 +1390,8 @@ fsm_start:
 	 */
 	if (poll_next)
 		goto fsm_start;
+out_unlock:
+	spin_unlock_irq(ap->lock);
 }
 
 /**
diff --git a/drivers/ata/pata_octeon_cf.c b/drivers/ata/pata_octeon_cf.c
index e73bef3..5507f36 100644
--- a/drivers/ata/pata_octeon_cf.c
+++ b/drivers/ata/pata_octeon_cf.c
@@ -1068,7 +1068,7 @@ static struct of_device_id octeon_cf_match[] = {
 	},
 	{},
 };
-MODULE_DEVICE_TABLE(of, octeon_i2c_match);
+MODULE_DEVICE_TABLE(of, octeon_cf_match);
 
 static struct platform_driver octeon_cf_driver = {
 	.probe		= octeon_cf_probe,
diff --git a/drivers/ata/sata_sil.c b/drivers/ata/sata_sil.c
index dd1faa5..cdfb98e 100644
--- a/drivers/ata/sata_sil.c
+++ b/drivers/ata/sata_sil.c
@@ -631,6 +631,9 @@ static void sil_dev_config(struct ata_device *dev)
 	unsigned int n, quirks = 0;
 	unsigned char model_num[ATA_ID_PROD_LEN + 1];
 
+	/* This controller doesn't support trim */
+	dev->horkage |= ATA_HORKAGE_NOTRIM;
+
 	ata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));
 
 	for (n = 0; sil_blacklist[n].product; n++)
diff --git a/drivers/auxdisplay/ks0108.c b/drivers/auxdisplay/ks0108.c
index 5b93852..0d75285 100644
--- a/drivers/auxdisplay/ks0108.c
+++ b/drivers/auxdisplay/ks0108.c
@@ -139,6 +139,7 @@ static int __init ks0108_init(void)
 
 	ks0108_pardevice = parport_register_device(ks0108_parport, KS0108_NAME,
 		NULL, NULL, NULL, PARPORT_DEV_EXCL, NULL);
+	parport_put_port(ks0108_parport);
 	if (ks0108_pardevice == NULL) {
 		printk(KERN_ERR KS0108_NAME ": ERROR: "
 			"parport didn't register new device\n");
diff --git a/drivers/base/ambpriv.c b/drivers/base/ambpriv.c
index 9ffc879..135b631 100644
--- a/drivers/base/ambpriv.c
+++ b/drivers/base/ambpriv.c
@@ -13,6 +13,10 @@
 #include <linux/err.h>
 #include <linux/pm_runtime.h>
 #include <linux/ambpriv_device.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
 #include "base.h"
 
 #define to_ambpriv_driver(drv)	(container_of((drv), struct ambpriv_driver, driver))
@@ -21,6 +25,202 @@ struct device ambpriv_bus = {
 	.init_name	= "ambpriv",
 };
 
+static int of_ambpriv_match_device(struct device *dev, void *match)
+{
+	return !!of_match_device(match, dev);
+}
+
+struct ambpriv_device *of_find_ambpriv_device_by_match(struct of_device_id *match)
+{
+	struct device *dev;
+
+	dev = bus_find_device(&ambpriv_bus_type, NULL, match, of_ambpriv_match_device);
+	return dev ? to_ambpriv_device(dev) : NULL;
+}
+EXPORT_SYMBOL(of_find_ambpriv_device_by_match);
+
+static int of_ambpriv_node_device(struct device *dev, void *data)
+{
+	return dev->of_node == data;
+}
+
+struct ambpriv_device *of_find_ambpriv_device_by_node(struct device_node *np)
+{
+	struct device *dev;
+
+	dev = bus_find_device(&ambpriv_bus_type, NULL, np, of_ambpriv_node_device);
+	return dev ? to_ambpriv_device(dev) : NULL;
+}
+EXPORT_SYMBOL(of_find_ambpriv_device_by_node);
+
+int ambpriv_get_irq(struct ambpriv_device *dev, unsigned int num)
+{
+	struct resource *r = NULL;
+	int i;
+
+	if (dev == NULL)
+		return -ENODEV;
+
+	for (i = 0; i < dev->num_resources; i++) {
+		r = &dev->resource[i];
+		if ((resource_type(r) == IORESOURCE_IRQ) && num-- == 0)
+			break;
+	}
+
+	if (i == dev->num_resources)
+		return -ENXIO;
+
+	if (r && r->flags & IORESOURCE_BITS)
+		irqd_set_trigger_type(irq_get_irq_data(r->start),
+				      r->flags & IORESOURCE_BITS);
+
+	return r->start;
+}
+EXPORT_SYMBOL(ambpriv_get_irq);
+
+int ambpriv_get_irq_by_name(struct ambpriv_device *dev, const char *name)
+{
+	struct resource *r = NULL;
+	int i;
+
+	if (dev == NULL)
+		return -ENODEV;
+
+	for (i = 0; i < dev->num_resources; i++) {
+		r = &dev->resource[i];
+
+		if (unlikely(!r->name))
+			continue;
+
+		if ((resource_type(r) == IORESOURCE_IRQ) && !strcmp(r->name, name))
+			break;
+	}
+
+	if (i == dev->num_resources)
+		return -ENXIO;
+
+	return r->start;
+}
+EXPORT_SYMBOL(ambpriv_get_irq_by_name);
+
+static struct ambpriv_device *of_ambpriv_device_alloc(struct device_node *np,
+		struct device *parent)
+{
+	struct ambpriv_device *dev;
+	const __be32 *reg_prop;
+	struct resource *res;
+	int psize, i, num_reg = 0, num_irq;
+
+	dev = ambpriv_device_alloc("", -1);
+	if (!dev)
+		return NULL;
+
+	reg_prop = of_get_property(np, "reg", &psize);
+	if (reg_prop)
+		num_reg = psize / sizeof(u32) / 2;
+
+
+	num_irq = of_irq_count(np);
+
+	if (num_reg || num_irq) {
+		res = kzalloc(sizeof(*res) * (num_irq + num_reg), GFP_KERNEL);
+		if (!res) {
+			ambpriv_device_put(dev);
+			return NULL;
+		}
+
+		dev->resource = res;
+		dev->num_resources = num_reg + num_irq;
+
+		for (i = 0; i < num_reg; i++, res++, reg_prop += 2) {
+			res->start = be32_to_cpup(reg_prop);
+			res->end = res->start + be32_to_cpup(reg_prop + 1) - 1;
+			res->flags = IORESOURCE_MEM;
+		}
+
+		of_irq_to_resource_table(np, res, num_irq);
+	}
+
+	dev->dev.of_node = of_node_get(np);
+	dev->dev.parent = parent ? : &ambpriv_bus;
+	of_device_make_bus_id(&dev->dev);
+	dev->name = dev_name(&dev->dev);
+
+	return dev;
+}
+
+static struct ambpriv_device *of_ambpriv_device_create_pdata(
+		struct device_node *np, struct device *parent)
+{
+	struct ambpriv_device *dev;
+
+	dev = of_ambpriv_device_alloc(np, parent);
+	if (!dev)
+		return NULL;
+
+	if (ambpriv_device_add(dev) < 0) {
+		ambpriv_device_put(dev);
+		return NULL;
+	}
+
+	return dev;
+}
+
+static int of_ambpriv_bus_create(struct device_node *bus,
+		const struct of_device_id *matches, struct device *parent)
+{
+	struct device_node *child;
+	struct ambpriv_device *dev;
+	int rc = 0;
+
+	/* Make sure it has a compatible property */
+	if (!of_get_property(bus, "compatible", NULL))
+		return 0;
+
+	dev = of_ambpriv_device_create_pdata(bus, parent);
+	if (!dev || !of_match_node(matches, bus))
+		return 0;
+
+	for_each_child_of_node(bus, child) {
+		rc = of_ambpriv_bus_create(child, matches, &dev->dev);
+		if (rc) {
+			of_node_put(child);
+			break;
+		}
+	}
+
+	return rc;
+}
+
+static const struct of_device_id of_ambpriv_bus_match_table[] = {
+	{ .compatible = "ambpriv-bus", },
+	{} /* Empty terminated list */
+};
+
+static int __init of_ambpriv_populate(void)
+{
+	struct device_node *root, *child;
+	int rval;
+
+	root = of_find_node_by_path("/iav");
+	if (!root)
+		return -EINVAL;
+
+	for_each_child_of_node(root, child) {
+		rval = of_ambpriv_bus_create(child, of_ambpriv_bus_match_table, NULL);
+		if (rval) {
+			of_node_put(child);
+			break;
+		}
+	}
+
+	of_node_put(root);
+
+	return 0;
+}
+late_initcall(of_ambpriv_populate);
+
+
 int ambpriv_add_devices(struct ambpriv_device **devs, int num)
 {
 	int i, ret = 0;
@@ -256,6 +456,11 @@ struct ambpriv_device * __init_or_module ambpriv_create_bundle(
 	struct ambpriv_device *ambdev;
 	int error;
 
+	ambdev = of_find_ambpriv_device_by_match(
+			(struct of_device_id *)driver->driver.of_match_table);
+	if (ambdev)
+		goto register_drv;
+
 	ambdev = ambpriv_device_alloc(driver->driver.name, -1);
 	if (!ambdev) {
 		error = -ENOMEM;
@@ -274,6 +479,7 @@ struct ambpriv_device * __init_or_module ambpriv_create_bundle(
 	if (error)
 		goto err_pdev_put;
 
+register_drv:
 	error = ambpriv_driver_register(driver);
 	if (error)
 		goto err_pdev_del;
@@ -292,6 +498,10 @@ EXPORT_SYMBOL(ambpriv_create_bundle);
 static int ambpriv_match(struct device *dev, struct device_driver *drv)
 {
 	struct ambpriv_device *ambdev = to_ambpriv_device(dev);
+
+	if (of_driver_match_device(dev, drv))
+		return 1;
+
 	return (strcmp(ambdev->name, drv->name) == 0);
 }
 
diff --git a/drivers/base/devres.c b/drivers/base/devres.c
index 507379e..4e2fb40 100644
--- a/drivers/base/devres.c
+++ b/drivers/base/devres.c
@@ -296,10 +296,10 @@ void * devres_get(struct device *dev, void *new_res,
 	if (!dr) {
 		add_dr(dev, &new_dr->node);
 		dr = new_dr;
-		new_dr = NULL;
+		new_res = NULL;
 	}
 	spin_unlock_irqrestore(&dev->devres_lock, flags);
-	devres_free(new_dr);
+	devres_free(new_res);
 
 	return dr->data;
 }
diff --git a/drivers/base/firmware_class.c b/drivers/base/firmware_class.c
index 00a5656..8e08fab 100644
--- a/drivers/base/firmware_class.c
+++ b/drivers/base/firmware_class.c
@@ -513,10 +513,8 @@ static void fw_dev_release(struct device *dev)
 	module_put(THIS_MODULE);
 }
 
-static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int do_firmware_uevent(struct firmware_priv *fw_priv, struct kobj_uevent_env *env)
 {
-	struct firmware_priv *fw_priv = to_firmware_priv(dev);
-
 	if (add_uevent_var(env, "FIRMWARE=%s", fw_priv->buf->fw_id))
 		return -ENOMEM;
 	if (add_uevent_var(env, "TIMEOUT=%i", loading_timeout))
@@ -527,6 +525,18 @@ static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct firmware_priv *fw_priv = to_firmware_priv(dev);
+	int err = 0;
+
+	mutex_lock(&fw_lock);
+	if (fw_priv->buf)
+		err = do_firmware_uevent(fw_priv, env);
+	mutex_unlock(&fw_lock);
+	return err;
+}
+
 static struct class firmware_class = {
 	.name		= "firmware",
 	.class_attrs	= firmware_class_attrs,
diff --git a/drivers/base/module.c b/drivers/base/module.c
index db930d3..2a21578 100644
--- a/drivers/base/module.c
+++ b/drivers/base/module.c
@@ -24,10 +24,12 @@ static char *make_driver_name(struct device_driver *drv)
 
 static void module_create_drivers_dir(struct module_kobject *mk)
 {
-	if (!mk || mk->drivers_dir)
-		return;
+	static DEFINE_MUTEX(drivers_dir_mutex);
 
-	mk->drivers_dir = kobject_create_and_add("drivers", &mk->kobj);
+	mutex_lock(&drivers_dir_mutex);
+	if (mk && !mk->drivers_dir)
+		mk->drivers_dir = kobject_create_and_add("drivers", &mk->kobj);
+	mutex_unlock(&drivers_dir_mutex);
 }
 
 void module_add_driver(struct module *mod, struct device_driver *drv)
diff --git a/drivers/base/platform.c b/drivers/base/platform.c
index 9eda842..8717be5 100644
--- a/drivers/base/platform.c
+++ b/drivers/base/platform.c
@@ -347,9 +347,7 @@ int platform_device_add(struct platform_device *pdev)
 
 	while (--i >= 0) {
 		struct resource *r = &pdev->resource[i];
-		unsigned long type = resource_type(r);
-
-		if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
+		if (r->parent)
 			release_resource(r);
 	}
 
@@ -380,9 +378,7 @@ void platform_device_del(struct platform_device *pdev)
 
 		for (i = 0; i < pdev->num_resources; i++) {
 			struct resource *r = &pdev->resource[i];
-			unsigned long type = resource_type(r);
-
-			if (type == IORESOURCE_MEM || type == IORESOURCE_IO)
+			if (r->parent)
 				release_resource(r);
 		}
 	}
diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
index b41994f..2670beb 100644
--- a/drivers/base/regmap/regmap-debugfs.c
+++ b/drivers/base/regmap/regmap-debugfs.c
@@ -23,8 +23,7 @@ static struct dentry *regmap_debugfs_root;
 /* Calculate the length of a fixed format  */
 static size_t regmap_calc_reg_len(int max_val, char *buf, size_t buf_size)
 {
-	snprintf(buf, buf_size, "%x", max_val);
-	return strlen(buf);
+	return snprintf(NULL, 0, "%x", max_val);
 }
 
 static ssize_t regmap_name_read_file(struct file *file,
@@ -419,7 +418,7 @@ static ssize_t regmap_access_read_file(struct file *file,
 		/* If we're in the region the user is trying to read */
 		if (p >= *ppos) {
 			/* ...but not beyond it */
-			if (buf_pos >= count - 1 - tot_len)
+			if (buf_pos + tot_len + 1 >= count)
 				break;
 
 			/* Format the register */
diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c
index 6a66f0b..4f3d70a 100644
--- a/drivers/base/regmap/regmap.c
+++ b/drivers/base/regmap/regmap.c
@@ -1586,7 +1586,7 @@ int regmap_bulk_read(struct regmap *map, unsigned int reg, void *val,
 					  &ival);
 			if (ret != 0)
 				return ret;
-			memcpy(val + (i * val_bytes), &ival, val_bytes);
+			map->format.format_val(val + (i * val_bytes), ival, 0);
 		}
 	}
 
diff --git a/drivers/block/nbd.c b/drivers/block/nbd.c
index cf1576d..d593fa5 100644
--- a/drivers/block/nbd.c
+++ b/drivers/block/nbd.c
@@ -581,8 +581,8 @@ static void do_nbd_request(struct request_queue *q)
 		BUG_ON(nbd->magic != NBD_MAGIC);
 
 		if (unlikely(!nbd->sock)) {
-			dev_err(disk_to_dev(nbd->disk),
-				"Attempted send on closed socket\n");
+			dev_err_ratelimited(disk_to_dev(nbd->disk),
+					    "Attempted send on closed socket\n");
 			req->errors++;
 			nbd_end_request(req);
 			spin_lock_irq(q->queue_lock);
@@ -815,10 +815,6 @@ static int __init nbd_init(void)
 		return -EINVAL;
 	}
 
-	nbd_dev = kcalloc(nbds_max, sizeof(*nbd_dev), GFP_KERNEL);
-	if (!nbd_dev)
-		return -ENOMEM;
-
 	part_shift = 0;
 	if (max_part > 0) {
 		part_shift = fls(max_part);
@@ -840,6 +836,10 @@ static int __init nbd_init(void)
 	if (nbds_max > 1UL << (MINORBITS - part_shift))
 		return -EINVAL;
 
+	nbd_dev = kcalloc(nbds_max, sizeof(*nbd_dev), GFP_KERNEL);
+	if (!nbd_dev)
+		return -ENOMEM;
+
 	for (i = 0; i < nbds_max; i++) {
 		struct gendisk *disk = alloc_disk(1 << part_shift);
 		if (!disk)
diff --git a/drivers/block/paride/pd.c b/drivers/block/paride/pd.c
index 19ad8f0..897b6b9 100644
--- a/drivers/block/paride/pd.c
+++ b/drivers/block/paride/pd.c
@@ -126,7 +126,7 @@
 */
 #include <linux/types.h>
 
-static bool verbose = 0;
+static int verbose = 0;
 static int major = PD_MAJOR;
 static char *name = PD_NAME;
 static int cluster = 64;
@@ -161,7 +161,7 @@ enum {D_PRT, D_PRO, D_UNI, D_MOD, D_GEO, D_SBY, D_DLY, D_SLV};
 static DEFINE_MUTEX(pd_mutex);
 static DEFINE_SPINLOCK(pd_lock);
 
-module_param(verbose, bool, 0);
+module_param(verbose, int, 0);
 module_param(major, int, 0);
 module_param(name, charp, 0);
 module_param(cluster, int, 0);
diff --git a/drivers/block/paride/pt.c b/drivers/block/paride/pt.c
index 2596042..ada4505 100644
--- a/drivers/block/paride/pt.c
+++ b/drivers/block/paride/pt.c
@@ -117,7 +117,7 @@
 
 */
 
-static bool verbose = 0;
+static int verbose = 0;
 static int major = PT_MAJOR;
 static char *name = PT_NAME;
 static int disable = 0;
@@ -152,7 +152,7 @@ static int (*drives[4])[6] = {&drive0, &drive1, &drive2, &drive3};
 
 #include <asm/uaccess.h>
 
-module_param(verbose, bool, 0);
+module_param(verbose, int, 0);
 module_param(major, int, 0);
 module_param(name, charp, 0);
 module_param_array(drive0, int, NULL, 0);
diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c
index 7e3f451..85b31ba 100644
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -93,6 +93,8 @@ static int atomic_dec_return_safe(atomic_t *v)
 
 #define RBD_MINORS_PER_MAJOR	256		/* max minors per blkdev */
 
+#define RBD_MAX_PARENT_CHAIN_LEN	16
+
 #define RBD_SNAP_DEV_NAME_PREFIX	"snap_"
 #define RBD_MAX_SNAP_NAME_LEN	\
 			(NAME_MAX - (sizeof (RBD_SNAP_DEV_NAME_PREFIX) - 1))
@@ -394,7 +396,7 @@ static ssize_t rbd_add(struct bus_type *bus, const char *buf,
 		       size_t count);
 static ssize_t rbd_remove(struct bus_type *bus, const char *buf,
 			  size_t count);
-static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping);
+static int rbd_dev_image_probe(struct rbd_device *rbd_dev, int depth);
 static void rbd_spec_put(struct rbd_spec *spec);
 
 static struct bus_attribute rbd_bus_attrs[] = {
@@ -457,6 +459,7 @@ void rbd_warn(struct rbd_device *rbd_dev, const char *fmt, ...)
 #  define rbd_assert(expr)	((void) 0)
 #endif /* !RBD_DEBUG */
 
+static void rbd_osd_copyup_callback(struct rbd_obj_request *obj_request);
 static int rbd_img_obj_request_submit(struct rbd_obj_request *obj_request);
 static void rbd_img_parent_read(struct rbd_obj_request *obj_request);
 static void rbd_dev_remove_parent(struct rbd_device *rbd_dev);
@@ -1670,6 +1673,16 @@ static void rbd_osd_stat_callback(struct rbd_obj_request *obj_request)
 	obj_request_done_set(obj_request);
 }
 
+static void rbd_osd_call_callback(struct rbd_obj_request *obj_request)
+{
+	dout("%s: obj %p\n", __func__, obj_request);
+
+	if (obj_request_img_data_test(obj_request))
+		rbd_osd_copyup_callback(obj_request);
+	else
+		obj_request_done_set(obj_request);
+}
+
 static void rbd_osd_req_callback(struct ceph_osd_request *osd_req,
 				struct ceph_msg *msg)
 {
@@ -1708,6 +1721,8 @@ static void rbd_osd_req_callback(struct ceph_osd_request *osd_req,
 		rbd_osd_stat_callback(obj_request);
 		break;
 	case CEPH_OSD_OP_CALL:
+		rbd_osd_call_callback(obj_request);
+		break;
 	case CEPH_OSD_OP_NOTIFY_ACK:
 	case CEPH_OSD_OP_WATCH:
 		rbd_osd_trivial_callback(obj_request);
@@ -1851,11 +1866,11 @@ static struct rbd_obj_request *rbd_obj_request_create(const char *object_name,
 	rbd_assert(obj_request_type_valid(type));
 
 	size = strlen(object_name) + 1;
-	name = kmalloc(size, GFP_KERNEL);
+	name = kmalloc(size, GFP_NOIO);
 	if (!name)
 		return NULL;
 
-	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_KERNEL);
+	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_NOIO);
 	if (!obj_request) {
 		kfree(name);
 		return NULL;
@@ -2115,6 +2130,11 @@ static bool rbd_img_obj_end_request(struct rbd_obj_request *obj_request)
 			result, xferred);
 		if (!img_request->result)
 			img_request->result = result;
+		/*
+		 * Need to end I/O on the entire obj_request worth of
+		 * bytes in case of error.
+		 */
+		xferred = obj_request->length;
 	}
 
 	/* Image object requests don't own their page array */
@@ -2300,13 +2320,15 @@ out_unwind:
 }
 
 static void
-rbd_img_obj_copyup_callback(struct rbd_obj_request *obj_request)
+rbd_osd_copyup_callback(struct rbd_obj_request *obj_request)
 {
 	struct rbd_img_request *img_request;
 	struct rbd_device *rbd_dev;
 	struct page **pages;
 	u32 page_count;
 
+	dout("%s: obj %p\n", __func__, obj_request);
+
 	rbd_assert(obj_request->type == OBJ_REQUEST_BIO);
 	rbd_assert(obj_request_img_data_test(obj_request));
 	img_request = obj_request->img_request;
@@ -2332,9 +2354,7 @@ rbd_img_obj_copyup_callback(struct rbd_obj_request *obj_request)
 	if (!obj_request->result)
 		obj_request->xferred = obj_request->length;
 
-	/* Finish up with the normal image object callback */
-
-	rbd_img_obj_callback(obj_request);
+	obj_request_done_set(obj_request);
 }
 
 static void
@@ -2431,7 +2451,6 @@ rbd_img_obj_parent_read_full_callback(struct rbd_img_request *img_request)
 
 	/* All set, send it off. */
 
-	orig_request->callback = rbd_img_obj_copyup_callback;
 	osdc = &rbd_dev->rbd_client->client->osdc;
 	img_result = rbd_obj_request_submit(osdc, orig_request);
 	if (!img_result)
@@ -3436,6 +3455,9 @@ static int rbd_init_disk(struct rbd_device *rbd_dev)
 	blk_queue_io_opt(q, segment_size);
 
 	blk_queue_merge_bvec(q, rbd_merge_bvec);
+	if (!ceph_test_opt(rbd_dev->rbd_client->client, NOCRC))
+		q->backing_dev_info.capabilities |= BDI_CAP_STABLE_WRITES;
+
 	disk->queue = q;
 
 	q->queuedata = rbd_dev;
@@ -4811,45 +4833,50 @@ out_err:
 	return ret;
 }
 
-static int rbd_dev_probe_parent(struct rbd_device *rbd_dev)
+/*
+ * @depth is rbd_dev_image_probe() -> rbd_dev_probe_parent() ->
+ * rbd_dev_image_probe() recursion depth, which means it's also the
+ * length of the already discovered part of the parent chain.
+ */
+static int rbd_dev_probe_parent(struct rbd_device *rbd_dev, int depth)
 {
 	struct rbd_device *parent = NULL;
-	struct rbd_spec *parent_spec;
-	struct rbd_client *rbdc;
 	int ret;
 
 	if (!rbd_dev->parent_spec)
 		return 0;
-	/*
-	 * We need to pass a reference to the client and the parent
-	 * spec when creating the parent rbd_dev.  Images related by
-	 * parent/child relationships always share both.
-	 */
-	parent_spec = rbd_spec_get(rbd_dev->parent_spec);
-	rbdc = __rbd_get_client(rbd_dev->rbd_client);
 
-	ret = -ENOMEM;
-	parent = rbd_dev_create(rbdc, parent_spec);
-	if (!parent)
+	if (++depth > RBD_MAX_PARENT_CHAIN_LEN) {
+		pr_info("parent chain is too long (%d)\n", depth);
+		ret = -EINVAL;
+		goto out_err;
+	}
+
+	parent = rbd_dev_create(rbd_dev->rbd_client, rbd_dev->parent_spec);
+	if (!parent) {
+		ret = -ENOMEM;
 		goto out_err;
+	}
 
-	ret = rbd_dev_image_probe(parent, false);
+	/*
+	 * Images related by parent/child relationships always share
+	 * rbd_client and spec/parent_spec, so bump their refcounts.
+	 */
+	__rbd_get_client(rbd_dev->rbd_client);
+	rbd_spec_get(rbd_dev->parent_spec);
+
+	ret = rbd_dev_image_probe(parent, depth);
 	if (ret < 0)
 		goto out_err;
+
 	rbd_dev->parent = parent;
 	atomic_set(&rbd_dev->parent_ref, 1);
-
 	return 0;
+
 out_err:
-	if (parent) {
-		rbd_dev_unparent(rbd_dev);
-		kfree(rbd_dev->header_name);
+	rbd_dev_unparent(rbd_dev);
+	if (parent)
 		rbd_dev_destroy(parent);
-	} else {
-		rbd_put_client(rbdc);
-		rbd_spec_put(parent_spec);
-	}
-
 	return ret;
 }
 
@@ -4955,7 +4982,7 @@ static void rbd_dev_image_release(struct rbd_device *rbd_dev)
  * parent), initiate a watch on its header object before using that
  * object to get detailed information about the rbd image.
  */
-static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)
+static int rbd_dev_image_probe(struct rbd_device *rbd_dev, int depth)
 {
 	int ret;
 	int tmp;
@@ -4976,7 +5003,7 @@ static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)
 	if (ret)
 		goto err_out_format;
 
-	if (mapping) {
+	if (!depth) {
 		ret = rbd_dev_header_watch_sync(rbd_dev, true);
 		if (ret)
 			goto out_header_name;
@@ -4993,7 +5020,7 @@ static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)
 	if (ret)
 		goto err_out_probe;
 
-	ret = rbd_dev_probe_parent(rbd_dev);
+	ret = rbd_dev_probe_parent(rbd_dev, depth);
 	if (ret)
 		goto err_out_probe;
 
@@ -5004,7 +5031,7 @@ static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)
 err_out_probe:
 	rbd_dev_unprobe(rbd_dev);
 err_out_watch:
-	if (mapping) {
+	if (!depth) {
 		tmp = rbd_dev_header_watch_sync(rbd_dev, false);
 		if (tmp)
 			rbd_warn(rbd_dev, "unable to tear down "
@@ -5075,7 +5102,7 @@ static ssize_t rbd_add(struct bus_type *bus,
 	rbdc = NULL;		/* rbd_dev now owns this */
 	spec = NULL;		/* rbd_dev now owns this */
 
-	rc = rbd_dev_image_probe(rbd_dev, true);
+	rc = rbd_dev_image_probe(rbd_dev, 0);
 	if (rc < 0)
 		goto err_out_rbd_dev;
 
diff --git a/drivers/block/xen-blkfront.c b/drivers/block/xen-blkfront.c
index ddd9a09..ea7ed86 100644
--- a/drivers/block/xen-blkfront.c
+++ b/drivers/block/xen-blkfront.c
@@ -1590,7 +1590,8 @@ static void blkback_changed(struct xenbus_device *dev,
 			break;
 		/* Missed the backend's Closing state -- fallthrough */
 	case XenbusStateClosing:
-		blkfront_closing(info);
+		if (info)
+			blkfront_closing(info);
 		break;
 	}
 }
diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c
index dad8891..9c2c4ec 100644
--- a/drivers/bluetooth/ath3k.c
+++ b/drivers/bluetooth/ath3k.c
@@ -77,6 +77,8 @@ static struct usb_device_id ath3k_table[] = {
 	{ USB_DEVICE(0x0CF3, 0x3004) },
 	{ USB_DEVICE(0x0CF3, 0x3008) },
 	{ USB_DEVICE(0x0CF3, 0x311D) },
+	{ USB_DEVICE(0x0CF3, 0x311E) },
+	{ USB_DEVICE(0x0CF3, 0x311F) },
 	{ USB_DEVICE(0x0CF3, 0x817a) },
 	{ USB_DEVICE(0x13d3, 0x3375) },
 	{ USB_DEVICE(0x04CA, 0x3004) },
@@ -120,6 +122,8 @@ static struct usb_device_id ath3k_blist_tbl[] = {
 	{ USB_DEVICE(0x0cf3, 0x3004), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x3008), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x311D), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0x311E), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0x311F), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0CF3, 0x817a), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 61a8ec4..537ad68 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -49,6 +49,7 @@ static struct usb_driver btusb_driver;
 #define BTUSB_WRONG_SCO_MTU	0x40
 #define BTUSB_ATH3012		0x80
 #define BTUSB_INTEL		0x100
+#define BTUSB_INTEL_BOOT	0x200
 
 static struct usb_device_id btusb_table[] = {
 	/* Generic Bluetooth USB device */
@@ -113,6 +114,13 @@ static struct usb_device_id btusb_table[] = {
 	/*Broadcom devices with vendor specific id */
 	{ USB_VENDOR_AND_INTERFACE_INFO(0x0a5c, 0xff, 0x01, 0x01) },
 
+	/* IMC Networks - Broadcom based */
+	{ USB_VENDOR_AND_INTERFACE_INFO(0x13d3, 0xff, 0x01, 0x01) },
+
+	/* Intel Bluetooth USB Bootloader (RAM module) */
+	{ USB_DEVICE(0x8087, 0x0a5a),
+	  .driver_info = BTUSB_INTEL_BOOT | BTUSB_BROKEN_ISOC },
+
 	{ }	/* Terminating entry */
 };
 
@@ -141,6 +149,8 @@ static struct usb_device_id blacklist_table[] = {
 	{ USB_DEVICE(0x0cf3, 0x3004), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x3008), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x311d), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0x311e), .driver_info = BTUSB_ATH3012 },
+	{ USB_DEVICE(0x0cf3, 0x311f), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0cf3, 0x817a), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
@@ -1224,6 +1234,8 @@ static int btusb_setup_intel(struct hci_dev *hdev)
 	}
 	fw_ptr = fw->data;
 
+	kfree_skb(skb);
+
 	/* This Intel specific command enables the manufacturer mode of the
 	 * controller.
 	 *
@@ -1444,6 +1456,9 @@ static int btusb_probe(struct usb_interface *intf,
 	if (id->driver_info & BTUSB_INTEL)
 		hdev->setup = btusb_setup_intel;
 
+	if (id->driver_info & BTUSB_INTEL_BOOT)
+		set_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);
+
 	/* Interface numbers are hardcoded in the specification */
 	data->isoc = usb_ifnum_to_if(data->udev, 1);
 
diff --git a/drivers/bluetooth/hci_vhci.c b/drivers/bluetooth/hci_vhci.c
index d8b7aed..f3ce1c4 100644
--- a/drivers/bluetooth/hci_vhci.c
+++ b/drivers/bluetooth/hci_vhci.c
@@ -265,6 +265,7 @@ static int vhci_release(struct inode *inode, struct file *file)
 	hci_unregister_dev(hdev);
 	hci_free_dev(hdev);
 
+	skb_queue_purge(&data->readq);
 	file->private_data = NULL;
 	kfree(data);
 
diff --git a/drivers/bus/mvebu-mbus.c b/drivers/bus/mvebu-mbus.c
index 711dcf4..7c43782 100644
--- a/drivers/bus/mvebu-mbus.c
+++ b/drivers/bus/mvebu-mbus.c
@@ -838,7 +838,7 @@ fs_initcall(mvebu_mbus_debugfs_init);
 int __init mvebu_mbus_init(const char *soc, phys_addr_t mbuswins_phys_base,
 			   size_t mbuswins_size,
 			   phys_addr_t sdramwins_phys_base,
-			   size_t sdramwins_size)
+			   size_t sdramwins_size, int is_coherent)
 {
 	struct mvebu_mbus_state *mbus = &mbus_state;
 	const struct of_device_id *of_id;
@@ -865,8 +865,7 @@ int __init mvebu_mbus_init(const char *soc, phys_addr_t mbuswins_phys_base,
 		return -ENOMEM;
 	}
 
-	if (of_find_compatible_node(NULL, NULL, "marvell,coherency-fabric"))
-		mbus->hw_io_coherency = 1;
+	mbus->hw_io_coherency = is_coherent;
 
 	for (win = 0; win < mbus->soc->num_wins; win++)
 		mvebu_mbus_disable_window(mbus, win);
diff --git a/drivers/char/agp/intel-gtt.c b/drivers/char/agp/intel-gtt.c
index b8e2014..051aadb 100644
--- a/drivers/char/agp/intel-gtt.c
+++ b/drivers/char/agp/intel-gtt.c
@@ -583,7 +583,7 @@ static inline int needs_ilk_vtd_wa(void)
 	/* Query intel_iommu to see if we need the workaround. Presumably that
 	 * was loaded first.
 	 */
-	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_HB ||
+	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_D_IG ||
 	     gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_IG) &&
 	     intel_iommu_gfx_mapped)
 		return 1;
diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c
index 40b3f75..a67ac2a 100644
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@ -1144,14 +1144,14 @@ static int smi_start_processing(void       *send_info,
 
 	new_smi->intf = intf;
 
-	/* Try to claim any interrupts. */
-	if (new_smi->irq_setup)
-		new_smi->irq_setup(new_smi);
-
 	/* Set up the timer that drives the interface. */
 	setup_timer(&new_smi->si_timer, smi_timeout, (long)new_smi);
 	smi_mod_timer(new_smi, jiffies + SI_TIMEOUT_JIFFIES);
 
+	/* Try to claim any interrupts. */
+	if (new_smi->irq_setup)
+		new_smi->irq_setup(new_smi);
+
 	/*
 	 * Check if the user forcefully enabled the daemon.
 	 */
@@ -2717,7 +2717,7 @@ static int wait_for_msg_done(struct smi_info *smi_info)
 		    smi_result == SI_SM_CALL_WITH_TICK_DELAY) {
 			schedule_timeout_uninterruptible(1);
 			smi_result = smi_info->handlers->event(
-				smi_info->si_sm, 100);
+				smi_info->si_sm, jiffies_to_usecs(1));
 		} else if (smi_result == SI_SM_CALL_WITHOUT_DELAY) {
 			smi_result = smi_info->handlers->event(
 				smi_info->si_sm, 0);
diff --git a/drivers/char/tpm/tpm_ibmvtpm.c b/drivers/char/tpm/tpm_ibmvtpm.c
index 09df26f..ce854bb 100644
--- a/drivers/char/tpm/tpm_ibmvtpm.c
+++ b/drivers/char/tpm/tpm_ibmvtpm.c
@@ -529,7 +529,7 @@ static void ibmvtpm_crq_process(struct ibmvtpm_crq *crq,
 			}
 			ibmvtpm->rtce_size = be16_to_cpu(crq->len);
 			ibmvtpm->rtce_buf = kmalloc(ibmvtpm->rtce_size,
-						    GFP_KERNEL);
+						    GFP_ATOMIC);
 			if (!ibmvtpm->rtce_buf) {
 				dev_err(ibmvtpm->dev, "Failed to allocate memory for rtce buffer\n");
 				return;
@@ -618,6 +618,9 @@ static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,
 		goto cleanup;
 	}
 
+	ibmvtpm->dev = dev;
+	ibmvtpm->vdev = vio_dev;
+
 	crq_q = &ibmvtpm->crq_queue;
 	crq_q->crq_addr = (struct ibmvtpm_crq *)get_zeroed_page(GFP_KERNEL);
 	if (!crq_q->crq_addr) {
@@ -662,8 +665,6 @@ static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,
 
 	crq_q->index = 0;
 
-	ibmvtpm->dev = dev;
-	ibmvtpm->vdev = vio_dev;
 	TPM_VPRIV(chip) = (void *)ibmvtpm;
 
 	spin_lock_init(&ibmvtpm->rtce_lock);
diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c
index bf9b15a..a21e2fa 100644
--- a/drivers/clk/versatile/clk-sp810.c
+++ b/drivers/clk/versatile/clk-sp810.c
@@ -128,8 +128,8 @@ struct clk *clk_sp810_timerclken_of_get(struct of_phandle_args *clkspec,
 {
 	struct clk_sp810 *sp810 = data;
 
-	if (WARN_ON(clkspec->args_count != 1 || clkspec->args[0] >
-			ARRAY_SIZE(sp810->timerclken)))
+	if (WARN_ON(clkspec->args_count != 1 ||
+		    clkspec->args[0] >=	ARRAY_SIZE(sp810->timerclken)))
 		return NULL;
 
 	return sp810->timerclken[clkspec->args[0]].clk;
@@ -141,6 +141,7 @@ void __init clk_sp810_of_setup(struct device_node *node)
 	const char *parent_names[2];
 	char name[12];
 	struct clk_init_data init;
+	static int instance;
 	int i;
 
 	if (!sp810) {
@@ -172,7 +173,7 @@ void __init clk_sp810_of_setup(struct device_node *node)
 	init.num_parents = ARRAY_SIZE(parent_names);
 
 	for (i = 0; i < ARRAY_SIZE(sp810->timerclken); i++) {
-		snprintf(name, ARRAY_SIZE(name), "timerclken%d", i);
+		snprintf(name, sizeof(name), "sp810_%d_%d", instance, i);
 
 		sp810->timerclken[i].sp810 = sp810;
 		sp810->timerclken[i].channel = i;
@@ -184,5 +185,6 @@ void __init clk_sp810_of_setup(struct device_node *node)
 	}
 
 	of_clk_add_provider(node, clk_sp810_timerclken_of_get, sp810);
+	instance++;
 }
 CLK_OF_DECLARE(sp810, "arm,sp810", clk_sp810_of_setup);
diff --git a/drivers/clocksource/vt8500_timer.c b/drivers/clocksource/vt8500_timer.c
index 64f553f..5874ebf 100644
--- a/drivers/clocksource/vt8500_timer.c
+++ b/drivers/clocksource/vt8500_timer.c
@@ -50,6 +50,8 @@
 
 #define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)
 
+#define MIN_OSCR_DELTA		16
+
 static void __iomem *regbase;
 
 static cycle_t vt8500_timer_read(struct clocksource *cs)
@@ -80,7 +82,7 @@ static int vt8500_timer_set_next_event(unsigned long cycles,
 		cpu_relax();
 	writel((unsigned long)alarm, regbase + TIMER_MATCH_VAL);
 
-	if ((signed)(alarm - clocksource.read(&clocksource)) <= 16)
+	if ((signed)(alarm - clocksource.read(&clocksource)) <= MIN_OSCR_DELTA)
 		return -ETIME;
 
 	writel(1, regbase + TIMER_IER_VAL);
@@ -162,7 +164,7 @@ static void __init vt8500_timer_init(struct device_node *np)
 		pr_err("%s: setup_irq failed for %s\n", __func__,
 							clockevent.name);
 	clockevents_config_and_register(&clockevent, VT8500_TIMER_HZ,
-					4, 0xf0000000);
+					MIN_OSCR_DELTA * 2, 0xf0000000);
 }
 
 CLOCKSOURCE_OF_DECLARE(vt8500, "via,vt8500-timer", vt8500_timer_init);
diff --git a/drivers/connector/connector.c b/drivers/connector/connector.c
index 0daa11e..bdbd8041 100644
--- a/drivers/connector/connector.c
+++ b/drivers/connector/connector.c
@@ -154,26 +154,21 @@ static int cn_call_callback(struct sk_buff *skb)
  *
  * It checks skb, netlink header and msg sizes, and calls callback helper.
  */
-static void cn_rx_skb(struct sk_buff *__skb)
+static void cn_rx_skb(struct sk_buff *skb)
 {
 	struct nlmsghdr *nlh;
-	struct sk_buff *skb;
 	int len, err;
 
-	skb = skb_get(__skb);
-
 	if (skb->len >= NLMSG_HDRLEN) {
 		nlh = nlmsg_hdr(skb);
 		len = nlmsg_len(nlh);
 
 		if (len < (int)sizeof(struct cn_msg) ||
 		    skb->len < nlh->nlmsg_len ||
-		    len > CONNECTOR_MAX_MSG_SIZE) {
-			kfree_skb(skb);
+		    len > CONNECTOR_MAX_MSG_SIZE)
 			return;
-		}
 
-		err = cn_call_callback(skb);
+		err = cn_call_callback(skb_get(skb));
 		if (err < 0)
 			kfree_skb(skb);
 	}
diff --git a/drivers/cpufreq/ambarella-cpufreq.c b/drivers/cpufreq/ambarella-cpufreq.c
index b3d600a..5831980 100644
--- a/drivers/cpufreq/ambarella-cpufreq.c
+++ b/drivers/cpufreq/ambarella-cpufreq.c
@@ -20,6 +20,8 @@
 #include <linux/slab.h>
 #include <linux/types.h>
 #include <plat/event.h>
+#include <linux/io.h>
+#include <plat/rct.h>
 
 //#define amba_cpufreq_debug	//used at debug mode
 
@@ -56,6 +58,11 @@ static int amba_cpufreq_target(struct cpufreq_policy *policy,
 	int index, ret;
 	unsigned int cur_freq;
 
+	if(target_freq < 96000) {
+		printk("Target frequency is too low, cortex is not stable, it should be more than 96000\n");
+		return -EINVAL;
+	}
+
 	if (cpufreq_frequency_table_target(policy, amba_cpufreq.cortex_clktbl,
 				target_freq, relation, &index))
 		return -EINVAL;
@@ -65,7 +72,8 @@ static int amba_cpufreq_target(struct cpufreq_policy *policy,
 	core_newfreq = amba_cpufreq.core_clktbl[index].frequency * 1000;
 	freqs.new = cortex_newfreq / 1000;
 
-	amba_cpufreq_prt(KERN_INFO "prepare to switch the frequency from %d KHz to %d KHz\n",freqs.old, freqs.new);
+	amba_cpufreq_prt(KERN_INFO "prepare to switch the frequency from %d KHz to %d KHz\n"
+				,freqs.old, freqs.new);
 
 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 	ambarella_set_event(AMBA_EVENT_PRE_CPUFREQ, NULL);
@@ -83,11 +91,21 @@ static int amba_cpufreq_target(struct cpufreq_policy *policy,
 		pr_err("CPU Freq: cpu clk_set_rate failed: %d\n", ret);
 	}
 
+#if (CHIP_REV == S2L) || (CHIP_REV == S3L)
+	if(amba_cpufreq.core_clktbl[index].frequency <= 96000) {
+		/*Disable IDSP/VDSP to Save Power*/
+		amba_writel(CKEN_CLUSTER_REG, 0x540);
+	} else {
+		/*Enable IDSP/VDSP to Save Power*/
+		amba_writel(CKEN_CLUSTER_REG, 0x3fff);
+	}
+#endif
 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 	ambarella_set_event(AMBA_EVENT_POST_CPUFREQ, NULL);
 
 	cur_freq = clk_get_rate(amba_cpufreq.cortex_clk) / 1000;
-	amba_cpufreq_prt(KERN_INFO "current frequency of cortex clock is:%d KHz\n", cur_freq);
+	amba_cpufreq_prt(KERN_INFO "current frequency of cortex clock is:%d KHz\n",
+				 cur_freq);
 
 
 	return ret;
@@ -141,7 +159,7 @@ static int amba_cpufreq_driver_init(void)
 	struct cpufreq_frequency_table *cortex_freqtbl;
 	struct cpufreq_frequency_table *core_freqtbl;
 	const __be32 *val;
-	int cnt, i, ret;
+	int cnt, i, ret, clk_div;
 
 	printk("ambarella cpufreq driver init\n");
 	np = of_find_node_by_path("/cpus");
@@ -150,6 +168,12 @@ static int amba_cpufreq_driver_init(void)
 		return -ENODEV;
 	}
 
+	ret = of_property_read_u32(np, "amb,core-div", &clk_div);
+	if (ret != 0 || !((clk_div == 1 || clk_div == 2))) {
+		/*Default is that the pll_out_core is twice gclk_core */
+		clk_div = 2;
+	}
+
 	if (of_property_read_u32(np, "clock-latency",
 				&amba_cpufreq.transition_latency))
 		amba_cpufreq.transition_latency = CPUFREQ_ETERNAL;
@@ -178,7 +202,8 @@ static int amba_cpufreq_driver_init(void)
 
 	for (i = 0; i < cnt; i++) {
 		core_freqtbl[i].index = i;
-		core_freqtbl[i].frequency = be32_to_cpup(val) * 2;
+		/*pll_out_core = clk_div * gclk_core;*/
+		core_freqtbl[i].frequency = be32_to_cpup(val) * clk_div;
 
 		cortex_freqtbl[i].index = i;
 		cortex_freqtbl[i].frequency = be32_to_cpup((val + 1));
@@ -190,7 +215,7 @@ static int amba_cpufreq_driver_init(void)
 	cortex_freqtbl[i].frequency = clk_get_rate(clk_get(NULL, "gclk_cortex")) / 1000;
 
 	core_freqtbl[i].index = i;
-	core_freqtbl[i].frequency = clk_get_rate(clk_get(NULL, "gclk_core")) / 1000;
+	core_freqtbl[i].frequency = clk_get_rate(clk_get(NULL, "gclk_core")) / 1000 * clk_div;
 
 	i++;
 	cortex_freqtbl[i].index = i;
diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index c3a93fe..5b11022 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -135,6 +135,9 @@ int cpuidle_idle_call(void)
 
 	/* ask the governor for the next state */
 	next_state = cpuidle_curr_governor->select(drv, dev);
+	if (next_state < 0)
+		return -EBUSY;
+
 	if (need_resched()) {
 		dev->last_residency = 0;
 		/* give the governor an opportunity to reflect on the outcome */
diff --git a/drivers/cpuidle/governors/menu.c b/drivers/cpuidle/governors/menu.c
index bc580b6..67fd901 100644
--- a/drivers/cpuidle/governors/menu.c
+++ b/drivers/cpuidle/governors/menu.c
@@ -269,7 +269,7 @@ static int menu_select(struct cpuidle_driver *drv, struct cpuidle_device *dev)
 		data->needs_update = 0;
 	}
 
-	data->last_state_idx = 0;
+	data->last_state_idx = CPUIDLE_DRIVER_STATE_START - 1;
 	data->exit_us = 0;
 
 	/* Special case when user has set very strict latency requirement */
diff --git a/drivers/crypto/caam/caamhash.c b/drivers/crypto/caam/caamhash.c
index 84573b4..dda43cc 100644
--- a/drivers/crypto/caam/caamhash.c
+++ b/drivers/crypto/caam/caamhash.c
@@ -895,13 +895,14 @@ static int ahash_final_ctx(struct ahash_request *req)
 			  state->buflen_1;
 	u32 *sh_desc = ctx->sh_desc_fin, *desc;
 	dma_addr_t ptr = ctx->sh_desc_fin_dma;
-	int sec4_sg_bytes;
+	int sec4_sg_bytes, sec4_sg_src_index;
 	int digestsize = crypto_ahash_digestsize(ahash);
 	struct ahash_edesc *edesc;
 	int ret = 0;
 	int sh_len;
 
-	sec4_sg_bytes = (1 + (buflen ? 1 : 0)) * sizeof(struct sec4_sg_entry);
+	sec4_sg_src_index = 1 + (buflen ? 1 : 0);
+	sec4_sg_bytes = sec4_sg_src_index * sizeof(struct sec4_sg_entry);
 
 	/* allocate space for base edesc and hw desc commands, link tables */
 	edesc = kmalloc(sizeof(struct ahash_edesc) + DESC_JOB_IO_LEN +
@@ -928,7 +929,7 @@ static int ahash_final_ctx(struct ahash_request *req)
 	state->buf_dma = try_buf_map_to_sec4_sg(jrdev, edesc->sec4_sg + 1,
 						buf, state->buf_dma, buflen,
 						last_buflen);
-	(edesc->sec4_sg + sec4_sg_bytes - 1)->len |= SEC4_SG_LEN_FIN;
+	(edesc->sec4_sg + sec4_sg_src_index - 1)->len |= SEC4_SG_LEN_FIN;
 
 	append_seq_in_ptr(desc, edesc->sec4_sg_dma, ctx->ctx_len + buflen,
 			  LDST_SGF);
diff --git a/drivers/crypto/caam/caamrng.c b/drivers/crypto/caam/caamrng.c
index d1939a9..04aefff 100644
--- a/drivers/crypto/caam/caamrng.c
+++ b/drivers/crypto/caam/caamrng.c
@@ -56,7 +56,7 @@
 
 /* Buffer, its dma address and lock */
 struct buf_data {
-	u8 buf[RN_BUF_SIZE];
+	u8 buf[RN_BUF_SIZE] ____cacheline_aligned;
 	dma_addr_t addr;
 	struct completion filled;
 	u32 hw_desc[DESC_JOB_O_LEN];
diff --git a/drivers/crypto/ixp4xx_crypto.c b/drivers/crypto/ixp4xx_crypto.c
index 21180d6..7cb51b3 100644
--- a/drivers/crypto/ixp4xx_crypto.c
+++ b/drivers/crypto/ixp4xx_crypto.c
@@ -915,7 +915,6 @@ static int ablk_perform(struct ablkcipher_request *req, int encrypt)
 		crypt->mode |= NPE_OP_NOT_IN_PLACE;
 		/* This was never tested by Intel
 		 * for more than one dst buffer, I think. */
-		BUG_ON(req->dst->length < nbytes);
 		req_ctx->dst = NULL;
 		if (!chainup_buffers(dev, req->dst, nbytes, &dst_hook,
 					flags, DMA_FROM_DEVICE))
diff --git a/drivers/crypto/nx/nx.c b/drivers/crypto/nx/nx.c
index bbdab6e..fe68964 100644
--- a/drivers/crypto/nx/nx.c
+++ b/drivers/crypto/nx/nx.c
@@ -309,7 +309,7 @@ static void nx_of_update_msc(struct device   *dev,
 		     ((bytes_so_far + sizeof(struct msc_triplet)) <= lenp) &&
 		     i < msc->triplets;
 		     i++) {
-			if (msc->fc > NX_MAX_FC || msc->mode > NX_MAX_MODE) {
+			if (msc->fc >= NX_MAX_FC || msc->mode >= NX_MAX_MODE) {
 				dev_err(dev, "unknown function code/mode "
 					"combo: %d/%d (ignored)\n", msc->fc,
 					msc->mode);
diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c
index 5b2b5e6..057d894 100644
--- a/drivers/crypto/talitos.c
+++ b/drivers/crypto/talitos.c
@@ -935,7 +935,8 @@ static int sg_to_link_tbl(struct scatterlist *sg, int sg_count,
 		sg_count--;
 		link_tbl_ptr--;
 	}
-	be16_add_cpu(&link_tbl_ptr->len, cryptlen);
+	link_tbl_ptr->len = cpu_to_be16(be16_to_cpu(link_tbl_ptr->len)
+					+ cryptlen);
 
 	/* tag end of link table */
 	link_tbl_ptr->j_extent = DESC_PTR_LNKTBL_RETURN;
@@ -2621,6 +2622,7 @@ static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,
 		break;
 	default:
 		dev_err(dev, "unknown algorithm type %d\n", t_alg->algt.type);
+		kfree(t_alg);
 		return ERR_PTR(-EINVAL);
 	}
 
diff --git a/drivers/crypto/ux500/hash/hash_core.c b/drivers/crypto/ux500/hash/hash_core.c
index 6789c16..cde4a6e 100644
--- a/drivers/crypto/ux500/hash/hash_core.c
+++ b/drivers/crypto/ux500/hash/hash_core.c
@@ -806,7 +806,7 @@ int hash_process_data(
 						&device_data->state);
 				memmove(req_ctx->state.buffer,
 						device_data->state.buffer,
-						HASH_BLOCK_SIZE / sizeof(u32));
+						HASH_BLOCK_SIZE);
 				if (ret) {
 					dev_err(device_data->dev, "[%s] "
 							"hash_resume_state()"
@@ -858,7 +858,7 @@ int hash_process_data(
 
 			memmove(device_data->state.buffer,
 					req_ctx->state.buffer,
-					HASH_BLOCK_SIZE / sizeof(u32));
+					HASH_BLOCK_SIZE);
 			if (ret) {
 				dev_err(device_data->dev, "[%s] "
 						"hash_save_state()"
diff --git a/drivers/dma/ambarella_dma.c b/drivers/dma/ambarella_dma.c
index e7c86f2..54819a1 100644
--- a/drivers/dma/ambarella_dma.c
+++ b/drivers/dma/ambarella_dma.c
@@ -25,6 +25,7 @@
 #include <linux/dmapool.h>
 #include <linux/delay.h>
 #include <linux/of.h>
+#include <linux/of_dma.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <mach/hardware.h>
@@ -198,42 +199,11 @@ static void ambdma_put_desc(struct ambdma_chan *amb_chan,
 static void ambdma_return_desc(struct ambdma_chan *amb_chan,
 		struct ambdma_desc *amb_desc)
 {
-	struct dma_async_tx_descriptor	*txd = &amb_desc->txd;
-
 	/* move children to free_list */
 	list_splice_init(&amb_desc->tx_list, &amb_chan->free_list);
 	/* move myself to free_list */
 	list_move_tail(&amb_desc->desc_node, &amb_chan->free_list);
 
-	/* unmap dma addresses if required */
-	if (!amb_chan->chan.private) {
-		if (!(txd->flags & DMA_COMPL_SKIP_DEST_UNMAP)) {
-			struct device *dev = amb_chan->chan.device->dev;
-			if (txd->flags & DMA_COMPL_DEST_UNMAP_SINGLE)
-				dma_unmap_single(dev,
-						amb_desc->lli->dst,
-						amb_desc->len,
-						DMA_FROM_DEVICE);
-			else
-				dma_unmap_page(dev,
-						amb_desc->lli->dst,
-						amb_desc->len,
-						DMA_FROM_DEVICE);
-		}
-		if (!(txd->flags & DMA_COMPL_SKIP_SRC_UNMAP)) {
-			struct device *dev = amb_chan->chan.device->dev;
-			if (txd->flags & DMA_COMPL_SRC_UNMAP_SINGLE)
-				dma_unmap_single(dev,
-						amb_desc->lli->src,
-						amb_desc->len,
-						DMA_TO_DEVICE);
-			else
-				dma_unmap_page(dev,
-						amb_desc->lli->src,
-						amb_desc->len,
-						DMA_TO_DEVICE);
-		}
-	}
 }
 
 static void ambdma_chain_complete(struct ambdma_chan *amb_chan,
@@ -984,11 +954,55 @@ dma_memcpy_err:
 	return NULL;
 }
 
+struct amba_dma_filter_param {
+	struct device_node *of_node;
+	unsigned int chan_id;
+	unsigned int dma_type;
+	//unsigned int force_stop;
+};
+
+static bool amba_dma_filter_fn(struct dma_chan *chan, void *fn_param)
+{
+	struct amba_dma_filter_param *param = fn_param;
+	//struct ambdma_chan *amb_chan = to_ambdma_chan(chan);
+	//struct ambdma_device *amb_dma = amb_chan->amb_dma;
+
+	if (chan->chan_id != param->chan_id)
+		return false;
+
+	//amb_chan->chan.private = &param->force_stop;
+	return true;
+}
+
+static struct dma_chan *amb_dma_xlate(struct of_phandle_args *dma_spec,
+			       struct of_dma *ofdma)
+{
+	struct ambdma_device *amb_dma = ofdma->of_dma_data;
+	dma_cap_mask_t mask;
+	struct amba_dma_filter_param param;
+
+	if (dma_spec->args_count != 2)
+		return NULL;
+	if (dma_spec->args[1] == 1)
+		mask = amb_dma->dma_slave.cap_mask;
+	else
+		mask = amb_dma->dma_memcpy.cap_mask;
+
+	param.of_node = ofdma->of_node;
+	param.chan_id = dma_spec->args[0];
+
+	if (param.chan_id >= amb_dma->nr_channels)
+		return NULL;
+
+	return dma_request_channel(mask, amba_dma_filter_fn, &param);
+}
+
 static int ambarella_dma_probe(struct platform_device *pdev)
 {
 	struct ambdma_device *amb_dma;
 	struct ambdma_chan *amb_chan;
 	struct device_node *np = pdev->dev.of_node;
+	const char *prop_name = "dma-trans-type";
 	int val, i, ret = 0;
 
 	/* alloc the amba dma engine struct */
@@ -1041,6 +1055,22 @@ static int ambarella_dma_probe(struct platform_device *pdev)
 
 	of_property_read_u32(np, "amb,copy-align", &amb_dma->copy_align);
 	amb_dma->support_prs = !!of_find_property(np, "amb,support-prs", NULL);
+	ret = of_property_read_u32(np, "dma-channels", &amb_dma->nr_channels);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read dma-channels\n");
+		return ret;
+	}
+	ret = of_property_read_u32(np, "dma-requests", &amb_dma->dma_requests);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read dma-requests\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32_array(np, prop_name, amb_dma->dma_channel_type, amb_dma->nr_channels);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read dma-trans-type\n");
+		return ret;
+	}
 
 	/* Init dma_device struct */
 	dma_cap_zero(amb_dma->dma_slave.cap_mask);
@@ -1085,9 +1115,7 @@ static int ambarella_dma_probe(struct platform_device *pdev)
 				(unsigned long)amb_chan);
 		dma_cookie_init(&amb_chan->chan);
 
-		if (i == I2S_TX_DMA_CHAN || i == I2S_RX_DMA_CHAN ||
-			i == UART_TX_DMA_CHAN || i == UART_RX_DMA_CHAN ||
-			i == NOR_SPI_TX_DMA_CHAN || i == NOR_SPI_RX_DMA_CHAN) {
+		if (amb_dma->dma_channel_type[i] != 0) {
 			amb_chan->chan.device = &amb_dma->dma_slave;
 			list_add_tail(&amb_chan->chan.device_node,
 					&amb_dma->dma_slave.channels);
@@ -1100,33 +1128,16 @@ static int ambarella_dma_probe(struct platform_device *pdev)
 
 #if (DMA_SUPPORT_SELECT_CHANNEL == 1)
 	val = 0;
+	ret = of_property_read_u32_array(np, "dma-channel-sel",
+				amb_dma->dma_channel_sel, amb_dma->nr_channels);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read dma-channel-sel\n");
+	}
 	for (i = 0; i < NUM_DMA_CHANNELS; i++) {
-		switch(i) {
-		case NOR_SPI_TX_DMA_CHAN:
-			val |= NOR_SPI_TX_DMA_REQ_IDX << (i * 4);
-			break;
-		case NOR_SPI_RX_DMA_CHAN:
-			val |= NOR_SPI_RX_DMA_REQ_IDX << (i * 4);
-			break;
-		case SSI1_TX_DMA_CHAN:
-			val |= SSI1_TX_DMA_REQ_IDX << (i * 4);
-			break;
-		case SSI1_RX_DMA_CHAN:
-			val |= SSI1_RX_DMA_REQ_IDX << (i * 4);
-			break;
-		case UART_TX_DMA_CHAN:
-			val |= UART_TX_DMA_REQ_IDX << (i * 4);
-			break;
-		case UART_RX_DMA_CHAN:
-			val |= UART_RX_DMA_REQ_IDX << (i * 4);
-			break;
-		case I2S_RX_DMA_CHAN:
-			val |= I2S_RX_DMA_REQ_IDX << (i * 4);
-			break;
-		case I2S_TX_DMA_CHAN:
-			val |= I2S_TX_DMA_REQ_IDX << (i * 4);
-			break;
-		}
+		if (ret)
+			val |= i << (i * 4);
+		else
+			val |= (amb_dma->dma_channel_sel[i]) << (i * 4);
 	}
 	amba_writel(AHBSP_DMA_CHANNEL_SEL_REG, val);
 #endif
@@ -1174,6 +1185,15 @@ static int ambarella_dma_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, amb_dma);
 
+	if (np) {
+		ret = of_dma_controller_register(np, amb_dma_xlate, amb_dma);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to register controller\n");
+			goto ambdma_dma_probe_exit6;
+		}
+	}
+
 	dev_info(&pdev->dev, "Ambarella DMA Engine \n");
 
 	return 0;
@@ -1216,6 +1236,9 @@ static int ambarella_dma_remove(struct platform_device *pdev)
 		tasklet_kill(&amb_chan->tasklet);
 	}
 
+	if (pdev->dev.of_node)
+		of_dma_controller_free(pdev->dev.of_node);
+
 	dma_async_device_unregister(&amb_dma->dma_memcpy);
 	dma_async_device_unregister(&amb_dma->dma_slave);
 
@@ -1231,6 +1254,52 @@ static int ambarella_dma_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+#if (DMA_SUPPORT_SELECT_CHANNEL == 1)
+static u32 ambdma_chan_sel_val = 0;
+#endif
+static int ambarella_dma_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct ambdma_device *amb_dma = platform_get_drvdata(pdev);
+	struct ambdma_chan *amb_chan;
+	int i;
+
+	/* save dma channel register */
+	for (i = 0; i < NUM_DMA_CHANNELS; i++) {
+		amb_chan = &amb_dma->amb_chan[i];
+		amb_chan->ch_ctl = amba_readl(DMA_CHAN_CTR_REG(i));
+		amb_chan->ch_da = amba_readl(DMA_CHAN_DA_REG(i));
+		amb_chan->ch_sta = amba_readl(DMA_CHAN_STA_REG(i));
+	}
+#if (DMA_SUPPORT_SELECT_CHANNEL == 1)
+	ambdma_chan_sel_val = amba_readl(AHBSP_DMA_CHANNEL_SEL_REG);
+#endif
+	return 0;
+
+}
+
+static int ambarella_dma_resume(struct platform_device *pdev)
+{
+	struct ambdma_device *amb_dma = platform_get_drvdata(pdev);
+	struct ambdma_chan *amb_chan;
+	int i;
+
+#if (DMA_SUPPORT_SELECT_CHANNEL == 1)
+	amba_writel(AHBSP_DMA_CHANNEL_SEL_REG, ambdma_chan_sel_val);
+#endif
+	/* restore dma channel register */
+	for (i = 0; i < NUM_DMA_CHANNELS; i++) {
+		amb_chan = &amb_dma->amb_chan[i];
+		amba_writel(DMA_CHAN_STA_REG(i), amb_chan->ch_sta);
+		amba_writel(DMA_CHAN_DA_REG(i), amb_chan->ch_da);
+		amba_writel(DMA_CHAN_CTR_REG(i), amb_chan->ch_ctl);
+	}
+
+	return 0;
+}
+#endif
+
+
 static const struct of_device_id ambarella_dma_dt_ids[] = {
 	{.compatible = "ambarella,dma", },
 	{},
@@ -1240,7 +1309,10 @@ MODULE_DEVICE_TABLE(of, ambarella_dma_dt_ids);
 static struct platform_driver ambarella_dma_driver = {
 	.probe		= ambarella_dma_probe,
 	.remove		= ambarella_dma_remove,
-
+#ifdef CONFIG_PM
+	.suspend		= ambarella_dma_suspend,
+	.resume		= ambarella_dma_resume,
+#endif
 	.driver		= {
 		.name	= "ambarella-dma",
 		.owner	= THIS_MODULE,
diff --git a/drivers/dma/ambarella_dma.h b/drivers/dma/ambarella_dma.h
index bfaa217..5c82ba3 100644
--- a/drivers/dma/ambarella_dma.h
+++ b/drivers/dma/ambarella_dma.h
@@ -66,6 +66,9 @@ struct ambdma_chan {
 	dma_addr_t			rt_addr;
 	u32				rt_attr;
 	u32				force_stop;
+	u32				ch_ctl;
+	u32				ch_sta;
+	u32				ch_da;
 	enum ambdma_status		status;
 };
 
@@ -83,6 +86,10 @@ struct ambdma_device {
 	u32				copy_align;
 	/* support pause/resume/stop */
 	u32				support_prs : 1;
+	u32				nr_channels;
+	u32				dma_requests;
+	u32				dma_channel_type[NUM_DMA_CHANNELS];
+	u32				dma_channel_sel[NUM_DMA_CHANNELS];
 };
 
 
diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c
index d64ae14..43092c3 100644
--- a/drivers/dma/mv_xor.c
+++ b/drivers/dma/mv_xor.c
@@ -393,7 +393,8 @@ static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)
 	dma_cookie_t cookie = 0;
 	int busy = mv_chan_is_busy(mv_chan);
 	u32 current_desc = mv_chan_get_current_desc(mv_chan);
-	int seen_current = 0;
+	int current_cleaned = 0;
+	struct mv_xor_desc *hw_desc;
 
 	dev_dbg(mv_chan_to_devp(mv_chan), "%s %d\n", __func__, __LINE__);
 	dev_dbg(mv_chan_to_devp(mv_chan), "current_desc %x\n", current_desc);
@@ -405,38 +406,57 @@ static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)
 
 	list_for_each_entry_safe(iter, _iter, &mv_chan->chain,
 					chain_node) {
-		prefetch(_iter);
-		prefetch(&_iter->async_tx);
 
-		/* do not advance past the current descriptor loaded into the
-		 * hardware channel, subsequent descriptors are either in
-		 * process or have not been submitted
-		 */
-		if (seen_current)
-			break;
+		/* clean finished descriptors */
+		hw_desc = iter->hw_desc;
+		if (hw_desc->status & XOR_DESC_SUCCESS) {
+			cookie = mv_xor_run_tx_complete_actions(iter, mv_chan,
+								cookie);
 
-		/* stop the search if we reach the current descriptor and the
-		 * channel is busy
-		 */
-		if (iter->async_tx.phys == current_desc) {
-			seen_current = 1;
-			if (busy)
+			/* done processing desc, clean slot */
+			mv_xor_clean_slot(iter, mv_chan);
+
+			/* break if we did cleaned the current */
+			if (iter->async_tx.phys == current_desc) {
+				current_cleaned = 1;
+				break;
+			}
+		} else {
+			if (iter->async_tx.phys == current_desc) {
+				current_cleaned = 0;
 				break;
+			}
 		}
-
-		cookie = mv_xor_run_tx_complete_actions(iter, mv_chan, cookie);
-
-		if (mv_xor_clean_slot(iter, mv_chan))
-			break;
 	}
 
 	if ((busy == 0) && !list_empty(&mv_chan->chain)) {
-		struct mv_xor_desc_slot *chain_head;
-		chain_head = list_entry(mv_chan->chain.next,
-					struct mv_xor_desc_slot,
-					chain_node);
-
-		mv_xor_start_new_chain(mv_chan, chain_head);
+		if (current_cleaned) {
+			/*
+			 * current descriptor cleaned and removed, run
+			 * from list head
+			 */
+			iter = list_entry(mv_chan->chain.next,
+					  struct mv_xor_desc_slot,
+					  chain_node);
+			mv_xor_start_new_chain(mv_chan, iter);
+		} else {
+			if (!list_is_last(&iter->chain_node, &mv_chan->chain)) {
+				/*
+				 * descriptors are still waiting after
+				 * current, trigger them
+				 */
+				iter = list_entry(iter->chain_node.next,
+						  struct mv_xor_desc_slot,
+						  chain_node);
+				mv_xor_start_new_chain(mv_chan, iter);
+			} else {
+				/*
+				 * some descriptors are still waiting
+				 * to be cleaned
+				 */
+				tasklet_schedule(&mv_chan->irq_tasklet);
+			}
+		}
 	}
 
 	if (cookie > 0)
diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h
index c632a47..e003851 100644
--- a/drivers/dma/mv_xor.h
+++ b/drivers/dma/mv_xor.h
@@ -32,6 +32,7 @@
 #define XOR_OPERATION_MODE_XOR		0
 #define XOR_OPERATION_MODE_MEMCPY	2
 #define XOR_OPERATION_MODE_MEMSET	4
+#define XOR_DESC_SUCCESS		0x40000000
 
 #define XOR_CURR_DESC(chan)	(chan->mmr_base + 0x210 + (chan->idx * 4))
 #define XOR_NEXT_DESC(chan)	(chan->mmr_base + 0x200 + (chan->idx * 4))
diff --git a/drivers/dma/omap-dma.c b/drivers/dma/omap-dma.c
index ec3fc4f..b94a376 100644
--- a/drivers/dma/omap-dma.c
+++ b/drivers/dma/omap-dma.c
@@ -487,6 +487,7 @@ static int omap_dma_terminate_all(struct omap_chan *c)
 	 * c->desc is NULL and exit.)
 	 */
 	if (c->desc) {
+		omap_dma_desc_free(&c->desc->vd);
 		c->desc = NULL;
 		/* Avoid stopping the dma twice */
 		if (!c->paused)
diff --git a/drivers/edac/amd64_edac.c b/drivers/edac/amd64_edac.c
index 8b3d901..19353112 100644
--- a/drivers/edac/amd64_edac.c
+++ b/drivers/edac/amd64_edac.c
@@ -1266,7 +1266,7 @@ static u64 f1x_get_norm_dct_addr(struct amd64_pvt *pvt, u8 range,
 	u64 chan_off;
 	u64 dram_base		= get_dram_base(pvt, range);
 	u64 hole_off		= f10_dhar_offset(pvt);
-	u64 dct_sel_base_off	= (pvt->dct_sel_hi & 0xFFFFFC00) << 16;
+	u64 dct_sel_base_off	= (u64)(pvt->dct_sel_hi & 0xFFFFFC00) << 16;
 
 	if (hi_rng) {
 		/*
diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c
index 88cd940..453c816 100644
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@ -973,21 +973,26 @@ nomem:
  */
 int edac_create_sysfs_mci_device(struct mem_ctl_info *mci)
 {
+	char *name;
 	int i, err;
 
 	/*
 	 * The memory controller needs its own bus, in order to avoid
 	 * namespace conflicts at /sys/bus/edac.
 	 */
-	mci->bus->name = kasprintf(GFP_KERNEL, "mc%d", mci->mc_idx);
-	if (!mci->bus->name)
+	name = kasprintf(GFP_KERNEL, "mc%d", mci->mc_idx);
+	if (!name)
 		return -ENOMEM;
 
+	mci->bus->name = name;
+
 	edac_dbg(0, "creating bus %s\n", mci->bus->name);
 
 	err = bus_register(mci->bus);
-	if (err < 0)
+	if (err < 0) {
+		kfree(name);
 		return err;
+	}
 
 	/* get the /sys/devices/system/edac subsys reference */
 	mci->dev.type = &mci_attr_type;
@@ -1071,7 +1076,8 @@ fail:
 fail2:
 	device_unregister(&mci->dev);
 	bus_unregister(mci->bus);
-	kfree(mci->bus->name);
+	kfree(name);
+
 	return err;
 }
 
@@ -1102,10 +1108,12 @@ void edac_remove_sysfs_mci_device(struct mem_ctl_info *mci)
 
 void edac_unregister_sysfs(struct mem_ctl_info *mci)
 {
+	const char *name = mci->bus->name;
+
 	edac_dbg(1, "Unregistering device %s\n", dev_name(&mci->dev));
 	device_unregister(&mci->dev);
 	bus_unregister(mci->bus);
-	kfree(mci->bus->name);
+	kfree(name);
 }
 
 static void mc_attr_release(struct device *dev)
diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 271818a..c4131a7 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1878,7 +1878,7 @@ static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,
 
 	i7_dev = get_i7core_dev(mce->socketid);
 	if (!i7_dev)
-		return NOTIFY_BAD;
+		return NOTIFY_DONE;
 
 	mci = i7_dev->mci;
 	pvt = mci->pvt_info;
diff --git a/drivers/edac/ppc4xx_edac.c b/drivers/edac/ppc4xx_edac.c
index ef6b7e0..5c361f3 100644
--- a/drivers/edac/ppc4xx_edac.c
+++ b/drivers/edac/ppc4xx_edac.c
@@ -921,7 +921,7 @@ static int ppc4xx_edac_init_csrows(struct mem_ctl_info *mci, u32 mcopt1)
 	 */
 
 	for (row = 0; row < mci->nr_csrows; row++) {
-		struct csrow_info *csi = &mci->csrows[row];
+		struct csrow_info *csi = mci->csrows[row];
 
 		/*
 		 * Get the configuration settings for this
diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c
index e04462b..0d40f7f 100644
--- a/drivers/edac/sb_edac.c
+++ b/drivers/edac/sb_edac.c
@@ -270,8 +270,9 @@ static const u32 correrrthrsld[] = {
  * sbridge structs
  */
 
-#define NUM_CHANNELS	4
-#define MAX_DIMMS	3		/* Max DIMMS per channel */
+#define NUM_CHANNELS		4
+#define MAX_DIMMS		3	/* Max DIMMS per channel */
+#define CHANNEL_UNSPECIFIED	0xf	/* Intel IA32 SDM 15-14 */
 
 struct sbridge_info {
 	u32	mcmtr;
@@ -622,7 +623,7 @@ static void get_memory_layout(const struct mem_ctl_info *mci)
 	u32 reg;
 	u64 limit, prv = 0;
 	u64 tmp_mb;
-	u32 mb, kb;
+	u32 gb, mb;
 	u32 rir_way;
 
 	/*
@@ -635,8 +636,9 @@ static void get_memory_layout(const struct mem_ctl_info *mci)
 	pvt->tolm = GET_TOLM(reg);
 	tmp_mb = (1 + pvt->tolm) >> 20;
 
-	mb = div_u64_rem(tmp_mb, 1000, &kb);
-	edac_dbg(0, "TOLM: %u.%03u GB (0x%016Lx)\n", mb, kb, (u64)pvt->tolm);
+	gb = div_u64_rem(tmp_mb, 1024, &mb);
+	edac_dbg(0, "TOLM: %u.%03u GB (0x%016Lx)\n",
+		gb, (mb*1000)/1024, (u64)pvt->tolm);
 
 	/* Address range is already 45:25 */
 	pci_read_config_dword(pvt->pci_sad1, TOHM,
@@ -644,8 +646,9 @@ static void get_memory_layout(const struct mem_ctl_info *mci)
 	pvt->tohm = GET_TOHM(reg);
 	tmp_mb = (1 + pvt->tohm) >> 20;
 
-	mb = div_u64_rem(tmp_mb, 1000, &kb);
-	edac_dbg(0, "TOHM: %u.%03u GB (0x%016Lx)\n", mb, kb, (u64)pvt->tohm);
+	gb = div_u64_rem(tmp_mb, 1024, &mb);
+	edac_dbg(0, "TOHM: %u.%03u GB (0x%016Lx)\n",
+		gb, (mb*1000)/1024, (u64)pvt->tohm);
 
 	/*
 	 * Step 2) Get SAD range and SAD Interleave list
@@ -667,11 +670,11 @@ static void get_memory_layout(const struct mem_ctl_info *mci)
 			break;
 
 		tmp_mb = (limit + 1) >> 20;
-		mb = div_u64_rem(tmp_mb, 1000, &kb);
+		gb = div_u64_rem(tmp_mb, 1024, &mb);
 		edac_dbg(0, "SAD#%d %s up to %u.%03u GB (0x%016Lx) Interleave: %s reg=0x%08x\n",
 			 n_sads,
 			 get_dram_attr(reg),
-			 mb, kb,
+			 gb, (mb*1000)/1024,
 			 ((u64)tmp_mb) << 20L,
 			 INTERLEAVE_MODE(reg) ? "8:6" : "[8:6]XOR[18:16]",
 			 reg);
@@ -701,9 +704,9 @@ static void get_memory_layout(const struct mem_ctl_info *mci)
 			break;
 		tmp_mb = (limit + 1) >> 20;
 
-		mb = div_u64_rem(tmp_mb, 1000, &kb);
+		gb = div_u64_rem(tmp_mb, 1024, &mb);
 		edac_dbg(0, "TAD#%d: up to %u.%03u GB (0x%016Lx), socket interleave %d, memory interleave %d, TGT: %d, %d, %d, %d, reg=0x%08x\n",
-			 n_tads, mb, kb,
+			 n_tads, gb, (mb*1000)/1024,
 			 ((u64)tmp_mb) << 20L,
 			 (u32)TAD_SOCK(reg),
 			 (u32)TAD_CH(reg),
@@ -726,10 +729,10 @@ static void get_memory_layout(const struct mem_ctl_info *mci)
 					      tad_ch_nilv_offset[j],
 					      &reg);
 			tmp_mb = TAD_OFFSET(reg) >> 20;
-			mb = div_u64_rem(tmp_mb, 1000, &kb);
+			gb = div_u64_rem(tmp_mb, 1024, &mb);
 			edac_dbg(0, "TAD CH#%d, offset #%d: %u.%03u GB (0x%016Lx), reg=0x%08x\n",
 				 i, j,
-				 mb, kb,
+				 gb, (mb*1000)/1024,
 				 ((u64)tmp_mb) << 20L,
 				 reg);
 		}
@@ -751,10 +754,10 @@ static void get_memory_layout(const struct mem_ctl_info *mci)
 
 			tmp_mb = RIR_LIMIT(reg) >> 20;
 			rir_way = 1 << RIR_WAY(reg);
-			mb = div_u64_rem(tmp_mb, 1000, &kb);
+			gb = div_u64_rem(tmp_mb, 1024, &mb);
 			edac_dbg(0, "CH#%d RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d, reg=0x%08x\n",
 				 i, j,
-				 mb, kb,
+				 gb, (mb*1000)/1024,
 				 ((u64)tmp_mb) << 20L,
 				 rir_way,
 				 reg);
@@ -765,10 +768,10 @@ static void get_memory_layout(const struct mem_ctl_info *mci)
 						      &reg);
 				tmp_mb = RIR_OFFSET(reg) << 6;
 
-				mb = div_u64_rem(tmp_mb, 1000, &kb);
+				gb = div_u64_rem(tmp_mb, 1024, &mb);
 				edac_dbg(0, "CH#%d RIR#%d INTL#%d, offset %u.%03u GB (0x%016Lx), tgt: %d, reg=0x%08x\n",
 					 i, j, k,
-					 mb, kb,
+					 gb, (mb*1000)/1024,
 					 ((u64)tmp_mb) << 20L,
 					 (u32)RIR_RNK_TGT(reg),
 					 reg);
@@ -805,7 +808,7 @@ static int get_memory_error_data(struct mem_ctl_info *mci,
 	u8			ch_way,sck_way;
 	u32			tad_offset;
 	u32			rir_way;
-	u32			mb, kb;
+	u32			mb, gb;
 	u64			ch_addr, offset, limit, prv = 0;
 
 
@@ -1021,10 +1024,10 @@ static int get_memory_error_data(struct mem_ctl_info *mci,
 			continue;
 
 		limit = RIR_LIMIT(reg);
-		mb = div_u64_rem(limit >> 20, 1000, &kb);
+		gb = div_u64_rem(limit >> 20, 1024, &mb);
 		edac_dbg(0, "RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d\n",
 			 n_rir,
-			 mb, kb,
+			 gb, (mb*1000)/1024,
 			 limit,
 			 1 << RIR_WAY(reg));
 		if  (ch_addr <= limit)
@@ -1451,6 +1454,9 @@ static void sbridge_mce_output_error(struct mem_ctl_info *mci,
 
 	/* FIXME: need support for channel mask */
 
+	if (channel == CHANNEL_UNSPECIFIED)
+		channel = -1;
+
 	/* Call the helper to output message */
 	edac_mc_handle_error(tp_event, mci, core_err_cnt,
 			     m->addr >> PAGE_SHIFT, m->addr & ~PAGE_MASK, 0,
@@ -1532,7 +1538,7 @@ static int sbridge_mce_check_error(struct notifier_block *nb, unsigned long val,
 
 	mci = get_mci_for_node_id(mce->socketid);
 	if (!mci)
-		return NOTIFY_BAD;
+		return NOTIFY_DONE;
 	pvt = mci->pvt_info;
 
 	/*
diff --git a/drivers/firewire/ohci.c b/drivers/firewire/ohci.c
index 0f3e304..14ca13a 100644
--- a/drivers/firewire/ohci.c
+++ b/drivers/firewire/ohci.c
@@ -3670,6 +3670,11 @@ static int pci_probe(struct pci_dev *dev,
 
 	reg_write(ohci, OHCI1394_IsoXmitIntMaskSet, ~0);
 	ohci->it_context_support = reg_read(ohci, OHCI1394_IsoXmitIntMaskSet);
+	/* JMicron JMB38x often shows 0 at first read, just ignore it */
+	if (!ohci->it_context_support) {
+		ohci_notice(ohci, "overriding IsoXmitIntMask\n");
+		ohci->it_context_support = 0xf;
+	}
 	reg_write(ohci, OHCI1394_IsoXmitIntMaskClear, ~0);
 	ohci->it_context_mask = ohci->it_context_support;
 	ohci->n_it = hweight32(ohci->it_context_mask);
diff --git a/drivers/firmware/efi/efivars.c b/drivers/firmware/efi/efivars.c
index 8bd1bb6..24ae2a6 100644
--- a/drivers/firmware/efi/efivars.c
+++ b/drivers/firmware/efi/efivars.c
@@ -219,7 +219,8 @@ efivar_store_raw(struct efivar_entry *entry, const char *buf, size_t count)
 	}
 
 	if ((new_var->Attributes & ~EFI_VARIABLE_MASK) != 0 ||
-	    efivar_validate(new_var, new_var->Data, new_var->DataSize) == false) {
+	    efivar_validate(new_var->VendorGuid, new_var->VariableName,
+			    new_var->Data, new_var->DataSize) == false) {
 		printk(KERN_ERR "efivars: Malformed variable content\n");
 		return -EINVAL;
 	}
@@ -334,7 +335,8 @@ static ssize_t efivar_create(struct file *filp, struct kobject *kobj,
 		return -EACCES;
 
 	if ((new_var->Attributes & ~EFI_VARIABLE_MASK) != 0 ||
-	    efivar_validate(new_var, new_var->Data, new_var->DataSize) == false) {
+	    efivar_validate(new_var->VendorGuid, new_var->VariableName,
+			    new_var->Data, new_var->DataSize) == false) {
 		printk(KERN_ERR "efivars: Malformed variable content\n");
 		return -EINVAL;
 	}
@@ -405,35 +407,27 @@ efivar_create_sysfs_entry(struct efivar_entry *new_var)
 {
 	int i, short_name_size;
 	char *short_name;
-	unsigned long variable_name_size;
-	efi_char16_t *variable_name;
-
-	variable_name = new_var->var.VariableName;
-	variable_name_size = ucs2_strlen(variable_name) * sizeof(efi_char16_t);
+	unsigned long utf8_name_size;
+	efi_char16_t *variable_name = new_var->var.VariableName;
 
 	/*
-	 * Length of the variable bytes in ASCII, plus the '-' separator,
+	 * Length of the variable bytes in UTF8, plus the '-' separator,
 	 * plus the GUID, plus trailing NUL
 	 */
-	short_name_size = variable_name_size / sizeof(efi_char16_t)
-				+ 1 + EFI_VARIABLE_GUID_LEN + 1;
-
-	short_name = kzalloc(short_name_size, GFP_KERNEL);
+	utf8_name_size = ucs2_utf8size(variable_name);
+	short_name_size = utf8_name_size + 1 + EFI_VARIABLE_GUID_LEN + 1;
 
+	short_name = kmalloc(short_name_size, GFP_KERNEL);
 	if (!short_name)
 		return 1;
 
-	/* Convert Unicode to normal chars (assume top bits are 0),
-	   ala UTF-8 */
-	for (i=0; i < (int)(variable_name_size / sizeof(efi_char16_t)); i++) {
-		short_name[i] = variable_name[i] & 0xFF;
-	}
+	ucs2_as_utf8(short_name, variable_name, short_name_size);
+
 	/* This is ugly, but necessary to separate one vendor's
 	   private variables from another's.         */
-
-	*(short_name + strlen(short_name)) = '-';
+	short_name[utf8_name_size] = '-';
 	efi_guid_unparse(&new_var->var.VendorGuid,
-			 short_name + strlen(short_name));
+			 short_name + utf8_name_size + 1);
 
 	new_var->kobj.kset = efivars_kset;
 
diff --git a/drivers/firmware/efi/vars.c b/drivers/firmware/efi/vars.c
index 7dbc319..61e7ec5 100644
--- a/drivers/firmware/efi/vars.c
+++ b/drivers/firmware/efi/vars.c
@@ -42,7 +42,7 @@ DECLARE_WORK(efivar_work, NULL);
 EXPORT_SYMBOL_GPL(efivar_work);
 
 static bool
-validate_device_path(struct efi_variable *var, int match, u8 *buffer,
+validate_device_path(efi_char16_t *var_name, int match, u8 *buffer,
 		     unsigned long len)
 {
 	struct efi_generic_dev_path *node;
@@ -75,7 +75,7 @@ validate_device_path(struct efi_variable *var, int match, u8 *buffer,
 }
 
 static bool
-validate_boot_order(struct efi_variable *var, int match, u8 *buffer,
+validate_boot_order(efi_char16_t *var_name, int match, u8 *buffer,
 		    unsigned long len)
 {
 	/* An array of 16-bit integers */
@@ -86,18 +86,18 @@ validate_boot_order(struct efi_variable *var, int match, u8 *buffer,
 }
 
 static bool
-validate_load_option(struct efi_variable *var, int match, u8 *buffer,
+validate_load_option(efi_char16_t *var_name, int match, u8 *buffer,
 		     unsigned long len)
 {
 	u16 filepathlength;
 	int i, desclength = 0, namelen;
 
-	namelen = ucs2_strnlen(var->VariableName, sizeof(var->VariableName));
+	namelen = ucs2_strnlen(var_name, EFI_VAR_NAME_LEN);
 
 	/* Either "Boot" or "Driver" followed by four digits of hex */
 	for (i = match; i < match+4; i++) {
-		if (var->VariableName[i] > 127 ||
-		    hex_to_bin(var->VariableName[i] & 0xff) < 0)
+		if (var_name[i] > 127 ||
+		    hex_to_bin(var_name[i] & 0xff) < 0)
 			return true;
 	}
 
@@ -132,12 +132,12 @@ validate_load_option(struct efi_variable *var, int match, u8 *buffer,
 	/*
 	 * And, finally, check the filepath
 	 */
-	return validate_device_path(var, match, buffer + desclength + 6,
+	return validate_device_path(var_name, match, buffer + desclength + 6,
 				    filepathlength);
 }
 
 static bool
-validate_uint16(struct efi_variable *var, int match, u8 *buffer,
+validate_uint16(efi_char16_t *var_name, int match, u8 *buffer,
 		unsigned long len)
 {
 	/* A single 16-bit integer */
@@ -148,7 +148,7 @@ validate_uint16(struct efi_variable *var, int match, u8 *buffer,
 }
 
 static bool
-validate_ascii_string(struct efi_variable *var, int match, u8 *buffer,
+validate_ascii_string(efi_char16_t *var_name, int match, u8 *buffer,
 		      unsigned long len)
 {
 	int i;
@@ -165,67 +165,148 @@ validate_ascii_string(struct efi_variable *var, int match, u8 *buffer,
 }
 
 struct variable_validate {
+	efi_guid_t vendor;
 	char *name;
-	bool (*validate)(struct efi_variable *var, int match, u8 *data,
+	bool (*validate)(efi_char16_t *var_name, int match, u8 *data,
 			 unsigned long len);
 };
 
+/*
+ * This is the list of variables we need to validate, as well as the
+ * whitelist for what we think is safe not to default to immutable.
+ *
+ * If it has a validate() method that's not NULL, it'll go into the
+ * validation routine.  If not, it is assumed valid, but still used for
+ * whitelisting.
+ *
+ * Note that it's sorted by {vendor,name}, but globbed names must come after
+ * any other name with the same prefix.
+ */
 static const struct variable_validate variable_validate[] = {
-	{ "BootNext", validate_uint16 },
-	{ "BootOrder", validate_boot_order },
-	{ "DriverOrder", validate_boot_order },
-	{ "Boot*", validate_load_option },
-	{ "Driver*", validate_load_option },
-	{ "ConIn", validate_device_path },
-	{ "ConInDev", validate_device_path },
-	{ "ConOut", validate_device_path },
-	{ "ConOutDev", validate_device_path },
-	{ "ErrOut", validate_device_path },
-	{ "ErrOutDev", validate_device_path },
-	{ "Timeout", validate_uint16 },
-	{ "Lang", validate_ascii_string },
-	{ "PlatformLang", validate_ascii_string },
-	{ "", NULL },
+	{ EFI_GLOBAL_VARIABLE_GUID, "BootNext", validate_uint16 },
+	{ EFI_GLOBAL_VARIABLE_GUID, "BootOrder", validate_boot_order },
+	{ EFI_GLOBAL_VARIABLE_GUID, "Boot*", validate_load_option },
+	{ EFI_GLOBAL_VARIABLE_GUID, "DriverOrder", validate_boot_order },
+	{ EFI_GLOBAL_VARIABLE_GUID, "Driver*", validate_load_option },
+	{ EFI_GLOBAL_VARIABLE_GUID, "ConIn", validate_device_path },
+	{ EFI_GLOBAL_VARIABLE_GUID, "ConInDev", validate_device_path },
+	{ EFI_GLOBAL_VARIABLE_GUID, "ConOut", validate_device_path },
+	{ EFI_GLOBAL_VARIABLE_GUID, "ConOutDev", validate_device_path },
+	{ EFI_GLOBAL_VARIABLE_GUID, "ErrOut", validate_device_path },
+	{ EFI_GLOBAL_VARIABLE_GUID, "ErrOutDev", validate_device_path },
+	{ EFI_GLOBAL_VARIABLE_GUID, "Lang", validate_ascii_string },
+	{ EFI_GLOBAL_VARIABLE_GUID, "OsIndications", NULL },
+	{ EFI_GLOBAL_VARIABLE_GUID, "PlatformLang", validate_ascii_string },
+	{ EFI_GLOBAL_VARIABLE_GUID, "Timeout", validate_uint16 },
+	{ LINUX_EFI_CRASH_GUID, "*", NULL },
+	{ NULL_GUID, "", NULL },
 };
 
+/*
+ * Check if @var_name matches the pattern given in @match_name.
+ *
+ * @var_name: an array of @len non-NUL characters.
+ * @match_name: a NUL-terminated pattern string, optionally ending in "*". A
+ *              final "*" character matches any trailing characters @var_name,
+ *              including the case when there are none left in @var_name.
+ * @match: on output, the number of non-wildcard characters in @match_name
+ *         that @var_name matches, regardless of the return value.
+ * @return: whether @var_name fully matches @match_name.
+ */
+static bool
+variable_matches(const char *var_name, size_t len, const char *match_name,
+		 int *match)
+{
+	for (*match = 0; ; (*match)++) {
+		char c = match_name[*match];
+
+		switch (c) {
+		case '*':
+			/* Wildcard in @match_name means we've matched. */
+			return true;
+
+		case '\0':
+			/* @match_name has ended. Has @var_name too? */
+			return (*match == len);
+
+		default:
+			/*
+			 * We've reached a non-wildcard char in @match_name.
+			 * Continue only if there's an identical character in
+			 * @var_name.
+			 */
+			if (*match < len && c == var_name[*match])
+				continue;
+			return false;
+		}
+	}
+}
+
 bool
-efivar_validate(struct efi_variable *var, u8 *data, unsigned long len)
+efivar_validate(efi_guid_t vendor, efi_char16_t *var_name, u8 *data,
+		unsigned long data_size)
 {
 	int i;
-	u16 *unicode_name = var->VariableName;
+	unsigned long utf8_size;
+	u8 *utf8_name;
 
-	for (i = 0; variable_validate[i].validate != NULL; i++) {
-		const char *name = variable_validate[i].name;
-		int match;
+	utf8_size = ucs2_utf8size(var_name);
+	utf8_name = kmalloc(utf8_size + 1, GFP_KERNEL);
+	if (!utf8_name)
+		return false;
 
-		for (match = 0; ; match++) {
-			char c = name[match];
-			u16 u = unicode_name[match];
+	ucs2_as_utf8(utf8_name, var_name, utf8_size);
+	utf8_name[utf8_size] = '\0';
 
-			/* All special variables are plain ascii */
-			if (u > 127)
-				return true;
+	for (i = 0; variable_validate[i].name[0] != '\0'; i++) {
+		const char *name = variable_validate[i].name;
+		int match = 0;
 
-			/* Wildcard in the matching name means we've matched */
-			if (c == '*')
-				return variable_validate[i].validate(var,
-							     match, data, len);
+		if (efi_guidcmp(vendor, variable_validate[i].vendor))
+			continue;
 
-			/* Case sensitive match */
-			if (c != u)
+		if (variable_matches(utf8_name, utf8_size+1, name, &match)) {
+			if (variable_validate[i].validate == NULL)
 				break;
-
-			/* Reached the end of the string while matching */
-			if (!c)
-				return variable_validate[i].validate(var,
-							     match, data, len);
+			kfree(utf8_name);
+			return variable_validate[i].validate(var_name, match,
+							     data, data_size);
 		}
 	}
-
+	kfree(utf8_name);
 	return true;
 }
 EXPORT_SYMBOL_GPL(efivar_validate);
 
+bool
+efivar_variable_is_removable(efi_guid_t vendor, const char *var_name,
+			     size_t len)
+{
+	int i;
+	bool found = false;
+	int match = 0;
+
+	/*
+	 * Check if our variable is in the validated variables list
+	 */
+	for (i = 0; variable_validate[i].name[0] != '\0'; i++) {
+		if (efi_guidcmp(variable_validate[i].vendor, vendor))
+			continue;
+
+		if (variable_matches(var_name, len,
+				     variable_validate[i].name, &match)) {
+			found = true;
+			break;
+		}
+	}
+
+	/*
+	 * If it's in our list, it is removable.
+	 */
+	return found;
+}
+EXPORT_SYMBOL_GPL(efivar_variable_is_removable);
+
 static efi_status_t
 check_var_size(u32 attributes, unsigned long size)
 {
@@ -797,7 +878,7 @@ int efivar_entry_set_get_size(struct efivar_entry *entry, u32 attributes,
 
 	*set = false;
 
-	if (efivar_validate(&entry->var, data, *size) == false)
+	if (efivar_validate(*vendor, name, data, *size) == false)
 		return -EINVAL;
 
 	/*
diff --git a/drivers/gpio/gpio-ambarella.c b/drivers/gpio/gpio-ambarella.c
index 68fdd82..997226a 100644
--- a/drivers/gpio/gpio-ambarella.c
+++ b/drivers/gpio/gpio-ambarella.c
@@ -32,8 +32,8 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/irqchip/chained_irq.h>
+#include <plat/iav_helper.h>
 #include <plat/pinctrl.h>
-#include <plat/service.h>
 
 #if defined(CONFIG_PM)
 struct amb_gpio_regs {
@@ -225,8 +225,29 @@ static struct gpio_chip amb_gc = {
 
 static void amb_gpio_irq_enable(struct irq_data *data)
 {
+	struct amb_gpio_chip *amb_gpio = dev_get_drvdata(amb_gc.dev);
 	void __iomem *regbase = irq_data_get_irq_chip_data(data);
-	u32 offset = PINID_TO_OFFSET(data->hwirq);
+	void __iomem *iomux_base = amb_gpio->iomux_base;
+	u32 i, bank, offset, val;
+
+	bank = PINID_TO_BANK(data->hwirq);
+	offset = PINID_TO_OFFSET(data->hwirq);
+
+	/* make sure the pin is in gpio input mode */
+	if (!gpiochip_is_requested(&amb_gc, data->hwirq)) {
+		amba_clrbitsl(regbase + GPIO_AFSEL_OFFSET, 0x1 << offset);
+		amba_clrbitsl(regbase + GPIO_DIR_OFFSET, 0x1 << offset);
+
+		if (iomux_base) {
+			for (i = 0; i < 3; i++) {
+				val = amba_readl(iomux_base + IOMUX_REG_OFFSET(bank, i));
+				val &= (~(0x1 << offset));
+				amba_writel(iomux_base + IOMUX_REG_OFFSET(bank, i), val);
+			}
+			amba_writel(iomux_base + IOMUX_CTRL_SET_OFFSET, 0x1);
+			amba_writel(iomux_base + IOMUX_CTRL_SET_OFFSET, 0x0);
+		}
+	}
 
 	amba_writel(regbase + GPIO_IC_OFFSET, 0x1 << offset);
 	amba_setbitsl(regbase + GPIO_IE_OFFSET, 0x1 << offset);
diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c
index 426c51d..ac11e45 100644
--- a/drivers/gpio/gpio-pca953x.c
+++ b/drivers/gpio/gpio-pca953x.c
@@ -75,7 +75,7 @@ MODULE_DEVICE_TABLE(i2c, pca953x_id);
 #define MAX_BANK 5
 #define BANK_SZ 8
 
-#define NBANK(chip) (chip->gpio_chip.ngpio / BANK_SZ)
+#define NBANK(chip) DIV_ROUND_UP(chip->gpio_chip.ngpio, BANK_SZ)
 
 struct pca953x_chip {
 	unsigned gpio_start;
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index ca1cb2d7..c3768fa 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -752,6 +752,7 @@ static struct class gpio_class = {
  */
 static int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
 {
+	struct gpio_chip	*chip;
 	unsigned long		flags;
 	int			status;
 	const char		*ioname = NULL;
@@ -769,8 +770,16 @@ static int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
 		return -EINVAL;
 	}
 
+	chip = desc->chip;
+
 	mutex_lock(&sysfs_lock);
 
+	/* check if chip is being removed */
+	if (!chip || !chip->exported) {
+		status = -ENODEV;
+		goto fail_unlock;
+	}
+
 	spin_lock_irqsave(&gpio_lock, flags);
 	if (!test_bit(FLAG_REQUESTED, &desc->flags) ||
 	     test_bit(FLAG_EXPORT, &desc->flags)) {
@@ -1040,6 +1049,8 @@ static void gpiochip_unexport(struct gpio_chip *chip)
 {
 	int			status;
 	struct device		*dev;
+	struct gpio_desc *desc;
+	unsigned int i;
 
 	mutex_lock(&sysfs_lock);
 	dev = class_find_device(&gpio_class, NULL, chip, match_export);
@@ -1047,6 +1058,7 @@ static void gpiochip_unexport(struct gpio_chip *chip)
 		sysfs_remove_group(&dev->kobj, &gpiochip_attr_group);
 		put_device(dev);
 		device_unregister(dev);
+		/* prevent further gpiod exports */
 		chip->exported = 0;
 		status = 0;
 	} else
@@ -1056,6 +1068,13 @@ static void gpiochip_unexport(struct gpio_chip *chip)
 	if (status)
 		pr_debug("%s: chip %s status %d\n", __func__,
 				chip->label, status);
+
+	/* unregister gpiod class devices owned by sysfs */
+	for (i = 0; i < chip->ngpio; i++) {
+		desc = &chip->desc[i];
+		if (test_and_clear_bit(FLAG_SYSFS, &desc->flags))
+			gpiod_free(desc);
+	}
 }
 
 static int __init gpiolib_sysfs_init(void)
@@ -1265,6 +1284,8 @@ int gpiochip_remove(struct gpio_chip *chip)
 	int		status = 0;
 	unsigned	id;
 
+	gpiochip_unexport(chip);
+
 	spin_lock_irqsave(&gpio_lock, flags);
 
 	gpiochip_remove_pin_ranges(chip);
@@ -1285,9 +1306,6 @@ int gpiochip_remove(struct gpio_chip *chip)
 
 	spin_unlock_irqrestore(&gpio_lock, flags);
 
-	if (status == 0)
-		gpiochip_unexport(chip);
-
 	return status;
 }
 EXPORT_SYMBOL_GPL(gpiochip_remove);
diff --git a/drivers/gpu/drm/ast/ast_drv.h b/drivers/gpu/drm/ast/ast_drv.h
index b6b7d70..5cfc176 100644
--- a/drivers/gpu/drm/ast/ast_drv.h
+++ b/drivers/gpu/drm/ast/ast_drv.h
@@ -296,6 +296,7 @@ int ast_framebuffer_init(struct drm_device *dev,
 int ast_fbdev_init(struct drm_device *dev);
 void ast_fbdev_fini(struct drm_device *dev);
 void ast_fbdev_set_suspend(struct drm_device *dev, int state);
+void ast_fbdev_set_base(struct ast_private *ast, unsigned long gpu_addr);
 
 struct ast_bo {
 	struct ttm_buffer_object bo;
diff --git a/drivers/gpu/drm/ast/ast_fb.c b/drivers/gpu/drm/ast/ast_fb.c
index fbc0823..a298d8f 100644
--- a/drivers/gpu/drm/ast/ast_fb.c
+++ b/drivers/gpu/drm/ast/ast_fb.c
@@ -366,3 +366,10 @@ void ast_fbdev_set_suspend(struct drm_device *dev, int state)
 
 	fb_set_suspend(ast->fbdev->helper.fbdev, state);
 }
+
+void ast_fbdev_set_base(struct ast_private *ast, unsigned long gpu_addr)
+{
+	ast->fbdev->helper.fbdev->fix.smem_start =
+		ast->fbdev->helper.fbdev->apertures->ranges[0].base + gpu_addr;
+	ast->fbdev->helper.fbdev->fix.smem_len = ast->vram_size - gpu_addr;
+}
diff --git a/drivers/gpu/drm/ast/ast_main.c b/drivers/gpu/drm/ast/ast_main.c
index 96f874a..6283432 100644
--- a/drivers/gpu/drm/ast/ast_main.c
+++ b/drivers/gpu/drm/ast/ast_main.c
@@ -124,7 +124,7 @@ static int ast_get_dram_info(struct drm_device *dev)
 	} while (ast_read32(ast, 0x10000) != 0x01);
 	data = ast_read32(ast, 0x10004);
 
-	if (data & 0x400)
+	if (data & 0x40)
 		ast->dram_bus_width = 16;
 	else
 		ast->dram_bus_width = 32;
@@ -359,6 +359,7 @@ int ast_driver_load(struct drm_device *dev, unsigned long flags)
 	dev->mode_config.min_height = 0;
 	dev->mode_config.preferred_depth = 24;
 	dev->mode_config.prefer_shadow = 1;
+	dev->mode_config.fb_base = pci_resource_start(ast->dev->pdev, 0);
 
 	if (ast->chip == AST2100 ||
 	    ast->chip == AST2200 ||
diff --git a/drivers/gpu/drm/ast/ast_mode.c b/drivers/gpu/drm/ast/ast_mode.c
index e8f6418..f3a54ad 100644
--- a/drivers/gpu/drm/ast/ast_mode.c
+++ b/drivers/gpu/drm/ast/ast_mode.c
@@ -509,6 +509,8 @@ static int ast_crtc_do_set_base(struct drm_crtc *crtc,
 		ret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &bo->kmap);
 		if (ret)
 			DRM_ERROR("failed to kmap fbcon\n");
+		else
+			ast_fbdev_set_base(ast, gpu_addr);
 	}
 	ast_bo_unreserve(bo);
 
diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
index 8759d69..c24c356 100644
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@ -1955,8 +1955,11 @@ int drm_mode_setcrtc(struct drm_device *dev, void *data,
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
 		return -EINVAL;
 
-	/* For some reason crtc x/y offsets are signed internally. */
-	if (crtc_req->x > INT_MAX || crtc_req->y > INT_MAX)
+	/*
+	 * Universal plane src offsets are only 16.16, prevent havoc for
+	 * drivers using universal plane code internally.
+	 */
+	if (crtc_req->x & 0xffff0000 || crtc_req->y & 0xffff0000)
 		return -ERANGE;
 
 	drm_modeset_lock_all(dev);
diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c
index b78cbe7..93b7410 100644
--- a/drivers/gpu/drm/drm_fb_helper.c
+++ b/drivers/gpu/drm/drm_fb_helper.c
@@ -1313,7 +1313,6 @@ static int drm_pick_crtcs(struct drm_fb_helper *fb_helper,
 			  int n, int width, int height)
 {
 	int c, o;
-	struct drm_device *dev = fb_helper->dev;
 	struct drm_connector *connector;
 	struct drm_connector_helper_funcs *connector_funcs;
 	struct drm_encoder *encoder;
@@ -1334,7 +1333,7 @@ static int drm_pick_crtcs(struct drm_fb_helper *fb_helper,
 	if (modes[n] == NULL)
 		return best_score;
 
-	crtcs = kzalloc(dev->mode_config.num_connector *
+	crtcs = kzalloc(fb_helper->connector_count *
 			sizeof(struct drm_fb_helper_crtc *), GFP_KERNEL);
 	if (!crtcs)
 		return best_score;
@@ -1381,7 +1380,7 @@ static int drm_pick_crtcs(struct drm_fb_helper *fb_helper,
 			best_crtc = crtc;
 			best_score = score;
 			memcpy(best_crtcs, crtcs,
-			       dev->mode_config.num_connector *
+			       fb_helper->connector_count *
 			       sizeof(struct drm_fb_helper_crtc *));
 		}
 	}
diff --git a/drivers/gpu/drm/drm_lock.c b/drivers/gpu/drm/drm_lock.c
index d752c96..bdceb60 100644
--- a/drivers/gpu/drm/drm_lock.c
+++ b/drivers/gpu/drm/drm_lock.c
@@ -58,6 +58,9 @@ int drm_lock(struct drm_device *dev, void *data, struct drm_file *file_priv)
 	struct drm_master *master = file_priv->master;
 	int ret = 0;
 
+	if (drm_core_check_feature(dev, DRIVER_MODESET))
+		return -EINVAL;
+
 	++file_priv->lock_count;
 
 	if (lock->context == DRM_KERNEL_CONTEXT) {
@@ -151,6 +154,9 @@ int drm_unlock(struct drm_device *dev, void *data, struct drm_file *file_priv)
 	struct drm_lock *lock = data;
 	struct drm_master *master = file_priv->master;
 
+	if (drm_core_check_feature(dev, DRIVER_MODESET))
+		return -EINVAL;
+
 	if (lock->context == DRM_KERNEL_CONTEXT) {
 		DRM_ERROR("Process %d using kernel context %d\n",
 			  task_pid_nr(current), lock->context);
diff --git a/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c b/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c
index 489ffd2..a3d37e4 100644
--- a/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c
+++ b/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c
@@ -85,7 +85,7 @@ static const char *const dsi_errors[] = {
 	"RX Prot Violation",
 	"HS Generic Write FIFO Full",
 	"LP Generic Write FIFO Full",
-	"Generic Read Data Avail"
+	"Generic Read Data Avail",
 	"Special Packet Sent",
 	"Tearing Effect",
 };
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 47d8b68..0ebe0c3 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1804,7 +1804,7 @@ void i915_teardown_sysfs(struct drm_device *dev_priv);
 /* intel_i2c.c */
 extern int intel_setup_gmbus(struct drm_device *dev);
 extern void intel_teardown_gmbus(struct drm_device *dev);
-extern inline bool intel_gmbus_is_port_valid(unsigned port)
+static inline bool intel_gmbus_is_port_valid(unsigned port)
 {
 	return (port >= GMBUS_PORT_SSC && port <= GMBUS_PORT_DPD);
 }
@@ -1813,7 +1813,7 @@ extern struct i2c_adapter *intel_gmbus_get_adapter(
 		struct drm_i915_private *dev_priv, unsigned port);
 extern void intel_gmbus_set_speed(struct i2c_adapter *adapter, int speed);
 extern void intel_gmbus_force_bit(struct i2c_adapter *adapter, bool force_bit);
-extern inline bool intel_gmbus_is_forced_bit(struct i2c_adapter *adapter)
+static inline bool intel_gmbus_is_forced_bit(struct i2c_adapter *adapter)
 {
 	return container_of(adapter, struct intel_gmbus, adapter)->force_bit;
 }
diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
index 7695b5d..35287ab 100644
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@ -909,6 +909,7 @@
 #define   GMBUS_CYCLE_INDEX	(2<<25)
 #define   GMBUS_CYCLE_STOP	(4<<25)
 #define   GMBUS_BYTE_COUNT_SHIFT 16
+#define   GMBUS_BYTE_COUNT_MAX   256U
 #define   GMBUS_SLAVE_INDEX_SHIFT 8
 #define   GMBUS_SLAVE_ADDR_SHIFT 1
 #define   GMBUS_SLAVE_READ	(1<<0)
diff --git a/drivers/gpu/drm/i915/intel_i2c.c b/drivers/gpu/drm/i915/intel_i2c.c
index 639fe19..d5e666f 100644
--- a/drivers/gpu/drm/i915/intel_i2c.c
+++ b/drivers/gpu/drm/i915/intel_i2c.c
@@ -276,18 +276,17 @@ gmbus_wait_idle(struct drm_i915_private *dev_priv)
 }
 
 static int
-gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,
-		u32 gmbus1_index)
+gmbus_xfer_read_chunk(struct drm_i915_private *dev_priv,
+		      unsigned short addr, u8 *buf, unsigned int len,
+		      u32 gmbus1_index)
 {
 	int reg_offset = dev_priv->gpio_mmio_base;
-	u16 len = msg->len;
-	u8 *buf = msg->buf;
 
 	I915_WRITE(GMBUS1 + reg_offset,
 		   gmbus1_index |
 		   GMBUS_CYCLE_WAIT |
 		   (len << GMBUS_BYTE_COUNT_SHIFT) |
-		   (msg->addr << GMBUS_SLAVE_ADDR_SHIFT) |
+		   (addr << GMBUS_SLAVE_ADDR_SHIFT) |
 		   GMBUS_SLAVE_READ | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
@@ -309,11 +308,35 @@ gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,
 }
 
 static int
-gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)
+gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,
+		u32 gmbus1_index)
 {
-	int reg_offset = dev_priv->gpio_mmio_base;
-	u16 len = msg->len;
 	u8 *buf = msg->buf;
+	unsigned int rx_size = msg->len;
+	unsigned int len;
+	int ret;
+
+	do {
+		len = min(rx_size, GMBUS_BYTE_COUNT_MAX);
+
+		ret = gmbus_xfer_read_chunk(dev_priv, msg->addr,
+					    buf, len, gmbus1_index);
+		if (ret)
+			return ret;
+
+		rx_size -= len;
+		buf += len;
+	} while (rx_size != 0);
+
+	return 0;
+}
+
+static int
+gmbus_xfer_write_chunk(struct drm_i915_private *dev_priv,
+		       unsigned short addr, u8 *buf, unsigned int len)
+{
+	int reg_offset = dev_priv->gpio_mmio_base;
+	unsigned int chunk_size = len;
 	u32 val, loop;
 
 	val = loop = 0;
@@ -325,8 +348,8 @@ gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)
 	I915_WRITE(GMBUS3 + reg_offset, val);
 	I915_WRITE(GMBUS1 + reg_offset,
 		   GMBUS_CYCLE_WAIT |
-		   (msg->len << GMBUS_BYTE_COUNT_SHIFT) |
-		   (msg->addr << GMBUS_SLAVE_ADDR_SHIFT) |
+		   (chunk_size << GMBUS_BYTE_COUNT_SHIFT) |
+		   (addr << GMBUS_SLAVE_ADDR_SHIFT) |
 		   GMBUS_SLAVE_WRITE | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
@@ -343,6 +366,29 @@ gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)
 		if (ret)
 			return ret;
 	}
+
+	return 0;
+}
+
+static int
+gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)
+{
+	u8 *buf = msg->buf;
+	unsigned int tx_size = msg->len;
+	unsigned int len;
+	int ret;
+
+	do {
+		len = min(tx_size, GMBUS_BYTE_COUNT_MAX);
+
+		ret = gmbus_xfer_write_chunk(dev_priv, msg->addr, buf, len);
+		if (ret)
+			return ret;
+
+		buf += len;
+		tx_size -= len;
+	} while (tx_size != 0);
+
 	return 0;
 }
 
@@ -395,7 +441,7 @@ gmbus_xfer(struct i2c_adapter *adapter,
 					       struct intel_gmbus,
 					       adapter);
 	struct drm_i915_private *dev_priv = bus->dev_priv;
-	int i, reg_offset;
+	int i = 0, inc, try = 0, reg_offset;
 	int ret = 0;
 
 	mutex_lock(&dev_priv->gmbus_mutex);
@@ -407,12 +453,14 @@ gmbus_xfer(struct i2c_adapter *adapter,
 
 	reg_offset = dev_priv->gpio_mmio_base;
 
+retry:
 	I915_WRITE(GMBUS0 + reg_offset, bus->reg0);
 
-	for (i = 0; i < num; i++) {
+	for (; i < num; i += inc) {
+		inc = 1;
 		if (gmbus_is_index_read(msgs, i, num)) {
 			ret = gmbus_xfer_index_read(dev_priv, &msgs[i]);
-			i += 1;  /* set i to the index of the read xfer */
+			inc = 2; /* an index read is two msgs */
 		} else if (msgs[i].flags & I2C_M_RD) {
 			ret = gmbus_xfer_read(dev_priv, &msgs[i], 0);
 		} else {
@@ -484,6 +532,18 @@ clear_err:
 			 adapter->name, msgs[i].addr,
 			 (msgs[i].flags & I2C_M_RD) ? 'r' : 'w', msgs[i].len);
 
+	/*
+	 * Passive adapters sometimes NAK the first probe. Retry the first
+	 * message once on -ENXIO for GMBUS transfers; the bit banging algorithm
+	 * has retries internally. See also the retry loop in
+	 * drm_do_probe_ddc_edid, which bails out on the first -ENXIO.
+	 */
+	if (ret == -ENXIO && i == 0 && try++ == 0) {
+		DRM_DEBUG_KMS("GMBUS [%s] NAK on first message, retry\n",
+			      adapter->name);
+		goto retry;
+	}
+
 	goto out;
 
 timeout:
diff --git a/drivers/gpu/drm/i915/intel_lvds.c b/drivers/gpu/drm/i915/intel_lvds.c
index f5d1dc5..54ebfbe 100644
--- a/drivers/gpu/drm/i915/intel_lvds.c
+++ b/drivers/gpu/drm/i915/intel_lvds.c
@@ -1007,12 +1007,28 @@ static int intel_dual_link_lvds_callback(const struct dmi_system_id *id)
 static const struct dmi_system_id intel_dual_link_lvds[] = {
 	{
 		.callback = intel_dual_link_lvds_callback,
-		.ident = "Apple MacBook Pro (Core i5/i7 Series)",
+		.ident = "Apple MacBook Pro 15\" (2010)",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro6,2"),
+		},
+	},
+	{
+		.callback = intel_dual_link_lvds_callback,
+		.ident = "Apple MacBook Pro 15\" (2011)",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
 			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro8,2"),
 		},
 	},
+	{
+		.callback = intel_dual_link_lvds_callback,
+		.ident = "Apple MacBook Pro 15\" (2012)",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro9,1"),
+		},
+	},
 	{ }	/* terminating entry */
 };
 
diff --git a/drivers/gpu/drm/mgag200/mgag200_mode.c b/drivers/gpu/drm/mgag200/mgag200_mode.c
index f6341e8..7bd2acc 100644
--- a/drivers/gpu/drm/mgag200/mgag200_mode.c
+++ b/drivers/gpu/drm/mgag200/mgag200_mode.c
@@ -1487,6 +1487,11 @@ static int mga_vga_mode_valid(struct drm_connector *connector,
 		return MODE_BANDWIDTH;
 	}
 
+	if ((mode->hdisplay % 8) != 0 || (mode->hsync_start % 8) != 0 ||
+	    (mode->hsync_end % 8) != 0 || (mode->htotal % 8) != 0) {
+		return MODE_H_ILLEGAL;
+	}
+
 	if (mode->crtc_hdisplay > 2048 || mode->crtc_hsync_start > 4096 ||
 	    mode->crtc_hsync_end > 4096 || mode->crtc_htotal > 4096 ||
 	    mode->crtc_vdisplay > 2048 || mode->crtc_vsync_start > 4096 ||
diff --git a/drivers/gpu/drm/nouveau/nouveau_gem.c b/drivers/gpu/drm/nouveau/nouveau_gem.c
index 5bccf31..4d41739 100644
--- a/drivers/gpu/drm/nouveau/nouveau_gem.c
+++ b/drivers/gpu/drm/nouveau/nouveau_gem.c
@@ -177,11 +177,12 @@ nouveau_gem_info(struct drm_file *file_priv, struct drm_gem_object *gem,
 	struct nouveau_bo *nvbo = nouveau_gem_object(gem);
 	struct nouveau_vma *vma;
 
-	if (nvbo->bo.mem.mem_type == TTM_PL_TT)
+	if (is_power_of_2(nvbo->valid_domains))
+		rep->domain = nvbo->valid_domains;
+	else if (nvbo->bo.mem.mem_type == TTM_PL_TT)
 		rep->domain = NOUVEAU_GEM_DOMAIN_GART;
 	else
 		rep->domain = NOUVEAU_GEM_DOMAIN_VRAM;
-
 	rep->offset = nvbo->bo.offset;
 	if (cli->base.vm) {
 		vma = nouveau_bo_vma_find(nvbo, cli->base.vm);
diff --git a/drivers/gpu/drm/qxl/qxl_cmd.c b/drivers/gpu/drm/qxl/qxl_cmd.c
index f867714..5a48d74 100644
--- a/drivers/gpu/drm/qxl/qxl_cmd.c
+++ b/drivers/gpu/drm/qxl/qxl_cmd.c
@@ -500,6 +500,7 @@ int qxl_hw_surface_alloc(struct qxl_device *qdev,
 
 	cmd = (struct qxl_surface_cmd *)qxl_release_map(qdev, release);
 	cmd->type = QXL_SURFACE_CMD_CREATE;
+	cmd->flags = QXL_SURF_FLAG_KEEP_DATA;
 	cmd->u.surface_create.format = surf->surf.format;
 	cmd->u.surface_create.width = surf->surf.width;
 	cmd->u.surface_create.height = surf->surf.height;
diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c
index 971dd87..8ac3330 100644
--- a/drivers/gpu/drm/radeon/atombios_crtc.c
+++ b/drivers/gpu/drm/radeon/atombios_crtc.c
@@ -312,8 +312,10 @@ atombios_set_crtc_dtd_timing(struct drm_crtc *crtc,
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
-	if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
+	if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc->crtc_id;
@@ -356,8 +358,10 @@ static void atombios_crtc_set_timing(struct drm_crtc *crtc,
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
-	if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
+	if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc->crtc_id;
diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c
index 1b564d7..5b8d868 100644
--- a/drivers/gpu/drm/radeon/atombios_encoders.c
+++ b/drivers/gpu/drm/radeon/atombios_encoders.c
@@ -870,8 +870,6 @@ atombios_dig_encoder_setup(struct drm_encoder *encoder, int action, int panel_mo
 			else
 				args.v1.ucLaneNum = 4;
 
-			if (ENCODER_MODE_IS_DP(args.v1.ucEncoderMode) && (dp_clock == 270000))
-				args.v1.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;
 			switch (radeon_encoder->encoder_id) {
 			case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
 				args.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER1;
@@ -888,6 +886,10 @@ atombios_dig_encoder_setup(struct drm_encoder *encoder, int action, int panel_mo
 				args.v1.ucConfig |= ATOM_ENCODER_CONFIG_LINKB;
 			else
 				args.v1.ucConfig |= ATOM_ENCODER_CONFIG_LINKA;
+
+			if (ENCODER_MODE_IS_DP(args.v1.ucEncoderMode) && (dp_clock == 270000))
+				args.v1.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;
+
 			break;
 		case 2:
 		case 3:
diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c
index ba2ab9a..f4b9b1c 100644
--- a/drivers/gpu/drm/radeon/radeon_atombios.c
+++ b/drivers/gpu/drm/radeon/radeon_atombios.c
@@ -452,7 +452,9 @@ static bool radeon_atom_apply_quirks(struct drm_device *dev,
 	}
 
 	/* Fujitsu D3003-S2 board lists DVI-I as DVI-D and VGA */
-	if (((dev->pdev->device == 0x9802) || (dev->pdev->device == 0x9806)) &&
+	if (((dev->pdev->device == 0x9802) ||
+	     (dev->pdev->device == 0x9805) ||
+	     (dev->pdev->device == 0x9806)) &&
 	    (dev->pdev->subsystem_vendor == 0x1734) &&
 	    (dev->pdev->subsystem_device == 0x11bd)) {
 		if (*connector_type == DRM_MODE_CONNECTOR_VGA) {
@@ -463,14 +465,6 @@ static bool radeon_atom_apply_quirks(struct drm_device *dev,
 		}
 	}
 
-	/* Fujitsu D3003-S2 board lists DVI-I as DVI-I and VGA */
-	if ((dev->pdev->device == 0x9805) &&
-	    (dev->pdev->subsystem_vendor == 0x1734) &&
-	    (dev->pdev->subsystem_device == 0x11bd)) {
-		if (*connector_type == DRM_MODE_CONNECTOR_VGA)
-			return false;
-	}
-
 	return true;
 }
 
@@ -1150,7 +1144,7 @@ bool radeon_atom_get_clock_info(struct drm_device *dev)
 		    le16_to_cpu(firmware_info->info.usReferenceClock);
 		p1pll->reference_div = 0;
 
-		if (crev < 2)
+		if ((frev < 2) && (crev < 2))
 			p1pll->pll_out_min =
 				le16_to_cpu(firmware_info->info.usMinPixelClockPLL_Output);
 		else
@@ -1159,7 +1153,7 @@ bool radeon_atom_get_clock_info(struct drm_device *dev)
 		p1pll->pll_out_max =
 		    le32_to_cpu(firmware_info->info.ulMaxPixelClockPLL_Output);
 
-		if (crev >= 4) {
+		if (((frev < 2) && (crev >= 4)) || (frev >= 2)) {
 			p1pll->lcd_pll_out_min =
 				le16_to_cpu(firmware_info->info_14.usLcdMinPixelClockPLL_Output) * 100;
 			if (p1pll->lcd_pll_out_min == 0)
diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
index 8c44ef5..a7e1893 100644
--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c
+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c
@@ -11,6 +11,7 @@
 #include <acpi/acpi.h>
 #include <acpi/acpi_bus.h>
 #include <linux/pci.h>
+#include <linux/delay.h>
 
 #include "radeon_acpi.h"
 
@@ -252,6 +253,10 @@ static int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)
 		if (!info)
 			return -EIO;
 		kfree(info);
+
+		/* 200ms delay is required after off */
+		if (state == 0)
+			msleep(200);
 	}
 	return 0;
 }
diff --git a/drivers/gpu/drm/radeon/radeon_bios.c b/drivers/gpu/drm/radeon/radeon_bios.c
index b131520..72b0248 100644
--- a/drivers/gpu/drm/radeon/radeon_bios.c
+++ b/drivers/gpu/drm/radeon/radeon_bios.c
@@ -76,7 +76,7 @@ static bool igp_read_bios_from_vram(struct radeon_device *rdev)
 
 static bool radeon_read_bios(struct radeon_device *rdev)
 {
-	uint8_t __iomem *bios;
+	uint8_t __iomem *bios, val1, val2;
 	size_t size;
 
 	rdev->bios = NULL;
@@ -86,15 +86,19 @@ static bool radeon_read_bios(struct radeon_device *rdev)
 		return false;
 	}
 
-	if (size == 0 || bios[0] != 0x55 || bios[1] != 0xaa) {
+	val1 = readb(&bios[0]);
+	val2 = readb(&bios[1]);
+
+	if (size == 0 || val1 != 0x55 || val2 != 0xaa) {
 		pci_unmap_rom(rdev->pdev, bios);
 		return false;
 	}
-	rdev->bios = kmemdup(bios, size, GFP_KERNEL);
+	rdev->bios = kzalloc(size, GFP_KERNEL);
 	if (rdev->bios == NULL) {
 		pci_unmap_rom(rdev->pdev, bios);
 		return false;
 	}
+	memcpy_fromio(rdev->bios, bios, size);
 	pci_unmap_rom(rdev->pdev, bios);
 	return true;
 }
diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c
index 68ce360..9c64a97 100644
--- a/drivers/gpu/drm/radeon/radeon_combios.c
+++ b/drivers/gpu/drm/radeon/radeon_combios.c
@@ -1271,10 +1271,15 @@ struct radeon_encoder_lvds *radeon_combios_get_lvds_info(struct radeon_encoder
 
 			if ((RBIOS16(tmp) == lvds->native_mode.hdisplay) &&
 			    (RBIOS16(tmp + 2) == lvds->native_mode.vdisplay)) {
+				u32 hss = (RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;
+
+				if (hss > lvds->native_mode.hdisplay)
+					hss = (10 - 1) * 8;
+
 				lvds->native_mode.htotal = lvds->native_mode.hdisplay +
 					(RBIOS16(tmp + 17) - RBIOS16(tmp + 19)) * 8;
 				lvds->native_mode.hsync_start = lvds->native_mode.hdisplay +
-					(RBIOS16(tmp + 21) - RBIOS16(tmp + 19) - 1) * 8;
+					hss;
 				lvds->native_mode.hsync_end = lvds->native_mode.hsync_start +
 					(RBIOS8(tmp + 23) * 8);
 
@@ -3398,6 +3403,14 @@ void radeon_combios_asic_init(struct drm_device *dev)
 	    rdev->pdev->subsystem_device == 0x30ae)
 		return;
 
+	/* quirk for rs4xx HP Compaq dc5750 Small Form Factor to make it resume
+	 * - it hangs on resume inside the dynclk 1 table.
+	 */
+	if (rdev->family == CHIP_RS480 &&
+	    rdev->pdev->subsystem_vendor == 0x103c &&
+	    rdev->pdev->subsystem_device == 0x280a)
+		return;
+
 	/* DYN CLK 1 */
 	table = combios_get_table_offset(dev, COMBIOS_DYN_CLK_1_TABLE);
 	if (table)
diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c
index fc604fc..ea62810 100644
--- a/drivers/gpu/drm/radeon/radeon_connectors.c
+++ b/drivers/gpu/drm/radeon/radeon_connectors.c
@@ -78,6 +78,11 @@ void radeon_connector_hotplug(struct drm_connector *connector)
 			if (!radeon_hpd_sense(rdev, radeon_connector->hpd.hpd)) {
 				drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
 			} else if (radeon_dp_needs_link_train(radeon_connector)) {
+				/* Don't try to start link training before we
+				 * have the dpcd */
+				if (!radeon_dp_getdpcd(radeon_connector))
+					return;
+
 				/* set it to OFF so that drm_helper_connector_dpms()
 				 * won't return immediately since the current state
 				 * is ON at this point.
@@ -1686,7 +1691,6 @@ radeon_add_atom_connector(struct drm_device *dev,
 						      1);
 			/* no HPD on analog connectors */
 			radeon_connector->hpd.hpd = RADEON_HPD_NONE;
-			connector->polled = DRM_CONNECTOR_POLL_CONNECT;
 			connector->interlace_allowed = true;
 			connector->doublescan_allowed = true;
 			break;
@@ -1884,8 +1888,10 @@ radeon_add_atom_connector(struct drm_device *dev,
 	}
 
 	if (radeon_connector->hpd.hpd == RADEON_HPD_NONE) {
-		if (i2c_bus->valid)
-			connector->polled = DRM_CONNECTOR_POLL_CONNECT;
+		if (i2c_bus->valid) {
+			connector->polled = DRM_CONNECTOR_POLL_CONNECT |
+			                    DRM_CONNECTOR_POLL_DISCONNECT;
+		}
 	} else
 		connector->polled = DRM_CONNECTOR_POLL_HPD;
 
@@ -1957,7 +1963,6 @@ radeon_add_legacy_connector(struct drm_device *dev,
 					      1);
 		/* no HPD on analog connectors */
 		radeon_connector->hpd.hpd = RADEON_HPD_NONE;
-		connector->polled = DRM_CONNECTOR_POLL_CONNECT;
 		connector->interlace_allowed = true;
 		connector->doublescan_allowed = true;
 		break;
@@ -2042,10 +2047,13 @@ radeon_add_legacy_connector(struct drm_device *dev,
 	}
 
 	if (radeon_connector->hpd.hpd == RADEON_HPD_NONE) {
-		if (i2c_bus->valid)
-			connector->polled = DRM_CONNECTOR_POLL_CONNECT;
+		if (i2c_bus->valid) {
+			connector->polled = DRM_CONNECTOR_POLL_CONNECT |
+			                    DRM_CONNECTOR_POLL_DISCONNECT;
+		}
 	} else
 		connector->polled = DRM_CONNECTOR_POLL_HPD;
+
 	connector->display_info.subpixel_order = subpixel_order;
 	drm_sysfs_connector_add(connector);
 }
diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c
index 8df1525..e9db3f8 100644
--- a/drivers/gpu/drm/radeon/radeon_device.c
+++ b/drivers/gpu/drm/radeon/radeon_device.c
@@ -449,6 +449,23 @@ void radeon_gtt_location(struct radeon_device *rdev, struct radeon_mc *mc)
 /*
  * GPU helpers function.
  */
+
+/**
+ * radeon_device_is_virtual - check if we are running is a virtual environment
+ *
+ * Check if the asic has been passed through to a VM (all asics).
+ * Used at driver startup.
+ * Returns true if virtual or false if not.
+ */
+static bool radeon_device_is_virtual(void)
+{
+#ifdef CONFIG_X86
+	return boot_cpu_has(X86_FEATURE_HYPERVISOR);
+#else
+	return false;
+#endif
+}
+
 /**
  * radeon_card_posted - check if the hw has already been initialized
  *
@@ -462,6 +479,10 @@ bool radeon_card_posted(struct radeon_device *rdev)
 {
 	uint32_t reg;
 
+	/* for pass through, always force asic_init */
+	if (radeon_device_is_virtual())
+		return false;
+
 	/* required for EFI mode on macbook2,1 which uses an r5xx asic */
 	if (efi_enabled(EFI_BOOT) &&
 	    (rdev->pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE) &&
diff --git a/drivers/gpu/drm/radeon/radeon_gart.c b/drivers/gpu/drm/radeon/radeon_gart.c
index 2915a1c..c4bb0bc 100644
--- a/drivers/gpu/drm/radeon/radeon_gart.c
+++ b/drivers/gpu/drm/radeon/radeon_gart.c
@@ -251,8 +251,10 @@ void radeon_gart_unbind(struct radeon_device *rdev, unsigned offset,
 			}
 		}
 	}
-	mb();
-	radeon_gart_tlb_flush(rdev);
+	if (rdev->gart.ptr) {
+		mb();
+		radeon_gart_tlb_flush(rdev);
+	}
 }
 
 /**
@@ -294,8 +296,10 @@ int radeon_gart_bind(struct radeon_device *rdev, unsigned offset,
 			}
 		}
 	}
-	mb();
-	radeon_gart_tlb_flush(rdev);
+	if (rdev->gart.ptr) {
+		mb();
+		radeon_gart_tlb_flush(rdev);
+	}
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c
index 1fe12ab..6acd364 100644
--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c
+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c
@@ -73,10 +73,17 @@ static void radeon_hotplug_work_func(struct work_struct *work)
 	struct drm_mode_config *mode_config = &dev->mode_config;
 	struct drm_connector *connector;
 
+	/* we can race here at startup, some boards seem to trigger
+	 * hotplug irqs when they shouldn't. */
+	if (!rdev->mode_info.mode_config_initialized)
+		return;
+
+	mutex_lock(&mode_config->mutex);
 	if (mode_config->num_connector) {
 		list_for_each_entry(connector, &mode_config->connector_list, head)
 			radeon_connector_hotplug(connector);
 	}
+	mutex_unlock(&mode_config->mutex);
 	/* Just fire off a uevent and let userspace tell us what to do */
 	drm_helper_hpd_irq_event(dev);
 }
diff --git a/drivers/gpu/drm/radeon/radeon_sa.c b/drivers/gpu/drm/radeon/radeon_sa.c
index f0bac68..8962411 100644
--- a/drivers/gpu/drm/radeon/radeon_sa.c
+++ b/drivers/gpu/drm/radeon/radeon_sa.c
@@ -349,8 +349,15 @@ int radeon_sa_bo_new(struct radeon_device *rdev,
 			/* see if we can skip over some allocations */
 		} while (radeon_sa_bo_next_hole(sa_manager, fences, tries));
 
+		for (i = 0; i < RADEON_NUM_RINGS; ++i) {
+			if (fences[i])
+				radeon_fence_ref(fences[i]);
+		}
+
 		spin_unlock(&sa_manager->wq.lock);
 		r = radeon_fence_wait_any(rdev, fences, false);
+		for (i = 0; i < RADEON_NUM_RINGS; ++i)
+			radeon_fence_unref(&fences[i]);
 		spin_lock(&sa_manager->wq.lock);
 		/* if we have nothing to wait for block */
 		if (r == -ENOENT && block) {
diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c
index 4a14e11..f701559 100644
--- a/drivers/gpu/drm/radeon/radeon_ttm.c
+++ b/drivers/gpu/drm/radeon/radeon_ttm.c
@@ -619,7 +619,7 @@ static int radeon_ttm_tt_populate(struct ttm_tt *ttm)
 						       0, PAGE_SIZE,
 						       PCI_DMA_BIDIRECTIONAL);
 		if (pci_dma_mapping_error(rdev->pdev, gtt->ttm.dma_address[i])) {
-			while (--i) {
+			while (i--) {
 				pci_unmap_page(rdev->pdev, gtt->ttm.dma_address[i],
 					       PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
 				gtt->ttm.dma_address[i] = 0;
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
index 6c44c69..94a0baa 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
@@ -25,6 +25,7 @@
  *
  **************************************************************************/
 #include <linux/module.h>
+#include <linux/console.h>
 
 #include <drm/drmP.h>
 #include "vmwgfx_drv.h"
@@ -1192,6 +1193,12 @@ static int vmw_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 static int __init vmwgfx_init(void)
 {
 	int ret;
+
+#ifdef CONFIG_VGA_CONSOLE
+	if (vgacon_text_force())
+		return -EINVAL;
+#endif
+
 	ret = drm_pci_init(&driver, &vmw_pci_driver);
 	if (ret)
 		DRM_ERROR("Failed initializing DRM.\n");
diff --git a/drivers/gpu/vga/vgaarb.c b/drivers/gpu/vga/vgaarb.c
index e893f6e..3c84e96 100644
--- a/drivers/gpu/vga/vgaarb.c
+++ b/drivers/gpu/vga/vgaarb.c
@@ -392,8 +392,10 @@ int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible)
 		set_current_state(interruptible ?
 				  TASK_INTERRUPTIBLE :
 				  TASK_UNINTERRUPTIBLE);
-		if (signal_pending(current)) {
-			rc = -EINTR;
+		if (interruptible && signal_pending(current)) {
+			__set_current_state(TASK_RUNNING);
+			remove_wait_queue(&vga_wait_queue, &wait);
+			rc = -ERESTARTSYS;
 			break;
 		}
 		schedule();
diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index 2bd798a..c1a8cf2 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -1462,7 +1462,7 @@ int hid_connect(struct hid_device *hdev, unsigned int connect_mask)
 		"Multi-Axis Controller"
 	};
 	const char *type, *bus;
-	char buf[64];
+	char buf[64] = "";
 	unsigned int i;
 	int len;
 	int ret;
diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index a3915d1..eb5700e 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -1084,7 +1084,7 @@ void hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct
 		return;
 
 	/* report the usage code as scancode if the key status has changed */
-	if (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)
+	if (usage->type == EV_KEY && (!!test_bit(usage->code, input->key)) != value)
 		input_event(input, EV_MSC, MSC_SCAN, usage->hid);
 
 	input_event(input, usage->type, usage->code, value);
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index ada164e..92aef982 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -180,7 +180,7 @@ static void hid_io_error(struct hid_device *hid)
 	if (time_after(jiffies, usbhid->stop_retry)) {
 
 		/* Retries failed, so do a port reset unless we lack bandwidth*/
-		if (test_bit(HID_NO_BANDWIDTH, &usbhid->iofl)
+		if (!test_bit(HID_NO_BANDWIDTH, &usbhid->iofl)
 		     && !test_and_set_bit(HID_RESET_PENDING, &usbhid->iofl)) {
 
 			schedule_work(&usbhid->reset_work);
@@ -490,8 +490,6 @@ static void hid_ctrl(struct urb *urb)
 	struct usbhid_device *usbhid = hid->driver_data;
 	int unplug = 0, status = urb->status;
 
-	spin_lock(&usbhid->lock);
-
 	switch (status) {
 	case 0:			/* success */
 		if (usbhid->ctrl[usbhid->ctrltail].dir == USB_DIR_IN)
@@ -511,6 +509,8 @@ static void hid_ctrl(struct urb *urb)
 		hid_warn(urb->dev, "ctrl urb status %d received\n", status);
 	}
 
+	spin_lock(&usbhid->lock);
+
 	if (unplug) {
 		usbhid->ctrltail = usbhid->ctrlhead;
 	} else {
@@ -988,14 +988,6 @@ static int usbhid_output_raw_report(struct hid_device *hid, __u8 *buf, size_t co
 	return ret;
 }
 
-static void usbhid_restart_queues(struct usbhid_device *usbhid)
-{
-	if (usbhid->urbout && !test_bit(HID_OUT_RUNNING, &usbhid->iofl))
-		usbhid_restart_out_queue(usbhid);
-	if (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl))
-		usbhid_restart_ctrl_queue(usbhid);
-}
-
 static void hid_free_buffers(struct usb_device *dev, struct hid_device *hid)
 {
 	struct usbhid_device *usbhid = hid->driver_data;
@@ -1412,6 +1404,37 @@ static void hid_cease_io(struct usbhid_device *usbhid)
 	usb_kill_urb(usbhid->urbout);
 }
 
+static void hid_restart_io(struct hid_device *hid)
+{
+	struct usbhid_device *usbhid = hid->driver_data;
+	int clear_halt = test_bit(HID_CLEAR_HALT, &usbhid->iofl);
+	int reset_pending = test_bit(HID_RESET_PENDING, &usbhid->iofl);
+
+	spin_lock_irq(&usbhid->lock);
+	clear_bit(HID_SUSPENDED, &usbhid->iofl);
+	usbhid_mark_busy(usbhid);
+
+	if (clear_halt || reset_pending)
+		schedule_work(&usbhid->reset_work);
+	usbhid->retry_delay = 0;
+	spin_unlock_irq(&usbhid->lock);
+
+	if (reset_pending || !test_bit(HID_STARTED, &usbhid->iofl))
+		return;
+
+	if (!clear_halt) {
+		if (hid_start_in(hid) < 0)
+			hid_io_error(hid);
+	}
+
+	spin_lock_irq(&usbhid->lock);
+	if (usbhid->urbout && !test_bit(HID_OUT_RUNNING, &usbhid->iofl))
+		usbhid_restart_out_queue(usbhid);
+	if (!test_bit(HID_CTRL_RUNNING, &usbhid->iofl))
+		usbhid_restart_ctrl_queue(usbhid);
+	spin_unlock_irq(&usbhid->lock);
+}
+
 /* Treat USB reset pretty much the same as suspend/resume */
 static int hid_pre_reset(struct usb_interface *intf)
 {
@@ -1461,14 +1484,14 @@ static int hid_post_reset(struct usb_interface *intf)
 		return 1;
 	}
 
+	/* No need to do another reset or clear a halted endpoint */
 	spin_lock_irq(&usbhid->lock);
 	clear_bit(HID_RESET_PENDING, &usbhid->iofl);
+	clear_bit(HID_CLEAR_HALT, &usbhid->iofl);
 	spin_unlock_irq(&usbhid->lock);
 	hid_set_idle(dev, intf->cur_altsetting->desc.bInterfaceNumber, 0, 0);
-	status = hid_start_in(hid);
-	if (status < 0)
-		hid_io_error(hid);
-	usbhid_restart_queues(usbhid);
+
+	hid_restart_io(hid);
 
 	return 0;
 }
@@ -1491,25 +1514,9 @@ void usbhid_put_power(struct hid_device *hid)
 #ifdef CONFIG_PM
 static int hid_resume_common(struct hid_device *hid, bool driver_suspended)
 {
-	struct usbhid_device *usbhid = hid->driver_data;
-	int status;
-
-	spin_lock_irq(&usbhid->lock);
-	clear_bit(HID_SUSPENDED, &usbhid->iofl);
-	usbhid_mark_busy(usbhid);
-
-	if (test_bit(HID_CLEAR_HALT, &usbhid->iofl) ||
-			test_bit(HID_RESET_PENDING, &usbhid->iofl))
-		schedule_work(&usbhid->reset_work);
-	usbhid->retry_delay = 0;
-
-	usbhid_restart_queues(usbhid);
-	spin_unlock_irq(&usbhid->lock);
-
-	status = hid_start_in(hid);
-	if (status < 0)
-		hid_io_error(hid);
+	int status = 0;
 
+	hid_restart_io(hid);
 	if (driver_suspended && hid->driver && hid->driver->resume)
 		status = hid->driver->resume(hid);
 	return status;
@@ -1576,12 +1583,8 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 static int hid_resume(struct usb_interface *intf)
 {
 	struct hid_device *hid = usb_get_intfdata (intf);
-	struct usbhid_device *usbhid = hid->driver_data;
 	int status;
 
-	if (!test_bit(HID_STARTED, &usbhid->iofl))
-		return 0;
-
 	status = hid_resume_common(hid, true);
 	dev_dbg(&intf->dev, "resume status %d\n", status);
 	return 0;
@@ -1590,10 +1593,8 @@ static int hid_resume(struct usb_interface *intf)
 static int hid_reset_resume(struct usb_interface *intf)
 {
 	struct hid_device *hid = usb_get_intfdata(intf);
-	struct usbhid_device *usbhid = hid->driver_data;
 	int status;
 
-	clear_bit(HID_SUSPENDED, &usbhid->iofl);
 	status = hid_post_reset(intf);
 	if (status >= 0 && hid->driver && hid->driver->reset_resume) {
 		int ret = hid->driver->reset_resume(hid);
diff --git a/drivers/hid/usbhid/hiddev.c b/drivers/hid/usbhid/hiddev.c
index 2f1ddca..700145b 100644
--- a/drivers/hid/usbhid/hiddev.c
+++ b/drivers/hid/usbhid/hiddev.c
@@ -516,13 +516,13 @@ static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd,
 					goto inval;
 			} else if (uref->usage_index >= field->report_count)
 				goto inval;
-
-			else if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&
-				 (uref_multi->num_values > HID_MAX_MULTI_USAGES ||
-				  uref->usage_index + uref_multi->num_values > field->report_count))
-				goto inval;
 		}
 
+		if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&
+		    (uref_multi->num_values > HID_MAX_MULTI_USAGES ||
+		     uref->usage_index + uref_multi->num_values > field->report_count))
+			goto inval;
+
 		switch (cmd) {
 		case HIDIOCGUSAGE:
 			uref->value = field->value[uref->usage_index];
diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c
index 92f34de..05e6a7d 100644
--- a/drivers/hv/channel.c
+++ b/drivers/hv/channel.c
@@ -169,7 +169,7 @@ int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,
 			   GFP_KERNEL);
 	if (!open_info) {
 		err = -ENOMEM;
-		goto error0;
+		goto error_gpadl;
 	}
 
 	init_completion(&open_info->waitevent);
@@ -185,7 +185,7 @@ int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,
 
 	if (userdatalen > MAX_USER_DEFINED_BYTES) {
 		err = -EINVAL;
-		goto error0;
+		goto error_gpadl;
 	}
 
 	if (userdatalen)
@@ -226,6 +226,9 @@ error1:
 	list_del(&open_info->msglistentry);
 	spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);
 
+error_gpadl:
+	vmbus_teardown_gpadl(newchannel, newchannel->ringbuffer_gpadlhandle);
+
 error0:
 	free_pages((unsigned long)out,
 		get_order(send_ringbuffer_size + recv_ringbuffer_size));
diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c
index 21ef689..edf8995 100644
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@ -648,7 +648,7 @@ int vmbus_request_offers(void)
 {
 	struct vmbus_channel_message_header *msg;
 	struct vmbus_channel_msginfo *msginfo;
-	int ret, t;
+	int ret;
 
 	msginfo = kmalloc(sizeof(*msginfo) +
 			  sizeof(struct vmbus_channel_message_header),
@@ -656,8 +656,6 @@ int vmbus_request_offers(void)
 	if (!msginfo)
 		return -ENOMEM;
 
-	init_completion(&msginfo->waitevent);
-
 	msg = (struct vmbus_channel_message_header *)msginfo->msg;
 
 	msg->msgtype = CHANNELMSG_REQUESTOFFERS;
@@ -671,14 +669,6 @@ int vmbus_request_offers(void)
 		goto cleanup;
 	}
 
-	t = wait_for_completion_timeout(&msginfo->waitevent, 5*HZ);
-	if (t == 0) {
-		ret = -ETIMEDOUT;
-		goto cleanup;
-	}
-
-
-
 cleanup:
 	kfree(msginfo);
 
diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c
index f445b08..80754e2 100644
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@ -32,6 +32,7 @@
 #include <linux/acpi.h>
 #include <acpi/acpi_bus.h>
 #include <linux/completion.h>
+#include <linux/cpu.h>
 #include <linux/hyperv.h>
 #include <linux/kernel_stat.h>
 #include <asm/hyperv.h>
@@ -517,6 +518,39 @@ static void vmbus_flow_handler(unsigned int irq, struct irq_desc *desc)
 	desc->action->handler(irq, desc->action->dev_id);
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+static int hyperv_cpu_disable(void)
+{
+	return -ENOSYS;
+}
+
+static void hv_cpu_hotplug_quirk(bool vmbus_loaded)
+{
+	static void *previous_cpu_disable;
+
+	/*
+	 * Offlining a CPU when running on newer hypervisors (WS2012R2, Win8,
+	 * ...) is not supported at this moment as channel interrupts are
+	 * distributed across all of them.
+	 */
+
+	if ((vmbus_proto_version == VERSION_WS2008) ||
+	    (vmbus_proto_version == VERSION_WIN7))
+		return;
+
+	if (vmbus_loaded) {
+		previous_cpu_disable = smp_ops.cpu_disable;
+		smp_ops.cpu_disable = hyperv_cpu_disable;
+		pr_notice("CPU offlining is not supported by hypervisor\n");
+	} else if (previous_cpu_disable)
+		smp_ops.cpu_disable = previous_cpu_disable;
+}
+#else
+static void hv_cpu_hotplug_quirk(bool vmbus_loaded)
+{
+}
+#endif
+
 /*
  * vmbus_bus_init -Main vmbus driver initialization routine.
  *
@@ -572,6 +606,7 @@ static int vmbus_bus_init(int irq)
 	if (ret)
 		goto err_irq;
 
+	hv_cpu_hotplug_quirk(true);
 	vmbus_request_offers();
 
 	return 0;
@@ -808,6 +843,7 @@ static void __exit vmbus_exit(void)
 	bus_unregister(&hv_bus);
 	hv_cleanup();
 	acpi_bus_unregister_driver(&vmbus_acpi_driver);
+	hv_cpu_hotplug_quirk(false);
 }
 
 
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index 5690d45..d17d3e6 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -140,7 +140,6 @@ obj-$(CONFIG_SENSORS_W83L785TS)	+= w83l785ts.o
 obj-$(CONFIG_SENSORS_W83L786NG)	+= w83l786ng.o
 obj-$(CONFIG_SENSORS_WM831X)	+= wm831x-hwmon.o
 obj-$(CONFIG_SENSORS_WM8350)	+= wm8350-hwmon.o
-obj-$(CONFIG_SENSORS_AMBARELLA_ADC_TEMPER)	+= ambarella_adc_temper.o
 
 obj-$(CONFIG_PMBUS)		+= pmbus/
 
diff --git a/drivers/hwmon/max1111.c b/drivers/hwmon/max1111.c
index eda077d..f787f04 100644
--- a/drivers/hwmon/max1111.c
+++ b/drivers/hwmon/max1111.c
@@ -85,6 +85,9 @@ static struct max1111_data *the_max1111;
 
 int max1111_read_channel(int channel)
 {
+	if (!the_max1111 || !the_max1111->spi)
+		return -ENODEV;
+
 	return max1111_read(&the_max1111->spi->dev, channel);
 }
 EXPORT_SYMBOL(max1111_read_channel);
@@ -260,6 +263,9 @@ static int max1111_remove(struct spi_device *spi)
 {
 	struct max1111_data *data = spi_get_drvdata(spi);
 
+#ifdef CONFIG_SHARPSL_PM
+	the_max1111 = NULL;
+#endif
 	hwmon_device_unregister(data->hwmon_dev);
 	sysfs_remove_group(&spi->dev.kobj, &max1110_attr_group);
 	sysfs_remove_group(&spi->dev.kobj, &max1111_attr_group);
diff --git a/drivers/hwmon/mcp3021.c b/drivers/hwmon/mcp3021.c
index eedb322..f712cc7 100644
--- a/drivers/hwmon/mcp3021.c
+++ b/drivers/hwmon/mcp3021.c
@@ -31,14 +31,11 @@
 /* output format */
 #define MCP3021_SAR_SHIFT	2
 #define MCP3021_SAR_MASK	0x3ff
-
 #define MCP3021_OUTPUT_RES	10	/* 10-bit resolution */
-#define MCP3021_OUTPUT_SCALE	4
 
 #define MCP3221_SAR_SHIFT	0
 #define MCP3221_SAR_MASK	0xfff
 #define MCP3221_OUTPUT_RES	12	/* 12-bit resolution */
-#define MCP3221_OUTPUT_SCALE	1
 
 enum chips {
 	mcp3021,
@@ -54,7 +51,6 @@ struct mcp3021_data {
 	u16 sar_shift;
 	u16 sar_mask;
 	u8 output_res;
-	u8 output_scale;
 };
 
 static int mcp3021_read16(struct i2c_client *client)
@@ -84,13 +80,7 @@ static int mcp3021_read16(struct i2c_client *client)
 
 static inline u16 volts_from_reg(struct mcp3021_data *data, u16 val)
 {
-	if (val == 0)
-		return 0;
-
-	val = val * data->output_scale - data->output_scale / 2;
-
-	return val * DIV_ROUND_CLOSEST(data->vdd,
-			(1 << data->output_res) * data->output_scale);
+	return DIV_ROUND_CLOSEST(data->vdd * val, 1 << data->output_res);
 }
 
 static ssize_t show_in_input(struct device *dev, struct device_attribute *attr,
@@ -132,14 +122,12 @@ static int mcp3021_probe(struct i2c_client *client,
 		data->sar_shift = MCP3021_SAR_SHIFT;
 		data->sar_mask = MCP3021_SAR_MASK;
 		data->output_res = MCP3021_OUTPUT_RES;
-		data->output_scale = MCP3021_OUTPUT_SCALE;
 		break;
 
 	case mcp3221:
 		data->sar_shift = MCP3221_SAR_SHIFT;
 		data->sar_mask = MCP3221_SAR_MASK;
 		data->output_res = MCP3221_OUTPUT_RES;
-		data->output_scale = MCP3221_OUTPUT_SCALE;
 		break;
 	}
 
diff --git a/drivers/hwmon/ntc_thermistor.c b/drivers/hwmon/ntc_thermistor.c
index c64d3d4..d7bb12a 100644
--- a/drivers/hwmon/ntc_thermistor.c
+++ b/drivers/hwmon/ntc_thermistor.c
@@ -181,8 +181,10 @@ static struct ntc_thermistor_platform_data *
 ntc_thermistor_parse_dt(struct platform_device *pdev)
 {
 	struct iio_channel *chan;
+	enum iio_chan_type type;
 	struct device_node *np = pdev->dev.of_node;
 	struct ntc_thermistor_platform_data *pdata;
+	int ret;
 
 	if (!np)
 		return NULL;
@@ -195,6 +197,13 @@ ntc_thermistor_parse_dt(struct platform_device *pdev)
 	if (IS_ERR(chan))
 		return ERR_CAST(chan);
 
+	ret = iio_get_channel_type(chan, &type);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	if (type != IIO_VOLTAGE)
+		return ERR_PTR(-EINVAL);
+
 	if (of_property_read_u32(np, "pullup-uv", &pdata->pullup_uv))
 		return ERR_PTR(-ENODEV);
 	if (of_property_read_u32(np, "pullup-ohm", &pdata->pullup_ohm))
diff --git a/drivers/i2c/busses/i2c-ambarella.c b/drivers/i2c/busses/i2c-ambarella.c
index 6b7fd7e..b1baa3e 100644
--- a/drivers/i2c/busses/i2c-ambarella.c
+++ b/drivers/i2c/busses/i2c-ambarella.c
@@ -81,6 +81,7 @@ struct ambarella_i2c_dev_info {
 	u32					clk_limit;
 	u32					bulk_num;
 	u32					duty_cycle;
+	u32					turbo_mode;
 
 	struct i2c_msg				*msgs;
 	__u16					msg_num;
@@ -120,7 +121,8 @@ int ambpriv_i2c_update_addr(const char *name, int bus, int addr)
 			return -ENODEV;
 		}
 
-		if (!strcmp(client->name, AMBARELLA_I2C_VIN_FDT_NAME))
+		if (!strcmp(client->name, AMBARELLA_I2C_VIN_FDT_NAME) ||
+			!strcmp(client->name, name))
 			break;
 	}
 
@@ -221,21 +223,16 @@ static inline void ambarella_i2c_bulk_write(
 	struct ambarella_i2c_dev_info *pinfo,
 	__u32 fifosize)
 {
-	do {
+	while (fifosize--) {
 		amba_writeb(pinfo->regbase + IDC_FMDATA_OFFSET,
-			pinfo->msgs->buf[pinfo->msg_index]);
-		pinfo->msg_index++;
-		fifosize--;
-
-		if (pinfo->msg_index >= pinfo->msgs->len) {
-			amba_writel(pinfo->regbase + IDC_FMCTRL_OFFSET,
-				IDC_FMCTRL_IF | IDC_FMCTRL_STOP);
-
-			return;
-		}
-	} while (fifosize > 1);
+			pinfo->msgs->buf[pinfo->msg_index++]);
+		if (pinfo->msg_index >= pinfo->msgs->len)
+			break;
+	};
 
-	amba_writel(pinfo->regbase + IDC_FMCTRL_OFFSET, IDC_FMCTRL_IF);
+	/* the last fifo data MUST be STOP+IF */
+	amba_writel(pinfo->regbase + IDC_FMCTRL_OFFSET,
+		IDC_FMCTRL_IF | IDC_FMCTRL_STOP);
 }
 
 static inline void ambarella_i2c_start_bulk_msg_write(
@@ -245,6 +242,7 @@ static inline void ambarella_i2c_start_bulk_msg_write(
 
 	pinfo->state = AMBA_I2C_STATE_BULK_WRITE;
 
+	amba_writel(pinfo->regbase + IDC_CTRL_OFFSET, 0);
 	amba_writel(pinfo->regbase + IDC_FMCTRL_OFFSET, IDC_FMCTRL_START);
 
 	if (pinfo->msgs->flags & I2C_M_TEN) {
@@ -273,7 +271,7 @@ static inline void ambarella_i2c_start_current_msg(
 
 	if (pinfo->msgs->flags & I2C_M_RD) {
 		ambarella_i2c_start_single_msg(pinfo);
-	} else if (pinfo->msgs->len > pinfo->bulk_num) {
+	} else if (pinfo->turbo_mode) {
 		ambarella_i2c_start_bulk_msg_write(pinfo);
 	} else {
 		ambarella_i2c_start_single_msg(pinfo);
@@ -432,28 +430,18 @@ amba_i2c_irq_write:
 		}
 		break;
 	case AMBA_I2C_STATE_BULK_WRITE:
-		if (ambarella_i2c_check_ack(pinfo, &control_reg,
-			CONFIG_I2C_AMBARELLA_BULK_RETRY_NUM) ==	IDC_CTRL_ACK) {
-			amba_writel(pinfo->regbase + IDC_CTRL_OFFSET,
-				IDC_CTRL_ACK);
-			if (pinfo->msg_index >= pinfo->msgs->len) {
-				if (pinfo->msg_num > 1) {
-					pinfo->msgs++;
-					pinfo->state = AMBA_I2C_STATE_START_NEW;
-					pinfo->msg_num--;
-					goto amba_i2c_irq_start_new;
-				}
-				ambarella_i2c_stop(pinfo,
-					AMBA_I2C_STATE_IDLE, &ack_control);
-			} else {
-				ambarella_i2c_bulk_write(pinfo,
-					IDC_FIFO_BUF_SIZE);
-			}
-			goto amba_i2c_irq_exit;
-		} else {
-			ack_control = IDC_CTRL_ACK;
+		while (((status_reg & 0xF0) != 0x50) && ((status_reg & 0xF0) != 0x00)) {
+			cpu_relax();
+			status_reg = amba_readl(pinfo->regbase + IDC_STS_OFFSET);
+		};
+		if (pinfo->msg_num > 1) {
+			pinfo->msgs++;
+			pinfo->state = AMBA_I2C_STATE_START_NEW;
+			pinfo->msg_num--;
+			goto amba_i2c_irq_start_new;
 		}
-		break;
+		ambarella_i2c_stop(pinfo, AMBA_I2C_STATE_IDLE, &ack_control);
+		goto amba_i2c_irq_exit;
 	default:
 		dev_err(pinfo->dev, "ambarella_i2c_irq in wrong state[0x%x]\n",
 			pinfo->state);
@@ -477,9 +465,28 @@ static int ambarella_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	int				errorCode = -EPERM;
 	int				retryCount;
 	long				timeout;
+	int				i;
 
 	pinfo = (struct ambarella_i2c_dev_info *)i2c_get_adapdata(adap);
 
+	/* check data length for FIFO mode */
+	if (unlikely(pinfo->turbo_mode)) {
+		pinfo->msgs = msgs;
+		pinfo->msg_num = num;
+		for (i = 0 ; i < pinfo->msg_num; i++) {
+			if ((!(pinfo->msgs->flags & I2C_M_RD)) &&
+				(pinfo->msgs->len > IDC_FIFO_BUF_SIZE - 2)) {
+				dev_err(pinfo->dev,
+					"Turbo(FIFO) mode can only support <= "
+					"%d bytes writing, but message[%d]: %d bytes applied!\n",
+					IDC_FIFO_BUF_SIZE - 2, i, pinfo->msgs->len);
+
+				return -EPERM;
+			}
+			pinfo->msgs++;
+		}
+	}
+
 	down(&pinfo->system_event_sem);
 
 	for (retryCount = 0; retryCount < adap->retries; retryCount++) {
@@ -491,7 +498,7 @@ static int ambarella_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 
 		ambarella_i2c_start_current_msg(pinfo);
 		timeout = wait_event_timeout(pinfo->msg_wait,
-			pinfo->msg_num == 0, CONFIG_I2C_AMBARELLA_ACK_TIMEOUT);
+			pinfo->msg_num == 0, adap->timeout);
 		if (timeout <= 0) {
 			pinfo->state = AMBA_I2C_STATE_NO_ACK;
 		}
@@ -584,12 +591,6 @@ static int ambarella_i2c_probe(struct platform_device *pdev)
 	if (pinfo->clk_limit < 1000 || pinfo->clk_limit > 400000)
 		pinfo->clk_limit = 100000;
 
-	errorCode = of_property_read_u32(np, "amb,bulk-num", &pinfo->bulk_num);
-	if (errorCode < 0) {
-		dev_err(&pdev->dev, "Get bulk-num failed!\n");
-		return -ENODEV;
-	}
-
 	errorCode = of_property_read_u32(np, "amb,duty-cycle", &pinfo->duty_cycle);
 	if (errorCode < 0) {
 		dev_dbg(&pdev->dev, "Missing duty-cycle, assuming 1:1!\n");
@@ -599,6 +600,14 @@ static int ambarella_i2c_probe(struct platform_device *pdev)
 	if (pinfo->duty_cycle > 2)
 		pinfo->duty_cycle = 2;
 
+	/* check if using turbo mode */
+	if (of_find_property(pdev->dev.of_node, "amb,turbo-mode", NULL)) {
+		pinfo->turbo_mode = 1;
+		dev_info(&pdev->dev,"Turbo(FIFO) mode is used(ignore device ACK)!\n");
+	} else {
+		pinfo->turbo_mode = 0;
+	}
+
 	init_waitqueue_head(&pinfo->msg_wait);
 	sema_init(&pinfo->system_event_sem, 1);
 
@@ -697,8 +706,8 @@ static int ambarella_i2c_resume(struct device *dev)
 }
 
 static const struct dev_pm_ops ambarella_i2c_dev_pm_ops = {
-	.suspend = ambarella_i2c_suspend,
-	.resume = ambarella_i2c_resume,
+	.suspend_late = ambarella_i2c_suspend,
+	.resume_early = ambarella_i2c_resume,
 	.freeze = ambarella_i2c_suspend,
 	.thaw = ambarella_i2c_resume,
 };
diff --git a/drivers/i2c/busses/i2c-at91.c b/drivers/i2c/busses/i2c-at91.c
index 09324d0..ceabcfe 100644
--- a/drivers/i2c/busses/i2c-at91.c
+++ b/drivers/i2c/busses/i2c-at91.c
@@ -63,6 +63,9 @@
 #define	AT91_TWI_UNRE		0x0080	/* Underrun Error */
 #define	AT91_TWI_NACK		0x0100	/* Not Acknowledged */
 
+#define	AT91_TWI_INT_MASK \
+	(AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY | AT91_TWI_NACK)
+
 #define	AT91_TWI_IER		0x0024	/* Interrupt Enable Register */
 #define	AT91_TWI_IDR		0x0028	/* Interrupt Disable Register */
 #define	AT91_TWI_IMR		0x002c	/* Interrupt Mask Register */
@@ -118,13 +121,12 @@ static void at91_twi_write(struct at91_twi_dev *dev, unsigned reg, unsigned val)
 
 static void at91_disable_twi_interrupts(struct at91_twi_dev *dev)
 {
-	at91_twi_write(dev, AT91_TWI_IDR,
-		       AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY);
+	at91_twi_write(dev, AT91_TWI_IDR, AT91_TWI_INT_MASK);
 }
 
 static void at91_twi_irq_save(struct at91_twi_dev *dev)
 {
-	dev->imr = at91_twi_read(dev, AT91_TWI_IMR) & 0x7;
+	dev->imr = at91_twi_read(dev, AT91_TWI_IMR) & AT91_TWI_INT_MASK;
 	at91_disable_twi_interrupts(dev);
 }
 
@@ -214,6 +216,14 @@ static void at91_twi_write_data_dma_callback(void *data)
 	dma_unmap_single(dev->dev, sg_dma_address(&dev->dma.sg),
 			 dev->buf_len, DMA_TO_DEVICE);
 
+	/*
+	 * When this callback is called, THR/TX FIFO is likely not to be empty
+	 * yet. So we have to wait for TXCOMP or NACK bits to be set into the
+	 * Status Register to be sure that the STOP bit has been sent and the
+	 * transfer is completed. The NACK interrupt has already been enabled,
+	 * we just have to enable TXCOMP one.
+	 */
+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);
 	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);
 }
 
@@ -308,7 +318,7 @@ static void at91_twi_read_data_dma_callback(void *data)
 	/* The last two bytes have to be read without using dma */
 	dev->buf += dev->buf_len - 2;
 	dev->buf_len = 2;
-	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY);
+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY | AT91_TWI_TXCOMP);
 }
 
 static void at91_twi_read_data_dma(struct at91_twi_dev *dev)
@@ -369,7 +379,7 @@ static irqreturn_t atmel_twi_interrupt(int irq, void *dev_id)
 	/* catch error flags */
 	dev->transfer_status |= status;
 
-	if (irqstatus & AT91_TWI_TXCOMP) {
+	if (irqstatus & (AT91_TWI_TXCOMP | AT91_TWI_NACK)) {
 		at91_disable_twi_interrupts(dev);
 		complete(&dev->cmd_complete);
 	}
@@ -382,6 +392,34 @@ static int at91_do_twi_transfer(struct at91_twi_dev *dev)
 	int ret;
 	bool has_unre_flag = dev->pdata->has_unre_flag;
 
+	/*
+	 * WARNING: the TXCOMP bit in the Status Register is NOT a clear on
+	 * read flag but shows the state of the transmission at the time the
+	 * Status Register is read. According to the programmer datasheet,
+	 * TXCOMP is set when both holding register and internal shifter are
+	 * empty and STOP condition has been sent.
+	 * Consequently, we should enable NACK interrupt rather than TXCOMP to
+	 * detect transmission failure.
+	 *
+	 * Besides, the TXCOMP bit is already set before the i2c transaction
+	 * has been started. For read transactions, this bit is cleared when
+	 * writing the START bit into the Control Register. So the
+	 * corresponding interrupt can safely be enabled just after.
+	 * However for write transactions managed by the CPU, we first write
+	 * into THR, so TXCOMP is cleared. Then we can safely enable TXCOMP
+	 * interrupt. If TXCOMP interrupt were enabled before writing into THR,
+	 * the interrupt handler would be called immediately and the i2c command
+	 * would be reported as completed.
+	 * Also when a write transaction is managed by the DMA controller,
+	 * enabling the TXCOMP interrupt in this function may lead to a race
+	 * condition since we don't know whether the TXCOMP interrupt is enabled
+	 * before or after the DMA has started to write into THR. So the TXCOMP
+	 * interrupt is enabled later by at91_twi_write_data_dma_callback().
+	 * Immediately after in that DMA callback, we still need to send the
+	 * STOP condition manually writing the corresponding bit into the
+	 * Control Register.
+	 */
+
 	dev_dbg(dev->dev, "transfer: %s %d bytes.\n",
 		(dev->msg->flags & I2C_M_RD) ? "read" : "write", dev->buf_len);
 
@@ -412,26 +450,24 @@ static int at91_do_twi_transfer(struct at91_twi_dev *dev)
 		 * seems to be the best solution.
 		 */
 		if (dev->use_dma && (dev->buf_len > AT91_I2C_DMA_THRESHOLD)) {
+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);
 			at91_twi_read_data_dma(dev);
-			/*
-			 * It is important to enable TXCOMP irq here because
-			 * doing it only when transferring the last two bytes
-			 * will mask NACK errors since TXCOMP is set when a
-			 * NACK occurs.
-			 */
-			at91_twi_write(dev, AT91_TWI_IER,
-			       AT91_TWI_TXCOMP);
-		} else
+		} else {
 			at91_twi_write(dev, AT91_TWI_IER,
-			       AT91_TWI_TXCOMP | AT91_TWI_RXRDY);
+				       AT91_TWI_TXCOMP |
+				       AT91_TWI_NACK |
+				       AT91_TWI_RXRDY);
+		}
 	} else {
 		if (dev->use_dma && (dev->buf_len > AT91_I2C_DMA_THRESHOLD)) {
+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);
 			at91_twi_write_data_dma(dev);
-			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);
 		} else {
 			at91_twi_write_next_byte(dev);
 			at91_twi_write(dev, AT91_TWI_IER,
-				AT91_TWI_TXCOMP | AT91_TWI_TXRDY);
+				       AT91_TWI_TXCOMP |
+				       AT91_TWI_NACK |
+				       AT91_TWI_TXRDY);
 		}
 	}
 
diff --git a/drivers/i2c/busses/i2c-cpm.c b/drivers/i2c/busses/i2c-cpm.c
index 3823623..693e4ce 100644
--- a/drivers/i2c/busses/i2c-cpm.c
+++ b/drivers/i2c/busses/i2c-cpm.c
@@ -120,8 +120,8 @@ struct cpm_i2c {
 	cbd_t __iomem *rbase;
 	u_char *txbuf[CPM_MAXBD];
 	u_char *rxbuf[CPM_MAXBD];
-	u32 txdma[CPM_MAXBD];
-	u32 rxdma[CPM_MAXBD];
+	dma_addr_t txdma[CPM_MAXBD];
+	dma_addr_t rxdma[CPM_MAXBD];
 };
 
 static irqreturn_t cpm_i2c_interrupt(int irq, void *dev_id)
diff --git a/drivers/i2c/busses/i2c-rcar.c b/drivers/i2c/busses/i2c-rcar.c
index 8a806f5c..3f2dbd1 100644
--- a/drivers/i2c/busses/i2c-rcar.c
+++ b/drivers/i2c/busses/i2c-rcar.c
@@ -673,15 +673,16 @@ static int rcar_i2c_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	pm_runtime_enable(dev);
+	platform_set_drvdata(pdev, priv);
+
 	ret = i2c_add_numbered_adapter(adap);
 	if (ret < 0) {
 		dev_err(dev, "reg adap failed: %d\n", ret);
+		pm_runtime_disable(dev);
 		return ret;
 	}
 
-	pm_runtime_enable(dev);
-	platform_set_drvdata(pdev, priv);
-
 	dev_info(dev, "probed\n");
 
 	return 0;
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index 48e31ed..9d539cb 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -206,6 +206,7 @@ int i2c_generic_scl_recovery(struct i2c_adapter *adap)
 	adap->bus_recovery_info->set_scl(adap, 1);
 	return i2c_generic_recovery(adap);
 }
+EXPORT_SYMBOL_GPL(i2c_generic_scl_recovery);
 
 int i2c_generic_gpio_recovery(struct i2c_adapter *adap)
 {
@@ -220,6 +221,7 @@ int i2c_generic_gpio_recovery(struct i2c_adapter *adap)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(i2c_generic_gpio_recovery);
 
 int i2c_recover_bus(struct i2c_adapter *adap)
 {
@@ -229,6 +231,7 @@ int i2c_recover_bus(struct i2c_adapter *adap)
 	dev_dbg(&adap->dev, "Trying i2c bus recovery\n");
 	return adap->bus_recovery_info->recover_bus(adap);
 }
+EXPORT_SYMBOL_GPL(i2c_recover_bus);
 
 static int i2c_device_probe(struct device *dev)
 {
diff --git a/drivers/iio/accel/kxsd9.c b/drivers/iio/accel/kxsd9.c
index 7c9a1d9..a22c427 100644
--- a/drivers/iio/accel/kxsd9.c
+++ b/drivers/iio/accel/kxsd9.c
@@ -81,7 +81,7 @@ static int kxsd9_write_scale(struct iio_dev *indio_dev, int micro)
 
 	mutex_lock(&st->buf_lock);
 	ret = spi_w8r8(st->us, KXSD9_READ(KXSD9_REG_CTRL_C));
-	if (ret)
+	if (ret < 0)
 		goto error_ret;
 	st->tx[0] = KXSD9_WRITE(KXSD9_REG_CTRL_C);
 	st->tx[1] = (ret & ~KXSD9_FS_MASK) | i;
@@ -163,7 +163,7 @@ static int kxsd9_read_raw(struct iio_dev *indio_dev,
 		break;
 	case IIO_CHAN_INFO_SCALE:
 		ret = spi_w8r8(st->us, KXSD9_READ(KXSD9_REG_CTRL_C));
-		if (ret)
+		if (ret < 0)
 			goto error_ret;
 		*val2 = kxsd9_micro_scales[ret & KXSD9_FS_MASK];
 		ret = IIO_VAL_INT_PLUS_MICRO;
diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index c2744a7..6569a4e 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -406,7 +406,7 @@ static int ad7266_probe(struct spi_device *spi)
 	st = iio_priv(indio_dev);
 
 	st->reg = regulator_get(&spi->dev, "vref");
-	if (!IS_ERR_OR_NULL(st->reg)) {
+	if (!IS_ERR(st->reg)) {
 		ret = regulator_enable(st->reg);
 		if (ret)
 			goto error_put_reg;
@@ -417,6 +417,10 @@ static int ad7266_probe(struct spi_device *spi)
 
 		st->vref_uv = ret;
 	} else {
+		/* Any other error indicates that the regulator does exist */
+		if (PTR_ERR(st->reg) != -ENODEV)
+			return PTR_ERR(st->reg);
+
 		/* Use internal reference */
 		st->vref_uv = 2500000;
 	}
diff --git a/drivers/iio/adc/ad7793.c b/drivers/iio/adc/ad7793.c
index 334e31f..6bd0c1a 100644
--- a/drivers/iio/adc/ad7793.c
+++ b/drivers/iio/adc/ad7793.c
@@ -101,7 +101,7 @@
 #define AD7795_CH_AIN1M_AIN1M	8 /* AIN1(-) - AIN1(-) */
 
 /* ID Register Bit Designations (AD7793_REG_ID) */
-#define AD7785_ID		0xB
+#define AD7785_ID		0x3
 #define AD7792_ID		0xA
 #define AD7793_ID		0xB
 #define AD7794_ID		0xF
diff --git a/drivers/iio/dac/ad5064.c b/drivers/iio/dac/ad5064.c
index aa26d50..4eda4ea 100644
--- a/drivers/iio/dac/ad5064.c
+++ b/drivers/iio/dac/ad5064.c
@@ -602,10 +602,16 @@ static int ad5064_i2c_write(struct ad5064_state *st, unsigned int cmd,
 	unsigned int addr, unsigned int val)
 {
 	struct i2c_client *i2c = to_i2c_client(st->dev);
+	int ret;
 
 	st->data.i2c[0] = (cmd << 4) | addr;
 	put_unaligned_be16(val, &st->data.i2c[1]);
-	return i2c_master_send(i2c, st->data.i2c, 3);
+
+	ret = i2c_master_send(i2c, st->data.i2c, 3);
+	if (ret < 0)
+		return ret;
+
+	return 0;
 }
 
 static int ad5064_i2c_probe(struct i2c_client *i2c,
diff --git a/drivers/iio/dac/ad5624r_spi.c b/drivers/iio/dac/ad5624r_spi.c
index bb298aa..6deac5a 100644
--- a/drivers/iio/dac/ad5624r_spi.c
+++ b/drivers/iio/dac/ad5624r_spi.c
@@ -22,7 +22,7 @@
 #include "ad5624r.h"
 
 static int ad5624r_spi_write(struct spi_device *spi,
-			     u8 cmd, u8 addr, u16 val, u8 len)
+			     u8 cmd, u8 addr, u16 val, u8 shift)
 {
 	u32 data;
 	u8 msg[3];
@@ -35,7 +35,7 @@ static int ad5624r_spi_write(struct spi_device *spi,
 	 * 14-, 12-bit input code followed by 0, 2, or 4 don't care bits,
 	 * for the AD5664R, AD5644R, and AD5624R, respectively.
 	 */
-	data = (0 << 22) | (cmd << 19) | (addr << 16) | (val << (16 - len));
+	data = (0 << 22) | (cmd << 19) | (addr << 16) | (val << shift);
 	msg[0] = data >> 16;
 	msg[1] = data >> 8;
 	msg[2] = data;
diff --git a/drivers/iio/dac/mcp4725.c b/drivers/iio/dac/mcp4725.c
index a612ec7..029207b 100644
--- a/drivers/iio/dac/mcp4725.c
+++ b/drivers/iio/dac/mcp4725.c
@@ -166,6 +166,7 @@ static int mcp4725_probe(struct i2c_client *client,
 	data->client = client;
 
 	indio_dev->dev.parent = &client->dev;
+	indio_dev->name = id->name;
 	indio_dev->info = &mcp4725_info;
 	indio_dev->channels = &mcp4725_channel;
 	indio_dev->num_channels = 1;
diff --git a/drivers/iio/imu/Kconfig b/drivers/iio/imu/Kconfig
index 4f40a10..6a4316e 100644
--- a/drivers/iio/imu/Kconfig
+++ b/drivers/iio/imu/Kconfig
@@ -38,3 +38,4 @@ config IIO_ADIS_LIB_BUFFER
 	  family.
 
 source "drivers/iio/imu/inv_mpu6050/Kconfig"
+source "drivers/iio/imu/inv_mpu9250/Kconfig"
diff --git a/drivers/iio/imu/Makefile b/drivers/iio/imu/Makefile
index f2f56ce..8993e58 100644
--- a/drivers/iio/imu/Makefile
+++ b/drivers/iio/imu/Makefile
@@ -13,3 +13,4 @@ adis_lib-$(CONFIG_IIO_ADIS_LIB_BUFFER) += adis_buffer.o
 obj-$(CONFIG_IIO_ADIS_LIB) += adis_lib.o
 
 obj-y += inv_mpu6050/
+obj-y += inv_mpu9250/
diff --git a/drivers/iio/imu/adis16400.h b/drivers/iio/imu/adis16400.h
index 0916bf6..1e8fd2e 100644
--- a/drivers/iio/imu/adis16400.h
+++ b/drivers/iio/imu/adis16400.h
@@ -165,6 +165,7 @@ struct adis16400_state {
 	int				filt_int;
 
 	struct adis adis;
+	unsigned long avail_scan_mask[2];
 };
 
 /* At the moment triggers are only used for ring buffer
diff --git a/drivers/iio/imu/adis16400_core.c b/drivers/iio/imu/adis16400_core.c
index 7d60c85..9721c58 100644
--- a/drivers/iio/imu/adis16400_core.c
+++ b/drivers/iio/imu/adis16400_core.c
@@ -438,6 +438,11 @@ static int adis16400_read_raw(struct iio_dev *indio_dev,
 			*val = st->variant->temp_scale_nano / 1000000;
 			*val2 = (st->variant->temp_scale_nano % 1000000);
 			return IIO_VAL_INT_PLUS_MICRO;
+		case IIO_PRESSURE:
+			/* 20 uBar = 0.002kPascal */
+			*val = 0;
+			*val2 = 2000;
+			return IIO_VAL_INT_PLUS_MICRO;
 		default:
 			return -EINVAL;
 		}
@@ -480,10 +485,10 @@ static int adis16400_read_raw(struct iio_dev *indio_dev,
 	}
 }
 
-#define ADIS16400_VOLTAGE_CHAN(addr, bits, name, si) { \
+#define ADIS16400_VOLTAGE_CHAN(addr, bits, name, si, chn) { \
 	.type = IIO_VOLTAGE, \
 	.indexed = 1, \
-	.channel = 0, \
+	.channel = chn, \
 	.extend_name = name, \
 	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
 		BIT(IIO_CHAN_INFO_SCALE), \
@@ -499,10 +504,10 @@ static int adis16400_read_raw(struct iio_dev *indio_dev,
 }
 
 #define ADIS16400_SUPPLY_CHAN(addr, bits) \
-	ADIS16400_VOLTAGE_CHAN(addr, bits, "supply", ADIS16400_SCAN_SUPPLY)
+	ADIS16400_VOLTAGE_CHAN(addr, bits, "supply", ADIS16400_SCAN_SUPPLY, 0)
 
 #define ADIS16400_AUX_ADC_CHAN(addr, bits) \
-	ADIS16400_VOLTAGE_CHAN(addr, bits, NULL, ADIS16400_SCAN_ADC)
+	ADIS16400_VOLTAGE_CHAN(addr, bits, NULL, ADIS16400_SCAN_ADC, 1)
 
 #define ADIS16400_GYRO_CHAN(mod, addr, bits) { \
 	.type = IIO_ANGL_VEL, \
@@ -819,11 +824,6 @@ static const struct iio_info adis16400_info = {
 	.debugfs_reg_access = adis_debugfs_reg_access,
 };
 
-static const unsigned long adis16400_burst_scan_mask[] = {
-	~0UL,
-	0,
-};
-
 static const char * const adis16400_status_error_msgs[] = {
 	[ADIS16400_DIAG_STAT_ZACCL_FAIL] = "Z-axis accelerometer self-test failure",
 	[ADIS16400_DIAG_STAT_YACCL_FAIL] = "Y-axis accelerometer self-test failure",
@@ -871,6 +871,20 @@ static const struct adis_data adis16400_data = {
 		BIT(ADIS16400_DIAG_STAT_POWER_LOW),
 };
 
+static void adis16400_setup_chan_mask(struct adis16400_state *st)
+{
+	const struct adis16400_chip_info *chip_info = st->variant;
+	unsigned i;
+
+	for (i = 0; i < chip_info->num_channels; i++) {
+		const struct iio_chan_spec *ch = &chip_info->channels[i];
+
+		if (ch->scan_index >= 0 &&
+		    ch->scan_index != ADIS16400_SCAN_TIMESTAMP)
+			st->avail_scan_mask[0] |= BIT(ch->scan_index);
+	}
+}
+
 static int adis16400_probe(struct spi_device *spi)
 {
 	struct adis16400_state *st;
@@ -894,8 +908,10 @@ static int adis16400_probe(struct spi_device *spi)
 	indio_dev->info = &adis16400_info;
 	indio_dev->modes = INDIO_DIRECT_MODE;
 
-	if (!(st->variant->flags & ADIS16400_NO_BURST))
-		indio_dev->available_scan_masks = adis16400_burst_scan_mask;
+	if (!(st->variant->flags & ADIS16400_NO_BURST)) {
+		adis16400_setup_chan_mask(st);
+		indio_dev->available_scan_masks = st->avail_scan_mask;
+	}
 
 	ret = adis_init(&st->adis, indio_dev, spi, &adis16400_data);
 	if (ret)
diff --git a/drivers/iio/imu/adis16480.c b/drivers/iio/imu/adis16480.c
index b7db383..b0d05e8 100644
--- a/drivers/iio/imu/adis16480.c
+++ b/drivers/iio/imu/adis16480.c
@@ -110,6 +110,10 @@
 struct adis16480_chip_info {
 	unsigned int num_channels;
 	const struct iio_chan_spec *channels;
+	unsigned int gyro_max_val;
+	unsigned int gyro_max_scale;
+	unsigned int accel_max_val;
+	unsigned int accel_max_scale;
 };
 
 struct adis16480 {
@@ -533,19 +537,21 @@ static int adis16480_set_filter_freq(struct iio_dev *indio_dev,
 static int adis16480_read_raw(struct iio_dev *indio_dev,
 	const struct iio_chan_spec *chan, int *val, int *val2, long info)
 {
+	struct adis16480 *st = iio_priv(indio_dev);
+
 	switch (info) {
 	case IIO_CHAN_INFO_RAW:
 		return adis_single_conversion(indio_dev, chan, 0, val);
 	case IIO_CHAN_INFO_SCALE:
 		switch (chan->type) {
 		case IIO_ANGL_VEL:
-			*val = 0;
-			*val2 = IIO_DEGREE_TO_RAD(20000); /* 0.02 degree/sec */
-			return IIO_VAL_INT_PLUS_MICRO;
+			*val = st->chip_info->gyro_max_scale;
+			*val2 = st->chip_info->gyro_max_val;
+			return IIO_VAL_FRACTIONAL;
 		case IIO_ACCEL:
-			*val = 0;
-			*val2 = IIO_G_TO_M_S_2(800); /* 0.8 mg */
-			return IIO_VAL_INT_PLUS_MICRO;
+			*val = st->chip_info->accel_max_scale;
+			*val2 = st->chip_info->accel_max_val;
+			return IIO_VAL_FRACTIONAL;
 		case IIO_MAGN:
 			*val = 0;
 			*val2 = 100; /* 0.0001 gauss */
@@ -702,18 +708,39 @@ static const struct adis16480_chip_info adis16480_chip_info[] = {
 	[ADIS16375] = {
 		.channels = adis16485_channels,
 		.num_channels = ARRAY_SIZE(adis16485_channels),
+		/*
+		 * storing the value in rad/degree and the scale in degree
+		 * gives us the result in rad and better precession than
+		 * storing the scale directly in rad.
+		 */
+		.gyro_max_val = IIO_RAD_TO_DEGREE(22887),
+		.gyro_max_scale = 300,
+		.accel_max_val = IIO_M_S_2_TO_G(21973),
+		.accel_max_scale = 18,
 	},
 	[ADIS16480] = {
 		.channels = adis16480_channels,
 		.num_channels = ARRAY_SIZE(adis16480_channels),
+		.gyro_max_val = IIO_RAD_TO_DEGREE(22500),
+		.gyro_max_scale = 450,
+		.accel_max_val = IIO_M_S_2_TO_G(12500),
+		.accel_max_scale = 5,
 	},
 	[ADIS16485] = {
 		.channels = adis16485_channels,
 		.num_channels = ARRAY_SIZE(adis16485_channels),
+		.gyro_max_val = IIO_RAD_TO_DEGREE(22500),
+		.gyro_max_scale = 450,
+		.accel_max_val = IIO_M_S_2_TO_G(20000),
+		.accel_max_scale = 5,
 	},
 	[ADIS16488] = {
 		.channels = adis16480_channels,
 		.num_channels = ARRAY_SIZE(adis16480_channels),
+		.gyro_max_val = IIO_RAD_TO_DEGREE(22500),
+		.gyro_max_scale = 450,
+		.accel_max_val = IIO_M_S_2_TO_G(22500),
+		.accel_max_scale = 18,
 	},
 };
 
diff --git a/drivers/iio/imu/adis_buffer.c b/drivers/iio/imu/adis_buffer.c
index 99d8e0b..d0538bc 100644
--- a/drivers/iio/imu/adis_buffer.c
+++ b/drivers/iio/imu/adis_buffer.c
@@ -43,7 +43,7 @@ int adis_update_scan_mode(struct iio_dev *indio_dev,
 		return -ENOMEM;
 
 	rx = adis->buffer;
-	tx = rx + indio_dev->scan_bytes;
+	tx = rx + scan_count;
 
 	spi_message_init(&adis->msg);
 
diff --git a/drivers/iio/imu/adis_trigger.c b/drivers/iio/imu/adis_trigger.c
index e0017c2..f53e9a8 100644
--- a/drivers/iio/imu/adis_trigger.c
+++ b/drivers/iio/imu/adis_trigger.c
@@ -60,7 +60,7 @@ int adis_probe_trigger(struct adis *adis, struct iio_dev *indio_dev)
 	iio_trigger_set_drvdata(adis->trig, adis);
 	ret = iio_trigger_register(adis->trig);
 
-	indio_dev->trig = adis->trig;
+	indio_dev->trig = iio_trigger_get(adis->trig);
 	if (ret)
 		goto error_free_irq;
 
diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_ring.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_ring.c
index 7da0832..01d661e 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_ring.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_ring.c
@@ -25,6 +25,16 @@
 #include <linux/poll.h>
 #include "inv_mpu_iio.h"
 
+static void inv_clear_kfifo(struct inv_mpu6050_state *st)
+{
+	unsigned long flags;
+
+	/* take the spin lock sem to avoid interrupt kick in */
+	spin_lock_irqsave(&st->time_stamp_lock, flags);
+	kfifo_reset(&st->timestamps);
+	spin_unlock_irqrestore(&st->time_stamp_lock, flags);
+}
+
 int inv_reset_fifo(struct iio_dev *indio_dev)
 {
 	int result;
@@ -51,6 +61,10 @@ int inv_reset_fifo(struct iio_dev *indio_dev)
 					INV_MPU6050_BIT_FIFO_RST);
 	if (result)
 		goto reset_fifo_fail;
+
+	/* clear timestamps fifo */
+	inv_clear_kfifo(st);
+
 	/* enable interrupt */
 	if (st->chip_config.accl_fifo_enable ||
 	    st->chip_config.gyro_fifo_enable) {
@@ -84,16 +98,6 @@ reset_fifo_fail:
 	return result;
 }
 
-static void inv_clear_kfifo(struct inv_mpu6050_state *st)
-{
-	unsigned long flags;
-
-	/* take the spin lock sem to avoid interrupt kick in */
-	spin_lock_irqsave(&st->time_stamp_lock, flags);
-	kfifo_reset(&st->timestamps);
-	spin_unlock_irqrestore(&st->time_stamp_lock, flags);
-}
-
 /**
  * inv_mpu6050_irq_handler() - Cache a timestamp at each data ready interrupt.
  */
@@ -187,7 +191,6 @@ end_session:
 flush_fifo:
 	/* Flush HW and SW FIFOs. */
 	inv_reset_fifo(indio_dev);
-	inv_clear_kfifo(st);
 	mutex_unlock(&indio_dev->mlock);
 	iio_trigger_notify_done(indio_dev->trig);
 
diff --git a/drivers/iio/imu/inv_mpu9250/Kconfig b/drivers/iio/imu/inv_mpu9250/Kconfig
new file mode 100644
index 0000000..eef999c
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu9250/Kconfig
@@ -0,0 +1,30 @@
+#
+# inv-mpu9250 drivers for Invensense MPU devices and combos
+#
+
+config INV_MPU9250_IIO
+	tristate
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+
+config INV_MPU9250_I2C
+	tristate "Invensense MPU9250 devices (I2C)"
+	depends on I2C_MUX
+	select INV_MPU9250_IIO
+	select REGMAP_I2C
+	help
+	  This driver supports the Invensense MPU9250 motion tracking
+	  devices over I2C.
+	  This driver can be built as a module. The module will be called
+	  inv-mpu9250-i2c.
+
+config INV_MPU9250_SPI
+	tristate "Invensense MPU9250 devices (SPI)"
+	depends on SPI_MASTER
+	select INV_MPU9250_IIO
+	select REGMAP_SPI
+	help
+	  This driver supports the Invensense MPU9250 motion tracking
+	  devices over SPI.
+	  This driver can be built as a module. The module will be called
+	  inv-mpu9250-spi.
diff --git a/drivers/iio/imu/inv_mpu9250/Makefile b/drivers/iio/imu/inv_mpu9250/Makefile
new file mode 100644
index 0000000..88aa5f7
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu9250/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for Invensense MPU9250 device.
+#
+
+obj-$(CONFIG_INV_MPU9250_IIO) += inv-mpu9250.o
+inv-mpu9250-objs := inv_mpu_core.o inv_mpu_ring.o inv_mpu_trigger.o
+
+obj-$(CONFIG_INV_MPU9250_I2C) += inv-mpu9250-i2c.o
+inv-mpu9250-i2c-objs := inv_mpu_i2c.o inv_mpu_acpi.o
+
+obj-$(CONFIG_INV_MPU9250_SPI) += inv-mpu9250-spi.o
+inv-mpu9250-spi-objs := inv_mpu_spi.o inv_mpu_i2cmst.o
\ No newline at end of file
diff --git a/drivers/iio/imu/inv_mpu9250/inv_mpu_acpi.c b/drivers/iio/imu/inv_mpu9250/inv_mpu_acpi.c
new file mode 100644
index 0000000..f62b8bd
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu9250/inv_mpu_acpi.c
@@ -0,0 +1,213 @@
+/*
+ * inv_mpu_acpi: ACPI processing for creating client devices
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifdef CONFIG_ACPI
+
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/dmi.h>
+#include <linux/acpi.h>
+#include "inv_mpu_iio.h"
+
+enum inv_mpu_product_name {
+	INV_MPU_NOT_MATCHED,
+	INV_MPU_ASUS_T100TA,
+};
+
+static enum inv_mpu_product_name matched_product_name;
+
+static int __init asus_t100_matched(const struct dmi_system_id *d)
+{
+	matched_product_name = INV_MPU_ASUS_T100TA;
+
+	return 0;
+}
+
+static const struct dmi_system_id inv_mpu_dev_list[] = {
+	{
+	.callback = asus_t100_matched,
+	.ident = "Asus Transformer Book T100",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "T100TA"),
+			DMI_MATCH(DMI_PRODUCT_VERSION, "1.0"),
+		},
+	},
+	/* Add more matching tables here..*/
+	{}
+};
+
+static int asus_acpi_get_sensor_info(struct acpi_device *adev,
+				     struct i2c_client *client,
+				     struct i2c_board_info *info)
+{
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	int i;
+	acpi_status status;
+	union acpi_object *cpm;
+
+	status = acpi_evaluate_object(adev->handle, "CNF0", NULL, &buffer);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	cpm = buffer.pointer;
+	for (i = 0; i < cpm->package.count; ++i) {
+		union acpi_object *elem;
+		int j;
+
+		elem = &cpm->package.elements[i];
+		for (j = 0; j < elem->package.count; ++j) {
+			union acpi_object *sub_elem;
+
+			sub_elem = &elem->package.elements[j];
+			if (sub_elem->type == ACPI_TYPE_STRING)
+				strlcpy(info->type, sub_elem->string.pointer,
+					sizeof(info->type));
+			else if (sub_elem->type == ACPI_TYPE_INTEGER) {
+				if (sub_elem->integer.value != client->addr) {
+					info->addr = sub_elem->integer.value;
+					break; /* Not a MPU6500 primary */
+				}
+			}
+		}
+	}
+
+	kfree(buffer.pointer);
+
+	return cpm->package.count;
+}
+
+static int acpi_i2c_check_resource(struct acpi_resource *ares, void *data)
+{
+	u32 *addr = data;
+
+	if (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
+		struct acpi_resource_i2c_serialbus *sb;
+
+		sb = &ares->data.i2c_serial_bus;
+		if (sb->type == ACPI_RESOURCE_SERIAL_TYPE_I2C) {
+			if (*addr)
+				*addr |= (sb->slave_address << 16);
+			else
+				*addr = sb->slave_address;
+		}
+	}
+
+	/* Tell the ACPI core that we already copied this address */
+	return 1;
+}
+
+static int inv_mpu_process_acpi_config(struct i2c_client *client,
+				       unsigned short *primary_addr,
+				       unsigned short *secondary_addr)
+{
+	const struct acpi_device_id *id;
+	struct acpi_device *adev;
+	u32 i2c_addr = 0;
+	LIST_HEAD(resources);
+	int ret;
+
+	id = acpi_match_device(client->dev.driver->acpi_match_table,
+			       &client->dev);
+	if (!id)
+		return -ENODEV;
+
+	adev = ACPI_COMPANION(&client->dev);
+	if (!adev)
+		return -ENODEV;
+
+	ret = acpi_dev_get_resources(adev, &resources,
+				     acpi_i2c_check_resource, &i2c_addr);
+	if (ret < 0)
+		return ret;
+
+	acpi_dev_free_resource_list(&resources);
+	*primary_addr = i2c_addr & 0x0000ffff;
+	*secondary_addr = (i2c_addr & 0xffff0000) >> 16;
+
+	return 0;
+}
+
+int inv_mpu_acpi_create_mux_client(struct i2c_client *client)
+{
+	struct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(&client->dev));
+
+	st->mux_client = NULL;
+	if (ACPI_HANDLE(&client->dev)) {
+		struct i2c_board_info info;
+		struct acpi_device *adev;
+		int ret = -1;
+
+		adev = ACPI_COMPANION(&client->dev);
+		memset(&info, 0, sizeof(info));
+
+		dmi_check_system(inv_mpu_dev_list);
+		switch (matched_product_name) {
+		case INV_MPU_ASUS_T100TA:
+			ret = asus_acpi_get_sensor_info(adev, client,
+							&info);
+			break;
+		/* Add more matched product processing here */
+		default:
+			break;
+		}
+
+		if (ret < 0) {
+			/* No matching DMI, so create device on INV6XX type */
+			unsigned short primary, secondary;
+
+			ret = inv_mpu_process_acpi_config(client, &primary,
+							  &secondary);
+			if (!ret && secondary) {
+				char *name;
+
+				info.addr = secondary;
+				strlcpy(info.type, dev_name(&adev->dev),
+					sizeof(info.type));
+				name = strchr(info.type, ':');
+				if (name)
+					*name = '\0';
+				strlcat(info.type, "-client",
+					sizeof(info.type));
+			} else
+				return 0; /* no secondary addr, which is OK */
+		}
+		st->mux_client = i2c_new_device(st->muxc->adapter[0], &info);
+		if (!st->mux_client)
+			return -ENODEV;
+	}
+
+	return 0;
+}
+
+void inv_mpu_acpi_delete_mux_client(struct i2c_client *client)
+{
+	struct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(&client->dev));
+
+	if (st->mux_client)
+		i2c_unregister_device(st->mux_client);
+}
+#else
+
+#include "inv_mpu_iio.h"
+
+int inv_mpu_acpi_create_mux_client(struct i2c_client *client)
+{
+	return 0;
+}
+
+void inv_mpu_acpi_delete_mux_client(struct i2c_client *client)
+{
+}
+#endif
diff --git a/drivers/iio/imu/inv_mpu9250/inv_mpu_core.c b/drivers/iio/imu/inv_mpu9250/inv_mpu_core.c
new file mode 100644
index 0000000..a2c8afb
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu9250/inv_mpu_core.c
@@ -0,0 +1,932 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/regmap.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/spinlock.h>
+#include <linux/iio/iio.h>
+#include <linux/acpi.h>
+#include "inv_mpu_iio.h"
+
+/*
+ * this is the gyro scale translated from dynamic range plus/minus
+ * {250, 500, 1000, 2000} to rad/s
+ */
+static const int gyro_scale_6050[] = {133090, 266181, 532362, 1064724};
+
+/*
+ * this is the accel scale translated from dynamic range plus/minus
+ * {2, 4, 8, 16} to m/s^2
+ */
+static const int accel_scale[] = {598, 1196, 2392, 4785};
+
+static const struct inv_mpu6050_reg_map reg_set_6500 = {
+	.sample_rate_div	= INV_MPU6050_REG_SAMPLE_RATE_DIV,
+	.lpf                    = INV_MPU6050_REG_CONFIG,
+	.user_ctrl              = INV_MPU6050_REG_USER_CTRL,
+	.fifo_en                = INV_MPU6050_REG_FIFO_EN,
+	.gyro_config            = INV_MPU6050_REG_GYRO_CONFIG,
+	.accl_config            = INV_MPU6050_REG_ACCEL_CONFIG,
+	.fifo_count_h           = INV_MPU6050_REG_FIFO_COUNT_H,
+	.fifo_r_w               = INV_MPU6050_REG_FIFO_R_W,
+	.raw_gyro               = INV_MPU6050_REG_RAW_GYRO,
+	.raw_accl               = INV_MPU6050_REG_RAW_ACCEL,
+	.temperature            = INV_MPU6050_REG_TEMPERATURE,
+	.int_enable             = INV_MPU6050_REG_INT_ENABLE,
+	.pwr_mgmt_1             = INV_MPU6050_REG_PWR_MGMT_1,
+	.pwr_mgmt_2             = INV_MPU6050_REG_PWR_MGMT_2,
+	.int_pin_cfg		= INV_MPU6050_REG_INT_PIN_CFG,
+	.accl_offset		= INV_MPU6500_REG_ACCEL_OFFSET,
+	.gyro_offset		= INV_MPU6050_REG_GYRO_OFFSET,
+};
+
+static const struct inv_mpu6050_reg_map reg_set_6050 = {
+	.sample_rate_div	= INV_MPU6050_REG_SAMPLE_RATE_DIV,
+	.lpf                    = INV_MPU6050_REG_CONFIG,
+	.user_ctrl              = INV_MPU6050_REG_USER_CTRL,
+	.fifo_en                = INV_MPU6050_REG_FIFO_EN,
+	.gyro_config            = INV_MPU6050_REG_GYRO_CONFIG,
+	.accl_config            = INV_MPU6050_REG_ACCEL_CONFIG,
+	.fifo_count_h           = INV_MPU6050_REG_FIFO_COUNT_H,
+	.fifo_r_w               = INV_MPU6050_REG_FIFO_R_W,
+	.raw_gyro               = INV_MPU6050_REG_RAW_GYRO,
+	.raw_accl               = INV_MPU6050_REG_RAW_ACCEL,
+	.temperature            = INV_MPU6050_REG_TEMPERATURE,
+	.int_enable             = INV_MPU6050_REG_INT_ENABLE,
+	.pwr_mgmt_1             = INV_MPU6050_REG_PWR_MGMT_1,
+	.pwr_mgmt_2             = INV_MPU6050_REG_PWR_MGMT_2,
+	.int_pin_cfg		= INV_MPU6050_REG_INT_PIN_CFG,
+	.accl_offset		= INV_MPU6050_REG_ACCEL_OFFSET,
+	.gyro_offset		= INV_MPU6050_REG_GYRO_OFFSET,
+};
+
+static const struct inv_mpu6050_chip_config chip_config_6050 = {
+	.fsr = INV_MPU6050_FSR_2000DPS,
+	.lpf = INV_MPU6050_FILTER_20HZ,
+	.fifo_rate = INV_MPU6050_INIT_FIFO_RATE,
+	.gyro_fifo_enable = false,
+	.accl_fifo_enable = false,
+	.accl_fs = INV_MPU6050_FS_02G,
+};
+
+/* Indexed by enum inv_devices */
+static const struct inv_mpu6050_hw hw_info[] = {
+	{
+		.whoami = INV_MPU6050_WHOAMI_VALUE,
+		.name = "MPU6050",
+		.reg = &reg_set_6050,
+		.config = &chip_config_6050,
+	},
+	{
+		.whoami = INV_MPU6500_WHOAMI_VALUE,
+		.name = "MPU6500",
+		.reg = &reg_set_6500,
+		.config = &chip_config_6050,
+	},
+	{
+		.whoami = INV_MPU6000_WHOAMI_VALUE,
+		.name = "MPU6000",
+		.reg = &reg_set_6050,
+		.config = &chip_config_6050,
+	},
+	{
+		.whoami = INV_MPU9150_WHOAMI_VALUE,
+		.name = "MPU9150",
+		.reg = &reg_set_6050,
+		.config = &chip_config_6050,
+	},
+	{
+		.whoami = INV_MPU9250_WHOAMI_VALUE,
+		.name = "MPU9250",
+		.reg = &reg_set_6500,
+		.config = &chip_config_6050,
+	},
+};
+
+int inv_mpu6050_switch_engine(struct inv_mpu6050_state *st, bool en, u32 mask)
+{
+	unsigned int d, mgmt_1;
+	int result;
+	/*
+	 * switch clock needs to be careful. Only when gyro is on, can
+	 * clock source be switched to gyro. Otherwise, it must be set to
+	 * internal clock
+	 */
+	if (mask == INV_MPU6050_BIT_PWR_GYRO_STBY) {
+		result = regmap_read(st->map, st->reg->pwr_mgmt_1, &mgmt_1);
+		if (result)
+			return result;
+
+		mgmt_1 &= ~INV_MPU6050_BIT_CLK_MASK;
+	}
+
+	if ((mask == INV_MPU6050_BIT_PWR_GYRO_STBY) && (!en)) {
+		/*
+		 * turning off gyro requires switch to internal clock first.
+		 * Then turn off gyro engine
+		 */
+		mgmt_1 |= INV_CLK_INTERNAL;
+		result = regmap_write(st->map, st->reg->pwr_mgmt_1, mgmt_1);
+		if (result)
+			return result;
+	}
+
+	result = regmap_read(st->map, st->reg->pwr_mgmt_2, &d);
+	if (result)
+		return result;
+	if (en)
+		d &= ~mask;
+	else
+		d |= mask;
+	result = regmap_write(st->map, st->reg->pwr_mgmt_2, d);
+	if (result)
+		return result;
+
+	if (en) {
+		/* Wait for output stabilize */
+		msleep(INV_MPU6050_TEMP_UP_TIME);
+		if (mask == INV_MPU6050_BIT_PWR_GYRO_STBY) {
+			/* switch internal clock to PLL */
+			mgmt_1 |= INV_CLK_PLL;
+			result = regmap_write(st->map,
+					      st->reg->pwr_mgmt_1, mgmt_1);
+			if (result)
+				return result;
+		}
+	}
+
+	return 0;
+}
+
+int inv_mpu6050_set_power_itg(struct inv_mpu6050_state *st, bool power_on)
+{
+	int result = 0;
+
+	if (power_on) {
+		/* Already under indio-dev->mlock mutex */
+		if (!st->powerup_count)
+			result = regmap_write(st->map, st->reg->pwr_mgmt_1, 0);
+		if (!result)
+			st->powerup_count++;
+	} else {
+		st->powerup_count--;
+		if (!st->powerup_count)
+			result = regmap_write(st->map, st->reg->pwr_mgmt_1,
+					      INV_MPU6050_BIT_SLEEP);
+	}
+
+	if (result)
+		return result;
+
+	if (power_on)
+		usleep_range(INV_MPU6050_REG_UP_TIME_MIN,
+			     INV_MPU6050_REG_UP_TIME_MAX);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_mpu6050_set_power_itg);
+
+/**
+ *  inv_mpu6050_init_config() - Initialize hardware, disable FIFO.
+ *
+ *  Initial configuration:
+ *  FSR: ± 2000DPS
+ *  DLPF: 20Hz
+ *  FIFO rate: 50Hz
+ *  Clock source: Gyro PLL
+ */
+static int inv_mpu6050_init_config(struct iio_dev *indio_dev)
+{
+	int result;
+	u8 d;
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+
+	result = inv_mpu6050_set_power_itg(st, true);
+	if (result)
+		return result;
+	d = (INV_MPU6050_FSR_2000DPS << INV_MPU6050_GYRO_CONFIG_FSR_SHIFT);
+	result = regmap_write(st->map, st->reg->gyro_config, d);
+	if (result)
+		return result;
+
+	d = INV_MPU6050_FILTER_20HZ;
+	result = regmap_write(st->map, st->reg->lpf, d);
+	if (result)
+		return result;
+
+	d = INV_MPU6050_ONE_K_HZ / INV_MPU6050_INIT_FIFO_RATE - 1;
+	result = regmap_write(st->map, st->reg->sample_rate_div, d);
+	if (result)
+		return result;
+
+	d = (INV_MPU6050_FS_02G << INV_MPU6050_ACCL_CONFIG_FSR_SHIFT);
+	result = regmap_write(st->map, st->reg->accl_config, d);
+	if (result)
+		return result;
+
+	memcpy(&st->chip_config, hw_info[st->chip_type].config,
+	       sizeof(struct inv_mpu6050_chip_config));
+	result = inv_mpu6050_set_power_itg(st, false);
+
+	return result;
+}
+
+static int inv_mpu6050_sensor_set(struct inv_mpu6050_state  *st, int reg,
+				int axis, int val)
+{
+	int ind, result;
+	__be16 d = cpu_to_be16(val);
+
+	ind = (axis - IIO_MOD_X) * 2;
+	result = regmap_bulk_write(st->map, reg + ind, (u8 *)&d, 2);
+	if (result)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int inv_mpu6050_sensor_show(struct inv_mpu6050_state  *st, int reg,
+				   int axis, int *val)
+{
+	int ind, result;
+	__be16 d;
+
+	ind = (axis - IIO_MOD_X) * 2;
+	result = regmap_bulk_read(st->map, reg + ind, (u8 *)&d, 2);
+	if (result)
+		return -EINVAL;
+	*val = (short)be16_to_cpup(&d);
+
+	return IIO_VAL_INT;
+}
+
+static int
+inv_mpu6050_read_raw(struct iio_dev *indio_dev,
+		     struct iio_chan_spec const *chan,
+		     int *val, int *val2, long mask)
+{
+	struct inv_mpu6050_state  *st = iio_priv(indio_dev);
+	int ret = 0;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+	{
+		int result;
+
+		ret = IIO_VAL_INT;
+		result = 0;
+		mutex_lock(&indio_dev->mlock);
+		if (!st->chip_config.enable) {
+			result = inv_mpu6050_set_power_itg(st, true);
+			if (result)
+				goto error_read_raw;
+		}
+		/* when enable is on, power is already on */
+		switch (chan->type) {
+		case IIO_ANGL_VEL:
+			if (!st->chip_config.gyro_fifo_enable ||
+			    !st->chip_config.enable) {
+				result = inv_mpu6050_switch_engine(st, true,
+						INV_MPU6050_BIT_PWR_GYRO_STBY);
+				if (result)
+					goto error_read_raw;
+			}
+			ret = inv_mpu6050_sensor_show(st, st->reg->raw_gyro,
+						      chan->channel2, val);
+			if (!st->chip_config.gyro_fifo_enable ||
+			    !st->chip_config.enable) {
+				result = inv_mpu6050_switch_engine(st, false,
+						INV_MPU6050_BIT_PWR_GYRO_STBY);
+				if (result)
+					goto error_read_raw;
+			}
+			break;
+		case IIO_ACCEL:
+			if (!st->chip_config.accl_fifo_enable ||
+			    !st->chip_config.enable) {
+				result = inv_mpu6050_switch_engine(st, true,
+						INV_MPU6050_BIT_PWR_ACCL_STBY);
+				if (result)
+					goto error_read_raw;
+			}
+			ret = inv_mpu6050_sensor_show(st, st->reg->raw_accl,
+						      chan->channel2, val);
+			if (!st->chip_config.accl_fifo_enable ||
+			    !st->chip_config.enable) {
+				result = inv_mpu6050_switch_engine(st, false,
+						INV_MPU6050_BIT_PWR_ACCL_STBY);
+				if (result)
+					goto error_read_raw;
+			}
+			break;
+		case IIO_TEMP:
+			if (!st->chip_config.enable) {
+				result = inv_mpu6050_switch_engine(st, true,
+                                                INV_MPU6050_BIT_PWR_TEMP_STBY);
+                                if (result)
+                                        goto error_read_raw;
+                        }
+			/* wait for stablization */
+			msleep(INV_MPU6050_SENSOR_UP_TIME);
+			ret = inv_mpu6050_sensor_show(st, st->reg->temperature,
+						IIO_MOD_X, val);
+			if (!st->chip_config.enable) {
+                                result = inv_mpu6050_switch_engine(st, false,
+                                                INV_MPU6050_BIT_PWR_TEMP_STBY);
+                                if (result)
+                                        goto error_read_raw;
+                        }
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+error_read_raw:
+		if (!st->chip_config.enable)
+			result |= inv_mpu6050_set_power_itg(st, false);
+		mutex_unlock(&indio_dev->mlock);
+		if (result)
+			return result;
+
+		return ret;
+	}
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_ANGL_VEL:
+			*val  = 0;
+			*val2 = gyro_scale_6050[st->chip_config.fsr];
+
+			return IIO_VAL_INT_PLUS_NANO;
+		case IIO_ACCEL:
+			*val = 0;
+			*val2 = accel_scale[st->chip_config.accl_fs];
+
+			return IIO_VAL_INT_PLUS_MICRO;
+		case IIO_TEMP:
+			*val = 0;
+			*val2 = INV_MPU6050_TEMP_SCALE;
+
+			return IIO_VAL_INT_PLUS_MICRO;
+		default:
+			return -EINVAL;
+		}
+	case IIO_CHAN_INFO_OFFSET:
+		switch (chan->type) {
+		case IIO_TEMP:
+			*val = INV_MPU6050_TEMP_OFFSET;
+
+			return IIO_VAL_INT;
+		default:
+			return -EINVAL;
+		}
+	case IIO_CHAN_INFO_CALIBBIAS:
+		switch (chan->type) {
+		case IIO_ANGL_VEL:
+			ret = inv_mpu6050_sensor_show(st, st->reg->gyro_offset,
+						chan->channel2, val);
+			return IIO_VAL_INT;
+		case IIO_ACCEL:
+			ret = inv_mpu6050_sensor_show(st, st->reg->accl_offset,
+						chan->channel2, val);
+			return IIO_VAL_INT;
+
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_mpu6050_write_gyro_scale(struct inv_mpu6050_state *st, int val)
+{
+	int result, i;
+	u8 d;
+
+	for (i = 0; i < ARRAY_SIZE(gyro_scale_6050); ++i) {
+		if (gyro_scale_6050[i] == val) {
+			d = (i << INV_MPU6050_GYRO_CONFIG_FSR_SHIFT);
+			result = regmap_write(st->map, st->reg->gyro_config, d);
+			if (result)
+				return result;
+
+			st->chip_config.fsr = i;
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static int inv_write_raw_get_fmt(struct iio_dev *indio_dev,
+				 struct iio_chan_spec const *chan, long mask)
+{
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_ANGL_VEL:
+			return IIO_VAL_INT_PLUS_NANO;
+		default:
+			return IIO_VAL_INT_PLUS_MICRO;
+		}
+	default:
+		return IIO_VAL_INT_PLUS_MICRO;
+	}
+
+	return -EINVAL;
+}
+
+static int inv_mpu6050_write_accel_scale(struct inv_mpu6050_state *st, int val)
+{
+	int result, i;
+	u8 d;
+
+	for (i = 0; i < ARRAY_SIZE(accel_scale); ++i) {
+		if (accel_scale[i] == val) {
+			d = (i << INV_MPU6050_ACCL_CONFIG_FSR_SHIFT);
+			result = regmap_write(st->map, st->reg->accl_config, d);
+			if (result)
+				return result;
+
+			st->chip_config.accl_fs = i;
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static int inv_mpu6050_write_raw(struct iio_dev *indio_dev,
+				 struct iio_chan_spec const *chan,
+				 int val, int val2, long mask)
+{
+	struct inv_mpu6050_state  *st = iio_priv(indio_dev);
+	int result;
+
+	mutex_lock(&indio_dev->mlock);
+	/*
+	 * we should only update scale when the chip is disabled, i.e.
+	 * not running
+	 */
+	if (st->chip_config.enable) {
+		result = -EBUSY;
+		goto error_write_raw;
+	}
+	result = inv_mpu6050_set_power_itg(st, true);
+	if (result)
+		goto error_write_raw;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_ANGL_VEL:
+			result = inv_mpu6050_write_gyro_scale(st, val2);
+			break;
+		case IIO_ACCEL:
+			result = inv_mpu6050_write_accel_scale(st, val2);
+			break;
+		default:
+			result = -EINVAL;
+			break;
+		}
+		break;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		switch (chan->type) {
+		case IIO_ANGL_VEL:
+			result = inv_mpu6050_sensor_set(st,
+							st->reg->gyro_offset,
+							chan->channel2, val);
+			break;
+		case IIO_ACCEL:
+			result = inv_mpu6050_sensor_set(st,
+							st->reg->accl_offset,
+							chan->channel2, val);
+			break;
+		default:
+			result = -EINVAL;
+		}
+	default:
+		result = -EINVAL;
+		break;
+	}
+
+error_write_raw:
+	result |= inv_mpu6050_set_power_itg(st, false);
+	mutex_unlock(&indio_dev->mlock);
+
+	return result;
+}
+
+/**
+ *  inv_mpu6050_set_lpf() - set low pass filer based on fifo rate.
+ *
+ *                  Based on the Nyquist principle, the sampling rate must
+ *                  exceed twice of the bandwidth of the signal, or there
+ *                  would be alising. This function basically search for the
+ *                  correct low pass parameters based on the fifo rate, e.g,
+ *                  sampling frequency.
+ */
+static int inv_mpu6050_set_lpf(struct inv_mpu6050_state *st, int rate)
+{
+	const int hz[] = {188, 98, 42, 20, 10, 5};
+	const int d[] = {INV_MPU6050_FILTER_188HZ, INV_MPU6050_FILTER_98HZ,
+			INV_MPU6050_FILTER_42HZ, INV_MPU6050_FILTER_20HZ,
+			INV_MPU6050_FILTER_10HZ, INV_MPU6050_FILTER_5HZ};
+	int i, h, result;
+	u8 data;
+
+	h = (rate >> 1);
+	i = 0;
+	while ((h < hz[i]) && (i < ARRAY_SIZE(d) - 1))
+		i++;
+	data = d[i];
+	result = regmap_write(st->map, st->reg->lpf, data);
+	if (result)
+		return result;
+	st->chip_config.lpf = data;
+
+	return 0;
+}
+
+/**
+ * inv_mpu6050_fifo_rate_store() - Set fifo rate.
+ */
+static ssize_t
+inv_mpu6050_fifo_rate_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	s32 fifo_rate;
+	u8 d;
+	int result;
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+
+	if (kstrtoint(buf, 10, &fifo_rate))
+		return -EINVAL;
+	if (fifo_rate < INV_MPU6050_MIN_FIFO_RATE ||
+	    fifo_rate > INV_MPU6050_MAX_FIFO_RATE)
+		return -EINVAL;
+	if (fifo_rate == st->chip_config.fifo_rate)
+		return count;
+
+	mutex_lock(&indio_dev->mlock);
+	if (st->chip_config.enable) {
+		result = -EBUSY;
+		goto fifo_rate_fail;
+	}
+	result = inv_mpu6050_set_power_itg(st, true);
+	if (result)
+		goto fifo_rate_fail;
+
+	d = INV_MPU6050_ONE_K_HZ / fifo_rate - 1;
+	result = regmap_write(st->map, st->reg->sample_rate_div, d);
+	if (result)
+		goto fifo_rate_fail;
+	st->chip_config.fifo_rate = fifo_rate;
+
+	result = inv_mpu6050_set_lpf(st, fifo_rate);
+	if (result)
+		goto fifo_rate_fail;
+
+fifo_rate_fail:
+	result |= inv_mpu6050_set_power_itg(st, false);
+	mutex_unlock(&indio_dev->mlock);
+	if (result)
+		return result;
+
+	return count;
+}
+
+/**
+ * inv_fifo_rate_show() - Get the current sampling rate.
+ */
+static ssize_t
+inv_fifo_rate_show(struct device *dev, struct device_attribute *attr,
+		   char *buf)
+{
+	struct inv_mpu6050_state *st = iio_priv(dev_to_iio_dev(dev));
+
+	return sprintf(buf, "%d\n", st->chip_config.fifo_rate);
+}
+
+/**
+ * inv_attr_show() - calling this function will show current
+ *                    parameters.
+ */
+static ssize_t inv_attr_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct inv_mpu6050_state *st = iio_priv(dev_to_iio_dev(dev));
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	const char **m;
+
+	switch (this_attr->address) {
+	/*
+	 * In MPU6050, the two matrix are the same because gyro and accel
+	 * are integrated in one chip
+	 */
+	case ATTR_GYRO_MATRIX:
+	case ATTR_ACCL_MATRIX:
+		m = st->orientation.rotation;
+
+		return sprintf(buf, "%s, %s, %s; %s, %s, %s; %s, %s, %s\n",
+			m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);
+	default:
+		return -EINVAL;
+	}
+}
+
+/**
+ * inv_mpu6050_validate_trigger() - validate_trigger callback for invensense
+ *                                  MPU6050 device.
+ * @indio_dev: The IIO device
+ * @trig: The new trigger
+ *
+ * Returns: 0 if the 'trig' matches the trigger registered by the MPU6050
+ * device, -EINVAL otherwise.
+ */
+static int inv_mpu6050_validate_trigger(struct iio_dev *indio_dev,
+					struct iio_trigger *trig)
+{
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+
+	if (st->trig != trig)
+		return -EINVAL;
+
+	return 0;
+}
+
+#define INV_MPU6050_CHAN(_type, _channel2, _index)                    \
+	{                                                             \
+		.type = _type,                                        \
+		.modified = 1,                                        \
+		.channel2 = _channel2,                                \
+		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |	      \
+				      BIT(IIO_CHAN_INFO_CALIBBIAS),   \
+		.scan_index = _index,                                 \
+		.scan_type = {                                        \
+				.sign = 's',                          \
+				.realbits = 16,                       \
+				.storagebits = 16,                    \
+				.shift = 0,                           \
+				.endianness = IIO_BE,                 \
+			     },                                       \
+	}
+
+static const struct iio_chan_spec inv_mpu_channels[] = {
+	IIO_CHAN_SOFT_TIMESTAMP(INV_MPU6050_SCAN_TIMESTAMP),
+	/*
+	 * Note that temperature should only be via polled reading only,
+	 * not the final scan elements output.
+	 */
+	{
+		.type = IIO_TEMP,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)
+				| BIT(IIO_CHAN_INFO_OFFSET)
+				| BIT(IIO_CHAN_INFO_SCALE),
+		.scan_index = -1,
+	},
+	INV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_X, INV_MPU6050_SCAN_GYRO_X),
+	INV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_Y, INV_MPU6050_SCAN_GYRO_Y),
+	INV_MPU6050_CHAN(IIO_ANGL_VEL, IIO_MOD_Z, INV_MPU6050_SCAN_GYRO_Z),
+
+	INV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_X, INV_MPU6050_SCAN_ACCL_X),
+	INV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_Y, INV_MPU6050_SCAN_ACCL_Y),
+	INV_MPU6050_CHAN(IIO_ACCEL, IIO_MOD_Z, INV_MPU6050_SCAN_ACCL_Z),
+};
+
+/* constant IIO attribute */
+static IIO_CONST_ATTR_SAMP_FREQ_AVAIL("10 20 50 100 200 500");
+static IIO_CONST_ATTR(in_anglvel_scale_available,
+					  "0.000133090 0.000266181 0.000532362 0.001064724");
+static IIO_CONST_ATTR(in_accel_scale_available,
+					  "0.000598 0.001196 0.002392 0.004785");
+static IIO_DEV_ATTR_SAMP_FREQ(S_IRUGO | S_IWUSR, inv_fifo_rate_show,
+	inv_mpu6050_fifo_rate_store);
+
+/* Deprecated: kept for userspace backward compatibility. */
+static IIO_DEVICE_ATTR(in_gyro_matrix, S_IRUGO, inv_attr_show, NULL,
+	ATTR_GYRO_MATRIX);
+static IIO_DEVICE_ATTR(in_accel_matrix, S_IRUGO, inv_attr_show, NULL,
+	ATTR_ACCL_MATRIX);
+
+static struct attribute *inv_attributes[] = {
+	&iio_dev_attr_in_gyro_matrix.dev_attr.attr,  /* deprecated */
+	&iio_dev_attr_in_accel_matrix.dev_attr.attr, /* deprecated */
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_const_attr_in_accel_scale_available.dev_attr.attr,
+	&iio_const_attr_in_anglvel_scale_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group inv_attribute_group = {
+	.attrs = inv_attributes
+};
+
+static const struct iio_info mpu_info = {
+	.driver_module = THIS_MODULE,
+	.read_raw = &inv_mpu6050_read_raw,
+	.write_raw = &inv_mpu6050_write_raw,
+	.write_raw_get_fmt = &inv_write_raw_get_fmt,
+	.attrs = &inv_attribute_group,
+	.validate_trigger = inv_mpu6050_validate_trigger,
+};
+
+/**
+ *  inv_check_and_setup_chip() - check and setup chip.
+ */
+static int inv_check_and_setup_chip(struct inv_mpu6050_state *st)
+{
+	int result;
+	unsigned int regval;
+
+	st->hw  = &hw_info[st->chip_type];
+	st->reg = hw_info[st->chip_type].reg;
+
+	/* reset to make sure previous state are not there */
+	result = regmap_write(st->map, st->reg->pwr_mgmt_1,
+			      INV_MPU6050_BIT_H_RESET);
+	if (result)
+		return result;
+	msleep(INV_MPU6050_POWER_UP_TIME);
+
+	/* check chip self-identification */
+	result = regmap_read(st->map, INV_MPU6050_REG_WHOAMI, &regval);
+	if (result)
+		return result;
+	if (regval != st->hw->whoami) {
+		dev_warn(st->dev,
+				"whoami mismatch got %#02x expected %#02hhx for %s\n",
+				regval, st->hw->whoami, st->hw->name);
+	}
+
+	/*
+	 * toggle power state. After reset, the sleep bit could be on
+	 * or off depending on the OTP settings. Toggling power would
+	 * make it in a definite state as well as making the hardware
+	 * state align with the software state
+	 */
+	result = inv_mpu6050_set_power_itg(st, false);
+	if (result)
+		return result;
+	result = inv_mpu6050_set_power_itg(st, true);
+	if (result)
+		return result;
+
+	result = inv_mpu6050_switch_engine(st, false,
+					   INV_MPU6050_BIT_PWR_ACCL_STBY);
+	if (result)
+		return result;
+	result = inv_mpu6050_switch_engine(st, false,
+					   INV_MPU6050_BIT_PWR_GYRO_STBY);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+int inv_mpu_core_probe(struct device *dev, struct regmap *regmap, int irq, const char *name,
+		int (*inv_mpu_bus_setup)(struct iio_dev *), int chip_type)
+{
+	struct inv_mpu6050_state *st;
+	struct iio_dev *indio_dev;
+	int result;
+
+	indio_dev = iio_device_alloc(sizeof(*st));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	BUILD_BUG_ON(ARRAY_SIZE(hw_info) != INV_NUM_PARTS);
+	if (chip_type < 0 || chip_type >= INV_NUM_PARTS) {
+		dev_err(dev, "Bad invensense chip_type=%d name=%s\n",
+				chip_type, name);
+		return -ENODEV;
+	}
+	st = iio_priv(indio_dev);
+	st->chip_type = chip_type;
+	st->powerup_count = 0;
+	st->irq = irq;
+	st->map = regmap;
+	st->dev = dev;
+
+	result = of_property_read_string_array(dev->of_node,
+			"mount-matrix", st->orientation.rotation,
+			ARRAY_SIZE(st->orientation.rotation));
+
+	if (result != ARRAY_SIZE(st->orientation.rotation)) {
+		dev_err(dev, "Failed to retrieve mounting matrix %d\n", result);
+		return result;
+	}
+
+	/* power is turned on inside check chip type*/
+	result = inv_check_and_setup_chip(st);
+	if (result)
+		return result;
+
+	if (inv_mpu_bus_setup)
+		inv_mpu_bus_setup(indio_dev);
+
+	result = inv_mpu6050_init_config(indio_dev);
+	if (result) {
+		dev_err(dev, "Could not initialize device.\n");
+		return result;
+	}
+
+	dev_set_drvdata(dev, indio_dev);
+	indio_dev->dev.parent = dev;
+	/* name will be NULL when enumerated via ACPI */
+	if (name)
+		indio_dev->name = name;
+	else
+		indio_dev->name = dev_name(dev);
+	indio_dev->channels = inv_mpu_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);
+
+	indio_dev->info = &mpu_info;
+	indio_dev->modes = INDIO_BUFFER_TRIGGERED;
+
+	result = iio_triggered_buffer_setup(indio_dev,
+					    inv_mpu6050_irq_handler,
+					    inv_mpu6050_read_fifo,
+					    NULL);
+	if (result) {
+		dev_err(dev, "configure buffer fail %d\n", result);
+		return result;
+	}
+	result = inv_mpu6050_probe_trigger(indio_dev);
+	if (result) {
+		dev_err(dev, "trigger probe fail %d\n", result);
+		goto out_unreg_ring;
+	}
+
+	INIT_KFIFO(st->timestamps);
+	spin_lock_init(&st->time_stamp_lock);
+	result = iio_device_register(indio_dev);
+	if (result) {
+		dev_err(dev, "IIO register fail %d\n", result);
+		goto out_remove_trigger;
+	}
+
+	return 0;
+
+out_remove_trigger:
+	inv_mpu6050_remove_trigger(st);
+out_unreg_ring:
+	iio_triggered_buffer_cleanup(indio_dev);
+	return result;
+}
+EXPORT_SYMBOL_GPL(inv_mpu_core_probe);
+
+int inv_mpu_core_remove(struct device  *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+
+	iio_device_unregister(indio_dev);
+	inv_mpu6050_remove_trigger(iio_priv(indio_dev));
+	iio_triggered_buffer_cleanup(indio_dev);
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(inv_mpu_core_remove);
+
+#ifdef CONFIG_PM_SLEEP
+
+static int inv_mpu_resume(struct device *dev)
+{
+	return inv_mpu6050_set_power_itg(iio_priv(dev_get_drvdata(dev)), true);
+}
+
+static int inv_mpu_suspend(struct device *dev)
+{
+	return inv_mpu6050_set_power_itg(iio_priv(dev_get_drvdata(dev)), false);
+}
+#endif /* CONFIG_PM_SLEEP */
+
+SIMPLE_DEV_PM_OPS(inv_mpu_pmops, inv_mpu_suspend, inv_mpu_resume);
+EXPORT_SYMBOL_GPL(inv_mpu_pmops);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device MPU6050 driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu9250/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu9250/inv_mpu_i2c.c
new file mode 100644
index 0000000..6b44d29
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu9250/inv_mpu_i2c.c
@@ -0,0 +1,201 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/iio/iio.h>
+#include <linux/module.h>
+#include "inv_mpu_iio.h"
+
+static const struct regmap_config inv_mpu_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)
+{
+	struct iio_dev *indio_dev = i2c_mux_priv(muxc);
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+	int ret = 0;
+
+	/* Use the same mutex which was used everywhere to protect power-op */
+	mutex_lock(&indio_dev->mlock);
+	if (!st->powerup_count) {
+		ret = regmap_write(st->map, st->reg->pwr_mgmt_1, 0);
+		if (ret)
+			goto write_error;
+
+		usleep_range(INV_MPU6050_REG_UP_TIME_MIN,
+			     INV_MPU6050_REG_UP_TIME_MAX);
+	}
+	if (!ret) {
+		st->powerup_count++;
+		ret = regmap_write(st->map, st->reg->int_pin_cfg,
+				   INV_MPU6050_INT_PIN_CFG |
+				   INV_MPU6050_BIT_BYPASS_EN);
+	}
+write_error:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+static int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)
+{
+	struct iio_dev *indio_dev = i2c_mux_priv(muxc);
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	/* It doesn't really mattter, if any of the calls fails */
+	regmap_write(st->map, st->reg->int_pin_cfg, INV_MPU6050_INT_PIN_CFG);
+	st->powerup_count--;
+	if (!st->powerup_count)
+		regmap_write(st->map, st->reg->pwr_mgmt_1,
+			     INV_MPU6050_BIT_SLEEP);
+	mutex_unlock(&indio_dev->mlock);
+
+	return 0;
+}
+
+static const char *inv_mpu_match_acpi_device(struct device *dev, int *chip_id)
+{
+	const struct acpi_device_id *id;
+
+	id = acpi_match_device(dev->driver->acpi_match_table, dev);
+	if (!id)
+		return NULL;
+
+	*chip_id = (int)id->driver_data;
+
+	return dev_name(dev);
+}
+
+/**
+ *  inv_mpu_probe() - probe function.
+ *  @client:          i2c client.
+ *  @id:              i2c device id.
+ *
+ *  Returns 0 on success, a negative error code otherwise.
+ */
+static int inv_mpu_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct inv_mpu6050_state *st;
+	int result, chip_type;
+	struct regmap *regmap;
+	const char *name;
+
+	if (!i2c_check_functionality(client->adapter,
+				     I2C_FUNC_SMBUS_I2C_BLOCK))
+		return -EOPNOTSUPP;
+
+	if (id) {
+		chip_type = (int)id->driver_data;
+		name = id->name;
+	} else if (ACPI_HANDLE(&client->dev)) {
+		name = inv_mpu_match_acpi_device(&client->dev, &chip_type);
+		if (!name)
+			return -ENODEV;
+	} else {
+		return -ENOSYS;
+	}
+
+	regmap = devm_regmap_init_i2c(client, &inv_mpu_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(&client->dev, "Failed to register i2c regmap %d\n",
+			(int)PTR_ERR(regmap));
+		return PTR_ERR(regmap);
+	}
+
+	result = inv_mpu_core_probe(&client->dev, regmap, client->irq, name,
+				    NULL, chip_type);
+	if (result < 0)
+		return result;
+
+	st = iio_priv(dev_get_drvdata(&client->dev));
+	st->muxc = i2c_mux_alloc(client->adapter, &client->dev,
+				 1, 0, I2C_MUX_LOCKED,
+				 inv_mpu6050_select_bypass,
+				 inv_mpu6050_deselect_bypass);
+	if (!st->muxc) {
+		result = -ENOMEM;
+		goto out_unreg_device;
+	}
+	st->muxc->priv = dev_get_drvdata(&client->dev);
+	result = i2c_mux_add_adapter(st->muxc, 0, 0, 0);
+	if (result)
+		goto out_unreg_device;
+
+	result = inv_mpu_acpi_create_mux_client(client);
+	if (result)
+		goto out_del_mux;
+
+	return 0;
+
+out_del_mux:
+	i2c_mux_del_adapters(st->muxc);
+out_unreg_device:
+	inv_mpu_core_remove(&client->dev);
+	return result;
+}
+
+static int inv_mpu_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+
+	inv_mpu_acpi_delete_mux_client(client);
+	i2c_mux_del_adapters(st->muxc);
+
+	return inv_mpu_core_remove(&client->dev);
+}
+
+/*
+ * device id table is used to identify what device can be
+ * supported by this driver
+ */
+static const struct i2c_device_id inv_mpu_id[] = {
+	{"mpu6050", INV_MPU6050},
+	{"mpu6500", INV_MPU6500},
+	{"mpu9150", INV_MPU9150},
+	{"mpu9250", INV_MPU9250},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, inv_mpu_id);
+
+static const struct acpi_device_id inv_acpi_match[] = {
+	{"INVN6500", INV_MPU6500},
+	{ },
+};
+
+MODULE_DEVICE_TABLE(acpi, inv_acpi_match);
+
+static struct i2c_driver inv_mpu_driver = {
+	.probe		=	inv_mpu_probe,
+	.remove		=	inv_mpu_remove,
+	.id_table	=	inv_mpu_id,
+	.driver = {
+		.acpi_match_table = ACPI_PTR(inv_acpi_match),
+		.name	=	"inv-mpu6050-i2c",
+		.pm     =       &inv_mpu_pmops,
+	},
+};
+
+module_i2c_driver(inv_mpu_driver);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device MPU6050 driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu9250/inv_mpu_i2cmst.c b/drivers/iio/imu/inv_mpu9250/inv_mpu_i2cmst.c
new file mode 100644
index 0000000..1fa4530
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu9250/inv_mpu_i2cmst.c
@@ -0,0 +1,182 @@
+/*
+* Copyright (C) 2016 Ambarella, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of_i2c.h>
+#include <linux/iio/iio.h>
+#include "inv_mpu_iio.h"
+
+int inv_mpu_i2cmst_read_data(struct inv_mpu6050_state *st,
+		u16 addr, u8 command, int size, union i2c_smbus_data *data)
+{
+	unsigned int d, num;
+	void *buf;
+	int result;
+
+	result = inv_mpu6050_set_power_itg(st, true);
+	if (result)
+		return result;
+
+	switch (size) {
+	case I2C_SMBUS_BYTE_DATA:
+		num = 1;
+		buf = &data->byte;
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		num = 2;
+		buf = &data->word;
+		break;
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		num = data->block[0];
+		buf = &data->block[1];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	d = INV_MPU6050_BIT_I2C_SLV0_EN | num;
+	result = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV0_CTRL, d);
+	if (result)
+		return result;
+
+	result = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV0_REG, command);
+	if (result)
+		return result;
+
+	d = INV_MPU6050_BIT_I2C_SLV0_RNW | addr;
+	result = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV0_ADDR, d);
+	if (result)
+		return result;
+
+	d = 1000 / st->chip_config.fifo_rate;
+	msleep(d + d / 2);
+
+	result = regmap_bulk_read(st->map, INV_MPU6050_REG_EXT_SENS_DATA, buf, num);
+	if (result)
+		return result;
+
+	result = inv_mpu6050_set_power_itg(st, false);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+int inv_mpu_i2cmst_write_data(struct inv_mpu6050_state *st,
+		u16 addr, u8 command, int size, union i2c_smbus_data *data)
+{
+	unsigned int d;
+	int result;
+
+	if (size != I2C_SMBUS_BYTE_DATA) {
+		dev_err(&st->adap->dev, "funky write size %d\n", size);
+		return -EINVAL;
+	}
+
+	result = inv_mpu6050_set_power_itg(st, true);
+	if (result)
+		return result;
+
+	d = INV_MPU6050_BIT_I2C_SLV0_EN | 1; /* only one byte allowed to write */
+	result = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV0_CTRL, d);
+	if (result)
+		return result;
+
+	result = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV0_REG, command);
+	if (result)
+		return result;
+
+	result = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV0_DO, data->byte);
+	if (result)
+		return result;
+
+	result = regmap_write(st->map, INV_MPU6050_REG_I2C_SLV0_ADDR, addr);
+	if (result)
+		return result;
+
+	d = 1000 / st->chip_config.fifo_rate;
+	msleep(d + d / 2);
+
+	result = inv_mpu6050_set_power_itg(st, false);
+	if (result)
+		return result;
+
+	return 0;
+}
+
+static int inv_mpu_i2cmst_xfer(struct i2c_adapter *adap, u16 addr,
+		unsigned short flags, char rw, u8 command,
+		int size, union i2c_smbus_data *data)
+{
+	struct inv_mpu6050_state *st = i2c_get_adapdata(adap);
+	int ret = -EINVAL;
+
+	if (rw == I2C_SMBUS_WRITE)
+		ret = inv_mpu_i2cmst_write_data(st, addr, command, size, data);
+	else if (rw == I2C_SMBUS_READ)
+		ret = inv_mpu_i2cmst_read_data(st, addr, command, size, data);
+
+	return ret;
+}
+
+static u32 inv_mpu_i2cmst_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_READ_I2C_BLOCK;
+}
+
+static const struct i2c_algorithm inv_mpu_i2cmst_algo = {
+	.smbus_xfer	= inv_mpu_i2cmst_xfer,
+	.functionality	= inv_mpu_i2cmst_func,
+};
+
+int inv_mpu_i2cmst_probe(struct iio_dev *indio_dev)
+{
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+	struct i2c_adapter *adap;
+	int ret;
+
+	adap = devm_kzalloc(&indio_dev->dev, sizeof(*adap), GFP_KERNEL);
+	if (!adap)
+		return -ENOMEM;
+
+	adap->owner = THIS_MODULE;
+	adap->class = I2C_CLASS_HWMON;
+	strlcpy(adap->name, "INV MPU I2CMST adapter", sizeof(adap->name));
+	adap->algo = &inv_mpu_i2cmst_algo;
+	adap->dev.parent = &indio_dev->dev;
+	adap->dev.of_node = indio_dev->dev.of_node;
+
+	i2c_set_adapdata(adap, st);
+	st->adap = adap;
+
+	ret = i2c_add_adapter(adap);
+	if (ret < 0) {
+		dev_err(&indio_dev->dev, "failed to add I2C master: %d\n", ret);
+		return ret;
+	}
+
+	of_i2c_register_devices(adap);
+
+	return 0;
+}
+
+void inv_mpu_i2cmst_remove(struct iio_dev *indio_dev)
+{
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+	i2c_del_adapter(st->adap);
+}
+
+MODULE_AUTHOR("Cao Rongrong <rrcao@ambarella.com>");
+MODULE_DESCRIPTION("Invensense MPU9250 I2C Master driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu9250/inv_mpu_iio.h b/drivers/iio/imu/inv_mpu9250/inv_mpu_iio.h
new file mode 100644
index 0000000..4a6b360
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu9250/inv_mpu_iio.h
@@ -0,0 +1,315 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/kfifo.h>
+#include <linux/spinlock.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/regmap.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/kfifo_buf.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/platform_data/invensense_mpu6050.h>
+
+/**
+ *  struct inv_mpu6050_reg_map - Notable registers.
+ *  @sample_rate_div:	Divider applied to gyro output rate.
+ *  @lpf:		Configures internal low pass filter.
+ *  @user_ctrl:		Enables/resets the FIFO.
+ *  @fifo_en:		Determines which data will appear in FIFO.
+ *  @gyro_config:	gyro config register.
+ *  @accl_config:	accel config register
+ *  @fifo_count_h:	Upper byte of FIFO count.
+ *  @fifo_r_w:		FIFO register.
+ *  @raw_gyro:		Address of first gyro register.
+ *  @raw_accl:		Address of first accel register.
+ *  @temperature:	temperature register
+ *  @int_enable:	Interrupt enable register.
+ *  @pwr_mgmt_1:	Controls chip's power state and clock source.
+ *  @pwr_mgmt_2:	Controls power state of individual sensors.
+ *  @int_pin_cfg;	Controls interrupt pin configuration.
+ *  @accl_offset:	Controls the accelerometer calibration offset.
+ *  @gyro_offset:	Controls the gyroscope calibration offset.
+ */
+struct inv_mpu6050_reg_map {
+	u8 sample_rate_div;
+	u8 lpf;
+	u8 user_ctrl;
+	u8 fifo_en;
+	u8 gyro_config;
+	u8 accl_config;
+	u8 fifo_count_h;
+	u8 fifo_r_w;
+	u8 raw_gyro;
+	u8 raw_accl;
+	u8 temperature;
+	u8 int_enable;
+	u8 pwr_mgmt_1;
+	u8 pwr_mgmt_2;
+	u8 int_pin_cfg;
+	u8 accl_offset;
+	u8 gyro_offset;
+};
+
+/*device enum */
+enum inv_devices {
+	INV_MPU6050,
+	INV_MPU6500,
+	INV_MPU6000,
+	INV_MPU9150,
+	INV_MPU9250,
+	INV_NUM_PARTS
+};
+
+/**
+ *  struct inv_mpu6050_chip_config - Cached chip configuration data.
+ *  @fsr:		Full scale range.
+ *  @lpf:		Digital low pass filter frequency.
+ *  @accl_fs:		accel full scale range.
+ *  @enable:		master enable state.
+ *  @accl_fifo_enable:	enable accel data output
+ *  @gyro_fifo_enable:	enable gyro data output
+ *  @fifo_rate:		FIFO update rate.
+ */
+struct inv_mpu6050_chip_config {
+	unsigned int fsr:2;
+	unsigned int lpf:3;
+	unsigned int accl_fs:2;
+	unsigned int enable:1;
+	unsigned int accl_fifo_enable:1;
+	unsigned int gyro_fifo_enable:1;
+	u16 fifo_rate;
+};
+
+/**
+ *  struct inv_mpu6050_hw - Other important hardware information.
+ *  @whoami:	Self identification byte from WHO_AM_I register
+ *  @name:      name of the chip.
+ *  @reg:   register map of the chip.
+ *  @config:    configuration of the chip.
+ */
+struct inv_mpu6050_hw {
+	u8 whoami;
+	u8 *name;
+	const struct inv_mpu6050_reg_map *reg;
+	const struct inv_mpu6050_chip_config *config;
+};
+
+/*
+ *  struct inv_mpu6050_state - Driver state variables.
+ *  @TIMESTAMP_FIFO_SIZE: fifo size for timestamp.
+ *  @trig:              IIO trigger.
+ *  @chip_config:	Cached attribute information.
+ *  @reg:		Map of important registers.
+ *  @hw:		Other hardware-specific information.
+ *  @chip_type:		chip type.
+ *  @time_stamp_lock:	spin lock to time stamp.
+ *  @orientation:	sensor chip orientation relative to main hardware.
+ *  @timestamps:        kfifo queue to store time stamp.
+ *  @map		regmap pointer.
+ *  @irq		interrupt number.
+ */
+struct inv_mpu6050_state {
+#define TIMESTAMP_FIFO_SIZE 16
+	struct iio_trigger  *trig;
+	struct inv_mpu6050_chip_config chip_config;
+	const struct inv_mpu6050_reg_map *reg;
+	const struct inv_mpu6050_hw *hw;
+	struct i2c_adapter *adap;
+	enum   inv_devices chip_type;
+	spinlock_t time_stamp_lock;
+	struct i2c_mux_core *muxc;
+	struct i2c_client *mux_client;
+	unsigned int powerup_count;
+	struct iio_mount_matrix orientation;
+	DECLARE_KFIFO(timestamps, long long, TIMESTAMP_FIFO_SIZE);
+	struct regmap *map;
+	struct device *dev;
+	int irq;
+};
+
+/*register and associated bit definition*/
+#define INV_MPU6050_REG_ACCEL_OFFSET        0x06
+#define INV_MPU6050_REG_GYRO_OFFSET         0x13
+
+#define INV_MPU6050_REG_SAMPLE_RATE_DIV     0x19
+#define INV_MPU6050_REG_CONFIG              0x1A
+#define INV_MPU6050_REG_GYRO_CONFIG         0x1B
+#define INV_MPU6050_REG_ACCEL_CONFIG        0x1C
+
+#define INV_MPU6050_REG_FIFO_EN             0x23
+#define INV_MPU6050_BIT_ACCEL_OUT           0x08
+#define INV_MPU6050_BITS_GYRO_OUT           0x70
+
+#define INV_MPU6050_REG_I2C_MST_CTRL        0x24
+#define INV_MPU6050_BIT_WAIT_FOR_ES         0x40
+#define INV_MPU6050_BIT_I2C_MST_CLK         0x0d
+
+#define INV_MPU6050_REG_I2C_SLV0_ADDR       0x25
+#define INV_MPU6050_BIT_I2C_SLV0_RNW        0x80
+
+#define INV_MPU6050_REG_I2C_SLV0_REG        0x26
+
+#define INV_MPU6050_REG_I2C_SLV0_CTRL       0x27
+#define INV_MPU6050_BIT_I2C_SLV0_EN         0x80
+
+#define INV_MPU6050_REG_INT_ENABLE          0x38
+#define INV_MPU6050_BIT_DATA_RDY_EN         0x01
+#define INV_MPU6050_BIT_DMP_INT_EN          0x02
+
+#define INV_MPU6050_REG_RAW_ACCEL           0x3B
+#define INV_MPU6050_REG_TEMPERATURE         0x41
+#define INV_MPU6050_REG_RAW_GYRO            0x43
+
+#define INV_MPU6050_REG_EXT_SENS_DATA       0x49
+
+#define INV_MPU6050_REG_I2C_SLV0_DO         0x63
+
+#define INV_MPU6050_REG_USER_CTRL           0x6A
+#define INV_MPU6050_BIT_FIFO_RST            0x04
+#define INV_MPU6050_BIT_DMP_RST             0x08
+#define INV_MPU6050_BIT_I2C_MST_EN          0x20
+#define INV_MPU6050_BIT_FIFO_EN             0x40
+#define INV_MPU6050_BIT_DMP_EN              0x80
+#define INV_MPU6050_BIT_I2C_IF_DIS          0x10
+
+#define INV_MPU6050_REG_PWR_MGMT_1          0x6B
+#define INV_MPU6050_BIT_H_RESET             0x80
+#define INV_MPU6050_BIT_SLEEP               0x40
+#define INV_MPU6050_BIT_CLK_MASK            0x7
+
+#define INV_MPU6050_REG_PWR_MGMT_2          0x6C
+#define INV_MPU6050_BIT_PWR_ACCL_STBY       0x38
+#define INV_MPU6050_BIT_PWR_GYRO_STBY       0x07
+#define INV_MPU6050_BIT_PWR_TEMP_STBY       0x01
+
+#define INV_MPU6050_REG_FIFO_COUNT_H        0x72
+#define INV_MPU6050_REG_FIFO_R_W            0x74
+
+#define INV_MPU6050_BYTES_PER_3AXIS_SENSOR   6
+#define INV_MPU6050_FIFO_COUNT_BYTE          2
+#define INV_MPU6050_FIFO_THRESHOLD           500
+
+/* mpu6500 registers */
+#define INV_MPU6500_REG_ACCEL_OFFSET        0x77
+
+/* delay time in milliseconds */
+#define INV_MPU6050_POWER_UP_TIME            100
+#define INV_MPU6050_TEMP_UP_TIME             100
+#define INV_MPU6050_SENSOR_UP_TIME           30
+
+/* delay time in microseconds */
+#define INV_MPU6050_REG_UP_TIME_MIN          5000
+#define INV_MPU6050_REG_UP_TIME_MAX          10000
+
+#define INV_MPU6050_TEMP_OFFSET	             12421
+#define INV_MPU6050_TEMP_SCALE               2941
+#define INV_MPU6050_MAX_GYRO_FS_PARAM        3
+#define INV_MPU6050_MAX_ACCL_FS_PARAM        3
+#define INV_MPU6050_THREE_AXIS               3
+#define INV_MPU6050_GYRO_CONFIG_FSR_SHIFT    3
+#define INV_MPU6050_ACCL_CONFIG_FSR_SHIFT    3
+
+/* 6 + 6 round up and plus 8 */
+#define INV_MPU6050_OUTPUT_DATA_SIZE         24
+
+#define INV_MPU6050_REG_INT_PIN_CFG	0x37
+#define INV_MPU6050_BIT_BYPASS_EN	0x2
+#define INV_MPU6050_INT_PIN_CFG		0
+
+/* init parameters */
+#define INV_MPU6050_INIT_FIFO_RATE           50
+#define INV_MPU6050_TIME_STAMP_TOR           5
+#define INV_MPU6050_MAX_FIFO_RATE            1000
+#define INV_MPU6050_MIN_FIFO_RATE            4
+#define INV_MPU6050_ONE_K_HZ                 1000
+
+#define INV_MPU6050_REG_WHOAMI			117
+
+#define INV_MPU6000_WHOAMI_VALUE		0x68
+#define INV_MPU6050_WHOAMI_VALUE		0x68
+#define INV_MPU6500_WHOAMI_VALUE		0x70
+#define INV_MPU9150_WHOAMI_VALUE		0x68
+#define INV_MPU9250_WHOAMI_VALUE		0x71
+
+/* scan element definition */
+enum inv_mpu6050_scan {
+	INV_MPU6050_SCAN_ACCL_X,
+	INV_MPU6050_SCAN_ACCL_Y,
+	INV_MPU6050_SCAN_ACCL_Z,
+	INV_MPU6050_SCAN_GYRO_X,
+	INV_MPU6050_SCAN_GYRO_Y,
+	INV_MPU6050_SCAN_GYRO_Z,
+	INV_MPU6050_SCAN_TIMESTAMP,
+};
+
+enum inv_mpu6050_filter_e {
+	INV_MPU6050_FILTER_256HZ_NOLPF2 = 0,
+	INV_MPU6050_FILTER_188HZ,
+	INV_MPU6050_FILTER_98HZ,
+	INV_MPU6050_FILTER_42HZ,
+	INV_MPU6050_FILTER_20HZ,
+	INV_MPU6050_FILTER_10HZ,
+	INV_MPU6050_FILTER_5HZ,
+	INV_MPU6050_FILTER_2100HZ_NOLPF,
+	NUM_MPU6050_FILTER
+};
+
+/* IIO attribute address */
+enum INV_MPU6050_IIO_ATTR_ADDR {
+	ATTR_GYRO_MATRIX,
+	ATTR_ACCL_MATRIX,
+};
+
+enum inv_mpu6050_accl_fs_e {
+	INV_MPU6050_FS_02G = 0,
+	INV_MPU6050_FS_04G,
+	INV_MPU6050_FS_08G,
+	INV_MPU6050_FS_16G,
+	NUM_ACCL_FSR
+};
+
+enum inv_mpu6050_fsr_e {
+	INV_MPU6050_FSR_250DPS = 0,
+	INV_MPU6050_FSR_500DPS,
+	INV_MPU6050_FSR_1000DPS,
+	INV_MPU6050_FSR_2000DPS,
+	NUM_MPU6050_FSR
+};
+
+enum inv_mpu6050_clock_sel_e {
+	INV_CLK_INTERNAL = 0,
+	INV_CLK_PLL,
+	NUM_CLK
+};
+
+irqreturn_t inv_mpu6050_irq_handler(int irq, void *p);
+irqreturn_t inv_mpu6050_read_fifo(int irq, void *p);
+int inv_mpu6050_probe_trigger(struct iio_dev *indio_dev);
+void inv_mpu6050_remove_trigger(struct inv_mpu6050_state *st);
+int inv_reset_fifo(struct iio_dev *indio_dev);
+int inv_mpu6050_switch_engine(struct inv_mpu6050_state *st, bool en, u32 mask);
+int inv_mpu6050_write_reg(struct inv_mpu6050_state *st, int reg, u8 val);
+int inv_mpu6050_set_power_itg(struct inv_mpu6050_state *st, bool power_on);
+int inv_mpu_acpi_create_mux_client(struct i2c_client *client);
+void inv_mpu_acpi_delete_mux_client(struct i2c_client *client);
+int inv_mpu_core_probe(struct device *dev, struct regmap *regmap,
+		int irq, const char *name,
+		int (*inv_mpu_bus_setup)(struct iio_dev *), int chip_type);
+int inv_mpu_core_remove(struct device *dev);
+int inv_mpu_i2cmst_probe(struct iio_dev *indio_dev);
+void inv_mpu_i2cmst_remove(struct iio_dev *indio_dev);
+extern const struct dev_pm_ops inv_mpu_pmops;
diff --git a/drivers/iio/imu/inv_mpu9250/inv_mpu_ring.c b/drivers/iio/imu/inv_mpu9250/inv_mpu_ring.c
new file mode 100644
index 0000000..919662d
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu9250/inv_mpu_ring.c
@@ -0,0 +1,196 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include "inv_mpu_iio.h"
+
+static void inv_clear_kfifo(struct inv_mpu6050_state *st)
+{
+	unsigned long flags;
+
+	/* take the spin lock sem to avoid interrupt kick in */
+	spin_lock_irqsave(&st->time_stamp_lock, flags);
+	kfifo_reset(&st->timestamps);
+	spin_unlock_irqrestore(&st->time_stamp_lock, flags);
+}
+
+int inv_reset_fifo(struct iio_dev *indio_dev)
+{
+	int result;
+	u8 d;
+	struct inv_mpu6050_state  *st = iio_priv(indio_dev);
+
+	/* disable interrupt */
+	result = regmap_write(st->map, st->reg->int_enable, 0);
+	if (result) {
+		dev_err(st->dev, "int_enable failed %d\n",
+			result);
+		return result;
+	}
+	/* disable the sensor output to FIFO */
+	result = regmap_write(st->map, st->reg->fifo_en, 0);
+	if (result)
+		goto reset_fifo_fail;
+	/* disable fifo reading */
+	result = regmap_update_bits(st->map, st->reg->user_ctrl,
+				INV_MPU6050_BIT_FIFO_EN, 0);
+	if (result)
+		goto reset_fifo_fail;
+
+	/* reset FIFO*/
+	result = regmap_update_bits(st->map, st->reg->user_ctrl,
+				INV_MPU6050_BIT_FIFO_RST, INV_MPU6050_BIT_FIFO_RST);
+	if (result)
+		goto reset_fifo_fail;
+
+	/* clear timestamps fifo */
+	inv_clear_kfifo(st);
+
+	/* enable interrupt */
+	if (st->chip_config.accl_fifo_enable ||
+	    st->chip_config.gyro_fifo_enable) {
+		result = regmap_write(st->map, st->reg->int_enable,
+				      INV_MPU6050_BIT_DATA_RDY_EN);
+		if (result)
+			return result;
+	}
+	/* enable FIFO reading and I2C master interface*/
+	result = regmap_update_bits(st->map, st->reg->user_ctrl,
+				INV_MPU6050_BIT_FIFO_EN, INV_MPU6050_BIT_FIFO_EN);
+	if (result)
+		goto reset_fifo_fail;
+	/* enable sensor output to FIFO */
+	d = 0;
+	if (st->chip_config.gyro_fifo_enable)
+		d |= INV_MPU6050_BITS_GYRO_OUT;
+	if (st->chip_config.accl_fifo_enable)
+		d |= INV_MPU6050_BIT_ACCEL_OUT;
+	result = regmap_write(st->map, st->reg->fifo_en, d);
+	if (result)
+		goto reset_fifo_fail;
+
+	return 0;
+
+reset_fifo_fail:
+	dev_err(st->dev, "reset fifo failed %d\n", result);
+	result = regmap_write(st->map, st->reg->int_enable,
+			      INV_MPU6050_BIT_DATA_RDY_EN);
+
+	return result;
+}
+
+/**
+ * inv_mpu6050_irq_handler() - Cache a timestamp at each data ready interrupt.
+ */
+irqreturn_t inv_mpu6050_irq_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+	s64 timestamp;
+
+	timestamp = iio_get_time_ns();
+	kfifo_in_spinlocked(&st->timestamps, &timestamp, 1,
+			    &st->time_stamp_lock);
+
+	return IRQ_WAKE_THREAD;
+}
+
+/**
+ * inv_mpu6050_read_fifo() - Transfer data from hardware FIFO to KFIFO.
+ */
+irqreturn_t inv_mpu6050_read_fifo(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+	size_t bytes_per_datum;
+	int result;
+	u8 data[INV_MPU6050_OUTPUT_DATA_SIZE];
+	u16 fifo_count;
+	s64 timestamp;
+	u64 *tmp;
+
+	mutex_lock(&indio_dev->mlock);
+	if (!(st->chip_config.accl_fifo_enable |
+		st->chip_config.gyro_fifo_enable))
+		goto end_session;
+	bytes_per_datum = 0;
+	if (st->chip_config.accl_fifo_enable)
+		bytes_per_datum += INV_MPU6050_BYTES_PER_3AXIS_SENSOR;
+
+	if (st->chip_config.gyro_fifo_enable)
+		bytes_per_datum += INV_MPU6050_BYTES_PER_3AXIS_SENSOR;
+
+	/*
+	 * read fifo_count register to know how many bytes inside FIFO
+	 * right now
+	 */
+	result = regmap_bulk_read(st->map, st->reg->fifo_count_h, data,
+				  INV_MPU6050_FIFO_COUNT_BYTE);
+	if (result)
+		goto end_session;
+	fifo_count = be16_to_cpup((__be16 *)(&data[0]));
+	if (fifo_count < bytes_per_datum)
+		goto end_session;
+	/* fifo count can't be odd number, if it is odd, reset fifo*/
+	if (fifo_count & 1)
+		goto flush_fifo;
+	if (fifo_count >  INV_MPU6050_FIFO_THRESHOLD)
+		goto flush_fifo;
+	/* Timestamp mismatch. */
+	if (kfifo_len(&st->timestamps) >
+	    fifo_count / bytes_per_datum + INV_MPU6050_TIME_STAMP_TOR)
+		goto flush_fifo;
+	while (fifo_count >= bytes_per_datum) {
+		result = regmap_bulk_read(st->map, st->reg->fifo_r_w,
+					  data, bytes_per_datum);
+		if (result)
+			goto flush_fifo;
+
+		result = kfifo_out(&st->timestamps, &timestamp, 1);
+		/* when there is no timestamp, put timestamp as 0 */
+		if (result == 0)
+			timestamp = 0;
+
+		tmp = (u64 *)data;
+		tmp[DIV_ROUND_UP(bytes_per_datum, 8)] = timestamp;
+		result = iio_push_to_buffers(indio_dev, data);
+		if (result)
+			goto flush_fifo;
+		fifo_count -= bytes_per_datum;
+	}
+
+end_session:
+	mutex_unlock(&indio_dev->mlock);
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+
+flush_fifo:
+	/* Flush HW and SW FIFOs. */
+	inv_reset_fifo(indio_dev);
+	mutex_unlock(&indio_dev->mlock);
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
diff --git a/drivers/iio/imu/inv_mpu9250/inv_mpu_spi.c b/drivers/iio/imu/inv_mpu9250/inv_mpu_spi.c
new file mode 100644
index 0000000..1f6b6af
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu9250/inv_mpu_spi.c
@@ -0,0 +1,132 @@
+/*
+* Copyright (C) 2015 Intel Corporation Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/spi/spi.h>
+#include <linux/regmap.h>
+#include <linux/iio/iio.h>
+#include "inv_mpu_iio.h"
+
+static const struct regmap_config inv_mpu_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static int inv_mpu_i2c_disable(struct iio_dev *indio_dev)
+{
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+	int ret = 0;
+
+	ret = inv_mpu6050_set_power_itg(st, true);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(st->map, INV_MPU6050_REG_USER_CTRL,
+			   INV_MPU6050_BIT_I2C_IF_DIS | INV_MPU6050_BIT_I2C_MST_EN);
+	if (ret) {
+		inv_mpu6050_set_power_itg(st, false);
+		return ret;
+	}
+
+	ret = regmap_write(st->map, INV_MPU6050_REG_I2C_MST_CTRL,
+			   INV_MPU6050_BIT_I2C_MST_CLK);
+	if (ret) {
+		inv_mpu6050_set_power_itg(st, false);
+		return ret;
+	}
+
+	return inv_mpu6050_set_power_itg(st, false);
+}
+
+static int inv_mpu_probe(struct spi_device *spi)
+{
+	struct regmap *regmap;
+	const struct spi_device_id *spi_id;
+	const struct acpi_device_id *acpi_id;
+	const char *name = NULL;
+	enum inv_devices chip_type;
+	int ret;
+
+	if ((spi_id = spi_get_device_id(spi))) {
+		chip_type = (enum inv_devices)spi_id->driver_data;
+		name = spi_id->name;
+	} else if ((acpi_id = acpi_match_device(spi->dev.driver->acpi_match_table, &spi->dev))) {
+		chip_type = (enum inv_devices)acpi_id->driver_data;
+	} else {
+		return -ENODEV;
+	}
+
+	regmap = devm_regmap_init_spi(spi, &inv_mpu_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(&spi->dev, "Failed to register spi regmap %d\n",
+			(int)PTR_ERR(regmap));
+		return PTR_ERR(regmap);
+	}
+
+	ret = inv_mpu_core_probe(&spi->dev, regmap, spi->irq, name,
+				  inv_mpu_i2c_disable, chip_type);
+	if (ret < 0)
+		return ret;
+
+	ret = inv_mpu_i2cmst_probe(dev_get_drvdata(&spi->dev));
+	if (ret < 0) {
+		dev_err(&spi->dev, "i2c master probe fail %d\n", ret);
+		inv_mpu_core_remove(&spi->dev);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int inv_mpu_remove(struct spi_device *spi)
+{
+	inv_mpu_i2cmst_remove(dev_get_drvdata(&spi->dev));
+	return inv_mpu_core_remove(&spi->dev);
+}
+
+/*
+ * device id table is used to identify what device can be
+ * supported by this driver
+ */
+static const struct spi_device_id inv_mpu_id[] = {
+	{"mpu6000", INV_MPU6000},
+	{"mpu6500", INV_MPU6500},
+	{"mpu9150", INV_MPU9150},
+	{"mpu9250", INV_MPU9250},
+	{}
+};
+
+MODULE_DEVICE_TABLE(spi, inv_mpu_id);
+
+static const struct acpi_device_id inv_acpi_match[] = {
+	{"INVN6000", INV_MPU6000},
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, inv_acpi_match);
+
+static struct spi_driver inv_mpu_driver = {
+	.probe		=	inv_mpu_probe,
+	.remove		=	inv_mpu_remove,
+	.id_table	=	inv_mpu_id,
+	.driver = {
+		.acpi_match_table = ACPI_PTR(inv_acpi_match),
+		.name	=	"inv-mpu6000-spi",
+		.pm     =       &inv_mpu_pmops,
+	},
+};
+
+module_spi_driver(inv_mpu_driver);
+
+MODULE_AUTHOR("Adriana Reus <adriana.reus@intel.com>");
+MODULE_DESCRIPTION("Invensense device MPU6000 driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/imu/inv_mpu9250/inv_mpu_trigger.c b/drivers/iio/imu/inv_mpu9250/inv_mpu_trigger.c
new file mode 100644
index 0000000..cca1c24
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu9250/inv_mpu_trigger.c
@@ -0,0 +1,148 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#include "inv_mpu_iio.h"
+
+static void inv_scan_query(struct iio_dev *indio_dev)
+{
+	struct inv_mpu6050_state  *st = iio_priv(indio_dev);
+
+	st->chip_config.gyro_fifo_enable =
+		test_bit(INV_MPU6050_SCAN_GYRO_X,
+			 indio_dev->active_scan_mask) ||
+		test_bit(INV_MPU6050_SCAN_GYRO_Y,
+			 indio_dev->active_scan_mask) ||
+		test_bit(INV_MPU6050_SCAN_GYRO_Z,
+			 indio_dev->active_scan_mask);
+
+	st->chip_config.accl_fifo_enable =
+		test_bit(INV_MPU6050_SCAN_ACCL_X,
+			 indio_dev->active_scan_mask) ||
+		test_bit(INV_MPU6050_SCAN_ACCL_Y,
+			 indio_dev->active_scan_mask) ||
+		test_bit(INV_MPU6050_SCAN_ACCL_Z,
+			 indio_dev->active_scan_mask);
+}
+
+/**
+ *  inv_mpu6050_set_enable() - enable chip functions.
+ *  @indio_dev:	Device driver instance.
+ *  @enable: enable/disable
+ */
+static int inv_mpu6050_set_enable(struct iio_dev *indio_dev, bool enable)
+{
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+	int result;
+
+	if (enable) {
+		result = inv_mpu6050_set_power_itg(st, true);
+		if (result)
+			return result;
+		inv_scan_query(indio_dev);
+		if (st->chip_config.gyro_fifo_enable) {
+			result = inv_mpu6050_switch_engine(st, true,
+					INV_MPU6050_BIT_PWR_GYRO_STBY);
+			if (result)
+				return result;
+		}
+		if (st->chip_config.accl_fifo_enable) {
+			result = inv_mpu6050_switch_engine(st, true,
+					INV_MPU6050_BIT_PWR_ACCL_STBY);
+			if (result)
+				return result;
+		}
+		result = inv_reset_fifo(indio_dev);
+		if (result)
+			return result;
+	} else {
+		result = regmap_write(st->map, st->reg->fifo_en, 0);
+		if (result)
+			return result;
+
+		result = regmap_write(st->map, st->reg->int_enable, 0);
+		if (result)
+			return result;
+
+		result = regmap_update_bits(st->map, st->reg->user_ctrl,
+					INV_MPU6050_BIT_FIFO_EN, 0);
+		if (result)
+			return result;
+
+		result = inv_mpu6050_switch_engine(st, false,
+					INV_MPU6050_BIT_PWR_GYRO_STBY);
+		if (result)
+			return result;
+
+		result = inv_mpu6050_switch_engine(st, false,
+					INV_MPU6050_BIT_PWR_ACCL_STBY);
+		if (result)
+			return result;
+		result = inv_mpu6050_set_power_itg(st, false);
+		if (result)
+			return result;
+	}
+	st->chip_config.enable = enable;
+
+	return 0;
+}
+
+/**
+ * inv_mpu_data_rdy_trigger_set_state() - set data ready interrupt state
+ * @trig: Trigger instance
+ * @state: Desired trigger state
+ */
+static int inv_mpu_data_rdy_trigger_set_state(struct iio_trigger *trig,
+					      bool state)
+{
+	return inv_mpu6050_set_enable(iio_trigger_get_drvdata(trig), state);
+}
+
+static const struct iio_trigger_ops inv_mpu_trigger_ops = {
+	.owner = THIS_MODULE,
+	.set_trigger_state = &inv_mpu_data_rdy_trigger_set_state,
+};
+
+int inv_mpu6050_probe_trigger(struct iio_dev *indio_dev)
+{
+	int ret;
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+
+	st->trig = iio_trigger_alloc("%s-dev%d", indio_dev->name, indio_dev->id);
+	if (!st->trig)
+		return -ENOMEM;
+
+	ret = devm_request_irq(&indio_dev->dev, st->irq,
+			       &iio_trigger_generic_data_rdy_poll,
+			       IRQF_TRIGGER_RISING,
+			       "inv_mpu",
+			       st->trig);
+	if (ret)
+		return ret;
+
+	st->trig->dev.parent = st->dev;
+	st->trig->ops = &inv_mpu_trigger_ops;
+	iio_trigger_set_drvdata(st->trig, indio_dev);
+
+	ret = iio_trigger_register(st->trig);
+	if (ret)
+		return ret;
+
+	indio_dev->trig = iio_trigger_get(st->trig);
+
+	return 0;
+}
+
+void inv_mpu6050_remove_trigger(struct inv_mpu6050_state *st)
+{
+	iio_trigger_unregister(st->trig);
+}
diff --git a/drivers/iio/industrialio-trigger.c b/drivers/iio/industrialio-trigger.c
index 4d6c7d8..301becc 100644
--- a/drivers/iio/industrialio-trigger.c
+++ b/drivers/iio/industrialio-trigger.c
@@ -203,22 +203,35 @@ static int iio_trigger_attach_poll_func(struct iio_trigger *trig,
 
 	/* Prevent the module from being removed whilst attached to a trigger */
 	__module_get(pf->indio_dev->info->driver_module);
+
+	/* Get irq number */
 	pf->irq = iio_trigger_get_irq(trig);
+	if (pf->irq < 0)
+		goto out_put_module;
+
+	/* Request irq */
 	ret = request_threaded_irq(pf->irq, pf->h, pf->thread,
 				   pf->type, pf->name,
 				   pf);
-	if (ret < 0) {
-		module_put(pf->indio_dev->info->driver_module);
-		return ret;
-	}
+	if (ret < 0)
+		goto out_put_irq;
 
+	/* Enable trigger in driver */
 	if (trig->ops && trig->ops->set_trigger_state && notinuse) {
 		ret = trig->ops->set_trigger_state(trig, true);
 		if (ret < 0)
-			module_put(pf->indio_dev->info->driver_module);
+			goto out_free_irq;
 	}
 
 	return ret;
+
+out_free_irq:
+	free_irq(pf->irq, pf);
+out_put_irq:
+	iio_trigger_put_irq(trig, pf->irq);
+out_put_module:
+	module_put(pf->indio_dev->info->driver_module);
+	return ret;
 }
 
 static int iio_trigger_detach_poll_func(struct iio_trigger *trig,
diff --git a/drivers/iio/magnetometer/Kconfig b/drivers/iio/magnetometer/Kconfig
index bd1cfb6..6cd03f3 100644
--- a/drivers/iio/magnetometer/Kconfig
+++ b/drivers/iio/magnetometer/Kconfig
@@ -7,9 +7,11 @@ config AK8975
 	tristate "Asahi Kasei AK8975 3-Axis Magnetometer"
 	depends on I2C
 	depends on GPIOLIB
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
 	help
-	  Say yes here to build support for Asahi Kasei AK8975 3-Axis
-	  Magnetometer.
+	  Say yes here to build support for Asahi Kasei AK8975, AK8963,
+	  AK09911 or AK09912 3-Axis Magnetometer.
 
 	  To compile this driver as a module, choose M here: the module
 	  will be called ak8975.
diff --git a/drivers/iio/magnetometer/ak8975.c b/drivers/iio/magnetometer/ak8975.c
index 53f8290..1cf7c6e 100644
--- a/drivers/iio/magnetometer/ak8975.c
+++ b/drivers/iio/magnetometer/ak8975.c
@@ -24,14 +24,23 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
+#include <linux/interrupt.h>
 #include <linux/err.h>
 #include <linux/mutex.h>
 #include <linux/delay.h>
-
+#include <linux/bitops.h>
 #include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/acpi.h>
+#include <linux/regulator/consumer.h>
 
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+
 /*
  * Register definitions, as well as various shifts and masks to get at the
  * individual fields of the registers.
@@ -61,10 +70,10 @@
 #define AK8975_REG_CNTL			0x0A
 #define AK8975_REG_CNTL_MODE_SHIFT	0
 #define AK8975_REG_CNTL_MODE_MASK	(0xF << AK8975_REG_CNTL_MODE_SHIFT)
-#define AK8975_REG_CNTL_MODE_POWER_DOWN	0
-#define AK8975_REG_CNTL_MODE_ONCE	1
-#define AK8975_REG_CNTL_MODE_SELF_TEST	8
-#define AK8975_REG_CNTL_MODE_FUSE_ROM	0xF
+#define AK8975_REG_CNTL_MODE_POWER_DOWN	0x00
+#define AK8975_REG_CNTL_MODE_ONCE	0x01
+#define AK8975_REG_CNTL_MODE_SELF_TEST	0x08
+#define AK8975_REG_CNTL_MODE_FUSE_ROM	0x0F
 
 #define AK8975_REG_RSVC			0x0B
 #define AK8975_REG_ASTC			0x0C
@@ -78,51 +87,443 @@
 #define AK8975_MAX_REGS			AK8975_REG_ASAZ
 
 /*
+ * AK09912 Register definitions
+ */
+#define AK09912_REG_WIA1		0x00
+#define AK09912_REG_WIA2		0x01
+#define AK09912_DEVICE_ID		0x04
+#define AK09911_DEVICE_ID		0x05
+
+#define AK09911_REG_INFO1		0x02
+#define AK09911_REG_INFO2		0x03
+
+#define AK09912_REG_ST1			0x10
+
+#define AK09912_REG_ST1_DRDY_SHIFT	0
+#define AK09912_REG_ST1_DRDY_MASK	(1 << AK09912_REG_ST1_DRDY_SHIFT)
+
+#define AK09912_REG_HXL			0x11
+#define AK09912_REG_HXH			0x12
+#define AK09912_REG_HYL			0x13
+#define AK09912_REG_HYH			0x14
+#define AK09912_REG_HZL			0x15
+#define AK09912_REG_HZH			0x16
+#define AK09912_REG_TMPS		0x17
+
+#define AK09912_REG_ST2			0x18
+#define AK09912_REG_ST2_HOFL_SHIFT	3
+#define AK09912_REG_ST2_HOFL_MASK	(1 << AK09912_REG_ST2_HOFL_SHIFT)
+
+#define AK09912_REG_CNTL1		0x30
+
+#define AK09912_REG_CNTL2		0x31
+#define AK09912_REG_CNTL_MODE_POWER_DOWN	0x00
+#define AK09912_REG_CNTL_MODE_ONCE	0x01
+#define AK09912_REG_CNTL_MODE_SELF_TEST	0x10
+#define AK09912_REG_CNTL_MODE_FUSE_ROM	0x1F
+#define AK09912_REG_CNTL2_MODE_SHIFT	0
+#define AK09912_REG_CNTL2_MODE_MASK	(0x1F << AK09912_REG_CNTL2_MODE_SHIFT)
+
+#define AK09912_REG_CNTL3		0x32
+
+#define AK09912_REG_TS1			0x33
+#define AK09912_REG_TS2			0x34
+#define AK09912_REG_TS3			0x35
+#define AK09912_REG_I2CDIS		0x36
+#define AK09912_REG_TS4			0x37
+
+#define AK09912_REG_ASAX		0x60
+#define AK09912_REG_ASAY		0x61
+#define AK09912_REG_ASAZ		0x62
+
+#define AK09912_MAX_REGS		AK09912_REG_ASAZ
+
+/*
  * Miscellaneous values.
  */
 #define AK8975_MAX_CONVERSION_TIMEOUT	500
 #define AK8975_CONVERSION_DONE_POLL_TIME 10
+#define AK8975_DATA_READY_TIMEOUT	((100*HZ)/1000)
+
+/*
+ * Precalculate scale factor (in Gauss units) for each axis and
+ * store in the device data.
+ *
+ * This scale factor is axis-dependent, and is derived from 3 calibration
+ * factors ASA(x), ASA(y), and ASA(z).
+ *
+ * These ASA values are read from the sensor device at start of day, and
+ * cached in the device context struct.
+ *
+ * Adjusting the flux value with the sensitivity adjustment value should be
+ * done via the following formula:
+ *
+ * Hadj = H * ( ( ( (ASA-128)*0.5 ) / 128 ) + 1 )
+ * where H is the raw value, ASA is the sensitivity adjustment, and Hadj
+ * is the resultant adjusted value.
+ *
+ * We reduce the formula to:
+ *
+ * Hadj = H * (ASA + 128) / 256
+ *
+ * H is in the range of -4096 to 4095.  The magnetometer has a range of
+ * +-1229uT.  To go from the raw value to uT is:
+ *
+ * HuT = H * 1229/4096, or roughly, 3/10.
+ *
+ * Since 1uT = 0.01 gauss, our final scale factor becomes:
+ *
+ * Hadj = H * ((ASA + 128) / 256) * 3/10 * 1/100
+ * Hadj = H * ((ASA + 128) * 0.003) / 256
+ *
+ * Since ASA doesn't change, we cache the resultant scale factor into the
+ * device context in ak8975_setup().
+ *
+ * Given we use IIO_VAL_INT_PLUS_MICRO bit when displaying the scale, we
+ * multiply the stored scale value by 1e6.
+ */
+static long ak8975_raw_to_gauss(u16 data)
+{
+	return (((long)data + 128) * 3000) / 256;
+}
+
+/*
+ * For AK8963 and AK09911, same calculation, but the device is less sensitive:
+ *
+ * H is in the range of +-8190.  The magnetometer has a range of
+ * +-4912uT.  To go from the raw value to uT is:
+ *
+ * HuT = H * 4912/8190, or roughly, 6/10, instead of 3/10.
+ */
+
+static long ak8963_09911_raw_to_gauss(u16 data)
+{
+	return (((long)data + 128) * 6000) / 256;
+}
+
+/*
+ * For AK09912, same calculation, except the device is more sensitive:
+ *
+ * H is in the range of -32752 to 32752.  The magnetometer has a range of
+ * +-4912uT.  To go from the raw value to uT is:
+ *
+ * HuT = H * 4912/32752, or roughly, 3/20, instead of 3/10.
+ */
+static long ak09912_raw_to_gauss(u16 data)
+{
+	return (((long)data + 128) * 1500) / 256;
+}
+
+/* Compatible Asahi Kasei Compass parts */
+enum asahi_compass_chipset {
+	AK8975,
+	AK8963,
+	AK09911,
+	AK09912,
+	AK_MAX_TYPE
+};
+
+enum ak_ctrl_reg_addr {
+	ST1,
+	ST2,
+	CNTL,
+	ASA_BASE,
+	MAX_REGS,
+	REGS_END,
+};
+
+enum ak_ctrl_reg_mask {
+	ST1_DRDY,
+	ST2_HOFL,
+	ST2_DERR,
+	CNTL_MODE,
+	MASK_END,
+};
+
+enum ak_ctrl_mode {
+	POWER_DOWN,
+	MODE_ONCE,
+	SELF_TEST,
+	FUSE_ROM,
+	MODE_END,
+};
+
+struct ak_def {
+	enum asahi_compass_chipset type;
+	long (*raw_to_gauss)(u16 data);
+	u16 range;
+	u8 ctrl_regs[REGS_END];
+	u8 ctrl_masks[MASK_END];
+	u8 ctrl_modes[MODE_END];
+	u8 data_regs[3];
+};
+
+static const struct ak_def ak_def_array[AK_MAX_TYPE] = {
+	{
+		.type = AK8975,
+		.raw_to_gauss = ak8975_raw_to_gauss,
+		.range = 4096,
+		.ctrl_regs = {
+			AK8975_REG_ST1,
+			AK8975_REG_ST2,
+			AK8975_REG_CNTL,
+			AK8975_REG_ASAX,
+			AK8975_MAX_REGS},
+		.ctrl_masks = {
+			AK8975_REG_ST1_DRDY_MASK,
+			AK8975_REG_ST2_HOFL_MASK,
+			AK8975_REG_ST2_DERR_MASK,
+			AK8975_REG_CNTL_MODE_MASK},
+		.ctrl_modes = {
+			AK8975_REG_CNTL_MODE_POWER_DOWN,
+			AK8975_REG_CNTL_MODE_ONCE,
+			AK8975_REG_CNTL_MODE_SELF_TEST,
+			AK8975_REG_CNTL_MODE_FUSE_ROM},
+		.data_regs = {
+			AK8975_REG_HXL,
+			AK8975_REG_HYL,
+			AK8975_REG_HZL},
+	},
+	{
+		.type = AK8963,
+		.raw_to_gauss = ak8963_09911_raw_to_gauss,
+		.range = 8190,
+		.ctrl_regs = {
+			AK8975_REG_ST1,
+			AK8975_REG_ST2,
+			AK8975_REG_CNTL,
+			AK8975_REG_ASAX,
+			AK8975_MAX_REGS},
+		.ctrl_masks = {
+			AK8975_REG_ST1_DRDY_MASK,
+			AK8975_REG_ST2_HOFL_MASK,
+			0,
+			AK8975_REG_CNTL_MODE_MASK},
+		.ctrl_modes = {
+			AK8975_REG_CNTL_MODE_POWER_DOWN,
+			AK8975_REG_CNTL_MODE_ONCE,
+			AK8975_REG_CNTL_MODE_SELF_TEST,
+			AK8975_REG_CNTL_MODE_FUSE_ROM},
+		.data_regs = {
+			AK8975_REG_HXL,
+			AK8975_REG_HYL,
+			AK8975_REG_HZL},
+	},
+	{
+		.type = AK09911,
+		.raw_to_gauss = ak8963_09911_raw_to_gauss,
+		.range = 8192,
+		.ctrl_regs = {
+			AK09912_REG_ST1,
+			AK09912_REG_ST2,
+			AK09912_REG_CNTL2,
+			AK09912_REG_ASAX,
+			AK09912_MAX_REGS},
+		.ctrl_masks = {
+			AK09912_REG_ST1_DRDY_MASK,
+			AK09912_REG_ST2_HOFL_MASK,
+			0,
+			AK09912_REG_CNTL2_MODE_MASK},
+		.ctrl_modes = {
+			AK09912_REG_CNTL_MODE_POWER_DOWN,
+			AK09912_REG_CNTL_MODE_ONCE,
+			AK09912_REG_CNTL_MODE_SELF_TEST,
+			AK09912_REG_CNTL_MODE_FUSE_ROM},
+		.data_regs = {
+			AK09912_REG_HXL,
+			AK09912_REG_HYL,
+			AK09912_REG_HZL},
+	},
+	{
+		.type = AK09912,
+		.raw_to_gauss = ak09912_raw_to_gauss,
+		.range = 32752,
+		.ctrl_regs = {
+			AK09912_REG_ST1,
+			AK09912_REG_ST2,
+			AK09912_REG_CNTL2,
+			AK09912_REG_ASAX,
+			AK09912_MAX_REGS},
+		.ctrl_masks = {
+			AK09912_REG_ST1_DRDY_MASK,
+			AK09912_REG_ST2_HOFL_MASK,
+			0,
+			AK09912_REG_CNTL2_MODE_MASK},
+		.ctrl_modes = {
+			AK09912_REG_CNTL_MODE_POWER_DOWN,
+			AK09912_REG_CNTL_MODE_ONCE,
+			AK09912_REG_CNTL_MODE_SELF_TEST,
+			AK09912_REG_CNTL_MODE_FUSE_ROM},
+		.data_regs = {
+			AK09912_REG_HXL,
+			AK09912_REG_HYL,
+			AK09912_REG_HZL},
+	}
+};
 
 /*
  * Per-instance context data for the device.
  */
 struct ak8975_data {
 	struct i2c_client	*client;
-	struct attribute_group	attrs;
+	const struct ak_def	*def;
 	struct mutex		lock;
 	u8			asa[3];
 	long			raw_to_gauss[3];
-	u8			reg_cache[AK8975_MAX_REGS];
 	int			eoc_gpio;
+	int			eoc_irq;
+	wait_queue_head_t	data_ready_queue;
+	unsigned long		flags;
+	u8			cntl_cache;
+	struct iio_mount_matrix orientation;
+	struct regulator	*vdd;
 };
 
-static const int ak8975_index_to_reg[] = {
-	AK8975_REG_HXL, AK8975_REG_HYL, AK8975_REG_HZL,
-};
+/* Enable attached power regulator if any. */
+static int ak8975_power_on(struct i2c_client *client)
+{
+	const struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct ak8975_data *data = iio_priv(indio_dev);
+	int ret;
+
+	data->vdd = devm_regulator_get(&client->dev, "vdd");
+	if (IS_ERR_OR_NULL(data->vdd)) {
+		ret = PTR_ERR(data->vdd);
+		if (ret == -ENODEV)
+			ret = 0;
+	} else {
+		ret = regulator_enable(data->vdd);
+	}
+
+	if (ret)
+		dev_err(&client->dev, "failed to enable Vdd supply: %d\n", ret);
+	return ret;
+}
+
+/* Disable attached power regulator if any. */
+static void ak8975_power_off(const struct i2c_client *client)
+{
+	const struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	const struct ak8975_data *data = iio_priv(indio_dev);
+
+	if (!IS_ERR_OR_NULL(data->vdd))
+		regulator_disable(data->vdd);
+}
 
 /*
- * Helper function to write to the I2C device's registers.
+ * Return 0 if the i2c device is the one we expect.
+ * return a negative error number otherwise
  */
-static int ak8975_write_data(struct i2c_client *client,
-			     u8 reg, u8 val, u8 mask, u8 shift)
+static int ak8975_who_i_am(struct i2c_client *client,
+			   enum asahi_compass_chipset type)
+{
+	u8 wia_val[2];
+	int ret;
+
+	/*
+	 * Signature for each device:
+	 * Device   |  WIA1      |  WIA2
+	 * AK09912  |  DEVICE_ID |  AK09912_DEVICE_ID
+	 * AK09911  |  DEVICE_ID |  AK09911_DEVICE_ID
+	 * AK8975   |  DEVICE_ID |  NA
+	 * AK8963   |  DEVICE_ID |  NA
+	 */
+	ret = i2c_smbus_read_i2c_block_data(client, AK09912_REG_WIA1,
+					    2, wia_val);
+	if (ret < 0) {
+		dev_err(&client->dev, "Error reading WIA\n");
+		return ret;
+	}
+
+	if (wia_val[0] != AK8975_DEVICE_ID)
+		return -ENODEV;
+
+	switch (type) {
+	case AK8975:
+	case AK8963:
+		return 0;
+	case AK09911:
+		if (wia_val[1] == AK09911_DEVICE_ID)
+			return 0;
+		break;
+	case AK09912:
+		if (wia_val[1] == AK09912_DEVICE_ID)
+			return 0;
+		break;
+	default:
+		dev_err(&client->dev, "Type %d unknown\n", type);
+	}
+	return -ENODEV;
+}
+
+/*
+ * Helper function to write to CNTL register.
+ */
+static int ak8975_set_mode(struct ak8975_data *data, enum ak_ctrl_mode mode)
 {
-	struct iio_dev *indio_dev = i2c_get_clientdata(client);
-	struct ak8975_data *data = iio_priv(indio_dev);
 	u8 regval;
 	int ret;
 
-	regval = (data->reg_cache[reg] & ~mask) | (val << shift);
-	ret = i2c_smbus_write_byte_data(client, reg, regval);
+	regval = (data->cntl_cache & ~data->def->ctrl_masks[CNTL_MODE]) |
+		 data->def->ctrl_modes[mode];
+	ret = i2c_smbus_write_byte_data(data->client,
+					data->def->ctrl_regs[CNTL], regval);
 	if (ret < 0) {
-		dev_err(&client->dev, "Write to device fails status %x\n", ret);
 		return ret;
 	}
-	data->reg_cache[reg] = regval;
+	data->cntl_cache = regval;
+	/* After mode change wait atleast 100us */
+	usleep_range(100, 500);
 
 	return 0;
 }
 
 /*
+ * Handle data ready irq
+ */
+static irqreturn_t ak8975_irq_handler(int irq, void *data)
+{
+	struct ak8975_data *ak8975 = data;
+
+	set_bit(0, &ak8975->flags);
+	wake_up(&ak8975->data_ready_queue);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Install data ready interrupt handler
+ */
+static int ak8975_setup_irq(struct ak8975_data *data)
+{
+	struct i2c_client *client = data->client;
+	int rc;
+	int irq;
+
+	init_waitqueue_head(&data->data_ready_queue);
+	clear_bit(0, &data->flags);
+	if (client->irq)
+		irq = client->irq;
+	else
+		irq = gpio_to_irq(data->eoc_gpio);
+
+	rc = devm_request_irq(&client->dev, irq, ak8975_irq_handler,
+			      IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+			      dev_name(&client->dev), data);
+	if (rc < 0) {
+		dev_err(&client->dev,
+			"irq %d request failed, (gpio %d): %d\n",
+			irq, data->eoc_gpio, rc);
+		return rc;
+	}
+
+	data->eoc_irq = irq;
+
+	return rc;
+}
+
+
+/*
  * Perform some start-of-day setup, including reading the asa calibration
  * values and caching them.
  */
@@ -130,34 +531,18 @@ static int ak8975_setup(struct i2c_client *client)
 {
 	struct iio_dev *indio_dev = i2c_get_clientdata(client);
 	struct ak8975_data *data = iio_priv(indio_dev);
-	u8 device_id;
 	int ret;
 
-	/* Confirm that the device we're talking to is really an AK8975. */
-	ret = i2c_smbus_read_byte_data(client, AK8975_REG_WIA);
-	if (ret < 0) {
-		dev_err(&client->dev, "Error reading WIA\n");
-		return ret;
-	}
-	device_id = ret;
-	if (device_id != AK8975_DEVICE_ID) {
-		dev_err(&client->dev, "Device ak8975 not found\n");
-		return -ENODEV;
-	}
-
 	/* Write the fused rom access mode. */
-	ret = ak8975_write_data(client,
-				AK8975_REG_CNTL,
-				AK8975_REG_CNTL_MODE_FUSE_ROM,
-				AK8975_REG_CNTL_MODE_MASK,
-				AK8975_REG_CNTL_MODE_SHIFT);
+	ret = ak8975_set_mode(data, FUSE_ROM);
 	if (ret < 0) {
 		dev_err(&client->dev, "Error in setting fuse access mode\n");
 		return ret;
 	}
 
 	/* Get asa data and store in the device data. */
-	ret = i2c_smbus_read_i2c_block_data(client, AK8975_REG_ASAX,
+	ret = i2c_smbus_read_i2c_block_data(client,
+					    data->def->ctrl_regs[ASA_BASE],
 					    3, data->asa);
 	if (ret < 0) {
 		dev_err(&client->dev, "Not able to read asa data\n");
@@ -165,54 +550,24 @@ static int ak8975_setup(struct i2c_client *client)
 	}
 
 	/* After reading fuse ROM data set power-down mode */
-	ret = ak8975_write_data(client,
-				AK8975_REG_CNTL,
-				AK8975_REG_CNTL_MODE_POWER_DOWN,
-				AK8975_REG_CNTL_MODE_MASK,
-				AK8975_REG_CNTL_MODE_SHIFT);
+	ret = ak8975_set_mode(data, POWER_DOWN);
 	if (ret < 0) {
 		dev_err(&client->dev, "Error in setting power-down mode\n");
 		return ret;
 	}
 
-/*
- * Precalculate scale factor (in Gauss units) for each axis and
- * store in the device data.
- *
- * This scale factor is axis-dependent, and is derived from 3 calibration
- * factors ASA(x), ASA(y), and ASA(z).
- *
- * These ASA values are read from the sensor device at start of day, and
- * cached in the device context struct.
- *
- * Adjusting the flux value with the sensitivity adjustment value should be
- * done via the following formula:
- *
- * Hadj = H * ( ( ( (ASA-128)*0.5 ) / 128 ) + 1 )
- *
- * where H is the raw value, ASA is the sensitivity adjustment, and Hadj
- * is the resultant adjusted value.
- *
- * We reduce the formula to:
- *
- * Hadj = H * (ASA + 128) / 256
- *
- * H is in the range of -4096 to 4095.  The magnetometer has a range of
- * +-1229uT.  To go from the raw value to uT is:
- *
- * HuT = H * 1229/4096, or roughly, 3/10.
- *
- * Since 1uT = 100 gauss, our final scale factor becomes:
- *
- * Hadj = H * ((ASA + 128) / 256) * 3/10 * 100
- * Hadj = H * ((ASA + 128) * 30 / 256
- *
- * Since ASA doesn't change, we cache the resultant scale factor into the
- * device context in ak8975_setup().
- */
-	data->raw_to_gauss[0] = ((data->asa[0] + 128) * 30) >> 8;
-	data->raw_to_gauss[1] = ((data->asa[1] + 128) * 30) >> 8;
-	data->raw_to_gauss[2] = ((data->asa[2] + 128) * 30) >> 8;
+	if (data->eoc_gpio > 0 || client->irq > 0) {
+		ret = ak8975_setup_irq(data);
+		if (ret < 0) {
+			dev_err(&client->dev,
+				"Error setting data ready interrupt\n");
+			return ret;
+		}
+	}
+
+	data->raw_to_gauss[0] = data->def->raw_to_gauss(data->asa[0]);
+	data->raw_to_gauss[1] = data->def->raw_to_gauss(data->asa[1]);
+	data->raw_to_gauss[2] = data->def->raw_to_gauss(data->asa[2]);
 
 	return 0;
 }
@@ -235,7 +590,7 @@ static int wait_conversion_complete_gpio(struct ak8975_data *data)
 		return -EINVAL;
 	}
 
-	ret = i2c_smbus_read_byte_data(client, AK8975_REG_ST1);
+	ret = i2c_smbus_read_byte_data(client, data->def->ctrl_regs[ST1]);
 	if (ret < 0)
 		dev_err(&client->dev, "Error in reading ST1\n");
 
@@ -252,7 +607,8 @@ static int wait_conversion_complete_polled(struct ak8975_data *data)
 	/* Wait for the conversion to complete. */
 	while (timeout_ms) {
 		msleep(AK8975_CONVERSION_DONE_POLL_TIME);
-		ret = i2c_smbus_read_byte_data(client, AK8975_REG_ST1);
+		ret = i2c_smbus_read_byte_data(client,
+					       data->def->ctrl_regs[ST1]);
 		if (ret < 0) {
 			dev_err(&client->dev, "Error in reading ST1\n");
 			return ret;
@@ -266,69 +622,89 @@ static int wait_conversion_complete_polled(struct ak8975_data *data)
 		dev_err(&client->dev, "Conversion timeout happened\n");
 		return -EINVAL;
 	}
+
 	return read_status;
 }
 
-/*
- * Emits the raw flux value for the x, y, or z axis.
- */
-static int ak8975_read_axis(struct iio_dev *indio_dev, int index, int *val)
+/* Returns 0 if the end of conversion interrupt occured or -ETIME otherwise */
+static int wait_conversion_complete_interrupt(struct ak8975_data *data)
 {
-	struct ak8975_data *data = iio_priv(indio_dev);
-	struct i2c_client *client = data->client;
 	int ret;
 
-	mutex_lock(&data->lock);
+	ret = wait_event_timeout(data->data_ready_queue,
+				 test_bit(0, &data->flags),
+				 AK8975_DATA_READY_TIMEOUT);
+	clear_bit(0, &data->flags);
 
+	return ret > 0 ? 0 : -ETIME;
+}
+
+static int ak8975_start_read_axis(struct ak8975_data *data,
+				  const struct i2c_client *client)
+{
 	/* Set up the device for taking a sample. */
-	ret = ak8975_write_data(client,
-				AK8975_REG_CNTL,
-				AK8975_REG_CNTL_MODE_ONCE,
-				AK8975_REG_CNTL_MODE_MASK,
-				AK8975_REG_CNTL_MODE_SHIFT);
+	int ret = ak8975_set_mode(data, MODE_ONCE);
+
 	if (ret < 0) {
 		dev_err(&client->dev, "Error in setting operating mode\n");
-		goto exit;
+		return ret;
 	}
 
 	/* Wait for the conversion to complete. */
-	if (gpio_is_valid(data->eoc_gpio))
+	if (data->eoc_irq)
+		ret = wait_conversion_complete_interrupt(data);
+	else if (gpio_is_valid(data->eoc_gpio))
 		ret = wait_conversion_complete_gpio(data);
 	else
 		ret = wait_conversion_complete_polled(data);
 	if (ret < 0)
-		goto exit;
+		return ret;
 
-	if (ret & AK8975_REG_ST1_DRDY_MASK) {
-		ret = i2c_smbus_read_byte_data(client, AK8975_REG_ST2);
+	/* This will be executed only for non-interrupt based waiting case */
+	if (ret & data->def->ctrl_masks[ST1_DRDY]) {
+		ret = i2c_smbus_read_byte_data(client,
+					       data->def->ctrl_regs[ST2]);
 		if (ret < 0) {
 			dev_err(&client->dev, "Error in reading ST2\n");
-			goto exit;
+			return ret;
 		}
-		if (ret & (AK8975_REG_ST2_DERR_MASK |
-			   AK8975_REG_ST2_HOFL_MASK)) {
+		if (ret & (data->def->ctrl_masks[ST2_DERR] |
+			   data->def->ctrl_masks[ST2_HOFL])) {
 			dev_err(&client->dev, "ST2 status error 0x%x\n", ret);
-			ret = -EINVAL;
-			goto exit;
+			return -EINVAL;
 		}
 	}
 
-	/* Read the flux value from the appropriate register
-	   (the register is specified in the iio device attributes). */
-	ret = i2c_smbus_read_word_data(client, ak8975_index_to_reg[index]);
-	if (ret < 0) {
-		dev_err(&client->dev, "Read axis data fails\n");
+	return 0;
+}
+
+/* Retrieve raw flux value for one of the x, y, or z axis.  */
+static int ak8975_read_axis(struct iio_dev *indio_dev, int index, int *val)
+{
+	struct ak8975_data *data = iio_priv(indio_dev);
+	const struct i2c_client *client = data->client;
+	const struct ak_def *def = data->def;
+	int ret;
+
+	mutex_lock(&data->lock);
+
+	ret = ak8975_start_read_axis(data, client);
+	if (ret)
+		goto exit;
+
+	ret = i2c_smbus_read_word_data(client, def->data_regs[index]);
+	if (ret < 0)
 		goto exit;
-	}
 
 	mutex_unlock(&data->lock);
 
 	/* Clamp to valid range. */
-	*val = clamp_t(s16, ret, -4096, 4095);
+	*val = clamp_t(s16, ret, -def->range, def->range);
 	return IIO_VAL_INT;
 
 exit:
 	mutex_unlock(&data->lock);
+	dev_err(&client->dev, "Error in reading axis\n");
 	return ret;
 }
 
@@ -343,12 +719,34 @@ static int ak8975_read_raw(struct iio_dev *indio_dev,
 	case IIO_CHAN_INFO_RAW:
 		return ak8975_read_axis(indio_dev, chan->address, val);
 	case IIO_CHAN_INFO_SCALE:
-		*val = data->raw_to_gauss[chan->address];
-		return IIO_VAL_INT;
+		*val = 0;
+		*val2 = data->raw_to_gauss[chan->address];
+		return IIO_VAL_INT_PLUS_MICRO;
 	}
 	return -EINVAL;
 }
 
+static ssize_t ak8975_attr_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct ak8975_data *data = iio_priv(dev_to_iio_dev(dev));
+	const char **m = data->orientation.rotation;
+
+	return sprintf(buf, "%s, %s, %s; %s, %s, %s; %s, %s, %s\n",
+		m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);
+}
+
+static IIO_DEVICE_ATTR(in_mount_matrix, S_IRUGO, ak8975_attr_show, NULL, 0);
+
+static struct attribute *ak8975_attributes[] = {
+	&iio_dev_attr_in_mount_matrix.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group ak8975_attribute_group = {
+	.attrs = ak8975_attributes
+};
+
 #define AK8975_CHANNEL(axis, index)					\
 	{								\
 		.type = IIO_MAGN,					\
@@ -357,16 +755,104 @@ static int ak8975_read_raw(struct iio_dev *indio_dev,
 		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |		\
 			     BIT(IIO_CHAN_INFO_SCALE),			\
 		.address = index,					\
+		.scan_index = index,					\
+		.scan_type = {						\
+			.sign = 's',					\
+			.realbits = 16,					\
+			.storagebits = 16,				\
+			.endianness = IIO_CPU				\
+		},							\
 	}
 
 static const struct iio_chan_spec ak8975_channels[] = {
 	AK8975_CHANNEL(X, 0), AK8975_CHANNEL(Y, 1), AK8975_CHANNEL(Z, 2),
+	IIO_CHAN_SOFT_TIMESTAMP(3),
 };
 
+static const unsigned long ak8975_scan_masks[] = { 0x7, 0 };
+
 static const struct iio_info ak8975_info = {
 	.read_raw = &ak8975_read_raw,
 	.driver_module = THIS_MODULE,
+	.attrs = &ak8975_attribute_group,
+};
+
+static const struct acpi_device_id ak_acpi_match[] = {
+	{"AK8975", AK8975},
+	{"AK8963", AK8963},
+	{"INVN6500", AK8963},
+	{"AK09911", AK09911},
+	{"AK09912", AK09912},
+	{ },
 };
+MODULE_DEVICE_TABLE(acpi, ak_acpi_match);
+
+static const char *ak8975_match_acpi_device(struct device *dev,
+					    enum asahi_compass_chipset *chipset)
+{
+	const struct acpi_device_id *id;
+
+	id = acpi_match_device(dev->driver->acpi_match_table, dev);
+	if (!id)
+		return NULL;
+	*chipset = (int)id->driver_data;
+
+	return dev_name(dev);
+}
+
+static void ak8975_fill_buffer(struct iio_dev *indio_dev)
+{
+	struct ak8975_data *data = iio_priv(indio_dev);
+	const struct i2c_client *client = data->client;
+	const struct ak_def *def = data->def;
+	int ret;
+	s16 buff[8]; /* 3 x 16 bits axis values + 1 aligned 64 bits timestamp */
+	u64 *tmp;
+
+	mutex_lock(&data->lock);
+
+	ret = ak8975_start_read_axis(data, client);
+	if (ret)
+		goto unlock;
+
+	/*
+	 * For each axis, read the flux value from the appropriate register
+	 * (the register is specified in the iio device attributes).
+	 */
+	ret = i2c_smbus_read_i2c_block_data(client,
+							def->data_regs[0],
+							3 * sizeof(buff[0]),
+							(u8 *)buff);
+	if (ret < 0)
+		goto unlock;
+
+	mutex_unlock(&data->lock);
+
+	/* Clamp to valid range. */
+	buff[0] = clamp_t(s16, le16_to_cpu(buff[0]), -def->range, def->range);
+	buff[1] = clamp_t(s16, le16_to_cpu(buff[1]), -def->range, def->range);
+	buff[2] = clamp_t(s16, le16_to_cpu(buff[2]), -def->range, def->range);
+
+	tmp = (u64 *)buff;
+	tmp[1] = iio_get_time_ns();
+	iio_push_to_buffers(indio_dev, (void *)buff);
+
+	return;
+
+unlock:
+	mutex_unlock(&data->lock);
+	dev_err(&client->dev, "Error in reading axes block\n");
+}
+
+static irqreturn_t ak8975_handle_trigger(int irq, void *p)
+{
+	const struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+
+	ak8975_fill_buffer(indio_dev);
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
 
 static int ak8975_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
@@ -375,81 +861,139 @@ static int ak8975_probe(struct i2c_client *client,
 	struct iio_dev *indio_dev;
 	int eoc_gpio;
 	int err;
+	const char *name = NULL;
+	enum asahi_compass_chipset chipset = AK_MAX_TYPE;
 
 	/* Grab and set up the supplied GPIO. */
-	if (client->dev.platform_data == NULL)
-		eoc_gpio = -1;
+	if (client->dev.of_node)
+		eoc_gpio = of_get_gpio(client->dev.of_node, 0);
 	else
-		eoc_gpio = *(int *)(client->dev.platform_data);
+		eoc_gpio = -1;
+
+	if (eoc_gpio == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
 
 	/* We may not have a GPIO based IRQ to scan, that is fine, we will
 	   poll if so */
 	if (gpio_is_valid(eoc_gpio)) {
-		err = gpio_request_one(eoc_gpio, GPIOF_IN, "ak_8975");
+		err = devm_gpio_request_one(&client->dev, eoc_gpio,
+							GPIOF_IN, "ak_8975");
 		if (err < 0) {
 			dev_err(&client->dev,
 				"failed to request GPIO %d, error %d\n",
 							eoc_gpio, err);
-			goto exit;
+			return err;
 		}
 	}
 
 	/* Register with IIO */
 	indio_dev = iio_device_alloc(sizeof(*data));
-	if (indio_dev == NULL) {
-		err = -ENOMEM;
-		goto exit_gpio;
-	}
+	if (indio_dev == NULL)
+		return -ENOMEM;
+
 	data = iio_priv(indio_dev);
 	i2c_set_clientdata(client, indio_dev);
+
+	data->client = client;
+	data->eoc_gpio = eoc_gpio;
+	data->eoc_irq = 0;
+
+
+	err = of_property_read_string_array(client->dev.of_node,
+			"mount-matrix", data->orientation.rotation,
+			ARRAY_SIZE(data->orientation.rotation));
+
+	if (err != ARRAY_SIZE(data->orientation.rotation)) {
+		dev_err(&client->dev, "Failed to retrieve mounting matrix %d\n", err);
+		return err;
+	}
+
+	/* id will be NULL when enumerated via ACPI */
+	if (id) {
+		chipset = (enum asahi_compass_chipset)(id->driver_data);
+		name = id->name;
+	} else if (ACPI_HANDLE(&client->dev)) {
+		name = ak8975_match_acpi_device(&client->dev, &chipset);
+		if (!name)
+			return -ENODEV;
+	} else
+		return -ENOSYS;
+
+	if (chipset >= AK_MAX_TYPE) {
+		dev_err(&client->dev, "AKM device type unsupported: %d\n",
+			chipset);
+		return -ENODEV;
+	}
+
+	data->def = &ak_def_array[chipset];
+
+	err = ak8975_power_on(client);
+	if (err)
+		return err;
+
+	err = ak8975_who_i_am(client, data->def->type);
+	if (err < 0) {
+		dev_err(&client->dev, "Unexpected device\n");
+		goto power_off;
+	}
+	dev_dbg(&client->dev, "Asahi compass chip %s\n", name);
+
 	/* Perform some basic start-of-day setup of the device. */
 	err = ak8975_setup(client);
 	if (err < 0) {
-		dev_err(&client->dev, "AK8975 initialization fails\n");
-		goto exit_free_iio;
+		dev_err(&client->dev, "%s initialization fails\n", name);
+		goto power_off;
 	}
 
-	data->client = client;
 	mutex_init(&data->lock);
-	data->eoc_gpio = eoc_gpio;
 	indio_dev->dev.parent = &client->dev;
 	indio_dev->channels = ak8975_channels;
 	indio_dev->num_channels = ARRAY_SIZE(ak8975_channels);
 	indio_dev->info = &ak8975_info;
+	indio_dev->available_scan_masks = ak8975_scan_masks;
 	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->name = name;
+
+	err = iio_triggered_buffer_setup(indio_dev, NULL, ak8975_handle_trigger,
+					 NULL);
+	if (err) {
+		dev_err(&client->dev, "triggered buffer setup failed\n");
+		goto power_off;
+	}
 
 	err = iio_device_register(indio_dev);
-	if (err < 0)
-		goto exit_free_iio;
+	if (err) {
+		dev_err(&client->dev, "device register failed\n");
+		goto cleanup_buffer;
+	}
 
 	return 0;
 
-exit_free_iio:
-	iio_device_free(indio_dev);
-exit_gpio:
-	if (gpio_is_valid(eoc_gpio))
-		gpio_free(eoc_gpio);
-exit:
+cleanup_buffer:
+	iio_triggered_buffer_cleanup(indio_dev);
+power_off:
+	ak8975_power_off(client);
 	return err;
 }
 
 static int ak8975_remove(struct i2c_client *client)
 {
 	struct iio_dev *indio_dev = i2c_get_clientdata(client);
-	struct ak8975_data *data = iio_priv(indio_dev);
 
 	iio_device_unregister(indio_dev);
-
-	if (gpio_is_valid(data->eoc_gpio))
-		gpio_free(data->eoc_gpio);
-
+	iio_triggered_buffer_cleanup(indio_dev);
 	iio_device_free(indio_dev);
+	ak8975_power_off(client);
 
 	return 0;
 }
 
 static const struct i2c_device_id ak8975_id[] = {
-	{"ak8975", 0},
+	{"ak8975", AK8975},
+	{"ak8963", AK8963},
+	{"AK8963", AK8963},
+	{"ak09911", AK09911},
+	{"ak09912", AK09912},
 	{}
 };
 
@@ -458,14 +1002,21 @@ MODULE_DEVICE_TABLE(i2c, ak8975_id);
 static const struct of_device_id ak8975_of_match[] = {
 	{ .compatible = "asahi-kasei,ak8975", },
 	{ .compatible = "ak8975", },
-	{ }
+	{ .compatible = "asahi-kasei,ak8963", },
+	{ .compatible = "ak8963", },
+	{ .compatible = "asahi-kasei,ak09911", },
+	{ .compatible = "ak09911", },
+	{ .compatible = "asahi-kasei,ak09912", },
+	{ .compatible = "ak09912", },
+	{}
 };
 MODULE_DEVICE_TABLE(of, ak8975_of_match);
 
 static struct i2c_driver ak8975_driver = {
 	.driver = {
 		.name	= "ak8975",
-		.of_match_table = ak8975_of_match,
+		.of_match_table = of_match_ptr(ak8975_of_match),
+		.acpi_match_table = ACPI_PTR(ak_acpi_match),
 	},
 	.probe		= ak8975_probe,
 	.remove		= ak8975_remove,
diff --git a/drivers/infiniband/core/cm.c b/drivers/infiniband/core/cm.c
index 784b97c..c410217 100644
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@ -857,6 +857,11 @@ retest:
 	case IB_CM_SIDR_REQ_RCVD:
 		spin_unlock_irq(&cm_id_priv->lock);
 		cm_reject_sidr_req(cm_id_priv, IB_SIDR_REJECT);
+		spin_lock_irq(&cm.lock);
+		if (!RB_EMPTY_NODE(&cm_id_priv->sidr_id_node))
+			rb_erase(&cm_id_priv->sidr_id_node,
+				 &cm.remote_sidr_table);
+		spin_unlock_irq(&cm.lock);
 		break;
 	case IB_CM_REQ_SENT:
 		ib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);
@@ -3093,7 +3098,10 @@ int ib_send_cm_sidr_rep(struct ib_cm_id *cm_id,
 	spin_unlock_irqrestore(&cm_id_priv->lock, flags);
 
 	spin_lock_irqsave(&cm.lock, flags);
-	rb_erase(&cm_id_priv->sidr_id_node, &cm.remote_sidr_table);
+	if (!RB_EMPTY_NODE(&cm_id_priv->sidr_id_node)) {
+		rb_erase(&cm_id_priv->sidr_id_node, &cm.remote_sidr_table);
+		RB_CLEAR_NODE(&cm_id_priv->sidr_id_node);
+	}
 	spin_unlock_irqrestore(&cm.lock, flags);
 	return 0;
 
diff --git a/drivers/infiniband/core/ucm.c b/drivers/infiniband/core/ucm.c
index f2f6393..5befec1 100644
--- a/drivers/infiniband/core/ucm.c
+++ b/drivers/infiniband/core/ucm.c
@@ -48,6 +48,7 @@
 
 #include <asm/uaccess.h>
 
+#include <rdma/ib.h>
 #include <rdma/ib_cm.h>
 #include <rdma/ib_user_cm.h>
 #include <rdma/ib_marshall.h>
@@ -1104,6 +1105,9 @@ static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,
 	struct ib_ucm_cmd_hdr hdr;
 	ssize_t result;
 
+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))
+		return -EACCES;
+
 	if (len < sizeof(hdr))
 		return -EINVAL;
 
diff --git a/drivers/infiniband/core/ucma.c b/drivers/infiniband/core/ucma.c
index 5ca44cd..99f1c170 100644
--- a/drivers/infiniband/core/ucma.c
+++ b/drivers/infiniband/core/ucma.c
@@ -43,6 +43,7 @@
 #include <linux/sysctl.h>
 #include <linux/module.h>
 
+#include <rdma/ib.h>
 #include <rdma/rdma_user_cm.h>
 #include <rdma/ib_marshall.h>
 #include <rdma/rdma_cm.h>
@@ -1249,6 +1250,9 @@ static ssize_t ucma_write(struct file *filp, const char __user *buf,
 	struct rdma_ucm_cmd_hdr hdr;
 	ssize_t ret;
 
+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))
+		return -EACCES;
+
 	if (len < sizeof(hdr))
 		return -EINVAL;
 
diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c
index a841123..c1fef27 100644
--- a/drivers/infiniband/core/umem.c
+++ b/drivers/infiniband/core/umem.c
@@ -94,6 +94,17 @@ struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,
 	if (dmasync)
 		dma_set_attr(DMA_ATTR_WRITE_BARRIER, &attrs);
 
+	if (!size)
+		return ERR_PTR(-EINVAL);
+
+	/*
+	 * If the combination of the addr and size requested for this memory
+	 * region causes an integer overflow, return error.
+	 */
+	if (((addr + size) < addr) ||
+	    PAGE_ALIGN(addr + size) < (addr + size))
+		return ERR_PTR(-EINVAL);
+
 	if (!can_do_mlock())
 		return ERR_PTR(-EPERM);
 
diff --git a/drivers/infiniband/core/uverbs.h b/drivers/infiniband/core/uverbs.h
index 0fcd7aa..8b8de21 100644
--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@ -69,7 +69,7 @@
  */
 
 struct ib_uverbs_device {
-	struct kref				ref;
+	atomic_t				refcount;
 	int					num_comp_vectors;
 	struct completion			comp;
 	struct device			       *dev;
@@ -78,6 +78,7 @@ struct ib_uverbs_device {
 	struct cdev			        cdev;
 	struct rb_root				xrcd_tree;
 	struct mutex				xrcd_tree_mutex;
+	struct kobject				kobj;
 };
 
 struct ib_uverbs_event_file {
diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c
index a7d00f6..44c15ce 100644
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@ -2106,6 +2106,12 @@ ssize_t ib_uverbs_post_send(struct ib_uverbs_file *file,
 		next->send_flags = user_wr->send_flags;
 
 		if (is_ud) {
+			if (next->opcode != IB_WR_SEND &&
+			    next->opcode != IB_WR_SEND_WITH_IMM) {
+				ret = -EINVAL;
+				goto out_put;
+			}
+
 			next->wr.ud.ah = idr_read_ah(user_wr->wr.ud.ah,
 						     file->ucontext);
 			if (!next->wr.ud.ah) {
@@ -2142,9 +2148,11 @@ ssize_t ib_uverbs_post_send(struct ib_uverbs_file *file,
 					user_wr->wr.atomic.compare_add;
 				next->wr.atomic.swap = user_wr->wr.atomic.swap;
 				next->wr.atomic.rkey = user_wr->wr.atomic.rkey;
+			case IB_WR_SEND:
 				break;
 			default:
-				break;
+				ret = -EINVAL;
+				goto out_put;
 			}
 		}
 
diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c
index 2c6f0f2..f50623d 100644
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@ -48,6 +48,8 @@
 
 #include <asm/uaccess.h>
 
+#include <rdma/ib.h>
+
 #include "uverbs.h"
 
 MODULE_AUTHOR("Roland Dreier");
@@ -119,14 +121,18 @@ static ssize_t (*uverbs_cmd_table[])(struct ib_uverbs_file *file,
 static void ib_uverbs_add_one(struct ib_device *device);
 static void ib_uverbs_remove_one(struct ib_device *device);
 
-static void ib_uverbs_release_dev(struct kref *ref)
+static void ib_uverbs_release_dev(struct kobject *kobj)
 {
 	struct ib_uverbs_device *dev =
-		container_of(ref, struct ib_uverbs_device, ref);
+		container_of(kobj, struct ib_uverbs_device, kobj);
 
-	complete(&dev->comp);
+	kfree(dev);
 }
 
+static struct kobj_type ib_uverbs_dev_ktype = {
+	.release = ib_uverbs_release_dev,
+};
+
 static void ib_uverbs_release_event_file(struct kref *ref)
 {
 	struct ib_uverbs_event_file *file =
@@ -282,13 +288,19 @@ static int ib_uverbs_cleanup_ucontext(struct ib_uverbs_file *file,
 	return context->device->dealloc_ucontext(context);
 }
 
+static void ib_uverbs_comp_dev(struct ib_uverbs_device *dev)
+{
+	complete(&dev->comp);
+}
+
 static void ib_uverbs_release_file(struct kref *ref)
 {
 	struct ib_uverbs_file *file =
 		container_of(ref, struct ib_uverbs_file, ref);
 
 	module_put(file->device->ib_dev->owner);
-	kref_put(&file->device->ref, ib_uverbs_release_dev);
+	if (atomic_dec_and_test(&file->device->refcount))
+		ib_uverbs_comp_dev(file->device);
 
 	kfree(file);
 }
@@ -460,6 +472,7 @@ static void ib_uverbs_async_handler(struct ib_uverbs_file *file,
 
 	entry->desc.async.element    = element;
 	entry->desc.async.event_type = event;
+	entry->desc.async.reserved   = 0;
 	entry->counter               = counter;
 
 	list_add_tail(&entry->list, &file->async_file->event_list);
@@ -577,6 +590,9 @@ static ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,
 	struct ib_uverbs_file *file = filp->private_data;
 	struct ib_uverbs_cmd_hdr hdr;
 
+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))
+		return -EACCES;
+
 	if (count < sizeof hdr)
 		return -EINVAL;
 
@@ -628,9 +644,7 @@ static int ib_uverbs_open(struct inode *inode, struct file *filp)
 	int ret;
 
 	dev = container_of(inode->i_cdev, struct ib_uverbs_device, cdev);
-	if (dev)
-		kref_get(&dev->ref);
-	else
+	if (!atomic_inc_not_zero(&dev->refcount))
 		return -ENXIO;
 
 	if (!try_module_get(dev->ib_dev->owner)) {
@@ -651,6 +665,7 @@ static int ib_uverbs_open(struct inode *inode, struct file *filp)
 	mutex_init(&file->mutex);
 
 	filp->private_data = file;
+	kobject_get(&dev->kobj);
 
 	return nonseekable_open(inode, filp);
 
@@ -658,13 +673,16 @@ err_module:
 	module_put(dev->ib_dev->owner);
 
 err:
-	kref_put(&dev->ref, ib_uverbs_release_dev);
+	if (atomic_dec_and_test(&dev->refcount))
+		ib_uverbs_comp_dev(dev);
+
 	return ret;
 }
 
 static int ib_uverbs_close(struct inode *inode, struct file *filp)
 {
 	struct ib_uverbs_file *file = filp->private_data;
+	struct ib_uverbs_device *dev = file->device;
 
 	ib_uverbs_cleanup_ucontext(file, file->ucontext);
 
@@ -672,6 +690,7 @@ static int ib_uverbs_close(struct inode *inode, struct file *filp)
 		kref_put(&file->async_file->ref, ib_uverbs_release_event_file);
 
 	kref_put(&file->ref, ib_uverbs_release_file);
+	kobject_put(&dev->kobj);
 
 	return 0;
 }
@@ -767,10 +786,11 @@ static void ib_uverbs_add_one(struct ib_device *device)
 	if (!uverbs_dev)
 		return;
 
-	kref_init(&uverbs_dev->ref);
+	atomic_set(&uverbs_dev->refcount, 1);
 	init_completion(&uverbs_dev->comp);
 	uverbs_dev->xrcd_tree = RB_ROOT;
 	mutex_init(&uverbs_dev->xrcd_tree_mutex);
+	kobject_init(&uverbs_dev->kobj, &ib_uverbs_dev_ktype);
 
 	spin_lock(&map_lock);
 	devnum = find_first_zero_bit(dev_map, IB_UVERBS_MAX_DEVICES);
@@ -797,6 +817,7 @@ static void ib_uverbs_add_one(struct ib_device *device)
 	cdev_init(&uverbs_dev->cdev, NULL);
 	uverbs_dev->cdev.owner = THIS_MODULE;
 	uverbs_dev->cdev.ops = device->mmap ? &uverbs_mmap_fops : &uverbs_fops;
+	uverbs_dev->cdev.kobj.parent = &uverbs_dev->kobj;
 	kobject_set_name(&uverbs_dev->cdev.kobj, "uverbs%d", uverbs_dev->devnum);
 	if (cdev_add(&uverbs_dev->cdev, base, 1))
 		goto err_cdev;
@@ -827,9 +848,10 @@ err_cdev:
 		clear_bit(devnum, overflow_map);
 
 err:
-	kref_put(&uverbs_dev->ref, ib_uverbs_release_dev);
+	if (atomic_dec_and_test(&uverbs_dev->refcount))
+		ib_uverbs_comp_dev(uverbs_dev);
 	wait_for_completion(&uverbs_dev->comp);
-	kfree(uverbs_dev);
+	kobject_put(&uverbs_dev->kobj);
 	return;
 }
 
@@ -849,9 +871,10 @@ static void ib_uverbs_remove_one(struct ib_device *device)
 	else
 		clear_bit(uverbs_dev->devnum - IB_UVERBS_MAX_DEVICES, overflow_map);
 
-	kref_put(&uverbs_dev->ref, ib_uverbs_release_dev);
+	if (atomic_dec_and_test(&uverbs_dev->refcount))
+		ib_uverbs_comp_dev(uverbs_dev);
 	wait_for_completion(&uverbs_dev->comp);
-	kfree(uverbs_dev);
+	kobject_put(&uverbs_dev->kobj);
 }
 
 static char *uverbs_devnode(struct device *dev, umode_t *mode)
diff --git a/drivers/infiniband/hw/cxgb3/iwch_cm.c b/drivers/infiniband/hw/cxgb3/iwch_cm.c
index 3e094cd..a9194ef 100644
--- a/drivers/infiniband/hw/cxgb3/iwch_cm.c
+++ b/drivers/infiniband/hw/cxgb3/iwch_cm.c
@@ -149,7 +149,7 @@ static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_en
 	error = l2t_send(tdev, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
-	return error;
+	return error < 0 ? error : 0;
 }
 
 int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)
@@ -165,7 +165,7 @@ int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)
 	error = cxgb3_ofld_send(tdev, skb);
 	if (error < 0)
 		kfree_skb(skb);
-	return error;
+	return error < 0 ? error : 0;
 }
 
 static void release_tid(struct t3cdev *tdev, u32 hwtid, struct sk_buff *skb)
diff --git a/drivers/infiniband/hw/mlx4/ah.c b/drivers/infiniband/hw/mlx4/ah.c
index a251bec..f55d695 100644
--- a/drivers/infiniband/hw/mlx4/ah.c
+++ b/drivers/infiniband/hw/mlx4/ah.c
@@ -65,6 +65,7 @@ static struct ib_ah *create_ib_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr,
 
 	ah->av.ib.port_pd = cpu_to_be32(to_mpd(pd)->pdn | (ah_attr->port_num << 24));
 	ah->av.ib.g_slid  = ah_attr->src_path_bits;
+	ah->av.ib.sl_tclass_flowlabel = cpu_to_be32(ah_attr->sl << 28);
 	if (ah_attr->ah_flags & IB_AH_GRH) {
 		ah->av.ib.g_slid   |= 0x80;
 		ah->av.ib.gid_index = ah_attr->grh.sgid_index;
@@ -82,7 +83,6 @@ static struct ib_ah *create_ib_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr,
 		       !(1 << ah->av.ib.stat_rate & dev->caps.stat_rate_support))
 			--ah->av.ib.stat_rate;
 	}
-	ah->av.ib.sl_tclass_flowlabel = cpu_to_be32(ah_attr->sl << 28);
 
 	return &ah->ibah;
 }
@@ -169,9 +169,13 @@ int mlx4_ib_query_ah(struct ib_ah *ibah, struct ib_ah_attr *ah_attr)
 	enum rdma_link_layer ll;
 
 	memset(ah_attr, 0, sizeof *ah_attr);
-	ah_attr->sl = be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 28;
 	ah_attr->port_num = be32_to_cpu(ah->av.ib.port_pd) >> 24;
 	ll = rdma_port_get_link_layer(ibah->device, ah_attr->port_num);
+	if (ll == IB_LINK_LAYER_ETHERNET)
+		ah_attr->sl = be32_to_cpu(ah->av.eth.sl_tclass_flowlabel) >> 29;
+	else
+		ah_attr->sl = be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 28;
+
 	ah_attr->dlid = ll == IB_LINK_LAYER_INFINIBAND ? be16_to_cpu(ah->av.ib.dlid) : 0;
 	if (ah->av.ib.stat_rate)
 		ah_attr->static_rate = ah->av.ib.stat_rate - MLX4_STAT_RATE_OFFSET;
diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c
index 4d599ce..6ee5348 100644
--- a/drivers/infiniband/hw/mlx4/mad.c
+++ b/drivers/infiniband/hw/mlx4/mad.c
@@ -64,6 +64,14 @@ enum {
 #define GUID_TBL_BLK_NUM_ENTRIES 8
 #define GUID_TBL_BLK_SIZE (GUID_TBL_ENTRY_SIZE * GUID_TBL_BLK_NUM_ENTRIES)
 
+/* Counters should be saturate once they reach their maximum value */
+#define ASSIGN_32BIT_COUNTER(counter, value) do {\
+	if ((value) > U32_MAX)			 \
+		counter = cpu_to_be32(U32_MAX); \
+	else					 \
+		counter = cpu_to_be32(value);	 \
+} while (0)
+
 struct mlx4_mad_rcv_buf {
 	struct ib_grh grh;
 	u8 payload[256];
@@ -730,10 +738,14 @@ static int ib_process_mad(struct ib_device *ibdev, int mad_flags, u8 port_num,
 static void edit_counter(struct mlx4_counter *cnt,
 					struct ib_pma_portcounters *pma_cnt)
 {
-	pma_cnt->port_xmit_data = cpu_to_be32((be64_to_cpu(cnt->tx_bytes)>>2));
-	pma_cnt->port_rcv_data  = cpu_to_be32((be64_to_cpu(cnt->rx_bytes)>>2));
-	pma_cnt->port_xmit_packets = cpu_to_be32(be64_to_cpu(cnt->tx_frames));
-	pma_cnt->port_rcv_packets  = cpu_to_be32(be64_to_cpu(cnt->rx_frames));
+	ASSIGN_32BIT_COUNTER(pma_cnt->port_xmit_data,
+			     (be64_to_cpu(cnt->tx_bytes) >> 2));
+	ASSIGN_32BIT_COUNTER(pma_cnt->port_rcv_data,
+			     (be64_to_cpu(cnt->rx_bytes) >> 2));
+	ASSIGN_32BIT_COUNTER(pma_cnt->port_xmit_packets,
+			     be64_to_cpu(cnt->tx_frames));
+	ASSIGN_32BIT_COUNTER(pma_cnt->port_rcv_packets,
+			     be64_to_cpu(cnt->rx_frames));
 }
 
 static int iboe_process_mad(struct ib_device *ibdev, int mad_flags, u8 port_num,
diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c
index 4f10af2..1fe3bdb 100644
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@ -346,7 +346,7 @@ static int send_wqe_overhead(enum mlx4_ib_qp_type type, u32 flags)
 			sizeof (struct mlx4_wqe_raddr_seg);
 	case MLX4_IB_QPT_RC:
 		return sizeof (struct mlx4_wqe_ctrl_seg) +
-			sizeof (struct mlx4_wqe_atomic_seg) +
+			sizeof (struct mlx4_wqe_masked_atomic_seg) +
 			sizeof (struct mlx4_wqe_raddr_seg);
 	case MLX4_IB_QPT_SMI:
 	case MLX4_IB_QPT_GSI:
@@ -2174,8 +2174,7 @@ static int build_lso_seg(struct mlx4_wqe_lso_seg *wqe, struct ib_send_wr *wr,
 
 	memcpy(wqe->header, wr->wr.ud.header, wr->wr.ud.hlen);
 
-	*lso_hdr_sz  = cpu_to_be32((wr->wr.ud.mss - wr->wr.ud.hlen) << 16 |
-				   wr->wr.ud.hlen);
+	*lso_hdr_sz  = cpu_to_be32(wr->wr.ud.mss << 16 | wr->wr.ud.hlen);
 	*lso_seg_len = halign;
 	return 0;
 }
diff --git a/drivers/infiniband/hw/mlx4/sysfs.c b/drivers/infiniband/hw/mlx4/sysfs.c
index 97516eb..c5ce408 100644
--- a/drivers/infiniband/hw/mlx4/sysfs.c
+++ b/drivers/infiniband/hw/mlx4/sysfs.c
@@ -563,6 +563,8 @@ static int add_port(struct mlx4_ib_dev *dev, int port_num, int slave)
 	struct mlx4_port *p;
 	int i;
 	int ret;
+	int is_eth = rdma_port_get_link_layer(&dev->ib_dev, port_num) ==
+			IB_LINK_LAYER_ETHERNET;
 
 	p = kzalloc(sizeof *p, GFP_KERNEL);
 	if (!p)
@@ -580,7 +582,8 @@ static int add_port(struct mlx4_ib_dev *dev, int port_num, int slave)
 
 	p->pkey_group.name  = "pkey_idx";
 	p->pkey_group.attrs =
-		alloc_group_attrs(show_port_pkey, store_port_pkey,
+		alloc_group_attrs(show_port_pkey,
+				  is_eth ? NULL : store_port_pkey,
 				  dev->dev->caps.pkey_table_len[port_num]);
 	if (!p->pkey_group.attrs)
 		goto err_alloc;
diff --git a/drivers/infiniband/hw/qib/qib.h b/drivers/infiniband/hw/qib/qib.h
index d1b30c6..727a9dc 100644
--- a/drivers/infiniband/hw/qib/qib.h
+++ b/drivers/infiniband/hw/qib/qib.h
@@ -1467,27 +1467,22 @@ extern struct mutex qib_mutex;
  * first to avoid possible serial port delays from printk.
  */
 #define qib_early_err(dev, fmt, ...) \
-	do { \
-		dev_err(dev, fmt, ##__VA_ARGS__); \
-	} while (0)
+	dev_err(dev, fmt, ##__VA_ARGS__)
 
 #define qib_dev_err(dd, fmt, ...) \
-	do { \
-		dev_err(&(dd)->pcidev->dev, "%s: " fmt, \
-			qib_get_unit_name((dd)->unit), ##__VA_ARGS__); \
-	} while (0)
+	dev_err(&(dd)->pcidev->dev, "%s: " fmt, \
+		qib_get_unit_name((dd)->unit), ##__VA_ARGS__)
 
-#define qib_dev_porterr(dd, port, fmt, ...) \
-	do { \
-		dev_err(&(dd)->pcidev->dev, "%s: IB%u:%u " fmt, \
-			qib_get_unit_name((dd)->unit), (dd)->unit, (port), \
-			##__VA_ARGS__); \
-	} while (0)
+#define qib_dev_warn(dd, fmt, ...) \
+	dev_warn(&(dd)->pcidev->dev, "%s: " fmt, \
+		qib_get_unit_name((dd)->unit), ##__VA_ARGS__)
 
+#define qib_dev_porterr(dd, port, fmt, ...) \
+	dev_err(&(dd)->pcidev->dev, "%s: IB%u:%u " fmt, \
+		qib_get_unit_name((dd)->unit), (dd)->unit, (port), \
+		##__VA_ARGS__)
 #define qib_devinfo(pcidev, fmt, ...) \
-	do { \
-		dev_info(&(pcidev)->dev, fmt, ##__VA_ARGS__); \
-	} while (0)
+	dev_info(&(pcidev)->dev, fmt, ##__VA_ARGS__)
 
 /*
  * this is used for formatting hw error messages...
diff --git a/drivers/infiniband/hw/qib/qib_file_ops.c b/drivers/infiniband/hw/qib/qib_file_ops.c
index b56c942..8cb29b3 100644
--- a/drivers/infiniband/hw/qib/qib_file_ops.c
+++ b/drivers/infiniband/hw/qib/qib_file_ops.c
@@ -45,6 +45,8 @@
 #include <linux/delay.h>
 #include <linux/export.h>
 
+#include <rdma/ib.h>
+
 #include "qib.h"
 #include "qib_common.h"
 #include "qib_user_sdma.h"
@@ -1977,6 +1979,9 @@ static ssize_t qib_write(struct file *fp, const char __user *data,
 	ssize_t ret = 0;
 	void *dest;
 
+	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))
+		return -EACCES;
+
 	if (count < sizeof(cmd.type)) {
 		ret = -EINVAL;
 		goto bail;
diff --git a/drivers/infiniband/hw/qib/qib_keys.c b/drivers/infiniband/hw/qib/qib_keys.c
index 3b9afcc..eabe547 100644
--- a/drivers/infiniband/hw/qib/qib_keys.c
+++ b/drivers/infiniband/hw/qib/qib_keys.c
@@ -86,6 +86,10 @@ int qib_alloc_lkey(struct qib_mregion *mr, int dma_region)
 	 * unrestricted LKEY.
 	 */
 	rkt->gen++;
+	/*
+	 * bits are capped in qib_verbs.c to insure enough bits
+	 * for generation number
+	 */
 	mr->lkey = (r << (32 - ib_qib_lkey_table_size)) |
 		((((1 << (24 - ib_qib_lkey_table_size)) - 1) & rkt->gen)
 		 << 8);
diff --git a/drivers/infiniband/hw/qib/qib_verbs.c b/drivers/infiniband/hw/qib/qib_verbs.c
index 904c384..6c809bf 100644
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@ -40,6 +40,7 @@
 #include <linux/rculist.h>
 #include <linux/mm.h>
 #include <linux/random.h>
+#include <linux/vmalloc.h>
 
 #include "qib.h"
 #include "qib_common.h"
@@ -2084,10 +2085,16 @@ int qib_register_ib_device(struct qib_devdata *dd)
 	 * the LKEY).  The remaining bits act as a generation number or tag.
 	 */
 	spin_lock_init(&dev->lk_table.lock);
+	/* insure generation is at least 4 bits see keys.c */
+	if (ib_qib_lkey_table_size > MAX_LKEY_TABLE_BITS) {
+		qib_dev_warn(dd, "lkey bits %u too large, reduced to %u\n",
+			ib_qib_lkey_table_size, MAX_LKEY_TABLE_BITS);
+		ib_qib_lkey_table_size = MAX_LKEY_TABLE_BITS;
+	}
 	dev->lk_table.max = 1 << ib_qib_lkey_table_size;
 	lk_tab_size = dev->lk_table.max * sizeof(*dev->lk_table.table);
 	dev->lk_table.table = (struct qib_mregion __rcu **)
-		__get_free_pages(GFP_KERNEL, get_order(lk_tab_size));
+		vmalloc(lk_tab_size);
 	if (dev->lk_table.table == NULL) {
 		ret = -ENOMEM;
 		goto err_lk;
@@ -2260,7 +2267,7 @@ err_tx:
 					sizeof(struct qib_pio_header),
 				  dev->pio_hdrs, dev->pio_hdrs_phys);
 err_hdrs:
-	free_pages((unsigned long) dev->lk_table.table, get_order(lk_tab_size));
+	vfree(dev->lk_table.table);
 err_lk:
 	kfree(dev->qp_table);
 err_qpt:
@@ -2314,8 +2321,7 @@ void qib_unregister_ib_device(struct qib_devdata *dd)
 					sizeof(struct qib_pio_header),
 				  dev->pio_hdrs, dev->pio_hdrs_phys);
 	lk_tab_size = dev->lk_table.max * sizeof(*dev->lk_table.table);
-	free_pages((unsigned long) dev->lk_table.table,
-		   get_order(lk_tab_size));
+	vfree(dev->lk_table.table);
 	kfree(dev->qp_table);
 }
 
diff --git a/drivers/infiniband/hw/qib/qib_verbs.h b/drivers/infiniband/hw/qib/qib_verbs.h
index aff8b2c..e4f9fff 100644
--- a/drivers/infiniband/hw/qib/qib_verbs.h
+++ b/drivers/infiniband/hw/qib/qib_verbs.h
@@ -645,6 +645,8 @@ struct qib_qpn_table {
 	struct qpn_map map[QPNMAP_ENTRIES];
 };
 
+#define MAX_LKEY_TABLE_BITS 23
+
 struct qib_lkey_table {
 	spinlock_t lock; /* protect changes in this struct */
 	u32 next;               /* next unused index (speeds search) */
diff --git a/drivers/infiniband/hw/qib/qib_verbs_mcast.c b/drivers/infiniband/hw/qib/qib_verbs_mcast.c
index dabb697..48ba1c3 100644
--- a/drivers/infiniband/hw/qib/qib_verbs_mcast.c
+++ b/drivers/infiniband/hw/qib/qib_verbs_mcast.c
@@ -286,15 +286,13 @@ int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
 	struct qib_ibdev *dev = to_idev(ibqp->device);
 	struct qib_ibport *ibp = to_iport(ibqp->device, qp->port_num);
 	struct qib_mcast *mcast = NULL;
-	struct qib_mcast_qp *p, *tmp;
+	struct qib_mcast_qp *p, *tmp, *delp = NULL;
 	struct rb_node *n;
 	int last = 0;
 	int ret;
 
-	if (ibqp->qp_num <= 1 || qp->state == IB_QPS_RESET) {
-		ret = -EINVAL;
-		goto bail;
-	}
+	if (ibqp->qp_num <= 1 || qp->state == IB_QPS_RESET)
+		return -EINVAL;
 
 	spin_lock_irq(&ibp->lock);
 
@@ -303,8 +301,7 @@ int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
 	while (1) {
 		if (n == NULL) {
 			spin_unlock_irq(&ibp->lock);
-			ret = -EINVAL;
-			goto bail;
+			return -EINVAL;
 		}
 
 		mcast = rb_entry(n, struct qib_mcast, rb_node);
@@ -328,6 +325,7 @@ int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
 		 */
 		list_del_rcu(&p->list);
 		mcast->n_attached--;
+		delp = p;
 
 		/* If this was the last attached QP, remove the GID too. */
 		if (list_empty(&mcast->qp_list)) {
@@ -338,15 +336,16 @@ int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
 	}
 
 	spin_unlock_irq(&ibp->lock);
+	/* QP not attached */
+	if (!delp)
+		return -EINVAL;
+	/*
+	 * Wait for any list walkers to finish before freeing the
+	 * list element.
+	 */
+	wait_event(mcast->wait, atomic_read(&mcast->refcount) <= 1);
+	qib_mcast_qp_free(delp);
 
-	if (p) {
-		/*
-		 * Wait for any list walkers to finish before freeing the
-		 * list element.
-		 */
-		wait_event(mcast->wait, atomic_read(&mcast->refcount) <= 1);
-		qib_mcast_qp_free(p);
-	}
 	if (last) {
 		atomic_dec(&mcast->refcount);
 		wait_event(mcast->wait, !atomic_read(&mcast->refcount));
@@ -355,11 +354,7 @@ int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
 		dev->n_mcast_grps_allocated--;
 		spin_unlock_irq(&dev->n_mcast_grps_lock);
 	}
-
-	ret = 0;
-
-bail:
-	return ret;
+	return 0;
 }
 
 int qib_mcast_tree_empty(struct qib_ibport *ibp)
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index b6e049a..a481094 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -887,7 +887,9 @@ struct ipoib_neigh *ipoib_neigh_get(struct net_device *dev, u8 *daddr)
 				neigh = NULL;
 				goto out_unlock;
 			}
-			neigh->alive = jiffies;
+
+			if (likely(skb_queue_len(&neigh->queue) < IPOIB_MAX_PATH_REC_QUEUE))
+				neigh->alive = jiffies;
 			goto out_unlock;
 		}
 	}
diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index 8019e64..43aa807 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -49,6 +49,8 @@ static int
 isert_rdma_accept(struct isert_conn *isert_conn);
 struct rdma_cm_id *isert_setup_id(struct isert_np *isert_np);
 
+static void isert_release_work(struct work_struct *work);
+
 static void
 isert_qp_event_callback(struct ib_event *e, void *context)
 {
@@ -202,7 +204,7 @@ fail:
 static void
 isert_free_rx_descriptors(struct isert_conn *isert_conn)
 {
-	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
+	struct ib_device *ib_dev = isert_conn->conn_device->ib_device;
 	struct iser_rx_desc *rx_desc;
 	int i;
 
@@ -432,6 +434,7 @@ isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 	init_completion(&isert_conn->conn_wait_comp_err);
 	kref_init(&isert_conn->conn_kref);
 	mutex_init(&isert_conn->conn_mutex);
+	INIT_WORK(&isert_conn->release_work, isert_release_work);
 
 	isert_conn->conn_cm_id = cma_id;
 	isert_conn->responder_resources = event->param.conn.responder_resources;
@@ -527,14 +530,15 @@ out:
 static void
 isert_connect_release(struct isert_conn *isert_conn)
 {
-	struct ib_device *ib_dev = isert_conn->conn_cm_id->device;
 	struct isert_device *device = isert_conn->conn_device;
 	int cq_index;
+	struct ib_device *ib_dev = device->ib_device;
 
 	pr_debug("Entering isert_connect_release(): >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
 
 	isert_free_rx_descriptors(isert_conn);
-	rdma_destroy_id(isert_conn->conn_cm_id);
+	if (isert_conn->conn_cm_id)
+		rdma_destroy_id(isert_conn->conn_cm_id);
 
 	if (isert_conn->conn_qp) {
 		cq_index = ((struct isert_cq_desc *)
@@ -673,6 +677,7 @@ isert_disconnected_handler(struct rdma_cm_id *cma_id,
 {
 	struct isert_np *isert_np = cma_id->context;
 	struct isert_conn *isert_conn;
+	bool terminating = false;
 
 	if (isert_np->np_cm_id == cma_id)
 		return isert_np_cma_handler(cma_id->context, event);
@@ -680,21 +685,37 @@ isert_disconnected_handler(struct rdma_cm_id *cma_id,
 	isert_conn = cma_id->qp->qp_context;
 
 	mutex_lock(&isert_conn->conn_mutex);
+	terminating = (isert_conn->state == ISER_CONN_TERMINATING);
 	isert_conn_terminate(isert_conn);
 	mutex_unlock(&isert_conn->conn_mutex);
 
 	pr_info("conn %p completing conn_wait\n", isert_conn);
 	complete(&isert_conn->conn_wait);
 
+	if (terminating)
+		goto out;
+
+	mutex_lock(&isert_np->np_accept_mutex);
+	if (!list_empty(&isert_conn->conn_accept_node)) {
+		list_del_init(&isert_conn->conn_accept_node);
+		isert_put_conn(isert_conn);
+		queue_work(isert_release_wq, &isert_conn->release_work);
+	}
+	mutex_unlock(&isert_np->np_accept_mutex);
+
+out:
 	return 0;
 }
 
-static void
+static int
 isert_connect_error(struct rdma_cm_id *cma_id)
 {
 	struct isert_conn *isert_conn = cma_id->qp->qp_context;
 
+	isert_conn->conn_cm_id = NULL;
 	isert_put_conn(isert_conn);
+
+	return -1;
 }
 
 static int
@@ -724,7 +745,7 @@ isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 	case RDMA_CM_EVENT_REJECTED:       /* FALLTHRU */
 	case RDMA_CM_EVENT_UNREACHABLE:    /* FALLTHRU */
 	case RDMA_CM_EVENT_CONNECT_ERROR:
-		isert_connect_error(cma_id);
+		ret = isert_connect_error(cma_id);
 		break;
 	default:
 		pr_err("Unhandled RDMA CMA event: %d\n", event->event);
@@ -2418,7 +2439,6 @@ static void isert_wait_conn(struct iscsi_conn *conn)
 
 	wait_for_completion(&isert_conn->conn_wait_comp_err);
 
-	INIT_WORK(&isert_conn->release_work, isert_release_work);
 	queue_work(isert_release_wq, &isert_conn->release_work);
 }
 
diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c
index 856c1b0..685e125 100644
--- a/drivers/input/joystick/xpad.c
+++ b/drivers/input/joystick/xpad.c
@@ -843,6 +843,9 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 	struct usb_endpoint_descriptor *ep_irq_in;
 	int i, error;
 
+	if (intf->cur_altsetting->desc.bNumEndpoints != 2)
+		return -ENODEV;
+
 	for (i = 0; xpad_device[i].idVendor; i++) {
 		if ((le16_to_cpu(udev->descriptor.idVendor) == xpad_device[i].idVendor) &&
 		    (le16_to_cpu(udev->descriptor.idProduct) == xpad_device[i].idProduct))
diff --git a/drivers/input/misc/ati_remote2.c b/drivers/input/misc/ati_remote2.c
index f63341f..e8c6a48 100644
--- a/drivers/input/misc/ati_remote2.c
+++ b/drivers/input/misc/ati_remote2.c
@@ -817,26 +817,49 @@ static int ati_remote2_probe(struct usb_interface *interface, const struct usb_d
 
 	ar2->udev = udev;
 
+	/* Sanity check, first interface must have an endpoint */
+	if (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {
+		dev_err(&interface->dev,
+			"%s(): interface 0 must have an endpoint\n", __func__);
+		r = -ENODEV;
+		goto fail1;
+	}
 	ar2->intf[0] = interface;
 	ar2->ep[0] = &alt->endpoint[0].desc;
 
+	/* Sanity check, the device must have two interfaces */
 	ar2->intf[1] = usb_ifnum_to_if(udev, 1);
+	if ((udev->actconfig->desc.bNumInterfaces < 2) || !ar2->intf[1]) {
+		dev_err(&interface->dev, "%s(): need 2 interfaces, found %d\n",
+			__func__, udev->actconfig->desc.bNumInterfaces);
+		r = -ENODEV;
+		goto fail1;
+	}
+
 	r = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);
 	if (r)
 		goto fail1;
+
+	/* Sanity check, second interface must have an endpoint */
 	alt = ar2->intf[1]->cur_altsetting;
+	if (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {
+		dev_err(&interface->dev,
+			"%s(): interface 1 must have an endpoint\n", __func__);
+		r = -ENODEV;
+		goto fail2;
+	}
 	ar2->ep[1] = &alt->endpoint[0].desc;
 
 	r = ati_remote2_urb_init(ar2);
 	if (r)
-		goto fail2;
+		goto fail3;
 
 	ar2->channel_mask = channel_mask;
 	ar2->mode_mask = mode_mask;
 
 	r = ati_remote2_setup(ar2, ar2->channel_mask);
 	if (r)
-		goto fail2;
+		goto fail3;
 
 	usb_make_path(udev, ar2->phys, sizeof(ar2->phys));
 	strlcat(ar2->phys, "/input0", sizeof(ar2->phys));
@@ -845,11 +868,11 @@ static int ati_remote2_probe(struct usb_interface *interface, const struct usb_d
 
 	r = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);
 	if (r)
-		goto fail2;
+		goto fail3;
 
 	r = ati_remote2_input_init(ar2);
 	if (r)
-		goto fail3;
+		goto fail4;
 
 	usb_set_intfdata(interface, ar2);
 
@@ -857,10 +880,11 @@ static int ati_remote2_probe(struct usb_interface *interface, const struct usb_d
 
 	return 0;
 
- fail3:
+ fail4:
 	sysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);
- fail2:
+ fail3:
 	ati_remote2_urb_cleanup(ar2);
+ fail2:
 	usb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);
  fail1:
 	kfree(ar2);
diff --git a/drivers/input/misc/ims-pcu.c b/drivers/input/misc/ims-pcu.c
index e204f26..77164dc 100644
--- a/drivers/input/misc/ims-pcu.c
+++ b/drivers/input/misc/ims-pcu.c
@@ -1433,6 +1433,8 @@ static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pc
 
 	pcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,
 					 union_desc->bMasterInterface0);
+	if (!pcu->ctrl_intf)
+		return -EINVAL;
 
 	alt = pcu->ctrl_intf->cur_altsetting;
 	pcu->ep_ctrl = &alt->endpoint[0].desc;
@@ -1440,6 +1442,8 @@ static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pc
 
 	pcu->data_intf = usb_ifnum_to_if(pcu->udev,
 					 union_desc->bSlaveInterface0);
+	if (!pcu->data_intf)
+		return -EINVAL;
 
 	alt = pcu->data_intf->cur_altsetting;
 	if (alt->desc.bNumEndpoints != 2) {
diff --git a/drivers/input/misc/max8997_haptic.c b/drivers/input/misc/max8997_haptic.c
index e973133..a8c9122 100644
--- a/drivers/input/misc/max8997_haptic.c
+++ b/drivers/input/misc/max8997_haptic.c
@@ -246,12 +246,14 @@ static int max8997_haptic_probe(struct platform_device *pdev)
 	struct max8997_dev *iodev = dev_get_drvdata(pdev->dev.parent);
 	const struct max8997_platform_data *pdata =
 					dev_get_platdata(iodev->dev);
-	const struct max8997_haptic_platform_data *haptic_pdata =
-					pdata->haptic_pdata;
+	const struct max8997_haptic_platform_data *haptic_pdata = NULL;
 	struct max8997_haptic *chip;
 	struct input_dev *input_dev;
 	int error;
 
+	if (pdata)
+		haptic_pdata = pdata->haptic_pdata;
+
 	if (!haptic_pdata) {
 		dev_err(&pdev->dev, "no haptic platform data\n");
 		return -EINVAL;
diff --git a/drivers/input/misc/powermate.c b/drivers/input/misc/powermate.c
index 49c0c3e..21ce1cf 100644
--- a/drivers/input/misc/powermate.c
+++ b/drivers/input/misc/powermate.c
@@ -308,6 +308,9 @@ static int powermate_probe(struct usb_interface *intf, const struct usb_device_i
 	int error = -ENOMEM;
 
 	interface = intf->cur_altsetting;
+	if (interface->desc.bNumEndpoints < 1)
+		return -EINVAL;
+
 	endpoint = &interface->endpoint[0].desc;
 	if (!usb_endpoint_is_int_in(endpoint))
 		return -EIO;
diff --git a/drivers/input/misc/uinput.c b/drivers/input/misc/uinput.c
index a0a4bba..3f2f3ac 100644
--- a/drivers/input/misc/uinput.c
+++ b/drivers/input/misc/uinput.c
@@ -835,9 +835,15 @@ static long uinput_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 }
 
 #ifdef CONFIG_COMPAT
+
+#define UI_SET_PHYS_COMPAT	_IOW(UINPUT_IOCTL_BASE, 108, compat_uptr_t)
+
 static long uinput_compat_ioctl(struct file *file,
 				unsigned int cmd, unsigned long arg)
 {
+	if (cmd == UI_SET_PHYS_COMPAT)
+		cmd = UI_SET_PHYS;
+
 	return uinput_ioctl_handler(file, cmd, arg, compat_ptr(arg));
 }
 #endif
diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c
index 85e75239..77f06d0 100644
--- a/drivers/input/mouse/elantech.c
+++ b/drivers/input/mouse/elantech.c
@@ -314,7 +314,7 @@ static void elantech_report_semi_mt_data(struct input_dev *dev,
 					 unsigned int x2, unsigned int y2)
 {
 	elantech_set_slot(dev, 0, num_fingers != 0, x1, y1);
-	elantech_set_slot(dev, 1, num_fingers == 2, x2, y2);
+	elantech_set_slot(dev, 1, num_fingers >= 2, x2, y2);
 }
 
 /*
@@ -784,6 +784,21 @@ static psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)
 }
 
 /*
+ * This writes the reg_07 value again to the hardware at the end of every
+ * set_rate call because the register loses its value. reg_07 allows setting
+ * absolute mode on v4 hardware
+ */
+static void elantech_set_rate_restore_reg_07(struct psmouse *psmouse,
+		unsigned int rate)
+{
+	struct elantech_data *etd = psmouse->private;
+
+	etd->original_set_rate(psmouse, rate);
+	if (elantech_write_reg(psmouse, 0x07, etd->reg_07))
+		psmouse_err(psmouse, "restoring reg_07 failed\n");
+}
+
+/*
  * Put the touchpad into absolute mode
  */
 static int elantech_set_absolute_mode(struct psmouse *psmouse)
@@ -985,6 +1000,8 @@ static int elantech_get_resolution_v4(struct psmouse *psmouse,
  * Asus K53SV              0x450f01        78, 15, 0c      2 hw buttons
  * Asus G46VW              0x460f02        00, 18, 0c      2 hw buttons
  * Asus G750JX             0x360f00        00, 16, 0c      2 hw buttons
+ * Asus TP500LN            0x381f17        10, 14, 0e      clickpad
+ * Asus X750JN             0x381f17        10, 14, 0e      clickpad
  * Asus UX31               0x361f00        20, 15, 0e      clickpad
  * Asus UX32VD             0x361f02        00, 15, 0e      clickpad
  * Avatar AVIU-145A2       0x361f00        ?               clickpad
@@ -1064,7 +1081,7 @@ static int elantech_set_input_params(struct psmouse *psmouse)
 			input_set_abs_params(dev, ABS_TOOL_WIDTH, ETP_WMIN_V2,
 					     ETP_WMAX_V2, 0, 0);
 		}
-		input_mt_init_slots(dev, 2, 0);
+		input_mt_init_slots(dev, 2, INPUT_MT_SEMI_MT);
 		input_set_abs_params(dev, ABS_MT_POSITION_X, x_min, x_max, 0, 0);
 		input_set_abs_params(dev, ABS_MT_POSITION_Y, y_min, y_max, 0, 0);
 		break;
@@ -1224,10 +1241,11 @@ static bool elantech_is_signature_valid(const unsigned char *param)
 		return true;
 
 	/*
-	 * Some models have a revision higher then 20. Meaning param[2] may
-	 * be 10 or 20, skip the rates check for these.
+	 * Some hw_version >= 4 models have a revision higher then 20. Meaning
+	 * that param[2] may be 10 or 20, skip the rates check for these.
 	 */
-	if (param[0] == 0x46 && (param[1] & 0xef) == 0x0f && param[2] < 40)
+	if ((param[0] & 0x0f) >= 0x06 && (param[1] & 0xaf) == 0x0f &&
+	    param[2] < 40)
 		return true;
 
 	for (i = 0; i < ARRAY_SIZE(rates); i++)
@@ -1339,6 +1357,13 @@ static const struct dmi_system_id no_hw_res_dmi_table[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "U2442"),
 		},
 	},
+	{
+		/* Fujitsu LIFEBOOK U745 does not work with crc_enabled == 0 */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "LIFEBOOK U745"),
+		},
+	},
 #endif
 	{ }
 };
@@ -1452,6 +1477,11 @@ int elantech_init(struct psmouse *psmouse)
 		goto init_fail;
 	}
 
+	if (etd->fw_version == 0x381f17) {
+		etd->original_set_rate = psmouse->set_rate;
+		psmouse->set_rate = elantech_set_rate_restore_reg_07;
+	}
+
 	if (elantech_set_input_params(psmouse)) {
 		psmouse_err(psmouse, "failed to query touchpad range.\n");
 		goto init_fail;
diff --git a/drivers/input/mouse/elantech.h b/drivers/input/mouse/elantech.h
index c1c15ab..13a12cc 100644
--- a/drivers/input/mouse/elantech.h
+++ b/drivers/input/mouse/elantech.h
@@ -138,6 +138,7 @@ struct elantech_data {
 	struct finger_pos mt[ETP_MAX_FINGERS];
 	unsigned char parity[256];
 	int (*send_cmd)(struct psmouse *psmouse, unsigned char c, unsigned char *param);
+	void (*original_set_rate)(struct psmouse *psmouse, unsigned int rate);
 };
 
 #ifdef CONFIG_MOUSE_PS2_ELANTECH
diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h
index 4de2571..5102b4f 100644
--- a/drivers/input/serio/i8042-x86ia64io.h
+++ b/drivers/input/serio/i8042-x86ia64io.h
@@ -258,6 +258,13 @@ static const struct dmi_system_id __initconst i8042_dmi_nomux_table[] = {
 		},
 	},
 	{
+		/* Fujitsu Lifebook U745 */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "LIFEBOOK U745"),
+		},
+	},
+	{
 		/* Fujitsu T70H */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
diff --git a/drivers/input/tablet/gtco.c b/drivers/input/tablet/gtco.c
index 29e01ab..a9f8f92 100644
--- a/drivers/input/tablet/gtco.c
+++ b/drivers/input/tablet/gtco.c
@@ -869,6 +869,14 @@ static int gtco_probe(struct usb_interface *usbinterface,
 		goto err_free_buf;
 	}
 
+	/* Sanity check that a device has an endpoint */
+	if (usbinterface->altsetting[0].desc.bNumEndpoints < 1) {
+		dev_err(&usbinterface->dev,
+			"Invalid number of endpoints\n");
+		error = -EINVAL;
+		goto err_free_urb;
+	}
+
 	/*
 	 * The endpoint is always altsetting 0, we know this since we know
 	 * this device only has one interrupt endpoint
@@ -890,7 +898,7 @@ static int gtco_probe(struct usb_interface *usbinterface,
 	 * HID report descriptor
 	 */
 	if (usb_get_extra_descriptor(usbinterface->cur_altsetting,
-				     HID_DEVICE_TYPE, &hid_desc) != 0){
+				     HID_DEVICE_TYPE, &hid_desc) != 0) {
 		dev_err(&usbinterface->dev,
 			"Can't retrieve exta USB descriptor to get hid report descriptor length\n");
 		error = -EIO;
diff --git a/drivers/input/touchscreen/ads7846.c b/drivers/input/touchscreen/ads7846.c
index 84ccf14..9332e46 100644
--- a/drivers/input/touchscreen/ads7846.c
+++ b/drivers/input/touchscreen/ads7846.c
@@ -697,18 +697,22 @@ static int ads7846_no_filter(void *ads, int data_idx, int *val)
 
 static int ads7846_get_value(struct ads7846 *ts, struct spi_message *m)
 {
+	int value;
 	struct spi_transfer *t =
 		list_entry(m->transfers.prev, struct spi_transfer, transfer_list);
 
 	if (ts->model == 7845) {
-		return be16_to_cpup((__be16 *)&(((char*)t->rx_buf)[1])) >> 3;
+		value = be16_to_cpup((__be16 *)&(((char *)t->rx_buf)[1]));
 	} else {
 		/*
 		 * adjust:  on-wire is a must-ignore bit, a BE12 value, then
 		 * padding; built from two 8 bit values written msb-first.
 		 */
-		return be16_to_cpup((__be16 *)t->rx_buf) >> 3;
+		value = be16_to_cpup((__be16 *)t->rx_buf);
 	}
+
+	/* enforce ADC output is 12 bits width */
+	return (value >> 3) & 0xfff;
 }
 
 static void ads7846_update_value(struct spi_message *m, int val)
diff --git a/drivers/input/touchscreen/usbtouchscreen.c b/drivers/input/touchscreen/usbtouchscreen.c
index 5f87bed..20aef5d 100644
--- a/drivers/input/touchscreen/usbtouchscreen.c
+++ b/drivers/input/touchscreen/usbtouchscreen.c
@@ -626,6 +626,9 @@ static int dmc_tsc10_init(struct usbtouch_usb *usbtouch)
 		goto err_out;
 	}
 
+	/* TSC-25 data sheet specifies a delay after the RESET command */
+	msleep(150);
+
 	/* set coordinate output rate */
 	buf[0] = buf[1] = 0xFF;
 	ret = usb_control_msg(dev, usb_rcvctrlpipe (dev, 0),
diff --git a/drivers/input/touchscreen/wacom_w8001.c b/drivers/input/touchscreen/wacom_w8001.c
index 9a83be6..abba112 100644
--- a/drivers/input/touchscreen/wacom_w8001.c
+++ b/drivers/input/touchscreen/wacom_w8001.c
@@ -28,7 +28,7 @@ MODULE_AUTHOR("Jaya Kumar <jayakumar.lkml@gmail.com>");
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
-#define W8001_MAX_LENGTH	11
+#define W8001_MAX_LENGTH	13
 #define W8001_LEAD_MASK		0x80
 #define W8001_LEAD_BYTE		0x80
 #define W8001_TAB_MASK		0x40
diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c
index dfb401c..6bde2a1 100644
--- a/drivers/iommu/amd_iommu.c
+++ b/drivers/iommu/amd_iommu.c
@@ -2106,8 +2106,8 @@ static void set_dte_entry(u16 devid, struct protection_domain *domain, bool ats)
 static void clear_dte_entry(u16 devid)
 {
 	/* remove entry from the device table seen by the hardware */
-	amd_iommu_dev_table[devid].data[0] = IOMMU_PTE_P | IOMMU_PTE_TV;
-	amd_iommu_dev_table[devid].data[1] = 0;
+	amd_iommu_dev_table[devid].data[0]  = IOMMU_PTE_P | IOMMU_PTE_TV;
+	amd_iommu_dev_table[devid].data[1] &= DTE_FLAG_MASK;
 
 	amd_iommu_apply_erratum_63(devid);
 }
diff --git a/drivers/iommu/amd_iommu_types.h b/drivers/iommu/amd_iommu_types.h
index 0285a21..7570f45 100644
--- a/drivers/iommu/amd_iommu_types.h
+++ b/drivers/iommu/amd_iommu_types.h
@@ -282,6 +282,7 @@
 #define IOMMU_PTE_IR (1ULL << 61)
 #define IOMMU_PTE_IW (1ULL << 62)
 
+#define DTE_FLAG_MASK	(0x3ffULL << 32)
 #define DTE_FLAG_IOTLB	(0x01UL << 32)
 #define DTE_FLAG_GV	(0x01ULL << 55)
 #define DTE_GLX_SHIFT	(56)
diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c
index a7967ce..3d4622c 100644
--- a/drivers/iommu/dmar.c
+++ b/drivers/iommu/dmar.c
@@ -968,7 +968,7 @@ void dmar_disable_qi(struct intel_iommu *iommu)
 
 	raw_spin_lock_irqsave(&iommu->register_lock, flags);
 
-	sts =  dmar_readq(iommu->reg + DMAR_GSTS_REG);
+	sts =  readl(iommu->reg + DMAR_GSTS_REG);
 	if (!(sts & DMA_GSTS_QIES))
 		goto end;
 
diff --git a/drivers/iommu/intel_irq_remapping.c b/drivers/iommu/intel_irq_remapping.c
index 45011f6..990cc29 100644
--- a/drivers/iommu/intel_irq_remapping.c
+++ b/drivers/iommu/intel_irq_remapping.c
@@ -495,7 +495,7 @@ static void iommu_disable_irq_remapping(struct intel_iommu *iommu)
 
 	raw_spin_lock_irqsave(&iommu->register_lock, flags);
 
-	sts = dmar_readq(iommu->reg + DMAR_GSTS_REG);
+	sts = readl(iommu->reg + DMAR_GSTS_REG);
 	if (!(sts & DMA_GSTS_IRES))
 		goto end;
 
diff --git a/drivers/irqchip/irq-ambarella.c b/drivers/irqchip/irq-ambarella.c
index dbaa9bf..b2bbec0 100644
--- a/drivers/irqchip/irq-ambarella.c
+++ b/drivers/irqchip/irq-ambarella.c
@@ -329,7 +329,7 @@ static void ambvic_raise_softirq(const struct cpumask *mask, unsigned int irq)
 	ambvic_sw_set(ambvic_data.ipi_reg_base, softirq);
 }
 
-static void ambvic_smp_softirq_init(void)
+void ambvic_smp_softirq_init(void)
 {
 	void __iomem *reg_base = ambvic_data.ipi_reg_base;
 	u32 val;
@@ -381,36 +381,35 @@ static inline int ambvic_handle_ipi(struct pt_regs *regs,
 static int ambvic_handle_scratchpad_vic(struct pt_regs *regs,
 	struct irq_domain *domain)
 {
-	u32 scratchpad;
-	u32 bank;
-	u32 irq, hwirq;
+	u32 scratchpad, irq_sta, irq, hwirq;
 	int handled = 0;
 
-	if (smp_processor_id()) {
-		scratchpad = AHB_SCRATCHPAD_REG(0x40);
-	} else {
-		scratchpad = AHB_SCRATCHPAD_REG(0x3C);
-	}
+	if (smp_processor_id())
+		scratchpad = AHBSP_PRI_IRQ_C1_REG;
+	else
+		scratchpad = AHBSP_PRI_IRQ_C0_REG;
+
 	do {
 		hwirq = amba_readl(scratchpad);
 		if (hwirq == VIC_NULL_PRI_IRQ_VAL) {
 #if (VIC_NULL_PRI_IRQ_FIX == 1)
-			void __iomem *reg_base = ambvic_data.reg_base[2];
-			if ((amba_readl(reg_base + VIC_IRQ_STA_OFFSET) & 0x1) == 0)
+			irq_sta = amba_readl(ambvic_data.reg_base[2] + VIC_IRQ_STA_OFFSET);
+			if ((irq_sta & 0x1) == 0)
 				break;
 #else
 			break;
 #endif
+		} else if (hwirq == 0) {
+			irq_sta = amba_readl(ambvic_data.reg_base[0] + VIC_IRQ_STA_OFFSET);
+			if ((irq_sta & 0x1) == 0)
+				break;
 		}
-		bank = (hwirq >> 5) & 0x3;
-		hwirq &= 0x1F;
+
 #if 0
 		printk("CPU%d_%s: %d_%d\n",
 			smp_processor_id(), __func__,
-			bank, hwirq);
+			(hwirq >> 5) & 0x3, hwirq & 0x1F);
 #endif
-		hwirq += bank * NR_VIC_IRQ_SIZE;
-
 		if (ambvic_handle_ipi(regs, domain, hwirq)) {
 			handled = 1;
 			continue;
@@ -428,9 +427,7 @@ static int ambvic_handle_one(struct pt_regs *regs,
 	struct irq_domain *domain, u32 bank)
 {
 	void __iomem *reg_base = ambvic_data.reg_base[bank];
-	u32 irq;
-	u32 hwirq;
-	u32 irq_sta;
+	u32 hwirq, irq, irq_sta;
 	int handled = 0;
 
 	do {
@@ -438,7 +435,7 @@ static int ambvic_handle_one(struct pt_regs *regs,
 		hwirq = amba_readl(reg_base + VIC_INT_PENDING_OFFSET);
 		if (hwirq == 0) {
 			irq_sta = amba_readl(reg_base + VIC_IRQ_STA_OFFSET);
-			if ((irq_sta & 0x00000001) == 0) {
+			if ((irq_sta & 0x1) == 0) {
 				break;
 			}
 		}
@@ -603,8 +600,8 @@ int __init ambvic_of_init(struct device_node *np, struct device_node *parent)
 			NR_VIC_IRQS, &amb_irq_domain_ops, NULL);
 	BUG_ON(!ambvic_data.domain);
 
-	// WORKAROUND only, will be removed finally
-	for (i = 1; i < NR_VIC_IRQS; i++) {
+	/* create mapping to make hwirq == irq to make life easier */
+	for (i = NR_VIC_IRQS - 1; i >= 0; i--) {
 		irq = irq_create_mapping(ambvic_data.domain, i);
 		irq_set_chip_and_handler(irq, &ambvic_chip, handle_level_irq);
 		irq_set_chip_data(irq, ambvic_data.reg_base[HWIRQ_TO_BANK(i)]);
diff --git a/drivers/isdn/gigaset/ser-gigaset.c b/drivers/isdn/gigaset/ser-gigaset.c
index 8c91fd5eb..3ac9c41 100644
--- a/drivers/isdn/gigaset/ser-gigaset.c
+++ b/drivers/isdn/gigaset/ser-gigaset.c
@@ -524,9 +524,18 @@ gigaset_tty_open(struct tty_struct *tty)
 	cs->hw.ser->tty = tty;
 	atomic_set(&cs->hw.ser->refcnt, 1);
 	init_completion(&cs->hw.ser->dead_cmp);
-
 	tty->disc_data = cs;
 
+	/* Set the amount of data we're willing to receive per call
+	 * from the hardware driver to half of the input buffer size
+	 * to leave some reserve.
+	 * Note: We don't do flow control towards the hardware driver.
+	 * If more data is received than will fit into the input buffer,
+	 * it will be dropped and an error will be logged. This should
+	 * never happen as the device is slow and the buffer size ample.
+	 */
+	tty->receive_room = RBUFSIZE/2;
+
 	/* OK.. Initialization of the datastructures and the HW is done.. Now
 	 * startup system and notify the LL that we are ready to run
 	 */
diff --git a/drivers/isdn/hardware/mISDN/hfcpci.c b/drivers/isdn/hardware/mISDN/hfcpci.c
index a7e4939..eab9167 100644
--- a/drivers/isdn/hardware/mISDN/hfcpci.c
+++ b/drivers/isdn/hardware/mISDN/hfcpci.c
@@ -2295,8 +2295,8 @@ _hfcpci_softirq(struct device *dev, void *arg)
 static void
 hfcpci_softirq(void *arg)
 {
-	(void) driver_for_each_device(&hfc_driver.driver, NULL, arg,
-				      _hfcpci_softirq);
+	WARN_ON_ONCE(driver_for_each_device(&hfc_driver.driver, NULL, arg,
+				      _hfcpci_softirq) != 0);
 
 	/* if next event would be in the past ... */
 	if ((s32)(hfc_jiffies + tics - jiffies) <= 0)
diff --git a/drivers/isdn/i4l/isdn_ppp.c b/drivers/isdn/i4l/isdn_ppp.c
index 38ceac5..0ed6731 100644
--- a/drivers/isdn/i4l/isdn_ppp.c
+++ b/drivers/isdn/i4l/isdn_ppp.c
@@ -301,6 +301,8 @@ isdn_ppp_open(int min, struct file *file)
 	is->compflags = 0;
 
 	is->reset = isdn_ppp_ccp_reset_alloc(is);
+	if (!is->reset)
+		return -ENOMEM;
 
 	is->lp = NULL;
 	is->mp_seqno = 0;       /* MP sequence number */
@@ -320,6 +322,10 @@ isdn_ppp_open(int min, struct file *file)
 	 * VJ header compression init
 	 */
 	is->slcomp = slhc_init(16, 16);	/* not necessary for 2. link in bundle */
+	if (IS_ERR(is->slcomp)) {
+		isdn_ppp_ccp_reset_free(is);
+		return PTR_ERR(is->slcomp);
+	}
 #endif
 #ifdef CONFIG_IPPP_FILTER
 	is->pass_filter = NULL;
@@ -568,10 +574,8 @@ isdn_ppp_ioctl(int min, struct file *file, unsigned int cmd, unsigned long arg)
 			is->maxcid = val;
 #ifdef CONFIG_ISDN_PPP_VJ
 			sltmp = slhc_init(16, val);
-			if (!sltmp) {
-				printk(KERN_ERR "ippp, can't realloc slhc struct\n");
-				return -ENOMEM;
-			}
+			if (IS_ERR(sltmp))
+				return PTR_ERR(sltmp);
 			if (is->slcomp)
 				slhc_free(is->slcomp);
 			is->slcomp = sltmp;
diff --git a/drivers/lguest/core.c b/drivers/lguest/core.c
index 0bf1e4e..19da222 100644
--- a/drivers/lguest/core.c
+++ b/drivers/lguest/core.c
@@ -176,7 +176,7 @@ static void unmap_switcher(void)
 bool lguest_address_ok(const struct lguest *lg,
 		       unsigned long addr, unsigned long len)
 {
-	return (addr+len) / PAGE_SIZE < lg->pfn_limit && (addr+len >= addr);
+	return addr+len <= lg->pfn_limit * PAGE_SIZE && (addr+len >= addr);
 }
 
 /*
diff --git a/drivers/macintosh/windfarm_core.c b/drivers/macintosh/windfarm_core.c
index 3ee198b..cc7ece1 100644
--- a/drivers/macintosh/windfarm_core.c
+++ b/drivers/macintosh/windfarm_core.c
@@ -435,7 +435,7 @@ int wf_unregister_client(struct notifier_block *nb)
 {
 	mutex_lock(&wf_lock);
 	blocking_notifier_chain_unregister(&wf_client_list, nb);
-	wf_client_count++;
+	wf_client_count--;
 	if (wf_client_count == 0)
 		wf_stop_thread();
 	mutex_unlock(&wf_lock);
diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c
index b4713ce..2a4c13a 100644
--- a/drivers/md/bcache/super.c
+++ b/drivers/md/bcache/super.c
@@ -1295,6 +1295,9 @@ static void cache_set_flush(struct closure *cl)
 	set_bit(CACHE_SET_STOPPING_2, &c->flags);
 	wake_up(&c->alloc_wait);
 
+	if (!c)
+		closure_return(cl);
+
 	bch_cache_accounting_destroy(&c->accounting);
 
 	kobject_put(&c->internal);
@@ -1959,8 +1962,10 @@ static int __init bcache_init(void)
 	closure_debug_init();
 
 	bcache_major = register_blkdev(0, "bcache");
-	if (bcache_major < 0)
+	if (bcache_major < 0) {
+		unregister_reboot_notifier(&reboot);
 		return bcache_major;
+	}
 
 	if (!(bcache_wq = create_workqueue("bcache")) ||
 	    !(bcache_kobj = kobject_create_and_add("bcache", fs_kobj)) ||
diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c
index a79cbd6..37470ee 100644
--- a/drivers/md/bitmap.c
+++ b/drivers/md/bitmap.c
@@ -564,6 +564,8 @@ static int bitmap_read_sb(struct bitmap *bitmap)
 	if (err)
 		return err;
 
+	err = -EINVAL;
+
 	sb = kmap_atomic(sb_page);
 
 	chunksize = le32_to_cpu(sb->chunksize);
diff --git a/drivers/md/dm-cache-policy-cleaner.c b/drivers/md/dm-cache-policy-cleaner.c
index b04d1f9..2eca908 100644
--- a/drivers/md/dm-cache-policy-cleaner.c
+++ b/drivers/md/dm-cache-policy-cleaner.c
@@ -434,7 +434,7 @@ static struct dm_cache_policy *wb_create(dm_cblock_t cache_size,
 static struct dm_cache_policy_type wb_policy_type = {
 	.name = "cleaner",
 	.version = {1, 0, 0},
-	.hint_size = 0,
+	.hint_size = 4,
 	.owner = THIS_MODULE,
 	.create = wb_create
 };
diff --git a/drivers/md/dm-exception-store.h b/drivers/md/dm-exception-store.h
index 0b25362..84e2770 100644
--- a/drivers/md/dm-exception-store.h
+++ b/drivers/md/dm-exception-store.h
@@ -70,7 +70,7 @@ struct dm_exception_store_type {
 	 * Update the metadata with this exception.
 	 */
 	void (*commit_exception) (struct dm_exception_store *store,
-				  struct dm_exception *e,
+				  struct dm_exception *e, int valid,
 				  void (*callback) (void *, int success),
 				  void *callback_context);
 
diff --git a/drivers/md/dm-flakey.c b/drivers/md/dm-flakey.c
index 7fcf21c..a9a47cd 100644
--- a/drivers/md/dm-flakey.c
+++ b/drivers/md/dm-flakey.c
@@ -286,10 +286,16 @@ static int flakey_map(struct dm_target *ti, struct bio *bio)
 		pb->bio_submitted = true;
 
 		/*
-		 * Map reads as normal.
+		 * Map reads as normal only if corrupt_bio_byte set.
 		 */
-		if (bio_data_dir(bio) == READ)
-			goto map_bio;
+		if (bio_data_dir(bio) == READ) {
+			/* If flags were specified, only corrupt those that match. */
+			if (fc->corrupt_bio_byte && (fc->corrupt_bio_rw == READ) &&
+			    all_corrupt_bio_flags_match(bio, fc))
+				goto map_bio;
+			else
+				return -EIO;
+		}
 
 		/*
 		 * Drop writes?
@@ -327,12 +333,13 @@ static int flakey_end_io(struct dm_target *ti, struct bio *bio, int error)
 
 	/*
 	 * Corrupt successful READs while in down state.
-	 * If flags were specified, only corrupt those that match.
 	 */
-	if (fc->corrupt_bio_byte && !error && pb->bio_submitted &&
-	    (bio_data_dir(bio) == READ) && (fc->corrupt_bio_rw == READ) &&
-	    all_corrupt_bio_flags_match(bio, fc))
-		corrupt_bio_data(bio, fc);
+	if (!error && pb->bio_submitted && (bio_data_dir(bio) == READ)) {
+		if (fc->corrupt_bio_byte)
+			corrupt_bio_data(bio, fc);
+		else
+			return -EIO;
+	}
 
 	return error;
 }
diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index 0ba21b0..eb7ddb2 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -1608,11 +1608,8 @@ static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,
 	/*
 	 * Only pass ioctls through if the device sizes match exactly.
 	 */
-	if (!bdev || ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT) {
-		int err = scsi_verify_blk_ioctl(NULL, cmd);
-		if (err)
-			r = err;
-	}
+	if (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)
+		r = scsi_verify_blk_ioctl(NULL, cmd);
 
 	if (r == -ENOTCONN && !fatal_signal_pending(current))
 		queue_work(kmultipathd, &m->process_queued_ios);
diff --git a/drivers/md/dm-raid.c b/drivers/md/dm-raid.c
index 84cddcc..4805c15 100644
--- a/drivers/md/dm-raid.c
+++ b/drivers/md/dm-raid.c
@@ -325,8 +325,7 @@ static int validate_region_size(struct raid_set *rs, unsigned long region_size)
 		 */
 		if (min_region_size > (1 << 13)) {
 			/* If not a power of 2, make it the next power of 2 */
-			if (min_region_size & (min_region_size - 1))
-				region_size = 1 << fls(region_size);
+			region_size = roundup_pow_of_two(min_region_size);
 			DMINFO("Choosing default region size of %lu sectors",
 			       region_size);
 		} else {
diff --git a/drivers/md/dm-snap-persistent.c b/drivers/md/dm-snap-persistent.c
index 2d2b1b7..8f6d3ea 100644
--- a/drivers/md/dm-snap-persistent.c
+++ b/drivers/md/dm-snap-persistent.c
@@ -646,7 +646,7 @@ static int persistent_prepare_exception(struct dm_exception_store *store,
 }
 
 static void persistent_commit_exception(struct dm_exception_store *store,
-					struct dm_exception *e,
+					struct dm_exception *e, int valid,
 					void (*callback) (void *, int success),
 					void *callback_context)
 {
@@ -655,6 +655,9 @@ static void persistent_commit_exception(struct dm_exception_store *store,
 	struct core_exception ce;
 	struct commit_callback *cb;
 
+	if (!valid)
+		ps->valid = 0;
+
 	ce.old_chunk = e->old_chunk;
 	ce.new_chunk = e->new_chunk;
 	write_exception(ps, ps->current_committed++, &ce);
diff --git a/drivers/md/dm-snap-transient.c b/drivers/md/dm-snap-transient.c
index 1ce9a25..31439d5 100644
--- a/drivers/md/dm-snap-transient.c
+++ b/drivers/md/dm-snap-transient.c
@@ -52,12 +52,12 @@ static int transient_prepare_exception(struct dm_exception_store *store,
 }
 
 static void transient_commit_exception(struct dm_exception_store *store,
-				       struct dm_exception *e,
+				       struct dm_exception *e, int valid,
 				       void (*callback) (void *, int success),
 				       void *callback_context)
 {
 	/* Just succeed */
-	callback(callback_context, 1);
+	callback(callback_context, valid);
 }
 
 static void transient_usage(struct dm_exception_store *store,
diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c
index d892a05..dbd0f00 100644
--- a/drivers/md/dm-snap.c
+++ b/drivers/md/dm-snap.c
@@ -1388,8 +1388,9 @@ static void __invalidate_snapshot(struct dm_snapshot *s, int err)
 	dm_table_event(s->ti->table);
 }
 
-static void pending_complete(struct dm_snap_pending_exception *pe, int success)
+static void pending_complete(void *context, int success)
 {
+	struct dm_snap_pending_exception *pe = context;
 	struct dm_exception *e;
 	struct dm_snapshot *s = pe->snap;
 	struct bio *origin_bios = NULL;
@@ -1459,24 +1460,13 @@ out:
 	free_pending_exception(pe);
 }
 
-static void commit_callback(void *context, int success)
-{
-	struct dm_snap_pending_exception *pe = context;
-
-	pending_complete(pe, success);
-}
-
 static void complete_exception(struct dm_snap_pending_exception *pe)
 {
 	struct dm_snapshot *s = pe->snap;
 
-	if (unlikely(pe->copy_error))
-		pending_complete(pe, 0);
-
-	else
-		/* Update the metadata if we are persistent */
-		s->store->type->commit_exception(s->store, &pe->e,
-						 commit_callback, pe);
+	/* Update the metadata if we are persistent */
+	s->store->type->commit_exception(s->store, &pe->e, !pe->copy_error,
+					 pending_complete, pe);
 }
 
 /*
diff --git a/drivers/md/dm-thin-metadata.c b/drivers/md/dm-thin-metadata.c
index 3b1503d..4bf9211 100644
--- a/drivers/md/dm-thin-metadata.c
+++ b/drivers/md/dm-thin-metadata.c
@@ -1191,6 +1191,12 @@ static int __reserve_metadata_snap(struct dm_pool_metadata *pmd)
 	dm_block_t held_root;
 
 	/*
+	 * We commit to ensure the btree roots which we increment in a
+	 * moment are up to date.
+	 */
+	__commit_transaction(pmd);
+
+	/*
 	 * Copy the superblock.
 	 */
 	dm_sm_inc_block(pmd->metadata_sm, THIN_SUPERBLOCK_LOCATION);
@@ -1281,8 +1287,8 @@ static int __release_metadata_snap(struct dm_pool_metadata *pmd)
 		return r;
 
 	disk_super = dm_block_data(copy);
-	dm_sm_dec_block(pmd->metadata_sm, le64_to_cpu(disk_super->data_mapping_root));
-	dm_sm_dec_block(pmd->metadata_sm, le64_to_cpu(disk_super->device_details_root));
+	dm_btree_del(&pmd->info, le64_to_cpu(disk_super->data_mapping_root));
+	dm_btree_del(&pmd->details_info, le64_to_cpu(disk_super->device_details_root));
 	dm_sm_dec_block(pmd->metadata_sm, held_root);
 
 	return dm_tm_unlock(pmd->tm, copy);
diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c
index 39996ca..295f74d 100644
--- a/drivers/md/dm-thin.c
+++ b/drivers/md/dm-thin.c
@@ -2109,7 +2109,7 @@ static int pool_ctr(struct dm_target *ti, unsigned argc, char **argv)
 						metadata_low_callback,
 						pool);
 	if (r)
-		goto out_free_pt;
+		goto out_flags_changed;
 
 	pt->callbacks.congested_fn = pool_is_congested;
 	dm_table_add_target_callbacks(ti->table, &pt->callbacks);
@@ -2281,7 +2281,7 @@ static void pool_postsuspend(struct dm_target *ti)
 	struct pool_c *pt = ti->private;
 	struct pool *pool = pt->pool;
 
-	cancel_delayed_work(&pool->waker);
+	cancel_delayed_work_sync(&pool->waker);
 	flush_workqueue(pool->wq);
 	(void) commit_or_fallback(pool);
 }
diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index a87f0c4..f69fed8 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -2333,10 +2333,16 @@ static void __dm_destroy(struct mapped_device *md, bool wait)
 	set_bit(DMF_FREEING, &md->flags);
 	spin_unlock(&_minor_lock);
 
+	/*
+	 * Take suspend_lock so that presuspend and postsuspend methods
+	 * do not race with internal suspend.
+	 */
+	mutex_lock(&md->suspend_lock);
 	if (!dm_suspended_md(md)) {
 		dm_table_presuspend_targets(map);
 		dm_table_postsuspend_targets(map);
 	}
+	mutex_unlock(&md->suspend_lock);
 
 	/*
 	 * Rare, but there may be I/O requests still going to complete,
diff --git a/drivers/md/md.c b/drivers/md/md.c
index aaf77b0..7c45286 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -5306,6 +5306,8 @@ EXPORT_SYMBOL_GPL(md_stop_writes);
 static void __md_stop(struct mddev *mddev)
 {
 	mddev->ready = 0;
+	/* Ensure ->event_work is done */
+	flush_workqueue(md_misc_wq);
 	mddev->pers->stop(mddev);
 	if (mddev->pers->sync_request && mddev->to_remove == NULL)
 		mddev->to_remove = &md_redundancy_group;
@@ -5628,9 +5630,9 @@ static int get_bitmap_file(struct mddev * mddev, void __user * arg)
 	int err = -ENOMEM;
 
 	if (md_allow_write(mddev))
-		file = kmalloc(sizeof(*file), GFP_NOIO);
+		file = kzalloc(sizeof(*file), GFP_NOIO);
 	else
-		file = kmalloc(sizeof(*file), GFP_KERNEL);
+		file = kzalloc(sizeof(*file), GFP_KERNEL);
 
 	if (!file)
 		goto out;
@@ -6221,7 +6223,7 @@ static int update_array_info(struct mddev *mddev, mdu_array_info_t *info)
 	    mddev->ctime         != info->ctime         ||
 	    mddev->level         != info->level         ||
 /*	    mddev->layout        != info->layout        || */
-	    !mddev->persistent	 != info->not_persistent||
+	    mddev->persistent	 != !info->not_persistent ||
 	    mddev->chunk_sectors != info->chunk_size >> 9 ||
 	    /* ignore bottom 8 bits of state, and allow SB_BITMAP_PRESENT to change */
 	    ((state^info->state) & 0xfffffe00)
diff --git a/drivers/md/persistent-data/dm-btree-internal.h b/drivers/md/persistent-data/dm-btree-internal.h
index bf2b80d..8731b6e 100644
--- a/drivers/md/persistent-data/dm-btree-internal.h
+++ b/drivers/md/persistent-data/dm-btree-internal.h
@@ -138,4 +138,10 @@ int lower_bound(struct btree_node *n, uint64_t key);
 
 extern struct dm_block_validator btree_node_validator;
 
+/*
+ * Value type for upper levels of multi-level btrees.
+ */
+extern void init_le64_type(struct dm_transaction_manager *tm,
+			   struct dm_btree_value_type *vt);
+
 #endif	/* DM_BTREE_INTERNAL_H */
diff --git a/drivers/md/persistent-data/dm-btree-remove.c b/drivers/md/persistent-data/dm-btree-remove.c
index b88757c..92cd09f 100644
--- a/drivers/md/persistent-data/dm-btree-remove.c
+++ b/drivers/md/persistent-data/dm-btree-remove.c
@@ -301,35 +301,40 @@ static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,
 {
 	int s;
 	uint32_t max_entries = le32_to_cpu(left->header.max_entries);
-	unsigned target = (nr_left + nr_center + nr_right) / 3;
-	BUG_ON(target > max_entries);
+	unsigned total = nr_left + nr_center + nr_right;
+	unsigned target_right = total / 3;
+	unsigned remainder = (target_right * 3) != total;
+	unsigned target_left = target_right + remainder;
+
+	BUG_ON(target_left > max_entries);
+	BUG_ON(target_right > max_entries);
 
 	if (nr_left < nr_right) {
-		s = nr_left - target;
+		s = nr_left - target_left;
 
 		if (s < 0 && nr_center < -s) {
 			/* not enough in central node */
-			shift(left, center, nr_center);
-			s = nr_center - target;
+			shift(left, center, -nr_center);
+			s += nr_center;
 			shift(left, right, s);
 			nr_right += s;
 		} else
 			shift(left, center, s);
 
-		shift(center, right, target - nr_right);
+		shift(center, right, target_right - nr_right);
 
 	} else {
-		s = target - nr_right;
+		s = target_right - nr_right;
 		if (s > 0 && nr_center < s) {
 			/* not enough in central node */
 			shift(center, right, nr_center);
-			s = target - nr_center;
+			s -= nr_center;
 			shift(left, right, s);
 			nr_left -= s;
 		} else
 			shift(center, right, s);
 
-		shift(left, center, nr_left - target);
+		shift(left, center, nr_left - target_left);
 	}
 
 	*key_ptr(parent, c->index) = center->keys[0];
@@ -544,14 +549,6 @@ static int remove_raw(struct shadow_spine *s, struct dm_btree_info *info,
 	return r;
 }
 
-static struct dm_btree_value_type le64_type = {
-	.context = NULL,
-	.size = sizeof(__le64),
-	.inc = NULL,
-	.dec = NULL,
-	.equal = NULL
-};
-
 int dm_btree_remove(struct dm_btree_info *info, dm_block_t root,
 		    uint64_t *keys, dm_block_t *new_root)
 {
@@ -559,12 +556,14 @@ int dm_btree_remove(struct dm_btree_info *info, dm_block_t root,
 	int index = 0, r = 0;
 	struct shadow_spine spine;
 	struct btree_node *n;
+	struct dm_btree_value_type le64_vt;
 
+	init_le64_type(info->tm, &le64_vt);
 	init_shadow_spine(&spine, info);
 	for (level = 0; level < info->levels; level++) {
 		r = remove_raw(&spine, info,
 			       (level == last_level ?
-				&info->value_type : &le64_type),
+				&info->value_type : &le64_vt),
 			       root, keys[level], (unsigned *)&index);
 		if (r < 0)
 			break;
diff --git a/drivers/md/persistent-data/dm-btree-spine.c b/drivers/md/persistent-data/dm-btree-spine.c
index 1b5e13e..0dee514 100644
--- a/drivers/md/persistent-data/dm-btree-spine.c
+++ b/drivers/md/persistent-data/dm-btree-spine.c
@@ -249,3 +249,40 @@ int shadow_root(struct shadow_spine *s)
 {
 	return s->root;
 }
+
+static void le64_inc(void *context, const void *value_le)
+{
+	struct dm_transaction_manager *tm = context;
+	__le64 v_le;
+
+	memcpy(&v_le, value_le, sizeof(v_le));
+	dm_tm_inc(tm, le64_to_cpu(v_le));
+}
+
+static void le64_dec(void *context, const void *value_le)
+{
+	struct dm_transaction_manager *tm = context;
+	__le64 v_le;
+
+	memcpy(&v_le, value_le, sizeof(v_le));
+	dm_tm_dec(tm, le64_to_cpu(v_le));
+}
+
+static int le64_equal(void *context, const void *value1_le, const void *value2_le)
+{
+	__le64 v1_le, v2_le;
+
+	memcpy(&v1_le, value1_le, sizeof(v1_le));
+	memcpy(&v2_le, value2_le, sizeof(v2_le));
+	return v1_le == v2_le;
+}
+
+void init_le64_type(struct dm_transaction_manager *tm,
+		    struct dm_btree_value_type *vt)
+{
+	vt->context = tm;
+	vt->size = sizeof(__le64);
+	vt->inc = le64_inc;
+	vt->dec = le64_dec;
+	vt->equal = le64_equal;
+}
diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c
index 0a7592e..b07fcda 100644
--- a/drivers/md/persistent-data/dm-btree.c
+++ b/drivers/md/persistent-data/dm-btree.c
@@ -235,12 +235,22 @@ static bool is_internal_level(struct dm_btree_info *info, struct frame *f)
 	return f->level < (info->levels - 1);
 }
 
+static void unlock_all_frames(struct del_stack *s)
+{
+	struct frame *f;
+
+	while (unprocessed_frames(s)) {
+		f = s->spine + s->top--;
+		dm_tm_unlock(s->tm, f->b);
+	}
+}
+
 int dm_btree_del(struct dm_btree_info *info, dm_block_t root)
 {
 	int r;
 	struct del_stack *s;
 
-	s = kmalloc(sizeof(*s), GFP_KERNEL);
+	s = kmalloc(sizeof(*s), GFP_NOIO);
 	if (!s)
 		return -ENOMEM;
 	s->tm = info->tm;
@@ -290,9 +300,13 @@ int dm_btree_del(struct dm_btree_info *info, dm_block_t root)
 			f->current_child = f->nr_children;
 		}
 	}
-
 out:
+	if (r) {
+		/* cleanup all frames of del_stack */
+		unlock_all_frames(s);
+	}
 	kfree(s);
+
 	return r;
 }
 EXPORT_SYMBOL_GPL(dm_btree_del);
@@ -455,8 +469,10 @@ static int btree_split_sibling(struct shadow_spine *s, dm_block_t root,
 
 	r = insert_at(sizeof(__le64), pn, parent_index + 1,
 		      le64_to_cpu(rn->keys[0]), &location);
-	if (r)
+	if (r) {
+		unlock_block(s->info, right);
 		return r;
+	}
 
 	if (key < le64_to_cpu(rn->keys[0])) {
 		unlock_block(s->info, right);
@@ -507,7 +523,7 @@ static int btree_split_beneath(struct shadow_spine *s, uint64_t key)
 
 	r = new_block(s->info, &right);
 	if (r < 0) {
-		/* FIXME: put left */
+		unlock_block(s->info, left);
 		return r;
 	}
 
@@ -651,12 +667,7 @@ static int insert(struct dm_btree_info *info, dm_block_t root,
 	struct btree_node *n;
 	struct dm_btree_value_type le64_type;
 
-	le64_type.context = NULL;
-	le64_type.size = sizeof(__le64);
-	le64_type.inc = NULL;
-	le64_type.dec = NULL;
-	le64_type.equal = NULL;
-
+	init_le64_type(info->tm, &le64_type);
 	init_shadow_spine(&spine, info);
 
 	for (level = 0; level < (info->levels - 1); level++) {
diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
index 86ac4a4..63d42ae 100644
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@ -327,7 +327,7 @@ static void raid1_end_read_request(struct bio *bio, int error)
 		spin_lock_irqsave(&conf->device_lock, flags);
 		if (r1_bio->mddev->degraded == conf->raid_disks ||
 		    (r1_bio->mddev->degraded == conf->raid_disks-1 &&
-		     !test_bit(Faulty, &conf->mirrors[mirror].rdev->flags)))
+		     test_bit(In_sync, &conf->mirrors[mirror].rdev->flags)))
 			uptodate = 1;
 		spin_unlock_irqrestore(&conf->device_lock, flags);
 	}
@@ -1382,6 +1382,7 @@ static void error(struct mddev *mddev, struct md_rdev *rdev)
 {
 	char b[BDEVNAME_SIZE];
 	struct r1conf *conf = mddev->private;
+	unsigned long flags;
 
 	/*
 	 * If it is not operational, then we have already marked it as dead
@@ -1401,14 +1402,13 @@ static void error(struct mddev *mddev, struct md_rdev *rdev)
 		return;
 	}
 	set_bit(Blocked, &rdev->flags);
+	spin_lock_irqsave(&conf->device_lock, flags);
 	if (test_and_clear_bit(In_sync, &rdev->flags)) {
-		unsigned long flags;
-		spin_lock_irqsave(&conf->device_lock, flags);
 		mddev->degraded++;
 		set_bit(Faulty, &rdev->flags);
-		spin_unlock_irqrestore(&conf->device_lock, flags);
 	} else
 		set_bit(Faulty, &rdev->flags);
+	spin_unlock_irqrestore(&conf->device_lock, flags);
 	/*
 	 * if recovery is running, make sure it aborts.
 	 */
@@ -1466,7 +1466,10 @@ static int raid1_spare_active(struct mddev *mddev)
 	 * Find all failed disks within the RAID1 configuration 
 	 * and mark them readable.
 	 * Called under mddev lock, so rcu protection not needed.
+	 * device_lock used to avoid races with raid1_end_read_request
+	 * which expects 'In_sync' flags and ->degraded to be consistent.
 	 */
+	spin_lock_irqsave(&conf->device_lock, flags);
 	for (i = 0; i < conf->raid_disks; i++) {
 		struct md_rdev *rdev = conf->mirrors[i].rdev;
 		struct md_rdev *repl = conf->mirrors[conf->raid_disks + i].rdev;
@@ -1496,7 +1499,6 @@ static int raid1_spare_active(struct mddev *mddev)
 			sysfs_notify_dirent_safe(rdev->sysfs_state);
 		}
 	}
-	spin_lock_irqsave(&conf->device_lock, flags);
 	mddev->degraded -= count;
 	spin_unlock_irqrestore(&conf->device_lock, flags);
 
@@ -2145,7 +2147,7 @@ static int narrow_write_error(struct r1bio *r1_bio, int i)
 		md_trim_bio(wbio, sector - r1_bio->sector, sectors);
 		wbio->bi_sector += rdev->data_offset;
 		wbio->bi_bdev = rdev->bdev;
-		if (submit_bio_wait(WRITE, wbio) == 0)
+		if (submit_bio_wait(WRITE, wbio) < 0)
 			/* failure! */
 			ok = rdev_set_badblocks(rdev, sector,
 						sectors, 0)
diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c
index a1ea2a7..f53f4f8 100644
--- a/drivers/md/raid10.c
+++ b/drivers/md/raid10.c
@@ -2597,7 +2597,7 @@ static int narrow_write_error(struct r10bio *r10_bio, int i)
 				   choose_data_offset(r10_bio, rdev) +
 				   (sector - r10_bio->sector));
 		wbio->bi_bdev = rdev->bdev;
-		if (submit_bio_wait(WRITE, wbio) == 0)
+		if (submit_bio_wait(WRITE, wbio) < 0)
 			/* Failure! */
 			ok = rdev_set_badblocks(rdev, sector,
 						sectors, 0)
@@ -3578,6 +3578,7 @@ static struct r10conf *setup_conf(struct mddev *mddev)
 			/* far_copies must be 1 */
 			conf->prev.stride = conf->dev_sectors;
 	}
+	conf->reshape_safe = conf->reshape_progress;
 	spin_lock_init(&conf->device_lock);
 	INIT_LIST_HEAD(&conf->retry_list);
 
@@ -3785,7 +3786,6 @@ static int run(struct mddev *mddev)
 		}
 		conf->offset_diff = min_offset_diff;
 
-		conf->reshape_safe = conf->reshape_progress;
 		clear_bit(MD_RECOVERY_SYNC, &mddev->recovery);
 		clear_bit(MD_RECOVERY_CHECK, &mddev->recovery);
 		set_bit(MD_RECOVERY_RESHAPE, &mddev->recovery);
@@ -4130,6 +4130,7 @@ static int raid10_start_reshape(struct mddev *mddev)
 		conf->reshape_progress = size;
 	} else
 		conf->reshape_progress = 0;
+	conf->reshape_safe = conf->reshape_progress;
 	spin_unlock_irq(&conf->device_lock);
 
 	if (mddev->delta_disks && mddev->bitmap) {
@@ -4196,6 +4197,7 @@ abort:
 		rdev->new_data_offset = rdev->data_offset;
 	smp_wmb();
 	conf->reshape_progress = MaxSector;
+	conf->reshape_safe = MaxSector;
 	mddev->reshape_position = MaxSector;
 	spin_unlock_irq(&conf->device_lock);
 	return ret;
@@ -4543,6 +4545,7 @@ static void end_reshape(struct r10conf *conf)
 	md_finish_reshape(conf->mddev);
 	smp_wmb();
 	conf->reshape_progress = MaxSector;
+	conf->reshape_safe = MaxSector;
 	spin_unlock_irq(&conf->device_lock);
 
 	/* read-ahead size must cover two whole stripes, which is
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 1b6986c..9ee3c46 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -1701,7 +1701,8 @@ static int resize_stripes(struct r5conf *conf, int newsize)
 
 	conf->slab_cache = sc;
 	conf->active_name = 1-conf->active_name;
-	conf->pool_size = newsize;
+	if (!err)
+		conf->pool_size = newsize;
 	return err;
 }
 
@@ -5657,8 +5658,8 @@ static int run(struct mddev *mddev)
 		}
 
 		if (discard_supported &&
-		   mddev->queue->limits.max_discard_sectors >= stripe &&
-		   mddev->queue->limits.discard_granularity >= stripe)
+		    mddev->queue->limits.max_discard_sectors >= (stripe >> 9) &&
+		    mddev->queue->limits.discard_granularity >= stripe)
 			queue_flag_set_unlocked(QUEUE_FLAG_DISCARD,
 						mddev->queue);
 		else
diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c
index 1f925e8..46a9842 100644
--- a/drivers/media/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb-core/dvb_frontend.c
@@ -2195,9 +2195,9 @@ static int dvb_frontend_ioctl_legacy(struct file *file,
 		dev_dbg(fe->dvb->device, "%s: current delivery system on cache: %d, V3 type: %d\n",
 				 __func__, c->delivery_system, fe->ops.info.type);
 
-		/* Force the CAN_INVERSION_AUTO bit on. If the frontend doesn't
-		 * do it, it is done for it. */
-		info->caps |= FE_CAN_INVERSION_AUTO;
+		/* Set CAN_INVERSION_AUTO bit on in other than oneshot mode */
+		if (!(fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT))
+			info->caps |= FE_CAN_INVERSION_AUTO;
 		err = 0;
 		break;
 	}
diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c
index fb504f1..5930aee 100644
--- a/drivers/media/dvb-frontends/af9013.c
+++ b/drivers/media/dvb-frontends/af9013.c
@@ -606,6 +606,10 @@ static int af9013_set_frontend(struct dvb_frontend *fe)
 			}
 		}
 
+		/* Return an error if can't find bandwidth or the right clock */
+		if (i == ARRAY_SIZE(coeff_lut))
+			return -EINVAL;
+
 		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
 			sizeof(coeff_lut[i].val));
 	}
diff --git a/drivers/media/dvb-frontends/cx24116.c b/drivers/media/dvb-frontends/cx24116.c
index 2916d7c..7bc68b3 100644
--- a/drivers/media/dvb-frontends/cx24116.c
+++ b/drivers/media/dvb-frontends/cx24116.c
@@ -963,6 +963,10 @@ static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,
 	struct cx24116_state *state = fe->demodulator_priv;
 	int i, ret;
 
+	/* Validate length */
+	if (d->msg_len > sizeof(d->msg))
+                return -EINVAL;
+
 	/* Dump DiSEqC message */
 	if (debug) {
 		printk(KERN_INFO "cx24116: %s(", __func__);
@@ -974,10 +978,6 @@ static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,
 		printk(") toneburst=%d\n", toneburst);
 	}
 
-	/* Validate length */
-	if (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))
-		return -EINVAL;
-
 	/* DiSEqC message */
 	for (i = 0; i < d->msg_len; i++)
 		state->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];
diff --git a/drivers/media/dvb-frontends/s5h1420.c b/drivers/media/dvb-frontends/s5h1420.c
index 93eeaf7..0b4f8fe 100644
--- a/drivers/media/dvb-frontends/s5h1420.c
+++ b/drivers/media/dvb-frontends/s5h1420.c
@@ -180,7 +180,7 @@ static int s5h1420_send_master_cmd (struct dvb_frontend* fe,
 	int result = 0;
 
 	dprintk("enter %s\n", __func__);
-	if (cmd->msg_len > 8)
+	if (cmd->msg_len > sizeof(cmd->msg))
 		return -EINVAL;
 
 	/* setup for DISEQC */
diff --git a/drivers/media/dvb-frontends/stb6100.c b/drivers/media/dvb-frontends/stb6100.c
index cea175d..4ef8a5c 100644
--- a/drivers/media/dvb-frontends/stb6100.c
+++ b/drivers/media/dvb-frontends/stb6100.c
@@ -193,7 +193,7 @@ static int stb6100_write_reg_range(struct stb6100_state *state, u8 buf[], int st
 		.len	= len + 1
 	};
 
-	if (1 + len > sizeof(buf)) {
+	if (1 + len > sizeof(cmdbuf)) {
 		printk(KERN_WARNING
 		       "%s: i2c wr: len=%d is too big!\n",
 		       KBUILD_MODNAME, len);
diff --git a/drivers/media/dvb-frontends/tda1004x.c b/drivers/media/dvb-frontends/tda1004x.c
index a2631be..08e0f0d 100644
--- a/drivers/media/dvb-frontends/tda1004x.c
+++ b/drivers/media/dvb-frontends/tda1004x.c
@@ -903,9 +903,18 @@ static int tda1004x_get_fe(struct dvb_frontend *fe)
 {
 	struct dtv_frontend_properties *fe_params = &fe->dtv_property_cache;
 	struct tda1004x_state* state = fe->demodulator_priv;
+	int status;
 
 	dprintk("%s\n", __func__);
 
+	status = tda1004x_read_byte(state, TDA1004X_STATUS_CD);
+	if (status == -1)
+		return -EIO;
+
+	/* Only update the properties cache if device is locked */
+	if (!(status & 8))
+		return 0;
+
 	// inversion status
 	fe_params->inversion = INVERSION_OFF;
 	if (tda1004x_read_byte(state, TDA1004X_CONFC1) & 0x20)
diff --git a/drivers/media/pci/bt8xx/bttv-driver.c b/drivers/media/pci/bt8xx/bttv-driver.c
index e2633d9..aa4519e 100644
--- a/drivers/media/pci/bt8xx/bttv-driver.c
+++ b/drivers/media/pci/bt8xx/bttv-driver.c
@@ -2376,6 +2376,19 @@ static int bttv_g_fmt_vid_overlay(struct file *file, void *priv,
 	return 0;
 }
 
+static void bttv_get_width_mask_vid_cap(const struct bttv_format *fmt,
+					unsigned int *width_mask,
+					unsigned int *width_bias)
+{
+	if (fmt->flags & FORMAT_FLAGS_PLANAR) {
+		*width_mask = ~15; /* width must be a multiple of 16 pixels */
+		*width_bias = 8;   /* nearest */
+	} else {
+		*width_mask = ~3; /* width must be a multiple of 4 pixels */
+		*width_bias = 2;  /* nearest */
+	}
+}
+
 static int bttv_try_fmt_vid_cap(struct file *file, void *priv,
 						struct v4l2_format *f)
 {
@@ -2385,6 +2398,7 @@ static int bttv_try_fmt_vid_cap(struct file *file, void *priv,
 	enum v4l2_field field;
 	__s32 width, height;
 	__s32 height2;
+	unsigned int width_mask, width_bias;
 	int rc;
 
 	fmt = format_by_fourcc(f->fmt.pix.pixelformat);
@@ -2417,9 +2431,9 @@ static int bttv_try_fmt_vid_cap(struct file *file, void *priv,
 	width = f->fmt.pix.width;
 	height = f->fmt.pix.height;
 
+	bttv_get_width_mask_vid_cap(fmt, &width_mask, &width_bias);
 	rc = limit_scaled_size_lock(fh, &width, &height, field,
-			       /* width_mask: 4 pixels */ ~3,
-			       /* width_bias: nearest */ 2,
+			       width_mask, width_bias,
 			       /* adjust_size */ 1,
 			       /* adjust_crop */ 0);
 	if (0 != rc)
@@ -2452,6 +2466,7 @@ static int bttv_s_fmt_vid_cap(struct file *file, void *priv,
 	struct bttv_fh *fh = priv;
 	struct bttv *btv = fh->btv;
 	__s32 width, height;
+	unsigned int width_mask, width_bias;
 	enum v4l2_field field;
 
 	retval = bttv_switch_type(fh, f->type);
@@ -2466,9 +2481,10 @@ static int bttv_s_fmt_vid_cap(struct file *file, void *priv,
 	height = f->fmt.pix.height;
 	field = f->fmt.pix.field;
 
+	fmt = format_by_fourcc(f->fmt.pix.pixelformat);
+	bttv_get_width_mask_vid_cap(fmt, &width_mask, &width_bias);
 	retval = limit_scaled_size_lock(fh, &width, &height, f->fmt.pix.field,
-			       /* width_mask: 4 pixels */ ~3,
-			       /* width_bias: nearest */ 2,
+			       width_mask, width_bias,
 			       /* adjust_size */ 1,
 			       /* adjust_crop */ 1);
 	if (0 != retval)
@@ -2476,8 +2492,6 @@ static int bttv_s_fmt_vid_cap(struct file *file, void *priv,
 
 	f->fmt.pix.field = field;
 
-	fmt = format_by_fourcc(f->fmt.pix.pixelformat);
-
 	/* update our state informations */
 	fh->fmt              = fmt;
 	fh->cap.field        = f->fmt.pix.field;
diff --git a/drivers/media/pci/saa7134/saa7134-alsa.c b/drivers/media/pci/saa7134/saa7134-alsa.c
index dbcdfbf8..11b0ef3 100644
--- a/drivers/media/pci/saa7134/saa7134-alsa.c
+++ b/drivers/media/pci/saa7134/saa7134-alsa.c
@@ -1145,6 +1145,8 @@ static int alsa_device_init(struct saa7134_dev *dev)
 
 static int alsa_device_exit(struct saa7134_dev *dev)
 {
+	if (!snd_saa7134_cards[dev->nr])
+		return 1;
 
 	snd_card_free(snd_saa7134_cards[dev->nr]);
 	snd_saa7134_cards[dev->nr] = NULL;
@@ -1194,7 +1196,8 @@ static void saa7134_alsa_exit(void)
 	int idx;
 
 	for (idx = 0; idx < SNDRV_CARDS; idx++) {
-		snd_card_free(snd_saa7134_cards[idx]);
+		if (snd_saa7134_cards[idx])
+			snd_card_free(snd_saa7134_cards[idx]);
 	}
 
 	saa7134_dmasound_init = NULL;
diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c
index 961d7ff..eb92027 100644
--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c
@@ -1000,6 +1000,11 @@ static int match_child(struct device *dev, void *data)
 	return !strcmp(dev_name(dev), (char *)data);
 }
 
+static void s5p_mfc_memdev_release(struct device *dev)
+{
+	dma_release_declared_memory(dev);
+}
+
 static void *mfc_get_drv_data(struct platform_device *pdev);
 
 static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)
@@ -1012,6 +1017,9 @@ static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)
 		mfc_err("Not enough memory\n");
 		return -ENOMEM;
 	}
+
+	dev_set_name(dev->mem_dev_l, "%s", "s5p-mfc-l");
+	dev->mem_dev_l->release = s5p_mfc_memdev_release;
 	device_initialize(dev->mem_dev_l);
 	of_property_read_u32_array(dev->plat_dev->dev.of_node,
 			"samsung,mfc-l", mem_info, 2);
@@ -1029,6 +1037,9 @@ static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)
 		mfc_err("Not enough memory\n");
 		return -ENOMEM;
 	}
+
+	dev_set_name(dev->mem_dev_r, "%s", "s5p-mfc-r");
+	dev->mem_dev_r->release = s5p_mfc_memdev_release;
 	device_initialize(dev->mem_dev_r);
 	of_property_read_u32_array(dev->plat_dev->dev.of_node,
 			"samsung,mfc-r", mem_info, 2);
diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc_common.h b/drivers/media/platform/s5p-mfc/s5p_mfc_common.h
index f804c1f..d3b54f7 100644
--- a/drivers/media/platform/s5p-mfc/s5p_mfc_common.h
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc_common.h
@@ -29,7 +29,7 @@
 
 /* Offset base used to differentiate between CAPTURE and OUTPUT
 *  while mmaping */
-#define DST_QUEUE_OFF_BASE      (TASK_SIZE / 2)
+#define DST_QUEUE_OFF_BASE	(1 << 30)
 
 #define MFC_BANK1_ALLOC_CTX	0
 #define MFC_BANK2_ALLOC_CTX	1
diff --git a/drivers/media/rc/rc-main.c b/drivers/media/rc/rc-main.c
index 1cf382a..cf7bbb6 100644
--- a/drivers/media/rc/rc-main.c
+++ b/drivers/media/rc/rc-main.c
@@ -943,9 +943,6 @@ static int rc_dev_uevent(struct device *device, struct kobj_uevent_env *env)
 {
 	struct rc_dev *dev = to_rc_dev(device);
 
-	if (!dev || !dev->input_dev)
-		return -ENODEV;
-
 	if (dev->rc_map.name)
 		ADD_HOTPLUG_VAR("NAME=%s", dev->rc_map.name);
 	if (dev->driver_name)
diff --git a/drivers/media/usb/gspca/ov534.c b/drivers/media/usb/gspca/ov534.c
index 2e28c81..a5bee0d 100644
--- a/drivers/media/usb/gspca/ov534.c
+++ b/drivers/media/usb/gspca/ov534.c
@@ -1490,8 +1490,13 @@ static void sd_set_streamparm(struct gspca_dev *gspca_dev,
 	struct v4l2_fract *tpf = &cp->timeperframe;
 	struct sd *sd = (struct sd *) gspca_dev;
 
-	/* Set requested framerate */
-	sd->frame_rate = tpf->denominator / tpf->numerator;
+	if (tpf->numerator == 0 || tpf->denominator == 0)
+		/* Set default framerate */
+		sd->frame_rate = 30;
+	else
+		/* Set requested framerate */
+		sd->frame_rate = tpf->denominator / tpf->numerator;
+
 	if (gspca_dev->streaming)
 		set_frame_rate(gspca_dev);
 
diff --git a/drivers/media/usb/gspca/topro.c b/drivers/media/usb/gspca/topro.c
index 4cb511c..22ea6ae 100644
--- a/drivers/media/usb/gspca/topro.c
+++ b/drivers/media/usb/gspca/topro.c
@@ -4791,7 +4791,11 @@ static void sd_set_streamparm(struct gspca_dev *gspca_dev,
 	struct v4l2_fract *tpf = &cp->timeperframe;
 	int fr, i;
 
-	sd->framerate = tpf->denominator / tpf->numerator;
+	if (tpf->numerator == 0 || tpf->denominator == 0)
+		sd->framerate = 30;
+	else
+		sd->framerate = tpf->denominator / tpf->numerator;
+
 	if (gspca_dev->streaming)
 		setframerate(gspca_dev, v4l2_ctrl_g_ctrl(gspca_dev->exposure));
 
diff --git a/drivers/media/usb/pwc/pwc-if.c b/drivers/media/usb/pwc/pwc-if.c
index 77bbf78..db1e8ee 100644
--- a/drivers/media/usb/pwc/pwc-if.c
+++ b/drivers/media/usb/pwc/pwc-if.c
@@ -91,6 +91,7 @@ static const struct usb_device_id pwc_device_table [] = {
 	{ USB_DEVICE(0x0471, 0x0312) },
 	{ USB_DEVICE(0x0471, 0x0313) }, /* the 'new' 720K */
 	{ USB_DEVICE(0x0471, 0x0329) }, /* Philips SPC 900NC PC Camera */
+	{ USB_DEVICE(0x0471, 0x032C) }, /* Philips SPC 880NC PC Camera */
 	{ USB_DEVICE(0x069A, 0x0001) }, /* Askey */
 	{ USB_DEVICE(0x046D, 0x08B0) }, /* Logitech QuickCam Pro 3000 */
 	{ USB_DEVICE(0x046D, 0x08B1) }, /* Logitech QuickCam Notebook Pro */
@@ -799,6 +800,11 @@ static int usb_pwc_probe(struct usb_interface *intf, const struct usb_device_id
 			name = "Philips SPC 900NC webcam";
 			type_id = 740;
 			break;
+		case 0x032C:
+			PWC_INFO("Philips SPC 880NC USB webcam detected.\n");
+			name = "Philips SPC 880NC webcam";
+			type_id = 740;
+			break;
 		default:
 			return -ENODEV;
 			break;
diff --git a/drivers/media/usb/stk1160/stk1160-v4l.c b/drivers/media/usb/stk1160/stk1160-v4l.c
index a59153d2..518a529 100644
--- a/drivers/media/usb/stk1160/stk1160-v4l.c
+++ b/drivers/media/usb/stk1160/stk1160-v4l.c
@@ -245,6 +245,11 @@ static int stk1160_stop_streaming(struct stk1160 *dev)
 	if (mutex_lock_interruptible(&dev->v4l_lock))
 		return -ERESTARTSYS;
 
+	/*
+	 * Once URBs are cancelled, the URB complete handler
+	 * won't be running. This is required to safely release the
+	 * current buffer (dev->isoc_ctl.buf).
+	 */
 	stk1160_cancel_isoc(dev);
 
 	/*
@@ -665,8 +670,16 @@ void stk1160_clear_queue(struct stk1160 *dev)
 		stk1160_info("buffer [%p/%d] aborted\n",
 				buf, buf->vb.v4l2_buf.index);
 	}
-	/* It's important to clear current buffer */
-	dev->isoc_ctl.buf = NULL;
+
+	/* It's important to release the current buffer */
+	if (dev->isoc_ctl.buf) {
+		buf = dev->isoc_ctl.buf;
+		dev->isoc_ctl.buf = NULL;
+
+		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);
+		stk1160_info("buffer [%p/%d] aborted\n",
+				buf, buf->vb.v4l2_buf.index);
+	}
 	spin_unlock_irqrestore(&dev->buf_lock, flags);
 }
 
diff --git a/drivers/media/usb/usbvision/usbvision-video.c b/drivers/media/usb/usbvision/usbvision-video.c
index d34c2af..bcfefe6 100644
--- a/drivers/media/usb/usbvision/usbvision-video.c
+++ b/drivers/media/usb/usbvision/usbvision-video.c
@@ -1459,6 +1459,7 @@ static void usbvision_release(struct usb_usbvision *usbvision)
 
 	usbvision_remove_sysfs(usbvision->vdev);
 	usbvision_unregister_video(usbvision);
+	kfree(usbvision->alt_max_pkt_size);
 
 	usb_free_urb(usbvision->ctrl_urb);
 
@@ -1520,7 +1521,7 @@ static int usbvision_probe(struct usb_interface *intf,
 	const struct usb_host_interface *interface;
 	struct usb_usbvision *usbvision = NULL;
 	const struct usb_endpoint_descriptor *endpoint;
-	int model, i;
+	int model, i, ret;
 
 	PDEBUG(DBG_PROBE, "VID=%#04x, PID=%#04x, ifnum=%u",
 				dev->descriptor.idVendor,
@@ -1529,33 +1530,51 @@ static int usbvision_probe(struct usb_interface *intf,
 	model = devid->driver_info;
 	if (model < 0 || model >= usbvision_device_data_size) {
 		PDEBUG(DBG_PROBE, "model out of bounds %d", model);
-		return -ENODEV;
+		ret = -ENODEV;
+		goto err_usb;
 	}
 	printk(KERN_INFO "%s: %s found\n", __func__,
 				usbvision_device_data[model].model_string);
 
 	if (usbvision_device_data[model].interface >= 0)
 		interface = &dev->actconfig->interface[usbvision_device_data[model].interface]->altsetting[0];
-	else
+	else if (ifnum < dev->actconfig->desc.bNumInterfaces)
 		interface = &dev->actconfig->interface[ifnum]->altsetting[0];
+	else {
+		dev_err(&intf->dev, "interface %d is invalid, max is %d\n",
+		    ifnum, dev->actconfig->desc.bNumInterfaces - 1);
+		ret = -ENODEV;
+		goto err_usb;
+	}
+
+	if (interface->desc.bNumEndpoints < 2) {
+		dev_err(&intf->dev, "interface %d has %d endpoints, but must"
+		    " have minimum 2\n", ifnum, interface->desc.bNumEndpoints);
+		ret = -ENODEV;
+		goto err_usb;
+	}
 	endpoint = &interface->endpoint[1].desc;
+
 	if (!usb_endpoint_xfer_isoc(endpoint)) {
 		dev_err(&intf->dev, "%s: interface %d. has non-ISO endpoint!\n",
 		    __func__, ifnum);
 		dev_err(&intf->dev, "%s: Endpoint attributes %d",
 		    __func__, endpoint->bmAttributes);
-		return -ENODEV;
+		ret = -ENODEV;
+		goto err_usb;
 	}
 	if (usb_endpoint_dir_out(endpoint)) {
 		dev_err(&intf->dev, "%s: interface %d. has ISO OUT endpoint!\n",
 		    __func__, ifnum);
-		return -ENODEV;
+		ret = -ENODEV;
+		goto err_usb;
 	}
 
 	usbvision = usbvision_alloc(dev, intf);
 	if (usbvision == NULL) {
 		dev_err(&intf->dev, "%s: couldn't allocate USBVision struct\n", __func__);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto err_usb;
 	}
 
 	if (dev->descriptor.bNumConfigurations > 1)
@@ -1574,7 +1593,8 @@ static int usbvision_probe(struct usb_interface *intf,
 	usbvision->alt_max_pkt_size = kmalloc(32 * usbvision->num_alt, GFP_KERNEL);
 	if (usbvision->alt_max_pkt_size == NULL) {
 		dev_err(&intf->dev, "usbvision: out of memory!\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto err_pkt;
 	}
 
 	for (i = 0; i < usbvision->num_alt; i++) {
@@ -1609,6 +1629,12 @@ static int usbvision_probe(struct usb_interface *intf,
 
 	PDEBUG(DBG_PROBE, "success");
 	return 0;
+
+err_pkt:
+	usbvision_release(usbvision);
+err_usb:
+	usb_put_dev(dev);
+	return ret;
 }
 
 
diff --git a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
index e2b0a09..07d6ce4 100644
--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c
@@ -264,7 +264,7 @@ static int put_v4l2_create32(struct v4l2_create_buffers *kp, struct v4l2_create_
 
 struct v4l2_standard32 {
 	__u32		     index;
-	__u32		     id[2]; /* __u64 would get the alignment wrong */
+	compat_u64	     id;
 	__u8		     name[24];
 	struct v4l2_fract    frameperiod; /* Frames, not fields */
 	__u32		     framelines;
@@ -284,7 +284,7 @@ static int put_v4l2_standard32(struct v4l2_standard *kp, struct v4l2_standard32
 {
 	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_standard32)) ||
 		put_user(kp->index, &up->index) ||
-		copy_to_user(up->id, &kp->id, sizeof(__u64)) ||
+		put_user(kp->id, &up->id) ||
 		copy_to_user(up->name, kp->name, 24) ||
 		copy_to_user(&up->frameperiod, &kp->frameperiod, sizeof(kp->frameperiod)) ||
 		put_user(kp->framelines, &up->framelines) ||
@@ -392,7 +392,8 @@ static int get_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user
 		get_user(kp->index, &up->index) ||
 		get_user(kp->type, &up->type) ||
 		get_user(kp->flags, &up->flags) ||
-		get_user(kp->memory, &up->memory))
+		get_user(kp->memory, &up->memory) ||
+		get_user(kp->length, &up->length))
 			return -EFAULT;
 
 	if (V4L2_TYPE_IS_OUTPUT(kp->type))
@@ -404,9 +405,6 @@ static int get_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user
 			return -EFAULT;
 
 	if (V4L2_TYPE_IS_MULTIPLANAR(kp->type)) {
-		if (get_user(kp->length, &up->length))
-			return -EFAULT;
-
 		num_planes = kp->length;
 		if (num_planes == 0) {
 			kp->m.planes = NULL;
@@ -439,16 +437,14 @@ static int get_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user
 	} else {
 		switch (kp->memory) {
 		case V4L2_MEMORY_MMAP:
-			if (get_user(kp->length, &up->length) ||
-				get_user(kp->m.offset, &up->m.offset))
+			if (get_user(kp->m.offset, &up->m.offset))
 				return -EFAULT;
 			break;
 		case V4L2_MEMORY_USERPTR:
 			{
 			compat_long_t tmp;
 
-			if (get_user(kp->length, &up->length) ||
-			    get_user(tmp, &up->m.userptr))
+			if (get_user(tmp, &up->m.userptr))
 				return -EFAULT;
 
 			kp->m.userptr = (unsigned long)compat_ptr(tmp);
@@ -490,7 +486,8 @@ static int put_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user
 		copy_to_user(&up->timecode, &kp->timecode, sizeof(struct v4l2_timecode)) ||
 		put_user(kp->sequence, &up->sequence) ||
 		put_user(kp->reserved2, &up->reserved2) ||
-		put_user(kp->reserved, &up->reserved))
+		put_user(kp->reserved, &up->reserved) ||
+		put_user(kp->length, &up->length))
 			return -EFAULT;
 
 	if (V4L2_TYPE_IS_MULTIPLANAR(kp->type)) {
@@ -513,13 +510,11 @@ static int put_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user
 	} else {
 		switch (kp->memory) {
 		case V4L2_MEMORY_MMAP:
-			if (put_user(kp->length, &up->length) ||
-				put_user(kp->m.offset, &up->m.offset))
+			if (put_user(kp->m.offset, &up->m.offset))
 				return -EFAULT;
 			break;
 		case V4L2_MEMORY_USERPTR:
-			if (put_user(kp->length, &up->length) ||
-				put_user(kp->m.userptr, &up->m.userptr))
+			if (put_user(kp->m.userptr, &up->m.userptr))
 				return -EFAULT;
 			break;
 		case V4L2_MEMORY_OVERLAY:
@@ -576,10 +571,10 @@ struct v4l2_input32 {
 	__u32	     type;		/*  Type of input */
 	__u32	     audioset;		/*  Associated audios (bitfield) */
 	__u32        tuner;             /*  Associated tuner */
-	v4l2_std_id  std;
+	compat_u64   std;
 	__u32	     status;
 	__u32	     reserved[4];
-} __attribute__ ((packed));
+};
 
 /* The 64-bit v4l2_input struct has extra padding at the end of the struct.
    Otherwise it is identical to the 32-bit version. */
@@ -719,6 +714,7 @@ static int put_v4l2_ext_controls32(struct v4l2_ext_controls *kp, struct v4l2_ext
 struct v4l2_event32 {
 	__u32				type;
 	union {
+		compat_s64		value64;
 		__u8			data[64];
 	} u;
 	__u32				pending;
diff --git a/drivers/media/v4l2-core/videobuf2-dma-contig.c b/drivers/media/v4l2-core/videobuf2-dma-contig.c
index fd56f25..297fbc5 100644
--- a/drivers/media/v4l2-core/videobuf2-dma-contig.c
+++ b/drivers/media/v4l2-core/videobuf2-dma-contig.c
@@ -117,7 +117,8 @@ static void vb2_dc_prepare(void *buf_priv)
 	if (!sgt || buf->db_attach)
 		return;
 
-	dma_sync_sg_for_device(buf->dev, sgt->sgl, sgt->nents, buf->dma_dir);
+	dma_sync_sg_for_device(buf->dev, sgt->sgl, sgt->orig_nents,
+			       buf->dma_dir);
 }
 
 static void vb2_dc_finish(void *buf_priv)
@@ -129,7 +130,7 @@ static void vb2_dc_finish(void *buf_priv)
 	if (!sgt || buf->db_attach)
 		return;
 
-	dma_sync_sg_for_cpu(buf->dev, sgt->sgl, sgt->nents, buf->dma_dir);
+	dma_sync_sg_for_cpu(buf->dev, sgt->sgl, sgt->orig_nents, buf->dma_dir);
 }
 
 /*********************************************/
diff --git a/drivers/memstick/core/mspro_block.c b/drivers/memstick/core/mspro_block.c
index f4176ca..cdd61ab 100644
--- a/drivers/memstick/core/mspro_block.c
+++ b/drivers/memstick/core/mspro_block.c
@@ -758,7 +758,7 @@ static int mspro_block_complete_req(struct memstick_dev *card, int error)
 
 		if (error || (card->current_mrq.tpc == MSPRO_CMD_STOP)) {
 			if (msb->data_dir == READ) {
-				for (cnt = 0; cnt < msb->current_seg; cnt++)
+				for (cnt = 0; cnt < msb->current_seg; cnt++) {
 					t_len += msb->req_sg[cnt].length
 						 / msb->page_size;
 
@@ -766,6 +766,7 @@ static int mspro_block_complete_req(struct memstick_dev *card, int error)
 						t_len += msb->current_page - 1;
 
 					t_len *= msb->page_size;
+				}
 			}
 		} else
 			t_len = blk_rq_bytes(msb->block_req);
diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c
index e59ac4c..c7576a5 100644
--- a/drivers/mfd/omap-usb-tll.c
+++ b/drivers/mfd/omap-usb-tll.c
@@ -269,6 +269,8 @@ static int usbtll_omap_probe(struct platform_device *pdev)
 
 		if (IS_ERR(tll->ch_clk[i]))
 			dev_dbg(dev, "can't get clock : %s\n", clkname);
+		else
+			clk_prepare(tll->ch_clk[i]);
 	}
 
 	pm_runtime_put_sync(dev);
@@ -301,9 +303,12 @@ static int usbtll_omap_remove(struct platform_device *pdev)
 	tll_dev = NULL;
 	spin_unlock(&tll_lock);
 
-	for (i = 0; i < tll->nch; i++)
-		if (!IS_ERR(tll->ch_clk[i]))
+	for (i = 0; i < tll->nch; i++) {
+		if (!IS_ERR(tll->ch_clk[i])) {
+			clk_unprepare(tll->ch_clk[i]);
 			clk_put(tll->ch_clk[i]);
+		}
+	}
 
 	pm_runtime_disable(&pdev->dev);
 	return 0;
diff --git a/drivers/mfd/sm501.c b/drivers/mfd/sm501.c
index 9816c23..c04e08d 100644
--- a/drivers/mfd/sm501.c
+++ b/drivers/mfd/sm501.c
@@ -1232,7 +1232,7 @@ static ssize_t sm501_dbg_regs(struct device *dev,
 }
 
 
-static DEVICE_ATTR(dbg_regs, 0666, sm501_dbg_regs, NULL);
+static DEVICE_ATTR(dbg_regs, 0444, sm501_dbg_regs, NULL);
 
 /* sm501_init_reg
  *
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index c002d86..7a68184 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -451,7 +451,7 @@ config ARM_CHARLCD
 	  still useful.
 
 config BMP085
-	bool
+	tristate
 	depends on SYSFS
 
 config BMP085_I2C
diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 8f99e8e..beb7422 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -216,7 +216,7 @@ static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 			 */
 			value = swab16(value);
 
-			if (dpot->uid == DPOT_UID(AD5271_ID))
+			if (dpot->uid == DPOT_UID(AD5274_ID))
 				value = value >> 2;
 		return value;
 	default:
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 7ad6682..a2863b7 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -59,8 +59,7 @@ MODULE_ALIAS("mmc:block");
 #define INAND_CMD38_ARG_SECTRIM2 0x88
 #define MMC_BLK_TIMEOUT_MS  (10 * 60 * 1000)        /* 10 minute timeout */
 
-#define mmc_req_rel_wr(req)	(((req->cmd_flags & REQ_FUA) || \
-				  (req->cmd_flags & REQ_META)) && \
+#define mmc_req_rel_wr(req)	((req->cmd_flags & REQ_FUA) && \
 				  (rq_data_dir(req) == WRITE))
 #define PACKED_CMD_VER	0x01
 #define PACKED_CMD_WR	0x02
@@ -202,6 +201,8 @@ static ssize_t power_ro_lock_show(struct device *dev,
 
 	ret = snprintf(buf, PAGE_SIZE, "%d\n", locked);
 
+	mmc_blk_put(md);
+
 	return ret;
 }
 
@@ -908,6 +909,18 @@ static inline void mmc_blk_reset_success(struct mmc_blk_data *md, int type)
 	md->reset_done &= ~type;
 }
 
+int mmc_access_rpmb(struct mmc_queue *mq)
+{
+	struct mmc_blk_data *md = mq->data;
+	/*
+	 * If this is a RPMB partition access, return ture
+	 */
+	if (md && md->part_type == EXT_CSD_PART_CONFIG_ACC_RPMB)
+		return true;
+
+	return false;
+}
+
 static int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
@@ -1286,13 +1299,9 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 
 	/*
 	 * Reliable writes are used to implement Forced Unit Access and
-	 * REQ_META accesses, and are supported only on MMCs.
-	 *
-	 * XXX: this really needs a good explanation of why REQ_META
-	 * is treated special.
+	 * are supported only on MMCs.
 	 */
-	bool do_rel_wr = ((req->cmd_flags & REQ_FUA) ||
-			  (req->cmd_flags & REQ_META)) &&
+	bool do_rel_wr = (req->cmd_flags & REQ_FUA) &&
 		(rq_data_dir(req) == WRITE) &&
 		(md->flags & MMC_BLK_REL_WR);
 
@@ -1573,8 +1582,8 @@ static void mmc_blk_packed_hdr_wrq_prep(struct mmc_queue_req *mqrq,
 
 	packed_cmd_hdr = packed->cmd_hdr;
 	memset(packed_cmd_hdr, 0, sizeof(packed->cmd_hdr));
-	packed_cmd_hdr[0] = (packed->nr_entries << 16) |
-		(PACKED_CMD_WR << 8) | PACKED_CMD_VER;
+	packed_cmd_hdr[0] = cpu_to_le32((packed->nr_entries << 16) |
+		(PACKED_CMD_WR << 8) | PACKED_CMD_VER);
 	hdr_blocks = mmc_large_sector(card) ? 8 : 1;
 
 	/*
@@ -1588,14 +1597,14 @@ static void mmc_blk_packed_hdr_wrq_prep(struct mmc_queue_req *mqrq,
 			((brq->data.blocks * brq->data.blksz) >=
 			 card->ext_csd.data_tag_unit_size);
 		/* Argument of CMD23 */
-		packed_cmd_hdr[(i * 2)] =
+		packed_cmd_hdr[(i * 2)] = cpu_to_le32(
 			(do_rel_wr ? MMC_CMD23_ARG_REL_WR : 0) |
 			(do_data_tag ? MMC_CMD23_ARG_TAG_REQ : 0) |
-			blk_rq_sectors(prq);
+			blk_rq_sectors(prq));
 		/* Argument of CMD18 or CMD25 */
-		packed_cmd_hdr[((i * 2)) + 1] =
+		packed_cmd_hdr[((i * 2)) + 1] = cpu_to_le32(
 			mmc_card_blockaddr(card) ?
-			blk_rq_pos(prq) : blk_rq_pos(prq) << 9;
+			blk_rq_pos(prq) : blk_rq_pos(prq) << 9);
 		packed->blocks += blk_rq_sectors(prq);
 		i++;
 	}
@@ -1821,9 +1830,11 @@ static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
 			break;
 		case MMC_BLK_CMD_ERR:
 			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
-			if (!mmc_blk_reset(md, card->host, type))
-				break;
-			goto cmd_abort;
+			if (mmc_blk_reset(md, card->host, type))
+				goto cmd_abort;
+			if (!ret)
+				goto start_new_req;
+			break;
 		case MMC_BLK_RETRY:
 			if (retry++ < 5)
 				break;
@@ -2311,11 +2322,12 @@ static const struct mmc_fixup blk_fixups[] =
 		  MMC_QUIRK_BLK_NO_CMD23),
 
 	/*
-	 * Some Micron MMC cards needs longer data read timeout than
-	 * indicated in CSD.
+	 * Some MMC cards need longer data read timeout than indicated in CSD.
 	 */
 	MMC_FIXUP(CID_NAME_ANY, CID_MANFID_MICRON, 0x200, add_quirk_mmc,
 		  MMC_QUIRK_LONG_READ_TIME),
+	MMC_FIXUP("008GE0", CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,
+		  MMC_QUIRK_LONG_READ_TIME),
 
 	/*
 	 * On these Samsung MoviNAND parts, performing secure erase or
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 9447a0e..645519f 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -37,7 +37,7 @@ static int mmc_prep_request(struct request_queue *q, struct request *req)
 		return BLKPREP_KILL;
 	}
 
-	if (mq && mmc_card_removed(mq->card))
+	if (mq && (mmc_card_removed(mq->card) || mmc_access_rpmb(mq)))
 		return BLKPREP_KILL;
 
 	req->cmd_flags |= REQ_DONTPREP;
diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h
index 5752d50..99e6521 100644
--- a/drivers/mmc/card/queue.h
+++ b/drivers/mmc/card/queue.h
@@ -73,4 +73,6 @@ extern void mmc_queue_bounce_post(struct mmc_queue_req *);
 extern int mmc_packed_init(struct mmc_queue *, struct mmc_card *);
 extern void mmc_packed_clean(struct mmc_queue *);
 
+extern int mmc_access_rpmb(struct mmc_queue *);
+
 #endif
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index a06828b..a3fb62e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -327,8 +327,10 @@ EXPORT_SYMBOL(mmc_start_bkops);
  */
 static void mmc_wait_data_done(struct mmc_request *mrq)
 {
-	mrq->host->context_info.is_done_rcv = true;
-	wake_up_interruptible(&mrq->host->context_info.wait);
+	struct mmc_context_info *context_info = &mrq->host->context_info;
+
+	context_info->is_done_rcv = true;
+	wake_up_interruptible(&context_info->wait);
 }
 
 static void mmc_wait_done(struct mmc_request *mrq)
@@ -799,11 +801,11 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 	/*
 	 * Some cards require longer data read timeout than indicated in CSD.
 	 * Address this by setting the read timeout to a "reasonably high"
-	 * value. For the cards tested, 300ms has proven enough. If necessary,
+	 * value. For the cards tested, 600ms has proven enough. If necessary,
 	 * this value can be increased if other problematic cards require this.
 	 */
 	if (mmc_card_long_read_time(card) && data->flags & MMC_DATA_READ) {
-		data->timeout_ns = 300000000;
+		data->timeout_ns = 600000000;
 		data->timeout_clks = 0;
 	}
 
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 73f58e0..2061264 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -266,6 +266,9 @@ static void mmc_select_card_type(struct mmc_card *card)
 	card->ext_csd.card_type = card_type;
 }
 
+/* Minimum partition switch timeout in milliseconds */
+#define MMC_MIN_PART_SWITCH_TIME	300
+
 /*
  * Decode extended CSD.
  */
@@ -330,6 +333,10 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 
 		/* EXT_CSD value is in units of 10ms, but we store in ms */
 		card->ext_csd.part_time = 10 * ext_csd[EXT_CSD_PART_SWITCH_TIME];
+		/* Some eMMC set the value too low so set a minimum */
+		if (card->ext_csd.part_time &&
+		    card->ext_csd.part_time < MMC_MIN_PART_SWITCH_TIME)
+			card->ext_csd.part_time = MMC_MIN_PART_SWITCH_TIME;
 
 		/* Sleep / awake timeout in 100ns units */
 		if (sa_shift > 0 && sa_shift <= 0x17)
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index caae3f0..2e2dcbd 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -12,6 +12,13 @@ config MMC_AMBARELLA
 	  Interface support. If you have an Ambarella Media Processor
 	  platform with a Multimedia Card slot, say Y here.
 
+config AMBARELLA_EMMC_BOOT
+        bool "EMMC Boot for Ambarella Platform"
+        default n
+        help
+          If you want to use ambarella platform to boot from emmc, you must
+          select this item, so it can help emmc reboot.
+
 config MMC_ARMMMCI
 	tristate "ARM AMBA Multimedia Card Interface support"
 	depends on ARM_AMBA
diff --git a/drivers/mmc/host/ambarella_sd.c b/drivers/mmc/host/ambarella_sd.c
index fa9ab75..dbaba4f 100644
--- a/drivers/mmc/host/ambarella_sd.c
+++ b/drivers/mmc/host/ambarella_sd.c
@@ -46,6 +46,7 @@
 #include <plat/fio.h>
 #include <plat/sd.h>
 #include <plat/event.h>
+#include <plat/rct.h>
 
 static struct mmc_host *G_mmc[SD_INSTANCES * AMBA_SD_MAX_SLOT_NUM];
 
@@ -55,11 +56,11 @@ static struct mmc_host *G_mmc[SD_INSTANCES * AMBA_SD_MAX_SLOT_NUM];
 #define CONFIG_SD_AMBARELLA_WAIT_COUNTER_LIMIT	(100000)
 #define CONFIG_SD_AMBARELLA_MAX_TIMEOUT		(10 * HZ)
 #define CONFIG_SD_AMBARELLA_VSW_PRE_SPEC	(5)
-#define CONFIG_SD_AMBARELLA_VSW_POST_SPEC	(1)
 #define CONFIG_SD_AMBARELLA_VSW_WAIT_LIMIT	(1000)
 
 #undef CONFIG_SD_AMBARELLA_DEBUG
 #undef CONFIG_SD_AMBARELLA_DEBUG_VERBOSE
+#undef CONFIG_SD_AMBARELLA_TUNING_DEBUG
 
 #define ambsd_printk(level, phcinfo, format, arg...)	\
 	printk(level "%s.%u: " format, dev_name(phcinfo->pinfo->dev), \
@@ -82,6 +83,15 @@ static struct mmc_host *G_mmc[SD_INSTANCES * AMBA_SD_MAX_SLOT_NUM];
 	({ if (0) ambsd_printk(KERN_DEBUG, phcinfo, format, ##arg); 0; })
 #endif
 
+#ifdef CONFIG_SD_AMBARELLA_TUNING_DEBUG
+#define ambsd_tuning_dbg(phcinfo, format, arg...)		\
+	ambsd_printk(KERN_DEBUG, phcinfo, format, ## arg)
+#else
+#define ambsd_tuning_dbg(phcinfo, format, arg...)		\
+	({ if (0) ambsd_printk(KERN_DEBUG, phcinfo, format, ##arg); 0; })
+#endif
+
+
 /* ==========================================================================*/
 enum ambarella_sd_state {
 	AMBA_SD_STATE_IDLE,
@@ -149,12 +159,20 @@ struct ambarella_sd_mmc_info {
 	struct semaphore		system_event_sem;
 
 	struct dentry			*debugfs;
+
+#ifdef CONFIG_PM
+	u32				sd_nisen;
+	u32				sd_eisen;
+	u32				sd_nixen;
+	u32				sd_eixen;
+#endif
 };
 
 struct ambarella_sd_controller_info {
 	unsigned char __iomem 		*regbase;
 	unsigned char __iomem 		*fio_reg;
 	unsigned char __iomem 		*timing_reg;
+	unsigned char __iomem		*sbc_reg;
 	struct device			*dev;
 	unsigned int			irq;
 	u32				dma_fix;
@@ -165,13 +183,45 @@ struct ambarella_sd_controller_info {
 
 	struct clk			*clk;
 	u32				default_wait_tmo;
+	u32				switch_voltage_tmo;
 	u8				slot_num;
-	u32				soft_phy : 1;
+	u32				phy_type;
 	struct ambarella_sd_phy_timing	*phy_timing;
 	u32				phy_timing_num;
 
 	struct ambarella_sd_mmc_info	*pslotinfo[AMBA_SD_MAX_SLOT_NUM];
 	struct mmc_ios			controller_ios;
+	bool	auto_tuning;
+};
+
+static const u8 tuning_blk_pattern_4bit[] = {
+        0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+        0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+        0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+        0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+        0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+        0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+        0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+        0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+};
+
+static const u8 tuning_blk_pattern_8bit[] = {
+        0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
+        0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,
+        0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
+        0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,
+        0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,
+        0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,
+        0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,
+        0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,
+        0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,
+        0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,
+        0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,
+        0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,
+        0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,
+        0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,
+        0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,
+        0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,
 };
 
 /* ==========================================================================*/
@@ -680,6 +730,20 @@ static void ambarella_sd_reset_all(struct mmc_host *mmc)
 
 	ambarella_sd_disable_int(mmc, 0xFFFFFFFF);
 	amba_write2w(pinfo->regbase + SD_NIS_OFFSET, 0xFFFF, 0xFFFF);
+
+	/*reset sd timing register*/
+	if(pinfo->phy_type == 0 && pinfo->timing_reg) {
+		amba_writel(pinfo->sbc_reg, 0x0);
+		amba_writel(pinfo->timing_reg + 4, 0x0);
+		amba_writel(pinfo->timing_reg, 0x04070000);
+	} else if(pinfo->phy_type == 1) {
+		amba_writel(pinfo->regbase + SD_DELAY_SEL_L, 0x0);
+		amba_writel(pinfo->regbase + SD_DELAY_SEL_H, 0x0);
+	} else if(pinfo->phy_type == 2 && pinfo->timing_reg) {
+		amba_writel(pinfo->timing_reg, amba_rct_readl(pinfo->timing_reg)
+			& 0x1c1f1c1f);
+	}
+
 	amba_writeb(pinfo->regbase + SD_RESET_OFFSET, SD_RESET_ALL);
 	while (1) {
 		reset_reg = amba_readb(pinfo->regbase + SD_RESET_OFFSET);
@@ -906,75 +970,6 @@ static inline void ambarella_sd_cmd_done(
 	}
 }
 
-static irqreturn_t ambarella_sd_irq(int irq, void *devid)
-{
-	struct ambarella_sd_controller_info *pinfo = devid;
-	struct ambarella_sd_mmc_info *pslotinfo = NULL;
-	u16 nis, eis, slot_id;
-
-	/* Read and clear the interrupt registers */
-	amba_read2w(pinfo->regbase + SD_NIS_OFFSET, &nis, &eis);
-	amba_write2w(pinfo->regbase + SD_NIS_OFFSET, nis, eis);
-
-	if (pinfo->slot_num > 1) {
-		u32 fio_ctrl = amba_readl(pinfo->fio_reg + FIO_CTR_OFFSET);
-		slot_id = (fio_ctrl & FIO_CTR_XD) ? 1 : 0;
-	} else
-		slot_id = 0;
-
-	pslotinfo = pinfo->pslotinfo[slot_id];
-
-	ambsd_dbg(pslotinfo, "%s nis = 0x%x, eis = 0x%x & %u\n",
-				__func__, nis, eis, pslotinfo->state);
-
-	if (nis & SD_NIS_CARD) {
-		ambsd_dbg(pslotinfo, "SD_NIS_CARD\n");
-		mmc_signal_sdio_irq(pslotinfo->mmc);
-	}
-
-	if (nis & SD_NIS_REMOVAL) {
-		ambsd_dbg(pslotinfo, "SD_NIS_REMOVAL\n");
-		mmc_detect_change(pslotinfo->mmc, msecs_to_jiffies(1000));
-	} else if (nis & SD_NIS_INSERT) {
-		ambsd_dbg(pslotinfo, "SD_NIS_INSERT\n");
-		mmc_detect_change(pslotinfo->mmc, msecs_to_jiffies(1000));
-	}
-
-	if (eis) {
-		if (eis & (SD_EIS_CMD_TMOUT_ERR | SD_EIS_CMD_CRC_ERR |
-			SD_EIS_CMD_BIT_ERR | SD_EIS_CMD_IDX_ERR |
-			SD_EIS_ACMD12_ERR)) {
-			ambarella_sd_reset_cmd_line(pslotinfo->mmc);
-		}
-		if (eis & (SD_EIS_DATA_TMOUT_ERR | SD_EIS_DATA_CRC_ERR)) {
-			ambarella_sd_reset_data_line(pslotinfo->mmc);
-		}
-		if (eis & (SD_EIS_DATA_BIT_ERR | SD_EIS_CURRENT_ERR)) {
-			ambarella_sd_reset_all(pslotinfo->mmc);
-		}
-		if (pslotinfo->state == AMBA_SD_STATE_CMD) {
-			ambarella_sd_cmd_done(pslotinfo, nis, eis);
-		} else if (pslotinfo->state == AMBA_SD_STATE_DATA) {
-			ambarella_sd_data_done(pslotinfo, nis, eis);
-		}
-	} else {
-		if (nis & SD_NIS_CMD_DONE) {
-			ambarella_sd_cmd_done(pslotinfo, nis, eis);
-		}
-		if (nis & SD_NIS_XFR_DONE) {
-			ambarella_sd_data_done(pslotinfo, nis, eis);
-		}
-#if 0
-		if (nis & SD_NIS_DMA) {
-			amba_writel(pinfo->regbase + SD_DMA_ADDR_OFFSET,
-			amba_readl(pinfo->regbase + SD_DMA_ADDR_OFFSET));
-		}
-#endif
-	}
-
-	return IRQ_HANDLED;
-}
-
 static void ambarella_sd_set_clk(struct mmc_host *mmc, struct mmc_ios *ios)
 {
 	struct ambarella_sd_mmc_info *pslotinfo = mmc_priv(mmc);
@@ -1083,7 +1078,7 @@ static void ambarella_sd_set_phy_timing(
 {
 	u32 i, val0, val1;
 
-	if (pinfo->timing_reg == NULL || pinfo->phy_timing_num == 0)
+	if (pinfo->phy_type < 0 || !pinfo->phy_timing || pinfo->phy_timing_num == 0)
 		return;
 
 	for (i = 0; i < pinfo->phy_timing_num; i++) {
@@ -1099,10 +1094,15 @@ static void ambarella_sd_set_phy_timing(
 	val0 = pinfo->phy_timing[i].val0;
 	val1 = pinfo->phy_timing[i].val1;
 
-	if (pinfo->soft_phy) {
+	if (pinfo->phy_type == 0) {
+		/*using rct sd phy*/
 		amba_writel(pinfo->timing_reg, val0 | 0x02000000);
 		amba_writel(pinfo->timing_reg, val0);
 		amba_writel(pinfo->regbase + SD_LAT_CTRL_OFFSET, val1);
+	} else if(pinfo->phy_type == 1) {
+		/*using sd controller as sd phy*/
+		amba_writel(pinfo->regbase + SD_DELAY_SEL_L, val0);
+		amba_writel(pinfo->regbase + SD_DELAY_SEL_H, val1);
 	} else {
 		u32 ms_delay = amba_rct_readl(pinfo->timing_reg);
 		ms_delay &= val0;
@@ -1133,10 +1133,12 @@ static void ambarella_sd_set_bus(struct mmc_host *mmc, struct mmc_ios *ios)
 		hostr &= ~(SD_HOST_8BIT);
 		hostr &= ~(SD_HOST_4BIT);
 	}
+
 	hostr &= ~SD_HOST_HIGH_SPEED;
 	switch (ios->timing) {
 	case MMC_TIMING_LEGACY:
 	case MMC_TIMING_MMC_HS:
+	case MMC_TIMING_MMC_HS200:
 	case MMC_TIMING_SD_HS:
 	case MMC_TIMING_UHS_SDR12:
 	case MMC_TIMING_UHS_SDR25:
@@ -1162,10 +1164,12 @@ static void ambarella_sd_set_bus(struct mmc_host *mmc, struct mmc_ios *ios)
 	}
 
 	amba_writeb(pinfo->regbase + SD_HOST_OFFSET, hostr);
-
 	ambsd_dbg(pslotinfo, "hostr = 0x%x.\n", hostr);
 
-	ambarella_sd_set_phy_timing(pinfo, ios->timing);
+	if(!pinfo->auto_tuning || ios->timing == MMC_TIMING_LEGACY
+		|| ios->timing == MMC_TIMING_MMC_HS || ios->timing == MMC_TIMING_SD_HS)
+		ambarella_sd_set_phy_timing(pinfo, ios->timing);
+
 }
 
 static void ambarella_sd_check_ios(struct mmc_host *mmc, struct mmc_ios *ios)
@@ -1200,6 +1204,58 @@ static void ambarella_sd_check_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	}
 }
 
+static void ambarella_sd_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	ambarella_sd_request_bus(mmc);
+	ambarella_sd_check_ios(mmc, ios);
+	ambarella_sd_release_bus(mmc);
+}
+
+static void ambarella_sd_recovery(struct mmc_host *mmc)
+{
+	struct ambarella_sd_mmc_info *pslotinfo = mmc_priv(mmc);
+	struct ambarella_sd_controller_info *pinfo = pslotinfo->pinfo;
+	u32 latency = 0, sbc_reg = 0, timing_reg0 = 0, timing_reg1 = 0;
+	u32 sd_delay_sel0 = 0, sd_delay_sel1 = 0, divisor = 0;
+
+	/*save the sd timing register*/
+	if(pinfo->phy_type == 0 && pinfo->timing_reg) {
+		latency = amba_readl(pinfo->regbase + SD_LAT_CTRL_OFFSET);
+		timing_reg0 = amba_readl(pinfo->timing_reg);
+		timing_reg1 = amba_readl(pinfo->timing_reg + 4);
+		sbc_reg = amba_readl(pinfo->sbc_reg);
+	} else if(pinfo->phy_type == 1) {
+		sd_delay_sel0 = amba_readl(pinfo->regbase + SD_DELAY_SEL_L);
+		sd_delay_sel1 = amba_readl(pinfo->regbase + SD_DELAY_SEL_H);
+	} else if(pinfo->phy_type == 2 && pinfo->timing_reg) {
+		timing_reg0 = amba_readl(pinfo->timing_reg);
+	}
+
+	divisor = (amba_readw(pinfo->regbase + SD_CLK_OFFSET) & 0xff00) >> 8;
+
+	ambarella_sd_reset_all(mmc);
+
+	/*restore clk*/
+	ambarella_sd_clear_clken(mmc);
+	ambarella_sd_set_iclk(mmc, divisor);
+	ambarella_sd_set_clken(mmc);
+	ambarella_sd_set_bus(mmc, &pinfo->controller_ios);
+
+	/*restore the sd timing register*/
+	if(pinfo->phy_type == 0 && pinfo->timing_reg) {
+		amba_writel(pinfo->regbase + SD_LAT_CTRL_OFFSET, latency);
+		amba_writel(pinfo->timing_reg, timing_reg0);
+		amba_writel(pinfo->timing_reg + 4, timing_reg1);
+		amba_writel(pinfo->sbc_reg, sbc_reg);
+	} else if(pinfo->phy_type == 1) {
+		amba_writel(pinfo->regbase + SD_DELAY_SEL_L, sd_delay_sel0);
+		amba_writel(pinfo->regbase + SD_DELAY_SEL_H, sd_delay_sel1);
+	} else if(pinfo->phy_type == 2 && pinfo->timing_reg) {
+		amba_writel(pinfo->timing_reg, timing_reg0);
+	}
+
+}
+
 static u32 ambarella_sd_check_cd(struct mmc_host *mmc)
 {
 	struct ambarella_sd_mmc_info *pslotinfo = mmc_priv(mmc);
@@ -1226,15 +1282,8 @@ static inline void ambarella_sd_prepare_tmo(
 	struct ambarella_sd_controller_info *pinfo = pslotinfo->pinfo;
 
 	pslotinfo->tmo = CONFIG_SD_AMBARELLA_TIMEOUT_VAL;
-	pslotinfo->wait_tmo = pinfo->default_wait_tmo;
-	if ((pslotinfo->wait_tmo > 0) && (pslotinfo->wait_tmo <
-		CONFIG_SD_AMBARELLA_MAX_TIMEOUT)) {
-		pslotinfo->sta_counter = CONFIG_SD_AMBARELLA_MAX_TIMEOUT;
-		pslotinfo->sta_counter /= pslotinfo->wait_tmo;
-	} else {
-		pslotinfo->sta_counter = 1;
-		pslotinfo->wait_tmo = (1 * HZ);
-	}
+	pslotinfo->wait_tmo = min_t(u32, pinfo->default_wait_tmo, CONFIG_SD_AMBARELLA_MAX_TIMEOUT);
+	pslotinfo->sta_counter = pinfo->default_wait_tmo / CONFIG_SD_AMBARELLA_MAX_TIMEOUT + 1;
 
 	ambsd_dbg(pslotinfo, "timeout_ns = %u, timeout_clks = %u, "
 		"wait_tmo = %u, tmo = %u, sta_counter = %u.\n",
@@ -1360,9 +1409,11 @@ static inline void ambarella_sd_send_cmd(struct ambarella_sd_mmc_info *pslotinfo
 			}
 			counter++;
 			if (counter > CONFIG_SD_AMBARELLA_WAIT_COUNTER_LIMIT) {
-				ambsd_warn(pslotinfo,
-					"Wait SD_STA_CMD_INHIBIT_DAT...\n");
+				if(pslotinfo->mrq->cmd->opcode != MMC_SEND_TUNING_BLOCK)
+					ambsd_warn(pslotinfo,
+						"Wait SD_STA_CMD_INHIBIT_DAT...\n");
 				pslotinfo->state = AMBA_SD_STATE_ERR;
+				pslotinfo->mrq->data->error = -EILSEQ;
 				pinfo->reset_error = 1;
 				goto ambarella_sd_send_cmd_exit;
 			}
@@ -1396,6 +1447,7 @@ static inline void ambarella_sd_send_cmd(struct ambarella_sd_mmc_info *pslotinfo
 				ambsd_warn(pslotinfo,
 					"Wait SD_STA_CMD_INHIBIT_CMD...\n");
 				pslotinfo->state = AMBA_SD_STATE_ERR;
+				pslotinfo->mrq->cmd->error = -EILSEQ;
 				pinfo->reset_error = 1;
 				goto ambarella_sd_send_cmd_exit;
 			}
@@ -1502,7 +1554,8 @@ static inline void ambarella_sd_post_cmd(struct ambarella_sd_mmc_info *pslotinfo
 		ambarella_sd_show_info(pslotinfo);
 #endif
 		if (pinfo->reset_error) {
-			ambarella_sd_reset_all(pslotinfo->mmc);
+			ambarella_sd_recovery(pslotinfo->mmc);
+			//ambarella_sd_reset_all(pslotinfo->mmc);
 		}
 		ambarella_sd_release_bus(pslotinfo->mmc);
 	}
@@ -1520,13 +1573,6 @@ static void ambarella_sd_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	mmc_request_done(mmc, mrq);
 }
 
-static void ambarella_sd_ios(struct mmc_host *mmc, struct mmc_ios *ios)
-{
-	ambarella_sd_request_bus(mmc);
-	ambarella_sd_check_ios(mmc, ios);
-	ambarella_sd_release_bus(mmc);
-}
-
 static int ambarella_sd_get_ro(struct mmc_host *mmc)
 {
 	struct ambarella_sd_mmc_info *pslotinfo = mmc_priv(mmc);
@@ -1597,10 +1643,8 @@ static int ambarella_sd_ssvs(struct mmc_host *mmc, struct mmc_ios *ios)
 		if (gpio_is_valid(pslotinfo->v18_gpio)) {
 			gpio_set_value_cansleep(pslotinfo->v18_gpio,
 						pslotinfo->v18_gpio_active);
-			msleep(10);
+			msleep(pinfo->switch_voltage_tmo);
 		}
-
-		msleep(CONFIG_SD_AMBARELLA_VSW_POST_SPEC);
 		ambarella_sd_set_clken(mmc);
 	}
 	ambarella_sd_release_bus(mmc);
@@ -1624,6 +1668,365 @@ static int ambarella_sd_card_busy(struct mmc_host *mmc)
 	return retval;
 }
 
+static int ambarella_send_tuning_cmd(struct mmc_host *host, u32 opcode, int *cmd_error)
+{
+	struct mmc_request mrq = {NULL};
+	struct mmc_command cmd = {0};
+	struct mmc_data data = {0};
+	struct scatterlist sg;
+	struct mmc_ios *ios = &host->ios;
+	const u8 *tuning_block_pattern;
+	int size, err = 0;
+	u8 *data_buf;
+
+	if (ios->bus_width == MMC_BUS_WIDTH_8) {
+			tuning_block_pattern = tuning_blk_pattern_8bit;
+			size = sizeof(tuning_blk_pattern_8bit);
+	} else if (ios->bus_width == MMC_BUS_WIDTH_4) {
+			tuning_block_pattern = tuning_blk_pattern_4bit;
+			size = sizeof(tuning_blk_pattern_4bit);
+	} else
+			return -EINVAL;
+
+	data_buf = kzalloc(size, GFP_KERNEL);
+	if (!data_buf)
+			return -ENOMEM;
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+
+	cmd.opcode = opcode;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	data.blksz = size;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	/*
+	 * According to the tuning specs, Tuning process
+	 * is normally shorter 40 executions of CMD19,
+	 * and timeout value should be shorter than 150 ms
+	 */
+	data.timeout_ns = 150 * NSEC_PER_MSEC;
+
+	data.sg = &sg;
+	data.sg_len = 1;
+	sg_init_one(&sg, data_buf, size);
+
+	mmc_wait_for_req(host, &mrq);
+
+	if (cmd_error)
+		*cmd_error = cmd.error;
+
+	if (cmd.error) {
+		err = cmd.error;
+		goto out;
+	}
+
+	if (data.error) {
+		err = data.error;
+		goto out;
+	}
+
+	if (memcmp(data_buf, tuning_block_pattern, size))
+		err = -EIO;
+
+out:
+	kfree(data_buf);
+	return err;
+
+}
+
+static int ambarella_sd_execute_tuning(struct mmc_host *mmc, u32 opcode)
+{
+	struct ambarella_sd_mmc_info *pslotinfo = mmc_priv(mmc);
+	struct ambarella_sd_controller_info *pinfo = pslotinfo->pinfo;
+	u32 tmp, misc, lat, s = -1, e = 0, middle;
+	u32 best_misc = 0, best_s = -1, best_e = 0, doing_retune = 0;
+	int dly, longest_range = 0, range = 0;
+	u32 clock = pinfo->controller_ios.clock;
+
+	if(!pinfo->auto_tuning || !pinfo->timing_reg)
+		return 0;
+
+retry:
+	if (doing_retune) {
+		clock -= 10000000;
+		if (clock <= 50000000) {
+			ambsd_tuning_dbg(pslotinfo,
+				"tuning: can't find any valid timing\n");
+			return -ECANCELED;
+		}
+
+		pinfo->controller_ios.clock = clock;
+		ambarella_sd_set_clk(mmc, &pinfo->controller_ios);
+	}
+
+	if(pinfo->phy_type == 0)
+		goto phy_type_0;
+	else if (pinfo->phy_type == 1)
+		goto phy_type_1;
+	else if (pinfo->phy_type == 2)
+		goto phy_type_2;
+
+phy_type_0:
+	for (misc = 0; misc < 4; misc++) {
+		writel_relaxed(0x8001, pinfo->sbc_reg);
+
+		tmp = readl_relaxed(pinfo->timing_reg);
+		tmp &= 0x0000ffff;
+		tmp |= ((misc >> 1) & 0x1) << 19;
+		writel_relaxed(tmp | (1 << 25), pinfo->timing_reg);
+		usleep_range(5, 10);
+		writel_relaxed(tmp, pinfo->timing_reg);
+		usleep_range(5, 10);
+		lat = ((misc >> 0) & 0x1) + 1;
+		tmp = (lat << 12) | (lat << 8) | (lat << 4) | (lat << 0);
+		writel_relaxed(tmp, pinfo->regbase + SD_LAT_CTRL_OFFSET);
+
+		for (dly = 0; dly < 4; dly++) {
+			tmp = readl_relaxed(pinfo->sbc_reg);
+			tmp &= 0xfffffff9;
+//			tmp |= (((dly >> 6) & 0x3) << 1);
+			tmp |= dly;
+			writel_relaxed(tmp, pinfo->sbc_reg);
+/*
+			sel = dly % 64;
+			if (sel < 0x20)
+				sel = 63 - sel;
+			else
+				sel = sel - 32;
+
+			tmp = (sel << 16) | (sel << 8) | (sel << 0);
+			writel_relaxed(tmp, pinfo->timing_reg + 4);
+*/
+			if (ambarella_send_tuning_cmd(mmc, opcode, NULL) == 0) {
+				/* Tuning is successful at this tuning point */
+				if (s == -1)
+					s = dly;
+				e = dly;
+				range++;
+			} else {
+				if (range > 0) {
+					ambsd_tuning_dbg(pslotinfo,
+						"tuning: misc[0x%x], count[%d](%d - %d)\n",
+						misc, e - s + 1, s, e);
+				}
+
+				if (range > longest_range) {
+					best_misc = misc;
+					best_s = s;
+					best_e = e;
+					longest_range = range;
+				}
+				s = -1;
+				e = range = 0;
+			}
+		}
+
+		/* in case the last timings are all working */
+		if (range > longest_range) {
+			if (range > 0) {
+				ambsd_tuning_dbg(pslotinfo,
+					"tuning last: misc[0x%x], count[%d](%d - %d)\n",
+					misc, e - s + 1, s, e);
+			}
+			best_misc = misc;
+			best_s = s;
+			best_e = e;
+			longest_range = range;
+		}
+		s = -1;
+		e = range = 0;
+	}
+
+	if (longest_range == 0) {
+		if (clock > 50000000) {
+			doing_retune = 1;
+			goto retry;
+		}
+
+		return -EIO;
+	}
+
+	middle = (best_s + best_e) / 2;
+
+//	tmp = (((middle >> 6) & 0x3) << 1) | 0x8001;
+	tmp = (middle << 1) | 0x8001;
+	writel_relaxed(tmp, pinfo->sbc_reg);
+/*
+	sel = middle % 64;
+	if (sel < 0x20)
+			sel = 63 - sel;
+	else
+			sel = sel - 32;
+
+	tmp = (sel << 16) | (sel << 8) | (sel << 0);
+	writel_relaxed(tmp, pinfo->timing_reg + 4);
+*/
+	tmp = readl_relaxed(pinfo->timing_reg);
+	tmp &= 0x0000ffff;
+	tmp |= ((best_misc >> 1) & 0x1) << 19;
+	writel_relaxed(tmp | (1 << 25), pinfo->timing_reg);
+	usleep_range(5, 10);
+	writel_relaxed(tmp, pinfo->timing_reg);
+	usleep_range(5, 10);
+
+	lat = ((best_misc >> 0) & 0x1) + 1;
+	tmp = (lat << 12) | (lat << 8) | (lat << 4) | (lat << 0);
+	writel_relaxed(tmp, pinfo->regbase + SD_LAT_CTRL_OFFSET);
+
+	ambarella_sd_recovery(mmc);
+
+	return 0;
+
+phy_type_1:
+
+	/* misc: 3 bits data out delay
+	 * dly: 2 bits clk mode and 3 bits clk out delay, total 5 bits;
+	 */
+
+	for(misc = 0; misc < 8; misc++) {
+		for(dly = 0; dly < 32; dly++) {
+			tmp = (misc << 9) | (misc << 15) | (misc << 21) | (misc << 27);
+			amba_writel(pinfo->regbase + SD_DELAY_SEL_L, tmp);
+			tmp = ((dly >> 3) << 25) | ((dly & 0x07) << 22) | (misc << 1)
+				| (misc << 7) | (misc << 13) | (misc << 19);
+			amba_writel(pinfo->regbase + SD_DELAY_SEL_H, tmp);
+
+			if (ambarella_send_tuning_cmd(mmc, opcode, NULL) == 0) {
+				/* Tuning is successful at this tuning point */
+				if (s == -1)
+					s = dly;
+				e = dly;
+				range++;
+			} else {
+				if (range > 0) {
+					ambsd_tuning_dbg(pslotinfo,
+						"tuning last: misc[0x%x], count[%d](%d - %d)\n",
+						misc, e - s + 1, s, e);
+				}
+
+				if (range > longest_range) {
+					best_misc = misc;
+					best_s = s;
+					best_e = e;
+					longest_range = range;
+				}
+				s = -1;
+				e = range = 0;
+			}
+		}
+
+		/* in case the last timings are all working */
+		if (range > longest_range) {
+			if (range > 0) {
+				ambsd_tuning_dbg(pslotinfo,
+					"tuning last: misc[0x%x], count[%d](%d - %d)\n",
+					misc, e - s + 1, s, e);
+			}
+			best_misc = misc;
+			best_s = s;
+			best_e = e;
+			longest_range = range;
+		}
+		s = -1;
+		e = range = 0;
+	}
+
+	if (longest_range == 0) {
+		if (clock > 50000000) {
+			doing_retune = 1;
+			goto retry;
+		}
+
+		return -EIO;
+	}
+
+	middle = (best_s + best_e) / 2;
+
+	tmp = (best_misc << 9) | (best_misc << 15) | (best_misc << 21) | (best_misc << 27);
+	amba_writel(pinfo->regbase + SD_DELAY_SEL_L, tmp);
+	tmp = ((middle >> 3) << 25) | ((middle & 0x07) << 22) | (best_misc << 1)
+		| (best_misc << 7) | (best_misc << 13) | (best_misc << 19);
+	amba_writel(pinfo->regbase + SD_DELAY_SEL_H, tmp);
+
+	ambarella_sd_recovery(mmc);
+
+	return 0;
+
+phy_type_2:
+
+	/* misc: 5 bits out clock delay
+	 * dly: 2 bits out data delay and 3 bits input data delay, total 5 bits;
+	 */
+
+	/*This is only used for s2e sdio slot*/
+	lat = amba_readl(pinfo->timing_reg);
+	lat &= ~0xC3E0E000;
+
+	for(misc = 0; misc < 32; misc++) {
+		for(dly = 0; dly < 32; dly++) {
+			tmp = lat | ((dly >> 3) << 30) | ((dly & 0x07) << 13) | (misc << 21);
+			amba_writel(pinfo->timing_reg, tmp);
+			if (ambarella_send_tuning_cmd(mmc, opcode, NULL) == 0) {
+				/* Tuning is successful at this tuning point */
+				if (s == -1)
+					s = dly;
+				e = dly;
+				range++;
+			} else {
+				if (range > 0) {
+					ambsd_tuning_dbg(pslotinfo,
+						"tuning last: misc[0x%x], count[%d](%d - %d)\n",
+						misc, e - s + 1, s, e);
+				}
+
+				if (range > longest_range) {
+					best_misc = misc;
+					best_s = s;
+					best_e = e;
+					longest_range = range;
+				}
+				s = -1;
+				e = range = 0;
+			}
+		}
+
+		/* in case the last timings are all working */
+		if (range > longest_range) {
+			if (range > 0) {
+				ambsd_tuning_dbg(pslotinfo,
+					"tuning last: misc[0x%x], count[%d](%d - %d)\n",
+					misc, e - s + 1, s, e);
+			}
+			best_misc = misc;
+			best_s = s;
+			best_e = e;
+			longest_range = range;
+		}
+		s = -1;
+		e = range = 0;
+	}
+
+	if (longest_range == 0) {
+		if (clock > 50000000) {
+			doing_retune = 1;
+			goto retry;
+		}
+
+		return -EIO;
+	}
+
+	middle = (best_s + best_e) / 2;
+	tmp = lat | ((middle >> 3) << 30) | ((middle & 0x07) << 13) | (best_misc << 21);
+	amba_writel(pinfo->timing_reg, tmp);
+
+	ambarella_sd_recovery(mmc);
+
+	return 0;
+}
+
 static const struct mmc_host_ops ambarella_sd_host_ops = {
 	.request = ambarella_sd_request,
 	.set_ios = ambarella_sd_ios,
@@ -1632,6 +2035,7 @@ static const struct mmc_host_ops ambarella_sd_host_ops = {
 	.enable_sdio_irq = ambarella_sd_enable_sdio_irq,
 	.start_signal_voltage_switch = ambarella_sd_ssvs,
 	.card_busy = ambarella_sd_card_busy,
+	.execute_tuning =  ambarella_sd_execute_tuning,
 };
 
 static int ambarella_sd_system_event(struct notifier_block *nb,
@@ -1662,6 +2066,79 @@ static int ambarella_sd_system_event(struct notifier_block *nb,
 	return NOTIFY_OK;
 }
 
+static irqreturn_t ambarella_sd_irq(int irq, void *devid)
+{
+	struct ambarella_sd_controller_info *pinfo = devid;
+	struct ambarella_sd_mmc_info *pslotinfo = NULL;
+	u16 nis, eis, slot_id;
+
+	/* Read and clear the interrupt registers */
+	amba_read2w(pinfo->regbase + SD_NIS_OFFSET, &nis, &eis);
+	amba_write2w(pinfo->regbase + SD_NIS_OFFSET, nis, eis);
+
+	if (pinfo->slot_num > 1) {
+		u32 fio_ctrl = amba_readl(pinfo->fio_reg + FIO_CTR_OFFSET);
+		slot_id = (fio_ctrl & FIO_CTR_XD) ? 1 : 0;
+	} else
+		slot_id = 0;
+
+	pslotinfo = pinfo->pslotinfo[slot_id];
+
+	ambsd_dbg(pslotinfo, "%s nis = 0x%x, eis = 0x%x & %u\n",
+				__func__, nis, eis, pslotinfo->state);
+
+	if (nis & SD_NIS_CARD) {
+		ambsd_dbg(pslotinfo, "SD_NIS_CARD\n");
+		mmc_signal_sdio_irq(pslotinfo->mmc);
+	}
+
+	if(pslotinfo->fixed_cd == -1) {
+		if (nis & SD_NIS_REMOVAL) {
+			ambsd_dbg(pslotinfo, "SD_NIS_REMOVAL\n");
+			mmc_detect_change(pslotinfo->mmc, msecs_to_jiffies(1000));
+		} else if (nis & SD_NIS_INSERT) {
+			ambsd_dbg(pslotinfo, "SD_NIS_INSERT\n");
+			mmc_detect_change(pslotinfo->mmc, msecs_to_jiffies(1000));
+		}
+	}
+
+	if (eis) {
+		if (eis & (SD_EIS_CMD_TMOUT_ERR | SD_EIS_CMD_CRC_ERR |
+			SD_EIS_CMD_BIT_ERR | SD_EIS_CMD_IDX_ERR |
+			SD_EIS_ACMD12_ERR)) {
+			ambarella_sd_reset_cmd_line(pslotinfo->mmc);
+		}
+		if (eis & (SD_EIS_DATA_TMOUT_ERR | SD_EIS_DATA_CRC_ERR)) {
+			ambarella_sd_reset_data_line(pslotinfo->mmc);
+		}
+		if (eis & (SD_EIS_DATA_BIT_ERR | SD_EIS_CURRENT_ERR)) {
+			//ambarella_sd_reset_all(pslotinfo->mmc);
+			ambarella_sd_recovery(pslotinfo->mmc);
+		}
+		if (pslotinfo->state == AMBA_SD_STATE_CMD) {
+			ambarella_sd_cmd_done(pslotinfo, nis, eis);
+		} else if (pslotinfo->state == AMBA_SD_STATE_DATA) {
+			ambarella_sd_data_done(pslotinfo, nis, eis);
+		}
+	} else {
+		if (nis & SD_NIS_CMD_DONE) {
+			ambarella_sd_cmd_done(pslotinfo, nis, eis);
+		}
+		if (nis & SD_NIS_XFR_DONE) {
+			ambarella_sd_data_done(pslotinfo, nis, eis);
+		}
+#if 0
+		if (nis & SD_NIS_DMA) {
+			amba_writel(pinfo->regbase + SD_DMA_ADDR_OFFSET,
+			amba_readl(pinfo->regbase + SD_DMA_ADDR_OFFSET));
+		}
+#endif
+	}
+
+	return IRQ_HANDLED;
+}
+
+
 /* ==========================================================================*/
 
 static int ambarella_sd_init_slot(struct device_node *np, int id,
@@ -1674,7 +2151,7 @@ static int ambarella_sd_init_slot(struct device_node *np, int id,
 	u32 gpio_init_flag, hc_cap, hc_timeout_clk;
 	int global_id, retval = 0;
 
-	mmc = mmc_alloc_host(sizeof(*mmc), pinfo->dev);
+	mmc = mmc_alloc_host(sizeof(*pslotinfo), pinfo->dev);
 	if (!mmc) {
 		dev_err(pinfo->dev, "Failed to alloc mmc host %u!\n", id);
 		return -ENOMEM;
@@ -1759,10 +2236,7 @@ static int ambarella_sd_init_slot(struct device_node *np, int id,
 		}
 	}
 
-	clk_set_rate(pinfo->clk, mmc->f_max);
-	mmc->f_max = clk_get_rate(pinfo->clk);
 	mmc->f_min = mmc->f_max >> 8;
-
 	mmc->ops = &ambarella_sd_host_ops;
 
 	init_waitqueue_head(&pslotinfo->wait);
@@ -1800,6 +2274,8 @@ static int ambarella_sd_init_slot(struct device_node *np, int id,
 	mmc->caps |= MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ |
 			MMC_CAP_ERASE | MMC_CAP_BUS_WIDTH_TEST;
 
+	mmc->caps2 |= MMC_CAP2_HS200 | MMC_CAP2_HS200_1_8V_SDR;
+
 	if (mmc->f_max > 25000000) {
 		mmc->caps |= MMC_CAP_SD_HIGHSPEED;
 		mmc->caps |= MMC_CAP_MMC_HIGHSPEED;
@@ -1950,7 +2426,7 @@ static int ambarella_sd_of_parse(struct ambarella_sd_controller_info *pinfo)
 	struct device_node *np = pinfo->dev->of_node;
 	const __be32 *prop;
 	const char *clk_name;
-	int psize, tmo, retval = 0;
+	int psize, tmo, switch_vol_tmo, retval = 0;
 
 	retval = of_property_read_string(np, "amb,clk-name", &clk_name);
 	if (retval < 0) {
@@ -1970,49 +2446,54 @@ static int ambarella_sd_of_parse(struct ambarella_sd_controller_info *pinfo)
 
 	retval = of_property_read_u32(np, "amb,wait-tmo", &tmo);
 	if (retval < 0)
-		tmo = 0x20000;
+		tmo = 0x10000;
 
 	pinfo->default_wait_tmo = msecs_to_jiffies(tmo);
 
 	if (pinfo->default_wait_tmo < CONFIG_SD_AMBARELLA_WAIT_TIMEOUT)
 		pinfo->default_wait_tmo = CONFIG_SD_AMBARELLA_WAIT_TIMEOUT;
 
+	retval = of_property_read_u32(np, "amb,switch-vol-tmo", &switch_vol_tmo);
+	if (retval < 0)
+		switch_vol_tmo = 100;
+
+	pinfo->switch_voltage_tmo = switch_vol_tmo;
+
 	retval = of_property_read_u32(np, "amb,max-blk-size", &pinfo->max_blk_sz);
 	if (retval < 0)
 		pinfo->max_blk_sz = 0x20000;
 
-	/* below are properties for phy timing */
-	if (pinfo->timing_reg == NULL) {
+	pinfo->auto_tuning = !!of_find_property(np, "amb,auto-tuning", NULL);
+	retval = of_property_read_u32(np, "amb,phy-type", &pinfo->phy_type);
+	if(retval) {
+		/*this controller don't support sd phy*/
+		pinfo->phy_type = -1;
 		retval = 0;
-		goto pasre_err;
-	}
-
-	pinfo->soft_phy = !!of_find_property(np, "amb,soft-phy", NULL);
+	} else {
+		/* amb,phy-timing must be provided when timing_reg is given */
+		prop = of_get_property(np, "amb,phy-timing", &psize);
+		if (!prop) {
+			retval = -EINVAL;
+			goto pasre_err;
+		}
 
-	/* amb,phy-timing must be provided when timing_reg is given */
-	prop = of_get_property(np, "amb,phy-timing", &psize);
-	if (!prop) {
-		retval = -EINVAL;
-		goto pasre_err;
-	}
+		psize /= sizeof(u32);
+		BUG_ON(psize % 3);
+		pinfo->phy_timing_num = psize / 3;
+		pinfo->phy_timing = devm_kzalloc(pinfo->dev, psize, GFP_KERNEL);
+		if (pinfo->phy_timing == NULL) {
+			retval = -ENOMEM;
+			goto pasre_err;
+		}
 
-	psize /= sizeof(u32);
-	BUG_ON(psize % 3);
-	pinfo->phy_timing_num = psize / 3;
+		retval = of_property_read_u32_array(np, "amb,phy-timing",
+				(u32 *)pinfo->phy_timing, psize);
 
-	pinfo->phy_timing = devm_kzalloc(pinfo->dev, psize, GFP_KERNEL);
-	if (pinfo->phy_timing == NULL) {
-		retval = -ENOMEM;
-		goto pasre_err;
+		/* bit0 of mode must be set, and the phy setting in first row with
+		 * bit0 set is the default one. */
+		BUG_ON(!(pinfo->phy_timing[0].mode & 0x1));
 	}
 
-	retval = of_property_read_u32_array(np, "amb,phy-timing",
-			(u32 *)pinfo->phy_timing, psize);
-
-	/* bit0 of mode must be set, and the phy setting in first row with
-	 * bit0 set is the default one. */
-	BUG_ON(!(pinfo->phy_timing[0].mode & 0x1));
-
 pasre_err:
 	return retval;
 }
@@ -2051,6 +2532,7 @@ static int ambarella_sd_get_resource(struct platform_device *pdev,
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 2);
 	if (mem == NULL) {
 		pinfo->timing_reg = NULL;
+		pinfo->auto_tuning = false;
 	} else {
 		pinfo->timing_reg = devm_ioremap(&pdev->dev,
 					mem->start, resource_size(mem));
@@ -2060,6 +2542,18 @@ static int ambarella_sd_get_resource(struct platform_device *pdev,
 		}
 	}
 
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	if (mem == NULL) {
+			pinfo->sbc_reg = pinfo->timing_reg;
+	} else {
+			pinfo->sbc_reg = devm_ioremap(&pdev->dev,
+									mem->start, resource_size(mem));
+			if (pinfo->sbc_reg == NULL) {
+					dev_err(&pdev->dev, "devm_ioremap() failed for sbc_reg\n");
+					return -ENOMEM;
+			}
+	}
+
 	pinfo->irq = platform_get_irq(pdev, 0);
 	if (pinfo->irq < 0) {
 		dev_err(&pdev->dev, "Get SD/MMC irq resource failed!\n");
@@ -2097,14 +2591,6 @@ static int ambarella_sd_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
-	retval = devm_request_irq(&pdev->dev, pinfo->irq, ambarella_sd_irq,
-				IRQF_SHARED | IRQF_TRIGGER_HIGH,
-				dev_name(&pdev->dev), pinfo);
-	if (retval < 0) {
-		dev_err(&pdev->dev, "Can't Request IRQ%u!\n", pinfo->irq);
-		goto ambarella_sd_probe_free_host;
-	}
-
 	pinfo->slot_num = 0;
 	for_each_child_of_node(pdev->dev.of_node, slot_np) {
 		if (!slot_np->name || of_node_cmp(slot_np->name, "slot"))
@@ -2122,6 +2608,15 @@ static int ambarella_sd_probe(struct platform_device *pdev)
 	}
 
 	platform_set_drvdata(pdev, pinfo);
+
+	retval = devm_request_irq(&pdev->dev, pinfo->irq, ambarella_sd_irq,
+				IRQF_SHARED | IRQF_TRIGGER_HIGH,
+				dev_name(&pdev->dev), pinfo);
+	if (retval < 0) {
+		dev_err(&pdev->dev, "Can't Request IRQ%u!\n", pinfo->irq);
+		goto ambarella_sd_probe_free_host;
+	}
+
 	dev_info(&pdev->dev, "%u slots @ %luHz\n",
 			pinfo->slot_num, clk_get_rate(pinfo->clk));
 
@@ -2163,24 +2658,41 @@ static int ambarella_sd_suspend(struct platform_device *pdev,
 	pm_message_t state)
 {
 	struct ambarella_sd_controller_info *pinfo;
+	struct ambarella_sd_mmc_info *pslotinfo;
+
 	int retval = 0, i;
 
 	pinfo = platform_get_drvdata(pdev);
 
 	for (i = 0; i < pinfo->slot_num; i++) {
-		retval = mmc_suspend_host(pinfo->pslotinfo[i]->mmc);
-		if (retval) {
-			ambsd_err(pinfo->pslotinfo[i],
-				"mmc_suspend_host[%d] failed[%d]!\n", i, retval);
+		pslotinfo = pinfo->pslotinfo[i];
+
+		if (pslotinfo->mmc) {
+			if (pslotinfo->mmc->pm_caps & MMC_PM_KEEP_POWER) {
+				pslotinfo->mmc->pm_flags = MMC_PM_KEEP_POWER;
+			}
+			retval = mmc_suspend_host(pslotinfo->mmc);
+			if (retval) {
+				ambsd_err(pslotinfo,
+					"mmc_suspend_host[%d] failed[%d]!\n", i, retval);
+				return retval;
+			}
+		}
+		if (pslotinfo->mmc->pm_caps & MMC_PM_KEEP_POWER) {
+			ambarella_sd_disable_int(pslotinfo->mmc, SD_NISEN_CARD);
+			pslotinfo->sd_nisen = amba_readw(pinfo->regbase + SD_NISEN_OFFSET);
+			pslotinfo->sd_eisen = amba_readw(pinfo->regbase + SD_EISEN_OFFSET);
+			pslotinfo->sd_nixen = amba_readw(pinfo->regbase + SD_NIXEN_OFFSET);
+			pslotinfo->sd_eixen = amba_readw(pinfo->regbase + SD_EIXEN_OFFSET);
 		}
 	}
 
 	disable_irq(pinfo->irq);
-
 	dev_dbg(&pdev->dev, "%s exit with %d @ %d\n", __func__,
 				retval, state.event);
 
 	return retval;
+
 }
 
 static int ambarella_sd_resume(struct platform_device *pdev)
@@ -2191,23 +2703,38 @@ static int ambarella_sd_resume(struct platform_device *pdev)
 
 	pinfo = platform_get_drvdata(pdev);
 
+	enable_irq(pinfo->irq);
+
 	for (i = 0; i < pinfo->slot_num; i++) {
 		pslotinfo = pinfo->pslotinfo[i];
 		if (gpio_is_valid(pslotinfo->pwr_gpio)){
 			gpio_direction_output(pslotinfo->pwr_gpio, pslotinfo->pwr_gpio_active);
 		}
-		clk_set_rate(pinfo->clk, pslotinfo->mmc->f_max);
-		ambarella_sd_reset_all(pslotinfo->mmc);
+		if (pslotinfo->mmc->pm_caps & MMC_PM_KEEP_POWER) {
+			amba_writew(pinfo->regbase + SD_NISEN_OFFSET, pslotinfo->sd_nisen);
+			amba_writew(pinfo->regbase + SD_EISEN_OFFSET, pslotinfo->sd_eisen);
+			amba_writew(pinfo->regbase + SD_NIXEN_OFFSET, pslotinfo->sd_nixen);
+			amba_writew(pinfo->regbase + SD_EIXEN_OFFSET, pslotinfo->sd_eixen);
+			pslotinfo->mmc->caps |= MMC_CAP_NONREMOVABLE;
+			mdelay(10);
+			ambarella_sd_set_clk(pslotinfo->mmc, &pinfo->controller_ios);
+			ambarella_sd_set_bus(pslotinfo->mmc, &pinfo->controller_ios);
+			mdelay(10);
+			ambarella_sd_enable_int(pslotinfo->mmc, SD_NISEN_CARD);
+		} else {
+			clk_set_rate(pinfo->clk, pslotinfo->mmc->f_max);
+			ambarella_sd_reset_all(pslotinfo->mmc);
+		}
 	}
-	enable_irq(pinfo->irq);
 
 	for (i = 0; i < pinfo->slot_num; i++) {
 		pslotinfo = pinfo->pslotinfo[i];
-		retval = mmc_resume_host(pslotinfo->mmc);
-		if (retval) {
-			ambsd_err(pslotinfo,
-			"mmc_resume_host[%d] failed[%d]!\n",
-			i, retval);
+		if (pslotinfo->mmc) {
+			retval = mmc_resume_host(pslotinfo->mmc);
+			if (retval) {
+				ambsd_err(pslotinfo,
+				"mmc_resume_host[%d] failed[%d]!\n", i, retval);
+			}
 		}
 	}
 
@@ -2217,6 +2744,37 @@ static int ambarella_sd_resume(struct platform_device *pdev)
 }
 #endif
 
+#ifdef CONFIG_AMBARELLA_EMMC_BOOT
+void ambarella_sd_shutdown (struct platform_device *pdev)
+{
+	struct ambarella_sd_controller_info *pinfo;
+	struct ambarella_sd_mmc_info *pslotinfo;
+	struct mmc_host *host;
+	struct mmc_command cmd = {0};
+	int i;
+
+	pinfo = platform_get_drvdata(pdev);
+
+	for (i = 0; i < pinfo->slot_num; i++) {
+		pslotinfo = pinfo->pslotinfo[i];
+		host = pslotinfo->mmc;
+		if((host == G_mmc[0]) && ((system_state == SYSTEM_RESTART) ||
+			(system_state == SYSTEM_HALT))) {
+			if (mmc_try_claim_host(pslotinfo->mmc)) {
+				cmd.opcode = 0;
+				cmd.arg = 0xf0f0f0f0;
+				cmd.flags = MMC_RSP_NONE;
+
+				mmc_wait_for_cmd(pslotinfo->mmc, &cmd, 0);
+			} else {
+				dev_err(&pdev->dev, "Unable to claim host!\n");
+			}
+		}
+	}
+
+}
+#endif
+
 static const struct of_device_id ambarella_mmc_dt_ids[] = {
 	{ .compatible = "ambarella,sdmmc", },
 	{ /* sentinel */ }
@@ -2230,6 +2788,10 @@ static struct platform_driver ambarella_sd_driver = {
 	.suspend	= ambarella_sd_suspend,
 	.resume		= ambarella_sd_resume,
 #endif
+
+#ifdef CONFIG_AMBARELLA_EMMC_BOOT
+	.shutdown	= ambarella_sd_shutdown,
+#endif
 	.driver		= {
 		.name	= "ambarella-sd",
 		.owner	= THIS_MODULE,
diff --git a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c
index 84b054b..e742761 100644
--- a/drivers/mmc/host/atmel-mci.c
+++ b/drivers/mmc/host/atmel-mci.c
@@ -1295,7 +1295,7 @@ static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 	if (ios->clock) {
 		unsigned int clock_min = ~0U;
-		u32 clkdiv;
+		int clkdiv;
 
 		spin_lock_bh(&host->lock);
 		if (!host->mode_reg) {
@@ -1320,7 +1320,12 @@ static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		/* Calculate clock divider */
 		if (host->caps.has_odd_clk_div) {
 			clkdiv = DIV_ROUND_UP(host->bus_hz, clock_min) - 2;
-			if (clkdiv > 511) {
+			if (clkdiv < 0) {
+				dev_warn(&mmc->class_dev,
+					 "clock %u too fast; using %lu\n",
+					 clock_min, host->bus_hz / 2);
+				clkdiv = 0;
+			} else if (clkdiv > 511) {
 				dev_warn(&mmc->class_dev,
 				         "clock %u too slow; using %lu\n",
 				         clock_min, host->bus_hz / (511 + 2));
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index f4f3038..faeda85 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -1740,7 +1740,7 @@ static struct amba_id mmci_ids[] = {
 	{
 		.id     = 0x00280180,
 		.mask   = 0x00ffffff,
-		.data	= &variant_u300,
+		.data	= &variant_nomadik,
 	},
 	{
 		.id     = 0x00480180,
diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
index d25f9ab..d33bb95 100644
--- a/drivers/mmc/host/sdhci-esdhc.h
+++ b/drivers/mmc/host/sdhci-esdhc.h
@@ -40,7 +40,7 @@
 #define ESDHC_DMA_SYSCTL	0x40c
 #define ESDHC_DMA_SNOOP		0x00000040
 
-#define ESDHC_HOST_CONTROL_RES	0x05
+#define ESDHC_HOST_CONTROL_RES	0x01
 
 static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 {
diff --git a/drivers/mmc/host/sdhci-pxav3.c b/drivers/mmc/host/sdhci-pxav3.c
index 4edb24b..c24fbc5 100644
--- a/drivers/mmc/host/sdhci-pxav3.c
+++ b/drivers/mmc/host/sdhci-pxav3.c
@@ -255,6 +255,7 @@ static int sdhci_pxav3_probe(struct platform_device *pdev)
 		mmc_of_parse(host->mmc);
 		sdhci_get_of_property(pdev);
 		pdata = pxav3_get_mmc_pdata(dev);
+		pdev->dev.platform_data = pdata;
 	} else if (pdata) {
 		/* on-chip device */
 		if (pdata->flags & PXA_FLAG_CARD_PERMANENT)
diff --git a/drivers/mtd/devices/ambarella_spinor.c b/drivers/mtd/devices/ambarella_spinor.c
index 0979248..81b056a 100644
--- a/drivers/mtd/devices/ambarella_spinor.c
+++ b/drivers/mtd/devices/ambarella_spinor.c
@@ -65,7 +65,7 @@
 #define JEDEC_MFR(_jedec_id)    ((_jedec_id) >> 16)
 
 #define PART_DEV_SPINOR		(0x08)
-
+static u16 spi_addr_mode = 3;
 
 /****************************************************************************/
 
@@ -116,11 +116,43 @@ static inline int write_disable(struct amb_norflash *flash)
  */
 static inline int set_4byte(struct amb_norflash *flash, u32 jedec_id, int enable)
 {
-    flash->command[0] = OPCODE_BRWR;
-    ambspi_send_cmd(flash, flash->command[0], 0, (enable << 7), 1);
-    return 0;
-}
+	int ret = 0;
 
+	switch (JEDEC_MFR(jedec_id)) {
+		case CFI_MFR_MACRONIX:
+		case 0xEF: /* winbond */
+		case 0xC8: /* GD */
+			flash->command[0] = enable ? OPCODE_EN4B : OPCODE_EX4B;
+			return ambspi_send_cmd(flash, flash->command[0], 0, 0, 0);
+		case CFI_MFR_ST: /*Micron*/
+			write_enable(flash);
+			flash->command[0] = enable ? OPCODE_EN4B : OPCODE_EX4B;
+			ret = ambspi_send_cmd(flash, flash->command[0], 0, 0, 0);
+			write_disable(flash);
+			return ret;
+		default:
+			/* Spansion style */
+			flash->command[0] = OPCODE_BRWR;
+			flash->command[1] = enable << 7;
+			return ambspi_send_cmd(flash, flash->command[0], 0, flash->command[1], 1);
+	}
+}
+/*
+mode 1 - enter 4 byte spi addr mode
+	 0 - exit  4 byte spi addr mode
+*/
+static void check_set_spinor_addr_mode(struct amb_norflash *flash, int mode)
+{
+	if (flash->addr_width == 4) {
+		if (spi_addr_mode == 3 && mode){
+			set_4byte(flash, flash->jedec_id, 1);
+			spi_addr_mode = 4;
+		} else if (spi_addr_mode == 4 && mode == 0){
+			set_4byte(flash, flash->jedec_id, 0);
+			spi_addr_mode = 3;
+		}
+	}
+}
 /*
  * Service routine to read status register until ready, or timeout occurs.
  * Returns non-zero if error.
@@ -214,11 +246,12 @@ static int amba_erase(struct mtd_info *mtd, struct erase_info *instr)
     len = instr->len;
 
     mutex_lock(&flash->lock);
-
+	check_set_spinor_addr_mode(flash, 1);
     /* whole-chip erase? */
     if (len == flash->mtd.size) {
         if (erase_chip(flash)) {
             instr->state = MTD_ERASE_FAILED;
+			check_set_spinor_addr_mode(flash, 0);
             mutex_unlock(&flash->lock);
             return -EIO;
         }
@@ -233,15 +266,16 @@ static int amba_erase(struct mtd_info *mtd, struct erase_info *instr)
         while (len) {
             if (erase_sector(flash, addr)) {
                 instr->state = MTD_ERASE_FAILED;
+				check_set_spinor_addr_mode(flash, 0);
                 mutex_unlock(&flash->lock);
-                return -EIO;
+				return -EIO;
             }
 
             addr += mtd->erasesize;
             len -= mtd->erasesize;
         }
     }
-
+	check_set_spinor_addr_mode(flash, 0);
     mutex_unlock(&flash->lock);
 
     instr->state = MTD_ERASE_DONE;
@@ -271,7 +305,7 @@ static int amba_erase(struct mtd_info *mtd, struct erase_info *instr)
         mutex_unlock(&flash->lock);
         return 1;
     }
-
+	check_set_spinor_addr_mode(flash, 1);
     /* Set up the write data buffer. */
     opcode = flash->fast_read ? OPCODE_FAST_READ : OPCODE_NORM_READ;
     flash->command[0] = opcode;
@@ -282,24 +316,29 @@ static int amba_erase(struct mtd_info *mtd, struct erase_info *instr)
         if (needread >= AMBA_SPINOR_DMA_BUFF_SIZE) {
             ret = ambspi_read_data(flash, from+offset, AMBA_SPINOR_DMA_BUFF_SIZE);
             if(ret) {
-                dev_err((const struct device *)&flash->dev,
-                        "SPI NOR read error from=%x len=%d\r\n", (u32)(from+offset), AMBA_SPINOR_DMA_BUFF_SIZE);
-                return -1;
+				dev_err((const struct device *)&flash->dev,
+						"SPI NOR read error from=%x len=%d\r\n", (u32)(from+offset), AMBA_SPINOR_DMA_BUFF_SIZE);
+				check_set_spinor_addr_mode(flash, 0);
+				mutex_unlock(&flash->lock);
+				return -1;
             }
-            memcpy(buf+offset, flash->dmabuf, AMBA_SPINOR_DMA_BUFF_SIZE);
-            offset += AMBA_SPINOR_DMA_BUFF_SIZE;
+			memcpy(buf+offset, flash->dmabuf, AMBA_SPINOR_DMA_BUFF_SIZE);
+			offset += AMBA_SPINOR_DMA_BUFF_SIZE;
         }else{
-            ret = ambspi_read_data(flash, from+offset, needread);
-            if(ret) {
-                dev_err((const struct device *)&flash->dev,
-                    "SPI NOR read error from=%x len=%d\r\n", (u32)(from+offset), needread);
-                return -1;
+			ret = ambspi_read_data(flash, from+offset, needread);
+			if(ret) {
+				dev_err((const struct device *)&flash->dev,
+						"SPI NOR read error from=%x len=%d\r\n", (u32)(from+offset), needread);
+				check_set_spinor_addr_mode(flash, 0);
+				mutex_unlock(&flash->lock);
+				return -1;
             }
             memcpy(buf+offset, flash->dmabuf, needread);
             offset += needread;
         }
     }
     *retlen = offset;
+	check_set_spinor_addr_mode(flash, 0);
     mutex_unlock(&flash->lock);
     return 0;
 }
@@ -321,7 +360,7 @@ static int amba_write(struct mtd_info *mtd, loff_t to, size_t len,
         mutex_unlock(&flash->lock);
         return 1;
     }
-
+	check_set_spinor_addr_mode(flash, 1);
     write_enable(flash);
 
     /* Set up the opcode in the write buffer. */
@@ -357,6 +396,7 @@ static int amba_write(struct mtd_info *mtd, loff_t to, size_t len,
                 }
                 /* write the next page to flash */
                 if (wait_till_ready(flash)) {
+					check_set_spinor_addr_mode(flash, 0);
                     mutex_unlock(&flash->lock);
                     return 1;
                 }
@@ -366,7 +406,7 @@ static int amba_write(struct mtd_info *mtd, loff_t to, size_t len,
             }
         }
     }
-
+	check_set_spinor_addr_mode(flash, 0);
     mutex_unlock(&flash->lock);
     return 0;
 }
@@ -416,6 +456,7 @@ static const struct ambid_t amb_ids[] = {
     { "s70fl01gs", INFO(0x010220, 0x4d00, 256 * 1024, 256, 512, 50000000, 0) },
 	{ "n25q256a", INFO(0x20ba19, 0, 64 * 1024, 512, 256, 50000000, 0) },
 	{ "mx25l25645g", INFO(0xc22019, 0, 64 * 1024, 512, 256, 50000000, 0) },
+	{ "mx66l51235f", INFO(0xc2201a, 0, 64 * 1024, 1024, 256, 50000000, 0) },
 	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, 256, 50000000, 0) },
 	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512, 256, 50000000, 0) },
 	{ "gd25q128", INFO(0xc84018, 0, 64 * 1024, 256, 256, 50000000, 0) },
@@ -588,9 +629,13 @@ static int    amb_spi_nor_probe(struct platform_device *pdev)
         /* enable 4-byte addressing if the device exceeds 16MiB */
         if (flash->mtd.size > 0x1000000) {
             flash->addr_width = 4;
-            set_4byte(flash, info->jedec_id, 1);
-        } else
-            flash->addr_width = 3;
+			/* We have set 4-bytes mode in bootloader */
+            //set_4byte(flash, info->jedec_id, 1);
+			spi_addr_mode = 4;
+        } else {
+			flash->addr_width = 3;
+			spi_addr_mode = 3;
+		}
     }
 
 	flash->jedec_id	= info->jedec_id;
@@ -617,6 +662,7 @@ static int    amb_spi_nor_probe(struct platform_device *pdev)
 	if (errCode < 0)
 		goto amb_spi_nor_probe_free_command;
 
+	check_set_spinor_addr_mode(flash, 0);
     printk("SPI NOR Controller probed\r\n");
     return 0;
 
@@ -676,6 +722,37 @@ static void amb_spi_nor_shutdown(struct platform_device *pdev)
 	}
 }
 
+#ifdef CONFIG_PM
+static int amb_spi_nor_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	int	errorCode = 0;
+	struct amb_norflash	*flash;
+
+	flash = platform_get_drvdata(pdev);
+
+	dev_dbg(&pdev->dev, "%s exit with %d @ %d\n",
+		__func__, errorCode, state.event);
+
+	return errorCode;
+}
+
+static int amb_spi_nor_resume(struct platform_device *pdev)
+{
+	int	errorCode = 0;
+	struct amb_norflash	*flash;
+
+	flash = platform_get_drvdata(pdev);
+	ambspi_init(flash);
+	if (flash->addr_width == 4)
+		set_4byte(flash, flash->jedec_id, 1);
+
+	dev_dbg(&pdev->dev, "%s exit with %d\n", __func__, errorCode);
+
+	return errorCode;
+}
+#endif
+
 static const struct of_device_id ambarella_spi_nor_of_match[] = {
     {.compatible = "ambarella,spinor", },
     {},
@@ -691,7 +768,10 @@ static struct platform_driver amb_spi_nor_driver = {
 	.probe = amb_spi_nor_probe,
 	.remove = amb_spi_nor_remove,
 	.shutdown = amb_spi_nor_shutdown,
-
+#ifdef CONFIG_PM
+	.suspend	= amb_spi_nor_suspend,
+	.resume		= amb_spi_nor_resume,
+#endif
 	/* REVISIT: many of these chips have deep power-down modes, which
 	 * should clearly be entered on suspend() to minimize power use.
 	 * And also when they're otherwise idle...
diff --git a/drivers/mtd/devices/spinor.c b/drivers/mtd/devices/spinor.c
index bb57a24..b1af28c 100644
--- a/drivers/mtd/devices/spinor.c
+++ b/drivers/mtd/devices/spinor.c
@@ -421,6 +421,7 @@ EXPORT_SYMBOL_GPL(ambspi_read_data);
 
 static u32 get_ssi3_freq_hz(void)
 {
+#define PLL_OUT_ENET   300000000
 	u32 val;
 
 	val = amba_rct_readl(CG_SSI3_REG);
@@ -430,63 +431,64 @@ static u32 get_ssi3_freq_hz(void)
 	if (val == 0)
 		val = 1;
 
-	return (clk_get_rate(clk_get(NULL, "gclk_core")) << 1) / val;
+	//return (clk_get_rate(clk_get(NULL, "gclk_core")) << 1) / val;
+	return (PLL_OUT_ENET) / val;
 }
 
 int ambspi_init(struct amb_norflash *flash)
 {
     u32 divider, tmp = 0;
-#if 0
-	divider = get_ssi3_freq_hz() / flash->clk;
-    tmp = amba_readl(flash->regbase + REG08);
-    REGPREP(tmp, REG08_CHIPSEL_MASK, REG08_CHIPSEL_SHIFT, ~(1 << SPINOR_DEV));
-    REGPREP(tmp, REG08_CLKDIV_MASK, REG08_CLKDIV_SHIFT, divider);
-    REGPREP(tmp, REG08_FLOWCON_MASK, REG08_FLOWCON_SHIFT, 1);
-    REGPREP(tmp, REG08_HOLDPIN_MASK, REG08_HOLDPIN_SHIFT, 3);
-    amba_writel(flash->regbase + REG08, tmp);
-
-    tmp = amba_readl(flash->regbase + REG00);
-    REGPREP(tmp, REG00_DATALEN_MASK, REG00_DATALEN_SHIFT, 0);
-    REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, 0);
-    REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, 0);
-    REGPREP(tmp, REG00_CMDLEN_MASK, REG00_CMDLEN_SHIFT, 1);
-    amba_writel(flash->regbase + REG00, tmp);
 
-    tmp = amba_readl(flash->regbase + REG04);
-    REGPREP(tmp, REG04_WRITEEN_MASK, REG04_WRITEEN_SHIFT, 0);
-    REGPREP(tmp, REG04_READEN_MASK, REG04_READEN_SHIFT, 0);
-    REGPREP(tmp, REG04_DATALANE_MASK, REG04_DATALANE_SHIFT, 0);
-    REGPREP(tmp, REG04_ADDRLANE_MASK, REG04_ADDRLANE_SHIFT, 0);
-    REGPREP(tmp, REG04_CMDLANE_MASK, REG04_CMDLANE_SHIFT, 0);
-    REGPREP(tmp, REG04_LSBFRT_MASK, REG04_LSBFRT_SHIFT, 0);
-    REGPREP(tmp, REG04_CMDDTR_MASK, REG04_CMDDTR_SHIFT, 0);
-    amba_writel(flash->regbase + REG04, tmp);
-#endif
-    tmp = 0x20;
-    amba_writel(flash->regbase + REG30, tmp);
-
-    tmp = 0;
-    REGPREP(tmp, REG40_TXFIFORESET_MASK, REG40_TXFIFORESET_SHIFT, 1);
-    amba_writel(flash->regbase + REG40, tmp);
-    tmp = 0;
-    REGPREP(tmp, REG44_RXFIFORESET_MASK, REG44_RXFIFORESET_SHIFT, 1);
-    amba_writel(flash->regbase + REG44, tmp);
+	divider = get_ssi3_freq_hz() / flash->clk;
+	tmp = amba_readl(flash->regbase + REG08);
+	REGPREP(tmp, REG08_CHIPSEL_MASK, REG08_CHIPSEL_SHIFT, ~(1 << SPINOR_DEV));
+	REGPREP(tmp, REG08_CLKDIV_MASK, REG08_CLKDIV_SHIFT, divider);
+	REGPREP(tmp, REG08_FLOWCON_MASK, REG08_FLOWCON_SHIFT, 1);
+	REGPREP(tmp, REG08_HOLDPIN_MASK, REG08_HOLDPIN_SHIFT, 3);
+	amba_writel(flash->regbase + REG08, tmp);
+
+	tmp = amba_readl(flash->regbase + REG00);
+	REGPREP(tmp, REG00_DATALEN_MASK, REG00_DATALEN_SHIFT, 0);
+	REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, 0);
+	REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, 0);
+	REGPREP(tmp, REG00_CMDLEN_MASK, REG00_CMDLEN_SHIFT, 1);
+	amba_writel(flash->regbase + REG00, tmp);
+
+	tmp = amba_readl(flash->regbase + REG04);
+	REGPREP(tmp, REG04_WRITEEN_MASK, REG04_WRITEEN_SHIFT, 0);
+	REGPREP(tmp, REG04_READEN_MASK, REG04_READEN_SHIFT, 0);
+	REGPREP(tmp, REG04_DATALANE_MASK, REG04_DATALANE_SHIFT, 0);
+	REGPREP(tmp, REG04_ADDRLANE_MASK, REG04_ADDRLANE_SHIFT, 0);
+	REGPREP(tmp, REG04_CMDLANE_MASK, REG04_CMDLANE_SHIFT, 0);
+	REGPREP(tmp, REG04_LSBFRT_MASK, REG04_LSBFRT_SHIFT, 0);
+	REGPREP(tmp, REG04_CMDDTR_MASK, REG04_CMDDTR_SHIFT, 0);
+	amba_writel(flash->regbase + REG04, tmp);
+
+	tmp = 0x20;
+	amba_writel(flash->regbase + REG30, tmp);
+
+	tmp = 0;
+	REGPREP(tmp, REG40_TXFIFORESET_MASK, REG40_TXFIFORESET_SHIFT, 1);
+	amba_writel(flash->regbase + REG40, tmp);
+	tmp = 0;
+	REGPREP(tmp, REG44_RXFIFORESET_MASK, REG44_RXFIFORESET_SHIFT, 1);
+	amba_writel(flash->regbase + REG44, tmp);
 
     /* after reset fifo, the 0x28 will become 0x10,
     *so , read REG200 times to clear the 0x28,  this is a bug in hardware
     */
 	while (amba_readl(flash->regbase + REG28) != 0) {
-        tmp = amba_readl(flash->regbase + REG200);
-    }
+		tmp = amba_readl(flash->regbase + REG200);
+	}
 
-    tmp = 0;
-    REGPREP(tmp, REG1C_TXFIFOLV_MASK, REG1C_TXFIFOLV_SHIFT, 0x7f);
-    amba_writel(flash->regbase + REG1C, tmp);
+	tmp = 0;
+	REGPREP(tmp, REG1C_TXFIFOLV_MASK, REG1C_TXFIFOLV_SHIFT, 0x7f);
+	amba_writel(flash->regbase + REG1C, tmp);
 
-    tmp = 0;
-    REGPREP(tmp, REG20_RXFIFOLV_MASK, REG20_RXFIFOLV_SHIFT, 0x7f);
-    amba_writel(flash->regbase + REG20, tmp);
+	tmp = 0;
+	REGPREP(tmp, REG20_RXFIFOLV_MASK, REG20_RXFIFOLV_SHIFT, 0x7f);
+	amba_writel(flash->regbase + REG20, tmp);
 
-    return 0;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(ambspi_init);
diff --git a/drivers/mtd/maps/dc21285.c b/drivers/mtd/maps/dc21285.c
index f8a7dd1..70a3db3 100644
--- a/drivers/mtd/maps/dc21285.c
+++ b/drivers/mtd/maps/dc21285.c
@@ -38,9 +38,9 @@ static void nw_en_write(void)
 	 * we want to write a bit pattern XXX1 to Xilinx to enable
 	 * the write gate, which will be open for about the next 2ms.
 	 */
-	spin_lock_irqsave(&nw_gpio_lock, flags);
+	raw_spin_lock_irqsave(&nw_gpio_lock, flags);
 	nw_cpld_modify(CPLD_FLASH_WR_ENABLE, CPLD_FLASH_WR_ENABLE);
-	spin_unlock_irqrestore(&nw_gpio_lock, flags);
+	raw_spin_unlock_irqrestore(&nw_gpio_lock, flags);
 
 	/*
 	 * let the ISA bus to catch on...
diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c
index 5073cbc..32d5e40 100644
--- a/drivers/mtd/mtd_blkdevs.c
+++ b/drivers/mtd/mtd_blkdevs.c
@@ -199,6 +199,7 @@ static int blktrans_open(struct block_device *bdev, fmode_t mode)
 		return -ERESTARTSYS; /* FIXME: busy loop! -arnd*/
 
 	mutex_lock(&dev->lock);
+	mutex_lock(&mtd_table_mutex);
 
 	if (dev->open)
 		goto unlock;
@@ -222,6 +223,7 @@ static int blktrans_open(struct block_device *bdev, fmode_t mode)
 
 unlock:
 	dev->open++;
+	mutex_unlock(&mtd_table_mutex);
 	mutex_unlock(&dev->lock);
 	blktrans_dev_put(dev);
 	return ret;
@@ -232,6 +234,7 @@ error_release:
 error_put:
 	module_put(dev->tr->owner);
 	kref_put(&dev->ref, blktrans_dev_release);
+	mutex_unlock(&mtd_table_mutex);
 	mutex_unlock(&dev->lock);
 	blktrans_dev_put(dev);
 	return ret;
@@ -245,6 +248,7 @@ static void blktrans_release(struct gendisk *disk, fmode_t mode)
 		return;
 
 	mutex_lock(&dev->lock);
+	mutex_lock(&mtd_table_mutex);
 
 	if (--dev->open)
 		goto unlock;
@@ -258,6 +262,7 @@ static void blktrans_release(struct gendisk *disk, fmode_t mode)
 		__put_mtd_device(dev->mtd);
 	}
 unlock:
+	mutex_unlock(&mtd_table_mutex);
 	mutex_unlock(&dev->lock);
 	blktrans_dev_put(dev);
 }
diff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c
index 3014933..f8013c1 100644
--- a/drivers/mtd/mtdpart.c
+++ b/drivers/mtd/mtdpart.c
@@ -634,8 +634,10 @@ int add_mtd_partitions(struct mtd_info *master,
 
 	for (i = 0; i < nbparts; i++) {
 		slave = allocate_partition(master, parts + i, i, cur_offset);
-		if (IS_ERR(slave))
+		if (IS_ERR(slave)) {
+			del_mtd_partitions(master);
 			return PTR_ERR(slave);
+		}
 
 		mutex_lock(&mtd_partitions_mutex);
 		list_add(&slave->list, &mtd_partitions);
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 4606284..f1f1894 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -48,6 +48,13 @@ config MTD_NAND_AMBARELLA
 	  This enables the SLC NAND flash controller on the Ambarella
 	  Media SoC.
 
+config MTD_SPINAND_AMBARELLA
+	tristate "Ambarella Media Soc SPI NAND support"
+	depends on PLAT_AMBARELLA
+	help
+	  This enables the SPI NAND flash controller on the Ambarella
+	  Media SoC.
+
 config MTD_NAND_DENALI
         tristate "Support Denali NAND controller"
         help
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 383b948..d60ff87 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -52,5 +52,6 @@ obj-$(CONFIG_MTD_NAND_JZ4740)		+= jz4740_nand.o
 obj-$(CONFIG_MTD_NAND_GPMI_NAND)	+= gpmi-nand/
 obj-$(CONFIG_MTD_NAND_XWAY)		+= xway_nand.o
 obj-$(CONFIG_MTD_NAND_BCM47XXNFLASH)	+= bcm47xxnflash/
+obj-$(CONFIG_MTD_SPINAND_AMBARELLA)	+= ambarella_spinand.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/ambarella_nand.c b/drivers/mtd/nand/ambarella_nand.c
index e601979..1e86be0 100644
--- a/drivers/mtd/nand/ambarella_nand.c
+++ b/drivers/mtd/nand/ambarella_nand.c
@@ -46,6 +46,7 @@
 #include <plat/dma.h>
 #include <plat/nand.h>
 #include <plat/fio.h>
+#include <plat/rct.h>
 #include <plat/event.h>
 
 #define AMBARELLA_NAND_DMA_BUFFER_SIZE	4096
@@ -244,7 +245,7 @@ static void nand_amb_enable_bch(struct ambarella_nand_info *nand_info)
 
 	fio_dsm_ctr |= (FIO_DSM_EN | FIO_DSM_MAJP_2KB);
 	dma_dsm_ctr |= (DMA_DSM_EN | DMA_DSM_MAJP_2KB);
-	fio_ctr_reg |= (FIO_CTR_RS | FIO_CTR_CO);
+	fio_ctr_reg |= (FIO_CTR_RS | FIO_CTR_CO | FIO_CTR_SKIP_BLANK);
 
 	if (nand_info->ecc_bits == 6) {
 	  fio_dsm_ctr |= FIO_DSM_SPJP_64B;
@@ -294,24 +295,56 @@ static void nand_amb_disable_bch(struct ambarella_nand_info *nand_info)
 	amba_writel(nand_info->fdmaregbase + FDMA_DSM_CTR_OFFSET, 0);
 }
 
-static int nand_bch_spare_cmp(struct ambarella_nand_info *nand_info)
+static int count_zero_bits(u8 *buf, int size, int max_bits)
 {
+	int i, zero_bits = 0;
+
+	for (i = 0; i < size; i++) {
+		zero_bits += hweight8(~buf[i]);
+		if (zero_bits > max_bits)
+			break;
+	}
+	return zero_bits;
+}
+
+static int nand_bch_check_blank_page(struct ambarella_nand_info *nand_info, int needset)
+{
+	struct nand_chip *chip = &nand_info->chip;
+	int eccsteps = chip->ecc.steps;
+	int zeroflip = 0;
+	int oob_subset;
+	int zero_bits = 0;
 	u32 i;
+	u8 *bufpos;
 	u8 *bsp;
 
+	bufpos = nand_info->dmabuf;
 	bsp = nand_info->dmabuf + nand_info->mtd.writesize;
+	oob_subset = nand_info->mtd.oobsize / eccsteps;
 
-	for (i = 0; i < nand_info->mtd.oobsize; i++) {
-		if (bsp[i] != 0xff)
-			break;
+	for (i = 0; i < eccsteps; i++) {
+		zero_bits = count_zero_bits(bufpos, chip->ecc.size,
+								chip->ecc.strength);
+		if (zero_bits > chip->ecc.strength)
+			return -1;
+
+		if (zero_bits)
+			zeroflip = 1;
+
+		zero_bits += count_zero_bits(bsp, oob_subset,
+								chip->ecc.strength);
+		if (zero_bits > chip->ecc.strength)
+			return -1;
+
+		bufpos += chip->ecc.size;
+		bsp += oob_subset;
 	}
 
-	if (i == nand_info->mtd.oobsize)
-		return 0;
+	if (needset && zeroflip)
+		memset(nand_info->dmabuf, 0xff, nand_info->mtd.writesize);
 
-	return -1;
+	return zeroflip;
 }
-
 static void amb_nand_set_timing(struct ambarella_nand_info *nand_info)
 {
 	u8 tcls, tals, tcs, tds;
@@ -351,6 +384,10 @@ static void amb_nand_set_timing(struct ambarella_nand_info *nand_info)
 		NAND_TIMING_LSHIFT8BIT(tcs) |
 		NAND_TIMING_LSHIFT0BIT(tds);
 
+	/* use default timing if gclk_core <= 96MHz */
+	if (clk <= 96)
+		val = 0x20202020;
+
 	amba_writel(nand_info->regbase + FLASH_TIM0_OFFSET, val);
 
 	/* timing 1 */
@@ -370,6 +407,10 @@ static void amb_nand_set_timing(struct ambarella_nand_info *nand_info)
 		NAND_TIMING_LSHIFT8BIT(tch) |
 		NAND_TIMING_LSHIFT0BIT(tdh);
 
+	/* use default timing if gclk_core <= 96MHz */
+	if (clk <= 96)
+		val = 0x20202020;
+
 	amba_writel(nand_info->regbase + FLASH_TIM1_OFFSET, val);
 
 	/* timing 2 */
@@ -389,6 +430,10 @@ static void amb_nand_set_timing(struct ambarella_nand_info *nand_info)
 		NAND_TIMING_LSHIFT8BIT(twb) |
 		NAND_TIMING_LSHIFT0BIT(trr);
 
+	/* use default timing if gclk_core <= 96MHz */
+	if (clk <= 96)
+		val = 0x20204020;
+
 	amba_writel(nand_info->regbase + FLASH_TIM2_OFFSET, val);
 
 	/* timing 3 */
@@ -408,6 +453,10 @@ static void amb_nand_set_timing(struct ambarella_nand_info *nand_info)
 		NAND_TIMING_LSHIFT8BIT(trb) |
 		NAND_TIMING_LSHIFT0BIT(tceh);
 
+	/* use default timing if gclk_core <= 96MHz */
+	if (clk <= 96)
+		val = 0x20202020;
+
 	amba_writel(nand_info->regbase + FLASH_TIM3_OFFSET, val);
 
 	/* timing 4 */
@@ -417,7 +466,7 @@ static void amb_nand_set_timing(struct ambarella_nand_info *nand_info)
 	twhr = NAND_TIMING_RSHIFT8BIT(t);
 	tir = NAND_TIMING_RSHIFT0BIT(t);
 
-	trdelay = nand_timing_calc(clk, 1, trdelay);
+	trdelay = trp + treh;
 	tclr = nand_timing_calc(clk, 0, tclr);
 	twhr = nand_timing_calc(clk, 0, twhr);
 	tir = nand_timing_calc(clk, 0, tir);
@@ -427,6 +476,10 @@ static void amb_nand_set_timing(struct ambarella_nand_info *nand_info)
 		NAND_TIMING_LSHIFT8BIT(twhr) |
 		NAND_TIMING_LSHIFT0BIT(tir);
 
+	/* use default timing if gclk_core <= 96MHz */
+	if (clk <= 96)
+		val = 0x20202020;
+
 	amba_writel(nand_info->regbase + FLASH_TIM4_OFFSET, val);
 
 	/* timing 5 */
@@ -444,6 +497,10 @@ static void amb_nand_set_timing(struct ambarella_nand_info *nand_info)
 		NAND_TIMING_LSHIFT8BIT(trhz) |
 		NAND_TIMING_LSHIFT0BIT(tar);
 
+	/* use default timing if gclk_core <= 96MHz */
+	if (clk <= 96)
+		val = 0x20202020;
+
 	amba_writel(nand_info->regbase + FLASH_TIM5_OFFSET, val);
 }
 
@@ -485,9 +542,6 @@ static irqreturn_t nand_fiocmd_isr_handler(int irq, void *dev_id)
 	val = amba_readl(nand_info->regbase + FIO_STA_OFFSET);
 
 	if (val & FIO_STA_FI) {
-		amba_clrbitsl(nand_info->regbase + FIO_CTR_OFFSET,
-			(FIO_CTR_RS | FIO_CTR_SE | FIO_CTR_CO));
-
 		amba_writel(nand_info->regbase + FLASH_INT_OFFSET, 0x0);
 
 		atomic_clear_mask(0x1, (unsigned long *)&nand_info->irq_flag);
@@ -765,6 +819,7 @@ static int nand_amb_request(struct ambarella_nand_info *nand_info)
 				nand_ctr_reg |= (NAND_CTR_SE | NAND_CTR_SA);
 
 			fio_ctr_reg = amba_readl(nand_info->regbase + FIO_CTR_OFFSET);
+			fio_ctr_reg &= ~(FIO_CTR_CO | FIO_CTR_RS);
 
 			if (nand_info->area == SPARE_ONLY ||
 				nand_info->area == SPARE_ECC  ||
@@ -822,6 +877,7 @@ static int nand_amb_request(struct ambarella_nand_info *nand_info)
 				nand_ctr_reg |= (NAND_CTR_SE | NAND_CTR_SA);
 
 			fio_ctr_reg = amba_readl(nand_info->regbase + FIO_CTR_OFFSET);
+			fio_ctr_reg &= ~(FIO_CTR_CO | FIO_CTR_RS);
 
 			if (nand_info->area == SPARE_ONLY ||
 				nand_info->area == SPARE_ECC  ||
@@ -883,10 +939,14 @@ static int nand_amb_request(struct ambarella_nand_info *nand_info)
 		if (nand_amb_is_hw_bch(nand_info)) {
 			if (cmd == NAND_AMB_CMD_READ) {
 				if (nand_info->fio_ecc_sta & FIO_ECC_RPT_FAIL) {
-					int ret = 0;
-					/* Workaround for page never used, BCH will be failed */
-					if (nand_info->area == MAIN_ECC || nand_info->area == SPARE_ECC)
-						ret = nand_bch_spare_cmp(nand_info);
+					int ret;
+
+					/* Workaround for some chips which will
+					 * report ECC failed for blank page. */
+					if (FIO_SUPPORT_SKIP_BLANK_ECC)
+						ret = -1;
+					else
+						ret = nand_bch_check_blank_page(nand_info, 1);
 
 					if (ret < 0) {
 						nand_info->mtd.ecc_stats.failed++;
@@ -895,17 +955,20 @@ static int nand_amb_request(struct ambarella_nand_info *nand_info)
 							nand_info->fio_ecc_sta, nand_info->addr);
 					}
 				} else if (nand_info->fio_ecc_sta & FIO_ECC_RPT_ERR) {
+					unsigned int corrected;
+					corrected = 1;
 					if (NAND_ECC_RPT_NUM_SUPPORT) {
+						corrected = (nand_info->fio_ecc_sta >> 16) & 0x000F;
 						dev_info(nand_info->dev, "BCH correct [%d]bit in block[%d]\n",
-						((nand_info->fio_ecc_sta >> 16) & 0x000F),
-						(nand_info->fio_ecc_sta & 0x00007FFF));
+						corrected, (nand_info->fio_ecc_sta & 0x00007FFF));
+					} else {
+						/* once bitflip and data corrected happened, BCH will keep on
+						 * to report bitflip in following read operations, even though
+						 * there is no bitflip happened really. So this is a workaround
+						 * to get it back. */
+						nand_amb_corrected_recovery(nand_info);
 					}
-					nand_info->mtd.ecc_stats.corrected++;
-					/* once bitflip and data corrected happened, BCH will keep on
-					 * to report bitflip in following read operations, even though
-					 * there is no bitflip happened really. So this is a workaround
-					 * to get it back. */
-					nand_amb_corrected_recovery(nand_info);
+					nand_info->mtd.ecc_stats.corrected += corrected;
 				}
 			} else if (cmd == NAND_AMB_CMD_PROGRAM) {
 				if (nand_info->fio_ecc_sta & FIO_ECC_RPT_FAIL) {
@@ -1438,9 +1501,11 @@ static int amb_nand_correct_data(struct mtd_info *mtd, u_char *buf,
 					"corrected bitflip %u\n", errloc[i]);
 			}
 		} else if (count < 0) {
-			count = nand_bch_spare_cmp(nand_info);
+			count = nand_bch_check_blank_page(nand_info , 0);
 			if (count < 0)
 				dev_err(nand_info->dev, "ecc unrecoverable error\n");
+			else if (count > 0)
+				memset(buf, 0xff, chip->ecc.size);
 		}
 
 		errorCode = count;
@@ -1522,8 +1587,16 @@ static int ambarella_nand_init_soft_bch(struct ambarella_nand_info *nand_info)
 static void ambarella_nand_init_hw(struct ambarella_nand_info *nand_info)
 {
 	/* reset FIO by RCT */
+	fio_select_lock(SELECT_FIO_FL);
 	ambarella_fio_rct_reset();
+	fio_unlock(SELECT_FIO_FL);
 
+	/* When suspend/resume mode, before exit random read mode,
+	 * we take time for make sure FIO reset well and
+	 * some dma req finished.
+	 */
+	if (nand_info->suspend == 1)
+		mdelay(2);
 	/* Exit random read mode */
 	amba_clrbitsl(nand_info->regbase + FIO_CTR_OFFSET, FIO_CTR_RR);
 
diff --git a/drivers/mtd/nand/ambarella_spinand.c b/drivers/mtd/nand/ambarella_spinand.c
new file mode 100644
index 0000000..a7c5f65
--- /dev/null
+++ b/drivers/mtd/nand/ambarella_spinand.c
@@ -0,0 +1,1414 @@
+/*
+ * drivers/mtd/ambarella_spinand.c
+ *
+ * History:
+ *    2015/10/26 - [Ken He] created file
+ *
+ * Copyright (C) 2014-2018, Ambarella, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+#include "ambarella_spinand.h"
+
+#define	MAX_WAIT_JIFFIES               (40 * HZ)
+#define MAX_WAIT_ERASE_JIFFIES         ((HZ * 400)/1000)
+#define AVERAGE_WAIT_JIFFIES           ((HZ * 20)/1000)
+
+#define CACHE_BUF	(2176)
+
+static struct nand_ecclayout ecc_layout_2KB_8bit = {
+       .eccbytes = 64,
+       .eccpos = {
+               64, 65, 66, 67, 68, 69, 70, 71,
+               72, 73, 74, 75, 76, 77, 78, 79,
+			   80, 81, 82, 83, 84, 85, 86, 87,
+			   88, 89, 90, 91, 92, 93, 94, 95,
+			   96, 97, 98, 99, 100, 101, 102, 103,
+			   104, 105, 106, 107, 108, 109, 110, 111,
+			   112, 113, 114, 115, 116, 117, 118, 119,
+			   120, 121, 122, 123, 124, 125, 126, 127
+       },
+       .oobfree = { {1, 63} }
+};
+
+/****************************************************************************/
+static inline struct amb_spinand *mtd_to_amb(struct mtd_info *mtd)
+{
+    return container_of(mtd, struct amb_spinand, mtd);
+}
+
+/* mtd_to_state - obtain the spinand state from the mtd info provided */
+static inline struct spinand_state *mtd_to_state(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct amb_spinand *flash = (struct amb_spinand *)chip->priv;
+	struct spinand_state *state = (struct spinand_state *)flash->priv;
+
+	return state;
+}
+/****************************************************************************/
+
+static int ambspinand_send_cmd(struct amb_spinand *flash, u32 cmd, u32 dummy_len, u32 data, u32 len)
+{
+    u32 tmp = 0;
+
+    tmp = amba_readl(flash->regbase + REG00);
+    REGPREP(tmp, REG00_DATALEN_MASK, REG00_DATALEN_SHIFT, 0);
+    REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, dummy_len);
+    REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, len);
+    REGPREP(tmp, REG00_CMDLEN_MASK, REG00_CMDLEN_SHIFT, 1);
+    amba_writel(flash->regbase + REG00, tmp);
+
+    tmp = amba_readl(flash->regbase + REG04);
+    REGPREP(tmp, REG04_WRITEEN_MASK, REG04_WRITEEN_SHIFT, 1);
+    REGPREP(tmp, REG04_READEN_MASK, REG04_READEN_SHIFT, 0);
+    REGPREP(tmp, REG04_DATALANE_MASK, REG04_DATALANE_SHIFT, 0);
+    REGPREP(tmp, REG04_ADDRLANE_MASK, REG04_ADDRLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDLANE_MASK, REG04_CMDLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDDTR_MASK, REG04_CMDDTR_SHIFT, 0);
+    REGPREP(tmp, REG04_LSBFRT_MASK, REG04_LSBFRT_SHIFT, 0);
+    amba_writel(flash->regbase + REG04, tmp);
+
+    tmp = amba_readl(flash->regbase + REG0C);
+    REGPREP(tmp, REG0C_CMD0_MASK, REG0C_CMD0_SHIFT, cmd);
+    amba_writel(flash->regbase + REG0C, tmp);
+
+    if(len){
+        tmp = data;
+        amba_writel(flash->regbase + REG14, tmp);
+    }
+
+    tmp = 0x0;
+    amba_writel(flash->regbase + REG30, tmp);
+
+    tmp = 0x20;
+    amba_writel(flash->regbase + REG3C, tmp);
+
+    tmp = amba_readl(flash->regbase + REG50);
+    REGPREP(tmp, REG50_STRTRX_MASK, REG50_STRTRX_SHIFT, 1);
+    amba_writel(flash->regbase + REG50, tmp);
+
+    for (;;){
+        tmp = amba_readl(flash->regbase + REG38);
+        if (REGDUMP(tmp, REG38_DATALENREACHINTR_MASK, REG38_DATALENREACHINTR_SHIFT) == 1){
+            return 0;
+        }
+    }
+    return -1;
+}
+
+static int ambspinand_read_reg(struct amb_spinand *flash, u32 datalen, u32 reg, u8 *value)
+{
+    u32 tmp = 0;
+    int i;
+
+    tmp = amba_readl(flash->regbase + REG28);
+    for (;REGDUMP(tmp, REG28_RXFIFOLV_MASK, REG28_RXFIFOLV_SHIFT)!= 0;){
+        amba_readb(flash->regbase + REG200);
+        tmp = amba_readl(flash->regbase + REG28);
+    }
+
+    tmp = amba_readl(flash->regbase + REG00);
+    REGPREP(tmp, REG00_CMDLEN_MASK, REG00_CMDLEN_SHIFT, 1);
+    REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, 0);
+    REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, 0);
+    REGPREP(tmp, REG00_DATALEN_MASK, REG00_DATALEN_SHIFT, datalen);
+    amba_writel(flash->regbase + REG00, tmp);
+
+    tmp = amba_readl(flash->regbase + REG04);
+    REGPREP(tmp, REG04_READEN_MASK, REG04_READEN_SHIFT, 1);
+    REGPREP(tmp, REG04_WRITEEN_MASK, REG04_WRITEEN_SHIFT, 0);
+    REGPREP(tmp, REG04_RXLANE_MASK, REG04_RXLANE_SHIFT, 1);
+    REGPREP(tmp, REG04_DATALANE_MASK, REG04_DATALANE_SHIFT, 1);
+    REGPREP(tmp, REG04_ADDRLANE_MASK, REG04_ADDRLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDLANE_MASK, REG04_CMDLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_LSBFRT_MASK, REG04_LSBFRT_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDDTR_MASK, REG04_CMDDTR_SHIFT, 0);
+    amba_writel(flash->regbase + REG04, tmp);
+
+    tmp = reg;
+    amba_writel(flash->regbase + REG0C, tmp);
+
+    tmp = 0x0;
+    amba_writel(flash->regbase + REG10, tmp);
+    tmp = 0x0;
+    amba_writel(flash->regbase + REG14, tmp);
+
+    tmp = 0;
+    REGPREP(tmp, REG50_STRTRX_MASK, REG50_STRTRX_SHIFT, 1);
+    amba_writel(flash->regbase + REG50, tmp);
+
+    for (;;){
+        tmp = amba_readl(flash->regbase + REG28);
+        if(REGDUMP(tmp, REG28_RXFIFOLV_MASK, REG28_RXFIFOLV_SHIFT) == datalen){
+            break;
+        }
+    }
+
+    for (i = 0; i < datalen; i++){
+        *(value+i) = amba_readb(flash->regbase + REG200);
+    }
+    return 0;
+}
+
+static int ambspinand_read_feature(struct amb_spinand *flash, u32 cmd, u32 datalen, u32 reg, u8 *value)
+{
+    u32 tmp = 0;
+    int i;
+
+    tmp = amba_readl(flash->regbase + REG28);
+    for (;REGDUMP(tmp, REG28_RXFIFOLV_MASK, REG28_RXFIFOLV_SHIFT)!= 0;){
+        amba_readb(flash->regbase + REG200);
+        tmp = amba_readl(flash->regbase + REG28);
+    }
+
+    tmp = amba_readl(flash->regbase + REG00);
+    REGPREP(tmp, REG00_CMDLEN_MASK, REG00_CMDLEN_SHIFT, 1);
+    REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, 0);
+    REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, 1);
+    REGPREP(tmp, REG00_DATALEN_MASK, REG00_DATALEN_SHIFT, datalen);
+    amba_writel(flash->regbase + REG00, tmp);
+
+    tmp = amba_readl(flash->regbase + REG04);
+    REGPREP(tmp, REG04_READEN_MASK, REG04_READEN_SHIFT, 1);
+    REGPREP(tmp, REG04_WRITEEN_MASK, REG04_WRITEEN_SHIFT, 0);
+    REGPREP(tmp, REG04_RXLANE_MASK, REG04_RXLANE_SHIFT, 1);
+    REGPREP(tmp, REG04_DATALANE_MASK, REG04_DATALANE_SHIFT, 1);
+    REGPREP(tmp, REG04_ADDRLANE_MASK, REG04_ADDRLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDLANE_MASK, REG04_CMDLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_LSBFRT_MASK, REG04_LSBFRT_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDDTR_MASK, REG04_CMDDTR_SHIFT, 0);
+    amba_writel(flash->regbase + REG04, tmp);
+
+    tmp = cmd;
+    amba_writel(flash->regbase + REG0C, tmp);
+
+    tmp = 0x0;
+    amba_writel(flash->regbase + REG10, tmp);
+    tmp = reg;
+    amba_writel(flash->regbase + REG14, tmp);
+
+    tmp = 0;
+    REGPREP(tmp, REG50_STRTRX_MASK, REG50_STRTRX_SHIFT, 1);
+    amba_writel(flash->regbase + REG50, tmp);
+
+    for (;;){
+        tmp = amba_readl(flash->regbase + REG28);
+        if(REGDUMP(tmp, REG28_RXFIFOLV_MASK, REG28_RXFIFOLV_SHIFT) == datalen){
+            break;
+        }
+    }
+
+    for (i = 0; i < datalen; i++){
+        *(value+i) = amba_readb(flash->regbase + REG200);
+    }
+    return 0;
+}
+
+static int ambspinand_set_feature(struct amb_spinand *flash, u32 cmd, u32 datalen, u32 reg, u8 value)
+{
+    u32 tmp = 0;
+/*
+    tmp = amba_readl(flash->regbase + REG28);
+    for (;REGDUMP(tmp, REG28_RXFIFOLV_MASK, REG28_RXFIFOLV_SHIFT)!= 0;){
+        amba_readb(flash->regbase + REG200);
+        tmp = amba_readl(flash->regbase + REG28);
+    }
+*/
+    tmp = amba_readl(flash->regbase + REG00);
+    REGPREP(tmp, REG00_CMDLEN_MASK, REG00_CMDLEN_SHIFT, 1);
+    REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, 0);
+    REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, 1);
+    REGPREP(tmp, REG00_DATALEN_MASK, REG00_DATALEN_SHIFT, datalen);
+    amba_writel(flash->regbase + REG00, tmp);
+
+    tmp = amba_readl(flash->regbase + REG04);
+    REGPREP(tmp, REG04_READEN_MASK, REG04_READEN_SHIFT, 0);
+    REGPREP(tmp, REG04_WRITEEN_MASK, REG04_WRITEEN_SHIFT, 1);
+    REGPREP(tmp, REG04_RXLANE_MASK, REG04_RXLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_DATALANE_MASK, REG04_DATALANE_SHIFT, 0);
+    REGPREP(tmp, REG04_ADDRLANE_MASK, REG04_ADDRLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDLANE_MASK, REG04_CMDLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_LSBFRT_MASK, REG04_LSBFRT_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDDTR_MASK, REG04_CMDDTR_SHIFT, 0);
+    amba_writel(flash->regbase + REG04, tmp);
+
+    tmp = cmd;
+    amba_writel(flash->regbase + REG0C, tmp);
+
+    tmp = 0x0;
+    amba_writel(flash->regbase + REG10, tmp);
+    tmp = reg;
+    amba_writel(flash->regbase + REG14, tmp);
+
+	amba_writeb(flash->regbase + REG100, value);
+    tmp = 0;
+    REGPREP(tmp, REG50_STRTRX_MASK, REG50_STRTRX_SHIFT, 1);
+    amba_writel(flash->regbase + REG50, tmp);
+
+	for (;;){
+            tmp = amba_readl(flash->regbase + REG24);
+            if(REGDUMP(tmp, REG24_TXFIFOLV_MASK, REG24_TXFIFOLV_SHIFT) == 0){
+                return 0;
+            }
+            udelay(100);//must delay
+    }
+
+    return 0;
+}
+
+static int ambspi_dma_config(struct amb_spinand *flash)
+{
+     flash->dmabuf = dma_alloc_coherent(flash->dev, AMBA_SPINOR_DMA_BUFF_SIZE,
+                     &flash->dmaaddr, GFP_KERNEL);
+     if (flash->dmabuf == NULL){
+        dev_err(flash->dev,  "dma_alloc_coherent failed!\n");
+        return -ENOMEM;
+     }
+     return 0;
+}
+
+static int ambspinand_prog_page(struct amb_spinand *flash, u16 byte_id, u8 *buf, u32 len)
+{
+    int done;
+    u32 tmp = 0;
+
+    amba_writel(flash->dmaregbase + 0x00,  0x1a800000);// DMA_ch0_control
+    amba_writel(flash->dmaregbase + 0x0c,  0x0);
+    amba_writel(flash->dmaregbase + 0x04,  flash->dmaaddr + byte_id);// DMA_ch0_src_addr
+    amba_writel(flash->dmaregbase + 0x08,  (u32)(flash->regbase + REG100));// DMA_ch0_dest_addr
+    amba_writel(flash->dmaregbase + 0x00,  0x9a800000|len);// DMA_ch0_control
+
+    tmp = amba_readl(flash->regbase + REG00);
+    REGPREP(tmp, REG00_DATALEN_MASK, REG00_DATALEN_SHIFT, len);
+    //REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, flash->dummy);
+    //REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, flash->addr_width);
+	REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, 0);
+    REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, 2);
+    REGPREP(tmp, REG00_CMDLEN_MASK, REG00_CMDLEN_SHIFT, 1);
+    amba_writel(flash->regbase + REG00, tmp);
+
+    tmp = amba_readl(flash->regbase + REG04);
+    REGPREP(tmp, REG04_WRITEEN_MASK, REG04_WRITEEN_SHIFT, 1);
+    REGPREP(tmp, REG04_READEN_MASK, REG04_READEN_SHIFT, 0);
+    REGPREP(tmp, REG04_DATALANE_MASK, REG04_DATALANE_SHIFT, 0);
+    REGPREP(tmp, REG04_ADDRLANE_MASK, REG04_ADDRLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDLANE_MASK, REG04_CMDLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_LSBFRT_MASK, REG04_LSBFRT_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDDTR_MASK, REG04_CMDDTR_SHIFT, 0);
+    amba_writel(flash->regbase + REG04, tmp);
+
+    tmp = flash->command[0];
+    amba_writel(flash->regbase + REG0C, tmp);
+
+    tmp = 0;
+    REGPREP(tmp, REG30_DATAREACH_MASK, REG30_DATAREACH_SHIFT, 1);
+    amba_writel(flash->regbase + REG30, tmp);
+
+    tmp = byte_id;
+    amba_writel(flash->regbase + REG14, tmp);
+
+    tmp = 0;
+    REGPREP(tmp, REG1C_TXFIFOLV_MASK, REG1C_TXFIFOLV_SHIFT, (256-32));
+    amba_writel(flash->regbase + REG1C, tmp);
+
+    tmp = amba_readl(flash->regbase + REG18);
+    REGPREP(tmp, REG18_TXDMAEN_MASK, REG18_TXDMAEN_SHIFT, 1);
+    REGPREP(tmp, REG18_RXDMAEN_MASK, REG18_RXDMAEN_SHIFT, 0);
+    amba_writel(flash->regbase + REG18, tmp);
+
+    do {
+        tmp = amba_readl(flash->regbase + REG2C);
+        done = REGDUMP(tmp, REG2C_TXFIFOEMP_MASK, REG2C_TXFIFOEMP_SHIFT);
+    }while (done != 0x0);
+
+    tmp = 0x20;
+    amba_writel(flash->regbase + REG3C, tmp);
+
+    tmp = amba_readl(flash->regbase + REG50);
+    REGPREP(tmp, REG50_STRTRX_MASK, REG50_STRTRX_SHIFT, 1);
+    amba_writel(flash->regbase + REG50, tmp);
+    for (;;){
+        tmp = amba_readl(flash->regbase + REG38);
+        if (REGDUMP(tmp,
+                REG38_DATALENREACHINTR_MASK,
+                REG38_DATALENREACHINTR_SHIFT) == 1){
+            return 0;
+        }
+    }
+    return -1;
+}
+
+static int ambspinand_read_page(struct amb_spinand *flash, u32 offset, u8 *rbuf,
+                            u32 len)
+{
+    u32 tmp = 0;
+
+    amba_writel(flash->dmaregbase + 0x10,  0x2a800000);// DMA_ch1_control
+    amba_writel(flash->dmaregbase + 0x1c,  0x0);
+    amba_writel(flash->dmaregbase + 0x14,  (u32)(flash->regbase + REG200));// DMA_ch1_src_addr
+    amba_writel(flash->dmaregbase + 0x18,  flash->dmaaddr);// DMA_ch1_dest_addr
+    amba_writel(flash->dmaregbase + 0x10,  0xaa800000 | len);// DMA_ch1_control
+
+    tmp = amba_readl(flash->regbase + REG00);
+    REGPREP(tmp, REG00_DATALEN_MASK, REG00_DATALEN_SHIFT, len);
+    //REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, flash->dummy);
+    //REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, flash->addr_width);
+	REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, 0);
+    REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, 3);
+    REGPREP(tmp, REG00_CMDLEN_MASK, REG00_CMDLEN_SHIFT, 1);
+    amba_writel(flash->regbase + REG00, tmp);
+
+    tmp = amba_readl(flash->regbase + REG04);
+    REGPREP(tmp, REG04_READEN_MASK, REG04_READEN_SHIFT, 1);
+    REGPREP(tmp, REG04_WRITEEN_MASK, REG04_WRITEEN_SHIFT, 0);
+    REGPREP(tmp, REG04_DATALANE_MASK, REG04_DATALANE_SHIFT, 1);
+    REGPREP(tmp, REG04_ADDRLANE_MASK, REG04_ADDRLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDLANE_MASK, REG04_CMDLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_LSBFRT_MASK, REG04_LSBFRT_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDDTR_MASK, REG04_CMDDTR_SHIFT, 0);
+    amba_writel(flash->regbase + REG04, tmp);
+
+    tmp = flash->command[0];
+    amba_writel(flash->regbase + REG0C, tmp);
+
+    tmp = offset;
+    amba_writel(flash->regbase + REG14, tmp);
+
+    tmp = 0x20;
+    amba_writel(flash->regbase + REG3C, tmp);
+
+    tmp = (32-1); // must use word.can't use rxfifothlv
+    amba_writel(flash->regbase + REG20, tmp);
+
+    tmp = amba_readl(flash->regbase + REG18);
+    REGPREP(tmp, REG18_RXDMAEN_MASK, REG18_RXDMAEN_SHIFT, 1);
+    REGPREP(tmp, REG18_TXDMAEN_MASK, REG18_TXDMAEN_SHIFT, 0);
+    amba_writel(flash->regbase + REG18, tmp);
+
+    tmp = amba_readl(flash->regbase + REG50);
+    REGPREP(tmp, REG50_STRTRX_MASK, REG50_STRTRX_SHIFT, 1);
+    amba_writel(flash->regbase + REG50, tmp);
+
+    for (;;){
+        tmp = amba_readl(flash->regbase + REG38);
+        if(REGDUMP(tmp,
+                REG38_DATALENREACHINTR_MASK,
+                REG38_DATALENREACHINTR_SHIFT) == 1){
+            return 0;
+        }
+        udelay(10);
+    }
+    return -1;
+}
+#if 0
+static u32 get_ssi3_freq_hz(void)
+{
+	#define PLL_OUT_ENET   300000000
+	u32 val;
+
+	val = amba_rct_readl(CG_SSI3_REG);
+	if (val & 0x01000000)
+		return 0;
+
+	if (val == 0)
+		val = 1;
+
+	//return (clk_get_rate(clk_get(NULL, "gclk_core")) << 1) / val;
+	return (PLL_OUT_ENET) / val;
+}
+#endif
+static int ambspinand_init(struct amb_spinand *flash)
+{
+    u32 tmp = 0;
+#if 0
+	u32 divider;
+	divider = get_ssi3_freq_hz() / flash->clk;
+    tmp = amba_readl(flash->regbase + REG08);
+    REGPREP(tmp, REG08_CHIPSEL_MASK, REG08_CHIPSEL_SHIFT, ~(1 << SPINOR_DEV));
+    REGPREP(tmp, REG08_CLKDIV_MASK, REG08_CLKDIV_SHIFT, divider);
+    REGPREP(tmp, REG08_FLOWCON_MASK, REG08_FLOWCON_SHIFT, 1);
+    REGPREP(tmp, REG08_HOLDPIN_MASK, REG08_HOLDPIN_SHIFT, 3);
+    amba_writel(flash->regbase + REG08, tmp);
+
+    tmp = amba_readl(flash->regbase + REG00);
+    REGPREP(tmp, REG00_DATALEN_MASK, REG00_DATALEN_SHIFT, 0);
+    REGPREP(tmp, REG00_DUMMYLEN_MASK, REG00_DUMMYLEN_SHIFT, 0);
+    REGPREP(tmp, REG00_ADDRLEN_MASK, REG00_ADDRLEN_SHIFT, 0);
+    REGPREP(tmp, REG00_CMDLEN_MASK, REG00_CMDLEN_SHIFT, 1);
+    amba_writel(flash->regbase + REG00, tmp);
+
+    tmp = amba_readl(flash->regbase + REG04);
+    REGPREP(tmp, REG04_WRITEEN_MASK, REG04_WRITEEN_SHIFT, 0);
+    REGPREP(tmp, REG04_READEN_MASK, REG04_READEN_SHIFT, 0);
+    REGPREP(tmp, REG04_DATALANE_MASK, REG04_DATALANE_SHIFT, 0);
+    REGPREP(tmp, REG04_ADDRLANE_MASK, REG04_ADDRLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDLANE_MASK, REG04_CMDLANE_SHIFT, 0);
+    REGPREP(tmp, REG04_LSBFRT_MASK, REG04_LSBFRT_SHIFT, 0);
+    REGPREP(tmp, REG04_CMDDTR_MASK, REG04_CMDDTR_SHIFT, 0);
+    amba_writel(flash->regbase + REG04, tmp);
+#endif
+    tmp = 0x20;
+    amba_writel(flash->regbase + REG30, tmp);
+
+    tmp = 0;
+    REGPREP(tmp, REG40_TXFIFORESET_MASK, REG40_TXFIFORESET_SHIFT, 1);
+    amba_writel(flash->regbase + REG40, tmp);
+    tmp = 0;
+    REGPREP(tmp, REG44_RXFIFORESET_MASK, REG44_RXFIFORESET_SHIFT, 1);
+    amba_writel(flash->regbase + REG44, tmp);
+
+    /* after reset fifo, the 0x28 will become 0x10,
+    *so , read REG200 times to clear the 0x28,  this is a bug in hardware
+    */
+	while (amba_readl(flash->regbase + REG28) != 0) {
+        tmp = amba_readl(flash->regbase + REG200);
+    }
+
+    tmp = 0;
+    REGPREP(tmp, REG1C_TXFIFOLV_MASK, REG1C_TXFIFOLV_SHIFT, 0x7f);
+    amba_writel(flash->regbase + REG1C, tmp);
+
+    tmp = 0;
+    REGPREP(tmp, REG20_RXFIFOLV_MASK, REG20_RXFIFOLV_SHIFT, 0x7f);
+    amba_writel(flash->regbase + REG20, tmp);
+
+    return 0;
+}
+/* spi nand function end */
+
+/****************************************************************************/
+/*
+ * spinand_write_enable - send command to enable write or erase of
+ * the nand cells.
+ * Before one can write or erase the nand cells, the write enable
+ * has to be set. After write or erase, the write enable bit is
+ * automatically cleared.
+ */
+static int spinand_write_enable(struct amb_spinand *flash)
+{
+    int ret;
+
+	flash->command[0] = SPI_NAND_WRITE_ENABLE;
+	ret = ambspinand_send_cmd(flash, flash->command[0], 0, 0, 0);
+	if (ret < 0) {
+		   dev_err(flash->dev, "Write Enable SPI NAND failed!\n");
+	}
+	return ret;
+}
+
+/*
+ * spinand_get_feature - send command to get feature register
+ * spinand_set_feature - send command to set feature register
+ *
+ * The GET FEATURES (0Fh) and SET FEATURES (1Fh) commands are used to
+ * alter the device behavior from the default power-on behavior.
+ * These commands use a 1-byte feature address to determine which feature
+ * is to be read or modified
+ */
+static int spinand_get_feature(struct amb_spinand *flash, u8 feature_reg,
+                                                               u8 *value)
+{
+	u32 cmd;
+	int ret;
+
+	cmd = SPI_NAND_GET_FEATURE_INS;
+
+	/* Check the register address */
+	if (feature_reg != SPI_NAND_PROTECTION_REG_ADDR &&
+		feature_reg != SPI_NAND_FEATURE_EN_REG_ADDR &&
+		feature_reg != SPI_NAND_STATUS_REG_ADDR &&
+		feature_reg != SPI_NAND_DS_REG_ADDR)
+			return -1;
+
+	ret = ambspinand_read_feature(flash, cmd, 1, feature_reg, value);
+	if (ret < 0)
+		dev_err(flash->dev, "Error %d read feature reg.\n", ret);
+	return ret;
+}
+
+static int spinand_set_feature(struct amb_spinand *flash, u8 feature_reg,
+                                                               u8 value)
+{
+	int ret;
+	u32 cmd;
+
+	cmd = SPI_NAND_SET_FEATURE;
+
+	/* Check the register address */
+	if (feature_reg != SPI_NAND_PROTECTION_REG_ADDR &&
+		feature_reg != SPI_NAND_FEATURE_EN_REG_ADDR &&
+		feature_reg != SPI_NAND_STATUS_REG_ADDR &&
+		feature_reg != SPI_NAND_DS_REG_ADDR)
+			return -1;
+
+	ret = ambspinand_set_feature(flash, cmd, 1, feature_reg, value);
+	if (ret < 0)
+		dev_err(flash->dev, "Error %d set feture reg.\n", ret);
+
+	return ret;
+}
+/*
+ * spinand_get_status
+ * spinand_get_protection
+ * spinand_get_feature_en
+ * spinand_get_driver_strength
+ *
+ * Read the specific feature register using spinand_get_feature
+ */
+static inline int
+spinand_get_status(struct amb_spinand *flash, u8 *value)
+{
+	return
+	spinand_get_feature(flash, SPI_NAND_STATUS_REG_ADDR, value);
+}
+static inline int
+spinand_get_protection(struct amb_spinand *flash, u8 *value)
+{
+	return
+	spinand_get_feature(flash, SPI_NAND_PROTECTION_REG_ADDR, value);
+}
+static inline int
+spinand_get_feature_en(struct amb_spinand *flash, u8 *value)
+{
+	return
+	spinand_get_feature(flash, SPI_NAND_FEATURE_EN_REG_ADDR, value);
+}
+static inline int
+spinand_get_driver_strength(struct amb_spinand *flash, u8 *value)
+{
+	return
+	spinand_get_feature(flash, SPI_NAND_DS_REG_ADDR, value);
+}
+/*
+ * spinand_set_status
+ * spinand_set_protection
+ * spinand_set_feature_en
+ *
+ * Set the specific feature register using spinand_set_feature
+ */
+static inline int
+spinand_set_status(struct amb_spinand *flash, u8 value)
+{
+	return
+	spinand_set_feature(flash, SPI_NAND_STATUS_REG_ADDR, value);
+}
+static inline int
+spinand_set_protection(struct amb_spinand *flash, u8 value)
+{
+	return
+	spinand_set_feature(flash, SPI_NAND_PROTECTION_REG_ADDR, value);
+}
+static inline int
+spinand_set_feature_en(struct amb_spinand *flash, u8 value)
+{
+	return
+	spinand_set_feature(flash, SPI_NAND_FEATURE_EN_REG_ADDR, value);
+}
+static inline int
+spinand_set_driver_strength(struct amb_spinand *flash, u8 value)
+{
+	return
+	spinand_set_feature(flash, SPI_NAND_DS_REG_ADDR, value);
+}
+/*
+ * is_spinand_busy - check the operation in progress bit and return
+ * if NAND chip is busy or not.
+ * This function checks the Operation In Progress (OIP) bit to
+ * determine whether the NAND memory is busy with a program execute,
+ * page read, block erase or reset command.
+ */
+static inline int is_spinand_busy(struct amb_spinand *flash)
+{
+	u8 status;
+	int ret;
+
+	/* Read the status register and check the OIP bit */
+	ret = spinand_get_status(flash, &status);
+	if (ret)
+		return ret;
+
+	if (status & SPI_NAND_OIP)
+		return 1;
+	else
+		return 0;
+}
+
+/* wait_execution_complete - wait for the current operation to finish */
+static inline int wait_execution_complete(struct amb_spinand *flash,
+                                                       u32 timeout)
+{
+	int ret;
+	unsigned long deadline = jiffies + timeout;
+
+	do {
+		ret = is_spinand_busy(flash);
+		if (!ret)
+			return 0;
+		if (ret < 0)
+			return ret;
+	} while (!time_after_eq(jiffies, deadline));
+
+	return -1;
+}
+
+static int spinand_enable_ecc(struct amb_spinand *flash)
+{
+	uint8_t feature_reg = 0;
+	int ret = 0;
+
+	ret = spinand_get_feature_en(flash, &feature_reg);
+	if (ret < 0)
+		return ret;
+	return spinand_set_feature_en(flash, feature_reg | SPI_NAND_ECC_EN);
+}
+#if 0
+static int spinand_disable_ecc(struct amb_spinand *flash)
+{
+	uint8_t feature_reg = 0;
+	int ret = 0;
+
+	ret = spinand_get_feature_en(flash, &feature_reg);
+	if (ret < 0)
+		return ret;
+	return spinand_set_feature_en(flash, feature_reg & (~SPI_NAND_ECC_EN));
+}
+#endif
+/*
+ * spinand_read_id - Read SPI nand ID
+ * Byte 0: Manufacture ID
+ * Byte 1: Device ID 1
+ * Byte 2: Device ID 2
+ */
+static int spinand_read_id(struct amb_spinand *flash, u8 *id)
+{
+	int ret;
+	u8 nand_id[3];
+	u32 cmd;
+
+	cmd = SPI_NAND_READ_ID;
+	ret = ambspinand_read_reg(flash,3, cmd, nand_id);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d reading id\n", ret);
+		return ret;
+	}
+	id[0] = nand_id[0];
+	id[1] = nand_id[1];
+	id[2] = nand_id[2];
+
+	return ret;
+}
+
+/* spinand_reset - send RESET command to NAND device */
+static void spinand_reset(struct amb_spinand *flash)
+{
+	int ret;
+
+	flash->command[0] = SPI_NAND_RESET;
+	ret = ambspinand_send_cmd(flash, flash->command[0], 0, 0, 0);
+	if (ret < 0) {
+		   dev_err(flash->dev, "Reset SPI NAND failed!\n");
+		   return;
+	}
+
+	/* OIP status can be read from 300ns after reset*/
+	udelay(1);
+	/* Wait for execution to complete */
+	ret = wait_execution_complete(flash, MAX_WAIT_JIFFIES);
+	if (ret) {
+		if (ret < 0)
+			dev_err(flash->dev, "%s: Wait execution complete failed!\n",
+				__func__);
+		else
+			dev_err(flash->dev, "%s: Wait execution complete timedout!\n",
+				__func__);
+	}
+}
+
+/*
+ * spinand_erase_block - erase a block
+ * The erase can specify the block to be erased
+ * (block_id >= 0, block_id < no_blocks)
+ * no_blocks depends on the size of the flash
+ * Command sequence: WRITE ENBALE, BLOCK ERASE,
+ * GET FEATURES command to read the status register
+ */
+static int spinand_erase_block(struct amb_spinand *flash, u32 page)
+{
+	int ret;
+	u8 status;
+
+	/* Enable capability of erasing NAND cells */
+	ret = spinand_write_enable(flash);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d on write enable.\n",
+					(int) ret);
+		return ret;
+	}
+
+	/* Set up command buffer. */
+	flash->command[0] = SPI_NAND_BLOCK_ERASE_INS;
+	ambspinand_send_cmd(flash, flash->command[0], 0, page, 3);
+
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d when erasing block.\n",
+					(int) ret);
+		return ret;
+	}
+
+	ret = wait_execution_complete(flash, MAX_WAIT_JIFFIES);
+	if (ret) {
+		if (ret < 0) {
+			dev_err(flash->dev, "%s: Wait execution complete failed!\n",
+					__func__);
+			return ret;
+		} else {
+			dev_err(flash->dev, "%s: Wait execution complete timedout!\n",
+					__func__);
+			return -1;
+		}
+	}
+
+	/* Check status register for erase fail bit */
+	ret = spinand_get_status(flash, &status);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d reading status register.\n",
+					(int) ret);
+		return ret;
+	}
+	if (status & SPI_NAND_EF) {
+		dev_err(flash->dev, "Erase fail on block %d\n", (page/64));
+		return -1;
+	}
+	return 0;
+}
+
+/*
+ * spinand_read_page_to_cache - send command to read data from the device and
+ * into the internal cache
+ * The read can specify the page to be read into cache
+ * (page_id >= 0, page_id < no_pages, no_pages=no_blocks*no_pages_per_block)
+ * no_blocks and no_pages_per_block depend on the size of the flash
+ */
+static int spinand_read_page_to_cache(struct amb_spinand *flash, u32 page_id)
+{
+	int ret = 0;
+	/* Set up command buffer. */
+	flash->command[0] = SPI_NAND_PAGE_READ_INS;
+	ret = ambspinand_send_cmd(flash, flash->command[0], 0, page_id, 3);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d when read page 0x%x to cache.\n",
+					page_id, (int) ret);
+    }
+	return ret;
+}
+
+/*
+ * spinand_read_from_cache - send command to read out the data from the
+ * cache register
+ * The read can specify a byte offset within the page
+ * (byte_id >= 0, byte_id < size_of_page)
+ * The read can specify a length to be read (len > 0 && len < size_of_page)
+ * size_of_page depends on the size of the flash
+ */
+static int spinand_read_from_cache(struct amb_spinand *flash,
+                                       u32 byte_id, int len, u8 *rbuf)
+{
+	int ret;
+
+	flash->command[0] = SPI_NAND_READ_CACHE_INS;
+	ret = ambspinand_read_page(flash, byte_id, rbuf, len);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d when read from cache.\n",
+			   (int) ret);
+	}
+	return ret;
+}
+
+/*
+ * spinand_read_page - read data from the flash by first reading the
+ * corresponding page into the internal cache and after reading out the
+ * data from it.
+ * The read can specify the page to be read into cache
+ * (page_id >= 0, page_id < no_pages, no_pages=no_blocks*no_pages_per_block)
+ * no_blocks and no_pages_per_block depend on the size of the flash
+ * The read can specify a byte offset within the page
+ * (byte_id >= 0, byte_id < size_of_page)
+ * The read can specify a length to be read (len > 0 && len < size_of_page)
+ * size_of_page depends on the size of the flash
+ */
+static int spinand_read_page(struct amb_spinand *flash, u32 page_id,
+                               u32 offset, int len, u8 *rbuf)
+{
+	int ret;
+	u8 status;
+
+	/* Read page from device to internal cache */
+	ret = spinand_read_page_to_cache(flash, page_id);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d reading page to cache.\n",
+				ret);
+		return ret;
+	}
+
+	/* Wait until the operation completes or a timeout occurs. */
+	ret = wait_execution_complete(flash, MAX_WAIT_JIFFIES);
+	if (ret) {
+		if (ret < 0) {
+			dev_err(flash->dev, "%s: Wait execution complete failed!\n",
+						__func__);
+			return ret;
+		} else {
+			dev_err(flash->dev, "%s: Wait execution complete timedout!\n",
+						__func__);
+			return -1;
+		}
+	}
+
+	/* Check status register for uncorrectable errors */
+	ret = spinand_get_status(flash, &status);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d reading status register.\n",
+					(int) ret);
+		return ret;
+	}
+	status &= SPI_NAND_ECC_UNABLE_TO_CORRECT;
+	if (status  == SPI_NAND_ECC_UNABLE_TO_CORRECT) {
+		dev_err(flash->dev, "ECC error reading page %d.\n",
+					page_id);
+		return -1;
+	}
+
+	/* Read page from internal cache to our buffers */
+	ret = spinand_read_from_cache(flash, offset, len, rbuf);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d reading from cache.\n",
+			(int) ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+/*
+ * spinand_program_data_to_cache - send command to program data to cache
+ * The write can specify a byte offset within the page
+ * (byte_id >= 0, byte_id < size_of_page)
+ * The write can specify a length to be written
+ * (len > 0 && len < size_of_page)
+ * size_of_page depends on the size of the flash
+ */
+static int spinand_program_data_to_cache(struct amb_spinand *flash,
+                                               u16 byte_id, int len, u8 *wbuf)
+{
+	int ret = 0;
+
+	flash->command[0] = SPI_NAND_PROGRAM_LOAD_INS;
+	ret = ambspinand_prog_page(flash, byte_id, wbuf, len);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d when program to cache.\n",
+			   (int) ret);
+	}
+	return ret;
+}
+
+/*
+ * spinand_program_execute - writes a page from cache to NAND array
+ * The write can specify the page to be programmed
+ * (page_id >= 0, page_id < no_pages, no_pages=no_blocks*no_pages_per_block)
+ * no_blocks and no_pages_per_block depend on the size of the flash
+ */
+static int spinand_program_execute(struct amb_spinand *flash, u32 page_id)
+{
+	int ret;
+
+	flash->command[0] = SPI_NAND_PROGRAM_EXEC_INS;
+	ret = ambspinand_send_cmd(flash, flash->command[0], 0, page_id, 3);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d when read page 0x%x to cache.\n",
+				   page_id, (int) ret);
+	}
+	return ret;
+}
+
+/*
+ * spinand_program_page - secquence to program a page
+ * The write can specify the page to be programmed
+ * (page_id >= 0, page_id < no_pages, no_pages=no_blocks*no_pages_per_block)
+ * no_blocks and no_pages_per_block depend on the size of the flash
+ * The write can specify a byte offset within the page
+ * (byte_id >= 0, byte_id < size_of_page)
+ * The write can specify a length to be written
+ * (len > 0 && len < size_of_page)
+ * size_of_page depends on the size of the flash
+ * Command sequence: WRITE ENABLE, PROGRAM LOAD, PROGRAM EXECUTE,
+ * GET FEATURE command to read the status
+ */
+static int spinand_program_page(struct amb_spinand *flash,
+               u32 page_id, u16 offset, int len, u8 *buf)
+{
+	int ret;
+	u8 status;
+	uint8_t *wbuf;
+
+	wbuf = buf;
+
+	/* Issue program cache command */
+	ret = spinand_program_data_to_cache(flash, offset, len, wbuf);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d when programming cache.\n",
+					(int) ret);
+		return ret;
+	}
+
+	/* Enable capability of programming NAND cells */
+	ret = spinand_write_enable(flash);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d on write enable.\n",
+					(int) ret);
+		return ret;
+	}
+
+	/* Issue program execute command */
+	ret = spinand_program_execute(flash, page_id);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d when programming NAND cells.\n",
+					(int) ret);
+		return ret;
+	}
+
+	/* Wait until the operation completes or a timeout occurs. */
+	ret = wait_execution_complete(flash, MAX_WAIT_JIFFIES);
+	if (ret) {
+		if (ret < 0) {
+			dev_err(flash->dev, "%s: Wait execution complete failed!\n",
+						__func__);
+			return ret;
+		} else {
+			dev_err(flash->dev, "%s Wait execution complete timedout!\n",
+						__func__);
+			return -1;
+		}
+	}
+
+	/* Check status register for program fail bit */
+	ret = spinand_get_status(flash, &status);
+	if (ret < 0) {
+		dev_err(flash->dev, "Error %d reading status register.\n",
+					(int) ret);
+		return ret;
+	}
+	if (status & SPI_NAND_PF) {
+		dev_err(flash->dev, "Program failed on page %d\n", page_id);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int spinand_write_page_hwecc(struct mtd_info *mtd,
+               struct nand_chip *chip, const uint8_t *buf, int oob_required)
+{
+	chip->write_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);
+	return 0;
+}
+
+static int spinand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+               uint8_t *buf, int oob_required, int page)
+{
+	u8 status;
+	int ret;
+	struct amb_spinand *flash = (struct amb_spinand *)chip->priv;
+
+	/* Read data and OOB area */
+	chip->read_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);
+	if (oob_required)
+		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* Wait until the operation completes or a timeout occurs. */
+	ret = wait_execution_complete(flash, MAX_WAIT_JIFFIES);
+	if (ret) {
+		if (ret < 0) {
+			pr_err("%s: Wait execution complete failed!\n",
+					__func__);
+			return ret;
+		} else {
+			pr_err("%s: Wait execution complete timedout!\n",
+					__func__);
+			return -1;
+		}
+	}
+
+	/* Check status register for uncorrectable errors */
+	ret = spinand_get_status(flash, &status);
+	if (ret < 0) {
+		pr_err("Error %d reading status register.\n", ret);
+		return ret;
+	}
+	status &= SPI_NAND_ECC_UNABLE_TO_CORRECT;
+	if (status  == SPI_NAND_ECC_UNABLE_TO_CORRECT) {
+		pr_info("ECC error reading page.\n");
+		mtd->ecc_stats.failed++;
+	}
+	if (status && (status != SPI_NAND_ECC_UNABLE_TO_CORRECT))
+		mtd->ecc_stats.corrected++;
+	return 0;
+}
+
+static void amb_spinand_cmdfunc(struct mtd_info *mtd, unsigned int command,
+                               int column, int page)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct amb_spinand *flash = (struct amb_spinand *)chip->priv;
+	struct spinand_state *state = (struct spinand_state *)flash->priv;
+
+	switch (command) {
+		case NAND_CMD_READ1:
+		case NAND_CMD_READ0:
+			state->buf_ptr = 0;
+			spinand_read_page(flash, page, 0, mtd->writesize,
+								flash->dmabuf);
+			break;
+		case NAND_CMD_READOOB:
+			state->buf_ptr = 0;
+			spinand_read_page(flash, page, mtd->writesize, mtd->oobsize,
+								flash->dmabuf);
+			break;
+		case NAND_CMD_RNDOUT:
+			state->buf_ptr = column;
+			break;
+		case NAND_CMD_READID:
+			state->buf_ptr = 0;
+			spinand_read_id(flash, (u8 *)flash->dmabuf);
+			break;
+		case NAND_CMD_PARAM:
+			state->buf_ptr = 0;
+			break;
+		/* ERASE1 performs the entire erase operation*/
+		case NAND_CMD_ERASE1:
+			//printk("spinand erase 1 command page 0x%x \n", page);
+			spinand_erase_block(flash, page);
+			break;
+		case NAND_CMD_ERASE2:
+			//printk("spinand erase 2 command page 0x%x \n", page);
+			break;
+		/* SEQIN sets up the addr buffer and all registers except the length */
+		case NAND_CMD_SEQIN:
+			state->col = column;
+			state->row = page;
+			state->buf_ptr = 0;
+			break;
+		/* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+		case NAND_CMD_PAGEPROG:
+			spinand_program_page(flash, state->row, state->col,
+									state->buf_ptr, flash->dmabuf);
+			break;
+		case NAND_CMD_STATUS:
+			spinand_get_status(flash, flash->dmabuf);
+			if (!(flash->dmabuf[0] & 0x80))
+				flash->dmabuf[0] = 0x80;
+			state->buf_ptr = 0;
+			break;
+		/* RESET command */
+		case NAND_CMD_RESET:
+			spinand_reset(flash);
+			break;
+		default:
+			dev_err(flash->dev, "Command 0x%x not implementd or unknown.\n",
+					command);
+		}
+}
+
+static int ambarella_spinand_get_resource(struct amb_spinand *flash,
+				struct platform_device *pdev)
+{
+    struct resource *res;
+    int errorCode = 0;
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) {
+        dev_err(&pdev->dev, "No mem resource for spinor_reg!\n");
+        errorCode = -ENXIO;
+        goto spinand_get_resource_err_exit;
+    }
+
+    flash->regbase =
+        devm_ioremap(&pdev->dev, res->start, resource_size(res));
+    if (!flash->regbase) {
+        dev_err(&pdev->dev, "devm_ioremap() failed\n");
+        errorCode = -ENOMEM;
+        goto spinand_get_resource_err_exit;
+    }
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+    if (!res) {
+        dev_err(&pdev->dev, "No mem resource for spinor_reg!\n");
+        errorCode = -ENXIO;
+        goto spinand_get_resource_err_exit;
+    }
+
+    flash->dmaregbase =
+        devm_ioremap(&pdev->dev, res->start, resource_size(res));
+    if (!flash->dmaregbase) {
+        dev_err(&pdev->dev, "devm_ioremap() failed\n");
+        errorCode = -ENOMEM;
+        goto spinand_get_resource_err_exit;
+    }
+
+    return 0;
+
+spinand_get_resource_err_exit:
+    return errorCode;
+}
+
+static int amb_spinand_waitfunc(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	struct amb_spinand *flash = (struct amb_spinand *)chip->priv;
+	int state = chip->state;
+	u32 timeout;
+
+	if (state == FL_ERASING)
+		timeout = MAX_WAIT_ERASE_JIFFIES;
+	else
+		timeout = AVERAGE_WAIT_JIFFIES;
+	return wait_execution_complete(flash, timeout);
+}
+
+static void amb_spinand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct amb_spinand *flash = (struct amb_spinand *)chip->priv;
+	struct spinand_state *state = (struct spinand_state *)flash->priv;
+
+	memcpy(flash->dmabuf + state->buf_ptr, buf, len);
+	state->buf_ptr += len;
+}
+
+static void amb_spinand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct amb_spinand *flash = (struct amb_spinand *)chip->priv;
+	struct spinand_state *state = (struct spinand_state *)flash->priv;
+
+	memcpy(buf, flash->dmabuf + state->buf_ptr, len);
+	state->buf_ptr += len;
+}
+
+static uint8_t amb_spinand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	struct amb_spinand *flash = (struct amb_spinand *)chip->priv;
+	struct spinand_state *state = (struct spinand_state *)flash->priv;
+	u8 data;
+
+	data = flash->dmabuf[state->buf_ptr];
+	state->buf_ptr++;
+	return data;
+}
+
+static void amb_spinand_select_chip(struct mtd_info *mtd, int dev)
+{
+}
+
+static int ambarella_spinand_init_chip(struct amb_spinand *flash,
+		struct device_node *np)
+{
+	struct nand_chip *chip = &flash->chip;
+
+	chip->read_byte = amb_spinand_read_byte;
+	chip->write_buf = amb_spinand_write_buf;
+	chip->read_buf = amb_spinand_read_buf;
+	chip->select_chip = amb_spinand_select_chip;
+	chip->waitfunc = amb_spinand_waitfunc;
+	chip->cmdfunc = amb_spinand_cmdfunc;
+	chip->options |= (NAND_CACHEPRG | NAND_NO_SUBPAGE_WRITE);
+	//chip->options |= NAND_CACHEPRG;
+	chip->priv = flash;
+	chip->bbt_options |= NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB;
+
+	flash->mtd.priv = chip;
+	flash->mtd.name = "amba_spinand";
+	flash->mtd.owner = THIS_MODULE;
+	flash->mtd.writebufsize = flash->mtd.writesize;
+	flash->mtd.type = MTD_NANDFLASH;
+
+	return 0;
+}
+
+static int ambarella_spinand_init_chipecc(struct amb_spinand *flash)
+{
+	int ret = 0;
+
+	struct nand_chip *chip = &flash->chip;
+
+	chip->ecc.mode	= NAND_ECC_HW;
+	chip->ecc.size	= 0x200;
+	chip->ecc.bytes	= 16;
+	chip->ecc.steps	= 0x4;
+
+	chip->ecc.strength = 8;
+	chip->ecc.total	= chip->ecc.steps * chip->ecc.bytes;
+	chip->ecc.layout = &ecc_layout_2KB_8bit;
+	chip->ecc.read_page = spinand_read_page_hwecc;
+	chip->ecc.write_page = spinand_write_page_hwecc;
+	ret = spinand_enable_ecc(flash);
+
+	return ret;
+}
+
+static int ambarella_spinand_probe(struct platform_device *pdev)
+{
+	struct mtd_info	*mtd;
+	struct mtd_part_parser_data	ppdata;
+	struct amb_spinand	*flash;
+	struct spinand_state *state;
+	int	errCode = 0;
+
+	flash = kzalloc(sizeof(struct amb_spinand), GFP_KERNEL);
+	if (!flash) {
+		errCode = -ENOMEM;
+		goto ambarella_spinand_probe_exit;
+	}
+
+	state = kzalloc(sizeof(struct spinand_state), GFP_KERNEL);
+	if (!state) {
+		errCode = -ENOMEM;
+		goto ambarella_spinand_probe_free_flash;
+	}
+	flash->priv = state;
+	state->buf_ptr = 0;
+
+    mutex_init(&flash->lock);
+    platform_set_drvdata(pdev, flash);
+    flash->dev = &pdev->dev;
+
+	/* set 50Mhz as default spi clock */
+	flash->clk = 50000000;
+    ambarella_spinand_get_resource(flash, pdev);
+    ambspinand_init(flash);
+
+	ambarella_spinand_init_chipecc(flash);
+	ambarella_spinand_init_chip(flash, pdev->dev.of_node);
+
+	mtd = &flash->mtd;
+
+	flash->command = kzalloc(5, GFP_KERNEL);
+    if(!flash->command) {
+        dev_err((const struct device *)&flash->dev,
+            "SPI NAND driver malloc command error\r\n");
+        errCode = -ENOMEM;
+        goto ambarella_spinand_probe_free_state;
+    }
+	//flash->clk = info->max_clk_hz;
+    ambspinand_init(flash);
+    ambspi_dma_config(flash);
+
+	spinand_set_protection(flash, SPI_NAND_PROTECTED_ALL_UNLOCKED);
+
+	if (nand_scan(mtd, 1))
+		return -ENXIO;
+
+	ppdata.of_node = pdev->dev.of_node;
+	errCode = mtd_device_parse_register(&flash->mtd, NULL, &ppdata, NULL, 0);
+	if (errCode < 0)
+		goto ambarella_spinand_probe_free_command;
+
+    printk("AMBARELLA SPINAND probed \n");
+    return 0;
+
+ambarella_spinand_probe_free_command:
+    kfree(flash->command);
+ambarella_spinand_probe_free_state:
+	kfree(state);
+ambarella_spinand_probe_free_flash:
+    kfree(flash);
+ambarella_spinand_probe_exit:
+    return errCode;
+}
+
+
+static int ambarella_spinand_remove(struct platform_device *pdev)
+{
+	struct amb_spinand    *flash = platform_get_drvdata(pdev);
+	int        status;
+
+	if (flash) {
+		/* Clean up MTD stuff. */
+		status = mtd_device_unregister(&flash->mtd);
+		if (status == 0) {
+			kfree(flash->command);
+			dma_free_coherent(flash->dev,
+				AMBA_SPINOR_DMA_BUFF_SIZE,
+				flash->dmabuf, flash->dmaaddr);
+			kfree(flash);
+		}
+	}
+    return 0;
+}
+
+static void ambarella_spinand_shutdown(struct platform_device *pdev)
+{
+	int ret;
+	struct amb_spinand    *flash = platform_get_drvdata(pdev);
+
+	/* Wait until finished previous write command. */
+	ret = wait_execution_complete(flash, MAX_WAIT_JIFFIES);
+	if (ret) {
+		if (ret < 0) {
+			dev_err(flash->dev, "%s: Wait execution complete failed!\n",
+					__func__);
+			return;
+		} else
+			dev_err(flash->dev, "%s: Wait execution complete timedout!\n",
+					__func__);
+	}
+	/* Workaround for the spinand software reboot */
+	spinand_read_page_to_cache(flash, 0);
+	ret = wait_execution_complete(flash, MAX_WAIT_JIFFIES);
+	if (ret) {
+		if (ret < 0)
+			dev_err(flash->dev, "%s: Wait execution complete failed!\n",
+					__func__);
+		else
+			dev_err(flash->dev, "%s: Wait execution complete timedout!\n",
+					__func__);
+	}
+	return;
+}
+
+static const struct of_device_id ambarella_spinand_of_match[] = {
+    {.compatible = "ambarella,spinand", },
+    {},
+};
+MODULE_DEVICE_TABLE(of, ambarella_spinand_of_match);
+
+static struct platform_driver amb_spinand_driver = {
+	.probe = ambarella_spinand_probe,
+	.remove = ambarella_spinand_remove,
+	.driver = {
+		.name = "ambarella-spinand",
+		.owner = THIS_MODULE,
+		.of_match_table = ambarella_spinand_of_match,
+	},
+	.shutdown = ambarella_spinand_shutdown,
+};
+
+module_platform_driver(amb_spinand_driver);
+
+MODULE_AUTHOR("Ken He");
+MODULE_DESCRIPTION("Ambarella Media processor SPI NAND Flash Controller Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/mtd/nand/ambarella_spinand.h b/drivers/mtd/nand/ambarella_spinand.h
new file mode 100644
index 0000000..d00bb4d
--- /dev/null
+++ b/drivers/mtd/nand/ambarella_spinand.h
@@ -0,0 +1,386 @@
+/**
+ * ambarella_spinand.h
+ *
+ * History:
+ *    2015/10/26 - [Ken He] created file
+ *
+ * Copyright 2014-2018 Ambarella Inc.  All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_AMBARELLA_SPINAND_H__
+#define __LINUX_AMBARELLA_SPINAND_H__
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/math64.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/mod_devicetable.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/of_platform.h>
+
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <plat/dma.h>
+#include <plat/rct.h>
+
+#include <plat/ptb.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/delay.h>
+
+#define REGPREP(reg,mask,shift,value) (reg=((~mask)&reg)|(value << shift))
+#define REGDUMP(reg,mask,shift) ((reg&mask)>>shift)
+
+#define REG00_DATALEN_SHIFT   0   /*[21:0]    data access length*/
+#define REG00_DATALEN_MASK    0x003fffff
+#define REG00_DUMMYLEN_SHIFT  22  /*[26:22]    dummy cycle length*/
+#define REG00_DUMMYLEN_MASK   0x07c00000
+#define REG00_ADDRLEN_SHIFT   27  /*[29:27]    address length*/
+#define REG00_ADDRLEN_MASK    0x38000000
+#define REG00_CMDLEN_SHIFT    30  /*[31:30]    command length*/
+#define    REG00_CMDLEN_MASK  0xc0000000
+
+#define REG04_READEN_SHIFT   0 /*[0]    data part read mode*/
+#define REG04_READEN_MASK    0x00000001
+#define REG04_WRITEEN_SHIFT  1 /*[1]    data part write mode*/
+#define REG04_WRITEEN_MASK   0x00000002
+#define REG04_RXLANE_SHIFT   9 /*[9] rx lane config*/
+#define REG04_RXLANE_MASK    0x00000200
+#define REG04_DATALANE_SHIFT 10 /*[11:10] number of data lane*/
+#define REG04_DATALANE_MASK  0x00000c00
+#define REG04_ADDRLANE_SHIFT 12 /*[13:12] number of addr lane*/
+#define REG04_ADDRLANE_MASK  0x00003000
+#define REG04_CMDLANE_SHIFT  14 /*[15:14] number of command lane */
+#define REG04_CMDLANE_MASK   0x0000c000
+#define REG04_LSBFRT_SHIFT   24 /*[24]    0-msb first 1-lsb first*/
+#define REG04_LSBFRT_MASK    0x01000000
+#define REG04_DATADTR_SHIFT  28 /*[28]    data double transfer rate*/
+#define REG04_DATADTR_MASK   0x10000000
+#define REG04_DUMMYDTR_SHIFT 29 /*[29]    dummy double transfer rate*/
+#define REG04_DUMMYDTR_MASK  0x20000000
+#define REG04_ADDRDTR_SHIFT  30 /*[30] address double transfer rate*/
+#define REG04_ADDRDTR_MASK   0x40000000
+#define REG04_CMDDTR_SHIFT   31/*[31] command dtr,only reg_clk divider>2*/
+#define REG04_CMDDTR_MASK    0x80000000
+
+#define REG08_RXSPLDELAY_SHIFT   0 /*[4:0]    adjust rx sampling data phase*/
+#define REG08_RXSPLDELAY_MASK    0x0000001f
+#define REG08_CLKDIV_SHIFT       10 /*[17:10]    divide reference clock*/
+#define REG08_CLKDIV_MASK        0x0003fc00
+#define REG08_CHIPSEL_SHIFT      18 /*[25:18]    cen for multiple device 0 for select and vice versa*/
+#define REG08_CHIPSEL_MASK       0x03fc0000
+#define REG08_HOLDSWITCH_SHIFT   26 /*[26]0 for hold switching on switch one ref clock cycle before negative edge*/
+#define REG08_HOLDSWITCH_MASK    0x04000000
+#define REG08_SPICLKPOL_SHIFT    27 /*[27]    clock will remain 1 or 0 in standby mode*/
+#define REG08_SPICLKPOL_MASK     0x08000000
+#define REG08_HOLDPIN_SHIFT      28 /*[30:28]    for flow control purpose*/
+#define REG08_HOLDPIN_MASK       0x70000000
+#define REG08_FLOWCON_SHIFT      31 /*[31]    flow control enable*/
+#define REG08_FLOWCON_MASK       0x80000000
+
+#define REG0C_CMD0_SHIFT 0 /*[7:0]    command for SPI  device*/
+#define REG0C_CMD0_MASK  0x000000ff
+#define REG0C_CMD1_SHIFT 8 /*[15:8]*/
+#define REG0C_CMD1_MASK  0x0000ff00
+#define REG0C_CMD2_SHIFT 16 /*[23:16]*/
+#define REG0C_CMD2_MASK  0x00ff0000
+
+#define REG18_RXDMAEN_SHIFT 0 /*[0]    rx dma enable*/
+#define REG18_RXDMAEN_MASK  0x00000001
+#define REG18_TXDMAEN_SHIFT 1 /*[1]    tx dma enable*/
+#define REG18_TXDMAEN_MASK  0x00000002
+
+#define REG1C_TXFIFOLV_SHIFT  0 /*[8:0]  tx fifo threshold level*/
+#define REG1C_TXFIFOLV_MASK   0x000000ff
+
+#define REG20_RXFIFOLV_SHIFT  0
+#define REG20_RXFIFOLV_MASK   0x000000ff
+
+#define REG24_TXFIFOLV_SHIFT  0
+#define REG24_TXFIFOLV_MASK   0x000000ff
+
+#define REG28_RXFIFOLV_SHIFT 0
+#define REG28_RXFIFOLV_MASK  0x000000ff
+
+#define REG2C_TXFIFONOTFULL_SHIFT 1 /*[1]*/
+#define REG2C_TXFIFONOTFULL_MASK  0x00000002
+#define REG2C_TXFIFOEMP_SHIFT     2 /*[2] tx fifo empty*/
+#define REG2C_TXFIFOEMP_MASK      0x00000004
+#define REG2C_RXFIFONOTEMP_SHIFT  3 /*[3] */
+#define REG2C_RXFIFONOTEMP_MASK   0x00000008
+#define REG2C_RXFIFOFULL_SHIFT    4 /*[4] rx fifo full*/
+#define REG2C_RXFIFOFULL_MASK     0x00000010
+
+#define REG30_TXEMP_SHIFT     0/*[0] tx fifo almost empty*/
+#define REG30_TXEMP_MASK      0x00000001
+#define REG30_TXOVER_SHIFT    1 /*[1]*/
+#define REG30_TXOVER_MASK     0x00000002
+#define REG30_RXUNDER_SHIFT   2/*[2]*/
+#define REG30_RXUNDER_MASK    0x00000004
+#define REG30_RXOVER_SHIFT    3/*[3]*/
+#define REG30_RXOVER_MASK     0x00000008
+#define REG30_RXFULL_SHIFT    4 /*[4]*/
+#define REG30_RXFULL_MASK     0x00000010
+#define REG30_DATAREACH_SHIFT 5 /*[5]*/
+#define REG30_DATAREACH_MASK  0x00000020
+#define REG30_TXUNDER_SHIFT   6/*[6]*/
+#define REG30_TXUNDER_MASK    0x00000040
+
+#define REG38_TXEMPTYINTR_SHIFT     0 /*[0]  tx almost empty*/
+#define REG38_TXEMPTYINTR_MASK      0x00000001
+#define REG38_TXOVERFLOWINTR_SHIFT  1 /*[1] */
+#define REG38_TXOVERFLOWINTR_MASK   0x00000002
+#define REG38_RXUNDERFLOWINTR_SHIFT 2 /*[2]*/
+#define REG38_RXUNDERFLOWINTR_MASK  0x00000004
+#define REG38_RXOVERFLOWINTR_SHIFT  3 /*[3]*/
+#define REG38_RXOVERFLOWINTR_MASK   0x00000008
+#define REG38_RXFULLINTR_SHIFT      4 /*[4] rx fifo almost full*/
+#define REG38_RXFULLINTR_MASK        0x00000010
+#define REG38_DATALENREACHINTR_SHIFT 5 /*[5] transaction done interrupt*/
+#define REG38_DATALENREACHINTR_MASK  0x00000020
+#define REG38_TXUNDERFLOWINTR_SHIFT  6 /*[6] */
+#define REG38_TXUNDERFLOWINTR_MASK   0x00000040
+
+#define REG40_TXFIFORESET_SHIFT  0 /*[0] software reset the tx fifo*/
+#define REG40_TXFIFORESET_MASK   0x00000001
+
+#define REG44_RXFIFORESET_SHIFT  0 /*[0]  software reset the rx fifo*/
+#define REG44_RXFIFORESET_MASK   0x00000001
+
+#define REG50_STRTRX_SHIFT 0 /*[0]    start tx or rx*/
+#define REG50_STRTRX_MASK  0x00000001
+
+#define HAS_IMG_PARTS       15
+#define TOTAL_FW_PARTS        (HAS_IMG_PARTS + HAS_NO_IMG_PARTS)
+
+#define REG00 0x00
+#define REG04 0x04
+#define REG08 0x08
+#define REG0C 0x0c
+#define REG10 0x10
+#define REG14 0x14
+#define REG18 0x18
+#define REG1C 0x1c
+#define REG20 0x20
+#define REG24 0x24
+#define REG28 0x28
+#define REG2C 0x2c
+#define REG30 0x30
+#define REG34 0x34
+#define REG38 0x38
+#define REG3C 0x3C
+#define REG40 0x40
+#define REG44 0x44
+#define REG50 0x50
+#define REG100 0x100
+#define REG200 0x200
+#define DMA_CONTROLLER_OFFSET (0xe0005000)
+
+#if defined(CONFIG_SPI_NOR_CHIP_0)
+#define SPINOR_DEV 0
+#elif defined(CONFIG_SPI_NOR_CHIP_1)
+#define SPINOR_DEV 1
+#elif defined(CONFIG_SPI_NOR_CHIP_2)
+#define SPINOR_DEV 2
+#elif defined(CONFIG_SPI_NOR_CHIP_3)
+#define SPINOR_DEV 3
+#else
+#define SPINOR_DEV 0
+#endif
+
+struct amb_spinand {
+    struct device                *dev;
+    unsigned char __iomem        *regbase;
+    unsigned char __iomem        *dmaregbase;
+    dma_addr_t                   dmaaddr;
+    u8                           *dmabuf;
+    int (*write_enable)(struct amb_spinand *flash);
+    int (*wait_till_ready)(struct amb_spinand *flash);
+    struct mutex                 lock;
+    struct mtd_info              mtd;
+    u16                          page_size;
+    u16                          addr_width;
+    u8                           erase_opcode;
+    u8                           *command;
+    u8                           dummy;
+    u32                          addr;
+	u32							 clk;
+    bool                         fast_read;
+	u32							 jedec_id;
+	struct nand_chip			chip;
+	void						*priv;
+};
+//the buffer size must align to 32 and smaller than the max size of DMA
+#define AMBA_SPINOR_DMA_BUFF_SIZE    4096
+
+/* SPI NAND Command Set Definitions */
+enum {
+	SPI_NAND_WRITE_ENABLE			= 0x06,
+	SPI_NAND_WRITE_DISABLE			= 0x04,
+	SPI_NAND_GET_FEATURE_INS		= 0x0F,
+	SPI_NAND_SET_FEATURE			= 0x1F,
+	SPI_NAND_PAGE_READ_INS			= 0x13,
+	SPI_NAND_READ_CACHE_INS			= 0x03,
+	SPI_NAND_FAST_READ_CACHE_INS		= 0x0B,
+	SPI_NAND_READ_CACHE_X2_INS		= 0x3B,
+	SPI_NAND_READ_CACHE_X4_INS		= 0x6B,
+	SPI_NAND_READ_CACHE_DUAL_IO_INS		= 0xBB,
+	SPI_NAND_READ_CACHE_QUAD_IO_INS		= 0xEB,
+	SPI_NAND_READ_ID			= 0x9F,
+	SPI_NAND_PROGRAM_LOAD_INS		= 0x02,
+	SPI_NAND_PROGRAM_LOAD4_INS		= 0x32,
+	SPI_NAND_PROGRAM_EXEC_INS		= 0x10,
+	SPI_NAND_PROGRAM_LOAD_RANDOM_INS	= 0x84,
+	SPI_NAND_PROGRAM_LOAD_RANDOM4_INS	= 0xC4,
+	SPI_NAND_BLOCK_ERASE_INS		= 0xD8,
+	SPI_NAND_RESET				= 0xFF
+};
+
+/* Feature registers */
+enum feature_register {
+	SPI_NAND_PROTECTION_REG_ADDR	= 0xA0,
+	SPI_NAND_FEATURE_EN_REG_ADDR	= 0xB0,
+	SPI_NAND_STATUS_REG_ADDR	= 0xC0,
+	SPI_NAND_DS_REG_ADDR		= 0xD0,
+};
+/*
+ * SR7 - reserved
+ * SR6 - ECC status 2
+ * SR5 - ECC status 1
+ * SR4 - ECC status 0
+ *
+ * ECCS provides ECC status as follows:
+ * 000b = No bit errors were detected during the previous read algorithm.
+ * 001b = bit error was detected and corrected, error bit number < 3.
+ * 010b = bit error was detected and corrected, error bit number = 4.
+ * 011b = bit error was detected and corrected, error bit number = 5.
+ * 100b = bit error was detected and corrected, error bit number = 6.
+ * 101b = bit error was detected and corrected, error bit number = 7.
+ * 110b = bit error was detected and corrected, error bit number = 8.
+ * 111b = bit error was detected and not corrected.
+ *
+ * SR3 - P_Fail Program fail
+ * SR2 - E_Fail Erase fail
+ * SR1 - WEL - Write enable latch
+ * SR0 - OIP - Operation in progress
+ */
+enum {
+	SPI_NAND_ECCS2	= 0x40,
+	SPI_NAND_ECCS1	= 0x20,
+	SPI_NAND_ECCS0	= 0x10,
+	SPI_NAND_PF	= 0x08,
+	SPI_NAND_EF	= 0x04,
+	SPI_NAND_WEL	= 0x02,
+	SPI_NAND_OIP	= 0x01
+};
+
+enum {
+	SPI_NAND_ECC_NO_ERRORS = 0x00,
+	SPI_NAND_ECC_UNABLE_TO_CORRECT =
+		SPI_NAND_ECCS0 | SPI_NAND_ECCS1 | SPI_NAND_ECCS2
+};
+
+/*
+ * Feature enable register description: SPI_NAND_FEATURE_EN_REG_ADDR
+ *
+ * FR7 - OTP protect
+ * FR6 - OTP enable
+ * FR5 - reserved
+ * FR4 - ECC enable
+ * FR3 - reserved
+ * FR2 - reserved
+ * FR1 - reserved
+ * FR0 - Quad operation enable
+ */
+enum {
+	SPI_NAND_QUAD_EN	= 0x01,
+	SPI_NAND_ECC_EN		= 0x10,
+	SPI_NAND_OTP_EN		= 0x40,
+	SPI_NAND_OTP_PRT	= 0x80
+};
+
+/*
+ * Protection register description: SPI_NAND_PROTECTION_REG_ADDR
+ *
+ * BL7 - BRWD
+ * BL6 - reserved
+ * BL5 - Block protect 2
+ * BL4 - Block protect 1
+ * BL3 - Block protect 0
+ * BL2 - INV
+ * BL1 - CMP
+ * BL0 - reserved
+ */
+enum {
+	SPI_NAND_BRWD	= 0x80,
+	SPI_NAND_BP2	= 0x20,
+	SPI_NAND_BP1	= 0x10,
+	SPI_NAND_BP0	= 0x08,
+	SPI_NAND_INV	= 0x04,
+	SPI_NAND_CMP	= 0x02
+};
+
+enum protected_rows {
+	/* All unlocked : 000xx */
+	SPI_NAND_PROTECTED_ALL_UNLOCKED	= 0x00,
+	SPI_NAND_UPPER_1_64_LOCKED	= 0x04,
+	SPI_NAND_LOWER_63_64_LOCKED	= 0x05,
+	SPI_NAND_LOWER_1_64_LOCKED	= 0x06,
+	SPI_NAND_UPPER_63_64_LOCKED	= 0x07,
+	SPI_NAND_UPPER_1_32_LOCKED	= 0x08,
+	SPI_NAND_LOWER_31_32_LOCKED	= 0x09,
+	SPI_NAND_LOWER_1_32_LOCKED	= 0x0A,
+	SPI_NAND_UPPER_31_32_LOCKED	= 0x0B,
+	SPI_NAND_UPPER_1_16_LOCKED	= 0x0C,
+	SPI_NAND_LOWER_15_16_LOCKED	= 0x0D,
+	SPI_NAND_LOWER_1_16_LOCKED	= 0x0E,
+	SPI_NAND_UPPER_15_16_LOCKED	= 0x0F,
+	SPI_NAND_UPPER_1_8_LOCKED	= 0x10,
+	SPI_NAND_LOWER_7_8_LOCKED	= 0x11,
+	SPI_NAND_LOWER_1_8_LOCKED	= 0x12,
+	SPI_NAND_UPPER_7_8_LOCKED	= 0x13,
+	SPI_NAND_UPPER_1_4_LOCKED	= 0x14,
+	SPI_NAND_LOWER_3_4_LOCKED	= 0x15,
+	SPI_NAND_LOWER_1_4_LOCKED	= 0x16,
+	SPI_NAND_UPPER_3_4_LOCKED	= 0x17,
+	SPI_NAND_UPPER_1_2_LOCKED	= 0x18,
+	SPI_NAND_BLOCK_0_LOCKED		= 0x19,
+	SPI_NAND_LOWER_1_2_LOCKED	= 0x1A,
+	SPI_NAND_BLOCK_0_LOCKED1	= 0x1B,
+	/* All locked (default) : 111xx */
+	SPI_NAND_PROTECTED_ALL_LOCKED	= 0x1C,
+
+};
+
+struct spinand_info{
+	struct	nand_ecclayout *ecclayout;
+	void	*priv;
+};
+
+struct spinand_state{
+	u32 col; /* offset in page */
+	u32 row; /* page number */
+	int	buf_ptr;
+};
+
+#endif /* __LINUX_AMBARELLA_SPINAND_H__ */
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index 7d66cdc..436794f 100644
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -64,10 +64,30 @@ struct nand_flash_dev nand_flash_ids[] = {
 		{ .id = {0x2c, 0xda, 0x90, 0x95, 0x04} },
 		  SZ_2K, SZ_256, SZ_128K, 0, 5, 128},
 
+	{"MT29F2G08ABAGA 2G 3.3V 8-bit",
+                { .id = {0x2c, 0xda, 0x90, 0x95, 0x06} },
+                  SZ_2K, SZ_256, SZ_128K, 0, 5, 128},
+
 	{"H27U2G8F2D 2G 3.3V 8-bit",
 		{ .id = {0xad, 0xda, 0x90, 0x95, 0x46} },
 		  SZ_2K, SZ_256, SZ_128K, 0, 5, 128},
 
+	{"GD5F1GQ4UCY1G SPINAND 1Gb 3.3V 8-bit",
+		{ .id = {0xc8, 0xb1, 0x48} },
+		SZ_2K, SZ_128, SZ_128K, LP_OPTIONS, 3, 128},
+
+	{"GD5F1GQ4UFY1G SPINAND 1Gb 3.3V 8-bit",
+		{ .id = {0xc8, 0xb3, 0x48} },
+		SZ_2K, SZ_128, SZ_128K, LP_OPTIONS, 3, 128},
+
+	{"GD5F2GQ4UCY1G SPINAND 2Gb 3.3V 8-bit",
+		{ .id = {0xc8, 0xb2, 0x48} },
+		SZ_2K, SZ_256, SZ_128K, LP_OPTIONS, 3, 128},
+
+	{"HYF1GQ4UBACAE SPINAND 1Gb 3.3V 8-bit",
+		{ .id = {0xc9, 0x59, 0x1b} },
+		SZ_2K, SZ_128, SZ_128K, LP_OPTIONS, 3, 128},
+
 	LEGACY_ID_NAND("NAND 4MiB 5V 8-bit",   0x6B, 4, SZ_8K, SP_OPTIONS),
 	LEGACY_ID_NAND("NAND 4MiB 3,3V 8-bit", 0xE3, 4, SZ_8K, SP_OPTIONS),
 	LEGACY_ID_NAND("NAND 4MiB 3,3V 8-bit", 0xE5, 4, SZ_8K, SP_OPTIONS),
@@ -193,6 +213,7 @@ struct nand_manufacturers nand_manuf_ids[] = {
 	{NAND_MFR_AMD, "AMD/Spansion"},
 	{NAND_MFR_MACRONIX, "Macronix"},
 	{NAND_MFR_EON, "Eon"},
+	{NAND_MFR_GD,"GigdDevice"},
 	{0x0, "Unknown"}
 };
 
diff --git a/drivers/mtd/onenand/onenand_base.c b/drivers/mtd/onenand/onenand_base.c
index b3f41f2..0f13fd4 100644
--- a/drivers/mtd/onenand/onenand_base.c
+++ b/drivers/mtd/onenand/onenand_base.c
@@ -2610,6 +2610,7 @@ static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
  */
 static int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
 {
+	struct onenand_chip *this = mtd->priv;
 	int ret;
 
 	ret = onenand_block_isbad(mtd, ofs);
@@ -2621,7 +2622,7 @@ static int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
 	}
 
 	onenand_get_device(mtd, FL_WRITING);
-	ret = mtd_block_markbad(mtd, ofs);
+	ret = this->block_markbad(mtd, ofs);
 	onenand_release_device(mtd);
 	return ret;
 }
diff --git a/drivers/mtd/ubi/attach.c b/drivers/mtd/ubi/attach.c
index c071d41..79d69bd 100644
--- a/drivers/mtd/ubi/attach.c
+++ b/drivers/mtd/ubi/attach.c
@@ -408,7 +408,7 @@ int ubi_compare_lebs(struct ubi_device *ubi, const struct ubi_ainf_peb *aeb,
 		second_is_newer = !second_is_newer;
 	} else {
 		dbg_bld("PEB %d CRC is OK", pnum);
-		bitflips = !!err;
+		bitflips |= !!err;
 	}
 	mutex_unlock(&ubi->buf_mutex);
 
diff --git a/drivers/mtd/ubi/build.c b/drivers/mtd/ubi/build.c
index a561335..03331c1 100644
--- a/drivers/mtd/ubi/build.c
+++ b/drivers/mtd/ubi/build.c
@@ -997,6 +997,9 @@ int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,
 			goto out_detach;
 	}
 
+	/* Make device "available" before it becomes accessible via sysfs */
+	ubi_devices[ubi_num] = ubi;
+
 	err = uif_init(ubi, &ref);
 	if (err)
 		goto out_detach;
@@ -1041,7 +1044,6 @@ int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,
 	wake_up_process(ubi->bgt_thread);
 	spin_unlock(&ubi->wl_lock);
 
-	ubi_devices[ubi_num] = ubi;
 	ubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL);
 	return ubi_num;
 
@@ -1052,6 +1054,7 @@ out_uif:
 	ubi_assert(ref);
 	uif_close(ubi);
 out_detach:
+	ubi_devices[ubi_num] = NULL;
 	ubi_wl_close(ubi);
 	ubi_free_internal_volumes(ubi);
 	vfree(ubi->vtbl);
diff --git a/drivers/mtd/ubi/cdev.c b/drivers/mtd/ubi/cdev.c
index 4f02848..fc764e7 100644
--- a/drivers/mtd/ubi/cdev.c
+++ b/drivers/mtd/ubi/cdev.c
@@ -475,7 +475,7 @@ static long vol_cdev_ioctl(struct file *file, unsigned int cmd,
 		/* Validate the request */
 		err = -EINVAL;
 		if (req.lnum < 0 || req.lnum >= vol->reserved_pebs ||
-		    req.bytes < 0 || req.lnum >= vol->usable_leb_size)
+		    req.bytes < 0 || req.bytes > vol->usable_leb_size)
 			break;
 
 		err = get_exclusive(desc);
diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c
index 0e11671d..930cf2c 100644
--- a/drivers/mtd/ubi/eba.c
+++ b/drivers/mtd/ubi/eba.c
@@ -1362,7 +1362,8 @@ int ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)
 				 * during re-size.
 				 */
 				ubi_move_aeb_to_list(av, aeb, &ai->erase);
-			vol->eba_tbl[aeb->lnum] = aeb->pnum;
+			else
+				vol->eba_tbl[aeb->lnum] = aeb->pnum;
 		}
 	}
 
diff --git a/drivers/mtd/ubi/io.c b/drivers/mtd/ubi/io.c
index bf79def..8822e88 100644
--- a/drivers/mtd/ubi/io.c
+++ b/drivers/mtd/ubi/io.c
@@ -931,6 +931,11 @@ static int validate_vid_hdr(const struct ubi_device *ubi,
 		goto bad;
 	}
 
+	if (data_size > ubi->leb_size) {
+		ubi_err("bad data_size");
+		goto bad;
+	}
+
 	if (vol_type == UBI_VID_STATIC) {
 		/*
 		 * Although from high-level point of view static volumes may
diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index f913d70..c4b1af0 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -74,6 +74,8 @@ int ubi_check_volume(struct ubi_device *ubi, int vol_id)
 	for (i = 0; i < vol->used_ebs; i++) {
 		int size;
 
+		cond_resched();
+
 		if (i == vol->used_ebs - 1)
 			size = vol->last_eb_bytes;
 		else
diff --git a/drivers/mtd/ubi/upd.c b/drivers/mtd/ubi/upd.c
index 2a1b6e0..0134ba3 100644
--- a/drivers/mtd/ubi/upd.c
+++ b/drivers/mtd/ubi/upd.c
@@ -193,7 +193,7 @@ int ubi_start_leb_change(struct ubi_device *ubi, struct ubi_volume *vol,
 	vol->changing_leb = 1;
 	vol->ch_lnum = req->lnum;
 
-	vol->upd_buf = vmalloc(req->bytes);
+	vol->upd_buf = vmalloc(ALIGN((int)req->bytes, ubi->min_io_size));
 	if (!vol->upd_buf)
 		return -ENOMEM;
 
diff --git a/drivers/mtd/ubi/vmt.c b/drivers/mtd/ubi/vmt.c
index 8330703..96131eb 100644
--- a/drivers/mtd/ubi/vmt.c
+++ b/drivers/mtd/ubi/vmt.c
@@ -534,13 +534,6 @@ int ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)
 		spin_unlock(&ubi->volumes_lock);
 	}
 
-	/* Change volume table record */
-	vtbl_rec = ubi->vtbl[vol_id];
-	vtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);
-	err = ubi_change_vtbl_record(ubi, vol_id, &vtbl_rec);
-	if (err)
-		goto out_acc;
-
 	if (pebs < 0) {
 		for (i = 0; i < -pebs; i++) {
 			err = ubi_eba_unmap_leb(ubi, vol, reserved_pebs + i);
@@ -558,6 +551,24 @@ int ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)
 		spin_unlock(&ubi->volumes_lock);
 	}
 
+	/*
+	 * When we shrink a volume we have to flush all pending (erase) work.
+	 * Otherwise it can happen that upon next attach UBI finds a LEB with
+	 * lnum > highest_lnum and refuses to attach.
+	 */
+	if (pebs < 0) {
+		err = ubi_wl_flush(ubi, vol_id, UBI_ALL);
+		if (err)
+			goto out_acc;
+	}
+
+	/* Change volume table record */
+	vtbl_rec = ubi->vtbl[vol_id];
+	vtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);
+	err = ubi_change_vtbl_record(ubi, vol_id, &vtbl_rec);
+	if (err)
+		goto out_acc;
+
 	vol->reserved_pebs = reserved_pebs;
 	if (vol->vol_type == UBI_DYNAMIC_VOLUME) {
 		vol->used_ebs = reserved_pebs;
diff --git a/drivers/mtd/ubi/vtbl.c b/drivers/mtd/ubi/vtbl.c
index d77b1c1..bebf49e 100644
--- a/drivers/mtd/ubi/vtbl.c
+++ b/drivers/mtd/ubi/vtbl.c
@@ -651,6 +651,7 @@ static int init_volumes(struct ubi_device *ubi,
 		if (ubi->corr_peb_count)
 			ubi_err("%d PEBs are corrupted and not used",
 				ubi->corr_peb_count);
+		return -ENOSPC;
 	}
 	ubi->rsvd_pebs += reserved_pebs;
 	ubi->avail_pebs -= reserved_pebs;
diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c
index 49e570a..3375bfb 100644
--- a/drivers/mtd/ubi/wl.c
+++ b/drivers/mtd/ubi/wl.c
@@ -999,7 +999,7 @@ static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,
 				int cancel)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
-	int vol_id = -1, uninitialized_var(lnum);
+	int vol_id = -1, lnum = -1;
 #ifdef CONFIG_MTD_UBI_FASTMAP
 	int anchor = wrk->anchor;
 #endif
@@ -1978,6 +1978,7 @@ int ubi_wl_init(struct ubi_device *ubi, struct ubi_attach_info *ai)
 		if (ubi->corr_peb_count)
 			ubi_err("%d PEBs are corrupted and not used",
 				ubi->corr_peb_count);
+		err = -ENOSPC;
 		goto out_free;
 	}
 	ubi->avail_pebs -= reserved_pebs;
diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c
index b143ce9..c0ed7c8 100644
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@ -876,6 +876,23 @@ static void bond_mc_swap(struct bonding *bond, struct slave *new_active,
 	}
 }
 
+static struct slave *bond_get_old_active(struct bonding *bond,
+					 struct slave *new_active)
+{
+	struct slave *slave;
+	int i;
+
+	bond_for_each_slave(bond, slave, i) {
+		if (slave == new_active)
+			continue;
+
+		if (ether_addr_equal(bond->dev->dev_addr, slave->dev->dev_addr))
+			return slave;
+	}
+
+	return NULL;
+}
+
 /*
  * bond_do_fail_over_mac
  *
@@ -919,6 +936,9 @@ static void bond_do_fail_over_mac(struct bonding *bond,
 		write_unlock_bh(&bond->curr_slave_lock);
 		read_unlock(&bond->lock);
 
+		if (!old_active)
+			old_active = bond_get_old_active(bond, new_active);
+
 		if (old_active) {
 			memcpy(tmp_mac, new_active->dev->dev_addr, ETH_ALEN);
 			memcpy(saddr.sa_data, old_active->dev->dev_addr,
@@ -2188,6 +2208,7 @@ static int  bond_release_and_destroy(struct net_device *bond_dev,
 		bond_dev->priv_flags |= IFF_DISABLE_NETPOLL;
 		pr_info("%s: destroying bond %s.\n",
 			bond_dev->name, bond_dev->name);
+		bond_remove_proc_entry(bond);
 		unregister_netdevice(bond_dev);
 	}
 	return ret;
diff --git a/drivers/net/can/at91_can.c b/drivers/net/can/at91_can.c
index 535d5dd..024078c 100644
--- a/drivers/net/can/at91_can.c
+++ b/drivers/net/can/at91_can.c
@@ -731,9 +731,10 @@ static int at91_poll_rx(struct net_device *dev, int quota)
 
 	/* upper group completed, look again in lower */
 	if (priv->rx_next > get_mb_rx_low_last(priv) &&
-	    quota > 0 && mb > get_mb_rx_last(priv)) {
+	    mb > get_mb_rx_last(priv)) {
 		priv->rx_next = get_mb_rx_first(priv);
-		goto again;
+		if (quota > 0)
+			goto again;
 	}
 
 	return received;
diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c
index f66aeb7..464e5f6 100644
--- a/drivers/net/can/dev.c
+++ b/drivers/net/can/dev.c
@@ -772,6 +772,11 @@ static int can_newlink(struct net *src_net, struct net_device *dev,
 	return -EOPNOTSUPP;
 }
 
+static void can_dellink(struct net_device *dev, struct list_head *head)
+{
+	return;
+}
+
 static struct rtnl_link_ops can_link_ops __read_mostly = {
 	.kind		= "can",
 	.maxtype	= IFLA_CAN_MAX,
@@ -779,6 +784,7 @@ static struct rtnl_link_ops can_link_ops __read_mostly = {
 	.setup		= can_setup,
 	.newlink	= can_newlink,
 	.changelink	= can_changelink,
+	.dellink	= can_dellink,
 	.get_size	= can_get_size,
 	.fill_info	= can_fill_info,
 	.get_xstats_size = can_get_xstats_size,
diff --git a/drivers/net/can/sja1000/sja1000.c b/drivers/net/can/sja1000/sja1000.c
index f17c301..732a8ed 100644
--- a/drivers/net/can/sja1000/sja1000.c
+++ b/drivers/net/can/sja1000/sja1000.c
@@ -184,6 +184,12 @@ static void sja1000_start(struct net_device *dev)
 	priv->write_reg(priv, SJA1000_RXERR, 0x0);
 	priv->read_reg(priv, SJA1000_ECC);
 
+	/* clear interrupt flags */
+	priv->read_reg(priv, SJA1000_IR);
+
+	/* clear interrupt flags */
+	priv->read_reg(priv, SJA1000_IR);
+
 	/* leave reset mode */
 	set_normal_mode(dev);
 }
diff --git a/drivers/net/can/usb/ems_usb.c b/drivers/net/can/usb/ems_usb.c
index 5f9a7ad..d921416 100644
--- a/drivers/net/can/usb/ems_usb.c
+++ b/drivers/net/can/usb/ems_usb.c
@@ -118,6 +118,9 @@ MODULE_LICENSE("GPL v2");
  */
 #define EMS_USB_ARM7_CLOCK 8000000
 
+#define CPC_TX_QUEUE_TRIGGER_LOW	25
+#define CPC_TX_QUEUE_TRIGGER_HIGH	35
+
 /*
  * CAN-Message representation in a CPC_MSG. Message object type is
  * CPC_MSG_TYPE_CAN_FRAME or CPC_MSG_TYPE_RTR_FRAME or
@@ -279,6 +282,11 @@ static void ems_usb_read_interrupt_callback(struct urb *urb)
 	switch (urb->status) {
 	case 0:
 		dev->free_slots = dev->intr_in_buffer[1];
+		if(dev->free_slots > CPC_TX_QUEUE_TRIGGER_HIGH){
+			if (netif_queue_stopped(netdev)){
+				netif_wake_queue(netdev);
+			}
+		}
 		break;
 
 	case -ECONNRESET: /* unlink */
@@ -530,8 +538,6 @@ static void ems_usb_write_bulk_callback(struct urb *urb)
 	/* Release context */
 	context->echo_index = MAX_TX_URBS;
 
-	if (netif_queue_stopped(netdev))
-		netif_wake_queue(netdev);
 }
 
 /*
@@ -591,7 +597,7 @@ static int ems_usb_start(struct ems_usb *dev)
 	int err, i;
 
 	dev->intr_in_buffer[0] = 0;
-	dev->free_slots = 15; /* initial size */
+	dev->free_slots = 50; /* initial size */
 
 	for (i = 0; i < MAX_RX_URBS; i++) {
 		struct urb *urb = NULL;
@@ -841,7 +847,7 @@ static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *ne
 
 		/* Slow down tx path */
 		if (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||
-		    dev->free_slots < 5) {
+		    dev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {
 			netif_stop_queue(netdev);
 		}
 	}
diff --git a/drivers/net/ethernet/ambarella/Makefile b/drivers/net/ethernet/ambarella/Makefile
index 4c7f5a2..e2e9c09 100644
--- a/drivers/net/ethernet/ambarella/Makefile
+++ b/drivers/net/ethernet/ambarella/Makefile
@@ -3,9 +3,3 @@
 #
 
 obj-$(CONFIG_NET_VENDOR_AMBARELLA)		+= ambarella_eth.o
-ifeq ($(CONFIG_PLAT_AMBARELLA_S3),y)
-ambarella_eth-y					:= ambarella_eth_enhanced.o
-else
-ambarella_eth-y					:= ambarella_eth_normal.o
-endif
-
diff --git a/drivers/net/ethernet/ambarella/ambarella_eth.c b/drivers/net/ethernet/ambarella/ambarella_eth.c
new file mode 100644
index 0000000..a081bd3
--- /dev/null
+++ b/drivers/net/ethernet/ambarella/ambarella_eth.c
@@ -0,0 +1,2597 @@
+/*
+ * /drivers/net/ethernet/ambarella/ambarella_eth_normal.c
+ *
+ * Author: Anthony Ginger <hfjiang@ambarella.com>
+ * Copyright (C) 2004-2011, Ambarella, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_mdio.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/crc32.h>
+#include <linux/time.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/ethtool.h>
+
+#include <asm/dma.h>
+
+#include <mach/hardware.h>
+#include <plat/eth.h>
+#include <plat/rct.h>
+/* ==========================================================================*/
+#define AMBETH_NAPI_WEIGHT		32
+#define AMBETH_TX_WATCHDOG		(2 * HZ)
+#define AMBETH_MII_RETRY_CNT		200
+#define AMBETH_FC_PAUSE_TIME		1954
+
+#define AMBETH_PACKET_MAXFRAME		(1536)
+#define AMBETH_RX_COPYBREAK		(1518)
+#define AMBETH_RX_RNG_MIN		(8)
+#define AMBETH_TX_RNG_MIN		(4)
+#define AMBETH_PHY_REG_SIZE		(32)
+
+#define AMBETH_RXDMA_STATUS	(ETH_DMA_STATUS_OVF | ETH_DMA_STATUS_RI | \
+				ETH_DMA_STATUS_RU | ETH_DMA_STATUS_RPS | \
+				ETH_DMA_STATUS_RWT)
+#define AMBETH_RXDMA_INTEN	(ETH_DMA_INTEN_OVE | ETH_DMA_INTEN_RIE | \
+				ETH_DMA_INTEN_RUE | ETH_DMA_INTEN_RSE | \
+				ETH_DMA_INTEN_RWE)
+#define AMBETH_TXDMA_STATUS	(ETH_DMA_STATUS_TI | ETH_DMA_STATUS_TPS | \
+				ETH_DMA_STATUS_TU | ETH_DMA_STATUS_TJT | \
+				ETH_DMA_STATUS_UNF)
+#if defined(CONFIG_NET_VENDOR_AMBARELLA_INTEN_TUE)
+#define AMBETH_TXDMA_INTEN	(ETH_DMA_INTEN_TIE | ETH_DMA_INTEN_TSE | \
+				ETH_DMA_INTEN_TUE | ETH_DMA_INTEN_TJE | \
+				ETH_DMA_INTEN_UNE)
+#else
+#define AMBETH_TXDMA_INTEN	(ETH_DMA_INTEN_TIE | ETH_DMA_INTEN_TSE | \
+				ETH_DMA_INTEN_TJE | ETH_DMA_INTEN_UNE)
+#endif
+#define AMBETH_DMA_INTEN	(ETH_DMA_INTEN_NIE | ETH_DMA_INTEN_AIE | \
+				ETH_DMA_INTEN_FBE | AMBETH_RXDMA_INTEN | \
+				AMBETH_TXDMA_INTEN)
+
+/* ==========================================================================*/
+struct ambeth_rng_info {
+	struct sk_buff			*skb;
+	dma_addr_t			mapping;
+};
+
+struct ambeth_tx_rngmng {
+	unsigned int			cur_tx;
+	unsigned int			dirty_tx;
+	struct ambeth_rng_info		*rng_tx;
+	struct ambeth_desc		*desc_tx;
+};
+
+struct ambeth_rx_rngmng {
+	unsigned int			cur_rx;
+	unsigned int			dirty_rx;
+	struct ambeth_rng_info		*rng_rx;
+	struct ambeth_desc		*desc_rx;
+};
+
+struct ambeth_info {
+	unsigned int			rx_count;
+	struct ambeth_rx_rngmng		rx;
+	unsigned int			tx_count;
+	unsigned int			tx_irq_low;
+	unsigned int			tx_irq_high;
+	struct ambeth_tx_rngmng		tx;
+	dma_addr_t			rx_dma_desc;
+	dma_addr_t			tx_dma_desc;
+	spinlock_t			lock;
+	int				oldspeed;
+	int				oldduplex;
+	int				oldlink;
+	int				oldpause;
+	int				oldasym_pause;
+	u32				flow_ctr;
+
+	struct net_device_stats		stats;
+	struct napi_struct		napi;
+	struct net_device		*ndev;
+
+	struct mii_bus			new_bus;
+	struct phy_device		*phydev;
+	int				pwr_gpio;
+	u8				pwr_gpio_active;
+	int				rst_gpio;
+	u8				rst_gpio_active;
+	u32				phy_supported;
+	u32				fixed_speed; /* only for phy-less */
+
+	unsigned char __iomem		*regbase;
+	u32				msg_enable;
+
+	u32				mdio_gpio : 1,
+					phy_enabled : 1,
+					ipc_tx : 1,
+					ipc_rx : 1,
+					dump_tx : 1,
+					dump_rx : 1,
+					dump_rx_free : 1,
+					dump_rx_all : 1;
+	int				clk_direction;
+};
+
+/* ==========================================================================*/
+static int msg_level = -1;
+module_param (msg_level, int, 0);
+MODULE_PARM_DESC (msg_level, "Override default message level");
+
+/* ==========================================================================*/
+static void amba_set_eth_desc(struct ambeth_desc *desc, u32 val) {
+	u32 status = 0, length = 0;
+
+	if(ETH_ENHANCED) {
+		if(val & ETH_TDES_IC)
+			status |= ETH_ENHANCED_TDES0_IC;
+		if(val & ETH_TDES_LS)
+			status |= ETH_ENHANCED_TDES0_LS;
+		if(val & ETH_TDES_FS)
+			status |= ETH_ENHANCED_TDES0_FS;
+		if(val & ETH_TDES_TCH)
+			status |= ETH_ENHANCED_TDES0_TCH;
+		if(val & ETH_TDES_CIC)
+			status |= ETH_ENHANCED_TDES0_CIC_V2;
+
+		desc->status |= status;
+	} else {
+		if(val & ETH_TDES_IC)
+			length |= ETH_TDES1_IC;
+		if(val & ETH_TDES_LS)
+			length |= ETH_TDES1_LS;
+		if(val & ETH_TDES_FS)
+			length |= ETH_TDES1_FS;
+		if(val & ETH_TDES_TCH)
+			length |= ETH_TDES1_TCH;
+		if(val & ETH_TDES_CIC)
+			length |= ETH_TDES1_CIC_TUI | ETH_TDES1_CIC_HDR;
+
+		desc->length |= length;
+	}
+
+}
+
+static void ambhw_dump(struct ambeth_info *lp)
+{
+	u32 i;
+	unsigned int dirty_diff;
+	u32 entry;
+
+	dirty_diff = (lp->rx.cur_rx - lp->rx.dirty_rx);
+	entry = (lp->rx.cur_rx % lp->rx_count);
+	dev_info(&lp->ndev->dev, "RX Info: cur_rx[%u], dirty_rx[%u],"
+		" diff[%u], entry[%u].\n", lp->rx.cur_rx, lp->rx.dirty_rx,
+		dirty_diff, entry);
+	for (i = 0; i < lp->rx_count; i++) {
+		dev_info(&lp->ndev->dev, "RX Info: RX descriptor[%u] "
+			"0x%08x 0x%08x 0x%08x 0x%08x.\n", i,
+			lp->rx.desc_rx[i].status, lp->rx.desc_rx[i].length,
+			lp->rx.desc_rx[i].buffer1, lp->rx.desc_rx[i].buffer2);
+	}
+	dirty_diff = (lp->tx.cur_tx - lp->tx.dirty_tx);
+	entry = (lp->tx.cur_tx % lp->tx_count);
+	dev_info(&lp->ndev->dev, "TX Info: cur_tx[%u], dirty_tx[%u],"
+		" diff[%u], entry[%u].\n", lp->tx.cur_tx, lp->tx.dirty_tx,
+		dirty_diff, entry);
+	for (i = 0; i < lp->tx_count; i++) {
+		dev_info(&lp->ndev->dev, "TX Info: TX descriptor[%u] "
+			"0x%08x 0x%08x 0x%08x 0x%08x.\n", i,
+			lp->tx.desc_tx[i].status, lp->tx.desc_tx[i].length,
+			lp->tx.desc_tx[i].buffer1, lp->tx.desc_tx[i].buffer2);
+	}
+	for (i = 0; i <= 21; i++) {
+		dev_dbg(&lp->ndev->dev, "GMAC[%d]: 0x%08x.\n", i,
+		amba_readl(lp->regbase + ETH_MAC_CFG_OFFSET + (i << 2)));
+	}
+	for (i = 0; i <= 54; i++) {
+		dev_dbg(&lp->ndev->dev, "GDMA[%d]: 0x%08x.\n", i,
+		amba_readl(lp->regbase + ETH_DMA_BUS_MODE_OFFSET + (i << 2)));
+	}
+}
+
+static inline int ambhw_dma_reset(struct ambeth_info *lp)
+{
+	int ret_val = 0;
+	u32 counter = 0;
+
+	amba_setbitsl(lp->regbase + ETH_DMA_BUS_MODE_OFFSET,
+		ETH_DMA_BUS_MODE_SWR);
+	do {
+		if (counter++ > 100) {
+			ret_val = -EIO;
+			break;
+		}
+		mdelay(1);
+	} while (amba_tstbitsl(lp->regbase + ETH_DMA_BUS_MODE_OFFSET,
+		ETH_DMA_BUS_MODE_SWR));
+
+	if (ret_val && netif_msg_drv(lp))
+		dev_err(&lp->ndev->dev, "DMA Error: Check PHY.\n");
+
+	return ret_val;
+}
+
+static inline void ambhw_dma_int_enable(struct ambeth_info *lp)
+{
+	amba_writel(lp->regbase + ETH_DMA_INTEN_OFFSET, AMBETH_DMA_INTEN);
+}
+
+static inline void ambhw_dma_int_disable(struct ambeth_info *lp)
+{
+	amba_writel(lp->regbase + ETH_DMA_INTEN_OFFSET, 0);
+}
+
+static inline void ambhw_dma_rx_start(struct ambeth_info *lp)
+{
+	amba_setbitsl(lp->regbase + ETH_DMA_OPMODE_OFFSET, ETH_DMA_OPMODE_SR);
+}
+
+static inline void ambhw_dma_rx_stop(struct ambeth_info *lp)
+{
+	unsigned int irq_status;
+	int i = 1300;
+
+	amba_clrbitsl(lp->regbase + ETH_DMA_OPMODE_OFFSET, ETH_DMA_OPMODE_SR);
+	do {
+		udelay(1);
+		irq_status = amba_readl(lp->regbase + ETH_DMA_STATUS_OFFSET);
+	} while ((irq_status & ETH_DMA_STATUS_RS_MASK) && --i);
+	if ((i <= 0) && netif_msg_drv(lp)) {
+		dev_err(&lp->ndev->dev,
+			"DMA Error: Stop RX status=0x%x, opmode=0x%x.\n",
+			amba_readl(lp->regbase + ETH_DMA_STATUS_OFFSET),
+			amba_readl(lp->regbase + ETH_DMA_OPMODE_OFFSET));
+	}
+}
+
+static inline void ambhw_dma_tx_start(struct ambeth_info *lp)
+{
+	amba_setbitsl(lp->regbase + ETH_DMA_OPMODE_OFFSET, ETH_DMA_OPMODE_ST);
+}
+
+static inline void ambhw_dma_tx_stop(struct ambeth_info *lp)
+{
+	unsigned int irq_status;
+	int i = 1300;
+
+	amba_clrbitsl(lp->regbase + ETH_DMA_OPMODE_OFFSET, ETH_DMA_OPMODE_ST);
+	do {
+		udelay(1);
+		irq_status = amba_readl(lp->regbase + ETH_DMA_STATUS_OFFSET);
+	} while ((irq_status & ETH_DMA_STATUS_TS_MASK) && --i);
+	if ((i <= 0) && netif_msg_drv(lp)) {
+		dev_err(&lp->ndev->dev,
+			"DMA Error: Stop TX status=0x%x, opmode=0x%x.\n",
+			amba_readl(lp->regbase + ETH_DMA_STATUS_OFFSET),
+			amba_readl(lp->regbase + ETH_DMA_OPMODE_OFFSET));
+	}
+	amba_setbitsl(lp->regbase + ETH_DMA_OPMODE_OFFSET, ETH_DMA_OPMODE_FTF);
+}
+
+static inline void ambhw_dma_tx_restart(struct ambeth_info *lp, u32 entry)
+{
+	lp->tx.desc_tx[entry].status = 0;
+	amba_set_eth_desc(&lp->tx.desc_tx[entry], ETH_TDES_IC);
+	lp->tx.desc_tx[entry].status |= ETH_TDES0_OWN;
+	amba_writel(lp->regbase + ETH_DMA_TX_DESC_LIST_OFFSET,
+		(u32)lp->tx_dma_desc + (entry * sizeof(struct ambeth_desc)));
+	if (netif_msg_tx_err(lp)) {
+		dev_err(&lp->ndev->dev, "TX Error: restart %u.\n", entry);
+		ambhw_dump(lp);
+	}
+	ambhw_dma_tx_start(lp);
+}
+
+static inline void ambhw_dma_tx_poll(struct ambeth_info *lp)
+{
+	amba_writel(lp->regbase + ETH_DMA_TX_POLL_DMD_OFFSET, 0x01);
+}
+
+static inline void ambhw_stop_tx_rx(struct ambeth_info *lp)
+{
+	unsigned int irq_status;
+	int i = 1300;
+
+	amba_clrbitsl(lp->regbase + ETH_MAC_CFG_OFFSET, ETH_MAC_CFG_RE);
+	amba_clrbitsl(lp->regbase + ETH_DMA_OPMODE_OFFSET,
+		(ETH_DMA_OPMODE_SR | ETH_DMA_OPMODE_ST));
+	do {
+		udelay(1);
+		irq_status = amba_readl(lp->regbase + ETH_DMA_STATUS_OFFSET);
+	} while ((irq_status & (ETH_DMA_STATUS_TS_MASK |
+		ETH_DMA_STATUS_RS_MASK)) && --i);
+	if ((i <= 0) && netif_msg_drv(lp)) {
+		dev_err(&lp->ndev->dev,
+			"DMA Error: Stop TX/RX status=0x%x, opmode=0x%x.\n",
+			amba_readl(lp->regbase + ETH_DMA_STATUS_OFFSET),
+			amba_readl(lp->regbase + ETH_DMA_OPMODE_OFFSET));
+	}
+	amba_clrbitsl(lp->regbase + ETH_MAC_CFG_OFFSET, ETH_MAC_CFG_TE);
+}
+
+static inline void ambhw_set_dma_desc(struct ambeth_info *lp)
+{
+	amba_writel(lp->regbase + ETH_DMA_RX_DESC_LIST_OFFSET,
+		lp->rx_dma_desc);
+	amba_writel(lp->regbase + ETH_DMA_TX_DESC_LIST_OFFSET,
+		lp->tx_dma_desc);
+}
+
+static inline phy_interface_t ambhw_get_interface(struct ambeth_info *lp)
+{
+	return amba_tstbitsl(lp->regbase + ETH_MAC_CFG_OFFSET,
+		ETH_MAC_CFG_PS) ? PHY_INTERFACE_MODE_MII :
+		PHY_INTERFACE_MODE_GMII;
+}
+
+static inline void ambhw_set_hwaddr(struct ambeth_info *lp, u8 *hwaddr)
+{
+	u32 val;
+
+	val = (hwaddr[5] << 8) | hwaddr[4];
+	amba_writel(lp->regbase + ETH_MAC_MAC0_HI_OFFSET, val);
+	udelay(4);
+	val = (hwaddr[3] << 24) | (hwaddr[2] << 16) |
+		(hwaddr[1] << 8) | hwaddr[0];
+	amba_writel(lp->regbase + ETH_MAC_MAC0_LO_OFFSET, val);
+}
+
+static inline void ambhw_get_hwaddr(struct ambeth_info *lp, u8 *hwaddr)
+{
+	u32 hval;
+	u32 lval;
+
+	hval = amba_readl(lp->regbase + ETH_MAC_MAC0_HI_OFFSET);
+	lval = amba_readl(lp->regbase + ETH_MAC_MAC0_LO_OFFSET);
+	hwaddr[5] = ((hval >> 8) & 0xff);
+	hwaddr[4] = ((hval >> 0) & 0xff);
+	hwaddr[3] = ((lval >> 24) & 0xff);
+	hwaddr[2] = ((lval >> 16) & 0xff);
+	hwaddr[1] = ((lval >> 8) & 0xff);
+	hwaddr[0] = ((lval >> 0) & 0xff);
+}
+
+static void ambeth_fc_resolve(struct ambeth_info *lp);
+
+static inline void ambhw_set_link_mode_speed(struct ambeth_info *lp)
+{
+	u32 val;
+
+	val = amba_readl(lp->regbase + ETH_MAC_CFG_OFFSET);
+	switch (lp->oldspeed) {
+	case SPEED_1000:
+		val &= ~(ETH_MAC_CFG_PS);
+		break;
+	case SPEED_100:
+		val |= ETH_MAC_CFG_PS;
+		val |= ETH_MAC_CFG_FES;
+		break;
+	case SPEED_10:
+		val |= ETH_MAC_CFG_PS;
+		val &= ~(ETH_MAC_CFG_FES);
+		break;
+	default:
+		break;
+	}
+	if (lp->oldduplex) {
+		val &= ~(ETH_MAC_CFG_DO);
+		val |= ETH_MAC_CFG_DM;
+	} else {
+		val &= ~(ETH_MAC_CFG_DM);
+		val |= ETH_MAC_CFG_DO;
+	}
+	amba_writel(lp->regbase + ETH_MAC_CFG_OFFSET, val);
+	ambeth_fc_resolve(lp);
+}
+
+static inline int ambhw_enable(struct ambeth_info *lp)
+{
+	int ret_val = 0;
+	u32 val;
+
+	ret_val = ambhw_dma_reset(lp);
+	if (ret_val)
+		goto ambhw_init_exit;
+
+	ambhw_set_hwaddr(lp, lp->ndev->dev_addr);
+
+	val = ETH_DMA_BUS_MODE_FB | ETH_DMA_BUS_MODE_PBL_32 |
+		ETH_DMA_BUS_MODE_DA_RX;
+
+	if(ETH_ENHANCED)
+		val |= ETH_DMA_BUS_MODE_ATDS;
+
+	amba_writel(lp->regbase + ETH_DMA_BUS_MODE_OFFSET, val);
+	amba_writel(lp->regbase + ETH_MAC_FRAME_FILTER_OFFSET, 0);
+
+	val = ETH_DMA_OPMODE_TTC_256 | ETH_DMA_OPMODE_RTC_64 |
+		ETH_DMA_OPMODE_FUF | ETH_DMA_OPMODE_TSF;
+	amba_writel(lp->regbase + ETH_DMA_OPMODE_OFFSET, val);
+	amba_writel(lp->regbase + ETH_MAC_CFG_OFFSET,
+		(ETH_MAC_CFG_TE | ETH_MAC_CFG_RE));
+
+	/*
+	 * (512 bits / N) * pause_time = actual pause time
+	 * ex:
+	 *     512 bits / 1 Gbps * 1954 = ~0.0010 sec = 1 ms
+	 *     512 bits / 100 Mbps * 1954 = ~0.010 sec = 10 ms
+	 */
+	amba_writel(lp->regbase + ETH_MAC_FLOW_CTR_OFFSET,
+		ETH_MAC_FLOW_CTR_PLT_256 |
+		ETH_MAC_FLOW_CTR_PT(AMBETH_FC_PAUSE_TIME));
+
+	if (lp->ipc_rx) {
+		amba_setbitsl(lp->regbase + ETH_DMA_OPMODE_OFFSET,
+				ETH_DMA_OPMODE_RSF);
+		amba_setbitsl(lp->regbase + ETH_MAC_CFG_OFFSET,
+				ETH_MAC_CFG_IPC);
+	}
+
+	if (lp->dump_rx_all) {
+		amba_setbitsl(lp->regbase + ETH_MAC_FRAME_FILTER_OFFSET,
+				ETH_MAC_FRAME_FILTER_RA);
+	}
+
+	if(ETH_ENHANCED)
+		amba_writel(lp->regbase + ETH_MAC_INTERRUPT_MASK_OFFSET,0xFFFFFFFF);
+
+	amba_writel(lp->regbase + ETH_DMA_STATUS_OFFSET,
+		amba_readl(lp->regbase + ETH_DMA_STATUS_OFFSET));
+
+ambhw_init_exit:
+	return ret_val;
+}
+
+static inline void ambhw_disable(struct ambeth_info *lp)
+{
+	ambhw_stop_tx_rx(lp);
+	ambhw_dma_int_disable(lp);
+}
+
+static void ambhw_dump_buffer(const char *msg,
+	unsigned char *data, unsigned int length)
+{
+	unsigned int i;
+
+	if (msg)
+		printk("%s", msg);
+	for (i = 0; i < length; i++) {
+		if (i % 16 == 0) {
+			printk("\n%03X:", i);
+		}
+		printk(" %02x", data[i]);
+	}
+	printk("\n");
+}
+
+/* ==========================================================================*/
+static int ambhw_mdio_read(struct mii_bus *bus,
+	int mii_id, int regnum)
+{
+	struct ambeth_info *lp = bus->priv;
+	int val, cnt;
+
+	for (cnt = AMBETH_MII_RETRY_CNT; cnt > 0; cnt--) {
+		if (!amba_tstbitsl(lp->regbase + ETH_MAC_GMII_ADDR_OFFSET,
+			ETH_MAC_GMII_ADDR_GB))
+			break;
+		udelay(10);
+	}
+	if ((cnt <= 0) && netif_msg_hw(lp)) {
+		dev_err(&lp->ndev->dev, "MII Error: Preread tmo!\n");
+		val = 0xFFFFFFFF;
+		goto ambhw_mdio_read_exit;
+	}
+
+	val = ETH_MAC_GMII_ADDR_PA(mii_id) | ETH_MAC_GMII_ADDR_GR(regnum);
+	val |= ETH_MAC_GMII_ADDR_CR_250_300MHZ | ETH_MAC_GMII_ADDR_GB;
+	amba_writel(lp->regbase + ETH_MAC_GMII_ADDR_OFFSET, val);
+
+	for (cnt = AMBETH_MII_RETRY_CNT; cnt > 0; cnt--) {
+		if (!amba_tstbitsl(lp->regbase + ETH_MAC_GMII_ADDR_OFFSET,
+			ETH_MAC_GMII_ADDR_GB))
+			break;
+		udelay(10);
+	}
+	if ((cnt <= 0) && netif_msg_hw(lp)) {
+		dev_err(&lp->ndev->dev, "MII Error: Postread tmo!\n");
+		val = 0xFFFFFFFF;
+		goto ambhw_mdio_read_exit;
+	}
+
+	val = amba_readl(lp->regbase + ETH_MAC_GMII_DATA_OFFSET);
+
+ambhw_mdio_read_exit:
+	if (netif_msg_hw(lp))
+		dev_info(&lp->ndev->dev,
+			"MII Read: addr[0x%02x], reg[0x%02x], val[0x%04x].\n",
+			mii_id, regnum, val);
+
+	return val;
+}
+
+static int ambhw_mdio_write(struct mii_bus *bus,
+	int mii_id, int regnum, u16 value)
+{
+	int ret_val = 0;
+	struct ambeth_info *lp;
+	int val;
+	int cnt = 0;
+
+	lp = (struct ambeth_info *)bus->priv;
+
+	if (netif_msg_hw(lp))
+		dev_info(&lp->ndev->dev,
+			"MII Write: id[0x%02x], add[0x%02x], val[0x%04x].\n",
+			mii_id, regnum, value);
+
+	for (cnt = AMBETH_MII_RETRY_CNT; cnt > 0; cnt--) {
+		if (!amba_tstbitsl(lp->regbase + ETH_MAC_GMII_ADDR_OFFSET,
+			ETH_MAC_GMII_ADDR_GB))
+			break;
+		udelay(10);
+	}
+	if ((cnt <= 0) && netif_msg_hw(lp)) {
+		dev_err(&lp->ndev->dev, "MII Error: Prewrite tmo!\n");
+		ret_val = -EIO;
+		goto ambhw_mdio_write_exit;
+	}
+
+	val = value;
+	amba_writel(lp->regbase + ETH_MAC_GMII_DATA_OFFSET, val);
+	val = ETH_MAC_GMII_ADDR_PA(mii_id) | ETH_MAC_GMII_ADDR_GR(regnum);
+	val |= ETH_MAC_GMII_ADDR_CR_250_300MHZ | ETH_MAC_GMII_ADDR_GW |
+		ETH_MAC_GMII_ADDR_GB;
+	amba_writel(lp->regbase + ETH_MAC_GMII_ADDR_OFFSET, val);
+
+	for (cnt = AMBETH_MII_RETRY_CNT; cnt > 0; cnt--) {
+		if (!amba_tstbitsl(lp->regbase + ETH_MAC_GMII_ADDR_OFFSET,
+			ETH_MAC_GMII_ADDR_GB))
+			break;
+		udelay(10);
+	}
+	if ((cnt <= 0) && netif_msg_hw(lp)) {
+		dev_err(&lp->ndev->dev, "MII Error: Postwrite tmo!\n");
+		ret_val = -EIO;
+		goto ambhw_mdio_write_exit;
+	}
+
+ambhw_mdio_write_exit:
+	return ret_val;
+}
+
+static int ambhw_mdio_reset(struct mii_bus *bus)
+{
+	struct ambeth_info *lp = bus->priv;
+	int ret_val = 0;
+
+	if (netif_msg_hw(lp)) {
+		dev_info(&lp->ndev->dev, "MII Info: Power gpio = %d, "
+			"Reset gpio = %d.\n", lp->pwr_gpio, lp->rst_gpio);
+	}
+
+	if (gpio_is_valid(lp->pwr_gpio))
+		gpio_set_value_cansleep(lp->pwr_gpio, !lp->pwr_gpio_active);
+	if (gpio_is_valid(lp->rst_gpio))
+		gpio_set_value_cansleep(lp->rst_gpio, lp->rst_gpio_active);
+	if (gpio_is_valid(lp->pwr_gpio))
+		gpio_set_value_cansleep(lp->pwr_gpio, lp->pwr_gpio_active);
+	if (gpio_is_valid(lp->rst_gpio))
+		gpio_set_value_cansleep(lp->rst_gpio, !lp->rst_gpio_active);
+
+	/* waiting for PHY working stable, this delay is a must */
+	msleep(50);
+
+	return ret_val;
+}
+
+/* ==========================================================================*/
+static void ambeth_adjust_link(struct net_device *ndev)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+	struct phy_device *phydev = lp->phydev;
+	int need_update = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&lp->lock, flags);
+
+	if (phydev->link) {
+		if (phydev->duplex != lp->oldduplex) {
+			need_update = 1;
+			lp->oldduplex = phydev->duplex;
+		}
+		if (phydev->speed != lp->oldspeed) {
+			switch (phydev->speed) {
+			case SPEED_1000:
+			case SPEED_100:
+			case SPEED_10:
+				need_update = 1;
+				lp->oldspeed = phydev->speed;
+				break;
+			default:
+				if (netif_msg_link(lp))
+					dev_warn(&lp->ndev->dev,
+						"Unknown Speed(%d).\n",
+						phydev->speed);
+				break;
+			}
+		}
+		if (phydev->pause != lp->oldpause ||
+		    phydev->asym_pause != lp->oldasym_pause) {
+			lp->oldpause = phydev->pause;
+			lp->oldasym_pause = phydev->asym_pause;
+			need_update = 1;
+		}
+		if (lp->oldlink != phydev->link) {
+			need_update = 1;
+			lp->oldlink = phydev->link;
+		}
+	} else if (lp->oldlink) {
+		need_update = 1;
+		lp->oldlink = PHY_DOWN;
+		lp->oldspeed = 0;
+		lp->oldduplex = -1;
+	}
+
+	if (need_update) {
+		ambhw_set_link_mode_speed(lp);
+		if (netif_msg_link(lp))
+			phy_print_status(phydev);
+	}
+	spin_unlock_irqrestore(&lp->lock, flags);
+}
+
+static void ambeth_fc_config(struct ambeth_info *lp)
+{
+	u32 sup, adv, flow_ctr;
+
+	sup = lp->phydev->supported;
+	adv = lp->phydev->advertising;
+	flow_ctr = lp->flow_ctr;
+
+	sup |= (SUPPORTED_Pause | SUPPORTED_Asym_Pause);
+	adv &= ~(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+
+	sup &= lp->phy_supported;
+
+	if (!(sup & (SUPPORTED_Pause | SUPPORTED_Asym_Pause)))
+		goto unsupported;
+
+        if (lp->fixed_speed != SPEED_UNKNOWN)
+		goto autoneg_unsupported;
+
+	if (!(sup & SUPPORTED_Autoneg) ||
+	    !(flow_ctr & AMBARELLA_ETH_FC_AUTONEG))
+		goto autoneg_unsupported;
+
+	if (flow_ctr & AMBARELLA_ETH_FC_RX) {
+		/*
+		 * Being able to decode pause frames is sufficently to
+		 * advertise that we support both sym. and asym. pause.
+		 * It doesn't matter if send pause frame or not.
+                 */
+		adv |= (ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+		goto done;
+	}
+
+	if (flow_ctr & AMBARELLA_ETH_FC_TX) {
+		/* Tell the link parter that we do send the pause frame. */
+		adv |= ADVERTISED_Asym_Pause;
+		goto done;
+	}
+	goto done;
+
+autoneg_unsupported:
+	/* Sanitize the config value */
+	lp->flow_ctr &= ~AMBARELLA_ETH_FC_AUTONEG;
+
+	/* Advertise nothing about pause frame */
+	adv &= ~(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+	goto done;
+
+unsupported:
+	/* Sanitize the config value */
+	lp->flow_ctr &= ~(AMBARELLA_ETH_FC_AUTONEG |
+					 AMBARELLA_ETH_FC_RX |
+					 AMBARELLA_ETH_FC_TX);
+done:
+	lp->phydev->advertising = adv;
+	lp->phydev->supported = sup;
+	dev_info(&lp->ndev->dev, "adv: sym %d, asym: %d\n",
+		 !!(adv & ADVERTISED_Pause),
+		 !!(adv & ADVERTISED_Asym_Pause));
+}
+
+static void ambeth_fc_resolve(struct ambeth_info *lp)
+{
+	u32 flow_ctr, fc, old_fc;
+
+	flow_ctr = lp->flow_ctr;
+
+	if (!(flow_ctr & AMBARELLA_ETH_FC_AUTONEG))
+		goto force_setting;
+
+	fc = old_fc = amba_readl(lp->regbase + ETH_MAC_FLOW_CTR_OFFSET);
+
+	dev_info(&lp->ndev->dev, "lp: sym: %d, asym: %d\n",
+		 lp->phydev->pause, lp->phydev->asym_pause);
+	/*
+	 * Decode pause frames only if user specified, and the link
+	 * partner could send them on the same time.
+	 */
+	if ((flow_ctr & AMBARELLA_ETH_FC_RX) &&
+	    (lp->phydev->pause || lp->phydev->asym_pause))
+		fc |= ETH_MAC_FLOW_CTR_RFE;
+	else
+		fc &= ~ETH_MAC_FLOW_CTR_RFE;
+
+	/*
+	 * Send pause frames only if user specified, and the link
+	 * partner can resopnds to them on the same time.
+	 */
+	if ((flow_ctr & AMBARELLA_ETH_FC_TX) && lp->phydev->pause)
+		fc |= ETH_MAC_FLOW_CTR_TFE;
+	else
+		fc &= ~ETH_MAC_FLOW_CTR_TFE;
+
+	if (fc != old_fc)
+		amba_writel(lp->regbase + ETH_MAC_FLOW_CTR_OFFSET, fc);
+
+	return;
+
+force_setting:
+
+	if (flow_ctr & AMBARELLA_ETH_FC_TX)
+		amba_setbitsl(lp->regbase + ETH_MAC_FLOW_CTR_OFFSET,
+			ETH_MAC_FLOW_CTR_TFE);
+
+	if (flow_ctr & AMBARELLA_ETH_FC_RX)
+		amba_setbitsl(lp->regbase + ETH_MAC_FLOW_CTR_OFFSET,
+			ETH_MAC_FLOW_CTR_RFE);
+}
+
+static int ambeth_phy_start(struct ambeth_info *lp)
+{
+	struct net_device *ndev = lp->ndev;
+	struct phy_device *phydev = lp->phydev;
+	phy_interface_t intf;
+	int ret_val = 0;
+	unsigned long flags;
+
+	if (lp->phy_enabled)
+		return 0;
+
+	lp->oldlink = PHY_DOWN;
+	lp->oldspeed = 0;
+	lp->oldduplex = -1;
+
+	/* Fixed Link mode: we allow all valid fixed_speed,
+	   even HW can not support the speed. */
+	switch (lp->fixed_speed) {
+	case SPEED_1000:
+	case SPEED_100:
+	case SPEED_10:
+		lp->oldlink = PHY_RUNNING;
+		lp->oldspeed = lp->fixed_speed;
+		lp->oldduplex = DUPLEX_FULL;
+		ambhw_set_link_mode_speed(lp);
+		dev_notice(&lp->ndev->dev, "Fixed Link - %d/%s\n", lp->oldspeed,
+			((lp->oldduplex == DUPLEX_FULL) ? "Full" : "Half"));
+		netif_carrier_on(ndev);
+		goto ambeth_init_phy_exit;
+		break;
+	default:
+		break;
+	}
+
+	intf = ambhw_get_interface(lp);
+	ret_val = phy_connect_direct(ndev, phydev, &ambeth_adjust_link, intf);
+	if (ret_val) {
+		dev_err(&lp->ndev->dev, "Could not attach to PHY!\n");
+		goto ambeth_init_phy_exit;
+	}
+
+	phydev->supported &= lp->phy_supported;
+	phydev->advertising = phydev->supported;
+
+	spin_lock_irqsave(&lp->lock, flags);
+	lp->phy_enabled = 1;
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	ambeth_fc_config(lp);
+	ret_val = phy_start_aneg(phydev);
+
+	ambeth_fc_resolve(lp);
+
+ambeth_init_phy_exit:
+	return ret_val;
+}
+
+static void ambeth_phy_stop(struct ambeth_info *lp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&lp->lock, flags);
+	lp->phy_enabled = 0;
+	lp->oldlink = PHY_DOWN;
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	phy_disconnect(lp->phydev);
+}
+
+static inline int ambeth_rx_rngmng_check_skb(struct ambeth_info *lp, u32 entry)
+{
+	int ret_val = 0;
+	dma_addr_t mapping;
+	struct sk_buff *skb;
+
+	if (lp->rx.rng_rx[entry].skb == NULL) {
+		skb = netdev_alloc_skb(lp->ndev, AMBETH_PACKET_MAXFRAME);
+		if (skb == NULL) {
+			if (netif_msg_drv(lp))
+				dev_err(&lp->ndev->dev,
+				"RX Error: netdev_alloc_skb.\n");
+			ret_val = -ENOMEM;
+			goto ambeth_rx_rngmng_skb_exit;
+		}
+		mapping = dma_map_single(&lp->ndev->dev, skb->data,
+			AMBETH_PACKET_MAXFRAME, DMA_FROM_DEVICE);
+		lp->rx.rng_rx[entry].skb = skb;
+		lp->rx.rng_rx[entry].mapping = mapping;
+		lp->rx.desc_rx[entry].buffer1 = mapping;
+	}
+
+ambeth_rx_rngmng_skb_exit:
+	return ret_val;
+}
+
+static inline void ambeth_rx_rngmng_init(struct ambeth_info *lp)
+{
+	int i;
+
+	lp->rx.cur_rx = 0;
+	lp->rx.dirty_rx = 0;
+	for (i = 0; i < lp->rx_count; i++) {
+		if (ambeth_rx_rngmng_check_skb(lp, i))
+			break;
+		lp->rx.desc_rx[i].status = ETH_RDES0_OWN;
+		lp->rx.desc_rx[i].length = (ETH_RDES1_RCH |
+			ETH_RDES1_RBS1x(AMBETH_PACKET_MAXFRAME));
+		lp->rx.desc_rx[i].buffer2 = (u32)lp->rx_dma_desc +
+			((i + 1) * sizeof(struct ambeth_desc));
+	}
+	lp->rx.desc_rx[lp->rx_count - 1].buffer2 = (u32)lp->rx_dma_desc;
+}
+
+static inline void ambeth_rx_rngmng_refill(struct ambeth_info *lp)
+{
+	u32 i;
+	unsigned int dirty_diff;
+	u32 entry;
+
+	dirty_diff = (lp->rx.cur_rx - lp->rx.dirty_rx);
+	for (i = 0; i < dirty_diff; i++) {
+		entry = lp->rx.dirty_rx % lp->rx_count;
+		if (ambeth_rx_rngmng_check_skb(lp, entry))
+			break;
+		lp->rx.desc_rx[entry].status = ETH_RDES0_OWN;
+		lp->rx.dirty_rx++;
+	}
+}
+
+static inline void ambeth_rx_rngmng_del(struct ambeth_info *lp)
+{
+	int i;
+	dma_addr_t mapping;
+	struct sk_buff *skb;
+
+	for (i = 0; i < lp->rx_count; i++) {
+		if (lp->rx.rng_rx) {
+			skb = lp->rx.rng_rx[i].skb;
+			mapping = lp->rx.rng_rx[i].mapping;
+			lp->rx.rng_rx[i].skb = NULL;
+			lp->rx.rng_rx[i].mapping = 0;
+			if (mapping) {
+				dma_unmap_single(&lp->ndev->dev, mapping,
+					AMBETH_PACKET_MAXFRAME,
+					DMA_FROM_DEVICE);
+			}
+			if (skb) {
+				dev_kfree_skb(skb);
+			}
+		}
+		if (lp->rx.desc_rx) {
+			lp->rx.desc_rx[i].status = 0;
+			lp->rx.desc_rx[i].length = 0;
+			lp->rx.desc_rx[i].buffer1 = 0xBADF00D0;
+			lp->rx.desc_rx[i].buffer2 = 0xBADF00D0;
+		}
+	}
+}
+
+static inline void ambeth_tx_rngmng_init(struct ambeth_info *lp)
+{
+	u32 i;
+
+	lp->tx.cur_tx = 0;
+	lp->tx.dirty_tx = 0;
+	for (i = 0; i < lp->tx_count; i++) {
+		lp->tx.rng_tx[i].mapping = 0;
+		lp->tx.desc_tx[i].length = 0;
+		amba_set_eth_desc(&lp->tx.desc_tx[i], ETH_TDES_LS | ETH_TDES_FS
+			| ETH_TDES_TCH);
+		lp->tx.desc_tx[i].buffer1 = 0;
+		lp->tx.desc_tx[i].buffer2 = (u32)lp->tx_dma_desc +
+			((i + 1) * sizeof(struct ambeth_desc));
+	}
+	lp->tx.desc_tx[lp->tx_count - 1].buffer2 = (u32)lp->tx_dma_desc;
+}
+
+static inline void ambeth_tx_rngmng_del(struct ambeth_info *lp)
+{
+	u32 i;
+	dma_addr_t mapping;
+	struct sk_buff *skb;
+
+	for (i = 0; i < lp->tx_count; i++) {
+		if (lp->tx.rng_tx) {
+			skb = lp->tx.rng_tx[i].skb;
+			mapping = lp->tx.rng_tx[i].mapping;
+			lp->tx.rng_tx[i].skb = NULL;
+			lp->tx.rng_tx[i].mapping = 0;
+			if (skb) {
+				dma_unmap_single(&lp->ndev->dev, mapping,
+					skb->len, DMA_TO_DEVICE);
+				dev_kfree_skb(skb);
+			}
+		}
+		if (lp->tx.desc_tx) {
+			lp->tx.desc_tx[i].status = 0;
+			lp->tx.desc_tx[i].length = 0;
+			lp->tx.desc_tx[i].buffer1 = 0xBADF00D0;
+			lp->tx.desc_tx[i].buffer2 = 0xBADF00D0;
+		}
+	}
+}
+
+static inline void ambeth_check_dma_error(struct ambeth_info *lp,
+	u32 irq_status)
+{
+	u32 miss_ov = 0;
+
+	if (unlikely(irq_status & ETH_DMA_STATUS_AIS)) {
+		if (irq_status & (ETH_DMA_STATUS_RU | ETH_DMA_STATUS_OVF))
+			miss_ov = amba_readl(lp->regbase +
+				ETH_DMA_MISS_FRAME_BOCNT_OFFSET);
+
+		if (irq_status & ETH_DMA_STATUS_FBI) {
+			if (netif_msg_drv(lp))
+				dev_err(&lp->ndev->dev,
+				"DMA Error: Fatal Bus Error 0x%x.\n",
+				(irq_status & ETH_DMA_STATUS_EB_MASK));
+		}
+		if (irq_status & ETH_DMA_STATUS_ETI) {
+			if (netif_msg_tx_err(lp))
+				dev_err(&lp->ndev->dev,
+				"DMA Error: Early Transmit.\n");
+		}
+		if (irq_status & ETH_DMA_STATUS_RWT) {
+			if (netif_msg_rx_err(lp))
+				dev_err(&lp->ndev->dev,
+				"DMA Error: Receive Watchdog Timeout.\n");
+		}
+		if (irq_status & ETH_DMA_STATUS_RPS) {
+			if (netif_msg_rx_err(lp))
+				dev_err(&lp->ndev->dev,
+				"DMA Error: Receive Process Stopped.\n");
+		}
+		if (irq_status & ETH_DMA_STATUS_RU) {
+			if (miss_ov & ETH_DMA_MISS_FRAME_BOCNT_FRAME) {
+				lp->stats.rx_dropped +=
+					ETH_DMA_MISS_FRAME_BOCNT_HOST(miss_ov);
+			}
+			if (netif_msg_rx_err(lp))
+				dev_err(&lp->ndev->dev,
+				"DMA Error: Receive Buffer Unavailable, %u.\n",
+				ETH_DMA_MISS_FRAME_BOCNT_HOST(miss_ov));
+		}
+		if (irq_status & ETH_DMA_STATUS_UNF) {
+			if (netif_msg_tx_err(lp))
+				dev_err(&lp->ndev->dev,
+				"DMA Error: Transmit Underflow.\n");
+		}
+		if (irq_status & ETH_DMA_STATUS_OVF) {
+			if (miss_ov & ETH_DMA_MISS_FRAME_BOCNT_FIFO) {
+				lp->stats.rx_fifo_errors +=
+					ETH_DMA_MISS_FRAME_BOCNT_APP(miss_ov);
+			}
+			if (netif_msg_rx_err(lp))
+				dev_err(&lp->ndev->dev,
+				"DMA Error: Receive FIFO Overflow, %u.\n",
+				ETH_DMA_MISS_FRAME_BOCNT_APP(miss_ov));
+		}
+		if (irq_status & ETH_DMA_STATUS_TJT) {
+			lp->stats.tx_errors++;
+			if (netif_msg_drv(lp))
+				dev_err(&lp->ndev->dev,
+				"DMA Error: Transmit Jabber Timeout.\n");
+		}
+		if (irq_status & ETH_DMA_STATUS_TPS) {
+			if (netif_msg_tx_err(lp))
+				dev_err(&lp->ndev->dev,
+				"DMA Error: Transmit Process Stopped.\n");
+		}
+		if (netif_msg_tx_err(lp) || netif_msg_rx_err(lp)) {
+			dev_err(&lp->ndev->dev, "DMA Error: Abnormal: 0x%x.\n",
+				irq_status);
+			ambhw_dump(lp);
+		}
+	}
+}
+
+static inline void ambeth_pause_frame(struct ambeth_info *lp)
+{
+	u32					fc;
+
+	fc = amba_readl(lp->regbase + ETH_MAC_FLOW_CTR_OFFSET);
+	if (!(fc & ETH_MAC_FLOW_CTR_TFE))
+		return;
+
+	fc |= ETH_MAC_FLOW_CTR_FCBBPA;
+
+	amba_writel(lp->regbase + ETH_MAC_FLOW_CTR_OFFSET, fc);
+}
+
+static inline void ambeth_interrupt_rx(struct ambeth_info *lp, u32 irq_status)
+{
+	if (irq_status & AMBETH_RXDMA_STATUS) {
+		amba_clrbitsl(lp->regbase + ETH_DMA_INTEN_OFFSET,
+			AMBETH_RXDMA_INTEN);
+		napi_schedule(&lp->napi);
+	}
+}
+
+static inline void ambeth_interrupt_gmac(struct ambeth_info *lp, u32 irq_status)
+{
+	if(ETH_ENHANCED) {
+		u32 tmp_reg;
+
+		if (irq_status & ETH_DMA_STATUS_GPI) {
+			dev_vdbg(&lp->ndev->dev, "ETH_DMA_STATUS_GPI\n");
+		}
+		if (irq_status & ETH_DMA_STATUS_GMI) {
+			dev_vdbg(&lp->ndev->dev, "ETH_DMA_STATUS_GMI\n");
+		}
+		if (irq_status & ETH_DMA_STATUS_GLI) {
+			dev_vdbg(&lp->ndev->dev, "ETH_DMA_STATUS_GLI\n");
+			tmp_reg = amba_readl(lp->regbase +
+				ETH_MAC_INTERRUPT_STATUS_OFFSET);
+			dev_vdbg(&lp->ndev->dev,
+				"ETH_MAC_INTERRUPT_STATUS_OFFSET = 0x%08X\n",tmp_reg);
+			tmp_reg = amba_readl(lp->regbase +
+				ETH_MAC_INTERRUPT_MASK_OFFSET);
+			dev_vdbg(&lp->ndev->dev,
+				"ETH_MAC_INTERRUPT_MASK_OFFSET = 0x%08X\n",tmp_reg);
+			tmp_reg = amba_readl(lp->regbase +
+				ETH_MAC_AN_STATUS_OFFSET);
+			dev_vdbg(&lp->ndev->dev,
+				"ETH_MAC_AN_STATUS_OFFSET = 0x%08X\n",tmp_reg);
+			tmp_reg = amba_readl(lp->regbase +
+				ETH_MAC_RGMII_CS_OFFSET);
+			dev_vdbg(&lp->ndev->dev,
+				"ETH_MAC_RGMII_CS_OFFSET = 0x%08X\n",tmp_reg);
+			tmp_reg = amba_readl(lp->regbase +
+				ETH_MAC_GPIO_OFFSET);
+			dev_vdbg(&lp->ndev->dev,
+				"ETH_MAC_GPIO_OFFSET = 0x%08X\n",tmp_reg);
+		}
+
+	}
+}
+
+static inline u32 ambeth_check_tdes0_status(struct ambeth_info *lp,
+	unsigned int status)
+{
+	u32 tx_retry = 0;
+
+	if (status & ETH_TDES0_JT) {
+		lp->stats.tx_heartbeat_errors++;
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev, "TX Error: Jabber Timeout.\n");
+	}
+	if (status & ETH_TDES0_FF) {
+		lp->stats.tx_dropped++;
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev, "TX Error: Frame Flushed.\n");
+	}
+	if (status & ETH_TDES0_PCE) {
+		lp->stats.tx_fifo_errors++;
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev,
+			"TX Error: Payload Checksum Error.\n");
+	}
+	if (status & ETH_TDES0_LCA) {
+		lp->stats.tx_carrier_errors++;
+		dev_err(&lp->ndev->dev, "TX Error: Loss of Carrier.\n");
+	}
+	if (status & ETH_TDES0_NC) {
+		lp->stats.tx_carrier_errors++;
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev, "TX Error: No Carrier.\n");
+	}
+	if (status & ETH_TDES0_LCO) {
+		lp->stats.tx_aborted_errors++;
+		lp->stats.collisions++;
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev, "TX Error: Late Collision.\n");
+	}
+	if (status & ETH_TDES0_EC) {
+		lp->stats.tx_aborted_errors++;
+		lp->stats.collisions += ETH_TDES0_CC(status);
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev,
+			"TX Error: Excessive Collision %u.\n",
+			ETH_TDES0_CC(status));
+	}
+	if (status & ETH_TDES0_VF) {
+		if (netif_msg_drv(lp))
+			dev_info(&lp->ndev->dev, "TX Info: VLAN Frame.\n");
+	}
+	if (status & ETH_TDES0_ED) {
+		lp->stats.tx_fifo_errors++;
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev,
+			"TX Error: Excessive Deferral.\n");
+	}
+	if (status & ETH_TDES0_UF) {
+		tx_retry = 1;
+		if (netif_msg_tx_err(lp)) {
+			dev_err(&lp->ndev->dev, "TX Error: Underflow Error.\n");
+			ambhw_dump(lp);
+		}
+	}
+	if (status & ETH_TDES0_DB) {
+		lp->stats.tx_fifo_errors++;
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev, "TX Error: Deferred Bit.\n");
+	}
+
+	return tx_retry;
+}
+
+static inline void ambeth_interrupt_tx(struct ambeth_info *lp, u32 irq_status)
+{
+	u32 i;
+	unsigned int dirty_diff;
+	u32 entry;
+	u32 status;
+
+	if (irq_status & AMBETH_TXDMA_STATUS) {
+		dev_vdbg(&lp->ndev->dev, "cur_tx[%u], dirty_tx[%u], 0x%x.\n",
+			lp->tx.cur_tx, lp->tx.dirty_tx, irq_status);
+		dirty_diff = (lp->tx.cur_tx - lp->tx.dirty_tx);
+		for (i = 0; i < dirty_diff; i++) {
+			entry = (lp->tx.dirty_tx % lp->tx_count);
+			status = lp->tx.desc_tx[entry].status;
+
+			if (status & ETH_TDES0_OWN)
+				break;
+
+			if (unlikely(status & ETH_TDES0_ES)) {
+				if ((status & ETH_TDES0_ES_MASK) ==
+					ETH_TDES0_ES) {
+					break;
+				}
+				if (ambeth_check_tdes0_status(lp, status)) {
+					ambhw_dma_tx_stop(lp);
+					ambhw_dma_tx_restart(lp, entry);
+					ambhw_dma_tx_poll(lp);
+					break;
+				} else {
+					lp->stats.tx_errors++;
+				}
+			} else {
+				if (unlikely(status & ETH_TDES0_IHE)) {
+					if (netif_msg_drv(lp))
+						dev_err(&lp->ndev->dev,
+						"TX Error: IP Header Error.\n");
+				}
+				lp->stats.tx_bytes +=
+					lp->tx.rng_tx[entry].skb->len;
+				lp->stats.tx_packets++;
+			}
+
+			dma_unmap_single(&lp->ndev->dev,
+				lp->tx.rng_tx[entry].mapping,
+				lp->tx.rng_tx[entry].skb->len,
+				DMA_TO_DEVICE);
+			dev_kfree_skb_irq(lp->tx.rng_tx[entry].skb);
+			lp->tx.rng_tx[entry].skb = NULL;
+			lp->tx.rng_tx[entry].mapping = 0;
+			lp->tx.dirty_tx++;
+		}
+		dirty_diff = (lp->tx.cur_tx - lp->tx.dirty_tx);
+		if (dirty_diff && (irq_status & ETH_DMA_STATUS_TU)) {
+			ambhw_dma_tx_poll(lp);
+		}
+		if (likely(dirty_diff < lp->tx_irq_low)) {
+			netif_wake_queue(lp->ndev);
+		}
+		dev_vdbg(&lp->ndev->dev, "cur_tx[%u], dirty_tx[%u], 0x%x.\n",
+			lp->tx.cur_tx, lp->tx.dirty_tx, irq_status);
+	}
+}
+
+static irqreturn_t ambeth_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev;
+	struct ambeth_info *lp;
+	u32 irq_status;
+	unsigned long flags;
+
+	ndev = (struct net_device *)dev_id;
+	lp = netdev_priv(ndev);
+
+	spin_lock_irqsave(&lp->lock, flags);
+	irq_status = amba_readl(lp->regbase + ETH_DMA_STATUS_OFFSET);
+	ambeth_check_dma_error(lp, irq_status);
+	ambeth_interrupt_gmac(lp, irq_status);
+	ambeth_interrupt_rx(lp, irq_status);
+	ambeth_interrupt_tx(lp, irq_status);
+	amba_writel(lp->regbase + ETH_DMA_STATUS_OFFSET, irq_status);
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static int ambeth_start_hw(struct net_device *ndev)
+{
+	int ret_val = 0;
+	struct ambeth_info *lp;
+	unsigned long flags;
+
+	lp = (struct ambeth_info *)netdev_priv(ndev);
+
+	if (gpio_is_valid(lp->pwr_gpio))
+		gpio_set_value_cansleep(lp->pwr_gpio, lp->pwr_gpio_active);
+	if (gpio_is_valid(lp->rst_gpio)) {
+		gpio_set_value_cansleep(lp->rst_gpio, lp->rst_gpio_active);
+		msleep(200);
+		gpio_set_value_cansleep(lp->rst_gpio, !lp->rst_gpio_active);
+	}
+
+	spin_lock_irqsave(&lp->lock, flags);
+	ret_val = ambhw_enable(lp);
+	spin_unlock_irqrestore(&lp->lock, flags);
+	if (ret_val)
+		goto ambeth_start_hw_exit;
+
+	lp->rx.rng_rx = kmalloc((sizeof(struct ambeth_rng_info) *
+		lp->rx_count), GFP_KERNEL);
+	if (lp->rx.rng_rx == NULL) {
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev, "alloc rng_rx fail.\n");
+		ret_val = -ENOMEM;
+		goto ambeth_start_hw_exit;
+	}
+	lp->rx.desc_rx = dma_alloc_coherent(&lp->ndev->dev,
+		(sizeof(struct ambeth_desc) * lp->rx_count),
+		&lp->rx_dma_desc, GFP_KERNEL);
+	if (lp->rx.desc_rx == NULL) {
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev,
+			"dma_alloc_coherent desc_rx fail.\n");
+		ret_val = -ENOMEM;
+		goto ambeth_start_hw_exit;
+	}
+	memset(lp->rx.rng_rx, 0,
+		(sizeof(struct ambeth_rng_info) * lp->rx_count));
+	memset(lp->rx.desc_rx, 0,
+		(sizeof(struct ambeth_desc) * lp->rx_count));
+	ambeth_rx_rngmng_init(lp);
+
+	lp->tx.rng_tx = kmalloc((sizeof(struct ambeth_rng_info) *
+		lp->tx_count), GFP_KERNEL);
+	if (lp->tx.rng_tx == NULL) {
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev, "alloc rng_tx fail.\n");
+		ret_val = -ENOMEM;
+		goto ambeth_start_hw_exit;
+	}
+	lp->tx.desc_tx = dma_alloc_coherent(&lp->ndev->dev,
+		(sizeof(struct ambeth_desc) * lp->tx_count),
+		&lp->tx_dma_desc, GFP_KERNEL);
+	if (lp->tx.desc_tx == NULL) {
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev,
+			"dma_alloc_coherent desc_tx fail.\n");
+		ret_val = -ENOMEM;
+		goto ambeth_start_hw_exit;
+	}
+	memset(lp->tx.rng_tx, 0,
+		(sizeof(struct ambeth_rng_info) * lp->tx_count));
+	memset(lp->tx.desc_tx, 0,
+		(sizeof(struct ambeth_desc) * lp->tx_count));
+	ambeth_tx_rngmng_init(lp);
+
+	spin_lock_irqsave(&lp->lock, flags);
+	ambhw_set_dma_desc(lp);
+	ambhw_dma_rx_start(lp);
+	ambhw_dma_tx_start(lp);
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+ambeth_start_hw_exit:
+	return ret_val;
+}
+
+static void ambeth_stop_hw(struct net_device *ndev)
+{
+	struct ambeth_info *lp;
+	unsigned long flags;
+
+	lp = (struct ambeth_info *)netdev_priv(ndev);
+
+	spin_lock_irqsave(&lp->lock, flags);
+	ambhw_disable(lp);
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	ambeth_tx_rngmng_del(lp);
+	if (lp->tx.desc_tx) {
+		dma_free_coherent(&lp->ndev->dev,
+			(sizeof(struct ambeth_desc) * lp->tx_count),
+			lp->tx.desc_tx, lp->tx_dma_desc);
+		lp->tx.desc_tx = NULL;
+	}
+	if (lp->tx.rng_tx) {
+		kfree(lp->tx.rng_tx);
+		lp->tx.rng_tx = NULL;
+	}
+
+	ambeth_rx_rngmng_del(lp);
+	if (lp->rx.desc_rx) {
+		dma_free_coherent(&lp->ndev->dev,
+			(sizeof(struct ambeth_desc) * lp->rx_count),
+			lp->rx.desc_rx, lp->rx_dma_desc);
+		lp->rx.desc_rx = NULL;
+	}
+	if (lp->rx.rng_rx) {
+		kfree(lp->rx.rng_rx);
+		lp->rx.rng_rx = NULL;
+	}
+
+	if (gpio_is_valid(lp->pwr_gpio))
+		gpio_set_value_cansleep(lp->pwr_gpio, !lp->pwr_gpio_active);
+	if (gpio_is_valid(lp->rst_gpio))
+		gpio_set_value_cansleep(lp->rst_gpio, lp->rst_gpio_active);
+}
+
+static int ambeth_open(struct net_device *ndev)
+{
+	int ret_val = 0;
+	struct ambeth_info *lp;
+
+	lp = (struct ambeth_info *)netdev_priv(ndev);
+
+	ret_val = ambeth_start_hw(ndev);
+	if (ret_val)
+		goto ambeth_open_exit;
+
+	ret_val = request_irq(ndev->irq, ambeth_interrupt,
+		IRQF_SHARED | IRQF_TRIGGER_HIGH, ndev->name, ndev);
+	if (ret_val) {
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev,
+			"Request_irq[%d] fail.\n", ndev->irq);
+		goto ambeth_open_exit;
+	}
+
+	napi_enable(&lp->napi);
+	netif_start_queue(ndev);
+	ambhw_dma_int_enable(lp);
+
+	netif_carrier_off(ndev);
+	ret_val = ambeth_phy_start(lp);
+	if (ret_val) {
+		netif_stop_queue(ndev);
+		napi_disable(&lp->napi);
+		free_irq(ndev->irq, ndev);
+	}
+
+ambeth_open_exit:
+	if (ret_val) {
+		ambeth_stop_hw(ndev);
+	}
+
+	return ret_val;
+}
+
+static int ambeth_stop(struct net_device *ndev)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+	int ret_val = 0;
+
+	netif_stop_queue(ndev);
+	napi_disable(&lp->napi);
+	free_irq(ndev->irq, ndev);
+	ambeth_phy_stop(lp);
+	netif_carrier_off(ndev);
+	ambeth_stop_hw(ndev);
+
+	return ret_val;
+}
+
+static int ambeth_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	int ret_val = 0;
+	struct ambeth_info *lp;
+	dma_addr_t mapping;
+	u32 entry;
+	unsigned int dirty_diff;
+	u32 tx_flag;
+	unsigned long flags;
+
+	lp = (struct ambeth_info *)netdev_priv(ndev);
+	tx_flag = ETH_TDES_LS | ETH_TDES_FS | ETH_TDES_TCH;
+
+	spin_lock_irqsave(&lp->lock, flags);
+	dirty_diff = (lp->tx.cur_tx - lp->tx.dirty_tx);
+	entry = (lp->tx.cur_tx % lp->tx_count);
+	if (dirty_diff == lp->tx_irq_high) {
+		tx_flag |= ETH_TDES_IC;
+	} else if (dirty_diff == (lp->tx_count - 1)) {
+		netif_stop_queue(ndev);
+		tx_flag |= ETH_TDES_IC;
+	} else if (dirty_diff >= lp->tx_count) {
+		netif_stop_queue(ndev);
+		ret_val = -ENOMEM;
+		ambhw_dma_tx_poll(lp);
+		spin_unlock_irqrestore(&lp->lock, flags);
+		dev_err(&lp->ndev->dev, "TX Error: TX OV.\n");
+		goto ambeth_hard_start_xmit_exit;
+	}
+	if (unlikely(lp->dump_tx))
+		ambhw_dump_buffer(__func__, skb->data, skb->len);
+
+	mapping = dma_map_single(&lp->ndev->dev,
+		skb->data, skb->len, DMA_TO_DEVICE);
+	if (lp->ipc_tx && (skb->ip_summed == CHECKSUM_PARTIAL)) {
+		tx_flag |= ETH_TDES_CIC;
+	}
+
+	lp->tx.rng_tx[entry].skb = skb;
+	lp->tx.rng_tx[entry].mapping = mapping;
+	lp->tx.desc_tx[entry].buffer1 = mapping;
+	lp->tx.desc_tx[entry].length = ETH_TDES1_TBS1x(skb->len);
+	lp->tx.desc_tx[entry].status = 0;
+	amba_set_eth_desc(&lp->tx.desc_tx[entry], tx_flag);
+	lp->tx.desc_tx[entry].status |= ETH_TDES0_OWN;
+
+	lp->tx.cur_tx++;
+	ambhw_dma_tx_poll(lp);
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	ndev->trans_start = jiffies;
+	dev_vdbg(&lp->ndev->dev, "TX Info: cur_tx[%u], dirty_tx[%u], "
+		"entry[%u], len[%u], data_len[%u], ip_summed[%u], "
+		"csum_start[%u], csum_offset[%u].\n",
+		lp->tx.cur_tx, lp->tx.dirty_tx, entry, skb->len, skb->data_len,
+		skb->ip_summed, skb->csum_start, skb->csum_offset);
+
+ambeth_hard_start_xmit_exit:
+	return ret_val;
+}
+
+static void ambeth_timeout(struct net_device *ndev)
+{
+	struct ambeth_info *lp;
+	unsigned long flags;
+	u32 irq_status;
+
+	lp = (struct ambeth_info *)netdev_priv(ndev);
+
+	dev_info(&lp->ndev->dev, "OOM Info:...\n");
+	spin_lock_irqsave(&lp->lock, flags);
+	irq_status = amba_readl(lp->regbase + ETH_DMA_STATUS_OFFSET);
+	ambeth_interrupt_tx(lp, irq_status | AMBETH_TXDMA_STATUS);
+	ambhw_dump(lp);
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	netif_wake_queue(ndev);
+}
+
+static struct net_device_stats *ambeth_get_stats(struct net_device *ndev)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+
+	return &lp->stats;
+}
+
+static void ambhw_dump_rx(struct ambeth_info *lp, u32 status, u32 entry)
+{
+	short pkt_len;
+	struct sk_buff *skb;
+	dma_addr_t mapping;
+
+	pkt_len = ETH_RDES0_FL(status) - 4;
+	if (unlikely(pkt_len > AMBETH_RX_COPYBREAK)) {
+		dev_warn(&lp->ndev->dev, "Bogus packet size %u.\n", pkt_len);
+		pkt_len = AMBETH_RX_COPYBREAK;
+	}
+
+	skb = lp->rx.rng_rx[entry].skb;
+	mapping = lp->rx.rng_rx[entry].mapping;
+	if (likely(skb && mapping)) {
+		dma_unmap_single(&lp->ndev->dev, mapping,
+			AMBETH_PACKET_MAXFRAME, DMA_FROM_DEVICE);
+		skb_put(skb, pkt_len);
+		lp->rx.rng_rx[entry].skb = NULL;
+		lp->rx.rng_rx[entry].mapping = 0;
+		ambhw_dump_buffer(__func__, skb->data, skb->len);
+		dev_kfree_skb(skb);
+	}
+}
+
+static inline void ambeth_check_rdes0_status(struct ambeth_info *lp,
+	u32 status, u32 entry)
+{
+	if (status & ETH_RDES0_DE) {
+		lp->stats.rx_frame_errors++;
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev,
+			"RX Error: Descriptor Error.\n");
+	}
+	if (status & ETH_RDES0_SAF) {
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev,
+			"RX Error: Source Address Filter Fail.\n");
+	}
+	if (status & ETH_RDES0_LE) {
+		lp->stats.rx_length_errors++;
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev, "RX Error: Length Error.\n");
+	}
+	if (status & ETH_RDES0_OE) {
+		lp->stats.rx_over_errors++;
+		if (netif_msg_rx_err(lp))
+			dev_err(&lp->ndev->dev, "RX Error: Overflow Error.\n");
+	}
+	if (status & ETH_RDES0_VLAN) {
+		if (netif_msg_drv(lp))
+			dev_info(&lp->ndev->dev, "RX Info: VLAN.\n");
+	}
+	if (status & ETH_RDES0_IPC) {
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev,
+			"RX Error: IPC Checksum/Giant Frame.\n");
+	}
+	if (status & ETH_RDES0_LC) {
+		lp->stats.collisions++;
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev, "RX Error: Late Collision.\n");
+	}
+	if (status & ETH_RDES0_FT) {
+		if (netif_msg_rx_err(lp))
+			dev_info(&lp->ndev->dev,
+			"RX Info: Ethernet-type frame.\n");
+	}
+	if (status & ETH_RDES0_RWT) {
+		if (netif_msg_drv(lp))
+			dev_err(&lp->ndev->dev,
+			"RX Error: Watchdog Timeout.\n");
+	}
+	if (status & ETH_RDES0_RE) {
+		lp->stats.rx_errors++;
+		if (netif_msg_rx_err(lp))
+			dev_err(&lp->ndev->dev, "RX Error: Receive.\n");
+	}
+	if (status & ETH_RDES0_DBE) {
+		if (amba_tstbitsl(lp->regbase + ETH_MAC_CFG_OFFSET,
+			ETH_MAC_CFG_PS)) {
+			lp->stats.rx_length_errors++;
+			if (netif_msg_drv(lp))
+				dev_err(&lp->ndev->dev,
+				"RX Error: Dribble Bit.\n");
+		}
+	}
+	if (status & ETH_RDES0_CE) {
+		lp->stats.rx_crc_errors++;
+		if (netif_msg_rx_err(lp)) {
+			dev_err(&lp->ndev->dev, "RX Error: CRC.\n");
+		}
+	}
+	if (status & ETH_RDES0_RX) {
+		if (netif_msg_drv(lp)) {
+			dev_err(&lp->ndev->dev,
+			"RX Error: Rx MAC Address/Payload Checksum.\n");
+			if (lp->dump_rx)
+				ambhw_dump_rx(lp, status, entry);
+		}
+	}
+}
+
+static inline void ambeth_napi_rx(struct ambeth_info *lp, u32 status, u32 entry)
+{
+	short pkt_len;
+	struct sk_buff *skb;
+	dma_addr_t mapping;
+
+	pkt_len = ETH_RDES0_FL(status) - 4;
+	skb = lp->rx.rng_rx[entry].skb;
+	mapping = lp->rx.rng_rx[entry].mapping;
+	if (likely(skb && mapping)) {
+		dma_unmap_single(&lp->ndev->dev, mapping,
+			AMBETH_PACKET_MAXFRAME, DMA_FROM_DEVICE);
+		skb_put(skb, pkt_len);
+		skb->protocol = eth_type_trans(skb, lp->ndev);
+		if(ETH_ENHANCED == 0) {
+			if (lp->ipc_rx) {
+				if ((status & ETH_RDES0_COE_MASK) ==
+					ETH_RDES0_COE_NOCHKERROR) {
+					skb->ip_summed = CHECKSUM_UNNECESSARY;
+				} else {
+					skb->ip_summed = CHECKSUM_NONE;
+					if (netif_msg_rx_err(lp)) {
+						dev_err(&lp->ndev->dev,
+						"RX Error: RDES0_COE[0x%x].\n", status);
+					}
+				}
+			}
+
+		}
+
+		if (unlikely(lp->dump_rx)) {
+			ambhw_dump_buffer(__func__, (skb->data - 14),
+				(skb->len + 14));
+		}
+		if (unlikely(lp->dump_rx_free))
+			kfree_skb(skb);
+		else
+			netif_receive_skb(skb);
+
+		lp->rx.rng_rx[entry].skb = NULL;
+		lp->rx.rng_rx[entry].mapping = 0;
+		lp->ndev->last_rx = jiffies;
+		lp->stats.rx_packets++;
+		lp->stats.rx_bytes += pkt_len;
+		lp->rx.cur_rx++;
+	} else {
+		if (netif_msg_drv(lp)) {
+			dev_err(&lp->ndev->dev,
+			"RX Error: %u skb[%p], map[0x%08X].\n",
+			entry, skb, mapping);
+		}
+	}
+}
+
+int ambeth_napi(struct napi_struct *napi, int budget)
+{
+	int rx_budget = budget;
+	struct ambeth_info *lp;
+	u32 entry;
+	u32 status;
+	unsigned long flags;
+	unsigned int dirty_diff;
+	short pkt_len;
+
+	lp = container_of(napi, struct ambeth_info, napi);
+	dev_vdbg(&lp->ndev->dev, "cur_rx[%u], dirty_rx[%u]\n",
+		lp->rx.cur_rx, lp->rx.dirty_rx);
+
+	if (unlikely(!netif_carrier_ok(lp->ndev)))
+		goto ambeth_poll_complete;
+
+	while (rx_budget > 0) {
+		entry = lp->rx.cur_rx % lp->rx_count;
+		status = lp->rx.desc_rx[entry].status;
+		if (status & ETH_RDES0_OWN)
+			break;
+
+		pkt_len = ETH_RDES0_FL(status) - 4;
+		if (unlikely(pkt_len > AMBETH_RX_COPYBREAK)) {
+			dev_err(&lp->ndev->dev, "ambarella eth: jumbo frame[size:%d] received drop\n",
+				pkt_len);
+			ambhw_dma_rx_stop(lp);
+			ambeth_check_rdes0_status(lp, status, entry);
+			lp->rx.cur_rx++;
+			break;
+		}
+
+		if (unlikely((status & (ETH_RDES0_FS | ETH_RDES0_LS)) !=
+			(ETH_RDES0_FS | ETH_RDES0_LS))) {
+			break;
+		}
+		if (likely((status & ETH_RDES0_ES) != ETH_RDES0_ES)) {
+			ambeth_napi_rx(lp, status, entry);
+		} else {
+			ambhw_dma_rx_stop(lp);
+			ambeth_check_rdes0_status(lp, status, entry);
+			rx_budget += lp->rx_count;
+			lp->rx.cur_rx++;
+		}
+		rx_budget--;
+
+		dirty_diff = (lp->rx.cur_rx - lp->rx.dirty_rx);
+		if (dirty_diff > (lp->rx_count / 4)) {
+			ambeth_rx_rngmng_refill(lp);
+		}
+	}
+
+ambeth_poll_complete:
+	if (rx_budget > 0) {
+		ambeth_rx_rngmng_refill(lp);
+		spin_lock_irqsave(&lp->lock, flags);
+		napi_complete(&lp->napi);
+		amba_setbitsl(lp->regbase + ETH_DMA_INTEN_OFFSET,
+			AMBETH_RXDMA_INTEN);
+		ambhw_dma_rx_start(lp);
+		spin_unlock_irqrestore(&lp->lock, flags);
+	}
+
+	dev_vdbg(&lp->ndev->dev, "cur_rx[%u], dirty_rx[%u], rx_budget[%u]\n",
+		lp->rx.cur_rx, lp->rx.dirty_rx, rx_budget);
+	return (budget - rx_budget);
+}
+
+static inline u32 ambhw_hashtable_crc(unsigned char *mac)
+{
+	unsigned char tmpbuf[ETH_ALEN];
+	int i;
+	u32 crc;
+
+	for (i = 0; i < ETH_ALEN; i++)
+		tmpbuf[i] = bitrev8(mac[i]);
+	crc = crc32_be(~0, tmpbuf, ETH_ALEN);
+
+	return (crc ^ ~0);
+}
+
+static inline void ambhw_hashtable_get(struct net_device *ndev, u32 *hat)
+{
+	struct netdev_hw_addr *ha;
+	unsigned int bitnr;
+#if 0
+	unsigned char test1[] = {0x1F,0x52,0x41,0x9C,0xB6,0xAF};
+	unsigned char test2[] = {0xA0,0x0A,0x98,0x00,0x00,0x45};
+	dev_info(&ndev->dev,
+		"Test1: 0x%08X.\n", ambhw_hashtable_crc(test1));
+	dev_info(&ndev->dev,
+		"Test2: 0x%08X.\n", ambhw_hashtable_crc(test2));
+#endif
+
+	hat[0] = hat[1] = 0;
+	netdev_for_each_mc_addr(ha, ndev) {
+		if (!(ha->addr[0] & 1))
+			continue;
+		bitnr = ambhw_hashtable_crc(ha->addr);
+		bitnr >>= 26;
+		bitnr &= 0x3F;
+		hat[bitnr >> 5] |= 1 << (bitnr & 31);
+	}
+}
+
+static void ambeth_set_multicast_list(struct net_device *ndev)
+{
+	struct ambeth_info *lp;
+	unsigned int mac_filter;
+	u32 hat[2];
+	unsigned long flags;
+
+	lp = (struct ambeth_info *)netdev_priv(ndev);
+	spin_lock_irqsave(&lp->lock, flags);
+
+	mac_filter = amba_readl(lp->regbase + ETH_MAC_FRAME_FILTER_OFFSET);
+	hat[0] = 0;
+	hat[1] = 0;
+
+	if (ndev->flags & IFF_PROMISC) {
+		mac_filter |= ETH_MAC_FRAME_FILTER_PR;
+	} else if (ndev->flags & (~IFF_PROMISC)) {
+		mac_filter &= ~ETH_MAC_FRAME_FILTER_PR;
+	}
+
+	if (ndev->flags & IFF_ALLMULTI) {
+		hat[0] = 0xFFFFFFFF;
+		hat[1] = 0xFFFFFFFF;
+		mac_filter |= ETH_MAC_FRAME_FILTER_PM;
+	} else if (!netdev_mc_empty(ndev)) {
+		ambhw_hashtable_get(ndev, hat);
+		mac_filter &= ~ETH_MAC_FRAME_FILTER_PM;
+		mac_filter |= ETH_MAC_FRAME_FILTER_HMC;
+	} else if (ndev->flags & (~IFF_ALLMULTI)) {
+		mac_filter &= ~ETH_MAC_FRAME_FILTER_PM;
+		mac_filter |= ETH_MAC_FRAME_FILTER_HMC;
+	}
+
+	if (netif_msg_hw(lp)) {
+		dev_info(&lp->ndev->dev, "MC Info: flags 0x%x.\n", ndev->flags);
+		dev_info(&lp->ndev->dev, "MC Info: mc_count 0x%x.\n",
+			netdev_mc_count(ndev));
+		dev_info(&lp->ndev->dev, "MC Info: mac_filter 0x%x.\n",
+			mac_filter);
+		dev_info(&lp->ndev->dev, "MC Info: hat[0x%x:0x%x].\n",
+			hat[1], hat[0]);
+	}
+
+	amba_writel(lp->regbase + ETH_MAC_HASH_HI_OFFSET, hat[1]);
+	amba_writel(lp->regbase + ETH_MAC_HASH_LO_OFFSET, hat[0]);
+	amba_writel(lp->regbase + ETH_MAC_FRAME_FILTER_OFFSET, mac_filter);
+
+	spin_unlock_irqrestore(&lp->lock, flags);
+}
+
+static int ambeth_set_mac_address(struct net_device *ndev, void *addr)
+{
+	struct ambeth_info *lp = (struct ambeth_info *)netdev_priv(ndev);
+	struct sockaddr *saddr = addr;
+	unsigned long flags;
+
+	if (!is_valid_ether_addr(saddr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	spin_lock_irqsave(&lp->lock, flags);
+
+	if (netif_running(ndev)) {
+		spin_unlock_irqrestore(&lp->lock, flags);
+		return -EBUSY;
+	}
+
+	dev_dbg(&lp->ndev->dev, "MAC address[%pM].\n", saddr->sa_data);
+
+	memcpy(ndev->dev_addr, saddr->sa_data, ndev->addr_len);
+	ambhw_set_hwaddr(lp, ndev->dev_addr);
+	ambhw_get_hwaddr(lp, ndev->dev_addr);
+
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	return 0;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void ambeth_poll_controller(struct net_device *ndev)
+{
+	ambeth_interrupt(ndev->irq, ndev);
+}
+#endif
+
+static int ambeth_ioctl(struct net_device *ndev, struct ifreq *ifr, int ecmd)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+
+	if (!netif_running(ndev))
+		return -EINVAL;
+
+	if (!lp->phydev)
+		return -ENODEV;
+
+	return phy_mii_ioctl(lp->phydev, ifr, ecmd);
+}
+
+static const struct net_device_ops ambeth_netdev_ops = {
+	.ndo_open		= ambeth_open,
+	.ndo_stop		= ambeth_stop,
+	.ndo_start_xmit		= ambeth_hard_start_xmit,
+	.ndo_set_rx_mode	= ambeth_set_multicast_list,
+	.ndo_set_mac_address 	= ambeth_set_mac_address,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_do_ioctl		= ambeth_ioctl,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_tx_timeout		= ambeth_timeout,
+	.ndo_get_stats		= ambeth_get_stats,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= ambeth_poll_controller,
+#endif
+};
+
+/* ==========================================================================*/
+static int ambeth_get_settings(struct net_device *ndev,
+	struct ethtool_cmd *ecmd)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+	int ret_val = 0;
+
+	if (!netif_running(ndev))
+		return -EINVAL;
+
+	if (lp->phy_enabled) {
+		ret_val = phy_ethtool_gset(lp->phydev, ecmd);
+	} else {
+		ret_val = -EINVAL;
+		if (lp->oldlink == PHY_RUNNING) {
+			ethtool_cmd_speed_set(ecmd, lp->oldspeed);
+			ecmd->duplex = lp->oldduplex;
+			ecmd->port = PORT_MII;
+			ecmd->phy_address = 0xFF;
+			ecmd->transceiver = XCVR_EXTERNAL;
+			ecmd->autoneg = AUTONEG_DISABLE;
+			ecmd->supported = SUPPORTED_MII;
+			switch (lp->oldspeed) {
+			case SPEED_1000:
+				if (lp->oldduplex == DUPLEX_FULL) {
+					ecmd->supported |=
+						SUPPORTED_1000baseT_Full;
+				} else {
+					ecmd->supported |=
+						SUPPORTED_1000baseT_Half;
+				}
+				ret_val = 0;
+				break;
+			case SPEED_100:
+				if (lp->oldduplex == DUPLEX_FULL) {
+					ecmd->supported |=
+						SUPPORTED_100baseT_Full;
+				} else {
+					ecmd->supported |=
+						SUPPORTED_100baseT_Half;
+				}
+				ret_val = 0;
+				break;
+			case SPEED_10:
+				if (lp->oldduplex == DUPLEX_FULL) {
+					ecmd->supported |=
+						SUPPORTED_10baseT_Full;
+				} else {
+					ecmd->supported |=
+						SUPPORTED_10baseT_Half;
+				}
+				ret_val = 0;
+				break;
+			default:
+				break;
+			}
+			ecmd->advertising = ecmd->supported;
+		}
+	}
+
+	return ret_val;
+}
+
+static int ambeth_set_settings(struct net_device *ndev,
+	struct ethtool_cmd *ecmd)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+
+	if (!netif_running(ndev) || !lp->phy_enabled)
+		return -EINVAL;
+
+	return phy_ethtool_sset(lp->phydev, ecmd);
+}
+
+static int ambeth_get_dump_flag(struct net_device *ndev,
+	struct ethtool_dump *ed)
+{
+	ed->len = (AMBETH_PHY_REG_SIZE * sizeof(u16));
+	ed->flag = 0;
+	pr_debug("%s: cmd[0x%08X], version[0x%08X], "
+		"flag[0x%08X], len[0x%08X]\n",
+		__func__, ed->cmd, ed->version,
+		ed->flag, ed->len);
+
+	return 0;
+}
+
+static int ambeth_get_dump_data(struct net_device *ndev,
+	struct ethtool_dump *ed, void *pdata)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+	int i;
+	u16 *regbuf;
+
+	pr_debug("%s: cmd[0x%08X], version[0x%08X], "
+		"flag[0x%08X], len[0x%08X]\n",
+		__func__, ed->cmd, ed->version,
+		ed->flag, ed->len);
+
+	if (!lp->phy_enabled) {
+		return -EINVAL;
+	}
+	regbuf = (u16 *)pdata;
+	for (i = 0; i < (ed->len / 2); i++) {
+		regbuf[i] = mdiobus_read(lp->phydev->bus,
+			lp->phydev->addr, i);
+	}
+
+	return 0;
+}
+
+static int ambeth_set_dump(struct net_device *ndev, struct ethtool_dump *ed)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+	u16 dbg_address;
+	u16 dbg_value;
+
+	pr_debug("%s: cmd[0x%08X], version[0x%08X], "
+		"flag[0x%08X], len[0x%08X]\n",
+		__func__, ed->cmd, ed->version,
+		ed->flag, ed->len);
+
+	if (!lp->phy_enabled) {
+		return -EINVAL;
+	}
+	dbg_address = ((ed->flag & 0xFFFF0000) >> 16);
+	dbg_value = (ed->flag & 0x0000FFFF);
+	mdiobus_write(lp->phydev->bus, lp->phydev->addr,
+		dbg_address, dbg_value);
+
+	return 0;
+}
+
+static u32 ambeth_get_msglevel(struct net_device *ndev)
+{
+	struct ambeth_info *lp;
+
+	lp = (struct ambeth_info *)netdev_priv(ndev);
+
+	return lp->msg_enable;
+}
+
+static void ambeth_set_msglevel(struct net_device *ndev, u32 value)
+{
+	struct ambeth_info *lp;
+
+	lp = (struct ambeth_info *)netdev_priv(ndev);
+
+	lp->msg_enable = value;
+}
+
+static void ambeth_get_pauseparam(struct net_device *ndev,
+				  struct ethtool_pauseparam *pause)
+{
+	struct ambeth_info *lp;
+	u32 flow_ctr;
+
+	lp = (struct ambeth_info *)netdev_priv(ndev);
+	flow_ctr = lp->flow_ctr;
+
+	pause->autoneg = (flow_ctr & AMBARELLA_ETH_FC_AUTONEG) ?
+				AUTONEG_ENABLE : AUTONEG_DISABLE;
+
+	pause->rx_pause = (flow_ctr & AMBARELLA_ETH_FC_RX) ? 1 : 0;
+	pause->tx_pause = (flow_ctr & AMBARELLA_ETH_FC_TX) ? 1 : 0;
+}
+
+static int ambeth_set_pauseparam(struct net_device *ndev,
+				 struct ethtool_pauseparam *pause)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+	u32 flow_ctr;
+	int ret_val = 0;
+
+	/*
+	 * Symmeteric pause can respond to recieved pause frames, and
+	 * send pause frames to the link partner.
+	 *
+	 * Asymmetric pause can send pause frames, but can't respond to
+	 * pause frames from the link partner.
+	 *
+	 * Autoneg only advertises and reports the 'cap (or will)' of
+	 * the link partner. The final resolution still has to be done in
+	 * MAC / Driver.
+	 *
+	 * Since our MAC can support both directions independently, we
+	 * advertise our 'cap' to the link partner based on the
+	 * pauseparam specified by the user (ethtool). And take the
+	 * 'cap' of the link partner reported into consideration for
+	 * makeing the final resolution.
+	 */
+
+	flow_ctr = lp->flow_ctr;
+
+	if (pause->autoneg)
+		flow_ctr |= AMBARELLA_ETH_FC_AUTONEG;
+	else
+		flow_ctr &= ~AMBARELLA_ETH_FC_AUTONEG;
+
+	if (pause->rx_pause)
+		flow_ctr |= AMBARELLA_ETH_FC_RX;
+	else
+		flow_ctr &= ~AMBARELLA_ETH_FC_RX;
+
+	if (pause->tx_pause)
+		flow_ctr |= AMBARELLA_ETH_FC_TX;
+	else
+		flow_ctr &= ~AMBARELLA_ETH_FC_TX;
+
+	lp->flow_ctr = flow_ctr;
+	if(lp->flow_ctr & (AMBARELLA_ETH_FC_TX | AMBARELLA_ETH_FC_RX))
+		lp->phy_supported |= SUPPORTED_Pause;
+	else
+		lp->phy_supported &= ~SUPPORTED_Pause;
+
+
+	ambeth_fc_config(lp);
+
+	if (pause->autoneg && lp->phydev->autoneg) {
+
+		ret_val = phy_start_aneg(lp->phydev);
+		if (ret_val)
+			goto done;
+	}
+	else {
+		ambeth_fc_resolve(lp);
+	}
+done:
+	return ret_val;
+}
+
+static int ambeth_get_eee(struct net_device *ndev, struct ethtool_eee *e)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+
+	/*now our chip don't support EEE*/
+	e->eee_enabled = false;
+	e->eee_active = false;
+	e->tx_lpi_enabled = false;
+	e->tx_lpi_timer = 0;
+
+	return phy_ethtool_get_eee(lp->phydev, e);
+}
+
+static int ambeth_set_eee(struct net_device *ndev, struct ethtool_eee *e)
+{
+	struct ambeth_info *lp = netdev_priv(ndev);
+	int ret = 0;
+
+	if(e->eee_enabled || e->tx_lpi_enabled) {
+		dev_err(&lp->ndev->dev, "eth don't support EEE.\n");
+		return -EOPNOTSUPP;
+	}
+
+	ret = phy_init_eee(lp->phydev, 0);
+	if (ret) {
+		dev_err(&lp->ndev->dev, "phy don't support EEE.\n");
+		return ret;
+	}
+
+	return phy_ethtool_set_eee(lp->phydev, e);
+}
+
+static const struct ethtool_ops ambeth_ethtool_ops = {
+	.get_settings		= ambeth_get_settings,
+	.set_settings		= ambeth_set_settings,
+	.get_link		= ethtool_op_get_link,
+	.get_dump_flag		= ambeth_get_dump_flag,
+	.get_dump_data		= ambeth_get_dump_data,
+	.set_dump		= ambeth_set_dump,
+	.get_msglevel		= ambeth_get_msglevel,
+	.set_msglevel		= ambeth_set_msglevel,
+	.get_pauseparam		= ambeth_get_pauseparam,
+	.set_pauseparam		= ambeth_set_pauseparam,
+	.get_eee		= ambeth_get_eee,
+	.set_eee		= ambeth_set_eee,
+};
+
+/* ==========================================================================*/
+static int ambeth_of_parse(struct device_node *np, struct ambeth_info *lp)
+{
+	struct device_node *phy_np;
+	enum of_gpio_flags flags;
+	int gmii, ret_val, clk_src, clk_direction, clk_pl;
+
+	ret_val = of_property_read_u32(np, "amb,fixed-speed", &lp->fixed_speed);
+	if (ret_val < 0)
+		lp->fixed_speed = SPEED_UNKNOWN;
+
+	gmii = !!of_find_property(np, "amb,support-gmii", NULL);
+	if (gmii) {
+		lp->phy_supported = (	SUPPORTED_10baseT_Half | \
+					SUPPORTED_10baseT_Full | \
+					SUPPORTED_100baseT_Half | \
+					SUPPORTED_100baseT_Full | \
+					SUPPORTED_1000baseT_Half | \
+					SUPPORTED_1000baseT_Full | \
+					SUPPORTED_Autoneg | \
+					SUPPORTED_MII);
+	} else {
+		lp->phy_supported = (	SUPPORTED_10baseT_Half | \
+					SUPPORTED_10baseT_Full | \
+					SUPPORTED_100baseT_Half | \
+					SUPPORTED_100baseT_Full | \
+					SUPPORTED_Autoneg | \
+					SUPPORTED_MII);
+	}
+
+	/*enable flow control*/
+	lp->phy_supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+
+	ret_val = of_property_read_u32(np, "amb,tx-ring-size", &lp->tx_count);
+	if (ret_val < 0 || lp->tx_count < AMBETH_TX_RNG_MIN)
+		lp->tx_count = AMBETH_TX_RNG_MIN;
+
+	ret_val = of_property_read_u32(np, "amb,rx-ring-size", &lp->rx_count);
+	if (ret_val < 0 || lp->rx_count < AMBETH_RX_RNG_MIN)
+		lp->rx_count = AMBETH_RX_RNG_MIN;
+
+	lp->tx_irq_low = ((lp->tx_count * 1) / 4);
+	lp->tx_irq_high = ((lp->tx_count * 3) / 4);
+
+	lp->ipc_tx = !!of_find_property(np, "amb,ipc-tx", NULL);
+	lp->ipc_rx = !!of_find_property(np, "amb,ipc-rx", NULL);
+	lp->dump_tx = !!of_find_property(np, "amb,dump-tx", NULL);
+	lp->dump_rx = !!of_find_property(np, "amb,dump-rx", NULL);
+	lp->dump_rx_free = !!of_find_property(np, "amb,dump-rx-free", NULL);
+	lp->dump_rx_all = !!of_find_property(np, "amb,dump-rx-all", NULL);
+	lp->mdio_gpio = !!of_find_property(np, "amb,mdio-gpio", NULL);
+
+	for_each_child_of_node(np, phy_np) {
+		if (!phy_np->name || of_node_cmp(phy_np->name, "phy"))
+			continue;
+
+		lp->pwr_gpio = of_get_named_gpio_flags(phy_np, "pwr-gpios", 0, &flags);
+		lp->pwr_gpio_active = !!(flags & OF_GPIO_ACTIVE_LOW);
+
+		lp->rst_gpio = of_get_named_gpio_flags(phy_np, "rst-gpios", 0, &flags);
+		lp->rst_gpio_active = !!(flags & OF_GPIO_ACTIVE_LOW);
+
+		ret_val = of_property_read_u32(phy_np, "amb,clk-src", &clk_src);
+		if (ret_val == 0 && clk_src == 0) {
+			/*clk_src == 0 represent the clk is external*/
+			amba_writel(ENET_CLK_SRC_SEL_REG, 0x00);
+		} else if(ret_val == 0 && clk_src == 1) {
+			/*clk_src == 1 and default represent the clk is internal*/
+			amba_writel(ENET_CLK_SRC_SEL_REG, 0x01);
+		} else {
+			/*default value for clk source*/
+		}
+
+		ret_val = of_property_read_u32(phy_np, "amb,clk-invert", &clk_pl);
+		if(ret_val == 0 && clk_pl == 1) {
+			amba_setbitsl(AHB_SCRATCHPAD_REG(0xc), 0x80000000);
+		} else if(ret_val == 0 && clk_pl == 0) {
+			amba_clrbitsl(AHB_SCRATCHPAD_REG(0xc), 0x80000000);
+		}
+
+		ret_val = of_property_read_u32(phy_np, "amb,clk-dir", &clk_direction);
+		if(ret_val == 0 && clk_direction == 1) {
+			/*set direction of xx_enet_clk_rx as output from ambarella chip*/
+			lp->clk_direction = 1;
+			ret_val = amba_readl(AHB_MISC_EN_REG);
+			ret_val |= (1 << 5);
+			amba_writel(AHB_MISC_EN_REG, ret_val);
+		} else if(ret_val == 0 && clk_direction == 0) {
+			/*set direction of xx_enet_clk_rx as output from external phy*/
+			lp->clk_direction = 0;
+			ret_val = amba_readl(AHB_MISC_EN_REG);
+			ret_val &= ~(1 << 5);
+			amba_writel(AHB_MISC_EN_REG, ret_val);
+		} else
+			lp->clk_direction = -1;
+	}
+
+	return 0;
+}
+
+static int ambeth_drv_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node, *mdio_np = NULL;
+	struct net_device *ndev;
+	struct ambeth_info *lp;
+	struct resource *res;
+	const char *macaddr;
+	int ret_val = 0;
+
+	if (!(ambarella_get_poc() & SYS_CONFIG_ETH_ENABLE)) {
+		dev_err(&pdev->dev, "Not enabled, check HW config!\n");
+		return -EPERM;
+	}
+
+	ndev = alloc_etherdev(sizeof(struct ambeth_info));
+	if (ndev == NULL) {
+		dev_err(&pdev->dev, "alloc_etherdev fail.\n");
+		return -ENOMEM;
+	}
+	lp = netdev_priv(ndev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "No mem resource for fio_reg!\n");
+		ret_val = -ENXIO;
+		goto ambeth_drv_probe_free_netdev;
+	}
+
+	lp->regbase = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+	if (!lp->regbase) {
+		dev_err(&pdev->dev, "devm_ioremap() failed\n");
+		ret_val = -ENOMEM;
+		goto ambeth_drv_probe_free_netdev;
+	}
+
+	ndev->irq = platform_get_irq(pdev, 0);
+	if (ndev->irq < 0) {
+		dev_err(&pdev->dev, "no irq for ethernet!\n");
+		ret_val = -ENODEV;
+		goto ambeth_drv_probe_free_netdev;
+	}
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+	ndev->dev.dma_mask = pdev->dev.dma_mask;
+	ndev->dev.coherent_dma_mask = pdev->dev.coherent_dma_mask;
+
+	spin_lock_init(&lp->lock);
+	lp->ndev = ndev;
+	lp->msg_enable = netif_msg_init(msg_level, NETIF_MSG_DRV);
+
+	ambeth_of_parse(np, lp);
+
+	if (lp->ipc_tx)
+		ndev->features |= NETIF_F_HW_CSUM;
+
+	/* request gpio for PHY power control */
+	if (gpio_is_valid(lp->pwr_gpio)) {
+		ret_val = devm_gpio_request(&pdev->dev,
+			lp->pwr_gpio, "phy power");
+		if (ret_val < 0) {
+			dev_err(&pdev->dev, "Failed to request pwr-gpios!\n");
+			goto ambeth_drv_probe_free_netdev;
+		}
+		gpio_direction_output(lp->pwr_gpio, lp->pwr_gpio_active);
+	}
+
+	/* request gpio for PHY reset control */
+	if (gpio_is_valid(lp->rst_gpio)) {
+		ret_val = devm_gpio_request(&pdev->dev,
+			lp->rst_gpio, "phy reset");
+		if (ret_val < 0) {
+			dev_err(&pdev->dev, "Failed to request rst-gpios!\n");
+			goto ambeth_drv_probe_free_netdev;
+		}
+		gpio_direction_output(lp->rst_gpio, !lp->rst_gpio_active);
+	}
+
+	if(lp->mdio_gpio) {
+		mdio_np = of_find_compatible_node(NULL, NULL, "virtual,mdio-gpio");
+
+		if(mdio_np == NULL) {
+			dev_err(&pdev->dev, "Failed to get mdio_gpio device node\n");
+			goto ambeth_drv_probe_free_netdev;
+		}
+
+		lp->phydev = of_phy_find_device(mdio_np->child);
+
+		if(!lp->phydev) {
+			dev_err(&pdev->dev, "Failed to get phydev from mdio_gpio device node\n");
+			goto ambeth_drv_probe_free_netdev;
+		}
+
+		lp->new_bus = *lp->phydev->bus;
+	} else {
+		lp->new_bus.name = "Ambarella MII Bus",
+		lp->new_bus.read = &ambhw_mdio_read,
+		lp->new_bus.write = &ambhw_mdio_write,
+		lp->new_bus.reset = &ambhw_mdio_reset,
+		snprintf(lp->new_bus.id, MII_BUS_ID_SIZE, "%s", pdev->name);
+		lp->new_bus.priv = lp;
+		lp->new_bus.irq = kmalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);
+		if (lp->new_bus.irq == NULL) {
+			dev_err(&pdev->dev, "alloc new_bus.irq fail.\n");
+			ret_val = -ENOMEM;
+			goto ambeth_drv_probe_free_netdev;
+		}
+
+		lp->new_bus.parent = &pdev->dev;
+		lp->new_bus.state = MDIOBUS_ALLOCATED;
+
+		ret_val = of_mdiobus_register(&lp->new_bus, pdev->dev.of_node);
+		if (ret_val < 0) {
+			dev_err(&pdev->dev, "mdiobus_register fail%d.\n", ret_val);
+			goto ambeth_drv_probe_kfree_mdiobus;
+		}
+
+		lp->phydev = phy_find_first(&lp->new_bus);
+		if (lp->phydev == NULL) {
+			dev_err(&pdev->dev, "No PHY device.\n");
+			ret_val = -ENODEV;
+			goto ambeth_drv_probe_kfree_mdiobus;
+		}
+	}
+
+	if (netif_msg_drv(lp)) {
+		dev_info(&pdev->dev, "Ethernet PHY[%d]: 0x%08x!\n",
+				lp->phydev->addr, lp->phydev->phy_id);
+	}
+
+	ether_setup(ndev);
+	ndev->netdev_ops = &ambeth_netdev_ops;
+	ndev->watchdog_timeo = AMBETH_TX_WATCHDOG;
+	netif_napi_add(ndev, &lp->napi, ambeth_napi, AMBETH_NAPI_WEIGHT);
+
+	macaddr = of_get_mac_address(pdev->dev.of_node);
+	if (macaddr)
+		memcpy(ndev->dev_addr, macaddr, ETH_ALEN);
+
+	if (!is_valid_ether_addr(ndev->dev_addr))
+		eth_hw_addr_random(ndev);
+
+	ambhw_disable(lp);
+
+	if (gpio_is_valid(lp->pwr_gpio))
+		gpio_set_value_cansleep(lp->pwr_gpio, !lp->pwr_gpio_active);
+	if (gpio_is_valid(lp->rst_gpio))
+		gpio_set_value_cansleep(lp->rst_gpio, lp->rst_gpio_active);
+
+	SET_ETHTOOL_OPS(ndev, &ambeth_ethtool_ops);
+	ret_val = register_netdev(ndev);
+	if (ret_val) {
+		dev_err(&pdev->dev, " register_netdev fail%d.\n", ret_val);
+		goto ambeth_drv_probe_netif_napi_del;
+	}
+
+	platform_set_drvdata(pdev, ndev);
+	dev_notice(&pdev->dev, "MAC Address[%pM].\n", ndev->dev_addr);
+
+	return 0;
+
+ambeth_drv_probe_netif_napi_del:
+	netif_napi_del(&lp->napi);
+	mdiobus_unregister(&lp->new_bus);
+
+ambeth_drv_probe_kfree_mdiobus:
+	kfree(lp->new_bus.irq);
+
+ambeth_drv_probe_free_netdev:
+	free_netdev(ndev);
+	return ret_val;
+}
+
+static int ambeth_drv_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct ambeth_info *lp = netdev_priv(ndev);
+
+	unregister_netdev(ndev);
+	netif_napi_del(&lp->napi);
+	mdiobus_unregister(&lp->new_bus);
+	kfree(lp->new_bus.irq);
+	platform_set_drvdata(pdev, NULL);
+	free_netdev(ndev);
+	dev_notice(&pdev->dev, "Removed.\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ambeth_drv_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct ambeth_info *lp = netdev_priv(ndev);
+	int ret_val = 0;
+	unsigned long flags;
+
+	if (!netif_running(ndev))
+		goto ambeth_drv_suspend_exit;
+
+	napi_disable(&lp->napi);
+	netif_device_detach(ndev);
+	disable_irq(ndev->irq);
+
+	ambeth_phy_stop(lp);
+
+	spin_lock_irqsave(&lp->lock, flags);
+	ambhw_disable(lp);
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	if (gpio_is_valid(lp->pwr_gpio))
+		gpio_set_value_cansleep(lp->pwr_gpio, !lp->pwr_gpio_active);
+	if (gpio_is_valid(lp->rst_gpio))
+		gpio_set_value_cansleep(lp->rst_gpio, lp->rst_gpio_active);
+
+ambeth_drv_suspend_exit:
+	dev_dbg(&pdev->dev, "%s exit with %d @ %d\n",
+		__func__, ret_val, state.event);
+
+	return ret_val;
+}
+
+static int ambeth_drv_resume(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct ambeth_info *lp = netdev_priv(ndev);
+	int ret_val = 0;
+	unsigned long flags;
+
+	if (!netif_running(ndev))
+		goto ambeth_drv_resume_exit;
+
+	if(lp->clk_direction == 1) {
+		ret_val = amba_readl(AHB_MISC_EN_REG);
+		ret_val |= (1 << 5);
+		amba_writel(AHB_MISC_EN_REG, ret_val);
+	} else if(lp->clk_direction == 0) {
+		ret_val = amba_readl(AHB_MISC_EN_REG);
+		ret_val &= ~(1 << 5);
+		amba_writel(AHB_MISC_EN_REG, ret_val);
+	}
+
+	if (gpio_is_valid(lp->pwr_gpio))
+		gpio_set_value_cansleep(lp->pwr_gpio, lp->pwr_gpio_active);
+	if (gpio_is_valid(lp->rst_gpio)) {
+		gpio_set_value_cansleep(lp->rst_gpio, lp->rst_gpio_active);
+		msleep(10);
+		gpio_set_value_cansleep(lp->rst_gpio, !lp->rst_gpio_active);
+	}
+
+	spin_lock_irqsave(&lp->lock, flags);
+	ret_val = ambhw_enable(lp);
+	ambhw_set_link_mode_speed(lp);
+	ambeth_rx_rngmng_init(lp);
+	ambeth_tx_rngmng_init(lp);
+	ambhw_set_dma_desc(lp);
+	ambhw_dma_rx_start(lp);
+	ambhw_dma_tx_start(lp);
+	ambhw_dma_int_enable(lp);
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	if (ret_val) {
+		dev_err(&pdev->dev, "ambhw_enable.\n");
+	} else {
+		ambeth_set_multicast_list(ndev);
+		netif_carrier_off(ndev);
+		ret_val = ambeth_phy_start(lp);
+		enable_irq(ndev->irq);
+		netif_device_attach(ndev);
+		napi_enable(&lp->napi);
+	}
+ambeth_drv_resume_exit:
+	dev_dbg(&pdev->dev, "%s exit with %d\n", __func__, ret_val);
+	return ret_val;
+}
+#endif
+
+static const struct of_device_id ambarella_eth_dt_ids[] = {
+	{ .compatible = "ambarella,eth" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ambarella_eth_dt_ids);
+
+static struct platform_driver ambeth_driver = {
+	.probe		= ambeth_drv_probe,
+	.remove		= ambeth_drv_remove,
+#ifdef CONFIG_PM
+	.suspend        = ambeth_drv_suspend,
+	.resume		= ambeth_drv_resume,
+#endif
+	.driver = {
+		.name	= "ambarella-eth",
+		.owner	= THIS_MODULE,
+		.of_match_table	= ambarella_eth_dt_ids,
+	},
+};
+
+module_platform_driver(ambeth_driver);
+
+MODULE_DESCRIPTION("Ambarella Media Processor Ethernet Driver");
+MODULE_AUTHOR("Anthony Ginger, <hfjiang@ambarella.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/net/ethernet/amd/pcnet32.c b/drivers/net/ethernet/amd/pcnet32.c
index ed21307..f6415fd 100644
--- a/drivers/net/ethernet/amd/pcnet32.c
+++ b/drivers/net/ethernet/amd/pcnet32.c
@@ -1516,7 +1516,7 @@ pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)
 {
 	struct pcnet32_private *lp;
 	int i, media;
-	int fdx, mii, fset, dxsuflo;
+	int fdx, mii, fset, dxsuflo, sram;
 	int chip_version;
 	char *chipname;
 	struct net_device *dev;
@@ -1553,7 +1553,7 @@ pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)
 	}
 
 	/* initialize variables */
-	fdx = mii = fset = dxsuflo = 0;
+	fdx = mii = fset = dxsuflo = sram = 0;
 	chip_version = (chip_version >> 12) & 0xffff;
 
 	switch (chip_version) {
@@ -1586,6 +1586,7 @@ pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)
 		chipname = "PCnet/FAST III 79C973";	/* PCI */
 		fdx = 1;
 		mii = 1;
+		sram = 1;
 		break;
 	case 0x2626:
 		chipname = "PCnet/Home 79C978";	/* PCI */
@@ -1609,6 +1610,7 @@ pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)
 		chipname = "PCnet/FAST III 79C975";	/* PCI */
 		fdx = 1;
 		mii = 1;
+		sram = 1;
 		break;
 	case 0x2628:
 		chipname = "PCnet/PRO 79C976";
@@ -1637,6 +1639,31 @@ pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)
 		dxsuflo = 1;
 	}
 
+	/*
+	 * The Am79C973/Am79C975 controllers come with 12K of SRAM
+	 * which we can use for the Tx/Rx buffers but most importantly,
+	 * the use of SRAM allow us to use the BCR18:NOUFLO bit to avoid
+	 * Tx fifo underflows.
+	 */
+	if (sram) {
+		/*
+		 * The SRAM is being configured in two steps. First we
+		 * set the SRAM size in the BCR25:SRAM_SIZE bits. According
+		 * to the datasheet, each bit corresponds to a 512-byte
+		 * page so we can have at most 24 pages. The SRAM_SIZE
+		 * holds the value of the upper 8 bits of the 16-bit SRAM size.
+		 * The low 8-bits start at 0x00 and end at 0xff. So the
+		 * address range is from 0x0000 up to 0x17ff. Therefore,
+		 * the SRAM_SIZE is set to 0x17. The next step is to set
+		 * the BCR26:SRAM_BND midway through so the Tx and Rx
+		 * buffers can share the SRAM equally.
+		 */
+		a->write_bcr(ioaddr, 25, 0x17);
+		a->write_bcr(ioaddr, 26, 0xc);
+		/* And finally enable the NOUFLO bit */
+		a->write_bcr(ioaddr, 18, a->read_bcr(ioaddr, 18) | (1 << 11));
+	}
+
 	dev = alloc_etherdev(sizeof(*lp));
 	if (!dev) {
 		ret = -ENOMEM;
diff --git a/drivers/net/ethernet/atheros/alx/main.c b/drivers/net/ethernet/atheros/alx/main.c
index a85a9c2..7357e54 100644
--- a/drivers/net/ethernet/atheros/alx/main.c
+++ b/drivers/net/ethernet/atheros/alx/main.c
@@ -86,9 +86,14 @@ static int alx_refill_rx_ring(struct alx_priv *alx, gfp_t gfp)
 	while (!cur_buf->skb && next != rxq->read_idx) {
 		struct alx_rfd *rfd = &rxq->rfd[cur];
 
-		skb = __netdev_alloc_skb(alx->dev, alx->rxbuf_size, gfp);
+		skb = __netdev_alloc_skb(alx->dev, alx->rxbuf_size + 64, gfp);
 		if (!skb)
 			break;
+
+		/* Workround for the HW RX DMA overflow issue */
+		if (((unsigned long)skb->data & 0xfff) == 0xfc0)
+			skb_reserve(skb, 64);
+
 		dma = dma_map_single(&alx->hw.pdev->dev,
 				     skb->data, alx->rxbuf_size,
 				     DMA_FROM_DEVICE);
diff --git a/drivers/net/ethernet/atheros/atl1c/atl1c_main.c b/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
index 11cdf1d..297c3e5 100644
--- a/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
+++ b/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
@@ -1016,13 +1016,12 @@ static int atl1c_setup_ring_resources(struct atl1c_adapter *adapter)
 		sizeof(struct atl1c_recv_ret_status) * rx_desc_count +
 		8 * 4;
 
-	ring_header->desc = pci_alloc_consistent(pdev, ring_header->size,
-				&ring_header->dma);
+	ring_header->desc = dma_zalloc_coherent(&pdev->dev, ring_header->size,
+						&ring_header->dma, GFP_KERNEL);
 	if (unlikely(!ring_header->desc)) {
-		dev_err(&pdev->dev, "pci_alloc_consistend failed\n");
+		dev_err(&pdev->dev, "could not get memory for DMA buffer\n");
 		goto err_nomem;
 	}
-	memset(ring_header->desc, 0, ring_header->size);
 	/* init TPD ring */
 
 	tpd_ring[0].dma = roundup(ring_header->dma, 8);
diff --git a/drivers/net/ethernet/atheros/atlx/atl2.c b/drivers/net/ethernet/atheros/atlx/atl2.c
index 265ce1b..96fe542 100644
--- a/drivers/net/ethernet/atheros/atlx/atl2.c
+++ b/drivers/net/ethernet/atheros/atlx/atl2.c
@@ -1413,7 +1413,7 @@ static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	err = -EIO;
 
-	netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;
+	netdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;
 	netdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
 
 	/* Init PHY as early as possible due to power saving issue  */
diff --git a/drivers/net/ethernet/broadcom/bnx2.c b/drivers/net/ethernet/broadcom/bnx2.c
index 5d20449..161dcba 100644
--- a/drivers/net/ethernet/broadcom/bnx2.c
+++ b/drivers/net/ethernet/broadcom/bnx2.c
@@ -2869,7 +2869,7 @@ bnx2_tx_int(struct bnx2 *bp, struct bnx2_napi *bnapi, int budget)
 		sw_cons = BNX2_NEXT_TX_BD(sw_cons);
 
 		tx_bytes += skb->len;
-		dev_kfree_skb(skb);
+		dev_kfree_skb_any(skb);
 		tx_pkt++;
 		if (tx_pkt == budget)
 			break;
@@ -6610,7 +6610,7 @@ bnx2_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	mapping = dma_map_single(&bp->pdev->dev, skb->data, len, PCI_DMA_TODEVICE);
 	if (dma_mapping_error(&bp->pdev->dev, mapping)) {
-		dev_kfree_skb(skb);
+		dev_kfree_skb_any(skb);
 		return NETDEV_TX_OK;
 	}
 
@@ -6703,7 +6703,7 @@ dma_error:
 			       PCI_DMA_TODEVICE);
 	}
 
-	dev_kfree_skb(skb);
+	dev_kfree_skb_any(skb);
 	return NETDEV_TX_OK;
 }
 
diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c
index 8c1eab1..518cc4b 100644
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -6437,7 +6437,7 @@ static void tg3_tx(struct tg3_napi *tnapi)
 		pkts_compl++;
 		bytes_compl += skb->len;
 
-		dev_kfree_skb(skb);
+		dev_kfree_skb_any(skb);
 
 		if (unlikely(tx_bug)) {
 			tg3_tx_recover(tp);
@@ -6769,7 +6769,7 @@ static int tg3_rx(struct tg3_napi *tnapi, int budget)
 		if (len > (tp->dev->mtu + ETH_HLEN) &&
 		    skb->protocol != htons(ETH_P_8021Q) &&
 		    skb->protocol != htons(ETH_P_8021AD)) {
-			dev_kfree_skb(skb);
+			dev_kfree_skb_any(skb);
 			goto drop_it_no_recycle;
 		}
 
@@ -7652,7 +7652,7 @@ static int tigon3_dma_hwbug_workaround(struct tg3_napi *tnapi,
 					  PCI_DMA_TODEVICE);
 		/* Make sure the mapping succeeded */
 		if (pci_dma_mapping_error(tp->pdev, new_addr)) {
-			dev_kfree_skb(new_skb);
+			dev_kfree_skb_any(new_skb);
 			ret = -1;
 		} else {
 			u32 save_entry = *entry;
@@ -7667,13 +7667,13 @@ static int tigon3_dma_hwbug_workaround(struct tg3_napi *tnapi,
 					    new_skb->len, base_flags,
 					    mss, vlan)) {
 				tg3_tx_skb_unmap(tnapi, save_entry, -1);
-				dev_kfree_skb(new_skb);
+				dev_kfree_skb_any(new_skb);
 				ret = -1;
 			}
 		}
 	}
 
-	dev_kfree_skb(skb);
+	dev_kfree_skb_any(skb);
 	*pskb = new_skb;
 	return ret;
 }
@@ -7716,7 +7716,7 @@ static int tg3_tso_bug(struct tg3 *tp, struct sk_buff *skb)
 	} while (segs);
 
 tg3_tso_bug_end:
-	dev_kfree_skb(skb);
+	dev_kfree_skb_any(skb);
 
 	return NETDEV_TX_OK;
 }
@@ -7954,7 +7954,7 @@ dma_error:
 	tg3_tx_skb_unmap(tnapi, tnapi->tx_prod, --i);
 	tnapi->tx_buffers[tnapi->tx_prod].skb = NULL;
 drop:
-	dev_kfree_skb(skb);
+	dev_kfree_skb_any(skb);
 drop_nofree:
 	tp->tx_dropped++;
 	return NETDEV_TX_OK;
@@ -10518,7 +10518,7 @@ static ssize_t tg3_show_temp(struct device *dev,
 	tg3_ape_scratchpad_read(tp, &temperature, attr->index,
 				sizeof(temperature));
 	spin_unlock_bh(&tp->lock);
-	return sprintf(buf, "%u\n", temperature);
+	return sprintf(buf, "%u\n", temperature * 1000);
 }
 
 
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index d81a7db..88e85cb 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -1767,7 +1767,7 @@ static u16 be_tx_compl_process(struct be_adapter *adapter,
 		queue_tail_inc(txq);
 	} while (cur_index != last_index);
 
-	kfree_skb(sent_skb);
+	dev_kfree_skb_any(sent_skb);
 	return num_wrbs;
 }
 
diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c
index 59ad007..a978fc8 100644
--- a/drivers/net/ethernet/intel/e1000/e1000_main.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c
@@ -144,6 +144,11 @@ static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,
 static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
 				     struct e1000_rx_ring *rx_ring,
 				     int *work_done, int work_to_do);
+static void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter,
+					 struct e1000_rx_ring *rx_ring,
+					 int cleaned_count)
+{
+}
 static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
 				   struct e1000_rx_ring *rx_ring,
 				   int cleaned_count);
@@ -3555,8 +3560,11 @@ static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
 		msleep(1);
 	/* e1000_down has a dependency on max_frame_size */
 	hw->max_frame_size = max_frame;
-	if (netif_running(netdev))
+	if (netif_running(netdev)) {
+		/* prevent buffers from being reallocated */
+		adapter->alloc_rx_buf = e1000_alloc_dummy_rx_buffers;
 		e1000_down(adapter);
+	}
 
 	/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN
 	 * means we reserve 2 more, this pushes us to allocate from the next
diff --git a/drivers/net/ethernet/intel/ixgb/ixgb_main.c b/drivers/net/ethernet/intel/ixgb/ixgb_main.c
index fce3e92..c5a9dcc 100644
--- a/drivers/net/ethernet/intel/ixgb/ixgb_main.c
+++ b/drivers/net/ethernet/intel/ixgb/ixgb_main.c
@@ -1527,12 +1527,12 @@ ixgb_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
 	int tso;
 
 	if (test_bit(__IXGB_DOWN, &adapter->flags)) {
-		dev_kfree_skb(skb);
+		dev_kfree_skb_any(skb);
 		return NETDEV_TX_OK;
 	}
 
 	if (skb->len <= 0) {
-		dev_kfree_skb(skb);
+		dev_kfree_skb_any(skb);
 		return NETDEV_TX_OK;
 	}
 
@@ -1549,7 +1549,7 @@ ixgb_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
 
 	tso = ixgb_tso(adapter, skb);
 	if (tso < 0) {
-		dev_kfree_skb(skb);
+		dev_kfree_skb_any(skb);
 		return NETDEV_TX_OK;
 	}
 
diff --git a/drivers/net/ethernet/jme.c b/drivers/net/ethernet/jme.c
index 070a6f1..2f4cbca 100644
--- a/drivers/net/ethernet/jme.c
+++ b/drivers/net/ethernet/jme.c
@@ -3290,13 +3290,14 @@ jme_resume(struct device *dev)
 		jme_reset_phy_processor(jme);
 	jme_phy_calibration(jme);
 	jme_phy_setEA(jme);
-	jme_start_irq(jme);
 	netif_device_attach(netdev);
 
 	atomic_inc(&jme->link_changing);
 
 	jme_reset_link(jme);
 
+	jme_start_irq(jme);
+
 	return 0;
 }
 
diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index 8b6c923..df3af29 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -210,7 +210,7 @@
 /* Various constants */
 
 /* Coalescing */
-#define MVNETA_TXDONE_COAL_PKTS		1
+#define MVNETA_TXDONE_COAL_PKTS		0	/* interrupt per packet */
 #define MVNETA_RX_COAL_PKTS		32
 #define MVNETA_RX_COAL_USEC		100
 
@@ -910,7 +910,7 @@ static void mvneta_defaults_set(struct mvneta_port *pp)
 	/* Set CPU queue access map - all CPUs have access to all RX
 	 * queues and to all TX queues
 	 */
-	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++)
+	for_each_present_cpu(cpu)
 		mvreg_write(pp, MVNETA_CPU_MAP(cpu),
 			    (MVNETA_CPU_RXQ_ACCESS_ALL_MASK |
 			     MVNETA_CPU_TXQ_ACCESS_ALL_MASK));
diff --git a/drivers/net/ethernet/mellanox/mlx4/cmd.c b/drivers/net/ethernet/mellanox/mlx4/cmd.c
index 28d706b..d64050f 100644
--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c
@@ -1836,7 +1836,7 @@ int mlx4_multi_func_init(struct mlx4_dev *dev)
 			spin_lock_init(&s_state->lock);
 		}
 
-		memset(&priv->mfunc.master.cmd_eqe, 0, dev->caps.eqe_size);
+		memset(&priv->mfunc.master.cmd_eqe, 0, sizeof(struct mlx4_eqe));
 		priv->mfunc.master.cmd_eqe.type = MLX4_EVENT_TYPE_CMD;
 		INIT_WORK(&priv->mfunc.master.comm_work,
 			  mlx4_master_comm_channel);
diff --git a/drivers/net/ethernet/mellanox/mlx4/eq.c b/drivers/net/ethernet/mellanox/mlx4/eq.c
index 6000342..16a1ccc 100644
--- a/drivers/net/ethernet/mellanox/mlx4/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c
@@ -183,7 +183,7 @@ static void slave_event(struct mlx4_dev *dev, u8 slave, struct mlx4_eqe *eqe)
 		return;
 	}
 
-	memcpy(s_eqe, eqe, dev->caps.eqe_size - 1);
+	memcpy(s_eqe, eqe, sizeof(struct mlx4_eqe) - 1);
 	s_eqe->slave_id = slave;
 	/* ensure all information is written before setting the ownersip bit */
 	wmb();
diff --git a/drivers/net/ethernet/qlogic/qlge/qlge_main.c b/drivers/net/ethernet/qlogic/qlge/qlge_main.c
index f87cc21..a978cc2 100644
--- a/drivers/net/ethernet/qlogic/qlge/qlge_main.c
+++ b/drivers/net/ethernet/qlogic/qlge/qlge_main.c
@@ -1620,7 +1620,18 @@ static void ql_process_mac_rx_skb(struct ql_adapter *qdev,
 		return;
 	}
 	skb_reserve(new_skb, NET_IP_ALIGN);
+
+	pci_dma_sync_single_for_cpu(qdev->pdev,
+				    dma_unmap_addr(sbq_desc, mapaddr),
+				    dma_unmap_len(sbq_desc, maplen),
+				    PCI_DMA_FROMDEVICE);
+
 	memcpy(skb_put(new_skb, length), skb->data, length);
+
+	pci_dma_sync_single_for_device(qdev->pdev,
+				       dma_unmap_addr(sbq_desc, mapaddr),
+				       dma_unmap_len(sbq_desc, maplen),
+				       PCI_DMA_FROMDEVICE);
 	skb = new_skb;
 
 	/* Frame error, so drop the packet. */
diff --git a/drivers/net/ethernet/realtek/8139cp.c b/drivers/net/ethernet/realtek/8139cp.c
index 064425d..437d4cf 100644
--- a/drivers/net/ethernet/realtek/8139cp.c
+++ b/drivers/net/ethernet/realtek/8139cp.c
@@ -899,7 +899,7 @@ out_unlock:
 
 	return NETDEV_TX_OK;
 out_dma_error:
-	kfree_skb(skb);
+	dev_kfree_skb_any(skb);
 	cp->dev->stats.tx_dropped++;
 	goto out_unlock;
 }
diff --git a/drivers/net/ethernet/realtek/8139too.c b/drivers/net/ethernet/realtek/8139too.c
index 3ccedeb..942673f 100644
--- a/drivers/net/ethernet/realtek/8139too.c
+++ b/drivers/net/ethernet/realtek/8139too.c
@@ -1715,9 +1715,9 @@ static netdev_tx_t rtl8139_start_xmit (struct sk_buff *skb,
 		if (len < ETH_ZLEN)
 			memset(tp->tx_buf[entry], 0, ETH_ZLEN);
 		skb_copy_and_csum_dev(skb, tp->tx_buf[entry]);
-		dev_kfree_skb(skb);
+		dev_kfree_skb_any(skb);
 	} else {
-		dev_kfree_skb(skb);
+		dev_kfree_skb_any(skb);
 		dev->stats.tx_dropped++;
 		return NETDEV_TX_OK;
 	}
diff --git a/drivers/net/ethernet/realtek/r8169.c b/drivers/net/ethernet/realtek/r8169.c
index e9b5d77a..2183c61 100644
--- a/drivers/net/ethernet/realtek/r8169.c
+++ b/drivers/net/ethernet/realtek/r8169.c
@@ -5768,7 +5768,7 @@ static void rtl8169_tx_clear_range(struct rtl8169_private *tp, u32 start,
 					     tp->TxDescArray + entry);
 			if (skb) {
 				tp->dev->stats.tx_dropped++;
-				dev_kfree_skb(skb);
+				dev_kfree_skb_any(skb);
 				tx_skb->skb = NULL;
 			}
 		}
@@ -5993,7 +5993,7 @@ static netdev_tx_t rtl8169_start_xmit(struct sk_buff *skb,
 err_dma_1:
 	rtl8169_unmap_tx_skb(d, tp->tx_skb + entry, txd);
 err_dma_0:
-	dev_kfree_skb(skb);
+	dev_kfree_skb_any(skb);
 err_update_stats:
 	dev->stats.tx_dropped++;
 	return NETDEV_TX_OK;
@@ -6076,7 +6076,7 @@ static void rtl_tx(struct net_device *dev, struct rtl8169_private *tp)
 			tp->tx_stats.packets++;
 			tp->tx_stats.bytes += tx_skb->skb->len;
 			u64_stats_update_end(&tp->tx_stats.syncp);
-			dev_kfree_skb(tx_skb->skb);
+			dev_kfree_skb_any(tx_skb->skb);
 			tx_skb->skb = NULL;
 		}
 		dirty_tx++;
diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c
index e29fe8d..93b6525 100644
--- a/drivers/net/ethernet/renesas/sh_eth.c
+++ b/drivers/net/ethernet/renesas/sh_eth.c
@@ -1161,7 +1161,8 @@ static void sh_eth_ring_format(struct net_device *ndev)
 	mdp->dirty_rx = (u32) (i - mdp->num_rx_ring);
 
 	/* Mark the last entry as wrapping the ring. */
-	rxdesc->status |= cpu_to_edmac(mdp, RD_RDEL);
+	if (rxdesc)
+		rxdesc->status |= cpu_to_edmac(mdp, RD_RDEL);
 
 	memset(mdp->tx_ring, 0, tx_ringsize);
 
@@ -1421,6 +1422,7 @@ static int sh_eth_rx(struct net_device *ndev, u32 intr_status)
 		desc_status >>= 16;
 #endif
 
+		skb = mdp->rx_skbuff[entry];
 		if (desc_status & (RD_RFS1 | RD_RFS2 | RD_RFS3 | RD_RFS4 |
 				   RD_RFS5 | RD_RFS6 | RD_RFS10)) {
 			ndev->stats.rx_errors++;
@@ -1436,12 +1438,11 @@ static int sh_eth_rx(struct net_device *ndev, u32 intr_status)
 				ndev->stats.rx_missed_errors++;
 			if (desc_status & RD_RFS10)
 				ndev->stats.rx_over_errors++;
-		} else {
+		} else	if (skb) {
 			if (!mdp->cd->hw_swap)
 				sh_eth_soft_swap(
 					phys_to_virt(ALIGN(rxdesc->addr, 4)),
 					pkt_len + 2);
-			skb = mdp->rx_skbuff[entry];
 			mdp->rx_skbuff[entry] = NULL;
 			if (mdp->cd->rpadir)
 				skb_reserve(skb, NET_IP_ALIGN);
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index c5f9cb8..ff08be5 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -731,10 +731,13 @@ static int stmmac_get_ts_info(struct net_device *dev,
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
 
-	if ((priv->hwts_tx_en) && (priv->hwts_rx_en)) {
+	if ((priv->dma_cap.time_stamp || priv->dma_cap.atime_stamp)) {
 
-		info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
+		info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |
+					SOF_TIMESTAMPING_TX_HARDWARE |
+					SOF_TIMESTAMPING_RX_SOFTWARE |
 					SOF_TIMESTAMPING_RX_HARDWARE |
+					SOF_TIMESTAMPING_SOFTWARE |
 					SOF_TIMESTAMPING_RAW_HARDWARE;
 
 		if (priv->ptp_clock)
diff --git a/drivers/net/irda/irtty-sir.c b/drivers/net/irda/irtty-sir.c
index a412671..0d71fa9f 100644
--- a/drivers/net/irda/irtty-sir.c
+++ b/drivers/net/irda/irtty-sir.c
@@ -430,16 +430,6 @@ static int irtty_open(struct tty_struct *tty)
 
 	/* Module stuff handled via irda_ldisc.owner - Jean II */
 
-	/* First make sure we're not already connected. */
-	if (tty->disc_data != NULL) {
-		priv = tty->disc_data;
-		if (priv && priv->magic == IRTTY_MAGIC) {
-			ret = -EEXIST;
-			goto out;
-		}
-		tty->disc_data = NULL;		/* ### */
-	}
-
 	/* stop the underlying  driver */
 	irtty_stop_receiver(tty, TRUE);
 	if (tty->ops->stop)
diff --git a/drivers/net/phy/broadcom.c b/drivers/net/phy/broadcom.c
index f8c90ea..7a1ff57 100644
--- a/drivers/net/phy/broadcom.c
+++ b/drivers/net/phy/broadcom.c
@@ -848,7 +848,7 @@ static struct mdio_device_id __maybe_unused broadcom_tbl[] = {
 	{ PHY_ID_BCM5421, 0xfffffff0 },
 	{ PHY_ID_BCM5461, 0xfffffff0 },
 	{ PHY_ID_BCM5464, 0xfffffff0 },
-	{ PHY_ID_BCM5482, 0xfffffff0 },
+	{ PHY_ID_BCM5481, 0xfffffff0 },
 	{ PHY_ID_BCM5482, 0xfffffff0 },
 	{ PHY_ID_BCM50610, 0xfffffff0 },
 	{ PHY_ID_BCM50610M, 0xfffffff0 },
diff --git a/drivers/net/phy/dp83640.c b/drivers/net/phy/dp83640.c
index 7490b6c..d2907a6 100644
--- a/drivers/net/phy/dp83640.c
+++ b/drivers/net/phy/dp83640.c
@@ -45,7 +45,7 @@
 #define PSF_TX		0x1000
 #define EXT_EVENT	1
 #define CAL_EVENT	7
-#define CAL_TRIGGER	7
+#define CAL_TRIGGER	1
 #define PER_TRIGGER	6
 
 #define MII_DP83640_MICR 0x11
diff --git a/drivers/net/phy/ksz80x1r.c b/drivers/net/phy/ksz80x1r.c
index d5af558..64372e8 100644
--- a/drivers/net/phy/ksz80x1r.c
+++ b/drivers/net/phy/ksz80x1r.c
@@ -73,6 +73,7 @@ void ksz80x1r_prevent_loss(struct phy_device *phydev) {
 	phy_write(phydev, 0x0d, 0x401c);
 	phy_write(phydev, 0x0e, 0xffff);
 }
+
 int ksz80x1r_config_aneg(struct phy_device *phydev)
 {
 	int result;
@@ -80,10 +81,10 @@ int ksz80x1r_config_aneg(struct phy_device *phydev)
 	result = genphy_config_aneg(phydev);
 	if(result > 0)
 		ksz80x1r_prevent_loss(phydev);
+
 	return result;
 }
 
-
 static int ksz80x1r_ack_interrupt(struct phy_device *phydev)
 {
 	int rc;
diff --git a/drivers/net/phy/mdio-gpio.c b/drivers/net/phy/mdio-gpio.c
index a47f923..a64ad54 100644
--- a/drivers/net/phy/mdio-gpio.c
+++ b/drivers/net/phy/mdio-gpio.c
@@ -30,16 +30,32 @@
 
 #include <linux/of_gpio.h>
 #include <linux/of_mdio.h>
+#include <linux/delay.h>
 
 struct mdio_gpio_info {
 	struct mdiobb_ctrl ctrl;
-	int mdc, mdio;
+	int mdc, mdio, rst;
+	int rst_active_low;
 };
 
+static int mdio_gpio_reset(struct mii_bus *bus)
+{
+	struct mdiobb_ctrl *bb_ctrl = bus->priv;
+	struct mdio_gpio_info *mdio_info = container_of(bb_ctrl, struct mdio_gpio_info, ctrl);
+
+	gpio_direction_output(mdio_info->rst, mdio_info->rst_active_low);
+	msleep(50);
+	gpio_direction_output(mdio_info->rst, !mdio_info->rst_active_low);
+	msleep(50);
+
+	return 0;
+}
+
 static void *mdio_gpio_of_get_data(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct mdio_gpio_platform_data *pdata;
+	enum of_gpio_flags flags;
 	int ret;
 
 	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
@@ -57,6 +73,18 @@ static void *mdio_gpio_of_get_data(struct platform_device *pdev)
 		return NULL;
 	pdata->mdio = ret;
 
+	pdata->rst = of_get_named_gpio_flags(np->child, "rst-gpios", 0, &flags);
+	if (gpio_is_valid(pdata->rst)) {
+		ret = devm_gpio_request(&pdev->dev,
+				pdata->rst, "phy reset");
+		if(ret < 0)
+			dev_err(&pdev->dev, "Failed to request rst-gpios!\n");
+		else {
+			pdata->rst_active_low = flags & OF_GPIO_ACTIVE_LOW;
+			pdata->reset = mdio_gpio_reset;
+		}
+	}
+
 	return pdata;
 }
 
@@ -119,6 +147,8 @@ static struct mii_bus *mdio_gpio_bus_init(struct device *dev,
 	bitbang->ctrl.reset = pdata->reset;
 	bitbang->mdc = pdata->mdc;
 	bitbang->mdio = pdata->mdio;
+	bitbang->rst = pdata->rst;
+	bitbang->rst_active_low = pdata->rst_active_low;
 
 	new_bus = alloc_mdio_bitbang(&bitbang->ctrl);
 	if (!new_bus)
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index f625016..48f8d58 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -1022,12 +1022,14 @@ int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable)
 
 	/* According to 802.3az,the EEE is supported only in full duplex-mode.
 	 * Also EEE feature is active when core is operating with MII, GMII
-	 * or RGMII.
+	 * or RGMII (all kinds). Internal PHYs are also allowed to proceed and
+	 * should return an error if they do not support EEE.
 	 */
 	if ((phydev->duplex == DUPLEX_FULL) &&
 	    ((phydev->interface == PHY_INTERFACE_MODE_MII) ||
 	    (phydev->interface == PHY_INTERFACE_MODE_GMII) ||
-	    (phydev->interface == PHY_INTERFACE_MODE_RGMII))) {
+	     (phydev->interface >= PHY_INTERFACE_MODE_RGMII &&
+	      phydev->interface <= PHY_INTERFACE_MODE_RGMII_TXID))) {
 		int eee_lp, eee_cap, eee_adv;
 		u32 lp, cap, adv;
 		int status;
diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c
index 5a1897d..14a8d29 100644
--- a/drivers/net/ppp/ppp_generic.c
+++ b/drivers/net/ppp/ppp_generic.c
@@ -716,10 +716,8 @@ static long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 			val &= 0xffff;
 		}
 		vj = slhc_init(val2+1, val+1);
-		if (!vj) {
-			netdev_err(ppp->dev,
-				   "PPP: no memory (VJ compressor)\n");
-			err = -ENOMEM;
+		if (IS_ERR(vj)) {
+			err = PTR_ERR(vj);
 			break;
 		}
 		ppp_lock(ppp);
@@ -2222,7 +2220,7 @@ int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)
 
 	pch->ppp = NULL;
 	pch->chan = chan;
-	pch->chan_net = net;
+	pch->chan_net = get_net(net);
 	chan->ppp = pch;
 	init_ppp_file(&pch->file, CHANNEL);
 	pch->file.hdrlen = chan->hdrlen;
@@ -2319,6 +2317,8 @@ ppp_unregister_channel(struct ppp_channel *chan)
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
+	put_net(pch->chan_net);
+	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
diff --git a/drivers/net/ppp/pppoe.c b/drivers/net/ppp/pppoe.c
index becfa3e..2840cf6 100644
--- a/drivers/net/ppp/pppoe.c
+++ b/drivers/net/ppp/pppoe.c
@@ -313,7 +313,6 @@ static void pppoe_flush_dev(struct net_device *dev)
 			if (po->pppoe_dev == dev &&
 			    sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND | PPPOX_ZOMBIE)) {
 				pppox_unbind_sock(sk);
-				sk->sk_state = PPPOX_ZOMBIE;
 				sk->sk_state_change(sk);
 				po->pppoe_dev = NULL;
 				dev_put(dev);
@@ -570,7 +569,7 @@ static int pppoe_release(struct socket *sock)
 
 	po = pppox_sk(sk);
 
-	if (sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND | PPPOX_ZOMBIE)) {
+	if (po->pppoe_dev) {
 		dev_put(po->pppoe_dev);
 		po->pppoe_dev = NULL;
 	}
diff --git a/drivers/net/ppp/pptp.c b/drivers/net/ppp/pptp.c
index 0d5a5fa..9a42343 100644
--- a/drivers/net/ppp/pptp.c
+++ b/drivers/net/ppp/pptp.c
@@ -420,6 +420,9 @@ static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,
 	struct pptp_opt *opt = &po->proto.pptp;
 	int error = 0;
 
+	if (sockaddr_len < sizeof(struct sockaddr_pppox))
+		return -EINVAL;
+
 	lock_sock(sk);
 
 	opt->src_addr = sp->sa_addr.pptp;
@@ -441,6 +444,9 @@ static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,
 	struct flowi4 fl4;
 	int error = 0;
 
+	if (sockaddr_len < sizeof(struct sockaddr_pppox))
+		return -EINVAL;
+
 	if (sp->sa_protocol != PX_PROTO_PPTP)
 		return -EINVAL;
 
diff --git a/drivers/net/rionet.c b/drivers/net/rionet.c
index f433b59..00a8128 100644
--- a/drivers/net/rionet.c
+++ b/drivers/net/rionet.c
@@ -269,7 +269,7 @@ static void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbo
 	struct net_device *ndev = dev_id;
 	struct rionet_private *rnet = netdev_priv(ndev);
 
-	spin_lock(&rnet->lock);
+	spin_lock(&rnet->tx_lock);
 
 	if (netif_msg_intr(rnet))
 		printk(KERN_INFO
@@ -288,7 +288,7 @@ static void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbo
 	if (rnet->tx_cnt < RIONET_TX_RING_SIZE)
 		netif_wake_queue(ndev);
 
-	spin_unlock(&rnet->lock);
+	spin_unlock(&rnet->tx_lock);
 }
 
 static int rionet_open(struct net_device *ndev)
diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c
index 1252d9c..b52eabc 100644
--- a/drivers/net/slip/slhc.c
+++ b/drivers/net/slip/slhc.c
@@ -84,8 +84,9 @@ static long decode(unsigned char **cpp);
 static unsigned char * put16(unsigned char *cp, unsigned short x);
 static unsigned short pull16(unsigned char **cpp);
 
-/* Initialize compression data structure
+/* Allocate compression data structure
  *	slots must be in range 0 to 255 (zero meaning no compression)
+ * Returns pointer to structure or ERR_PTR() on error.
  */
 struct slcompress *
 slhc_init(int rslots, int tslots)
@@ -94,11 +95,14 @@ slhc_init(int rslots, int tslots)
 	register struct cstate *ts;
 	struct slcompress *comp;
 
+	if (rslots < 0 || rslots > 255 || tslots < 0 || tslots > 255)
+		return ERR_PTR(-EINVAL);
+
 	comp = kzalloc(sizeof(struct slcompress), GFP_KERNEL);
 	if (! comp)
 		goto out_fail;
 
-	if ( rslots > 0  &&  rslots < 256 ) {
+	if (rslots > 0) {
 		size_t rsize = rslots * sizeof(struct cstate);
 		comp->rstate = kzalloc(rsize, GFP_KERNEL);
 		if (! comp->rstate)
@@ -106,7 +110,7 @@ slhc_init(int rslots, int tslots)
 		comp->rslot_limit = rslots - 1;
 	}
 
-	if ( tslots > 0  &&  tslots < 256 ) {
+	if (tslots > 0) {
 		size_t tsize = tslots * sizeof(struct cstate);
 		comp->tstate = kzalloc(tsize, GFP_KERNEL);
 		if (! comp->tstate)
@@ -141,7 +145,7 @@ out_free2:
 out_free:
 	kfree(comp);
 out_fail:
-	return NULL;
+	return ERR_PTR(-ENOMEM);
 }
 
 
diff --git a/drivers/net/slip/slip.c b/drivers/net/slip/slip.c
index a34d6bf..ca3e737 100644
--- a/drivers/net/slip/slip.c
+++ b/drivers/net/slip/slip.c
@@ -163,7 +163,7 @@ static int sl_alloc_bufs(struct slip *sl, int mtu)
 	if (cbuff == NULL)
 		goto err_exit;
 	slcomp = slhc_init(16, 16);
-	if (slcomp == NULL)
+	if (IS_ERR(slcomp))
 		goto err_exit;
 #endif
 	spin_lock_bh(&sl->lock);
diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c
index 14179a6..5225d43 100644
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@ -1636,10 +1636,10 @@ static int team_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)
 	struct team *team = netdev_priv(dev);
 	struct team_port *port;
 
-	rcu_read_lock();
-	list_for_each_entry_rcu(port, &team->port_list, list)
+	mutex_lock(&team->lock);
+	list_for_each_entry(port, &team->port_list, list)
 		vlan_vid_del(port->dev, proto, vid);
-	rcu_read_unlock();
+	mutex_unlock(&team->lock);
 
 	return 0;
 }
diff --git a/drivers/net/usb/asix_devices.c b/drivers/net/usb/asix_devices.c
index 97b5de7..05e8bd7 100644
--- a/drivers/net/usb/asix_devices.c
+++ b/drivers/net/usb/asix_devices.c
@@ -466,19 +466,7 @@ static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)
 		return ret;
 	}
 
-	ret = asix_sw_reset(dev, AX_SWRESET_IPPD | AX_SWRESET_PRL);
-	if (ret < 0)
-		return ret;
-
-	msleep(150);
-
-	ret = asix_sw_reset(dev, AX_SWRESET_CLEAR);
-	if (ret < 0)
-		return ret;
-
-	msleep(150);
-
-	ret = asix_sw_reset(dev, embd_phy ? AX_SWRESET_IPRL : AX_SWRESET_PRTE);
+	ax88772_reset(dev);
 
 	/* Read PHYID register *AFTER* the PHY was reset properly */
 	phyid = asix_get_phyid(dev);
@@ -888,7 +876,7 @@ static const struct driver_info ax88772_info = {
 	.unbind = ax88772_unbind,
 	.status = asix_status,
 	.link_reset = ax88772_link_reset,
-	.reset = ax88772_reset,
+	.reset = ax88772_link_reset,
 	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR | FLAG_MULTI_PACKET,
 	.rx_fixup = asix_rx_fixup_common,
 	.tx_fixup = asix_tx_fixup,
diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c
index 43afde8..a580241 100644
--- a/drivers/net/usb/cdc_ncm.c
+++ b/drivers/net/usb/cdc_ncm.c
@@ -464,7 +464,11 @@ advance:
 
 	iface_no = ctx->data->cur_altsetting->desc.bInterfaceNumber;
 
-	/* reset data interface */
+	/* Reset data interface. Some devices will not reset properly
+	 * unless they are configured first.  Toggle the altsetting to
+	 * force a reset
+	 */
+	usb_set_interface(dev->udev, iface_no, data_altsetting);
 	temp = usb_set_interface(dev->udev, iface_no, 0);
 	if (temp)
 		goto error2;
@@ -473,6 +477,13 @@ advance:
 	if (cdc_ncm_setup(ctx))
 		goto error2;
 
+	/* Some firmwares need a pause here or they will silently fail
+	 * to set up the interface properly.  This value was decided
+	 * empirically on a Sierra Wireless MC7455 running 02.08.02.00
+	 * firmware.
+	 */
+	usleep_range(10000, 20000);
+
 	/* configure data interface */
 	temp = usb_set_interface(dev->udev, iface_no, data_altsetting);
 	if (temp)
@@ -594,24 +605,13 @@ EXPORT_SYMBOL_GPL(cdc_ncm_select_altsetting);
 
 static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)
 {
-	int ret;
-
 	/* MBIM backwards compatible function? */
 	cdc_ncm_select_altsetting(dev, intf);
 	if (cdc_ncm_comm_intf_is_mbim(intf->cur_altsetting))
 		return -ENODEV;
 
 	/* NCM data altsetting is always 1 */
-	ret = cdc_ncm_bind_common(dev, intf, 1);
-
-	/*
-	 * We should get an event when network connection is "connected" or
-	 * "disconnected". Set network connection in "disconnected" state
-	 * (carrier is OFF) during attach, so the IP network stack does not
-	 * start IPv6 negotiation and more.
-	 */
-	usbnet_link_change(dev, 0, 0);
-	return ret;
+	return cdc_ncm_bind_common(dev, intf, 1);
 }
 
 static void cdc_ncm_align_tail(struct sk_buff *skb, size_t modulus, size_t remainder, size_t max)
@@ -1157,7 +1157,8 @@ static void cdc_ncm_disconnect(struct usb_interface *intf)
 
 static const struct driver_info cdc_ncm_info = {
 	.description = "CDC NCM",
-	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET,
+	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET
+			| FLAG_LINK_INTR,
 	.bind = cdc_ncm_bind,
 	.unbind = cdc_ncm_unbind,
 	.check_connect = cdc_ncm_check_connect,
@@ -1171,7 +1172,7 @@ static const struct driver_info cdc_ncm_info = {
 static const struct driver_info wwan_info = {
 	.description = "Mobile Broadband Network Device",
 	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET
-			| FLAG_WWAN,
+			| FLAG_LINK_INTR | FLAG_WWAN,
 	.bind = cdc_ncm_bind,
 	.unbind = cdc_ncm_unbind,
 	.check_connect = cdc_ncm_check_connect,
@@ -1185,7 +1186,7 @@ static const struct driver_info wwan_info = {
 static const struct driver_info wwan_noarp_info = {
 	.description = "Mobile Broadband Network Device (NO ARP)",
 	.flags = FLAG_POINTTOPOINT | FLAG_NO_SETINT | FLAG_MULTI_PACKET
-			| FLAG_WWAN | FLAG_NOARP,
+			| FLAG_LINK_INTR | FLAG_WWAN | FLAG_NOARP,
 	.bind = cdc_ncm_bind,
 	.unbind = cdc_ncm_unbind,
 	.check_connect = cdc_ncm_check_connect,
diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
index 43204f4..12aaf1f 100644
--- a/drivers/net/usb/qmi_wwan.c
+++ b/drivers/net/usb/qmi_wwan.c
@@ -724,6 +724,7 @@ static const struct usb_device_id products[] = {
 	{QMI_FIXED_INTF(0x19d2, 0x1426, 2)},	/* ZTE MF91 */
 	{QMI_FIXED_INTF(0x19d2, 0x1428, 2)},	/* Telewell TW-LTE 4G v2 */
 	{QMI_FIXED_INTF(0x19d2, 0x2002, 4)},	/* ZTE (Vodafone) K3765-Z */
+	{QMI_FIXED_INTF(0x2001, 0x7e19, 4)},	/* D-Link DWM-221 B1 */
 	{QMI_FIXED_INTF(0x0f3d, 0x68a2, 8)},    /* Sierra Wireless MC7700 */
 	{QMI_FIXED_INTF(0x114f, 0x68a2, 8)},    /* Sierra Wireless MC7750 */
 	{QMI_FIXED_INTF(0x1199, 0x68a2, 8)},	/* Sierra Wireless MC7710 in QMI mode */
@@ -742,6 +743,7 @@ static const struct usb_device_id products[] = {
 	{QMI_FIXED_INTF(0x2357, 0x9000, 4)},	/* TP-LINK MA260 */
 	{QMI_FIXED_INTF(0x1bc7, 0x1200, 5)},	/* Telit LE920 */
 	{QMI_FIXED_INTF(0x1bc7, 0x1201, 2)},	/* Telit LE920 */
+	{QMI_FIXED_INTF(0x1c9e, 0x9b01, 3)},	/* XS Stick W100-2 from 4G Systems */
 	{QMI_FIXED_INTF(0x0b3c, 0xc000, 4)},	/* Olivetti Olicard 100 */
 	{QMI_FIXED_INTF(0x0b3c, 0xc001, 4)},	/* Olivetti Olicard 120 */
 	{QMI_FIXED_INTF(0x0b3c, 0xc002, 4)},	/* Olivetti Olicard 140 */
diff --git a/drivers/net/usb/usbnet.c b/drivers/net/usb/usbnet.c
index 3d50e7d..2255d89 100644
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@ -753,7 +753,7 @@ int usbnet_stop (struct net_device *net)
 {
 	struct usbnet		*dev = netdev_priv(net);
 	struct driver_info	*info = dev->driver_info;
-	int			retval, pm;
+	int			retval, pm, mpn;
 
 	clear_bit(EVENT_DEV_OPEN, &dev->flags);
 	netif_stop_queue (net);
@@ -784,6 +784,8 @@ int usbnet_stop (struct net_device *net)
 
 	usbnet_purge_paused_rxq(dev);
 
+	mpn = !test_and_clear_bit(EVENT_NO_RUNTIME_PM, &dev->flags);
+
 	/* deferred work (task, timer, softirq) must also stop.
 	 * can't flush_scheduled_work() until we drop rtnl (later),
 	 * else workers could deadlock; so make workers a NOP.
@@ -794,8 +796,7 @@ int usbnet_stop (struct net_device *net)
 	if (!pm)
 		usb_autopm_put_interface(dev->intf);
 
-	if (info->manage_power &&
-	    !test_and_clear_bit(EVENT_NO_RUNTIME_PM, &dev->flags))
+	if (info->manage_power && mpn)
 		info->manage_power(dev, 0);
 	else
 		usb_autopm_put_interface(dev->intf);
@@ -1621,6 +1622,13 @@ out3:
 	if (info->unbind)
 		info->unbind (dev, udev);
 out1:
+	/* subdrivers must undo all they did in bind() if they
+	 * fail it, but we may fail later and a deferred kevent
+	 * may trigger an error resubmitting itself and, worse,
+	 * schedule a timer. So we kill it all just in case.
+	 */
+	cancel_work_sync(&dev->kevent);
+	del_timer_sync(&dev->delay);
 	free_netdev(net);
 out:
 	return status;
diff --git a/drivers/net/veth.c b/drivers/net/veth.c
index 177f911..cc6d3f9 100644
--- a/drivers/net/veth.c
+++ b/drivers/net/veth.c
@@ -116,12 +116,6 @@ static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)
 		kfree_skb(skb);
 		goto drop;
 	}
-	/* don't change ip_summed == CHECKSUM_PARTIAL, as that
-	 * will cause bad checksum on forwarded packets
-	 */
-	if (skb->ip_summed == CHECKSUM_NONE &&
-	    rcv->features & NETIF_F_RXCSUM)
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
 
 	if (likely(dev_forward_skb(rcv, skb) == NET_RX_SUCCESS)) {
 		struct pcpu_vstats *stats = this_cpu_ptr(dev->vstats);
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 2835bfe..b5d1152 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -1545,9 +1545,9 @@ static int virtnet_probe(struct virtio_device *vdev)
 	/* Do we support "hardware" checksums? */
 	if (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {
 		/* This opens up the world of extra features. */
-		dev->hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;
+		dev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;
 		if (csum)
-			dev->features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;
+			dev->features |= NETIF_F_HW_CSUM | NETIF_F_SG;
 
 		if (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {
 			dev->hw_features |= NETIF_F_TSO | NETIF_F_UFO
diff --git a/drivers/net/wan/farsync.c b/drivers/net/wan/farsync.c
index bcfff0d..2dfa147 100644
--- a/drivers/net/wan/farsync.c
+++ b/drivers/net/wan/farsync.c
@@ -2545,7 +2545,7 @@ fst_add_one(struct pci_dev *pdev, const struct pci_device_id *ent)
                 dev->mem_start   = card->phys_mem
                                  + BUF_OFFSET ( txBuffer[i][0][0]);
                 dev->mem_end     = card->phys_mem
-                                 + BUF_OFFSET ( txBuffer[i][NUM_TX_BUFFER][0]);
+                                 + BUF_OFFSET ( txBuffer[i][NUM_TX_BUFFER - 1][LEN_RX_BUFFER - 1]);
                 dev->base_addr   = card->pci_conf;
                 dev->irq         = card->irq;
 
diff --git a/drivers/net/wan/x25_asy.c b/drivers/net/wan/x25_asy.c
index 5895f19..e98de42 100644
--- a/drivers/net/wan/x25_asy.c
+++ b/drivers/net/wan/x25_asy.c
@@ -545,16 +545,12 @@ static void x25_asy_receive_buf(struct tty_struct *tty,
 
 static int x25_asy_open_tty(struct tty_struct *tty)
 {
-	struct x25_asy *sl = tty->disc_data;
+	struct x25_asy *sl;
 	int err;
 
 	if (tty->ops->write == NULL)
 		return -EOPNOTSUPP;
 
-	/* First make sure we're not already connected. */
-	if (sl && sl->magic == X25_ASY_MAGIC)
-		return -EEXIST;
-
 	/* OK.  Find a free X.25 channel to use. */
 	sl = x25_asy_alloc();
 	if (sl == NULL)
diff --git a/drivers/net/wireless/ath/ath5k/led.c b/drivers/net/wireless/ath/ath5k/led.c
index f77ef36..61879b1 100644
--- a/drivers/net/wireless/ath/ath5k/led.c
+++ b/drivers/net/wireless/ath/ath5k/led.c
@@ -77,7 +77,7 @@ static DEFINE_PCI_DEVICE_TABLE(ath5k_led_devices) = {
 	/* HP Compaq CQ60-206US (ddreggors@jumptv.com) */
 	{ ATH_SDEVICE(PCI_VENDOR_ID_HP, 0x0137a), ATH_LED(3, 1) },
 	/* HP Compaq C700 (nitrousnrg@gmail.com) */
-	{ ATH_SDEVICE(PCI_VENDOR_ID_HP, 0x0137b), ATH_LED(3, 1) },
+	{ ATH_SDEVICE(PCI_VENDOR_ID_HP, 0x0137b), ATH_LED(3, 0) },
 	/* LiteOn AR5BXB63 (magooz@salug.it) */
 	{ ATH_SDEVICE(PCI_VENDOR_ID_ATHEROS, 0x3067), ATH_LED(3, 0) },
 	/* IBM-specific AR5212 (all others) */
diff --git a/drivers/net/wireless/ath/ath9k/eeprom.c b/drivers/net/wireless/ath/ath9k/eeprom.c
index 971d770..2ac0548 100644
--- a/drivers/net/wireless/ath/ath9k/eeprom.c
+++ b/drivers/net/wireless/ath/ath9k/eeprom.c
@@ -408,10 +408,9 @@ void ath9k_hw_get_gain_boundaries_pdadcs(struct ath_hw *ah,
 
 	if (match) {
 		if (AR_SREV_9287(ah)) {
-			/* FIXME: array overrun? */
 			for (i = 0; i < numXpdGains; i++) {
 				minPwrT4[i] = data_9287[idxL].pwrPdg[i][0];
-				maxPwrT4[i] = data_9287[idxL].pwrPdg[i][4];
+				maxPwrT4[i] = data_9287[idxL].pwrPdg[i][intercepts - 1];
 				ath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],
 						data_9287[idxL].pwrPdg[i],
 						data_9287[idxL].vpdPdg[i],
@@ -421,7 +420,7 @@ void ath9k_hw_get_gain_boundaries_pdadcs(struct ath_hw *ah,
 		} else if (eeprom_4k) {
 			for (i = 0; i < numXpdGains; i++) {
 				minPwrT4[i] = data_4k[idxL].pwrPdg[i][0];
-				maxPwrT4[i] = data_4k[idxL].pwrPdg[i][4];
+				maxPwrT4[i] = data_4k[idxL].pwrPdg[i][intercepts - 1];
 				ath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],
 						data_4k[idxL].pwrPdg[i],
 						data_4k[idxL].vpdPdg[i],
@@ -431,7 +430,7 @@ void ath9k_hw_get_gain_boundaries_pdadcs(struct ath_hw *ah,
 		} else {
 			for (i = 0; i < numXpdGains; i++) {
 				minPwrT4[i] = data_def[idxL].pwrPdg[i][0];
-				maxPwrT4[i] = data_def[idxL].pwrPdg[i][4];
+				maxPwrT4[i] = data_def[idxL].pwrPdg[i][intercepts - 1];
 				ath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],
 						data_def[idxL].pwrPdg[i],
 						data_def[idxL].vpdPdg[i],
diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c
index bd126c2..3f37e46 100644
--- a/drivers/net/wireless/ath/ath9k/init.c
+++ b/drivers/net/wireless/ath/ath9k/init.c
@@ -819,6 +819,7 @@ void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
 	hw->max_rate_tries = 10;
 	hw->sta_data_size = sizeof(struct ath_node);
 	hw->vif_data_size = sizeof(struct ath_vif);
+	hw->extra_tx_headroom = 4;
 
 	hw->wiphy->available_antennas_rx = BIT(ah->caps.max_rxchains) - 1;
 	hw->wiphy->available_antennas_tx = BIT(ah->caps.max_txchains) - 1;
diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c
index 82a1b5b..c7f23d2 100644
--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -195,11 +195,13 @@ static bool ath_prepare_reset(struct ath_softc *sc)
 	ath9k_debug_samp_bb_mac(sc);
 	ath9k_hw_disable_interrupts(ah);
 
-	if (!ath_drain_all_txq(sc))
-		ret = false;
-
-	if (!ath_stoprecv(sc))
-		ret = false;
+	if (AR_SREV_9300_20_OR_LATER(ah)) {
+		ret &= ath_stoprecv(sc);
+		ret &= ath_drain_all_txq(sc);
+	} else {
+		ret &= ath_drain_all_txq(sc);
+		ret &= ath_stoprecv(sc);
+	}
 
 	return ret;
 }
diff --git a/drivers/net/wireless/iwlwifi/dvm/dev.h b/drivers/net/wireless/iwlwifi/dvm/dev.h
index 71ea775..e783ea0 100644
--- a/drivers/net/wireless/iwlwifi/dvm/dev.h
+++ b/drivers/net/wireless/iwlwifi/dvm/dev.h
@@ -670,7 +670,6 @@ struct iwl_priv {
 	unsigned long reload_jiffies;
 	int reload_count;
 	bool ucode_loaded;
-	bool init_ucode_run;		/* Don't run init uCode again */
 
 	u8 plcp_delta_threshold;
 
diff --git a/drivers/net/wireless/iwlwifi/dvm/lib.c b/drivers/net/wireless/iwlwifi/dvm/lib.c
index 54f5533..54308df 100644
--- a/drivers/net/wireless/iwlwifi/dvm/lib.c
+++ b/drivers/net/wireless/iwlwifi/dvm/lib.c
@@ -1023,7 +1023,7 @@ static void iwlagn_wowlan_program_keys(struct ieee80211_hw *hw,
 			u8 *pn = seq.ccmp.pn;
 
 			ieee80211_get_key_rx_seq(key, i, &seq);
-			aes_sc->pn = cpu_to_le64(
+			aes_sc[i].pn = cpu_to_le64(
 					(u64)pn[5] |
 					((u64)pn[4] << 8) |
 					((u64)pn[3] << 16) |
diff --git a/drivers/net/wireless/iwlwifi/dvm/ucode.c b/drivers/net/wireless/iwlwifi/dvm/ucode.c
index 0a1cdc5..5ad94a8 100644
--- a/drivers/net/wireless/iwlwifi/dvm/ucode.c
+++ b/drivers/net/wireless/iwlwifi/dvm/ucode.c
@@ -425,9 +425,6 @@ int iwl_run_init_ucode(struct iwl_priv *priv)
 	if (!priv->fw->img[IWL_UCODE_INIT].sec[0].len)
 		return 0;
 
-	if (priv->init_ucode_run)
-		return 0;
-
 	iwl_init_notification_wait(&priv->notif_wait, &calib_wait,
 				   calib_complete, ARRAY_SIZE(calib_complete),
 				   iwlagn_wait_calib, priv);
@@ -447,8 +444,6 @@ int iwl_run_init_ucode(struct iwl_priv *priv)
 	 */
 	ret = iwl_wait_notification(&priv->notif_wait, &calib_wait,
 					UCODE_CALIB_TIMEOUT);
-	if (!ret)
-		priv->init_ucode_run = true;
 
 	goto out;
 
diff --git a/drivers/net/wireless/iwlwifi/mvm/d3.c b/drivers/net/wireless/iwlwifi/mvm/d3.c
index 16bbdcc..2e95b41 100644
--- a/drivers/net/wireless/iwlwifi/mvm/d3.c
+++ b/drivers/net/wireless/iwlwifi/mvm/d3.c
@@ -295,12 +295,12 @@ static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,
 			u8 *pn = seq.ccmp.pn;
 
 			ieee80211_get_key_rx_seq(key, i, &seq);
-			aes_sc->pn = cpu_to_le64((u64)pn[5] |
-						 ((u64)pn[4] << 8) |
-						 ((u64)pn[3] << 16) |
-						 ((u64)pn[2] << 24) |
-						 ((u64)pn[1] << 32) |
-						 ((u64)pn[0] << 40));
+			aes_sc[i].pn = cpu_to_le64((u64)pn[5] |
+						   ((u64)pn[4] << 8) |
+						   ((u64)pn[3] << 16) |
+						   ((u64)pn[2] << 24) |
+						   ((u64)pn[1] << 32) |
+						   ((u64)pn[0] << 40));
 		}
 		data->use_rsc_tsc = true;
 		break;
diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c
index e6660d6..ec0d32a 100644
--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c
+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c
@@ -541,7 +541,7 @@ static int iwl_mvm_mac_add_interface(struct ieee80211_hw *hw,
 
 	ret = iwl_mvm_mac_ctxt_add(mvm, vif);
 	if (ret)
-		goto out_remove_mac;
+		goto out_release;
 
 	/*
 	 * Update power state on the new interface. Admittedly, based on
diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c
index cb34c78..735c266 100644
--- a/drivers/net/wireless/mac80211_hwsim.c
+++ b/drivers/net/wireless/mac80211_hwsim.c
@@ -1931,6 +1931,7 @@ static int hwsim_tx_info_frame_received_nl(struct sk_buff *skb_2,
 	if (!info->attrs[HWSIM_ATTR_ADDR_TRANSMITTER] ||
 	   !info->attrs[HWSIM_ATTR_FLAGS] ||
 	   !info->attrs[HWSIM_ATTR_COOKIE] ||
+	   !info->attrs[HWSIM_ATTR_SIGNAL] ||
 	   !info->attrs[HWSIM_ATTR_TX_INFO])
 		goto out;
 
diff --git a/drivers/net/wireless/mwifiex/debugfs.c b/drivers/net/wireless/mwifiex/debugfs.c
index a5f9875..f84e5d7e 100644
--- a/drivers/net/wireless/mwifiex/debugfs.c
+++ b/drivers/net/wireless/mwifiex/debugfs.c
@@ -637,7 +637,7 @@ mwifiex_rdeeprom_read(struct file *file, char __user *ubuf,
 		(struct mwifiex_private *) file->private_data;
 	unsigned long addr = get_zeroed_page(GFP_KERNEL);
 	char *buf = (char *) addr;
-	int pos = 0, ret = 0, i;
+	int pos, ret, i;
 	u8 value[MAX_EEPROM_DATA];
 
 	if (!buf)
@@ -645,7 +645,7 @@ mwifiex_rdeeprom_read(struct file *file, char __user *ubuf,
 
 	if (saved_offset == -1) {
 		/* No command has been given */
-		pos += snprintf(buf, PAGE_SIZE, "0");
+		pos = snprintf(buf, PAGE_SIZE, "0");
 		goto done;
 	}
 
@@ -654,17 +654,17 @@ mwifiex_rdeeprom_read(struct file *file, char __user *ubuf,
 				  (u16) saved_bytes, value);
 	if (ret) {
 		ret = -EINVAL;
-		goto done;
+		goto out_free;
 	}
 
-	pos += snprintf(buf, PAGE_SIZE, "%d %d ", saved_offset, saved_bytes);
+	pos = snprintf(buf, PAGE_SIZE, "%d %d ", saved_offset, saved_bytes);
 
 	for (i = 0; i < saved_bytes; i++)
-		pos += snprintf(buf + strlen(buf), PAGE_SIZE, "%d ", value[i]);
-
-	ret = simple_read_from_buffer(ubuf, count, ppos, buf, pos);
+		pos += scnprintf(buf + pos, PAGE_SIZE - pos, "%d ", value[i]);
 
 done:
+	ret = simple_read_from_buffer(ubuf, count, ppos, buf, pos);
+out_free:
 	free_page(addr);
 	return ret;
 }
diff --git a/drivers/net/wireless/rt2x00/rt2800usb.c b/drivers/net/wireless/rt2x00/rt2800usb.c
index 400b867..44b6715 100644
--- a/drivers/net/wireless/rt2x00/rt2800usb.c
+++ b/drivers/net/wireless/rt2x00/rt2800usb.c
@@ -1020,6 +1020,7 @@ static struct usb_device_id rt2800usb_device_table[] = {
 	{ USB_DEVICE(0x07d1, 0x3c16) },
 	{ USB_DEVICE(0x07d1, 0x3c17) },
 	{ USB_DEVICE(0x2001, 0x3c1b) },
+	{ USB_DEVICE(0x2001, 0x3c25) },
 	/* Draytek */
 	{ USB_DEVICE(0x07fa, 0x7712) },
 	/* DVICO */
diff --git a/drivers/net/wireless/rtlwifi/base.c b/drivers/net/wireless/rtlwifi/base.c
index 6fc0853..d066f74 100644
--- a/drivers/net/wireless/rtlwifi/base.c
+++ b/drivers/net/wireless/rtlwifi/base.c
@@ -1392,9 +1392,9 @@ void rtl_watchdog_wq_callback(void *data)
 		if (((rtlpriv->link_info.num_rx_inperiod +
 		      rtlpriv->link_info.num_tx_inperiod) > 8) ||
 		    (rtlpriv->link_info.num_rx_inperiod > 2))
-			rtlpriv->enter_ps = true;
-		else
 			rtlpriv->enter_ps = false;
+		else
+			rtlpriv->enter_ps = true;
 
 		/* LeisurePS only work in infra mode. */
 		schedule_work(&rtlpriv->works.lps_change_work);
diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c
index e7a2af3..fa669b5 100644
--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c
+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c
@@ -313,6 +313,8 @@ static struct usb_device_id rtl8192c_usb_ids[] = {
 	{RTL_USB_DEVICE(0x07b8, 0x8188, rtl92cu_hal_cfg)}, /*Abocom - Abocom*/
 	{RTL_USB_DEVICE(0x07b8, 0x8189, rtl92cu_hal_cfg)}, /*Funai - Abocom*/
 	{RTL_USB_DEVICE(0x0846, 0x9041, rtl92cu_hal_cfg)}, /*NetGear WNA1000M*/
+	{RTL_USB_DEVICE(0x0846, 0x9043, rtl92cu_hal_cfg)}, /*NG WNA1000Mv2*/
+	{RTL_USB_DEVICE(0x0b05, 0x17ba, rtl92cu_hal_cfg)}, /*ASUS-Edimax*/
 	{RTL_USB_DEVICE(0x0bda, 0x5088, rtl92cu_hal_cfg)}, /*Thinkware-CC&C*/
 	{RTL_USB_DEVICE(0x0df6, 0x0052, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
 	{RTL_USB_DEVICE(0x0df6, 0x005c, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
@@ -369,6 +371,7 @@ static struct usb_device_id rtl8192c_usb_ids[] = {
 	{RTL_USB_DEVICE(0x2001, 0x3307, rtl92cu_hal_cfg)}, /*D-Link-Cameo*/
 	{RTL_USB_DEVICE(0x2001, 0x3309, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
 	{RTL_USB_DEVICE(0x2001, 0x330a, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
+	{RTL_USB_DEVICE(0x2001, 0x330d, rtl92cu_hal_cfg)}, /*D-Link DWA-131 */
 	{RTL_USB_DEVICE(0x2019, 0xab2b, rtl92cu_hal_cfg)}, /*Planex -Abocom*/
 	{RTL_USB_DEVICE(0x20f4, 0x624d, rtl92cu_hal_cfg)}, /*TRENDNet*/
 	{RTL_USB_DEVICE(0x2357, 0x0100, rtl92cu_hal_cfg)}, /*TP-Link WN8200ND*/
diff --git a/drivers/net/wireless/rtlwifi/usb.c b/drivers/net/wireless/rtlwifi/usb.c
index 57b12a5..3ad79736 100644
--- a/drivers/net/wireless/rtlwifi/usb.c
+++ b/drivers/net/wireless/rtlwifi/usb.c
@@ -119,7 +119,7 @@ static int _usbctrl_vendorreq_sync_read(struct usb_device *udev, u8 request,
 
 	do {
 		status = usb_control_msg(udev, pipe, request, reqtype, value,
-					 index, pdata, len, 0); /*max. timeout*/
+					 index, pdata, len, 1000);
 		if (status < 0) {
 			/* firmware download is checksumed, don't retry */
 			if ((value >= FW_8192C_START_ADDRESS &&
diff --git a/drivers/net/wireless/ti/wl18xx/debugfs.c b/drivers/net/wireless/ti/wl18xx/debugfs.c
index 7f1669c..779dc2b 100644
--- a/drivers/net/wireless/ti/wl18xx/debugfs.c
+++ b/drivers/net/wireless/ti/wl18xx/debugfs.c
@@ -136,7 +136,7 @@ WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, protection_filter, "%u");
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, accum_arp_pend_requests, "%u");
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, max_arp_queue_dep, "%u");
 
-WL18XX_DEBUGFS_FWSTATS_FILE(rx_rate, rx_frames_per_rates, "%u");
+WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(rx_rate, rx_frames_per_rates, 50);
 
 WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(aggr_size, tx_agg_vs_rate,
 				  AGGR_STATS_TX_AGG*AGGR_STATS_TX_RATE);
diff --git a/drivers/net/wireless/ti/wlcore/debugfs.h b/drivers/net/wireless/ti/wlcore/debugfs.h
index f7381dd..1bce432 100644
--- a/drivers/net/wireless/ti/wlcore/debugfs.h
+++ b/drivers/net/wireless/ti/wlcore/debugfs.h
@@ -26,8 +26,8 @@
 
 #include "wlcore.h"
 
-int wl1271_format_buffer(char __user *userbuf, size_t count,
-			 loff_t *ppos, char *fmt, ...);
+__printf(4, 5) int wl1271_format_buffer(char __user *userbuf, size_t count,
+					loff_t *ppos, char *fmt, ...);
 
 int wl1271_debugfs_init(struct wl1271 *wl);
 void wl1271_debugfs_exit(struct wl1271 *wl);
diff --git a/drivers/net/wireless/ti/wlcore/io.h b/drivers/net/wireless/ti/wlcore/io.h
index af7d9f9..beed58b 100644
--- a/drivers/net/wireless/ti/wlcore/io.h
+++ b/drivers/net/wireless/ti/wlcore/io.h
@@ -203,19 +203,23 @@ static inline int __must_check wlcore_write_reg(struct wl1271 *wl, int reg,
 
 static inline void wl1271_power_off(struct wl1271 *wl)
 {
-	int ret;
+	int ret = 0;
 
 	if (!test_bit(WL1271_FLAG_GPIO_POWER, &wl->flags))
 		return;
 
-	ret = wl->if_ops->power(wl->dev, false);
+	if (wl->if_ops->power)
+		ret = wl->if_ops->power(wl->dev, false);
 	if (!ret)
 		clear_bit(WL1271_FLAG_GPIO_POWER, &wl->flags);
 }
 
 static inline int wl1271_power_on(struct wl1271 *wl)
 {
-	int ret = wl->if_ops->power(wl->dev, true);
+	int ret = 0;
+
+	if (wl->if_ops->power)
+		ret = wl->if_ops->power(wl->dev, true);
 	if (ret == 0)
 		set_bit(WL1271_FLAG_GPIO_POWER, &wl->flags);
 
diff --git a/drivers/net/wireless/ti/wlcore/spi.c b/drivers/net/wireless/ti/wlcore/spi.c
index e264478..bfb57e6 100644
--- a/drivers/net/wireless/ti/wlcore/spi.c
+++ b/drivers/net/wireless/ti/wlcore/spi.c
@@ -72,7 +72,10 @@
  */
 #define SPI_AGGR_BUFFER_SIZE (4 * PAGE_SIZE)
 
-#define WSPI_MAX_NUM_OF_CHUNKS (SPI_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE)
+/* Maximum number of SPI write chunks */
+#define WSPI_MAX_NUM_OF_CHUNKS \
+	((SPI_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE) + 1)
+
 
 struct wl12xx_spi_glue {
 	struct device *dev;
@@ -270,9 +273,10 @@ static int __must_check wl12xx_spi_raw_write(struct device *child, int addr,
 					     void *buf, size_t len, bool fixed)
 {
 	struct wl12xx_spi_glue *glue = dev_get_drvdata(child->parent);
-	struct spi_transfer t[2 * (WSPI_MAX_NUM_OF_CHUNKS + 1)];
+	/* SPI write buffers - 2 for each chunk */
+	struct spi_transfer t[2 * WSPI_MAX_NUM_OF_CHUNKS];
 	struct spi_message m;
-	u32 commands[WSPI_MAX_NUM_OF_CHUNKS];
+	u32 commands[WSPI_MAX_NUM_OF_CHUNKS]; /* 1 command per chunk */
 	u32 *cmd;
 	u32 chunk_len;
 	int i;
diff --git a/drivers/net/xen-netback/common.h b/drivers/net/xen-netback/common.h
index f2faa77..dd6b7c3 100644
--- a/drivers/net/xen-netback/common.h
+++ b/drivers/net/xen-netback/common.h
@@ -66,6 +66,8 @@ struct xenvif {
 	/* The shared rings and indexes. */
 	struct xen_netif_tx_back_ring tx;
 	struct xen_netif_rx_back_ring rx;
+	atomic_t ring_refcnt;
+	wait_queue_head_t waiting_to_unmap;
 
 	/* Frontend feature information. */
 	u8 can_sg:1;
@@ -120,6 +122,8 @@ void xenvif_free(struct xenvif *vif);
 
 void xenvif_get(struct xenvif *vif);
 void xenvif_put(struct xenvif *vif);
+void xenvif_get_rings(struct xenvif *vif);
+void xenvif_put_rings(struct xenvif *vif);
 
 int xenvif_xenbus_init(void);
 
diff --git a/drivers/net/xen-netback/interface.c b/drivers/net/xen-netback/interface.c
index 540a796..7e3817a 100644
--- a/drivers/net/xen-netback/interface.c
+++ b/drivers/net/xen-netback/interface.c
@@ -44,12 +44,23 @@ void xenvif_get(struct xenvif *vif)
 	atomic_inc(&vif->refcnt);
 }
 
+void xenvif_get_rings(struct xenvif *vif)
+{
+	atomic_inc(&vif->ring_refcnt);
+}
+
 void xenvif_put(struct xenvif *vif)
 {
 	if (atomic_dec_and_test(&vif->refcnt))
 		wake_up(&vif->waiting_to_free);
 }
 
+void xenvif_put_rings(struct xenvif *vif)
+{
+	if (atomic_dec_and_test(&vif->ring_refcnt))
+		wake_up(&vif->waiting_to_unmap);
+}
+
 int xenvif_schedulable(struct xenvif *vif)
 {
 	return netif_running(vif->dev) && netif_carrier_ok(vif->dev);
@@ -91,6 +102,7 @@ static int xenvif_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	/* Reserve ring slots for the worst-case number of fragments. */
 	vif->rx_req_cons_peek += xen_netbk_count_skb_slots(vif, skb);
 	xenvif_get(vif);
+	xenvif_get_rings(vif);
 
 	if (vif->can_queue && xen_netbk_must_stop_queue(vif))
 		netif_stop_queue(dev);
@@ -271,6 +283,7 @@ struct xenvif *xenvif_alloc(struct device *parent, domid_t domid,
 	vif->dev = dev;
 	INIT_LIST_HEAD(&vif->schedule_list);
 	INIT_LIST_HEAD(&vif->notify_list);
+	init_waitqueue_head(&vif->waiting_to_unmap);
 
 	vif->credit_bytes = vif->remaining_credit = ~0UL;
 	vif->credit_usec  = 0UL;
@@ -365,12 +378,12 @@ void xenvif_disconnect(struct xenvif *vif)
 	if (netif_carrier_ok(vif->dev))
 		xenvif_carrier_off(vif);
 
+	disable_irq(vif->irq);
+	xen_netbk_unmap_frontend_rings(vif);
 	if (vif->irq) {
 		unbind_from_irqhandler(vif->irq, vif);
 		vif->irq = 0;
 	}
-
-	xen_netbk_unmap_frontend_rings(vif);
 }
 
 void xenvif_free(struct xenvif *vif)
diff --git a/drivers/net/xen-netback/netback.c b/drivers/net/xen-netback/netback.c
index 70b830f..1595f81 100644
--- a/drivers/net/xen-netback/netback.c
+++ b/drivers/net/xen-netback/netback.c
@@ -814,6 +814,7 @@ static void xen_netbk_rx_action(struct xen_netbk *netbk)
 			xenvif_put(vif);
 		npo.meta_cons += sco->meta_slots_used;
 		dev_kfree_skb(skb);
+		xenvif_put_rings(vif);
 	}
 
 	list_for_each_entry_safe(vif, tmp, &notify, notify_list) {
@@ -1864,6 +1865,9 @@ static int xen_netbk_kthread(void *data)
 
 void xen_netbk_unmap_frontend_rings(struct xenvif *vif)
 {
+	atomic_dec(&vif->ring_refcnt);
+	wait_event(vif->waiting_to_unmap, atomic_read(&vif->ring_refcnt) == 0);
+
 	if (vif->tx.sring)
 		xenbus_unmap_ring_vfree(xenvif_to_xenbus_device(vif),
 					vif->tx.sring);
@@ -1882,6 +1886,8 @@ int xen_netbk_map_frontend_rings(struct xenvif *vif,
 
 	int err = -ENOMEM;
 
+	atomic_set(&vif->ring_refcnt, 1);
+
 	err = xenbus_map_ring_valloc(xenvif_to_xenbus_device(vif),
 				     tx_ring_ref, &addr);
 	if (err)
diff --git a/drivers/net/xen-netback/xenbus.c b/drivers/net/xen-netback/xenbus.c
index 8a9e875..e0cf18c 100644
--- a/drivers/net/xen-netback/xenbus.c
+++ b/drivers/net/xen-netback/xenbus.c
@@ -33,6 +33,8 @@ struct backend_info {
 	enum xenbus_state frontend_state;
 	struct xenbus_watch hotplug_status_watch;
 	u8 have_hotplug_status_watch:1;
+
+	const char *hotplug_script;
 };
 
 static int connect_rings(struct backend_info *);
@@ -55,6 +57,7 @@ static int netback_remove(struct xenbus_device *dev)
 		xenvif_free(be->vif);
 		be->vif = NULL;
 	}
+	kfree(be->hotplug_script);
 	kfree(be);
 	dev_set_drvdata(&dev->dev, NULL);
 	return 0;
@@ -72,6 +75,7 @@ static int netback_probe(struct xenbus_device *dev,
 	struct xenbus_transaction xbt;
 	int err;
 	int sg;
+	const char *script;
 	struct backend_info *be = kzalloc(sizeof(struct backend_info),
 					  GFP_KERNEL);
 	if (!be) {
@@ -132,6 +136,15 @@ static int netback_probe(struct xenbus_device *dev,
 		goto fail;
 	}
 
+	script = xenbus_read(XBT_NIL, dev->nodename, "script", NULL);
+	if (IS_ERR(script)) {
+		err = PTR_ERR(script);
+		xenbus_dev_fatal(dev, err, "reading script");
+		goto fail;
+	}
+
+	be->hotplug_script = script;
+
 	err = xenbus_switch_state(dev, XenbusStateInitWait);
 	if (err)
 		goto fail;
@@ -162,22 +175,14 @@ static int netback_uevent(struct xenbus_device *xdev,
 			  struct kobj_uevent_env *env)
 {
 	struct backend_info *be = dev_get_drvdata(&xdev->dev);
-	char *val;
 
-	val = xenbus_read(XBT_NIL, xdev->nodename, "script", NULL);
-	if (IS_ERR(val)) {
-		int err = PTR_ERR(val);
-		xenbus_dev_fatal(xdev, err, "reading script");
-		return err;
-	} else {
-		if (add_uevent_var(env, "script=%s", val)) {
-			kfree(val);
-			return -ENOMEM;
-		}
-		kfree(val);
-	}
+	if (!be)
+		return 0;
+
+	if (add_uevent_var(env, "script=%s", be->hotplug_script))
+		return -ENOMEM;
 
-	if (!be || !be->vif)
+	if (!be->vif)
 		return 0;
 
 	return add_uevent_var(env, "vif=%s", be->vif->dev->name);
diff --git a/drivers/of/address.c b/drivers/of/address.c
index 8fb2b576..9ceff3c 100644
--- a/drivers/of/address.c
+++ b/drivers/of/address.c
@@ -629,10 +629,10 @@ struct device_node *of_find_matching_node_by_address(struct device_node *from,
 	struct resource res;
 
 	while (dn) {
-		if (of_address_to_resource(dn, 0, &res))
-			continue;
-		if (res.start == base_address)
+		if (!of_address_to_resource(dn, 0, &res) &&
+		    res.start == base_address)
 			return dn;
+
 		dn = of_find_matching_node(dn, matches);
 	}
 
diff --git a/drivers/parisc/iommu-helpers.h b/drivers/parisc/iommu-helpers.h
index 8c33491..c6aa388 100644
--- a/drivers/parisc/iommu-helpers.h
+++ b/drivers/parisc/iommu-helpers.h
@@ -104,7 +104,11 @@ iommu_coalesce_chunks(struct ioc *ioc, struct device *dev,
 	struct scatterlist *contig_sg;	   /* contig chunk head */
 	unsigned long dma_offset, dma_len; /* start/len of DMA stream */
 	unsigned int n_mappings = 0;
-	unsigned int max_seg_size = dma_get_max_seg_size(dev);
+	unsigned int max_seg_size = min(dma_get_max_seg_size(dev),
+					(unsigned)DMA_CHUNK_SIZE);
+	unsigned int max_seg_boundary = dma_get_seg_boundary(dev) + 1;
+	if (max_seg_boundary)	/* check if the addition above didn't overflow */
+		max_seg_size = min(max_seg_size, max_seg_boundary);
 
 	while (nents > 0) {
 
@@ -139,14 +143,11 @@ iommu_coalesce_chunks(struct ioc *ioc, struct device *dev,
 
 			/*
 			** First make sure current dma stream won't
-			** exceed DMA_CHUNK_SIZE if we coalesce the
+			** exceed max_seg_size if we coalesce the
 			** next entry.
 			*/   
-			if(unlikely(ALIGN(dma_len + dma_offset + startsg->length,
-					    IOVP_SIZE) > DMA_CHUNK_SIZE))
-				break;
-
-			if (startsg->length + dma_len > max_seg_size)
+			if (unlikely(ALIGN(dma_len + dma_offset + startsg->length, IOVP_SIZE) >
+				     max_seg_size))
 				break;
 
 			/*
diff --git a/drivers/parport/Kconfig b/drivers/parport/Kconfig
index a505760..46d2de2 100644
--- a/drivers/parport/Kconfig
+++ b/drivers/parport/Kconfig
@@ -36,7 +36,9 @@ if PARPORT
 config PARPORT_PC
 	tristate "PC-style hardware"
 	depends on (!SPARC64 || PCI) && !SPARC32 && !M32R && !FRV && !S390 && \
-		(!M68K || ISA) && !MN10300 && !AVR32 && !BLACKFIN && !XTENSA
+		(!M68K || ISA) && !MN10300 && !AVR32 && !BLACKFIN && \
+		!XTENSA && !CRIS && !H8300 && !ARM64
+
 	---help---
 	  You should say Y here if you have a PC-style parallel port. All
 	  IBM PC compatible computers and some Alphas have PC-style
diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 689f3c8..aee15ce 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1308,10 +1308,10 @@ int __must_check pci_create_sysfs_dev_files (struct pci_dev *pdev)
 	if (!sysfs_initialized)
 		return -EACCES;
 
-	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
-		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pci_config_attr);
-	else
+	if (pdev->cfg_size > PCI_CFG_SPACE_SIZE)
 		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+	else
+		retval = sysfs_create_bin_file(&pdev->dev.kobj, &pci_config_attr);
 	if (retval)
 		goto err;
 
@@ -1368,10 +1368,10 @@ err_rom_file:
 err_resource_files:
 	pci_remove_resource_files(pdev);
 err_config_file:
-	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
-		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
-	else
+	if (pdev->cfg_size > PCI_CFG_SPACE_SIZE)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+	else
+		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 err:
 	return retval;
 }
@@ -1405,10 +1405,10 @@ void pci_remove_sysfs_dev_files(struct pci_dev *pdev)
 
 	pci_remove_capabilities_sysfs(pdev);
 
-	if (pdev->cfg_size < PCI_CFG_SPACE_EXP_SIZE)
-		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
-	else
+	if (pdev->cfg_size > PCI_CFG_SPACE_SIZE)
 		sysfs_remove_bin_file(&pdev->dev.kobj, &pcie_config_attr);
+	else
+		sysfs_remove_bin_file(&pdev->dev.kobj, &pci_config_attr);
 
 	pci_remove_resource_files(pdev);
 
diff --git a/drivers/pci/pcie/aer/aerdrv.c b/drivers/pci/pcie/aer/aerdrv.c
index 76ef634..b84e713 100644
--- a/drivers/pci/pcie/aer/aerdrv.c
+++ b/drivers/pci/pcie/aer/aerdrv.c
@@ -262,7 +262,6 @@ static struct aer_rpc *aer_alloc_rpc(struct pcie_device *dev)
 	rpc->rpd = dev;
 	INIT_WORK(&rpc->dpc_handler, aer_isr);
 	mutex_init(&rpc->rpc_mutex);
-	init_waitqueue_head(&rpc->wait_release);
 
 	/* Use PCIe bus function to store rpc into PCIe device */
 	set_service_data(dev, rpc);
@@ -285,8 +284,7 @@ static void aer_remove(struct pcie_device *dev)
 		if (rpc->isr)
 			free_irq(dev->irq, dev);
 
-		wait_event(rpc->wait_release, rpc->prod_idx == rpc->cons_idx);
-
+		flush_work(&rpc->dpc_handler);
 		aer_disable_rootport(rpc);
 		kfree(rpc);
 		set_service_data(dev, NULL);
diff --git a/drivers/pci/pcie/aer/aerdrv.h b/drivers/pci/pcie/aer/aerdrv.h
index d12c77c..3b8766e 100644
--- a/drivers/pci/pcie/aer/aerdrv.h
+++ b/drivers/pci/pcie/aer/aerdrv.h
@@ -76,7 +76,6 @@ struct aer_rpc {
 					 * recovery on the same
 					 * root port hierarchy
 					 */
-	wait_queue_head_t wait_release;
 };
 
 struct aer_broadcast_data {
diff --git a/drivers/pci/pcie/aer/aerdrv_core.c b/drivers/pci/pcie/aer/aerdrv_core.c
index 0f4554e..a017aac 100644
--- a/drivers/pci/pcie/aer/aerdrv_core.c
+++ b/drivers/pci/pcie/aer/aerdrv_core.c
@@ -817,8 +817,6 @@ void aer_isr(struct work_struct *work)
 	while (get_e_source(rpc, &e_src))
 		aer_isr_one_error(p_device, &e_src);
 	mutex_unlock(&rpc->rpc_mutex);
-
-	wake_up(&rpc->wait_release);
 }
 
 /**
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 034a4d2..2d7cd0c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -292,6 +292,9 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 {
 	unsigned int pos, reg;
 
+	if (dev->non_compliant_bars)
+		return;
+
 	for (pos = 0; pos < howmany; pos++) {
 		struct resource *res = &dev->resource[pos];
 		reg = PCI_BASE_ADDRESS_0 + (pos << 2);
@@ -981,6 +984,7 @@ void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 int pci_setup_device(struct pci_dev *dev)
 {
 	u32 class;
+	u16 cmd;
 	u8 hdr_type;
 	struct pci_slot *slot;
 	int pos = 0;
@@ -1028,6 +1032,16 @@ int pci_setup_device(struct pci_dev *dev)
 	/* device class may be changed after fixup */
 	class = dev->class >> 8;
 
+	if (dev->non_compliant_bars) {
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);
+		if (cmd & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) {
+			dev_info(&dev->dev, "device has non-compliant BARs; disabling IO/MEM decoding\n");
+			cmd &= ~PCI_COMMAND_IO;
+			cmd &= ~PCI_COMMAND_MEMORY;
+			pci_write_config_word(dev, PCI_COMMAND, cmd);
+		}
+	}
+
 	switch (dev->hdr_type) {		    /* header type */
 	case PCI_HEADER_TYPE_NORMAL:		    /* standard header */
 		if (class == PCI_CLASS_BRIDGE_PCI)
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 910339c..a663715 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -292,6 +292,18 @@ static void quirk_citrine(struct pci_dev *dev)
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_IBM,	PCI_DEVICE_ID_IBM_CITRINE,	quirk_citrine);
 
+/*
+ * This chip can cause bus lockups if config addresses above 0x600
+ * are read or written.
+ */
+static void quirk_nfp6000(struct pci_dev *dev)
+{
+	dev->cfg_size = 0x600;
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP4000,	quirk_nfp6000);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP6000,	quirk_nfp6000);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP6000_VF,	quirk_nfp6000);
+
 /*  On IBM Crocodile ipr SAS adapters, expand BAR to system page size */
 static void quirk_extend_bar_to_page(struct pci_dev *dev)
 {
@@ -2796,12 +2808,15 @@ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x3c28, vtd_mask_spec_errors);
 
 static void fixup_ti816x_class(struct pci_dev *dev)
 {
+	u32 class = dev->class;
+
 	/* TI 816x devices do not have class code set when in PCIe boot mode */
-	dev_info(&dev->dev, "Setting PCI class for 816x PCIe device\n");
-	dev->class = PCI_CLASS_MULTIMEDIA_VIDEO;
+	dev->class = PCI_CLASS_MULTIMEDIA_VIDEO << 8;
+	dev_info(&dev->dev, "PCI class overridden (%#08x -> %#08x)\n",
+		 class, dev->class);
 }
 DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_TI, 0xb800,
-				 PCI_CLASS_NOT_DEFINED, 0, fixup_ti816x_class);
+			      PCI_CLASS_NOT_DEFINED, 0, fixup_ti816x_class);
 
 /* Some PCIe devices do not work reliably with the claimed maximum
  * payload size supported.
diff --git a/drivers/pci/xen-pcifront.c b/drivers/pci/xen-pcifront.c
index f7197a7..eb402f4 100644
--- a/drivers/pci/xen-pcifront.c
+++ b/drivers/pci/xen-pcifront.c
@@ -51,7 +51,7 @@ struct pcifront_device {
 };
 
 struct pcifront_sd {
-	int domain;
+	struct pci_sysdata sd;
 	struct pcifront_device *pdev;
 };
 
@@ -65,7 +65,9 @@ static inline void pcifront_init_sd(struct pcifront_sd *sd,
 				    unsigned int domain, unsigned int bus,
 				    struct pcifront_device *pdev)
 {
-	sd->domain = domain;
+	/* Because we do not expose that information via XenBus. */
+	sd->sd.node = first_online_node;
+	sd->sd.domain = domain;
 	sd->pdev = pdev;
 }
 
@@ -463,8 +465,8 @@ static int pcifront_scan_root(struct pcifront_device *pdev,
 	dev_info(&pdev->xdev->dev, "Creating PCI Frontend Bus %04x:%02x\n",
 		 domain, bus);
 
-	bus_entry = kmalloc(sizeof(*bus_entry), GFP_KERNEL);
-	sd = kmalloc(sizeof(*sd), GFP_KERNEL);
+	bus_entry = kzalloc(sizeof(*bus_entry), GFP_KERNEL);
+	sd = kzalloc(sizeof(*sd), GFP_KERNEL);
 	if (!bus_entry || !sd) {
 		err = -ENOMEM;
 		goto err_out;
diff --git a/drivers/pcmcia/topic.h b/drivers/pcmcia/topic.h
index 615a45a..582688fe 100644
--- a/drivers/pcmcia/topic.h
+++ b/drivers/pcmcia/topic.h
@@ -104,6 +104,9 @@
 #define TOPIC_EXCA_IF_CONTROL		0x3e	/* 8 bit */
 #define TOPIC_EXCA_IFC_33V_ENA		0x01
 
+#define TOPIC_PCI_CFG_PPBCN		0x3e	/* 16-bit */
+#define TOPIC_PCI_CFG_PPBCN_WBEN	0x0400
+
 static void topic97_zoom_video(struct pcmcia_socket *sock, int onoff)
 {
 	struct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);
@@ -138,6 +141,7 @@ static int topic97_override(struct yenta_socket *socket)
 static int topic95_override(struct yenta_socket *socket)
 {
 	u8 fctrl;
+	u16 ppbcn;
 
 	/* enable 3.3V support for 16bit cards */
 	fctrl = exca_readb(socket, TOPIC_EXCA_IF_CONTROL);
@@ -146,6 +150,18 @@ static int topic95_override(struct yenta_socket *socket)
 	/* tell yenta to use exca registers to power 16bit cards */
 	socket->flags |= YENTA_16BIT_POWER_EXCA | YENTA_16BIT_POWER_DF;
 
+	/* Disable write buffers to prevent lockups under load with numerous
+	   Cardbus cards, observed on Tecra 500CDT and reported elsewhere on the
+	   net.  This is not a power-on default according to the datasheet
+	   but some BIOSes seem to set it. */
+	if (pci_read_config_word(socket->dev, TOPIC_PCI_CFG_PPBCN, &ppbcn) == 0
+	    && socket->dev->revision <= 7
+	    && (ppbcn & TOPIC_PCI_CFG_PPBCN_WBEN)) {
+		ppbcn &= ~TOPIC_PCI_CFG_PPBCN_WBEN;
+		pci_write_config_word(socket->dev, TOPIC_PCI_CFG_PPBCN, ppbcn);
+		dev_info(&socket->dev->dev, "Disabled ToPIC95 Cardbus write buffers.\n");
+	}
+
 	return 0;
 }
 
diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
index 9c9fc69..ea40c51 100644
--- a/drivers/pinctrl/core.c
+++ b/drivers/pinctrl/core.c
@@ -1077,7 +1077,7 @@ void devm_pinctrl_put(struct pinctrl *p)
 EXPORT_SYMBOL_GPL(devm_pinctrl_put);
 
 int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
-			 bool dup, bool locked)
+			 bool dup)
 {
 	int i, ret;
 	struct pinctrl_maps *maps_node;
@@ -1145,11 +1145,9 @@ int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
 		maps_node->maps = maps;
 	}
 
-	if (!locked)
-		mutex_lock(&pinctrl_maps_mutex);
+	mutex_lock(&pinctrl_maps_mutex);
 	list_add_tail(&maps_node->node, &pinctrl_maps);
-	if (!locked)
-		mutex_unlock(&pinctrl_maps_mutex);
+	mutex_unlock(&pinctrl_maps_mutex);
 
 	return 0;
 }
@@ -1164,7 +1162,7 @@ int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
 int pinctrl_register_mappings(struct pinctrl_map const *maps,
 			      unsigned num_maps)
 {
-	return pinctrl_register_map(maps, num_maps, true, false);
+	return pinctrl_register_map(maps, num_maps, true);
 }
 
 void pinctrl_unregister_map(struct pinctrl_map const *map)
diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index 75476b3..b24ea84 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -183,7 +183,7 @@ static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,
 }
 
 int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
-			 bool dup, bool locked);
+			 bool dup);
 void pinctrl_unregister_map(struct pinctrl_map const *map);
 
 extern int pinctrl_force_sleep(struct pinctrl_dev *pctldev);
diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c
index 340fb4e..fd91c4c 100644
--- a/drivers/pinctrl/devicetree.c
+++ b/drivers/pinctrl/devicetree.c
@@ -92,7 +92,7 @@ static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,
 	dt_map->num_maps = num_maps;
 	list_add_tail(&dt_map->node, &p->dt_maps);
 
-	return pinctrl_register_map(map, num_maps, false, true);
+	return pinctrl_register_map(map, num_maps, false);
 }
 
 struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-370.c b/drivers/pinctrl/mvebu/pinctrl-armada-370.c
index 48e21a2..c99e64a 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-370.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-370.c
@@ -358,11 +358,11 @@ static struct mvebu_mpp_mode mv88f6710_mpp_modes[] = {
 	MPP_MODE(64,
 	   MPP_FUNCTION(0x0, "gpio", NULL),
 	   MPP_FUNCTION(0x1, "spi0", "miso"),
-	   MPP_FUNCTION(0x2, "spi0-1", "cs1")),
+	   MPP_FUNCTION(0x2, "spi0", "cs1")),
 	MPP_MODE(65,
 	   MPP_FUNCTION(0x0, "gpio", NULL),
 	   MPP_FUNCTION(0x1, "spi0", "mosi"),
-	   MPP_FUNCTION(0x2, "spi0-1", "cs2")),
+	   MPP_FUNCTION(0x2, "spi0", "cs2")),
 };
 
 static struct mvebu_pinctrl_soc_info armada_370_pinctrl_info;
diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c
index ab5dc04..5923a9e 100644
--- a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c
+++ b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c
@@ -14,10 +14,7 @@
  * available: mv78230, mv78260 and mv78460. From a pin muxing
  * perspective, the mv78230 has 49 MPP pins. The mv78260 and mv78460
  * both have 67 MPP pins (more GPIOs and address lines for the memory
- * bus mainly). The only difference between the mv78260 and the
- * mv78460 in terms of pin muxing is the addition of two functions on
- * pins 43 and 56 to access the VDD of the CPU2 and 3 (mv78260 has two
- * cores, mv78460 has four cores).
+ * bus mainly).
  */
 
 #include <linux/err.h>
@@ -159,20 +156,17 @@ static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {
 	MPP_MODE(24,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "sata1", "prsnt",    V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x2, "nf", "bootcs-re",   V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, "tdm", "rst",        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, "lcd", "hsync",      V_MV78230_PLUS)),
 	MPP_MODE(25,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "sata0", "prsnt",    V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x2, "nf", "bootcs-we",   V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, "tdm", "pclk",       V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, "lcd", "vsync",      V_MV78230_PLUS)),
 	MPP_MODE(26,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, "tdm", "fsync",      V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x4, "lcd", "clk",        V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x5, "vdd", "cpu1-pd",    V_MV78230_PLUS)),
+		 MPP_VAR_FUNCTION(0x4, "lcd", "clk",        V_MV78230_PLUS)),
 	MPP_MODE(27,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "ptp", "trig",       V_MV78230_PLUS),
@@ -187,8 +181,7 @@ static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "ptp", "clk",        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, "tdm", "int0",       V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x4, "lcd", "ref-clk",    V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x5, "vdd", "cpu0-pd",    V_MV78230_PLUS)),
+		 MPP_VAR_FUNCTION(0x4, "lcd", "ref-clk",    V_MV78230_PLUS)),
 	MPP_MODE(30,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "sd0", "clk",        V_MV78230_PLUS),
@@ -196,13 +189,11 @@ static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {
 	MPP_MODE(31,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "sd0", "cmd",        V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x3, "tdm", "int2",       V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x5, "vdd", "cpu0-pd",    V_MV78230_PLUS)),
+		 MPP_VAR_FUNCTION(0x3, "tdm", "int2",       V_MV78230_PLUS)),
 	MPP_MODE(32,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "sd0", "d0",         V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x3, "tdm", "int3",       V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x5, "vdd", "cpu1-pd",    V_MV78230_PLUS)),
+		 MPP_VAR_FUNCTION(0x3, "tdm", "int3",       V_MV78230_PLUS)),
 	MPP_MODE(33,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "sd0", "d1",         V_MV78230_PLUS),
@@ -234,7 +225,6 @@ static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "spi", "cs1",        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, "uart2", "cts",      V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x3, "vdd", "cpu1-pd",    V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, "lcd", "vga-hsync",  V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x5, "pcie", "clkreq0",   V_MV78230_PLUS)),
 	MPP_MODE(41,
@@ -249,15 +239,13 @@ static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {
 		 MPP_VAR_FUNCTION(0x1, "uart2", "rxd",      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, "uart0", "cts",      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, "tdm", "int7",       V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x4, "tdm-1", "timer",    V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x5, "vdd", "cpu0-pd",    V_MV78230_PLUS)),
+		 MPP_VAR_FUNCTION(0x4, "tdm-1", "timer",    V_MV78230_PLUS)),
 	MPP_MODE(43,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "uart2", "txd",      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, "uart0", "rts",      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, "spi", "cs3",        V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x4, "pcie", "rstout",    V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x5, "vdd", "cpu2-3-pd",  V_MV78460)),
+		 MPP_VAR_FUNCTION(0x4, "pcie", "rstout",    V_MV78230_PLUS)),
 	MPP_MODE(44,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "uart2", "cts",      V_MV78230_PLUS),
@@ -286,7 +274,7 @@ static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {
 		 MPP_VAR_FUNCTION(0x5, "pcie", "clkreq3",   V_MV78230_PLUS)),
 	MPP_MODE(48,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78230_PLUS),
-		 MPP_VAR_FUNCTION(0x1, "tclk", NULL,        V_MV78230_PLUS),
+		 MPP_VAR_FUNCTION(0x1, "dev", "clkout",     V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, "dev", "burst/last", V_MV78230_PLUS)),
 	MPP_MODE(49,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78260_PLUS),
@@ -308,16 +296,13 @@ static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {
 		 MPP_VAR_FUNCTION(0x1, "dev", "ad19",       V_MV78260_PLUS)),
 	MPP_MODE(55,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78260_PLUS),
-		 MPP_VAR_FUNCTION(0x1, "dev", "ad20",       V_MV78260_PLUS),
-		 MPP_VAR_FUNCTION(0x2, "vdd", "cpu0-pd",    V_MV78260_PLUS)),
+		 MPP_VAR_FUNCTION(0x1, "dev", "ad20",       V_MV78260_PLUS)),
 	MPP_MODE(56,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78260_PLUS),
-		 MPP_VAR_FUNCTION(0x1, "dev", "ad21",       V_MV78260_PLUS),
-		 MPP_VAR_FUNCTION(0x2, "vdd", "cpu1-pd",    V_MV78260_PLUS)),
+		 MPP_VAR_FUNCTION(0x1, "dev", "ad21",       V_MV78260_PLUS)),
 	MPP_MODE(57,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78260_PLUS),
-		 MPP_VAR_FUNCTION(0x1, "dev", "ad22",       V_MV78260_PLUS),
-		 MPP_VAR_FUNCTION(0x2, "vdd", "cpu2-3-pd",  V_MV78460)),
+		 MPP_VAR_FUNCTION(0x1, "dev", "ad22",       V_MV78260_PLUS)),
 	MPP_MODE(58,
 		 MPP_VAR_FUNCTION(0x0, "gpio", NULL,        V_MV78260_PLUS),
 		 MPP_VAR_FUNCTION(0x1, "dev", "ad23",       V_MV78260_PLUS)),
diff --git a/drivers/pinctrl/pinctrl-ambarella.c b/drivers/pinctrl/pinctrl-ambarella.c
index 9fcc1ce..28c33a8 100644
--- a/drivers/pinctrl/pinctrl-ambarella.c
+++ b/drivers/pinctrl/pinctrl-ambarella.c
@@ -40,7 +40,9 @@
 
 #define MUXIDS_TO_PINID(m)	((m) & 0xfff)
 #define MUXIDS_TO_ALT(m)	(((m) >> 12) & 0xf)
-#define MUXIDS_TO_CONF(m)	(((m) >> 16) & 0xffff)
+
+#define CONFIDS_TO_PINID(c)	((c) & 0xfff)
+#define CONFIDS_TO_CONF(c)	(((c) >> 16) & 0xffff)
 
 /*
  * bit1~0: 00: pull down, 01: pull up, 1x: clear pull up/down
@@ -61,6 +63,8 @@ struct ambpin_group {
 	unsigned int		*pins;
 	unsigned		num_pins;
 	u8			*alt;
+	unsigned int		*conf_pins;
+	unsigned		num_conf_pins;
 	unsigned long		*conf;
 };
 
@@ -118,9 +122,22 @@ static int amb_get_group_pins(struct pinctrl_dev *pctldev,
 }
 
 static void amb_pin_dbg_show(struct pinctrl_dev *pctldev,
-			struct seq_file *s, unsigned offset)
+			struct seq_file *s, unsigned pin)
 {
+	struct pin_desc *desc;
+
 	seq_printf(s, " %s", dev_name(pctldev->dev));
+
+	desc = pin_desc_get(pctldev, pin);
+	if (desc) {
+		seq_printf(s, " owner: %s%s%s%s",
+			desc->mux_owner ? desc->mux_owner : "",
+			desc->mux_owner && desc->gpio_owner ? " " : "",
+			desc->gpio_owner ? desc->gpio_owner : "",
+			!desc->mux_owner && !desc->gpio_owner ? "NULL" : "");
+	} else {
+		seq_printf(s, " not registered");
+	}
 }
 
 static int amb_dt_node_to_map(struct pinctrl_dev *pctldev,
@@ -132,9 +149,8 @@ static int amb_dt_node_to_map(struct pinctrl_dev *pctldev,
 	struct pinctrl_map *new_map;
 	char *grp_name = NULL;
 	int length = strlen(np->name) + SUFFIX_LENGTH;
-	u32 i, reg, new_num = 1;
+	u32 i, reg, new_num;
 
-	/* Check for pin config node which has no 'reg' property */
 	if (of_property_read_u32(np, "reg", &reg))
 		return -EINVAL;
 
@@ -157,7 +173,7 @@ static int amb_dt_node_to_map(struct pinctrl_dev *pctldev,
 		return -EINVAL;
 	}
 
-	new_num += grp->num_pins;
+	new_num = !!grp->num_pins + grp->num_conf_pins;
 	new_map = devm_kzalloc(soc->dev,
 				sizeof(struct pinctrl_map) * new_num, GFP_KERNEL);
 	if (!new_map)
@@ -167,16 +183,18 @@ static int amb_dt_node_to_map(struct pinctrl_dev *pctldev,
 	*num_maps = new_num;
 
 	/* create mux map */
-	new_map[0].type = PIN_MAP_TYPE_MUX_GROUP;
-	new_map[0].data.mux.group = grp_name;
-	new_map[0].data.mux.function = np->name;
+	if (grp->num_pins) {
+		new_map[0].type = PIN_MAP_TYPE_MUX_GROUP;
+		new_map[0].data.mux.group = grp_name;
+		new_map[0].data.mux.function = np->name;
+		new_map++;
+	}
 
 	/* create config map */
-	new_map++;
-	for (i = 0; i < grp->num_pins; i++) {
+	for (i = 0; i < grp->num_conf_pins; i++) {
 		new_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;
 		new_map[i].data.configs.group_or_pin =
-				pin_get_name(pctldev, grp->pins[i]);
+				pin_get_name(pctldev, grp->conf_pins[i]);
 		new_map[i].data.configs.configs = &grp->conf[i];
 		new_map[i].data.configs.num_configs = 1;
 	}
@@ -440,13 +458,44 @@ static int amb_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,
 static int amb_pinconf_get(struct pinctrl_dev *pctldev,
 			unsigned int pin, unsigned long *config)
 {
+	dev_WARN_ONCE(pctldev->dev, true, "NOT Implemented.\n");
 	return -ENOTSUPP;
 }
 
+static void amb_pinconf_dbg_show(struct pinctrl_dev *pctldev,
+			struct seq_file *s, unsigned pin)
+{
+	struct amb_pinctrl_soc_data *soc;
+	u32 bank, offset, reg;
+	u32 pull_en, pull_dir, drv_strength;
+
+	soc = pinctrl_dev_get_drvdata(pctldev);
+	bank = PINID_TO_BANK(pin);
+	offset = PINID_TO_OFFSET(pin);
+
+	reg = GPIO_PAD_PULL_REG(GPIO_PAD_PULL_EN_OFFSET(bank));
+	pull_en = (amba_readl(reg) >> offset) & 0x1;
+
+	reg = GPIO_PAD_PULL_REG(GPIO_PAD_PULL_DIR_OFFSET(bank));
+	pull_dir = (amba_readl(reg) >> offset) & 0x1;
+
+	seq_printf(s, " pull: %s, ", pull_en ? pull_dir ? "up" : "down" : "disable");
+
+	reg = RCT_REG(GPIO_DS0_OFFSET(bank));
+	drv_strength = ((amba_readl(reg) >> offset) & 0x1) << 1;
+	reg = RCT_REG(GPIO_DS1_OFFSET(bank));
+	drv_strength |= (amba_readl(reg) >> offset) & 0x1;
+
+	seq_printf(s, "drive-strength: %s",
+		drv_strength == 3 ? "12mA" : drv_strength == 2 ? "8mA" :
+		drv_strength == 1 ? "4mA" : "2mA");
+}
+
 /* list of pinconfig callbacks for pinconfig vertical in the pinctrl code */
 static const struct pinconf_ops amb_pinconf_ops = {
 	.pin_config_get		= amb_pinconf_get,
 	.pin_config_set		= amb_pinconf_set,
+	.pin_config_dbg_show	= amb_pinconf_dbg_show,
 };
 
 static struct pinctrl_desc amb_pinctrl_desc = {
@@ -461,48 +510,67 @@ static int amb_pinctrl_parse_group(struct amb_pinctrl_soc_data *soc,
 {
 	struct ambpin_group *grp = &soc->groups[idx];
 	struct property *prop;
-	const char *prop_name = "amb,pinmux-ids";
+	const char *prop_name;
 	char *grp_name;
 	int length = strlen(np->name) + SUFFIX_LENGTH;
-	u32 val, i;
+	u32 reg, i;
 
 	grp_name = devm_kzalloc(soc->dev, length, GFP_KERNEL);
 	if (!grp_name)
 		return -ENOMEM;
 
-	if (of_property_read_u32(np, "reg", &val))
+	if (of_property_read_u32(np, "reg", &reg))
 		return -EINVAL;
 
-	snprintf(grp_name, length, "%s.%d", np->name, val);
+	snprintf(grp_name, length, "%s.%d", np->name, reg);
 
 	grp->name = grp_name;
 
+	prop_name = "amb,pinmux-ids";
 	prop = of_find_property(np, prop_name, &length);
-	if (!prop)
-		return -EINVAL;
-	grp->num_pins = length / sizeof(u32);
+	if (prop) {
+		grp->num_pins = length / sizeof(u32);
 
-	grp->pins = devm_kzalloc(soc->dev,
-				grp->num_pins * sizeof(u32), GFP_KERNEL);
-	if (!grp->pins)
-		return -ENOMEM;
+		grp->pins = devm_kzalloc(soc->dev,
+					grp->num_pins * sizeof(u32), GFP_KERNEL);
+		if (!grp->pins)
+			return -ENOMEM;
 
-	grp->alt = devm_kzalloc(soc->dev,
-				grp->num_pins * sizeof(u8), GFP_KERNEL);
-	if (!grp->alt)
-		return -ENOMEM;
+		grp->alt = devm_kzalloc(soc->dev,
+					grp->num_pins * sizeof(u8), GFP_KERNEL);
+		if (!grp->alt)
+			return -ENOMEM;
 
-	grp->conf = devm_kzalloc(soc->dev,
-				grp->num_pins * sizeof(unsigned long), GFP_KERNEL);
-	if (!grp->conf)
-		return -ENOMEM;
+		of_property_read_u32_array(np, prop_name, grp->pins, grp->num_pins);
 
-	of_property_read_u32_array(np, prop_name, grp->pins, grp->num_pins);
+		for (i = 0; i < grp->num_pins; i++) {
+			grp->alt[i] = MUXIDS_TO_ALT(grp->pins[i]);
+			grp->pins[i] = MUXIDS_TO_PINID(grp->pins[i]);
+		}
+	}
 
-	for (i = 0; i < grp->num_pins; i++) {
-		grp->alt[i] = MUXIDS_TO_ALT(grp->pins[i]);
-		grp->conf[i] = MUXIDS_TO_CONF(grp->pins[i]);
-		grp->pins[i] = MUXIDS_TO_PINID(grp->pins[i]);
+	/* parse pinconf */
+	prop_name = "amb,pinconf-ids";
+	prop = of_find_property(np, prop_name, &length);
+	if (prop) {
+		grp->num_conf_pins = length / sizeof(u32);
+
+		grp->conf_pins = devm_kzalloc(soc->dev,
+					grp->num_conf_pins * sizeof(u32), GFP_KERNEL);
+		if (!grp->conf_pins)
+			return -ENOMEM;
+
+		grp->conf = devm_kzalloc(soc->dev,
+				grp->num_conf_pins * sizeof(unsigned long), GFP_KERNEL);
+		if (!grp->conf)
+			return -ENOMEM;
+
+		of_property_read_u32_array(np, prop_name, grp->conf_pins, grp->num_conf_pins);
+
+		for (i = 0; i < grp->num_conf_pins; i++) {
+			grp->conf[i] = CONFIDS_TO_CONF(grp->conf_pins[i]);
+			grp->conf_pins[i] = CONFIDS_TO_PINID(grp->conf_pins[i]);
+		}
 	}
 
 	if (out_name)
diff --git a/drivers/platform/x86/hp-wmi.c b/drivers/platform/x86/hp-wmi.c
index d111c86..46497c6 100644
--- a/drivers/platform/x86/hp-wmi.c
+++ b/drivers/platform/x86/hp-wmi.c
@@ -640,6 +640,11 @@ static int hp_wmi_rfkill_setup(struct platform_device *device)
 	if (err)
 		return err;
 
+	err = hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, &wireless,
+				   sizeof(wireless), 0);
+	if (err)
+		return err;
+
 	if (wireless & 0x1) {
 		wifi_rfkill = rfkill_alloc("hp-wifi", &device->dev,
 					   RFKILL_TYPE_WLAN,
diff --git a/drivers/platform/x86/intel_scu_ipcutil.c b/drivers/platform/x86/intel_scu_ipcutil.c
index 02bc5a6..aa45424 100644
--- a/drivers/platform/x86/intel_scu_ipcutil.c
+++ b/drivers/platform/x86/intel_scu_ipcutil.c
@@ -49,7 +49,7 @@ struct scu_ipc_data {
 
 static int scu_reg_access(u32 cmd, struct scu_ipc_data  *data)
 {
-	int count = data->count;
+	unsigned int count = data->count;
 
 	if (count == 0 || count == 3 || count > 4)
 		return -EINVAL;
diff --git a/drivers/pnp/pnpbios/bioscalls.c b/drivers/pnp/pnpbios/bioscalls.c
index 769d265..deb7f4b 100644
--- a/drivers/pnp/pnpbios/bioscalls.c
+++ b/drivers/pnp/pnpbios/bioscalls.c
@@ -21,7 +21,7 @@
 
 #include "pnpbios.h"
 
-static struct {
+__visible struct {
 	u16 offset;
 	u16 segment;
 } pnp_bios_callpoint;
@@ -41,6 +41,7 @@ asmlinkage void pnp_bios_callfunc(void);
 
 __asm__(".text			\n"
 	__ALIGN_STR "\n"
+	".globl pnp_bios_callfunc\n"
 	"pnp_bios_callfunc:\n"
 	"	pushl %edx	\n"
 	"	pushl %ecx	\n"
@@ -66,9 +67,9 @@ static struct desc_struct bad_bios_desc = GDT_ENTRY_INIT(0x4092,
  * after PnP BIOS oopses.
  */
 
-u32 pnp_bios_fault_esp;
-u32 pnp_bios_fault_eip;
-u32 pnp_bios_is_utter_crap = 0;
+__visible u32 pnp_bios_fault_esp;
+__visible u32 pnp_bios_fault_eip;
+__visible u32 pnp_bios_is_utter_crap = 0;
 
 static spinlock_t pnp_bios_lock;
 
diff --git a/drivers/power/lp8788-charger.c b/drivers/power/lp8788-charger.c
index ed49b50..72da2a6 100644
--- a/drivers/power/lp8788-charger.c
+++ b/drivers/power/lp8788-charger.c
@@ -417,8 +417,10 @@ static int lp8788_psy_register(struct platform_device *pdev,
 	pchg->battery.num_properties = ARRAY_SIZE(lp8788_battery_prop);
 	pchg->battery.get_property = lp8788_battery_get_property;
 
-	if (power_supply_register(&pdev->dev, &pchg->battery))
+	if (power_supply_register(&pdev->dev, &pchg->battery)) {
+		power_supply_unregister(&pchg->charger);
 		return -EPERM;
+	}
 
 	return 0;
 }
diff --git a/drivers/power/wm831x_power.c b/drivers/power/wm831x_power.c
index 153f31f..7b1ec8b 100644
--- a/drivers/power/wm831x_power.c
+++ b/drivers/power/wm831x_power.c
@@ -568,7 +568,7 @@ static int wm831x_power_probe(struct platform_device *pdev)
 
 	irq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, "SYSLO"));
 	ret = request_threaded_irq(irq, NULL, wm831x_syslo_irq,
-				   IRQF_TRIGGER_RISING, "System power low",
+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT, "System power low",
 				   power);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request SYSLO IRQ %d: %d\n",
@@ -578,7 +578,7 @@ static int wm831x_power_probe(struct platform_device *pdev)
 
 	irq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, "PWR SRC"));
 	ret = request_threaded_irq(irq, NULL, wm831x_pwr_src_irq,
-				   IRQF_TRIGGER_RISING, "Power source",
+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT, "Power source",
 				   power);
 	if (ret != 0) {
 		dev_err(&pdev->dev, "Failed to request PWR SRC IRQ %d: %d\n",
@@ -591,7 +591,7 @@ static int wm831x_power_probe(struct platform_device *pdev)
 				 platform_get_irq_byname(pdev,
 							 wm831x_bat_irqs[i]));
 		ret = request_threaded_irq(irq, NULL, wm831x_bat_irq,
-					   IRQF_TRIGGER_RISING,
+					   IRQF_TRIGGER_RISING | IRQF_ONESHOT,
 					   wm831x_bat_irqs[i],
 					   power);
 		if (ret != 0) {
diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 56bfea5..1d7a283 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -811,7 +811,7 @@ static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)
 static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev->constraints;
-	char buf[80] = "";
+	char buf[160] = "";
 	int count = 0;
 	int ret;
 
diff --git a/drivers/remoteproc/remoteproc_debugfs.c b/drivers/remoteproc/remoteproc_debugfs.c
index 157a573..4ef0dbd 100644
--- a/drivers/remoteproc/remoteproc_debugfs.c
+++ b/drivers/remoteproc/remoteproc_debugfs.c
@@ -156,7 +156,7 @@ rproc_recovery_write(struct file *filp, const char __user *user_buf,
 	char buf[10];
 	int ret;
 
-	if (count > sizeof(buf))
+	if (count < 1 || count > sizeof(buf))
 		return count;
 
 	ret = copy_from_user(buf, user_buf, count);
diff --git a/drivers/rtc/rtc-ambarella.c b/drivers/rtc/rtc-ambarella.c
index d42a2cf..c8203ae 100644
--- a/drivers/rtc/rtc-ambarella.c
+++ b/drivers/rtc/rtc-ambarella.c
@@ -51,6 +51,7 @@ struct ambarella_rtc {
 	 * 1. cannot detect power lost
 	 * 2. the msb 2bits are reserved. */
 	bool			is_limited;
+	int			irq;
 };
 
 
@@ -102,7 +103,7 @@ static int ambrtc_set_alarm_or_time(struct ambarella_rtc *ambrtc,
 		alarm_val = secs;
 		time_val = amba_readl(ambrtc->reg + RTC_CURT_OFFSET);
                 // only for wakeup ambarella internal PWC
-                amba_writel(ambrtc->reg + RTC_PWC_SET_STATUS_OFFSET, 0x8);
+                amba_writel(ambrtc->reg + RTC_PWC_SET_STATUS_OFFSET, 0x28);
 	}
 
 	if (ambrtc->is_limited) {
@@ -183,6 +184,21 @@ static int ambrtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
 	return ambrtc_set_alarm_or_time(ambrtc, AMBRTC_ALARM, alarm_sec);
 }
 
+static int ambrtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
+{
+	return 0;
+}
+
+static irqreturn_t ambrtc_alarm_irq(int irq, void *dev_id)
+{
+	struct ambarella_rtc *ambrtc = (struct ambarella_rtc *)dev_id;
+
+	if(ambrtc->rtc)
+		rtc_update_irq(ambrtc->rtc, 1, RTC_IRQF | RTC_AF);
+
+	return IRQ_HANDLED;
+}
+
 static int ambrtc_ioctl(struct device *dev, unsigned int cmd,
 			     unsigned long arg)
 {
@@ -213,6 +229,7 @@ static const struct rtc_class_ops ambarella_rtc_ops = {
 	.set_mmss	= ambrtc_set_mmss,
 	.read_alarm	= ambrtc_read_alarm,
 	.set_alarm	= ambrtc_set_alarm,
+	.alarm_irq_enable = ambrtc_alarm_irq_enable,
 };
 
 static void ambrtc_check_power_lost(struct ambarella_rtc *ambrtc)
@@ -242,7 +259,9 @@ static int ambrtc_probe(struct platform_device *pdev)
 	struct ambarella_rtc *ambrtc;
 	struct resource *mem;
 	void __iomem *reg;
-        struct device_node *np = pdev->dev.of_node;
+	int ret;
+	unsigned int wakeup_support;
+	struct device_node *np = pdev->dev.of_node;
 
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (mem == NULL) {
@@ -262,16 +281,28 @@ static int ambrtc_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
-	platform_set_drvdata(pdev, ambrtc);
+	ambrtc->irq = platform_get_irq(pdev, 0);
+	if (ambrtc->irq < 0) {
+		ambrtc->irq = -1;
+	} else {
+		ret = devm_request_irq(&pdev->dev, ambrtc->irq, ambrtc_alarm_irq, IRQF_SHARED,
+					"rtc alarm", ambrtc);
+		if (ret) {
+			dev_err(&pdev->dev, "could not request irq %d for rtc alarm\n", ambrtc->irq);
+			return ret;
+		}
+	}
 
 	ambrtc->reg = reg;
 	ambrtc->dev = &pdev->dev;
 	ambrtc->is_limited = !!of_find_property(pdev->dev.of_node,
 				"amb,is-limited", NULL);
-
+	platform_set_drvdata(pdev, ambrtc);
 	ambrtc_check_power_lost(ambrtc);
 
-        pdev->dev.power.can_wakeup = !!of_get_property(np, "rtc,wakeup", NULL);
+	wakeup_support = !!of_get_property(np, "rtc,wakeup", NULL);
+	if (wakeup_support)
+		device_set_wakeup_capable(&pdev->dev, 1);
 
 	ambrtc->rtc = devm_rtc_device_register(&pdev->dev, "rtc-ambarella",
 				     &ambarella_rtc_ops, THIS_MODULE);
@@ -298,6 +329,33 @@ static const struct of_device_id ambarella_rtc_dt_ids[] = {
 };
 MODULE_DEVICE_TABLE(of, ambarella_rtc_dt_ids);
 
+#ifdef CONFIG_PM_SLEEP
+static int ambarella_rtc_suspend(struct device *dev)
+{
+	struct ambarella_rtc *ambrtc = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev)){
+		if (ambrtc->irq != -1)
+			enable_irq_wake(ambrtc->irq);
+	}
+
+	return 0;
+}
+
+static int ambarella_rtc_resume(struct device *dev)
+{
+	struct ambarella_rtc *ambrtc = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev)) {
+		if (ambrtc->irq != -1)
+			disable_irq_wake(ambrtc->irq);
+	}
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(ambarella_rtc_pm_ops, ambarella_rtc_suspend, ambarella_rtc_resume);
+
 static struct platform_driver ambarella_rtc_driver = {
 	.probe		= ambrtc_probe,
 	.remove		= ambrtc_remove,
@@ -305,6 +363,7 @@ static struct platform_driver ambarella_rtc_driver = {
 		.name	= "ambarella-rtc",
 		.owner	= THIS_MODULE,
 		.of_match_table = ambarella_rtc_dt_ids,
+		.pm	= &ambarella_rtc_pm_ops,
 	},
 };
 
diff --git a/drivers/rtc/rtc-vr41xx.c b/drivers/rtc/rtc-vr41xx.c
index f91be04..ca0f213 100644
--- a/drivers/rtc/rtc-vr41xx.c
+++ b/drivers/rtc/rtc-vr41xx.c
@@ -272,12 +272,13 @@ static irqreturn_t rtclong1_interrupt(int irq, void *dev_id)
 }
 
 static const struct rtc_class_ops vr41xx_rtc_ops = {
-	.release	= vr41xx_rtc_release,
-	.ioctl		= vr41xx_rtc_ioctl,
-	.read_time	= vr41xx_rtc_read_time,
-	.set_time	= vr41xx_rtc_set_time,
-	.read_alarm	= vr41xx_rtc_read_alarm,
-	.set_alarm	= vr41xx_rtc_set_alarm,
+	.release		= vr41xx_rtc_release,
+	.ioctl			= vr41xx_rtc_ioctl,
+	.read_time		= vr41xx_rtc_read_time,
+	.set_time		= vr41xx_rtc_set_time,
+	.read_alarm		= vr41xx_rtc_read_alarm,
+	.set_alarm		= vr41xx_rtc_set_alarm,
+	.alarm_irq_enable	= vr41xx_rtc_alarm_irq_enable,
 };
 
 static int rtc_probe(struct platform_device *pdev)
diff --git a/drivers/s390/block/dasd_alias.c b/drivers/s390/block/dasd_alias.c
index a2597e6..6a64e86 100644
--- a/drivers/s390/block/dasd_alias.c
+++ b/drivers/s390/block/dasd_alias.c
@@ -264,8 +264,10 @@ void dasd_alias_disconnect_device_from_lcu(struct dasd_device *device)
 		spin_unlock_irqrestore(&lcu->lock, flags);
 		cancel_work_sync(&lcu->suc_data.worker);
 		spin_lock_irqsave(&lcu->lock, flags);
-		if (device == lcu->suc_data.device)
+		if (device == lcu->suc_data.device) {
+			dasd_put_device(device);
 			lcu->suc_data.device = NULL;
+		}
 	}
 	was_pending = 0;
 	if (device == lcu->ruac_data.device) {
@@ -273,8 +275,10 @@ void dasd_alias_disconnect_device_from_lcu(struct dasd_device *device)
 		was_pending = 1;
 		cancel_delayed_work_sync(&lcu->ruac_data.dwork);
 		spin_lock_irqsave(&lcu->lock, flags);
-		if (device == lcu->ruac_data.device)
+		if (device == lcu->ruac_data.device) {
+			dasd_put_device(device);
 			lcu->ruac_data.device = NULL;
+		}
 	}
 	private->lcu = NULL;
 	spin_unlock_irqrestore(&lcu->lock, flags);
@@ -549,8 +553,10 @@ static void lcu_update_work(struct work_struct *work)
 	if ((rc && (rc != -EOPNOTSUPP)) || (lcu->flags & NEED_UAC_UPDATE)) {
 		DBF_DEV_EVENT(DBF_WARNING, device, "could not update"
 			    " alias data in lcu (rc = %d), retry later", rc);
-		schedule_delayed_work(&lcu->ruac_data.dwork, 30*HZ);
+		if (!schedule_delayed_work(&lcu->ruac_data.dwork, 30*HZ))
+			dasd_put_device(device);
 	} else {
+		dasd_put_device(device);
 		lcu->ruac_data.device = NULL;
 		lcu->flags &= ~UPDATE_PENDING;
 	}
@@ -593,8 +599,10 @@ static int _schedule_lcu_update(struct alias_lcu *lcu,
 	 */
 	if (!usedev)
 		return -EINVAL;
+	dasd_get_device(usedev);
 	lcu->ruac_data.device = usedev;
-	schedule_delayed_work(&lcu->ruac_data.dwork, 0);
+	if (!schedule_delayed_work(&lcu->ruac_data.dwork, 0))
+		dasd_put_device(usedev);
 	return 0;
 }
 
@@ -722,7 +730,7 @@ static int reset_summary_unit_check(struct alias_lcu *lcu,
 	ASCEBC((char *) &cqr->magic, 4);
 	ccw = cqr->cpaddr;
 	ccw->cmd_code = DASD_ECKD_CCW_RSCK;
-	ccw->flags = 0 ;
+	ccw->flags = CCW_FLAG_SLI;
 	ccw->count = 16;
 	ccw->cda = (__u32)(addr_t) cqr->data;
 	((char *)cqr->data)[0] = reason;
@@ -926,6 +934,7 @@ static void summary_unit_check_handling_work(struct work_struct *work)
 	/* 3. read new alias configuration */
 	_schedule_lcu_update(lcu, device);
 	lcu->suc_data.device = NULL;
+	dasd_put_device(device);
 	spin_unlock_irqrestore(&lcu->lock, flags);
 }
 
@@ -985,6 +994,8 @@ void dasd_alias_handle_summary_unit_check(struct dasd_device *device,
 	}
 	lcu->suc_data.reason = reason;
 	lcu->suc_data.device = device;
+	dasd_get_device(device);
 	spin_unlock(&lcu->lock);
-	schedule_work(&lcu->suc_data.worker);
+	if (!schedule_work(&lcu->suc_data.worker))
+		dasd_put_device(device);
 };
diff --git a/drivers/s390/net/qeth_l2_main.c b/drivers/s390/net/qeth_l2_main.c
index ec8ccda..0090de4 100644
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -898,6 +898,7 @@ static void qeth_l2_remove_device(struct ccwgroup_device *cgdev)
 		qeth_l2_set_offline(cgdev);
 
 	if (card->dev) {
+		netif_napi_del(&card->napi);
 		unregister_netdev(card->dev);
 		card->dev = NULL;
 	}
diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c
index c1b0b27..7366bef 100644
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -3333,6 +3333,7 @@ static void qeth_l3_remove_device(struct ccwgroup_device *cgdev)
 		qeth_l3_set_offline(cgdev);
 
 	if (card->dev) {
+		netif_napi_del(&card->napi);
 		unregister_netdev(card->dev);
 		card->dev = NULL;
 	}
diff --git a/drivers/scsi/3w-9xxx.c b/drivers/scsi/3w-9xxx.c
index 0a73253..6adf9ab 100644
--- a/drivers/scsi/3w-9xxx.c
+++ b/drivers/scsi/3w-9xxx.c
@@ -149,7 +149,6 @@ static int twa_reset_sequence(TW_Device_Extension *tw_dev, int soft_reset);
 static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry *sglistarg);
 static void twa_scsiop_execute_scsi_complete(TW_Device_Extension *tw_dev, int request_id);
 static char *twa_string_lookup(twa_message_type *table, unsigned int aen_code);
-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id);
 
 /* Functions */
 
@@ -226,6 +225,17 @@ static const struct file_operations twa_fops = {
 	.llseek		= noop_llseek,
 };
 
+/*
+ * The controllers use an inline buffer instead of a mapped SGL for small,
+ * single entry buffers.  Note that we treat a zero-length transfer like
+ * a mapped SGL.
+ */
+static bool twa_command_mapped(struct scsi_cmnd *cmd)
+{
+	return scsi_sg_count(cmd) != 1 ||
+		scsi_bufflen(cmd) >= TW_MIN_SGL_LENGTH;
+}
+
 /* This function will complete an aen request from the isr */
 static int twa_aen_complete(TW_Device_Extension *tw_dev, int request_id)
 {
@@ -1352,11 +1362,12 @@ static irqreturn_t twa_interrupt(int irq, void *dev_instance)
 				}
 
 				/* Now complete the io */
+				if (twa_command_mapped(cmd))
+					scsi_dma_unmap(cmd);
+				cmd->scsi_done(cmd);
 				tw_dev->state[request_id] = TW_S_COMPLETED;
 				twa_free_request_id(tw_dev, request_id);
 				tw_dev->posted_request_count--;
-				tw_dev->srb[request_id]->scsi_done(tw_dev->srb[request_id]);
-				twa_unmap_scsi_data(tw_dev, request_id);
 			}
 
 			/* Check for valid status after each drain */
@@ -1414,26 +1425,6 @@ static void twa_load_sgl(TW_Device_Extension *tw_dev, TW_Command_Full *full_comm
 	}
 } /* End twa_load_sgl() */
 
-/* This function will perform a pci-dma mapping for a scatter gather list */
-static int twa_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)
-{
-	int use_sg;
-	struct scsi_cmnd *cmd = tw_dev->srb[request_id];
-
-	use_sg = scsi_dma_map(cmd);
-	if (!use_sg)
-		return 0;
-	else if (use_sg < 0) {
-		TW_PRINTK(tw_dev->host, TW_DRIVER, 0x1c, "Failed to map scatter gather list");
-		return 0;
-	}
-
-	cmd->SCp.phase = TW_PHASE_SGLIST;
-	cmd->SCp.have_data_in = use_sg;
-
-	return use_sg;
-} /* End twa_map_scsi_sg_data() */
-
 /* This function will poll for a response interrupt of a request */
 static int twa_poll_response(TW_Device_Extension *tw_dev, int request_id, int seconds)
 {
@@ -1612,9 +1603,12 @@ static int twa_reset_device_extension(TW_Device_Extension *tw_dev)
 		    (tw_dev->state[i] != TW_S_INITIAL) &&
 		    (tw_dev->state[i] != TW_S_COMPLETED)) {
 			if (tw_dev->srb[i]) {
-				tw_dev->srb[i]->result = (DID_RESET << 16);
-				tw_dev->srb[i]->scsi_done(tw_dev->srb[i]);
-				twa_unmap_scsi_data(tw_dev, i);
+				struct scsi_cmnd *cmd = tw_dev->srb[i];
+
+				cmd->result = (DID_RESET << 16);
+				if (twa_command_mapped(cmd))
+					scsi_dma_unmap(cmd);
+				cmd->scsi_done(cmd);
 			}
 		}
 	}
@@ -1793,21 +1787,20 @@ static int twa_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_
 	/* Save the scsi command for use by the ISR */
 	tw_dev->srb[request_id] = SCpnt;
 
-	/* Initialize phase to zero */
-	SCpnt->SCp.phase = TW_PHASE_INITIAL;
-
 	retval = twa_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	switch (retval) {
 	case SCSI_MLQUEUE_HOST_BUSY:
+		if (twa_command_mapped(SCpnt))
+			scsi_dma_unmap(SCpnt);
 		twa_free_request_id(tw_dev, request_id);
-		twa_unmap_scsi_data(tw_dev, request_id);
 		break;
 	case 1:
-		tw_dev->state[request_id] = TW_S_COMPLETED;
-		twa_free_request_id(tw_dev, request_id);
-		twa_unmap_scsi_data(tw_dev, request_id);
 		SCpnt->result = (DID_ERROR << 16);
+		if (twa_command_mapped(SCpnt))
+			scsi_dma_unmap(SCpnt);
 		done(SCpnt);
+		tw_dev->state[request_id] = TW_S_COMPLETED;
+		twa_free_request_id(tw_dev, request_id);
 		retval = 0;
 	}
 out:
@@ -1865,8 +1858,7 @@ static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,
 		/* Map sglist from scsi layer to cmd packet */
 
 		if (scsi_sg_count(srb)) {
-			if ((scsi_sg_count(srb) == 1) &&
-			    (scsi_bufflen(srb) < TW_MIN_SGL_LENGTH)) {
+			if (!twa_command_mapped(srb)) {
 				if (srb->sc_data_direction == DMA_TO_DEVICE ||
 				    srb->sc_data_direction == DMA_BIDIRECTIONAL)
 					scsi_sg_copy_to_buffer(srb,
@@ -1875,8 +1867,8 @@ static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,
 				command_packet->sg_list[0].address = TW_CPU_TO_SGL(tw_dev->generic_buffer_phys[request_id]);
 				command_packet->sg_list[0].length = cpu_to_le32(TW_MIN_SGL_LENGTH);
 			} else {
-				sg_count = twa_map_scsi_sg_data(tw_dev, request_id);
-				if (sg_count == 0)
+				sg_count = scsi_dma_map(srb);
+				if (sg_count < 0)
 					goto out;
 
 				scsi_for_each_sg(srb, sg, sg_count, i) {
@@ -1939,7 +1931,7 @@ static void twa_scsiop_execute_scsi_complete(TW_Device_Extension *tw_dev, int re
 {
 	struct scsi_cmnd *cmd = tw_dev->srb[request_id];
 
-	if (scsi_bufflen(cmd) < TW_MIN_SGL_LENGTH &&
+	if (!twa_command_mapped(cmd) &&
 	    (cmd->sc_data_direction == DMA_FROM_DEVICE ||
 	     cmd->sc_data_direction == DMA_BIDIRECTIONAL)) {
 		if (scsi_sg_count(cmd) == 1) {
@@ -1991,15 +1983,6 @@ static char *twa_string_lookup(twa_message_type *table, unsigned int code)
 	return(table[index].text);
 } /* End twa_string_lookup() */
 
-/* This function will perform a pci-dma unmap */
-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)
-{
-	struct scsi_cmnd *cmd = tw_dev->srb[request_id];
-
-	if (cmd->SCp.phase == TW_PHASE_SGLIST)
-		scsi_dma_unmap(cmd);
-} /* End twa_unmap_scsi_data() */
-
 /* This function gets called when a disk is coming on-line */
 static int twa_slave_configure(struct scsi_device *sdev)
 {
diff --git a/drivers/scsi/3w-9xxx.h b/drivers/scsi/3w-9xxx.h
index 040f721..0fdc83c 100644
--- a/drivers/scsi/3w-9xxx.h
+++ b/drivers/scsi/3w-9xxx.h
@@ -324,11 +324,6 @@ static twa_message_type twa_error_table[] = {
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
-/* Phase defines */
-#define TW_PHASE_INITIAL 0
-#define TW_PHASE_SINGLE  1
-#define TW_PHASE_SGLIST  2
-
 /* Misc defines */
 #define TW_9550SX_DRAIN_COMPLETED	      0xFFFF
 #define TW_SECTOR_SIZE                        512
diff --git a/drivers/scsi/3w-sas.c b/drivers/scsi/3w-sas.c
index 4de3460..61702ac 100644
--- a/drivers/scsi/3w-sas.c
+++ b/drivers/scsi/3w-sas.c
@@ -303,26 +303,6 @@ static int twl_post_command_packet(TW_Device_Extension *tw_dev, int request_id)
 	return 0;
 } /* End twl_post_command_packet() */
 
-/* This function will perform a pci-dma mapping for a scatter gather list */
-static int twl_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)
-{
-	int use_sg;
-	struct scsi_cmnd *cmd = tw_dev->srb[request_id];
-
-	use_sg = scsi_dma_map(cmd);
-	if (!use_sg)
-		return 0;
-	else if (use_sg < 0) {
-		TW_PRINTK(tw_dev->host, TW_DRIVER, 0x1, "Failed to map scatter gather list");
-		return 0;
-	}
-
-	cmd->SCp.phase = TW_PHASE_SGLIST;
-	cmd->SCp.have_data_in = use_sg;
-
-	return use_sg;
-} /* End twl_map_scsi_sg_data() */
-
 /* This function hands scsi cdb's to the firmware */
 static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry_ISO *sglistarg)
 {
@@ -370,8 +350,8 @@ static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,
 	if (!sglistarg) {
 		/* Map sglist from scsi layer to cmd packet */
 		if (scsi_sg_count(srb)) {
-			sg_count = twl_map_scsi_sg_data(tw_dev, request_id);
-			if (sg_count == 0)
+			sg_count = scsi_dma_map(srb);
+			if (sg_count <= 0)
 				goto out;
 
 			scsi_for_each_sg(srb, sg, sg_count, i) {
@@ -1116,15 +1096,6 @@ out:
 	return retval;
 } /* End twl_initialize_device_extension() */
 
-/* This function will perform a pci-dma unmap */
-static void twl_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)
-{
-	struct scsi_cmnd *cmd = tw_dev->srb[request_id];
-
-	if (cmd->SCp.phase == TW_PHASE_SGLIST)
-		scsi_dma_unmap(cmd);
-} /* End twl_unmap_scsi_data() */
-
 /* This function will handle attention interrupts */
 static int twl_handle_attention_interrupt(TW_Device_Extension *tw_dev)
 {
@@ -1265,11 +1236,11 @@ static irqreturn_t twl_interrupt(int irq, void *dev_instance)
 			}
 
 			/* Now complete the io */
+			scsi_dma_unmap(cmd);
+			cmd->scsi_done(cmd);
 			tw_dev->state[request_id] = TW_S_COMPLETED;
 			twl_free_request_id(tw_dev, request_id);
 			tw_dev->posted_request_count--;
-			tw_dev->srb[request_id]->scsi_done(tw_dev->srb[request_id]);
-			twl_unmap_scsi_data(tw_dev, request_id);
 		}
 
 		/* Check for another response interrupt */
@@ -1414,10 +1385,12 @@ static int twl_reset_device_extension(TW_Device_Extension *tw_dev, int ioctl_res
 		if ((tw_dev->state[i] != TW_S_FINISHED) &&
 		    (tw_dev->state[i] != TW_S_INITIAL) &&
 		    (tw_dev->state[i] != TW_S_COMPLETED)) {
-			if (tw_dev->srb[i]) {
-				tw_dev->srb[i]->result = (DID_RESET << 16);
-				tw_dev->srb[i]->scsi_done(tw_dev->srb[i]);
-				twl_unmap_scsi_data(tw_dev, i);
+			struct scsi_cmnd *cmd = tw_dev->srb[i];
+
+			if (cmd) {
+				cmd->result = (DID_RESET << 16);
+				scsi_dma_unmap(cmd);
+				cmd->scsi_done(cmd);
 			}
 		}
 	}
@@ -1521,9 +1494,6 @@ static int twl_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_
 	/* Save the scsi command for use by the ISR */
 	tw_dev->srb[request_id] = SCpnt;
 
-	/* Initialize phase to zero */
-	SCpnt->SCp.phase = TW_PHASE_INITIAL;
-
 	retval = twl_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	if (retval) {
 		tw_dev->state[request_id] = TW_S_COMPLETED;
diff --git a/drivers/scsi/3w-sas.h b/drivers/scsi/3w-sas.h
index d474892..fec6449 100644
--- a/drivers/scsi/3w-sas.h
+++ b/drivers/scsi/3w-sas.h
@@ -103,10 +103,6 @@ static char *twl_aen_severity_table[] =
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
-/* Phase defines */
-#define TW_PHASE_INITIAL 0
-#define TW_PHASE_SGLIST  2
-
 /* Misc defines */
 #define TW_SECTOR_SIZE                        512
 #define TW_MAX_UNITS			      32
diff --git a/drivers/scsi/3w-xxxx.c b/drivers/scsi/3w-xxxx.c
index 430ee37..8843ad7 100644
--- a/drivers/scsi/3w-xxxx.c
+++ b/drivers/scsi/3w-xxxx.c
@@ -1283,32 +1283,6 @@ static int tw_initialize_device_extension(TW_Device_Extension *tw_dev)
 	return 0;
 } /* End tw_initialize_device_extension() */
 
-static int tw_map_scsi_sg_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)
-{
-	int use_sg;
-
-	dprintk(KERN_WARNING "3w-xxxx: tw_map_scsi_sg_data()\n");
-
-	use_sg = scsi_dma_map(cmd);
-	if (use_sg < 0) {
-		printk(KERN_WARNING "3w-xxxx: tw_map_scsi_sg_data(): pci_map_sg() failed.\n");
-		return 0;
-	}
-
-	cmd->SCp.phase = TW_PHASE_SGLIST;
-	cmd->SCp.have_data_in = use_sg;
-
-	return use_sg;
-} /* End tw_map_scsi_sg_data() */
-
-static void tw_unmap_scsi_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)
-{
-	dprintk(KERN_WARNING "3w-xxxx: tw_unmap_scsi_data()\n");
-
-	if (cmd->SCp.phase == TW_PHASE_SGLIST)
-		scsi_dma_unmap(cmd);
-} /* End tw_unmap_scsi_data() */
-
 /* This function will reset a device extension */
 static int tw_reset_device_extension(TW_Device_Extension *tw_dev)
 {
@@ -1331,8 +1305,8 @@ static int tw_reset_device_extension(TW_Device_Extension *tw_dev)
 			srb = tw_dev->srb[i];
 			if (srb != NULL) {
 				srb->result = (DID_RESET << 16);
-				tw_dev->srb[i]->scsi_done(tw_dev->srb[i]);
-				tw_unmap_scsi_data(tw_dev->tw_pci_dev, tw_dev->srb[i]);
+				scsi_dma_unmap(srb);
+				srb->scsi_done(srb);
 			}
 		}
 	}
@@ -1779,8 +1753,8 @@ static int tw_scsiop_read_write(TW_Device_Extension *tw_dev, int request_id)
 	command_packet->byte8.io.lba = lba;
 	command_packet->byte6.block_count = num_sectors;
 
-	use_sg = tw_map_scsi_sg_data(tw_dev->tw_pci_dev, tw_dev->srb[request_id]);
-	if (!use_sg)
+	use_sg = scsi_dma_map(srb);
+	if (use_sg <= 0)
 		return 1;
 
 	scsi_for_each_sg(tw_dev->srb[request_id], sg, use_sg, i) {
@@ -1967,9 +1941,6 @@ static int tw_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_c
 	/* Save the scsi command for use by the ISR */
 	tw_dev->srb[request_id] = SCpnt;
 
-	/* Initialize phase to zero */
-	SCpnt->SCp.phase = TW_PHASE_INITIAL;
-
 	switch (*command) {
 		case READ_10:
 		case READ_6:
@@ -2196,12 +2167,11 @@ static irqreturn_t tw_interrupt(int irq, void *dev_instance)
 
 				/* Now complete the io */
 				if ((error != TW_ISR_DONT_COMPLETE)) {
+					scsi_dma_unmap(tw_dev->srb[request_id]);
+					tw_dev->srb[request_id]->scsi_done(tw_dev->srb[request_id]);
 					tw_dev->state[request_id] = TW_S_COMPLETED;
 					tw_state_request_finish(tw_dev, request_id);
 					tw_dev->posted_request_count--;
-					tw_dev->srb[request_id]->scsi_done(tw_dev->srb[request_id]);
-					
-					tw_unmap_scsi_data(tw_dev->tw_pci_dev, tw_dev->srb[request_id]);
 				}
 			}
 				
diff --git a/drivers/scsi/3w-xxxx.h b/drivers/scsi/3w-xxxx.h
index 49dcf03..1d31858 100644
--- a/drivers/scsi/3w-xxxx.h
+++ b/drivers/scsi/3w-xxxx.h
@@ -195,11 +195,6 @@ static unsigned char tw_sense_table[][4] =
 #define TW_AEN_SMART_FAIL        0x000F
 #define TW_AEN_SBUF_FAIL         0x0024
 
-/* Phase defines */
-#define TW_PHASE_INITIAL 0
-#define TW_PHASE_SINGLE 1
-#define TW_PHASE_SGLIST 2
-
 /* Misc defines */
 #define TW_ALIGNMENT_6000		      64 /* 64 bytes */
 #define TW_ALIGNMENT_7000                     4  /* 4 bytes */
diff --git a/drivers/scsi/aacraid/commctrl.c b/drivers/scsi/aacraid/commctrl.c
index ee6cadd..d6fcadd 100644
--- a/drivers/scsi/aacraid/commctrl.c
+++ b/drivers/scsi/aacraid/commctrl.c
@@ -63,7 +63,7 @@ static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)
 	struct fib *fibptr;
 	struct hw_fib * hw_fib = (struct hw_fib *)0;
 	dma_addr_t hw_fib_pa = (dma_addr_t)0LL;
-	unsigned size;
+	unsigned int size, osize;
 	int retval;
 
 	if (dev->in_reset) {
@@ -87,7 +87,8 @@ static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)
 	 *	will not overrun the buffer when we copy the memory. Return
 	 *	an error if we would.
 	 */
-	size = le16_to_cpu(kfib->header.Size) + sizeof(struct aac_fibhdr);
+	osize = size = le16_to_cpu(kfib->header.Size) +
+		sizeof(struct aac_fibhdr);
 	if (size < le16_to_cpu(kfib->header.SenderSize))
 		size = le16_to_cpu(kfib->header.SenderSize);
 	if (size > dev->max_fib_size) {
@@ -118,6 +119,14 @@ static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)
 		goto cleanup;
 	}
 
+	/* Sanity check the second copy */
+	if ((osize != le16_to_cpu(kfib->header.Size) +
+		sizeof(struct aac_fibhdr))
+		|| (size < le16_to_cpu(kfib->header.SenderSize))) {
+		retval = -EINVAL;
+		goto cleanup;
+	}
+
 	if (kfib->header.Command == cpu_to_le16(TakeABreakPt)) {
 		aac_adapter_interrupt(dev);
 		/*
diff --git a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c
index 1be0776..284efac 100644
--- a/drivers/scsi/aacraid/commsup.c
+++ b/drivers/scsi/aacraid/commsup.c
@@ -83,9 +83,12 @@ static int fib_map_alloc(struct aac_dev *dev)
 
 void aac_fib_map_free(struct aac_dev *dev)
 {
-	pci_free_consistent(dev->pdev,
-	  dev->max_fib_size * (dev->scsi_host_ptr->can_queue + AAC_NUM_MGT_FIB),
-	  dev->hw_fib_va, dev->hw_fib_pa);
+	if (dev->hw_fib_va && dev->max_fib_size) {
+		pci_free_consistent(dev->pdev,
+		(dev->max_fib_size *
+		(dev->scsi_host_ptr->can_queue + AAC_NUM_MGT_FIB)),
+		dev->hw_fib_va, dev->hw_fib_pa);
+	}
 	dev->hw_fib_va = NULL;
 	dev->hw_fib_pa = 0;
 }
@@ -587,10 +590,10 @@ int aac_fib_send(u16 command, struct fib *fibptr, unsigned long size,
 					}
 					return -EFAULT;
 				}
-				/* We used to udelay() here but that absorbed
-				 * a CPU when a timeout occured. Not very
-				 * useful. */
-				cpu_relax();
+				/*
+				 * Allow other processes / CPUS to use core
+				 */
+				schedule();
 			}
 		} else if (down_interruptible(&fibptr->event_wait)) {
 			/* Do nothing ... satisfy
@@ -1917,6 +1920,10 @@ int aac_command_thread(void *data)
 		if (difference <= 0)
 			difference = 1;
 		set_current_state(TASK_INTERRUPTIBLE);
+
+		if (kthread_should_stop())
+			break;
+
 		schedule_timeout(difference);
 
 		if (kthread_should_stop())
diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index 1ad39c7..0227813 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -2978,7 +2978,7 @@ be_sgl_create_contiguous(void *virtual_address,
 {
 	WARN_ON(!virtual_address);
 	WARN_ON(!physical_address);
-	WARN_ON(!length > 0);
+	WARN_ON(!length);
 	WARN_ON(!sgl);
 
 	sgl->va = virtual_address;
@@ -4040,6 +4040,7 @@ put_shost:
 	scsi_host_put(phba->shost);
 free_kset:
 	iscsi_boot_destroy_kset(phba->boot_kset);
+	phba->boot_kset = NULL;
 	return -ENOMEM;
 }
 
@@ -5080,9 +5081,9 @@ free_port:
 hba_free:
 	if (phba->msix_enabled)
 		pci_disable_msix(phba->pcidev);
-	iscsi_host_remove(phba->shost);
 	pci_dev_put(phba->pcidev);
 	iscsi_host_free(phba->shost);
+	pci_set_drvdata(pcidev, NULL);
 disable_pci:
 	pci_disable_device(pcidev);
 	return ret;
diff --git a/drivers/scsi/device_handler/scsi_dh_rdac.c b/drivers/scsi/device_handler/scsi_dh_rdac.c
index 69c915a..d661fcd 100644
--- a/drivers/scsi/device_handler/scsi_dh_rdac.c
+++ b/drivers/scsi/device_handler/scsi_dh_rdac.c
@@ -569,7 +569,7 @@ static int mode_select_handle_sense(struct scsi_device *sdev,
 			/*
 			 * Command Lock contention
 			 */
-			err = SCSI_DH_RETRY;
+			err = SCSI_DH_IMM_RETRY;
 		break;
 	default:
 		break;
@@ -619,6 +619,8 @@ retry:
 		err = mode_select_handle_sense(sdev, h->sense);
 		if (err == SCSI_DH_RETRY && retry_cnt--)
 			goto retry;
+		if (err == SCSI_DH_IMM_RETRY)
+			goto retry;
 	}
 	if (err == SCSI_DH_OK) {
 		h->state = RDAC_STATE_ACTIVE;
diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 3cafe0d..3020f1f 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -305,6 +305,17 @@ static void scsi_host_dev_release(struct device *dev)
 		kfree(queuedata);
 	}
 
+	if (shost->shost_state == SHOST_CREATED) {
+		/*
+		 * Free the shost_dev device name here if scsi_host_alloc()
+		 * and scsi_host_put() have been called but neither
+		 * scsi_host_add() nor scsi_host_remove() has been called.
+		 * This avoids that the memory allocated for the shost_dev
+		 * name is leaked.
+		 */
+		kfree(dev_name(&shost->shost_dev));
+	}
+
 	scsi_destroy_command_freelist(shost);
 	if (shost->bqt)
 		blk_free_tags(shost->bqt);
diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c
index 62ed744..a6cdf17 100644
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@ -3898,10 +3898,6 @@ static int hpsa_kdump_hard_reset_controller(struct pci_dev *pdev)
 
 	/* Save the PCI command register */
 	pci_read_config_word(pdev, 4, &command_register);
-	/* Turn the board off.  This is so that later pci_restore_state()
-	 * won't turn the board on before the rest of config space is ready.
-	 */
-	pci_disable_device(pdev);
 	pci_save_state(pdev);
 
 	/* find the first memory BAR, so we can find the cfg table */
@@ -3949,11 +3945,6 @@ static int hpsa_kdump_hard_reset_controller(struct pci_dev *pdev)
 		goto unmap_cfgtable;
 
 	pci_restore_state(pdev);
-	rc = pci_enable_device(pdev);
-	if (rc) {
-		dev_warn(&pdev->dev, "failed to enable device.\n");
-		goto unmap_cfgtable;
-	}
 	pci_write_config_word(pdev, 4, command_register);
 
 	/* Some devices (notably the HP Smart Array 5i Controller)
@@ -4448,6 +4439,23 @@ static int hpsa_init_reset_devices(struct pci_dev *pdev)
 	if (!reset_devices)
 		return 0;
 
+	/* kdump kernel is loading, we don't know in which state is
+	 * the pci interface. The dev->enable_cnt is equal zero
+	 * so we call enable+disable, wait a while and switch it on.
+	 */
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		dev_warn(&pdev->dev, "Failed to enable PCI device\n");
+		return -ENODEV;
+	}
+	pci_disable_device(pdev);
+	msleep(260);			/* a randomly chosen number */
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		dev_warn(&pdev->dev, "failed to enable device.\n");
+		return -ENODEV;
+	}
+	pci_set_master(pdev);
 	/* Reset the controller with a PCI power-cycle or via doorbell */
 	rc = hpsa_kdump_hard_reset_controller(pdev);
 
@@ -4456,10 +4464,11 @@ static int hpsa_init_reset_devices(struct pci_dev *pdev)
 	 * "performant mode".  Or, it might be 640x, which can't reset
 	 * due to concerns about shared bbwc between 6402/6404 pair.
 	 */
-	if (rc == -ENOTSUPP)
-		return rc; /* just try to do the kdump anyhow. */
-	if (rc)
-		return -ENODEV;
+	if (rc) {
+		if (rc != -ENOTSUPP) /* just try to do the kdump anyhow. */
+			rc = -ENODEV;
+		goto out_disable;
+	}
 
 	/* Now try to get the controller to respond to a no-op */
 	dev_warn(&pdev->dev, "Waiting for controller to respond to no-op\n");
@@ -4470,7 +4479,11 @@ static int hpsa_init_reset_devices(struct pci_dev *pdev)
 			dev_warn(&pdev->dev, "no-op failed%s\n",
 					(i < 11 ? "; re-trying" : ""));
 	}
-	return 0;
+
+out_disable:
+
+	pci_disable_device(pdev);
+	return rc;
 }
 
 static int hpsa_allocate_cmd_pool(struct ctlr_info *h)
@@ -4613,6 +4626,7 @@ static void hpsa_undo_allocations_after_kdump_soft_reset(struct ctlr_info *h)
 		iounmap(h->transtable);
 	if (h->cfgtable)
 		iounmap(h->cfgtable);
+	pci_disable_device(h->pdev);
 	pci_release_regions(h->pdev);
 	kfree(h);
 }
diff --git a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c
index f7732f3..2891faa 100644
--- a/drivers/scsi/ipr.c
+++ b/drivers/scsi/ipr.c
@@ -554,9 +554,10 @@ static void ipr_trc_hook(struct ipr_cmnd *ipr_cmd,
 {
 	struct ipr_trace_entry *trace_entry;
 	struct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;
+	unsigned int trace_index;
 
-	trace_entry = &ioa_cfg->trace[atomic_add_return
-			(1, &ioa_cfg->trace_index)%IPR_NUM_TRACE_ENTRIES];
+	trace_index = atomic_add_return(1, &ioa_cfg->trace_index) & IPR_TRACE_INDEX_MASK;
+	trace_entry = &ioa_cfg->trace[trace_index];
 	trace_entry->time = jiffies;
 	trace_entry->op_code = ipr_cmd->ioarcb.cmd_pkt.cdb[0];
 	trace_entry->type = type;
@@ -1006,10 +1007,15 @@ static void ipr_send_blocking_cmd(struct ipr_cmnd *ipr_cmd,
 
 static int ipr_get_hrrq_index(struct ipr_ioa_cfg *ioa_cfg)
 {
+	unsigned int hrrq;
+
 	if (ioa_cfg->hrrq_num == 1)
-		return 0;
-	else
-		return (atomic_add_return(1, &ioa_cfg->hrrq_index) % (ioa_cfg->hrrq_num - 1)) + 1;
+		hrrq = 0;
+	else {
+		hrrq = atomic_add_return(1, &ioa_cfg->hrrq_index);
+		hrrq = (hrrq % (ioa_cfg->hrrq_num - 1)) + 1;
+	}
+	return hrrq;
 }
 
 /**
@@ -3902,13 +3908,17 @@ static ssize_t ipr_store_update_fw(struct device *dev,
 	struct ipr_sglist *sglist;
 	char fname[100];
 	char *src;
-	int len, result, dnld_size;
+	char *endline;
+	int result, dnld_size;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
-	len = snprintf(fname, 99, "%s", buf);
-	fname[len-1] = '\0';
+	snprintf(fname, sizeof(fname), "%s", buf);
+
+	endline = strchr(fname, '\n');
+	if (endline)
+		*endline = '\0';
 
 	if (request_firmware(&fw_entry, fname, &ioa_cfg->pdev->dev)) {
 		dev_err(&ioa_cfg->pdev->dev, "Firmware file %s not found\n", fname);
@@ -6141,21 +6151,23 @@ static void ipr_scsi_done(struct ipr_cmnd *ipr_cmd)
 	struct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;
 	struct scsi_cmnd *scsi_cmd = ipr_cmd->scsi_cmd;
 	u32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);
-	unsigned long hrrq_flags;
+	unsigned long lock_flags;
 
 	scsi_set_resid(scsi_cmd, be32_to_cpu(ipr_cmd->s.ioasa.hdr.residual_data_len));
 
 	if (likely(IPR_IOASC_SENSE_KEY(ioasc) == 0)) {
 		scsi_dma_unmap(scsi_cmd);
 
-		spin_lock_irqsave(ipr_cmd->hrrq->lock, hrrq_flags);
+		spin_lock_irqsave(ipr_cmd->hrrq->lock, lock_flags);
 		list_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);
 		scsi_cmd->scsi_done(scsi_cmd);
-		spin_unlock_irqrestore(ipr_cmd->hrrq->lock, hrrq_flags);
+		spin_unlock_irqrestore(ipr_cmd->hrrq->lock, lock_flags);
 	} else {
-		spin_lock_irqsave(ipr_cmd->hrrq->lock, hrrq_flags);
+		spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
+		spin_lock(&ipr_cmd->hrrq->_lock);
 		ipr_erp_start(ioa_cfg, ipr_cmd);
-		spin_unlock_irqrestore(ipr_cmd->hrrq->lock, hrrq_flags);
+		spin_unlock(&ipr_cmd->hrrq->_lock);
+		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 	}
 }
 
@@ -9595,6 +9607,7 @@ static int ipr_probe_ioa(struct pci_dev *pdev,
 		ioa_cfg->intr_flag = IPR_USE_MSI;
 	else {
 		ioa_cfg->intr_flag = IPR_USE_LSI;
+		ioa_cfg->clear_isr = 1;
 		ioa_cfg->nvectors = 1;
 		dev_info(&pdev->dev, "Cannot enable MSI.\n");
 	}
diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h
index 535f573..e045676 100644
--- a/drivers/scsi/ipr.h
+++ b/drivers/scsi/ipr.h
@@ -257,7 +257,7 @@
 #define IPR_RUNTIME_RESET				0x40000000
 
 #define IPR_IPL_INIT_MIN_STAGE_TIME			5
-#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 15
+#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 30
 #define IPR_IPL_INIT_STAGE_UNKNOWN			0x0
 #define IPR_IPL_INIT_STAGE_TRANSOP			0xB0000000
 #define IPR_IPL_INIT_STAGE_MASK				0xff000000
@@ -1452,6 +1452,7 @@ struct ipr_ioa_cfg {
 
 #define IPR_NUM_TRACE_INDEX_BITS	8
 #define IPR_NUM_TRACE_ENTRIES		(1 << IPR_NUM_TRACE_INDEX_BITS)
+#define IPR_TRACE_INDEX_MASK		(IPR_NUM_TRACE_ENTRIES - 1)
 #define IPR_TRACE_SIZE	(sizeof(struct ipr_trace_entry) * IPR_NUM_TRACE_ENTRIES)
 	char trace_start[8];
 #define IPR_TRACE_START_LABEL			"trace"
diff --git a/drivers/scsi/libfc/fc_fcp.c b/drivers/scsi/libfc/fc_fcp.c
index 09c81b2..42c46dc 100644
--- a/drivers/scsi/libfc/fc_fcp.c
+++ b/drivers/scsi/libfc/fc_fcp.c
@@ -1039,11 +1039,26 @@ restart:
 		fc_fcp_pkt_hold(fsp);
 		spin_unlock_irqrestore(&si->scsi_queue_lock, flags);
 
-		if (!fc_fcp_lock_pkt(fsp)) {
+		spin_lock_bh(&fsp->scsi_pkt_lock);
+		if (!(fsp->state & FC_SRB_COMPL)) {
+			fsp->state |= FC_SRB_COMPL;
+			/*
+			 * TODO: dropping scsi_pkt_lock and then reacquiring
+			 * again around fc_fcp_cleanup_cmd() is required,
+			 * since fc_fcp_cleanup_cmd() calls into
+			 * fc_seq_set_resp() and that func preempts cpu using
+			 * schedule. May be schedule and related code should be
+			 * removed instead of unlocking here to avoid scheduling
+			 * while atomic bug.
+			 */
+			spin_unlock_bh(&fsp->scsi_pkt_lock);
+
 			fc_fcp_cleanup_cmd(fsp, error);
+
+			spin_lock_bh(&fsp->scsi_pkt_lock);
 			fc_io_compl(fsp);
-			fc_fcp_unlock_pkt(fsp);
 		}
+		spin_unlock_bh(&fsp->scsi_pkt_lock);
 
 		fc_fcp_pkt_release(fsp);
 		spin_lock_irqsave(&si->scsi_queue_lock, flags);
diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c
index cb465b2..e6e0679 100644
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@ -2684,7 +2684,7 @@ lpfc_online(struct lpfc_hba *phba)
 	}
 
 	vports = lpfc_create_vport_work_array(phba);
-	if (vports != NULL)
+	if (vports != NULL) {
 		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
 			struct Scsi_Host *shost;
 			shost = lpfc_shost_from_vport(vports[i]);
@@ -2701,7 +2701,8 @@ lpfc_online(struct lpfc_hba *phba)
 			}
 			spin_unlock_irq(shost->host_lock);
 		}
-		lpfc_destroy_vport_work_array(phba, vports);
+	}
+	lpfc_destroy_vport_work_array(phba, vports);
 
 	lpfc_unblock_mgmt_io(phba);
 	return 0;
diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c
index 572579f..9086141 100644
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@ -263,6 +263,16 @@ lpfc_sli4_eq_get(struct lpfc_queue *q)
 		return NULL;
 
 	q->hba_index = idx;
+
+	/*
+	 * insert barrier for instruction interlock : data from the hardware
+	 * must have the valid bit checked before it can be copied and acted
+	 * upon. Given what was seen in lpfc_sli4_cq_get() of speculative
+	 * instructions allowing action on content before valid bit checked,
+	 * add barrier here as well. May not be needed as "content" is a
+	 * single 32-bit entity here (vs multi word structure for cq's).
+	 */
+	mb();
 	return eqe;
 }
 
@@ -368,6 +378,17 @@ lpfc_sli4_cq_get(struct lpfc_queue *q)
 
 	cqe = q->qe[q->hba_index].cqe;
 	q->hba_index = idx;
+
+	/*
+	 * insert barrier for instruction interlock : data from the hardware
+	 * must have the valid bit checked before it can be copied and acted
+	 * upon. Speculative instructions were allowing a bcopy at the start
+	 * of lpfc_sli4_fp_handle_wcqe(), which is called immediately
+	 * after our return, to copy data before the valid bit check above
+	 * was done. As such, some of the copied data was stale. The barrier
+	 * ensures the check is before any data is copied.
+	 */
+	mb();
 	return cqe;
 }
 
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index b521213..280e769 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -300,6 +300,8 @@ enum MR_EVT_ARGS {
 	MR_EVT_ARGS_GENERIC,
 };
 
+
+#define SGE_BUFFER_SIZE	4096
 /*
  * define constants for device list query options
  */
diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c
index 78b4fe8..6ced6a3 100644
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@ -3470,7 +3470,7 @@ static int megasas_init_fw(struct megasas_instance *instance)
 	/* Find first memory bar */
 	bar_list = pci_select_bars(instance->pdev, IORESOURCE_MEM);
 	instance->bar = find_first_bit(&bar_list, sizeof(unsigned long));
-	if (pci_request_selected_regions(instance->pdev, instance->bar,
+	if (pci_request_selected_regions(instance->pdev, 1<<instance->bar,
 					 "megasas: LSI")) {
 		printk(KERN_DEBUG "megasas: IO memory region busy!\n");
 		return -EBUSY;
@@ -3602,7 +3602,7 @@ static int megasas_init_fw(struct megasas_instance *instance)
 	}
 
 	instance->max_sectors_per_req = instance->max_num_sge *
-						PAGE_SIZE / 512;
+						SGE_BUFFER_SIZE / 512;
 	if (tmp_sectors && (instance->max_sectors_per_req > tmp_sectors))
 		instance->max_sectors_per_req = tmp_sectors;
 
@@ -3640,7 +3640,7 @@ fail_ready_state:
 	iounmap(instance->reg_set);
 
       fail_ioremap:
-	pci_release_selected_regions(instance->pdev, instance->bar);
+	pci_release_selected_regions(instance->pdev, 1<<instance->bar);
 
 	return -EINVAL;
 }
@@ -3661,7 +3661,7 @@ static void megasas_release_mfi(struct megasas_instance *instance)
 
 	iounmap(instance->reg_set);
 
-	pci_release_selected_regions(instance->pdev, instance->bar);
+	pci_release_selected_regions(instance->pdev, 1<<instance->bar);
 }
 
 /**
@@ -5051,6 +5051,9 @@ static int megasas_mgmt_compat_ioctl_fw(struct file *file, unsigned long arg)
 	int i;
 	int error = 0;
 	compat_uptr_t ptr;
+	unsigned long local_raw_ptr;
+	u32 local_sense_off;
+	u32 local_sense_len;
 
 	if (clear_user(ioc, sizeof(*ioc)))
 		return -EFAULT;
@@ -5068,9 +5071,15 @@ static int megasas_mgmt_compat_ioctl_fw(struct file *file, unsigned long arg)
 	 * sense_len is not null, so prepare the 64bit value under
 	 * the same condition.
 	 */
-	if (ioc->sense_len) {
+	if (get_user(local_raw_ptr, ioc->frame.raw) ||
+		get_user(local_sense_off, &ioc->sense_off) ||
+		get_user(local_sense_len, &ioc->sense_len))
+		return -EFAULT;
+
+
+	if (local_sense_len) {
 		void __user **sense_ioc_ptr =
-			(void __user **)(ioc->frame.raw + ioc->sense_off);
+			(void __user **)((u8*)local_raw_ptr + local_sense_off);
 		compat_uptr_t *sense_cioc_ptr =
 			(compat_uptr_t *)(cioc->frame.raw + cioc->sense_off);
 		if (get_user(ptr, sense_cioc_ptr) ||
diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c
index a7d5668..d478088 100644
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@ -2020,7 +2020,7 @@ megasas_release_fusion(struct megasas_instance *instance)
 
 	iounmap(instance->reg_set);
 
-	pci_release_selected_regions(instance->pdev, instance->bar);
+	pci_release_selected_regions(instance->pdev, 1<<instance->bar);
 }
 
 /**
diff --git a/drivers/scsi/mvsas/mv_sas.c b/drivers/scsi/mvsas/mv_sas.c
index c9e2449..2da1959 100644
--- a/drivers/scsi/mvsas/mv_sas.c
+++ b/drivers/scsi/mvsas/mv_sas.c
@@ -441,14 +441,11 @@ static u32 mvs_get_ncq_tag(struct sas_task *task, u32 *tag)
 static int mvs_task_prep_ata(struct mvs_info *mvi,
 			     struct mvs_task_exec_info *tei)
 {
-	struct sas_ha_struct *sha = mvi->sas;
 	struct sas_task *task = tei->task;
 	struct domain_device *dev = task->dev;
 	struct mvs_device *mvi_dev = dev->lldd_dev;
 	struct mvs_cmd_hdr *hdr = tei->hdr;
 	struct asd_sas_port *sas_port = dev->port;
-	struct sas_phy *sphy = dev->phy;
-	struct asd_sas_phy *sas_phy = sha->sas_phy[sphy->number];
 	struct mvs_slot_info *slot;
 	void *buf_prd;
 	u32 tag = tei->tag, hdr_tag;
@@ -468,7 +465,7 @@ static int mvs_task_prep_ata(struct mvs_info *mvi,
 	slot->tx = mvi->tx_prod;
 	del_q = TXQ_MODE_I | tag |
 		(TXQ_CMD_STP << TXQ_CMD_SHIFT) |
-		(MVS_PHY_ID << TXQ_PHY_SHIFT) |
+		((sas_port->phy_mask & TXQ_PHY_MASK) << TXQ_PHY_SHIFT) |
 		(mvi_dev->taskfileset << TXQ_SRS_SHIFT);
 	mvi->tx[mvi->tx_prod] = cpu_to_le32(del_q);
 
@@ -990,6 +987,8 @@ static void mvs_slot_free(struct mvs_info *mvi, u32 rx_desc)
 static void mvs_slot_task_free(struct mvs_info *mvi, struct sas_task *task,
 			  struct mvs_slot_info *slot, u32 slot_idx)
 {
+	if (!slot)
+		return;
 	if (!slot->task)
 		return;
 	if (!sas_protocol_ata(task->task_proto))
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index d2a4c75..813e9d8 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -523,8 +523,9 @@ qla2x00_async_event(scsi_qla_host_t *vha, struct rsp_que *rsp, uint16_t *mb)
 	struct device_reg_2xxx __iomem *reg = &ha->iobase->isp;
 	struct device_reg_24xx __iomem *reg24 = &ha->iobase->isp24;
 	struct device_reg_82xx __iomem *reg82 = &ha->iobase->isp82;
-	uint32_t	rscn_entry, host_pid;
+	uint32_t	rscn_entry, host_pid, tmp_pid;
 	unsigned long	flags;
+	fc_port_t	*fcport = NULL;
 
 	/* Setup to process RIO completion. */
 	handle_cnt = 0;
@@ -918,6 +919,20 @@ skip_rio:
 		if (qla2x00_is_a_vp_did(vha, rscn_entry))
 			break;
 
+		/*
+		 * Search for the rport related to this RSCN entry and mark it
+		 * as lost.
+		 */
+		list_for_each_entry(fcport, &vha->vp_fcports, list) {
+			if (atomic_read(&fcport->state) != FCS_ONLINE)
+				continue;
+			tmp_pid = fcport->d_id.b24;
+			if (fcport->d_id.b24 == rscn_entry) {
+				qla2x00_mark_device_lost(vha, fcport, 0, 0);
+				break;
+			}
+		}
+
 		atomic_set(&vha->loop_down_timer, 0);
 		vha->flags.management_server_logged_in = 0;
 
diff --git a/drivers/scsi/qla2xxx/tcm_qla2xxx.c b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
index cfd49ec..c817160 100644
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@ -1465,7 +1465,7 @@ static int tcm_qla2xxx_check_initiator_node_acl(
 	/*
 	 * Finally register the new FC Nexus with TCM
 	 */
-	__transport_register_session(se_nacl->se_tpg, se_nacl, se_sess, sess);
+	transport_register_session(se_nacl->se_tpg, se_nacl, se_sess, sess);
 
 	return 0;
 }
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index 3668b1b..5ba69ea 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -898,7 +898,6 @@ static int scsi_request_sense(struct scsi_cmnd *scmd)
  */
 void scsi_eh_finish_cmd(struct scsi_cmnd *scmd, struct list_head *done_q)
 {
-	scmd->device->host->host_failed--;
 	scmd->eh_eflags = 0;
 	list_move_tail(&scmd->eh_entry, done_q);
 }
@@ -1849,8 +1848,17 @@ int scsi_error_handler(void *data)
 	 * We never actually get interrupted because kthread_run
 	 * disables signal delivery for the created thread.
 	 */
-	while (!kthread_should_stop()) {
+	while (true) {
+		/*
+		 * The sequence in kthread_stop() sets the stop flag first
+		 * then wakes the process.  To avoid missed wakeups, the task
+		 * should always be in a non running state before the stop
+		 * flag is checked
+		 */
 		set_current_state(TASK_INTERRUPTIBLE);
+		if (kthread_should_stop())
+			break;
+
 		if ((shost->host_failed == 0 && shost->host_eh_scheduled == 0) ||
 		    shost->host_failed != shost->host_busy) {
 			SCSI_LOG_ERROR_RECOVERY(1,
@@ -1883,6 +1891,9 @@ int scsi_error_handler(void *data)
 		else
 			scsi_unjam_host(shost);
 
+		/* All scmds have been handled */
+		shost->host_failed = 0;
+
 		/*
 		 * Note - if the above fails completely, the action is to take
 		 * individual devices offline and flush the queue of any
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index e5953c8..60031e1 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -546,66 +546,6 @@ void scsi_run_host_queues(struct Scsi_Host *shost)
 
 static void __scsi_release_buffers(struct scsi_cmnd *, int);
 
-/*
- * Function:    scsi_end_request()
- *
- * Purpose:     Post-processing of completed commands (usually invoked at end
- *		of upper level post-processing and scsi_io_completion).
- *
- * Arguments:   cmd	 - command that is complete.
- *              error    - 0 if I/O indicates success, < 0 for I/O error.
- *              bytes    - number of bytes of completed I/O
- *		requeue  - indicates whether we should requeue leftovers.
- *
- * Lock status: Assumed that lock is not held upon entry.
- *
- * Returns:     cmd if requeue required, NULL otherwise.
- *
- * Notes:       This is called for block device requests in order to
- *              mark some number of sectors as complete.
- * 
- *		We are guaranteeing that the request queue will be goosed
- *		at some point during this call.
- * Notes:	If cmd was requeued, upon return it will be a stale pointer.
- */
-static struct scsi_cmnd *scsi_end_request(struct scsi_cmnd *cmd, int error,
-					  int bytes, int requeue)
-{
-	struct request_queue *q = cmd->device->request_queue;
-	struct request *req = cmd->request;
-
-	/*
-	 * If there are blocks left over at the end, set up the command
-	 * to queue the remainder of them.
-	 */
-	if (blk_end_request(req, error, bytes)) {
-		/* kill remainder if no retrys */
-		if (error && scsi_noretry_cmd(cmd))
-			blk_end_request_all(req, error);
-		else {
-			if (requeue) {
-				/*
-				 * Bleah.  Leftovers again.  Stick the
-				 * leftovers in the front of the
-				 * queue, and goose the queue again.
-				 */
-				scsi_release_buffers(cmd);
-				scsi_requeue_command(q, cmd);
-				cmd = NULL;
-			}
-			return cmd;
-		}
-	}
-
-	/*
-	 * This will goose the queue request function at the end, so we don't
-	 * need to worry about launching another command.
-	 */
-	__scsi_release_buffers(cmd, 0);
-	scsi_next_command(cmd);
-	return NULL;
-}
-
 static inline unsigned int scsi_sgtable_index(unsigned short nents)
 {
 	unsigned int index;
@@ -735,16 +675,9 @@ static int __scsi_error_from_host_byte(struct scsi_cmnd *cmd, int result)
  *
  * Returns:     Nothing
  *
- * Notes:       This function is matched in terms of capabilities to
- *              the function that created the scatter-gather list.
- *              In other words, if there are no bounce buffers
- *              (the normal case for most drivers), we don't need
- *              the logic to deal with cleaning up afterwards.
- *
- *		We must call scsi_end_request().  This will finish off
- *		the specified number of sectors.  If we are done, the
- *		command block will be released and the queue function
- *		will be goosed.  If we are not done then we have to
+ * Notes:       We will finish off the specified number of sectors.  If we
+ *		are done, the command block will be released and the queue
+ *		function will be goosed.  If we are not done then we have to
  *		figure out what to do next:
  *
  *		a) We can call scsi_requeue_command().  The request
@@ -753,7 +686,7 @@ static int __scsi_error_from_host_byte(struct scsi_cmnd *cmd, int result)
  *		   be used if we made forward progress, or if we want
  *		   to switch from READ(10) to READ(6) for example.
  *
- *		b) We can call scsi_queue_insert().  The request will
+ *		b) We can call __scsi_queue_insert().  The request will
  *		   be put back on the queue and retried using the same
  *		   command as before, possibly after a delay.
  *
@@ -857,12 +790,28 @@ void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)
 	}
 
 	/*
-	 * A number of bytes were successfully read.  If there
-	 * are leftovers and there is some kind of error
-	 * (result != 0), retry the rest.
+	 * special case: failed zero length commands always need to
+	 * drop down into the retry code. Otherwise, if we finished
+	 * all bytes in the request we are done now.
 	 */
-	if (scsi_end_request(cmd, error, good_bytes, result == 0) == NULL)
-		return;
+	if (!(blk_rq_bytes(req) == 0 && error) &&
+	    !blk_end_request(req, error, good_bytes))
+		goto next_command;
+
+	/*
+	 * Kill remainder if no retrys.
+	 */
+	if (error && scsi_noretry_cmd(cmd)) {
+		blk_end_request_all(req, error);
+		goto next_command;
+	}
+
+	/*
+	 * If there had been no error, but we have leftover bytes in the
+	 * requeues just queue the command up again.
+	 */
+	if (result == 0)
+		goto requeue;
 
 	error = __scsi_error_from_host_byte(cmd, result);
 
@@ -984,7 +933,6 @@ void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)
 	switch (action) {
 	case ACTION_FAIL:
 		/* Give up and fail the remainder of the request */
-		scsi_release_buffers(cmd);
 		if (!(req->cmd_flags & REQ_QUIET)) {
 			if (description)
 				scmd_printk(KERN_INFO, cmd, "%s\n",
@@ -994,12 +942,11 @@ void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)
 				scsi_print_sense("", cmd);
 			scsi_print_command(cmd);
 		}
-		if (blk_end_request_err(req, error))
-			scsi_requeue_command(q, cmd);
-		else
-			scsi_next_command(cmd);
-		break;
+		if (!blk_end_request_err(req, error))
+			goto next_command;
+		/*FALLTHRU*/
 	case ACTION_REPREP:
+	requeue:
 		/* Unprep the request and put it back at the head of the queue.
 		 * A new command will be prepared and issued.
 		 */
@@ -1015,6 +962,11 @@ void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)
 		__scsi_queue_insert(cmd, SCSI_MLQUEUE_DEVICE_BUSY, 0);
 		break;
 	}
+	return;
+
+next_command:
+	__scsi_release_buffers(cmd, 0);
+	scsi_next_command(cmd);
 }
 
 static int scsi_init_sgtable(struct request *req, struct scsi_data_buffer *sdb,
@@ -1242,9 +1194,11 @@ int scsi_prep_state_check(struct scsi_device *sdev, struct request *req)
 				    "rejecting I/O to dead device\n");
 			ret = BLKPREP_KILL;
 			break;
-		case SDEV_QUIESCE:
 		case SDEV_BLOCK:
 		case SDEV_CREATED_BLOCK:
+			ret = BLKPREP_DEFER;
+			break;
+		case SDEV_QUIESCE:
 			/*
 			 * If the devices is blocked we defer normal commands.
 			 */
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 9e2dd47..135d7b5 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -789,7 +789,7 @@ sdev_store_queue_ramp_up_period(struct device *dev,
 		return -EINVAL;
 
 	sdev->queue_ramp_up_period = msecs_to_jiffies(period);
-	return period;
+	return count;
 }
 
 static struct device_attribute sdev_attr_queue_ramp_up_period =
@@ -1030,31 +1030,25 @@ static void __scsi_remove_target(struct scsi_target *starget)
 void scsi_remove_target(struct device *dev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev->parent);
-	struct scsi_target *starget, *last = NULL;
+	struct scsi_target *starget, *last_target = NULL;
 	unsigned long flags;
 
-	/* remove targets being careful to lookup next entry before
-	 * deleting the last
-	 */
+restart:
 	spin_lock_irqsave(shost->host_lock, flags);
 	list_for_each_entry(starget, &shost->__targets, siblings) {
-		if (starget->state == STARGET_DEL)
+		if (starget->state == STARGET_DEL ||
+		    starget == last_target)
 			continue;
 		if (starget->dev.parent == dev || &starget->dev == dev) {
-			/* assuming new targets arrive at the end */
 			kref_get(&starget->reap_ref);
+			last_target = starget;
 			spin_unlock_irqrestore(shost->host_lock, flags);
-			if (last)
-				scsi_target_reap(last);
-			last = starget;
 			__scsi_remove_target(starget);
-			spin_lock_irqsave(shost->host_lock, flags);
+			scsi_target_reap(starget);
+			goto restart;
 		}
 	}
 	spin_unlock_irqrestore(shost->host_lock, flags);
-
-	if (last)
-		scsi_target_reap(last);
 }
 EXPORT_SYMBOL(scsi_remove_target);
 
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 26b543b..4afce0e 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -3090,8 +3090,8 @@ static int sd_suspend(struct device *dev)
 	struct scsi_disk *sdkp = scsi_disk_get_from_dev(dev);
 	int ret = 0;
 
-	if (!sdkp)
-		return 0;	/* this can happen */
+	if (!sdkp)	/* E.g.: runtime suspend following sd_remove() */
+		return 0;
 
 	if (sdkp->WCE) {
 		sd_printk(KERN_NOTICE, sdkp, "Synchronizing SCSI cache\n");
@@ -3115,6 +3115,9 @@ static int sd_resume(struct device *dev)
 	struct scsi_disk *sdkp = scsi_disk_get_from_dev(dev);
 	int ret = 0;
 
+	if (!sdkp)	/* E.g.: runtime resume at the start of sd_probe() */
+		return 0;
+
 	if (!sdkp->device->manage_start_stop)
 		goto done;
 
diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index eba183c..3643bbf 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -70,6 +70,7 @@ static int ses_probe(struct device *dev)
 static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 			 void *buf, int bufflen)
 {
+	int ret;
 	unsigned char cmd[] = {
 		RECEIVE_DIAGNOSTIC,
 		1,		/* Set PCV bit */
@@ -78,9 +79,26 @@ static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 		bufflen & 0xff,
 		0
 	};
+	unsigned char recv_page_code;
 
-	return scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,
+	ret =  scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,
 				NULL, SES_TIMEOUT, SES_RETRIES, NULL);
+	if (unlikely(!ret))
+		return ret;
+
+	recv_page_code = ((unsigned char *)buf)[0];
+
+	if (likely(recv_page_code == page_code))
+		return ret;
+
+	/* successful diagnostic but wrong page code.  This happens to some
+	 * USB devices, just print a message and pretend there was an error */
+
+	sdev_printk(KERN_ERR, sdev,
+		    "Wrong diagnostic page; asked for %d got %u\n",
+		    page_code, recv_page_code);
+
+	return -EINVAL;
 }
 
 static int ses_send_diag(struct scsi_device *sdev, int page_code,
@@ -436,7 +454,15 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 			if (desc_ptr)
 				desc_ptr += len;
 
-			if (addl_desc_ptr)
+			if (addl_desc_ptr &&
+			    /* only find additional descriptions for specific devices */
+			    (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||
+			     type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE ||
+			     type_ptr[0] == ENCLOSURE_COMPONENT_SAS_EXPANDER ||
+			     /* these elements are optional */
+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_TARGET_PORT ||
+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT ||
+			     type_ptr[0] == ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS))
 				addl_desc_ptr += addl_desc_ptr[1] + 2;
 
 		}
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index eb81c98..1f65e32 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -633,7 +633,8 @@ sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
 	else
 		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
 	hp->dxfer_len = mxsize;
-	if (hp->dxfer_direction == SG_DXFER_TO_DEV)
+	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
+	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
 		hp->dxferp = (char __user *)buf + cmd_size;
 	else
 		hp->dxferp = NULL;
@@ -1258,7 +1259,7 @@ sg_mmap(struct file *filp, struct vm_area_struct *vma)
 	}
 
 	sfp->mmap_called = 1;
-	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
+	vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
 	vma->vm_private_data = sfp;
 	vma->vm_ops = &sg_mmap_vm_ops;
 	return 0;
@@ -1694,6 +1695,9 @@ static int sg_start_req(Sg_request *srp, unsigned char *cmd)
 			md->from_user = 0;
 	}
 
+	if (unlikely(iov_count > UIO_MAXIOV))
+		return -EINVAL;
+
 	if (iov_count) {
 		int len, size = sizeof(struct sg_iovec) * iov_count;
 		struct iovec *iov;
diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c
index 119d67f..1ac9943 100644
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@ -142,6 +142,9 @@ static int sr_runtime_suspend(struct device *dev)
 {
 	struct scsi_cd *cd = dev_get_drvdata(dev);
 
+	if (!cd)	/* E.g.: runtime suspend following sr_remove() */
+		return 0;
+
 	if (cd->media_present)
 		return -EBUSY;
 	else
@@ -1006,6 +1009,7 @@ static int sr_remove(struct device *dev)
 
 	blk_queue_prep_rq(cd->device->request_queue, scsi_prep_fn);
 	del_gendisk(cd->disk);
+	dev_set_drvdata(dev, NULL);
 
 	mutex_lock(&sr_ref_mutex);
 	kref_put(&cd->kref, sr_kref_release);
diff --git a/drivers/scsi/st.c b/drivers/scsi/st.c
index 2a32036..fa98112 100644
--- a/drivers/scsi/st.c
+++ b/drivers/scsi/st.c
@@ -1262,9 +1262,9 @@ static int st_open(struct inode *inode, struct file *filp)
 	spin_lock(&st_use_lock);
 	STp->in_use = 0;
 	spin_unlock(&st_use_lock);
-	scsi_tape_put(STp);
 	if (resumed)
 		scsi_autopm_put_device(STp->device);
+	scsi_tape_put(STp);
 	return retval;
 
 }
diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c
index a899078..913b91c 100644
--- a/drivers/scsi/storvsc_drv.c
+++ b/drivers/scsi/storvsc_drv.c
@@ -631,21 +631,22 @@ static unsigned int copy_to_bounce_buffer(struct scatterlist *orig_sgl,
 			if (bounce_sgl[j].length == PAGE_SIZE) {
 				/* full..move to next entry */
 				sg_kunmap_atomic(bounce_addr);
+				bounce_addr = 0;
 				j++;
+			}
 
-				/* if we need to use another bounce buffer */
-				if (srclen || i != orig_sgl_count - 1)
-					bounce_addr = sg_kmap_atomic(bounce_sgl,j);
+			/* if we need to use another bounce buffer */
+			if (srclen && bounce_addr == 0)
+				bounce_addr = sg_kmap_atomic(bounce_sgl, j);
 
-			} else if (srclen == 0 && i == orig_sgl_count - 1) {
-				/* unmap the last bounce that is < PAGE_SIZE */
-				sg_kunmap_atomic(bounce_addr);
-			}
 		}
 
 		sg_kunmap_atomic(src_addr - orig_sgl[i].offset);
 	}
 
+	if (bounce_addr)
+		sg_kunmap_atomic(bounce_addr);
+
 	local_irq_restore(flags);
 
 	return total_copied;
diff --git a/drivers/spi/spi-ambarella.c b/drivers/spi/spi-ambarella.c
index e86ac0d..1f444b7 100644
--- a/drivers/spi/spi-ambarella.c
+++ b/drivers/spi/spi-ambarella.c
@@ -39,39 +39,40 @@
 #include <asm/io.h>
 #include <mach/io.h>
 #include <plat/spi.h>
-#include <plat/ambcache.h>
 #include <plat/dma.h>
 #include <plat/rct.h>
 
-#define	AMBARELLA_SPI_MAX_LEN			4096
+#define	AMBARELLA_SPI_BUF_MAX_LEN			(1024 * 20) //4096
 #define	AMBARELLA_SPI_MAX_XFER_PER_MSG		32
+#define	AMBARELLA_SPI_MAX_CS_NUM			8
 
 struct ambarella_spi {
-	u8					txb[AMBARELLA_SPI_MAX_LEN];
-	u8					rxb[AMBARELLA_SPI_MAX_LEN];
-
-	u32					phys;
-	u32					virt;
-
-	struct clk			*clk;
-	u32					clk_freq;
-	int					cs_pins[8];
-
-	struct dma_chan		*txc;
-	struct dma_chan		*rxc;
-
+	struct device			*dev;
+	struct dma_chan		*tx_dma_chan;
+	struct dma_chan		*rx_dma_chan;
 	struct spi_message	*msg;
 	struct spi_transfer		*transfers[AMBARELLA_SPI_MAX_XFER_PER_MSG];
-	int					xfer_id, n_xfer;
+	struct clk			*clk;
+	struct tasklet_struct	tasklet;
+	void __iomem			*virt;
 
-	int					cs_active;
-	int					rw ;
-	int					irq;
+	u8 					*tx_dma_buf;
+	u8 					*rx_dma_buf;
+	dma_addr_t 			tx_dma_phys;
+	dma_addr_t 			rx_dma_phys;
+
+	u32					dma_buf_size;
+	u32					phys;
+	u32					clk_freq;
 	u32					dma_used:1;
 	u32					msb_first_only:1;
 	u32					ridx, widx;
-
-	struct tasklet_struct	tasklet;
+	u32					cspol;
+	int					cs_pins[AMBARELLA_SPI_MAX_CS_NUM];
+	int					xfer_id, n_xfer;
+	int					cs_active;
+	int					rw;
+	int					irq;
 };
 
 static void ambarella_spi_next_transfer(void *args);
@@ -98,40 +99,11 @@ static int ambarella_spi_of_parse(struct platform_device *pdev,
 	return 0;
 }
 
-static int of_dev_node_match(struct device *dev, void *data)
-{
-	return dev->of_node == data;
-}
-
-static struct spi_device *ambarella_spi_of_find_device(struct device_node *np)
-{
-	struct device *dev;
-
-	dev = bus_find_device(&spi_bus_type, NULL, np,
-					 of_dev_node_match);
-	if (!dev)
-		return NULL;
-
-	return to_spi_device(dev);
-}
-
-static bool ambarella_spi_dma_filter(struct dma_chan *chan, void *fparam)
-{
-	if (ambarella_dma_channel_id(chan) == *(int *)fparam) {
-		return true;
-	} else {
-		return false;
-	}
-}
-
 static void ambarella_spi_setup(struct ambarella_spi *bus, struct spi_device *spi)
 {
-	u32			virt;
 	spi_ctrl0_reg_t		cr0;
 	u32 			ssi_clk, sckdv;
 
-	virt		= bus->virt;
-
 	cr0.w		= 0;
 	cr0.s.dfs	= spi->bits_per_word - 1;
 	if (spi->mode & SPI_CPHA) {
@@ -161,26 +133,22 @@ static void ambarella_spi_setup(struct ambarella_spi *bus, struct spi_device *sp
 	cr0.s.byte_ws		= 0;
 	cr0.s.fc_en		= 0;
 	cr0.s.residue		= 1;
-	amba_writel(virt + SPI_CTRLR0_OFFSET, cr0.w);
+	amba_writel(bus->virt + SPI_CTRLR0_OFFSET, cr0.w);
 
 	ssi_clk = bus->clk_freq;
 	if(spi->max_speed_hz > ssi_clk / 2) {
 	    spi->max_speed_hz = ssi_clk / 2;
 	}
 	sckdv = (ssi_clk / spi->max_speed_hz + 1) & 0xfffe;
-	amba_writel(virt + SPI_BAUDR_OFFSET, sckdv);
+	amba_writel(bus->virt + SPI_BAUDR_OFFSET, sckdv);
 
-	if (spi->cs_gpio) {
-		gpio_set_value(spi->cs_gpio, 0);
-		bus->cs_active = 1;
-	}
+	bus->cspol = (spi->mode & SPI_CS_HIGH) ? 1 : 0;
+	gpio_set_value(spi->cs_gpio, bus->cspol);
+	bus->cs_active = 1;
 }
 
 static void ambarella_spi_stop(struct ambarella_spi *bus)
 {
-	gpio_set_value(bus->msg->spi->cs_gpio, 1);
-	bus->cs_active = 0;
-
 	amba_readl(bus->virt + SPI_ICR_OFFSET);
 	amba_readl(bus->virt + SPI_ISR_OFFSET);
 
@@ -188,22 +156,19 @@ static void ambarella_spi_stop(struct ambarella_spi *bus)
 	amba_writel(bus->virt + SPI_SER_OFFSET, 0);
 
 	if (bus->dma_used)
-		amba_writel(bus->virt + 0x4c, 0);
+		amba_writel(bus->virt + SPI_DMAC_OFFSET, 0);
 }
 
 static void ambarella_spi_prepare_transfer(struct ambarella_spi *bus)
 {
 	struct spi_message		*msg;
-	struct spi_transfer		*xfer;
-	u32				virt;
-	const void			*wbuf, *rbuf;
+	struct spi_transfer			*xfer;
+	const void				*wbuf, *rbuf;
 	spi_ctrl0_reg_t			cr0;
 
 	bus->widx = 0;
 	bus->ridx = 0;
 
-	virt		= bus->virt;
-
 	msg		= bus->msg;
 	xfer		= bus->transfers[bus->xfer_id];
 
@@ -220,52 +185,46 @@ static void ambarella_spi_prepare_transfer(struct ambarella_spi *bus)
 	}
 	msg->actual_length += xfer->len;
 
-	cr0.w		= amba_readl(virt + SPI_CTRLR0_OFFSET);
+	cr0.w		= amba_readl(bus->virt + SPI_CTRLR0_OFFSET);
 	cr0.s.tmod	= SPI_WRITE_READ;
-	amba_writel(virt + SPI_CTRLR0_OFFSET, cr0.w);
+	amba_writel(bus->virt + SPI_CTRLR0_OFFSET, cr0.w);
 
 	if (!bus->cs_active) {
-		gpio_set_value(msg->spi->cs_gpio, 0);
+		gpio_set_value(msg->spi->cs_gpio, bus->cspol);
 		bus->cs_active = 1;
 	}
 
-	amba_writel(virt + SPI_SSIENR_OFFSET, 0);
-	amba_writel(virt + SPI_SER_OFFSET, 0);
+	amba_writel(bus->virt + SPI_SSIENR_OFFSET, 0);
+	amba_writel(bus->virt + SPI_SER_OFFSET, 0);
 	if (bus->dma_used) {
 		if (bus->msg->spi->bits_per_word <= 8) {
-			amba_writel(virt + SPI_RXFTLR_OFFSET, 8 - 1);
+			amba_writel(bus->virt + SPI_RXFTLR_OFFSET, 8 - 1);
 		} else {
-			amba_writel(virt + SPI_RXFTLR_OFFSET, 4 - 1);
+			amba_writel(bus->virt + SPI_RXFTLR_OFFSET, 4 - 1);
 		}
-		amba_writel(virt + 0x4c, 0x03);
+		amba_writel(bus->virt + SPI_DMAC_OFFSET, 0x3);
 	} else {
 		disable_irq_nosync(bus->irq);
-		amba_writel(virt + SPI_IMR_OFFSET, SPI_TXEIS_MASK);
-		amba_writel(virt + SPI_TXFTLR_OFFSET, 0);
-		amba_writel(virt + SPI_RXFTLR_OFFSET, 1);
+		amba_writel(bus->virt + SPI_IMR_OFFSET, SPI_TXEIS_MASK);
+		amba_writel(bus->virt + SPI_TXFTLR_OFFSET, 0);
+		amba_writel(bus->virt + SPI_RXFTLR_OFFSET, 1);
 	}
-	amba_writel(virt + SPI_SSIENR_OFFSET, 1);
+	amba_writel(bus->virt + SPI_SSIENR_OFFSET, 1);
 }
 
 static void ambarella_spi_start_transfer(struct ambarella_spi *bus)
 {
-	struct spi_device		*spi;
-	struct spi_transfer		*xfer;
-	struct dma_slave_config		tx_cfg, rx_cfg;
-	struct dma_async_tx_descriptor	*txd, *rxd;
-	int				ret;
-	int				cs_id;
-	u32				virt;
-	u32				len, txa, rxa, widx, ridx, xfer_len, i;
+	struct spi_device *spi;
+	struct spi_transfer *xfer;
+	struct dma_slave_config tx_cfg, rx_cfg;
+	struct dma_async_tx_descriptor *txd, *rxd;
+	u32 len, widx, ridx, xfer_len, i;
 	void *wbuf, *rbuf;
 	u16 tmp;
 
-	xfer	= bus->transfers[bus->xfer_id];
-	spi	= bus->msg->spi;
-	virt	= bus->virt;
-	cs_id = spi->chip_select;
-	txa	= virt_to_phys(bus->txb);
-	rxa	= virt_to_phys(bus->rxb);
+	xfer = bus->transfers[bus->xfer_id];
+	spi = bus->msg->spi;
+
 	wbuf = (void *)xfer->tx_buf;
 	rbuf = (void *)xfer->rx_buf;
 	widx	= bus->widx;
@@ -277,6 +236,8 @@ static void ambarella_spi_start_transfer(struct ambarella_spi *bus)
 			len >>= 1;
 	}
 
+	dma_sync_single_for_cpu(bus->dev, bus->tx_dma_phys, len, DMA_TO_DEVICE);
+
 	switch (bus->rw) {
 	case SPI_WRITE_ONLY:
 	case SPI_WRITE_READ:
@@ -287,19 +248,19 @@ static void ambarella_spi_start_transfer(struct ambarella_spi *bus)
 					tmp = ((u8 *)wbuf)[widx++];
 				else
 					tmp = ((u16 *)wbuf)[widx++];
-				amba_writel(virt + SPI_DR_OFFSET, tmp);
+				amba_writel(bus->virt + SPI_DR_OFFSET, tmp);
 			}
 		} else {
-			memcpy(bus->txb, xfer->tx_buf, len);
+			memcpy(bus->tx_dma_buf, xfer->tx_buf, len);
 		}
 		break;
 	case SPI_READ_ONLY:
 		if (!bus->dma_used) {
 			xfer_len = min_t(int, len - ridx, SPI_DATA_FIFO_SIZE_16);
 			for(i = 0; i < xfer_len; i++)
-				amba_writel(virt + SPI_DR_OFFSET, SPI_DUMMY_DATA);
+				amba_writel(bus->virt + SPI_DR_OFFSET, SPI_DUMMY_DATA);
 		} else {
-			memset(bus->txb, 0xff, len);
+			memset(bus->tx_dma_buf, 0xFF, len);
 		}
 
 		break;
@@ -308,7 +269,7 @@ static void ambarella_spi_start_transfer(struct ambarella_spi *bus)
 	}
 
 	if (bus->dma_used) {
-		ambcache_clean_range(bus->txb, len);
+		/* TX DMA */
 		tx_cfg.dst_addr			= bus->phys + SPI_DR_OFFSET;
 		if (spi->bits_per_word <= 8) {
 			tx_cfg.dst_addr_width	= DMA_SLAVE_BUSWIDTH_1_BYTE;
@@ -318,12 +279,11 @@ static void ambarella_spi_start_transfer(struct ambarella_spi *bus)
 		tx_cfg.dst_maxburst		= 8;
 		tx_cfg.direction		= DMA_MEM_TO_DEV;
 
-		ret = dmaengine_slave_config(bus->txc, &tx_cfg);
-		BUG_ON(ret < 0);
+		BUG_ON(dmaengine_slave_config(bus->tx_dma_chan, &tx_cfg) < 0);
 
-		dma_sync_single_for_device(NULL, txa, len, DMA_TO_DEVICE);
+		dma_sync_single_for_device(bus->dev, bus->tx_dma_phys, len, DMA_TO_DEVICE);
 
-		txd = dmaengine_prep_slave_single(bus->txc, txa, len,
+		txd = dmaengine_prep_slave_single(bus->tx_dma_chan, bus->tx_dma_phys, len,
 			DMA_MEM_TO_DEV, DMA_PREP_INTERRUPT |
 			DMA_COMPL_SKIP_SRC_UNMAP | DMA_COMPL_SKIP_DEST_UNMAP | DMA_CTRL_ACK);
 		BUG_ON (!txd);
@@ -332,8 +292,9 @@ static void ambarella_spi_start_transfer(struct ambarella_spi *bus)
 		txd->callback_param	= NULL;
 		dmaengine_submit(txd);
 
-		dma_async_issue_pending(bus->txc);
+		dma_async_issue_pending(bus->tx_dma_chan);
 
+		/* RX DMA */
 		rx_cfg.src_addr			= bus->phys + SPI_DR_OFFSET;
 		if (spi->bits_per_word <= 8) {
 			rx_cfg.src_addr_width	= DMA_SLAVE_BUSWIDTH_1_BYTE;
@@ -342,26 +303,27 @@ static void ambarella_spi_start_transfer(struct ambarella_spi *bus)
 		}
 		rx_cfg.src_maxburst		= 8;
 		rx_cfg.direction		= DMA_DEV_TO_MEM;
-		ret = dmaengine_slave_config(bus->rxc, &rx_cfg);
-		BUG_ON(ret < 0);
 
-		rxd = dmaengine_prep_slave_single(bus->rxc, rxa, len,
-			DMA_DEV_TO_MEM,	DMA_PREP_INTERRUPT | DMA_CTRL_ACK |
+		BUG_ON(dmaengine_slave_config(bus->rx_dma_chan, &rx_cfg) < 0);
+
+		rxd = dmaengine_prep_slave_single(bus->rx_dma_chan, bus->rx_dma_phys, len,
+			DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT | DMA_CTRL_ACK |
 			DMA_COMPL_SKIP_SRC_UNMAP | DMA_COMPL_SKIP_DEST_UNMAP);
 		BUG_ON(!rxd);
 
 		rxd->callback		= ambarella_spi_next_transfer;
 		rxd->callback_param	= bus;
-		dma_sync_single_for_device(NULL, rxa, len, DMA_FROM_DEVICE);
+
+		dma_sync_single_for_device(bus->dev, bus->rx_dma_phys, len, DMA_FROM_DEVICE);
 
 		dmaengine_submit(rxd);
-		dma_async_issue_pending(bus->rxc);
+		dma_async_issue_pending(bus->rx_dma_chan);
 	} else {
 		bus->widx = widx;
 		enable_irq(bus->irq);
 	}
 
-	amba_writel(virt + SPI_SER_OFFSET, 1 << cs_id);
+	amba_writel(bus->virt + SPI_SER_OFFSET, 1 << spi->chip_select);
 }
 
 static void ambarella_spi_next_transfer(void *args)
@@ -375,8 +337,8 @@ static void ambarella_spi_next_transfer(void *args)
 		switch (bus->rw) {
 		case SPI_WRITE_READ:
 		case SPI_READ_ONLY:
-			ambcache_inv_range(bus->rxb, xfer->len);
-			memcpy(xfer->rx_buf, bus->rxb, xfer->len);
+			dma_sync_single_for_cpu(bus->dev, bus->rx_dma_phys, xfer->len, DMA_FROM_DEVICE);
+			memcpy(xfer->rx_buf, bus->rx_dma_buf, xfer->len);
 			break;
 		default:
 			break;
@@ -384,11 +346,14 @@ static void ambarella_spi_next_transfer(void *args)
 	}
 
 	if (xfer->cs_change) {
-		gpio_set_value(bus->msg->spi->cs_gpio, 1);
+		gpio_set_value(bus->msg->spi->cs_gpio, bus->cspol^1);
 		bus->cs_active = 0;
 	}
 
 	if (bus->xfer_id >= bus->n_xfer) {
+		gpio_set_value(bus->msg->spi->cs_gpio, bus->cspol^1);
+		bus->cs_active = 0;
+
 		ambarella_spi_stop(bus);
 		spi_finalize_current_message(bus->msg->spi->master);
 	} else {
@@ -401,21 +366,19 @@ static void ambarella_spi_tasklet(unsigned long data)
 {
 	struct ambarella_spi *bus = (struct ambarella_spi *)data;
 	struct spi_transfer *xfer;
-	u32 virt;
 	void *rbuf;
 	u32 widx, ridx, len, rxflr, xfer_len;
 	u32 status, finish_transfer = 0;
 	u16 i, tmp;
 
-	virt = bus->virt;
 	xfer = bus->transfers[bus->xfer_id];
 
 	/* Wait until SPI idle */
-	status = amba_readl(virt + SPI_SR_OFFSET);
+	status = amba_readl(bus->virt + SPI_SR_OFFSET);
 	if (status & 0x1) {
 		/* Transfer is still in progress */
 		for (i = 0; i < MAX_QUERY_TIMES; i++) {
-			status = amba_readl(virt + SPI_SR_OFFSET);
+			status = amba_readl(bus->virt + SPI_SR_OFFSET);
 			if (!(status & 0x1))
 				break;
 		}
@@ -430,21 +393,19 @@ static void ambarella_spi_tasklet(unsigned long data)
 	ridx	= bus->ridx;
 	len	= xfer->len;
 
-	if (!bus->dma_used) {
-		if (bus->msg->spi->bits_per_word > 8)
-			len >>= 1;
-	}
+	if (bus->msg->spi->bits_per_word > 8)
+		len >>= 1;
 
 	/* Fetch data from FIFO */
 	switch (bus->rw) {
 	case SPI_READ_ONLY:
 	case SPI_WRITE_READ:
 		xfer_len = len - ridx;
-		rxflr = amba_readl(virt + SPI_RXFLR_OFFSET);
+		rxflr = amba_readl(bus->virt + SPI_RXFLR_OFFSET);
 		if (xfer_len > rxflr)
 			xfer_len = rxflr;
 		for(i = 0; i < xfer_len; i++) {
-			tmp	= amba_readl(virt + SPI_DR_OFFSET);
+			tmp	= amba_readl(bus->virt + SPI_DR_OFFSET);
 			if (bus->msg->spi->bits_per_word <= 8)
 				((u8 *)rbuf)[ridx++] = tmp & 0xff;
 			else
@@ -502,6 +463,12 @@ static int ambarella_spi_one_message(struct spi_master *master, struct spi_messa
 		goto ambarella_spi_transfer_exit;
 	}
 
+	if (!gpio_is_valid(spi->cs_gpio)) {
+		dev_err(&master->dev, "cs %d is invalid!\n", spi->cs_gpio);
+		err = -EINVAL;
+		goto ambarella_spi_transfer_exit;
+	}
+
 	if (spi->bits_per_word < 4 || spi->bits_per_word > 16) {
 		err = -EINVAL;
 		goto ambarella_spi_transfer_exit;
@@ -530,7 +497,7 @@ static int ambarella_spi_one_message(struct spi_master *master, struct spi_messa
 	bus->n_xfer	= 0;
 	bus->xfer_id	= 0;
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-		if (xfer->len > AMBARELLA_SPI_MAX_LEN) {
+		if (xfer->len > AMBARELLA_SPI_BUF_MAX_LEN) {
 			err = -EINVAL;
 			goto ambarella_spi_transfer_exit;
 		}
@@ -559,40 +526,86 @@ static irqreturn_t ambarella_spi_isr(int irq, void *dev_data)
 	return IRQ_HANDLED;
 }
 
-static int ambarella_spi_dma_channel_allocate(struct spi_master *master)
+static int ambarella_spi_dma_channel_allocate(struct ambarella_spi *bus,
+			bool dma_to_memory)
 {
-	struct ambarella_spi *bus;
-	dma_cap_mask_t	mask;
-	int chan_id;
-	u32 val;
+	struct dma_chan *dma_chan;
+	dma_addr_t dma_phys;
+	u8 *dma_buf;
+	int ret = 0;
+
+	dma_chan = dma_request_slave_channel(bus->dev,
+					dma_to_memory ? "rx" : "tx");
+	if (IS_ERR(dma_chan)) {
+		ret = PTR_ERR(dma_chan);
+		if (ret != -EPROBE_DEFER)
+			dev_err(bus->dev,
+				"Dma channel is not available: %d\n", ret);
+		return ret;
+	}
+
+	dma_buf = dma_alloc_coherent(bus->dev, bus->dma_buf_size,
+				&dma_phys, GFP_KERNEL);
+	if (!dma_buf) {
+		dev_err(bus->dev, " Not able to allocate the dma buffer\n");
+		dma_release_channel(dma_chan);
+		return -ENOMEM;
+	}
+
+	if (dma_to_memory) {
+		bus->rx_dma_chan = dma_chan;
+		bus->rx_dma_buf = dma_buf;
+		bus->rx_dma_phys = dma_phys;
+	} else {
+		bus->tx_dma_chan = dma_chan;
+		bus->tx_dma_buf = dma_buf;
+		bus->tx_dma_phys = dma_phys;
+	}
 
-	bus = spi_master_get_devdata(master);
+	return ret;
+}
 
-	amba_writel(bus->virt + 0x4c, 0);
-	if (bus->dma_used) {
-		/* Enable DMA Channel 0/1 as SSI0 Tx and Rx */
-		val	 = amba_readl(AHB_SCRATCHPAD_REG(0x0c));
-		val	&= 0xff9fffff;
-		val	|= 0x00200000;
-		amba_writel(AHB_SCRATCHPAD_REG(0x0c), val);
+static void ambarella_spi_dma_channel_free(struct ambarella_spi *bus,
+	bool dma_to_memory)
+{
+	u8 *dma_buf;
+	dma_addr_t dma_phys;
+	struct dma_chan *dma_chan;
+
+	if (dma_to_memory) {
+		dma_buf = bus->rx_dma_buf;
+		dma_chan = bus->rx_dma_chan;
+		dma_phys = bus->rx_dma_phys;
+		bus->rx_dma_chan = NULL;
+		bus->rx_dma_buf = NULL;
+	} else {
+		dma_buf = bus->tx_dma_buf;
+		dma_chan = bus->tx_dma_chan;
+		dma_phys = bus->tx_dma_phys;
+		bus->tx_dma_buf = NULL;
+		bus->tx_dma_chan = NULL;
 	}
+	if (!dma_chan)
+		return;
 
-	chan_id = 2 * master->bus_num;
-	dma_cap_zero(mask);
-	dma_cap_set(DMA_SLAVE, mask);
-	bus->txc = dma_request_channel(mask, ambarella_spi_dma_filter, &chan_id);
-	if (!bus->txc) {
-		dev_err(&master->dev, "can't request DMA channel %d\n", chan_id);
-		return -EPERM;
-	}
+	dma_free_coherent(bus->dev, bus->dma_buf_size, dma_buf, dma_phys);
+	dma_release_channel(dma_chan);
+}
 
-	chan_id = 2 * master->bus_num + 1;
-	dma_cap_zero(mask);
-	dma_cap_set(DMA_SLAVE, mask);
-	bus->rxc = dma_request_channel(mask, ambarella_spi_dma_filter, &chan_id);
-	if (!bus->rxc) {
-		dev_err(&master->dev, "can't request DMA channel %d\n", chan_id);
-		return -EPERM;
+static int ambarella_spi_hw_setup(struct spi_device *spi)
+{
+	struct ambarella_spi *bus = spi_master_get_devdata(spi->master);
+	int err = 0;
+
+	if (gpio_is_valid(spi->cs_gpio) &&
+		(bus->cs_pins[spi->chip_select] != spi->cs_gpio)) {
+		err = gpio_request(spi->cs_gpio, dev_name(&spi->dev));
+		if (err < 0) {
+			dev_err(&spi->dev, "can't get CS: %d\n", err);
+			return -EINVAL;
+		}
+		gpio_direction_output(spi->cs_gpio, (spi->mode & SPI_CS_HIGH) ? 0 : 1);
+		bus->cs_pins[spi->chip_select] = spi->cs_gpio;
 	}
 
 	return 0;
@@ -604,42 +617,48 @@ static int ambarella_spi_probe(struct platform_device *pdev)
 	void __iomem				*reg;
 	struct ambarella_spi			*bus;
 	struct spi_master			*master;
-	struct device_node			*nc;
+	int					i;
 	int					err = 0;
 	int					irq;
+	u32					val;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		err = -EINVAL;
-		goto ambarella_spi_probe_exit;
+		goto exit_spi_probe;
 	}
 
 	reg = devm_ioremap(&pdev->dev, res->start, resource_size(res));
 	if (!reg) {
 		err = -ENOMEM;
-		goto ambarella_spi_probe_exit;
+		goto exit_spi_probe;
 	}
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		dev_err(&pdev->dev, "no irq resource!\n");
-		return -ENODEV;
+		err = -ENODEV;
+		goto exit_spi_probe;
 	}
 
 	master = spi_alloc_master(&pdev->dev, sizeof(*bus));
 	if (!master) {
 		err = -ENOMEM;
-		goto ambarella_spi_probe_exit;
+		goto exit_spi_probe;
 	}
 
-	bus				= spi_master_get_devdata(master);
-	bus->phys		= res->start;
-	bus->virt			= (u32)reg;
-	bus->irq			= irq;
+	bus = spi_master_get_devdata(master);
+	bus->phys = res->start;
+	bus->virt = reg;
+	bus->irq = irq;
+	bus->dev = &pdev->dev;
+
+	for (i = 0; i < AMBARELLA_SPI_MAX_CS_NUM; i++)
+		bus->cs_pins[i] = -1;
 
 	err = ambarella_spi_of_parse(pdev, master);
 	if (err < 0) {
-		goto ambarella_spi_probe_exit;
+		goto exit_free_master;
 	}
 
 	clk_set_rate(bus->clk, bus->clk_freq);
@@ -647,70 +666,68 @@ static int ambarella_spi_probe(struct platform_device *pdev)
 	amba_writel(reg + SPI_IMR_OFFSET, 0);
 
 	master->dev.of_node		= pdev->dev.of_node;
-	master->mode_bits		= SPI_CPHA | SPI_CPOL;
+	master->mode_bits		= SPI_CPHA | SPI_CPOL | SPI_CS_HIGH;
 	master->transfer_one_message	= ambarella_spi_one_message;
+	master->setup = ambarella_spi_hw_setup;
 	platform_set_drvdata(pdev, master);
 
-	err = spi_register_master(master);
-	if (err) {
-		goto ambarella_spi_probe_exit;
-	}
-
 	/* check if hw only supports msb first tx/rx */
 	if (of_find_property(pdev->dev.of_node, "amb,msb-first-only", NULL)) {
 		bus->msb_first_only = 1;
-		dev_info(&pdev->dev,"SPI[%d] only supports msb first tx-rx\n", master->bus_num);
+		dev_info(&pdev->dev,"Only supports msb first tx-rx\n");
 	} else {
 		bus->msb_first_only = 0;
+		master->mode_bits |= SPI_LSB_FIRST;
 	}
 
 	/* check if using dma */
 	if (of_find_property(pdev->dev.of_node, "amb,dma-used", NULL)) {
 		bus->dma_used = 1;
-		dev_info(&pdev->dev,"SPI[%d] uses DMA\n", master->bus_num);
-	} else {
-		bus->dma_used = 0;
-	}
+		dev_info(&pdev->dev,"DMA is used\n");
 
-	for_each_available_child_of_node(master->dev.of_node, nc) {
-		struct spi_device	*spi;
-
-		spi = ambarella_spi_of_find_device(nc);
-		if (!spi) {
-			continue;
-		}
-
-		if (gpio_is_valid(spi->cs_gpio)) {
-			err = devm_gpio_request(&pdev->dev,
-					spi->cs_gpio, dev_name(&spi->dev));
-			if (err < 0) {
-				dev_err(&pdev->dev, "can't get CS: %d\n", err);
-				goto ambarella_spi_probe_exit;
-			}
-			gpio_direction_output(spi->cs_gpio, 1);
-			bus->cs_pins[spi->chip_select] = spi->cs_gpio;
-		} else {
-			bus->cs_pins[spi->chip_select] = -1;
-		}
-	}
+		/* Enable DMA Channel 0/1 as SSI0 Tx and Rx */
+		val	 = amba_readl(AHB_SCRATCHPAD_REG(0x0c));
+		val	&= 0xff9fffff;
+		val	|= 0x00200000;
+		amba_writel(AHB_SCRATCHPAD_REG(0x0c), val);
 
-	if (bus->dma_used) {
-		err = ambarella_spi_dma_channel_allocate(master);
+		bus->dma_buf_size = AMBARELLA_SPI_BUF_MAX_LEN;
+		err = ambarella_spi_dma_channel_allocate(bus, false);
 		if (err < 0)
-			goto ambarella_spi_probe_exit;
+			goto exit_free_master;
+		err = ambarella_spi_dma_channel_allocate(bus, true);
+		if (err < 0)
+			goto exit_tx_dma_irq_free;
 	} else {
+		bus->dma_used = 0;
 		/* request IRQ */
 		err = devm_request_irq(&pdev->dev, irq, ambarella_spi_isr,
 				IRQF_TRIGGER_HIGH, dev_name(&pdev->dev), bus);
 		if (err)
-			goto ambarella_spi_probe_exit;
+			goto exit_free_master;
 
 		tasklet_init(&bus->tasklet, ambarella_spi_tasklet, (unsigned long)bus);
 	}
 
+	err = spi_register_master(master);
+	if (err)
+		goto exit_rx_dma_free;
+
 	dev_info(&pdev->dev, "Ambarella spi controller %d created.\r\n", master->bus_num);
 
-ambarella_spi_probe_exit:
+	return err;
+
+exit_rx_dma_free:
+	if (bus->dma_used)
+		ambarella_spi_dma_channel_free(bus, true);
+exit_tx_dma_irq_free:
+	if (bus->dma_used)
+		ambarella_spi_dma_channel_free(bus, false);
+	else
+		free_irq(irq, bus);
+exit_free_master:
+	spi_master_put(master);
+exit_spi_probe:
 	return err;
 }
 
@@ -718,14 +735,28 @@ static int ambarella_spi_remove(struct platform_device *pdev)
 {
 	struct spi_master		*master;
 	struct ambarella_spi		*bus;
+	int i;
 
 	master	= platform_get_drvdata(pdev);
 	bus	= spi_master_get_devdata(master);
 
 	if (!bus->dma_used)
 		tasklet_kill(&bus->tasklet);
+	else {
+		if (bus->tx_dma_chan)
+			ambarella_spi_dma_channel_free(bus, false);
+
+		if (bus->rx_dma_chan)
+			ambarella_spi_dma_channel_free(bus, true);
+	}
 
 	ambarella_spi_stop(bus);
+
+	for (i = 0; i < AMBARELLA_SPI_MAX_CS_NUM; i++) {
+		if (gpio_is_valid(bus->cs_pins[i]))
+			gpio_free(bus->cs_pins[i]);
+	}
+
 	spi_unregister_master(master);
 
 	return 0;
@@ -860,6 +891,28 @@ ambarella_spi_write_and_read_exit:
 }
 EXPORT_SYMBOL(ambarella_spi_write_and_read);
 
+#ifdef CONFIG_PM
+static int ambarella_spi_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	dev_dbg(&pdev->dev, "%s exit with 0 @ %d\n", __func__, state.event);
+
+	return 0;
+}
+
+static int ambarella_spi_resume(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct ambarella_spi *bus = spi_master_get_devdata(master);
+
+	clk_set_rate(bus->clk, bus->clk_freq);
+
+	dev_dbg(&pdev->dev, "%s exit with 0\n", __func__);
+
+	return 0;
+}
+#endif
+
 static const struct of_device_id ambarella_spi_dt_ids[] = {
 	{.compatible = "ambarella,spi", },
 	{},
@@ -869,6 +922,10 @@ MODULE_DEVICE_TABLE(of, ambarella_spi_dt_ids);
 static struct platform_driver ambarella_spi_driver = {
 	.probe		= ambarella_spi_probe,
 	.remove		= ambarella_spi_remove,
+#ifdef CONFIG_PM
+	.suspend		= ambarella_spi_suspend,
+	.resume		= ambarella_spi_resume,
+#endif
 	.driver		= {
 		.name	= "ambarella-spi",
 		.owner	= THIS_MODULE,
diff --git a/drivers/spi/spi-atmel.c b/drivers/spi/spi-atmel.c
index 380387a..462af46 100644
--- a/drivers/spi/spi-atmel.c
+++ b/drivers/spi/spi-atmel.c
@@ -594,7 +594,8 @@ static int atmel_spi_next_xfer_dma_submit(struct spi_master *master,
 
 	*plen = len;
 
-	if (atmel_spi_dma_slave_config(as, &slave_config, 8))
+	if (atmel_spi_dma_slave_config(as, &slave_config,
+				       xfer->bits_per_word))
 		goto err_exit;
 
 	/* Send both scatterlists */
diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c
index cc42ee5..787cfba 100644
--- a/drivers/spi/spi-pxa2xx.c
+++ b/drivers/spi/spi-pxa2xx.c
@@ -546,6 +546,10 @@ static irqreturn_t ssp_int(int irq, void *dev_id)
 	if (!(sccr1_reg & SSCR1_TIE))
 		mask &= ~SSSR_TFS;
 
+	/* Ignore RX timeout interrupt if it is disabled */
+	if (!(sccr1_reg & SSCR1_TINTE))
+		mask &= ~SSSR_TINT;
+
 	if (!(status & mask))
 		return IRQ_NONE;
 
diff --git a/drivers/spi/spi-xilinx.c b/drivers/spi/spi-xilinx.c
index 34d18dc..109a535 100644
--- a/drivers/spi/spi-xilinx.c
+++ b/drivers/spi/spi-xilinx.c
@@ -315,7 +315,7 @@ static int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
 		}
 
 		/* See if there is more data to send */
-		if (!xspi->remaining_bytes > 0)
+		if (xspi->remaining_bytes <= 0)
 			break;
 	}
 
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 32b7bb1..cc80ab1 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1030,8 +1030,7 @@ static struct class spi_master_class = {
  *
  * The caller is responsible for assigning the bus number and initializing
  * the master's methods before calling spi_register_master(); and (after errors
- * adding the device) calling spi_master_put() and kfree() to prevent a memory
- * leak.
+ * adding the device) calling spi_master_put() to prevent a memory leak.
  */
 struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 {
@@ -1048,7 +1047,7 @@ struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 	master->bus_num = -1;
 	master->num_chipselect = 1;
 	master->dev.class = &spi_master_class;
-	master->dev.parent = get_device(dev);
+	master->dev.parent = dev;
 	spi_master_set_devdata(master, &master[1]);
 
 	return master;
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 911e9e0..a08f923 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -243,7 +243,10 @@ static int spidev_message(struct spidev_data *spidev,
 		k_tmp->len = u_tmp->len;
 
 		total += k_tmp->len;
-		if (total > bufsiz) {
+		/* Check total length of transfers.  Also check each
+		 * transfer length to avoid arithmetic overflow.
+		 */
+		if (total > bufsiz || k_tmp->len > bufsiz) {
 			status = -EMSGSIZE;
 			goto done;
 		}
diff --git a/drivers/staging/comedi/drivers/adl_pci7x3x.c b/drivers/staging/comedi/drivers/adl_pci7x3x.c
index e396074..49cb692 100644
--- a/drivers/staging/comedi/drivers/adl_pci7x3x.c
+++ b/drivers/staging/comedi/drivers/adl_pci7x3x.c
@@ -119,10 +119,21 @@ static int adl_pci7x3x_do_insn_bits(struct comedi_device *dev,
 	unsigned int bits = data[1];
 
 	if (mask) {
+		unsigned int val;
+
 		s->state &= ~mask;
 		s->state |= (bits & mask);
-
-		outl(s->state, dev->iobase + reg);
+		val = s->state;
+		if (s->n_chan == 16) {
+			/*
+			 * It seems the PCI-7230 needs the 16-bit DO state
+			 * to be shifted left by 16 bits before being written
+			 * to the 32-bit register.  Set the value in both
+			 * halves of the register to be sure.
+			 */
+			val |= val << 16;
+		}
+		outl(val, dev->iobase + reg);
 	}
 
 	/*
diff --git a/drivers/staging/comedi/drivers/daqboard2000.c b/drivers/staging/comedi/drivers/daqboard2000.c
index b87f95c..1465a26 100644
--- a/drivers/staging/comedi/drivers/daqboard2000.c
+++ b/drivers/staging/comedi/drivers/daqboard2000.c
@@ -678,7 +678,7 @@ static const void *daqboard2000_find_boardinfo(struct comedi_device *dev,
 	const struct daq200_boardtype *board;
 	int i;
 
-	if (pcidev->subsystem_device != PCI_VENDOR_ID_IOTECH)
+	if (pcidev->subsystem_vendor != PCI_VENDOR_ID_IOTECH)
 		return NULL;
 
 	for (i = 0; i < ARRAY_SIZE(boardtypes); i++) {
diff --git a/drivers/staging/iio/accel/sca3000_core.c b/drivers/staging/iio/accel/sca3000_core.c
index 32950ad..b30c41b 100644
--- a/drivers/staging/iio/accel/sca3000_core.c
+++ b/drivers/staging/iio/accel/sca3000_core.c
@@ -588,7 +588,7 @@ static ssize_t sca3000_read_frequency(struct device *dev,
 		goto error_ret_mut;
 	ret = sca3000_read_ctrl_reg(st, SCA3000_REG_CTRL_SEL_OUT_CTRL);
 	mutex_unlock(&st->lock);
-	if (ret)
+	if (ret < 0)
 		goto error_ret;
 	val = ret;
 	if (base_freq > 0)
diff --git a/drivers/staging/iio/adc/lpc32xx_adc.c b/drivers/staging/iio/adc/lpc32xx_adc.c
index 2f2f7fd..9cbe2dd 100644
--- a/drivers/staging/iio/adc/lpc32xx_adc.c
+++ b/drivers/staging/iio/adc/lpc32xx_adc.c
@@ -76,7 +76,7 @@ static int lpc32xx_read_raw(struct iio_dev *indio_dev,
 
 	if (mask == IIO_CHAN_INFO_RAW) {
 		mutex_lock(&indio_dev->mlock);
-		clk_enable(info->clk);
+		clk_prepare_enable(info->clk);
 		/* Measurement setup */
 		__raw_writel(AD_INTERNAL | (chan->address) | AD_REFp | AD_REFm,
 			LPC32XX_ADC_SELECT(info->adc_base));
@@ -84,7 +84,7 @@ static int lpc32xx_read_raw(struct iio_dev *indio_dev,
 		__raw_writel(AD_PDN_CTRL | AD_STROBE,
 			LPC32XX_ADC_CTRL(info->adc_base));
 		wait_for_completion(&info->completion); /* set by ISR */
-		clk_disable(info->clk);
+		clk_disable_unprepare(info->clk);
 		*val = info->value;
 		mutex_unlock(&indio_dev->mlock);
 
diff --git a/drivers/staging/ozwpan/ozusbsvc1.c b/drivers/staging/ozwpan/ozusbsvc1.c
index 4e4b650..d4f55b0 100644
--- a/drivers/staging/ozwpan/ozusbsvc1.c
+++ b/drivers/staging/ozwpan/ozusbsvc1.c
@@ -314,7 +314,11 @@ static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body->data;
-			int n = (len - sizeof(struct oz_multiple_fixed)+1)
+			unsigned int n;
+			if (!body->unit_size ||
+				len < sizeof(struct oz_multiple_fixed) - 1)
+				break;
+			n = (len - (sizeof(struct oz_multiple_fixed) - 1))
 				/ body->unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,
@@ -376,10 +380,15 @@ void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)
 	case OZ_GET_DESC_RSP: {
 			struct oz_get_desc_rsp *body =
 				(struct oz_get_desc_rsp *)usb_hdr;
-			int data_len = elt->length -
-					sizeof(struct oz_get_desc_rsp) + 1;
-			u16 offs = le16_to_cpu(get_unaligned(&body->offset));
-			u16 total_size =
+			u16 offs, total_size;
+			u8 data_len;
+
+			if (elt->length < sizeof(struct oz_get_desc_rsp) - 1)
+				break;
+			data_len = elt->length -
+					(sizeof(struct oz_get_desc_rsp) - 1);
+			offs = le16_to_cpu(get_unaligned(&body->offset));
+			total_size =
 				le16_to_cpu(get_unaligned(&body->total_size));
 			oz_trace("USB_REQ_GET_DESCRIPTOR - cnf\n");
 			oz_hcd_get_desc_cnf(usb_ctx->hport, body->req_id,
diff --git a/drivers/staging/panel/panel.c b/drivers/staging/panel/panel.c
index c54df39..4d0a87b 100644
--- a/drivers/staging/panel/panel.c
+++ b/drivers/staging/panel/panel.c
@@ -275,11 +275,11 @@ static unsigned char lcd_bits[LCD_PORTS][LCD_BITS][BIT_STATES];
  * LCD types
  */
 #define LCD_TYPE_NONE		0
-#define LCD_TYPE_OLD		1
-#define LCD_TYPE_KS0074		2
-#define LCD_TYPE_HANTRONIX	3
-#define LCD_TYPE_NEXCOM		4
-#define LCD_TYPE_CUSTOM		5
+#define LCD_TYPE_CUSTOM		1
+#define LCD_TYPE_OLD		2
+#define LCD_TYPE_KS0074		3
+#define LCD_TYPE_HANTRONIX	4
+#define LCD_TYPE_NEXCOM		5
 
 /*
  * keypad types
@@ -457,8 +457,7 @@ MODULE_PARM_DESC(keypad_enabled, "Deprecated option, use keypad_type instead");
 static int lcd_type = -1;
 module_param(lcd_type, int, 0000);
 MODULE_PARM_DESC(lcd_type,
-		 "LCD type: 0=none, 1=old //, 2=serial ks0074, "
-		 "3=hantronix //, 4=nexcom //, 5=compiled-in");
+		"LCD type: 0=none, 1=compiled-in, 2=old, 3=serial ks0074, 4=hantronix, 5=nexcom");
 
 static int lcd_proto = -1;
 module_param(lcd_proto, int, 0000);
diff --git a/drivers/staging/rtl8187se/ieee80211/ieee80211.h b/drivers/staging/rtl8187se/ieee80211/ieee80211.h
index 8fc9f58..9fdd566 100644
--- a/drivers/staging/rtl8187se/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8187se/ieee80211/ieee80211.h
@@ -1447,12 +1447,12 @@ extern void ieee80211_sta_ps_send_null_frame(struct ieee80211_device *ieee, shor
 
 extern const long ieee80211_wlan_frequencies[];
 
-extern inline void ieee80211_increment_scans(struct ieee80211_device *ieee)
+static inline void ieee80211_increment_scans(struct ieee80211_device *ieee)
 {
 	ieee->scans++;
 }
 
-extern inline int ieee80211_get_scans(struct ieee80211_device *ieee)
+static inline int ieee80211_get_scans(struct ieee80211_device *ieee)
 {
 	return ieee->scans;
 }
diff --git a/drivers/staging/rtl8192e/rtllib.h b/drivers/staging/rtl8192e/rtllib.h
index 3485ef1..f35948e 100644
--- a/drivers/staging/rtl8192e/rtllib.h
+++ b/drivers/staging/rtl8192e/rtllib.h
@@ -2761,7 +2761,6 @@ extern void rtllib_stop_scan(struct rtllib_device *ieee);
 extern bool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan);
 extern void rtllib_stop_scan_syncro(struct rtllib_device *ieee);
 extern void rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh);
-extern inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee);
 extern u8 MgntQuery_MgntFrameTxRate(struct rtllib_device *ieee);
 extern void rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee,
 					  short pwr);
@@ -2943,12 +2942,12 @@ void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh);
 
 extern const long rtllib_wlan_frequencies[];
 
-extern inline void rtllib_increment_scans(struct rtllib_device *ieee)
+static inline void rtllib_increment_scans(struct rtllib_device *ieee)
 {
 	ieee->scans++;
 }
 
-extern inline int rtllib_get_scans(struct rtllib_device *ieee)
+static inline int rtllib_get_scans(struct rtllib_device *ieee)
 {
 	return ieee->scans;
 }
diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c
index 4feecec..0e4e837 100644
--- a/drivers/staging/rtl8192e/rtllib_softmac.c
+++ b/drivers/staging/rtl8192e/rtllib_softmac.c
@@ -341,7 +341,7 @@ inline void softmac_ps_mgmt_xmit(struct sk_buff *skb,
 	}
 }
 
-inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
+static inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)
 {
 	unsigned int len, rate_len;
 	u8 *tag;
diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211.h b/drivers/staging/rtl8192u/ieee80211/ieee80211.h
index 210898c..e1339c3 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211.h
@@ -2250,7 +2250,7 @@ static inline void *ieee80211_priv(struct net_device *dev)
 	return ((struct ieee80211_device *)netdev_priv(dev))->priv;
 }
 
-extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
+static inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
 {
 	/* Single white space is for Linksys APs */
 	if (essid_len == 1 && essid[0] == ' ')
@@ -2266,7 +2266,7 @@ extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
 	return 1;
 }
 
-extern inline int ieee80211_is_valid_mode(struct ieee80211_device *ieee, int mode)
+static inline int ieee80211_is_valid_mode(struct ieee80211_device *ieee, int mode)
 {
 	/*
 	 * It is possible for both access points and our device to support
@@ -2292,7 +2292,7 @@ extern inline int ieee80211_is_valid_mode(struct ieee80211_device *ieee, int mod
 	return 0;
 }
 
-extern inline int ieee80211_get_hdrlen(u16 fc)
+static inline int ieee80211_get_hdrlen(u16 fc)
 {
 	int hdrlen = IEEE80211_3ADDR_LEN;
 
@@ -2578,12 +2578,12 @@ void ieee80211_softmac_scan_syncro(struct ieee80211_device *ieee);
 
 extern const long ieee80211_wlan_frequencies[];
 
-extern inline void ieee80211_increment_scans(struct ieee80211_device *ieee)
+static inline void ieee80211_increment_scans(struct ieee80211_device *ieee)
 {
 	ieee->scans++;
 }
 
-extern inline int ieee80211_get_scans(struct ieee80211_device *ieee)
+static inline int ieee80211_get_scans(struct ieee80211_device *ieee)
 {
 	return ieee->scans;
 }
diff --git a/drivers/staging/rtl8712/ieee80211.h b/drivers/staging/rtl8712/ieee80211.h
index da4000e..8269be8 100644
--- a/drivers/staging/rtl8712/ieee80211.h
+++ b/drivers/staging/rtl8712/ieee80211.h
@@ -734,7 +734,7 @@ enum ieee80211_state {
 #define IEEE_G            (1<<2)
 #define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
 
-extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
+static inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
 {
 	/* Single white space is for Linksys APs */
 	if (essid_len == 1 && essid[0] == ' ')
@@ -748,7 +748,7 @@ extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
 	return 1;
 }
 
-extern inline int ieee80211_get_hdrlen(u16 fc)
+static inline int ieee80211_get_hdrlen(u16 fc)
 {
 	int hdrlen = 24;
 
diff --git a/drivers/staging/rtl8712/rtl8712_recv.c b/drivers/staging/rtl8712/rtl8712_recv.c
index d59a74a..4b25f3a 100644
--- a/drivers/staging/rtl8712/rtl8712_recv.c
+++ b/drivers/staging/rtl8712/rtl8712_recv.c
@@ -1075,7 +1075,8 @@ static int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)
 		/* for first fragment packet, driver need allocate 1536 +
 		 * drvinfo_sz + RXDESC_SIZE to defrag packet. */
 		if ((mf == 1) && (frag == 0))
-			alloc_sz = 1658;/*1658+6=1664, 1664 is 128 alignment.*/
+			/*1658+6=1664, 1664 is 128 alignment.*/
+			alloc_sz = max_t(u16, tmp_len, 1658);
 		else
 			alloc_sz = tmp_len;
 		/* 2 is for IP header 4 bytes alignment in QoS packet case.
diff --git a/drivers/staging/rtl8712/usb_intf.c b/drivers/staging/rtl8712/usb_intf.c
index e3a005d..1d9ab22 100644
--- a/drivers/staging/rtl8712/usb_intf.c
+++ b/drivers/staging/rtl8712/usb_intf.c
@@ -144,6 +144,7 @@ static struct usb_device_id rtl871x_usb_id_tbl[] = {
 	{USB_DEVICE(0x0DF6, 0x0058)},
 	{USB_DEVICE(0x0DF6, 0x0049)},
 	{USB_DEVICE(0x0DF6, 0x004C)},
+	{USB_DEVICE(0x0DF6, 0x006C)},
 	{USB_DEVICE(0x0DF6, 0x0064)},
 	/* Skyworth */
 	{USB_DEVICE(0x14b2, 0x3300)},
diff --git a/drivers/staging/speakup/fakekey.c b/drivers/staging/speakup/fakekey.c
index 4299cf4..5e1f16c 100644
--- a/drivers/staging/speakup/fakekey.c
+++ b/drivers/staging/speakup/fakekey.c
@@ -81,6 +81,7 @@ void speakup_fake_down_arrow(void)
 	__this_cpu_write(reporting_keystroke, true);
 	input_report_key(virt_keyboard, KEY_DOWN, PRESSED);
 	input_report_key(virt_keyboard, KEY_DOWN, RELEASED);
+	input_sync(virt_keyboard);
 	__this_cpu_write(reporting_keystroke, false);
 
 	/* reenable preemption */
diff --git a/drivers/staging/speakup/selection.c b/drivers/staging/speakup/selection.c
index b935975..364978e 100644
--- a/drivers/staging/speakup/selection.c
+++ b/drivers/staging/speakup/selection.c
@@ -139,7 +139,9 @@ static void __speakup_paste_selection(struct work_struct *work)
 	struct tty_ldisc *ld;
 	DECLARE_WAITQUEUE(wait, current);
 
-	ld = tty_ldisc_ref_wait(tty);
+	ld = tty_ldisc_ref(tty);
+	if (!ld)
+		goto tty_unref;
 
 	/* FIXME: this is completely unsafe */
 	add_wait_queue(&vc->paste_wait, &wait);
@@ -158,6 +160,7 @@ static void __speakup_paste_selection(struct work_struct *work)
 	current->state = TASK_RUNNING;
 
 	tty_ldisc_deref(ld);
+tty_unref:
 	tty_kref_put(tty);
 }
 
diff --git a/drivers/staging/usbip/usbip_common.c b/drivers/staging/usbip/usbip_common.c
index 7b97df6..b4f237e 100644
--- a/drivers/staging/usbip/usbip_common.c
+++ b/drivers/staging/usbip/usbip_common.c
@@ -784,6 +784,17 @@ int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)
 	if (!(size > 0))
 		return 0;
 
+	if (size > urb->transfer_buffer_length) {
+		/* should not happen, probably malicious packet */
+		if (ud->side == USBIP_STUB) {
+			usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);
+			return 0;
+		} else {
+			usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
+			return -EPIPE;
+		}
+	}
+
 	ret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);
 	if (ret != size) {
 		dev_err(&urb->dev->dev, "recv xbuf, %d\n", ret);
diff --git a/drivers/staging/vt6655/rf.c b/drivers/staging/vt6655/rf.c
index 6948984..c2d6028 100644
--- a/drivers/staging/vt6655/rf.c
+++ b/drivers/staging/vt6655/rf.c
@@ -966,6 +966,7 @@ bool RFbSetPower(
 		break;
 	case RATE_6M:
 	case RATE_9M:
+	case RATE_12M:
 	case RATE_18M:
 		byPwr = pDevice->abyOFDMPwrTbl[uCH];
 		if (pDevice->byRFType == RF_UW2452) {
diff --git a/drivers/staging/wlags49_h2/wl_internal.h b/drivers/staging/wlags49_h2/wl_internal.h
index b230781..11b00c3 100644
--- a/drivers/staging/wlags49_h2/wl_internal.h
+++ b/drivers/staging/wlags49_h2/wl_internal.h
@@ -1014,7 +1014,7 @@ static inline void wl_unlock(struct wl_private *lp,
 /* Interrupt enable disable functions                               */
 /********************************************************************/
 
-extern inline void wl_act_int_on(struct wl_private *lp)
+static inline void wl_act_int_on(struct wl_private *lp)
 {
 	/*
 	 * Only do something when the driver is handling
@@ -1026,7 +1026,7 @@ extern inline void wl_act_int_on(struct wl_private *lp)
 	}
 }
 
-extern inline void wl_act_int_off(struct wl_private *lp)
+static inline void wl_act_int_off(struct wl_private *lp)
 {
 	/*
 	 * Only do something when the driver is handling
diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c
index 9559ea7..d74da95 100644
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@ -518,7 +518,7 @@ static struct iscsit_transport iscsi_target_transport = {
 
 static int __init iscsi_target_init_module(void)
 {
-	int ret = 0;
+	int ret = 0, size;
 
 	pr_debug("iSCSI-Target "ISCSIT_VERSION"\n");
 
@@ -527,6 +527,7 @@ static int __init iscsi_target_init_module(void)
 		pr_err("Unable to allocate memory for iscsit_global\n");
 		return -1;
 	}
+	spin_lock_init(&iscsit_global->ts_bitmap_lock);
 	mutex_init(&auth_id_lock);
 	spin_lock_init(&sess_idr_lock);
 	idr_init(&tiqn_idr);
@@ -536,15 +537,11 @@ static int __init iscsi_target_init_module(void)
 	if (ret < 0)
 		goto out;
 
-	ret = iscsi_thread_set_init();
-	if (ret < 0)
+	size = BITS_TO_LONGS(ISCSIT_BITMAP_BITS) * sizeof(long);
+	iscsit_global->ts_bitmap = vzalloc(size);
+	if (!iscsit_global->ts_bitmap) {
+		pr_err("Unable to allocate iscsit_global->ts_bitmap\n");
 		goto configfs_out;
-
-	if (iscsi_allocate_thread_sets(TARGET_THREAD_SET_COUNT) !=
-			TARGET_THREAD_SET_COUNT) {
-		pr_err("iscsi_allocate_thread_sets() returned"
-			" unexpected value!\n");
-		goto ts_out1;
 	}
 
 	lio_cmd_cache = kmem_cache_create("lio_cmd_cache",
@@ -553,7 +550,7 @@ static int __init iscsi_target_init_module(void)
 	if (!lio_cmd_cache) {
 		pr_err("Unable to kmem_cache_create() for"
 				" lio_cmd_cache\n");
-		goto ts_out2;
+		goto bitmap_out;
 	}
 
 	lio_qr_cache = kmem_cache_create("lio_qr_cache",
@@ -608,10 +605,8 @@ qr_out:
 	kmem_cache_destroy(lio_qr_cache);
 cmd_out:
 	kmem_cache_destroy(lio_cmd_cache);
-ts_out2:
-	iscsi_deallocate_thread_sets();
-ts_out1:
-	iscsi_thread_set_free();
+bitmap_out:
+	vfree(iscsit_global->ts_bitmap);
 configfs_out:
 	iscsi_target_deregister_configfs();
 out:
@@ -621,8 +616,6 @@ out:
 
 static void __exit iscsi_target_cleanup_module(void)
 {
-	iscsi_deallocate_thread_sets();
-	iscsi_thread_set_free();
 	iscsit_release_discovery_tpg();
 	iscsit_unregister_transport(&iscsi_target_transport);
 	kmem_cache_destroy(lio_cmd_cache);
@@ -633,6 +626,7 @@ static void __exit iscsi_target_cleanup_module(void)
 
 	iscsi_target_deregister_configfs();
 
+	vfree(iscsit_global->ts_bitmap);
 	kfree(iscsit_global);
 }
 
@@ -1179,7 +1173,7 @@ iscsit_handle_scsi_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
 	 * traditional iSCSI block I/O.
 	 */
 	if (iscsit_allocate_iovecs(cmd) < 0) {
-		return iscsit_add_reject_cmd(cmd,
+		return iscsit_reject_cmd(cmd,
 				ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);
 	}
 	immed_data = cmd->immediate_data;
@@ -3590,17 +3584,16 @@ static int iscsit_send_reject(
 
 void iscsit_thread_get_cpumask(struct iscsi_conn *conn)
 {
-	struct iscsi_thread_set *ts = conn->thread_set;
 	int ord, cpu;
 	/*
-	 * thread_id is assigned from iscsit_global->ts_bitmap from
-	 * within iscsi_thread_set.c:iscsi_allocate_thread_sets()
+	 * bitmap_id is assigned from iscsit_global->ts_bitmap from
+	 * within iscsit_start_kthreads()
 	 *
-	 * Here we use thread_id to determine which CPU that this
-	 * iSCSI connection's iscsi_thread_set will be scheduled to
+	 * Here we use bitmap_id to determine which CPU that this
+	 * iSCSI connection's RX/TX threads will be scheduled to
 	 * execute upon.
 	 */
-	ord = ts->thread_id % cpumask_weight(cpu_online_mask);
+	ord = conn->bitmap_id % cpumask_weight(cpu_online_mask);
 	for_each_online_cpu(cpu) {
 		if (ord-- == 0) {
 			cpumask_set_cpu(cpu, conn->conn_cpumask);
@@ -3792,7 +3785,7 @@ check_rsp_state:
 	switch (state) {
 	case ISTATE_SEND_LOGOUTRSP:
 		if (!iscsit_logout_post_handler(cmd, conn))
-			goto restart;
+			return -ECONNRESET;
 		/* fall through */
 	case ISTATE_SEND_STATUS:
 	case ISTATE_SEND_ASYNCMSG:
@@ -3820,8 +3813,6 @@ check_rsp_state:
 
 err:
 	return -1;
-restart:
-	return -EAGAIN;
 }
 
 static int iscsit_handle_response_queue(struct iscsi_conn *conn)
@@ -3848,21 +3839,13 @@ static int iscsit_handle_response_queue(struct iscsi_conn *conn)
 int iscsi_target_tx_thread(void *arg)
 {
 	int ret = 0;
-	struct iscsi_conn *conn;
-	struct iscsi_thread_set *ts = arg;
+	struct iscsi_conn *conn = arg;
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
 
-restart:
-	conn = iscsi_tx_thread_pre_handler(ts);
-	if (!conn)
-		goto out;
-
-	ret = 0;
-
 	while (!kthread_should_stop()) {
 		/*
 		 * Ensure that both TX and RX per connection kthreads
@@ -3871,11 +3854,9 @@ restart:
 		iscsit_thread_check_cpumask(conn, current, 1);
 
 		wait_event_interruptible(conn->queues_wq,
-					 !iscsit_conn_all_queues_empty(conn) ||
-					 ts->status == ISCSI_THREAD_SET_RESET);
+					 !iscsit_conn_all_queues_empty(conn));
 
-		if ((ts->status == ISCSI_THREAD_SET_RESET) ||
-		     signal_pending(current))
+		if (signal_pending(current))
 			goto transport_err;
 
 get_immediate:
@@ -3886,15 +3867,20 @@ get_immediate:
 		ret = iscsit_handle_response_queue(conn);
 		if (ret == 1)
 			goto get_immediate;
-		else if (ret == -EAGAIN)
-			goto restart;
+		else if (ret == -ECONNRESET)
+			goto out;
 		else if (ret < 0)
 			goto transport_err;
 	}
 
 transport_err:
-	iscsit_take_action_for_connection_exit(conn);
-	goto restart;
+	/*
+	 * Avoid the normal connection failure code-path if this connection
+	 * is still within LOGIN mode, and iscsi_np process context is
+	 * responsible for cleaning up the early connection failure.
+	 */
+	if (conn->conn_state != TARG_CONN_STATE_IN_LOGIN)
+		iscsit_take_action_for_connection_exit(conn);
 out:
 	return 0;
 }
@@ -3974,35 +3960,46 @@ reject:
 	return iscsit_add_reject(conn, ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);
 }
 
+static bool iscsi_target_check_conn_state(struct iscsi_conn *conn)
+{
+	bool ret;
+
+	spin_lock_bh(&conn->state_lock);
+	ret = (conn->conn_state != TARG_CONN_STATE_LOGGED_IN);
+	spin_unlock_bh(&conn->state_lock);
+
+	return ret;
+}
+
 int iscsi_target_rx_thread(void *arg)
 {
-	int ret;
+	int ret, rc;
 	u8 buffer[ISCSI_HDR_LEN], opcode;
 	u32 checksum = 0, digest = 0;
-	struct iscsi_conn *conn = NULL;
-	struct iscsi_thread_set *ts = arg;
+	struct iscsi_conn *conn = arg;
 	struct kvec iov;
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
-
-restart:
-	conn = iscsi_rx_thread_pre_handler(ts);
-	if (!conn)
-		goto out;
+	/*
+	 * Wait for iscsi_post_login_handler() to complete before allowing
+	 * incoming iscsi/tcp socket I/O, and/or failing the connection.
+	 */
+	rc = wait_for_completion_interruptible(&conn->rx_login_comp);
+	if (rc < 0 || iscsi_target_check_conn_state(conn))
+		return 0;
 
 	if (conn->conn_transport->transport_type == ISCSI_INFINIBAND) {
 		struct completion comp;
-		int rc;
 
 		init_completion(&comp);
 		rc = wait_for_completion_interruptible(&comp);
 		if (rc < 0)
 			goto transport_err;
 
-		goto out;
+		goto transport_err;
 	}
 
 	while (!kthread_should_stop()) {
@@ -4085,8 +4082,6 @@ transport_err:
 	if (!signal_pending(current))
 		atomic_set(&conn->transport_failed, 1);
 	iscsit_take_action_for_connection_exit(conn);
-	goto restart;
-out:
 	return 0;
 }
 
@@ -4148,7 +4143,24 @@ int iscsit_close_connection(
 	if (conn->conn_transport->transport_type == ISCSI_TCP)
 		complete(&conn->conn_logout_comp);
 
-	iscsi_release_thread_set(conn);
+	if (!strcmp(current->comm, ISCSI_RX_THREAD_NAME)) {
+		if (conn->tx_thread &&
+		    cmpxchg(&conn->tx_thread_active, true, false)) {
+			send_sig(SIGINT, conn->tx_thread, 1);
+			kthread_stop(conn->tx_thread);
+		}
+	} else if (!strcmp(current->comm, ISCSI_TX_THREAD_NAME)) {
+		if (conn->rx_thread &&
+		    cmpxchg(&conn->rx_thread_active, true, false)) {
+			send_sig(SIGINT, conn->rx_thread, 1);
+			kthread_stop(conn->rx_thread);
+		}
+	}
+
+	spin_lock(&iscsit_global->ts_bitmap_lock);
+	bitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,
+			      get_order(1));
+	spin_unlock(&iscsit_global->ts_bitmap_lock);
 
 	iscsit_stop_timers_for_cmds(conn);
 	iscsit_stop_nopin_response_timer(conn);
@@ -4427,15 +4439,24 @@ static void iscsit_logout_post_handler_closesession(
 	struct iscsi_conn *conn)
 {
 	struct iscsi_session *sess = conn->sess;
-
-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);
-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);
+	int sleep = 1;
+	/*
+	 * Traditional iscsi/tcp will invoke this logic from TX thread
+	 * context during session logout, so clear tx_thread_active and
+	 * sleep if iscsit_close_connection() has not already occured.
+	 *
+	 * Since iser-target invokes this logic from it's own workqueue,
+	 * always sleep waiting for RX/TX thread shutdown to complete
+	 * within iscsit_close_connection().
+	 */
+	if (conn->conn_transport->transport_type == ISCSI_TCP)
+		sleep = cmpxchg(&conn->tx_thread_active, true, false);
 
 	atomic_set(&conn->conn_logout_remove, 0);
 	complete(&conn->conn_logout_comp);
 
 	iscsit_dec_conn_usage_count(conn);
-	iscsit_stop_session(sess, 1, 1);
+	iscsit_stop_session(sess, sleep, sleep);
 	iscsit_dec_session_usage_count(sess);
 	target_put_session(sess->se_sess);
 }
@@ -4443,13 +4464,15 @@ static void iscsit_logout_post_handler_closesession(
 static void iscsit_logout_post_handler_samecid(
 	struct iscsi_conn *conn)
 {
-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);
-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);
+	int sleep = 1;
+
+	if (conn->conn_transport->transport_type == ISCSI_TCP)
+		sleep = cmpxchg(&conn->tx_thread_active, true, false);
 
 	atomic_set(&conn->conn_logout_remove, 0);
 	complete(&conn->conn_logout_comp);
 
-	iscsit_cause_connection_reinstatement(conn, 1);
+	iscsit_cause_connection_reinstatement(conn, sleep);
 	iscsit_dec_conn_usage_count(conn);
 }
 
@@ -4663,6 +4686,7 @@ int iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)
 	struct iscsi_session *sess;
 	struct se_portal_group *se_tpg = &tpg->tpg_se_tpg;
 	struct se_session *se_sess, *se_sess_tmp;
+	LIST_HEAD(free_list);
 	int session_count = 0;
 
 	spin_lock_bh(&se_tpg->session_lock);
@@ -4684,14 +4708,17 @@ int iscsit_release_sessions_for_tpg(struct iscsi_portal_group *tpg, int force)
 		}
 		atomic_set(&sess->session_reinstatement, 1);
 		spin_unlock(&sess->conn_lock);
-		spin_unlock_bh(&se_tpg->session_lock);
 
-		iscsit_free_session(sess);
-		spin_lock_bh(&se_tpg->session_lock);
+		list_move_tail(&se_sess->sess_list, &free_list);
+	}
+	spin_unlock_bh(&se_tpg->session_lock);
+
+	list_for_each_entry_safe(se_sess, se_sess_tmp, &free_list, sess_list) {
+		sess = (struct iscsi_session *)se_sess->fabric_sess_ptr;
 
+		iscsit_free_session(sess);
 		session_count++;
 	}
-	spin_unlock_bh(&se_tpg->session_lock);
 
 	pr_debug("Released %d iSCSI Session(s) from Target Portal"
 			" Group: %hu\n", session_count, tpg->tpgt);
diff --git a/drivers/target/iscsi/iscsi_target_configfs.c b/drivers/target/iscsi/iscsi_target_configfs.c
index c45b336..200d779 100644
--- a/drivers/target/iscsi/iscsi_target_configfs.c
+++ b/drivers/target/iscsi/iscsi_target_configfs.c
@@ -1730,7 +1730,8 @@ static void lio_tpg_release_fabric_acl(
 }
 
 /*
- * Called with spin_lock_bh(struct se_portal_group->session_lock) held..
+ * Called with spin_lock_irq(struct se_portal_group->session_lock) held
+ * or not held.
  *
  * Also, this function calls iscsit_inc_session_usage_count() on the
  * struct iscsi_session in question.
@@ -1738,19 +1739,32 @@ static void lio_tpg_release_fabric_acl(
 static int lio_tpg_shutdown_session(struct se_session *se_sess)
 {
 	struct iscsi_session *sess = se_sess->fabric_sess_ptr;
+	struct se_portal_group *se_tpg = se_sess->se_tpg;
+	bool local_lock = false;
+
+	if (!spin_is_locked(&se_tpg->session_lock)) {
+		spin_lock_irq(&se_tpg->session_lock);
+		local_lock = true;
+	}
 
 	spin_lock(&sess->conn_lock);
 	if (atomic_read(&sess->session_fall_back_to_erl0) ||
 	    atomic_read(&sess->session_logout) ||
 	    (sess->time2retain_timer_flags & ISCSI_TF_EXPIRED)) {
 		spin_unlock(&sess->conn_lock);
+		if (local_lock)
+			spin_unlock_irq(&sess->conn_lock);
 		return 0;
 	}
 	atomic_set(&sess->session_reinstatement, 1);
 	spin_unlock(&sess->conn_lock);
 
 	iscsit_stop_time2retain_timer(sess);
+	spin_unlock_irq(&se_tpg->session_lock);
+
 	iscsit_stop_session(sess, 1, 1);
+	if (!local_lock)
+		spin_lock_irq(&se_tpg->session_lock);
 
 	return 1;
 }
diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h
index e117870..bf93e1c 100644
--- a/drivers/target/iscsi/iscsi_target_core.h
+++ b/drivers/target/iscsi/iscsi_target_core.h
@@ -586,6 +586,12 @@ struct iscsi_conn {
 	struct iscsi_session	*sess;
 	/* Pointer to thread_set in use for this conn's threads */
 	struct iscsi_thread_set	*thread_set;
+	int			bitmap_id;
+	int			rx_thread_active;
+	struct task_struct	*rx_thread;
+	struct completion	rx_login_comp;
+	int			tx_thread_active;
+	struct task_struct	*tx_thread;
 	/* list_head for session connection list */
 	struct list_head	conn_list;
 } ____cacheline_aligned;
@@ -862,10 +868,12 @@ struct iscsit_global {
 	/* Unique identifier used for the authentication daemon */
 	u32			auth_id;
 	u32			inactive_ts;
+#define ISCSIT_BITMAP_BITS	262144
 	/* Thread Set bitmap count */
 	int			ts_bitmap_count;
 	/* Thread Set bitmap pointer */
 	unsigned long		*ts_bitmap;
+	spinlock_t		ts_bitmap_lock;
 	/* Used for iSCSI discovery session authentication */
 	struct iscsi_node_acl	discovery_acl;
 	struct iscsi_portal_group	*discovery_tpg;
diff --git a/drivers/target/iscsi/iscsi_target_erl0.c b/drivers/target/iscsi/iscsi_target_erl0.c
index 08bd878..fab67ee 100644
--- a/drivers/target/iscsi/iscsi_target_erl0.c
+++ b/drivers/target/iscsi/iscsi_target_erl0.c
@@ -866,7 +866,10 @@ void iscsit_connection_reinstatement_rcfr(struct iscsi_conn *conn)
 	}
 	spin_unlock_bh(&conn->state_lock);
 
-	iscsi_thread_set_force_reinstatement(conn);
+	if (conn->tx_thread && conn->tx_thread_active)
+		send_sig(SIGINT, conn->tx_thread, 1);
+	if (conn->rx_thread && conn->rx_thread_active)
+		send_sig(SIGINT, conn->rx_thread, 1);
 
 sleep:
 	wait_for_completion(&conn->conn_wait_rcfr_comp);
@@ -891,10 +894,10 @@ void iscsit_cause_connection_reinstatement(struct iscsi_conn *conn, int sleep)
 		return;
 	}
 
-	if (iscsi_thread_set_force_reinstatement(conn) < 0) {
-		spin_unlock_bh(&conn->state_lock);
-		return;
-	}
+	if (conn->tx_thread && conn->tx_thread_active)
+		send_sig(SIGINT, conn->tx_thread, 1);
+	if (conn->rx_thread && conn->rx_thread_active)
+		send_sig(SIGINT, conn->rx_thread, 1);
 
 	atomic_set(&conn->connection_reinstatement, 1);
 	if (!sleep) {
diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c
index 0493e8b1..2c4db62 100644
--- a/drivers/target/iscsi/iscsi_target_login.c
+++ b/drivers/target/iscsi/iscsi_target_login.c
@@ -84,6 +84,7 @@ static struct iscsi_login *iscsi_login_init_conn(struct iscsi_conn *conn)
 	init_completion(&conn->conn_logout_comp);
 	init_completion(&conn->rx_half_close_comp);
 	init_completion(&conn->tx_half_close_comp);
+	init_completion(&conn->rx_login_comp);
 	spin_lock_init(&conn->cmd_lock);
 	spin_lock_init(&conn->conn_usage_lock);
 	spin_lock_init(&conn->immed_queue_lock);
@@ -683,7 +684,53 @@ static void iscsi_post_login_start_timers(struct iscsi_conn *conn)
 		iscsit_start_nopin_timer(conn);
 }
 
-static int iscsi_post_login_handler(
+int iscsit_start_kthreads(struct iscsi_conn *conn)
+{
+	int ret = 0;
+
+	spin_lock(&iscsit_global->ts_bitmap_lock);
+	conn->bitmap_id = bitmap_find_free_region(iscsit_global->ts_bitmap,
+					ISCSIT_BITMAP_BITS, get_order(1));
+	spin_unlock(&iscsit_global->ts_bitmap_lock);
+
+	if (conn->bitmap_id < 0) {
+		pr_err("bitmap_find_free_region() failed for"
+		       " iscsit_start_kthreads()\n");
+		return -ENOMEM;
+	}
+
+	conn->tx_thread = kthread_run(iscsi_target_tx_thread, conn,
+				      "%s", ISCSI_TX_THREAD_NAME);
+	if (IS_ERR(conn->tx_thread)) {
+		pr_err("Unable to start iscsi_target_tx_thread\n");
+		ret = PTR_ERR(conn->tx_thread);
+		goto out_bitmap;
+	}
+	conn->tx_thread_active = true;
+
+	conn->rx_thread = kthread_run(iscsi_target_rx_thread, conn,
+				      "%s", ISCSI_RX_THREAD_NAME);
+	if (IS_ERR(conn->rx_thread)) {
+		pr_err("Unable to start iscsi_target_rx_thread\n");
+		ret = PTR_ERR(conn->rx_thread);
+		goto out_tx;
+	}
+	conn->rx_thread_active = true;
+
+	return 0;
+out_tx:
+	send_sig(SIGINT, conn->tx_thread, 1);
+	kthread_stop(conn->tx_thread);
+	conn->tx_thread_active = false;
+out_bitmap:
+	spin_lock(&iscsit_global->ts_bitmap_lock);
+	bitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,
+			      get_order(1));
+	spin_unlock(&iscsit_global->ts_bitmap_lock);
+	return ret;
+}
+
+void iscsi_post_login_handler(
 	struct iscsi_np *np,
 	struct iscsi_conn *conn,
 	u8 zero_tsih)
@@ -693,7 +740,6 @@ static int iscsi_post_login_handler(
 	struct se_session *se_sess = sess->se_sess;
 	struct iscsi_portal_group *tpg = ISCSI_TPG_S(sess);
 	struct se_portal_group *se_tpg = &tpg->tpg_se_tpg;
-	struct iscsi_thread_set *ts;
 
 	iscsit_inc_conn_usage_count(conn);
 
@@ -708,7 +754,6 @@ static int iscsi_post_login_handler(
 	/*
 	 * SCSI Initiator -> SCSI Target Port Mapping
 	 */
-	ts = iscsi_get_thread_set();
 	if (!zero_tsih) {
 		iscsi_set_session_parameters(sess->sess_ops,
 				conn->param_list, 0);
@@ -736,8 +781,6 @@ static int iscsi_post_login_handler(
 		spin_unlock_bh(&sess->conn_lock);
 
 		iscsi_post_login_start_timers(conn);
-
-		iscsi_activate_thread_set(conn, ts);
 		/*
 		 * Determine CPU mask to ensure connection's RX and TX kthreads
 		 * are scheduled on the same CPU.
@@ -745,15 +788,20 @@ static int iscsi_post_login_handler(
 		iscsit_thread_get_cpumask(conn);
 		conn->conn_rx_reset_cpumask = 1;
 		conn->conn_tx_reset_cpumask = 1;
-
+		/*
+		 * Wakeup the sleeping iscsi_target_rx_thread() now that
+		 * iscsi_conn is in TARG_CONN_STATE_LOGGED_IN state.
+		 */
+		complete(&conn->rx_login_comp);
 		iscsit_dec_conn_usage_count(conn);
+
 		if (stop_timer) {
 			spin_lock_bh(&se_tpg->session_lock);
 			iscsit_stop_time2retain_timer(sess);
 			spin_unlock_bh(&se_tpg->session_lock);
 		}
 		iscsit_dec_session_usage_count(sess);
-		return 0;
+		return;
 	}
 
 	iscsi_set_session_parameters(sess->sess_ops, conn->param_list, 1);
@@ -795,7 +843,6 @@ static int iscsi_post_login_handler(
 	spin_unlock_bh(&se_tpg->session_lock);
 
 	iscsi_post_login_start_timers(conn);
-	iscsi_activate_thread_set(conn, ts);
 	/*
 	 * Determine CPU mask to ensure connection's RX and TX kthreads
 	 * are scheduled on the same CPU.
@@ -803,10 +850,12 @@ static int iscsi_post_login_handler(
 	iscsit_thread_get_cpumask(conn);
 	conn->conn_rx_reset_cpumask = 1;
 	conn->conn_tx_reset_cpumask = 1;
-
+	/*
+	 * Wakeup the sleeping iscsi_target_rx_thread() now that
+	 * iscsi_conn is in TARG_CONN_STATE_LOGGED_IN state.
+	 */
+	complete(&conn->rx_login_comp);
 	iscsit_dec_conn_usage_count(conn);
-
-	return 0;
 }
 
 static void iscsi_handle_login_thread_timeout(unsigned long data)
@@ -1282,20 +1331,9 @@ static int __iscsi_target_login_thread(struct iscsi_np *np)
 	if (iscsi_target_start_negotiation(login, conn) < 0)
 		goto new_sess_out;
 
-	if (!conn->sess) {
-		pr_err("struct iscsi_conn session pointer is NULL!\n");
-		goto new_sess_out;
-	}
-
 	iscsi_stop_login_thread_timer(np);
 
-	if (signal_pending(current))
-		goto new_sess_out;
-
-	ret = iscsi_post_login_handler(np, conn, zero_tsih);
-
-	if (ret < 0)
-		goto new_sess_out;
+	iscsi_post_login_handler(np, conn, zero_tsih);
 
 	iscsit_deaccess_np(np, tpg);
 	tpg = NULL;
diff --git a/drivers/target/iscsi/iscsi_target_login.h b/drivers/target/iscsi/iscsi_target_login.h
index 63efd28..6d7eb66 100644
--- a/drivers/target/iscsi/iscsi_target_login.h
+++ b/drivers/target/iscsi/iscsi_target_login.h
@@ -12,6 +12,7 @@ extern int iscsit_accept_np(struct iscsi_np *, struct iscsi_conn *);
 extern int iscsit_get_login_rx(struct iscsi_conn *, struct iscsi_login *);
 extern int iscsit_put_login_tx(struct iscsi_conn *, struct iscsi_login *, u32);
 extern void iscsit_free_conn(struct iscsi_np *, struct iscsi_conn *);
+extern int iscsit_start_kthreads(struct iscsi_conn *);
 extern int iscsi_target_login_thread(void *);
 extern int iscsi_login_disable_FIM_keys(struct iscsi_param_list *, struct iscsi_conn *);
 
diff --git a/drivers/target/iscsi/iscsi_target_nego.c b/drivers/target/iscsi/iscsi_target_nego.c
index 72d9dec..2a61a01 100644
--- a/drivers/target/iscsi/iscsi_target_nego.c
+++ b/drivers/target/iscsi/iscsi_target_nego.c
@@ -19,6 +19,7 @@
  ******************************************************************************/
 
 #include <linux/ctype.h>
+#include <linux/kthread.h>
 #include <scsi/iscsi_proto.h>
 #include <target/target_core_base.h>
 #include <target/target_core_fabric.h>
@@ -352,10 +353,24 @@ static int iscsi_target_do_tx_login_io(struct iscsi_conn *conn, struct iscsi_log
 		ntohl(login_rsp->statsn), login->rsp_length);
 
 	padding = ((-login->rsp_length) & 3);
+	/*
+	 * Before sending the last login response containing the transition
+	 * bit for full-feature-phase, go ahead and start up TX/RX threads
+	 * now to avoid potential resource allocation failures after the
+	 * final login response has been sent.
+	 */
+	if (login->login_complete) {
+		int rc = iscsit_start_kthreads(conn);
+		if (rc) {
+			iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
+					    ISCSI_LOGIN_STATUS_NO_RESOURCES);
+			return -1;
+		}
+	}
 
 	if (conn->conn_transport->iscsit_put_login_tx(conn, login,
 					login->rsp_length + padding) < 0)
-		return -1;
+		goto err;
 
 	login->rsp_length		= 0;
 	mutex_lock(&sess->cmdsn_mutex);
@@ -364,6 +379,24 @@ static int iscsi_target_do_tx_login_io(struct iscsi_conn *conn, struct iscsi_log
 	mutex_unlock(&sess->cmdsn_mutex);
 
 	return 0;
+
+err:
+	if (login->login_complete) {
+		if (conn->rx_thread && conn->rx_thread_active) {
+			send_sig(SIGINT, conn->rx_thread, 1);
+			complete(&conn->rx_login_comp);
+			kthread_stop(conn->rx_thread);
+		}
+		if (conn->tx_thread && conn->tx_thread_active) {
+			send_sig(SIGINT, conn->tx_thread, 1);
+			kthread_stop(conn->tx_thread);
+		}
+		spin_lock(&iscsit_global->ts_bitmap_lock);
+		bitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,
+				      get_order(1));
+		spin_unlock(&iscsit_global->ts_bitmap_lock);
+	}
+	return -1;
 }
 
 static int iscsi_target_do_login_io(struct iscsi_conn *conn, struct iscsi_login *login)
diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c
index b1e77ff..244776b 100644
--- a/drivers/target/target_core_pscsi.c
+++ b/drivers/target/target_core_pscsi.c
@@ -520,6 +520,7 @@ static int pscsi_configure_device(struct se_device *dev)
 					" pdv_host_id: %d\n", pdv->pdv_host_id);
 				return -EINVAL;
 			}
+			pdv->pdv_lld_host = sh;
 		}
 	} else {
 		if (phv->phv_mode == PHV_VIRTUAL_HOST_ID) {
@@ -602,6 +603,8 @@ static void pscsi_free_device(struct se_device *dev)
 		if ((phv->phv_mode == PHV_LLD_SCSI_HOST_NO) &&
 		    (phv->phv_lld_host != NULL))
 			scsi_host_put(phv->phv_lld_host);
+		else if (pdv->pdv_lld_host)
+			scsi_host_put(pdv->pdv_lld_host);
 
 		if ((sd->type == TYPE_DISK) || (sd->type == TYPE_ROM))
 			scsi_device_put(sd);
diff --git a/drivers/target/target_core_pscsi.h b/drivers/target/target_core_pscsi.h
index 1bd757d..820d305 100644
--- a/drivers/target/target_core_pscsi.h
+++ b/drivers/target/target_core_pscsi.h
@@ -45,6 +45,7 @@ struct pscsi_dev_virt {
 	int	pdv_lun_id;
 	struct block_device *pdv_bd;
 	struct scsi_device *pdv_sd;
+	struct Scsi_Host *pdv_lld_host;
 } ____cacheline_aligned;
 
 typedef enum phv_modes {
diff --git a/drivers/target/tcm_fc/tfc_io.c b/drivers/target/tcm_fc/tfc_io.c
index e415af3..c67d379 100644
--- a/drivers/target/tcm_fc/tfc_io.c
+++ b/drivers/target/tcm_fc/tfc_io.c
@@ -346,7 +346,7 @@ void ft_invl_hw_context(struct ft_cmd *cmd)
 		ep = fc_seq_exch(seq);
 		if (ep) {
 			lport = ep->lp;
-			if (lport && (ep->xid <= lport->lro_xid))
+			if (lport && (ep->xid <= lport->lro_xid)) {
 				/*
 				 * "ddp_done" trigger invalidation of HW
 				 * specific DDP context
@@ -361,6 +361,7 @@ void ft_invl_hw_context(struct ft_cmd *cmd)
 				 * identified using ep->xid)
 				 */
 				cmd->was_ddp_setup = 0;
+			}
 		}
 	}
 }
diff --git a/drivers/tty/hvc/hvc_xen.c b/drivers/tty/hvc/hvc_xen.c
index 4fc32c8..ff92155 100644
--- a/drivers/tty/hvc/hvc_xen.c
+++ b/drivers/tty/hvc/hvc_xen.c
@@ -299,11 +299,27 @@ static int xen_initial_domain_console_init(void)
 	return 0;
 }
 
+static void xen_console_update_evtchn(struct xencons_info *info)
+{
+	if (xen_hvm_domain()) {
+		uint64_t v;
+		int err;
+
+		err = hvm_get_parameter(HVM_PARAM_CONSOLE_EVTCHN, &v);
+		if (!err && v)
+			info->evtchn = v;
+	} else
+		info->evtchn = xen_start_info->console.domU.evtchn;
+}
+
 void xen_console_resume(void)
 {
 	struct xencons_info *info = vtermno_to_xencons(HVC_COOKIE);
-	if (info != NULL && info->irq)
+	if (info != NULL && info->irq) {
+		if (!xen_initial_domain())
+			xen_console_update_evtchn(info);
 		rebind_evtchn_irq(info->evtchn, info->irq);
+	}
 }
 
 static void xencons_disconnect_backend(struct xencons_info *info)
diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c
index 7cb3681..deee2b8 100644
--- a/drivers/tty/pty.c
+++ b/drivers/tty/pty.c
@@ -623,7 +623,14 @@ static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
 /* this is called once with whichever end is closed last */
 static void pty_unix98_shutdown(struct tty_struct *tty)
 {
-	devpts_kill_index(tty->driver_data, tty->index);
+	struct inode *ptmx_inode;
+
+	if (tty->driver->subtype == PTY_TYPE_MASTER)
+		ptmx_inode = tty->driver_data;
+	else
+		ptmx_inode = tty->link->driver_data;
+	devpts_kill_index(ptmx_inode, tty->index);
+	devpts_del_ref(ptmx_inode);
 }
 
 static const struct tty_operations ptm_unix98_ops = {
@@ -714,6 +721,18 @@ static int ptmx_open(struct inode *inode, struct file *filp)
 	set_bit(TTY_PTY_LOCK, &tty->flags); /* LOCK THE SLAVE */
 	tty->driver_data = inode;
 
+	/*
+	 * In the case where all references to ptmx inode are dropped and we
+	 * still have /dev/tty opened pointing to the master/slave pair (ptmx
+	 * is closed/released before /dev/tty), we must make sure that the inode
+	 * is still valid when we call the final pty_unix98_shutdown, thus we
+	 * hold an additional reference to the ptmx inode. For the same /dev/tty
+	 * last close case, we also need to make sure the super_block isn't
+	 * destroyed (devpts instance unmounted), before /dev/tty is closed and
+	 * on its release devpts_kill_index is called.
+	 */
+	devpts_add_ref(inode);
+
 	tty_add_file(tty, filp);
 
 	slave_inode = devpts_pty_new(inode,
diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index d8c06a3..1119d53 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -686,22 +686,16 @@ static int size_fifo(struct uart_8250_port *up)
  */
 static unsigned int autoconfig_read_divisor_id(struct uart_8250_port *p)
 {
-	unsigned char old_dll, old_dlm, old_lcr;
-	unsigned int id;
+	unsigned char old_lcr;
+	unsigned int id, old_dl;
 
 	old_lcr = serial_in(p, UART_LCR);
 	serial_out(p, UART_LCR, UART_LCR_CONF_MODE_A);
+	old_dl = serial_dl_read(p);
+	serial_dl_write(p, 0);
+	id = serial_dl_read(p);
+	serial_dl_write(p, old_dl);
 
-	old_dll = serial_in(p, UART_DLL);
-	old_dlm = serial_in(p, UART_DLM);
-
-	serial_out(p, UART_DLL, 0);
-	serial_out(p, UART_DLM, 0);
-
-	id = serial_in(p, UART_DLL) | serial_in(p, UART_DLM) << 8;
-
-	serial_out(p, UART_DLL, old_dll);
-	serial_out(p, UART_DLM, old_dlm);
 	serial_out(p, UART_LCR, old_lcr);
 
 	return id;
diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index 345b5dd..86281fa 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -98,7 +98,10 @@ static void dw8250_serial_out(struct uart_port *p, int offset, int value)
 			dw8250_force_idle(p);
 			writeb(value, p->membase + (UART_LCR << p->regshift));
 		}
-		dev_err(p->dev, "Couldn't set LCR to %d\n", value);
+		/*
+		 * FIXME: this deadlocks if port->lock is already held
+		 * dev_err(p->dev, "Couldn't set LCR to %d\n", value);
+		 */
 	}
 }
 
@@ -128,7 +131,10 @@ static void dw8250_serial_out32(struct uart_port *p, int offset, int value)
 			dw8250_force_idle(p);
 			writel(value, p->membase + (UART_LCR << p->regshift));
 		}
-		dev_err(p->dev, "Couldn't set LCR to %d\n", value);
+		/*
+		 * FIXME: this deadlocks if port->lock is already held
+		 * dev_err(p->dev, "Couldn't set LCR to %d\n", value);
+		 */
 	}
 }
 
diff --git a/drivers/tty/serial/8250/8250_pnp.c b/drivers/tty/serial/8250/8250_pnp.c
index 35d9ab9..91b1420 100644
--- a/drivers/tty/serial/8250/8250_pnp.c
+++ b/drivers/tty/serial/8250/8250_pnp.c
@@ -365,6 +365,11 @@ static const struct pnp_device_id pnp_dev_table[] = {
 	/* Winbond CIR port, should not be probed. We should keep track
 	   of it to prevent the legacy serial driver from probing it */
 	{	"WEC1022",		CIR_PORT	},
+	/*
+	 * SMSC IrCC SIR/FIR port, should not be probed by serial driver
+	 * as well so its own driver can bind to it.
+	 */
+	{	"SMCF010",		CIR_PORT	},
 	{	"",			0	}
 };
 
diff --git a/drivers/tty/serial/ambarella_uart.c b/drivers/tty/serial/ambarella_uart.c
index 6ce799f..768a7e6 100644
--- a/drivers/tty/serial/ambarella_uart.c
+++ b/drivers/tty/serial/ambarella_uart.c
@@ -325,12 +325,8 @@ static inline void serial_ambarella_check_modem_status(struct uart_port *port)
 			port->icount.rng++;
 		if (ms & UART_MS_DSR)
 			port->icount.dsr++;
-
-		/* HW has alread supported CTS handling, so we remove it */
-		/*
 		if (ms & UART_MS_DCTS)
 			uart_handle_cts_change(port, (ms & UART_MS_CTS));
-		*/
 		if (ms & UART_MS_DDCD)
 			uart_handle_dcd_change(port, (ms & UART_MS_DCD));
 
@@ -956,6 +952,8 @@ static void serial_ambarella_shutdown(struct uart_port *port)
 
 	if (amb_port->txdma_used || amb_port->rxdma_used) {
 		serial_ambarella_hw_deinit(amb_port);
+		spin_unlock_irqrestore(&port->lock, flags);
+
 		if (amb_port->txdma_used) {
 			dmaengine_terminate_all(amb_port->tx_dma_chan);
 			serial_ambarella_dma_channel_free(amb_port, false);
@@ -965,11 +963,14 @@ static void serial_ambarella_shutdown(struct uart_port *port)
 			dmaengine_terminate_all(amb_port->rx_dma_chan);
 			serial_ambarella_dma_channel_free(amb_port, true);
 		}
+
+		spin_lock_irqsave(&port->lock, flags);
 	}
 
-	free_irq(port->irq, port);
 	amba_clrbitsl(port->membase + UART_LC_OFFSET, UART_LC_BRK);
 	spin_unlock_irqrestore(&port->lock, flags);
+
+	free_irq(port->irq, port);
 }
 
 static void serial_ambarella_set_termios(struct uart_port *port,
diff --git a/drivers/tty/serial/of_serial.c b/drivers/tty/serial/of_serial.c
index 39c7ea4..2225f83 100644
--- a/drivers/tty/serial/of_serial.c
+++ b/drivers/tty/serial/of_serial.c
@@ -262,7 +262,6 @@ static struct of_device_id of_platform_serial_table[] = {
 	{ .compatible = "ibm,qpace-nwp-serial",
 		.data = (void *)PORT_NWPSERIAL, },
 #endif
-	{ .type = "serial",         .data = (void *)PORT_UNKNOWN, },
 	{ /* end of list */ },
 };
 
diff --git a/drivers/tty/serial/samsung.c b/drivers/tty/serial/samsung.c
index b8366b1..921bf90 100644
--- a/drivers/tty/serial/samsung.c
+++ b/drivers/tty/serial/samsung.c
@@ -724,6 +724,8 @@ static void s3c24xx_serial_set_termios(struct uart_port *port,
 	/* check to see if we need  to change clock source */
 
 	if (ourport->baudclk != clk) {
+		clk_prepare_enable(clk);
+
 		s3c24xx_serial_setsource(port, clk_sel);
 
 		if (!IS_ERR(ourport->baudclk)) {
@@ -731,8 +733,6 @@ static void s3c24xx_serial_set_termios(struct uart_port *port,
 			ourport->baudclk = ERR_PTR(-EINVAL);
 		}
 
-		clk_prepare_enable(clk);
-
 		ourport->baudclk = clk;
 		ourport->baudclk_rate = clk ? clk_get_rate(clk) : 0;
 	}
diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c
index 2967b6e..8977eaf 100644
--- a/drivers/tty/tty_io.c
+++ b/drivers/tty/tty_io.c
@@ -2576,6 +2576,28 @@ static int tiocsetd(struct tty_struct *tty, int __user *p)
 }
 
 /**
+ *	tiocgetd	-	get line discipline
+ *	@tty: tty device
+ *	@p: pointer to user data
+ *
+ *	Retrieves the line discipline id directly from the ldisc.
+ *
+ *	Locking: waits for ldisc reference (in case the line discipline
+ *		is changing or the tty is being hungup)
+ */
+
+static int tiocgetd(struct tty_struct *tty, int __user *p)
+{
+	struct tty_ldisc *ld;
+	int ret;
+
+	ld = tty_ldisc_ref_wait(tty);
+	ret = put_user(ld->ops->num, p);
+	tty_ldisc_deref(ld);
+	return ret;
+}
+
+/**
  *	send_break	-	performed time break
  *	@tty: device to break on
  *	@duration: timeout in mS
@@ -2789,7 +2811,7 @@ long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	case TIOCGSID:
 		return tiocgsid(tty, real_tty, p);
 	case TIOCGETD:
-		return put_user(tty->ldisc->ops->num, (int __user *)p);
+		return tiocgetd(tty, p);
 	case TIOCSETD:
 		return tiocsetd(tty, p);
 	case TIOCVHANGUP:
diff --git a/drivers/tty/vt/keyboard.c b/drivers/tty/vt/keyboard.c
index a9af1b9a..1f6e096 100644
--- a/drivers/tty/vt/keyboard.c
+++ b/drivers/tty/vt/keyboard.c
@@ -371,34 +371,22 @@ static void to_utf8(struct vc_data *vc, uint c)
 
 static void do_compute_shiftstate(void)
 {
-	unsigned int i, j, k, sym, val;
+	unsigned int k, sym, val;
 
 	shift_state = 0;
 	memset(shift_down, 0, sizeof(shift_down));
 
-	for (i = 0; i < ARRAY_SIZE(key_down); i++) {
-
-		if (!key_down[i])
+	for_each_set_bit(k, key_down, min(NR_KEYS, KEY_CNT)) {
+		sym = U(key_maps[0][k]);
+		if (KTYP(sym) != KT_SHIFT && KTYP(sym) != KT_SLOCK)
 			continue;
 
-		k = i * BITS_PER_LONG;
-
-		for (j = 0; j < BITS_PER_LONG; j++, k++) {
-
-			if (!test_bit(k, key_down))
-				continue;
+		val = KVAL(sym);
+		if (val == KVAL(K_CAPSSHIFT))
+			val = KVAL(K_SHIFT);
 
-			sym = U(key_maps[0][k]);
-			if (KTYP(sym) != KT_SHIFT && KTYP(sym) != KT_SLOCK)
-				continue;
-
-			val = KVAL(sym);
-			if (val == KVAL(K_CAPSSHIFT))
-				val = KVAL(K_SHIFT);
-
-			shift_down[val]++;
-			shift_state |= (1 << val);
-		}
+		shift_down[val]++;
+		shift_state |= BIT(val);
 	}
 }
 
diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c
index db9d69f..6dff194 100644
--- a/drivers/tty/vt/vt.c
+++ b/drivers/tty/vt/vt.c
@@ -3534,9 +3534,10 @@ static int do_register_con_driver(const struct consw *csw, int first, int last)
 		goto err;
 
 	desc = csw->con_startup();
-
-	if (!desc)
+	if (!desc) {
+		retval = -ENODEV;
 		goto err;
+	}
 
 	retval = -EINVAL;
 
diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index 2800776..e7436eb 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -997,6 +997,9 @@ static int acm_probe(struct usb_interface *intf,
 	if (quirks == NO_UNION_NORMAL) {
 		data_interface = usb_ifnum_to_if(usb_dev, 1);
 		control_interface = usb_ifnum_to_if(usb_dev, 0);
+		/* we would crash */
+		if (!data_interface || !control_interface)
+			return -ENODEV;
 		goto skip_normal_probe;
 	}
 
@@ -1726,6 +1729,16 @@ static const struct usb_device_id acm_ids[] = {
 	},
 #endif
 
+	/*Samsung phone in firmware update mode */
+	{ USB_DEVICE(0x04e8, 0x685d),
+	.driver_info = IGNORE_DEVICE,
+	},
+
+	/* Exclude Infineon Flash Loader utility */
+	{ USB_DEVICE(0x058b, 0x0041),
+	.driver_info = IGNORE_DEVICE,
+	},
+
 	/* control interfaces without any protocol set */
 	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
 		USB_CDC_PROTO_NONE) },
diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c
index 6463ca3..07133d0 100644
--- a/drivers/usb/class/cdc-wdm.c
+++ b/drivers/usb/class/cdc-wdm.c
@@ -244,7 +244,7 @@ static void wdm_int_callback(struct urb *urb)
 	case USB_CDC_NOTIFY_RESPONSE_AVAILABLE:
 		dev_dbg(&desc->intf->dev,
 			"NOTIFY_RESPONSE_AVAILABLE received: index %d len %d",
-			dr->wIndex, dr->wLength);
+			le16_to_cpu(dr->wIndex), le16_to_cpu(dr->wLength));
 		break;
 
 	case USB_CDC_NOTIFY_NETWORK_CONNECTION:
@@ -257,7 +257,9 @@ static void wdm_int_callback(struct urb *urb)
 		clear_bit(WDM_POLL_RUNNING, &desc->flags);
 		dev_err(&desc->intf->dev,
 			"unknown notification %d received: index %d len %d\n",
-			dr->bNotificationType, dr->wIndex, dr->wLength);
+			dr->bNotificationType,
+			le16_to_cpu(dr->wIndex),
+			le16_to_cpu(dr->wLength));
 		goto exit;
 	}
 
@@ -403,7 +405,7 @@ static ssize_t wdm_write
 			     USB_RECIP_INTERFACE);
 	req->bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;
 	req->wValue = 0;
-	req->wIndex = desc->inum;
+	req->wIndex = desc->inum; /* already converted */
 	req->wLength = cpu_to_le16(count);
 	set_bit(WDM_IN_USE, &desc->flags);
 	desc->outbuf = buf;
@@ -417,7 +419,7 @@ static ssize_t wdm_write
 		rv = usb_translate_errors(rv);
 	} else {
 		dev_dbg(&desc->intf->dev, "Tx URB has been submitted index=%d",
-			req->wIndex);
+			le16_to_cpu(req->wIndex));
 	}
 out:
 	usb_autopm_put_interface(desc->intf);
@@ -780,7 +782,7 @@ static int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor
 	desc->irq->bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);
 	desc->irq->bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;
 	desc->irq->wValue = 0;
-	desc->irq->wIndex = desc->inum;
+	desc->irq->wIndex = desc->inum; /* already converted */
 	desc->irq->wLength = cpu_to_le16(desc->wMaxCommand);
 
 	usb_fill_control_urb(
diff --git a/drivers/usb/class/usblp.c b/drivers/usb/class/usblp.c
index d4c47d5..7ac5fac 100644
--- a/drivers/usb/class/usblp.c
+++ b/drivers/usb/class/usblp.c
@@ -870,11 +870,11 @@ static int usblp_wwait(struct usblp *usblp, int nonblock)
 
 	add_wait_queue(&usblp->wwait, &waita);
 	for (;;) {
-		set_current_state(TASK_INTERRUPTIBLE);
 		if (mutex_lock_interruptible(&usblp->mut)) {
 			rc = -EINTR;
 			break;
 		}
+		set_current_state(TASK_INTERRUPTIBLE);
 		rc = usblp_wtest(usblp, nonblock);
 		mutex_unlock(&usblp->mut);
 		if (rc <= 0)
diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 6524383..9b05e88 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -114,16 +114,18 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 				cfgno, inum, asnum, ep->desc.bEndpointAddress);
 		ep->ss_ep_comp.bmAttributes = 16;
 	} else if (usb_endpoint_xfer_isoc(&ep->desc) &&
-			desc->bmAttributes > 2) {
+		   USB_SS_MULT(desc->bmAttributes) > 3) {
 		dev_warn(ddev, "Isoc endpoint has Mult of %d in "
 				"config %d interface %d altsetting %d ep %d: "
-				"setting to 3\n", desc->bmAttributes + 1,
+				"setting to 3\n",
+				USB_SS_MULT(desc->bmAttributes),
 				cfgno, inum, asnum, ep->desc.bEndpointAddress);
 		ep->ss_ep_comp.bmAttributes = 2;
 	}
 
 	if (usb_endpoint_xfer_isoc(&ep->desc))
-		max_tx = (desc->bMaxBurst + 1) * (desc->bmAttributes + 1) *
+		max_tx = (desc->bMaxBurst + 1) *
+			(USB_SS_MULT(desc->bmAttributes)) *
 			usb_endpoint_maxp(&ep->desc);
 	else if (usb_endpoint_xfer_int(&ep->desc))
 		max_tx = usb_endpoint_maxp(&ep->desc) *
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 78ddfb4..cfce807 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -513,7 +513,7 @@ static void async_completed(struct urb *urb)
 	snoop(&urb->dev->dev, "urb complete\n");
 	snoop_urb(urb->dev, as->userurb, urb->pipe, urb->actual_length,
 			as->status, COMPLETE, NULL, 0);
-	if ((urb->transfer_flags & URB_DIR_MASK) == USB_DIR_IN)
+	if ((urb->transfer_flags & URB_DIR_MASK) == URB_DIR_IN)
 		snoop_urb_data(urb, urb->actual_length);
 
 	if (as->status < 0 && as->bulk_addr && as->status != -ECONNRESET &&
@@ -1106,10 +1106,11 @@ static int proc_getdriver(struct dev_state *ps, void __user *arg)
 
 static int proc_connectinfo(struct dev_state *ps, void __user *arg)
 {
-	struct usbdevfs_connectinfo ci = {
-		.devnum = ps->dev->devnum,
-		.slow = ps->dev->speed == USB_SPEED_LOW
-	};
+	struct usbdevfs_connectinfo ci;
+
+	memset(&ci, 0, sizeof(ci));
+	ci.devnum = ps->dev->devnum;
+	ci.slow = ps->dev->speed == USB_SPEED_LOW;
 
 	if (copy_to_user(arg, &ci, sizeof(ci)))
 		return -EFAULT;
@@ -1593,7 +1594,7 @@ static struct async *reap_as(struct dev_state *ps)
 	for (;;) {
 		__set_current_state(TASK_INTERRUPTIBLE);
 		as = async_getcompleted(ps);
-		if (as)
+		if (as || !connected(ps))
 			break;
 		if (signal_pending(current))
 			break;
@@ -1616,7 +1617,7 @@ static int proc_reapurb(struct dev_state *ps, void __user *arg)
 	}
 	if (signal_pending(current))
 		return -EINTR;
-	return -EIO;
+	return -ENODEV;
 }
 
 static int proc_reapurbnonblock(struct dev_state *ps, void __user *arg)
@@ -1625,10 +1626,11 @@ static int proc_reapurbnonblock(struct dev_state *ps, void __user *arg)
 	struct async *as;
 
 	as = async_getcompleted(ps);
-	retval = -EAGAIN;
 	if (as) {
 		retval = processcompl(as, (void __user * __user *)arg);
 		free_async(as);
+	} else {
+		retval = (connected(ps) ? -EAGAIN : -ENODEV);
 	}
 	return retval;
 }
@@ -1758,7 +1760,7 @@ static int proc_reapurb_compat(struct dev_state *ps, void __user *arg)
 	}
 	if (signal_pending(current))
 		return -EINTR;
-	return -EIO;
+	return -ENODEV;
 }
 
 static int proc_reapurbnonblock_compat(struct dev_state *ps, void __user *arg)
@@ -1766,11 +1768,12 @@ static int proc_reapurbnonblock_compat(struct dev_state *ps, void __user *arg)
 	int retval;
 	struct async *as;
 
-	retval = -EAGAIN;
 	as = async_getcompleted(ps);
 	if (as) {
 		retval = processcompl_compat(as, (void __user * __user *)arg);
 		free_async(as);
+	} else {
+		retval = (connected(ps) ? -EAGAIN : -ENODEV);
 	}
 	return retval;
 }
@@ -1941,7 +1944,8 @@ static int proc_get_capabilities(struct dev_state *ps, void __user *arg)
 {
 	__u32 caps;
 
-	caps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM;
+	caps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM |
+			USBDEVFS_CAP_REAP_AFTER_DISCONNECT;
 	if (!ps->dev->bus->no_stop_on_short)
 		caps |= USBDEVFS_CAP_BULK_CONTINUATION;
 	if (ps->dev->bus->sg_tablesize)
@@ -2002,6 +2006,32 @@ static long usbdev_do_ioctl(struct file *file, unsigned int cmd,
 		return -EPERM;
 
 	usb_lock_device(dev);
+
+	/* Reap operations are allowed even after disconnection */
+	switch (cmd) {
+	case USBDEVFS_REAPURB:
+		snoop(&dev->dev, "%s: REAPURB\n", __func__);
+		ret = proc_reapurb(ps, p);
+		goto done;
+
+	case USBDEVFS_REAPURBNDELAY:
+		snoop(&dev->dev, "%s: REAPURBNDELAY\n", __func__);
+		ret = proc_reapurbnonblock(ps, p);
+		goto done;
+
+#ifdef CONFIG_COMPAT
+	case USBDEVFS_REAPURB32:
+		snoop(&dev->dev, "%s: REAPURB32\n", __func__);
+		ret = proc_reapurb_compat(ps, p);
+		goto done;
+
+	case USBDEVFS_REAPURBNDELAY32:
+		snoop(&dev->dev, "%s: REAPURBNDELAY32\n", __func__);
+		ret = proc_reapurbnonblock_compat(ps, p);
+		goto done;
+#endif
+	}
+
 	if (!connected(ps)) {
 		usb_unlock_device(dev);
 		return -ENODEV;
@@ -2095,16 +2125,6 @@ static long usbdev_do_ioctl(struct file *file, unsigned int cmd,
 			inode->i_mtime = CURRENT_TIME;
 		break;
 
-	case USBDEVFS_REAPURB32:
-		snoop(&dev->dev, "%s: REAPURB32\n", __func__);
-		ret = proc_reapurb_compat(ps, p);
-		break;
-
-	case USBDEVFS_REAPURBNDELAY32:
-		snoop(&dev->dev, "%s: REAPURBNDELAY32\n", __func__);
-		ret = proc_reapurbnonblock_compat(ps, p);
-		break;
-
 	case USBDEVFS_IOCTL32:
 		snoop(&dev->dev, "%s: IOCTL32\n", __func__);
 		ret = proc_ioctl_compat(ps, ptr_to_compat(p));
@@ -2116,16 +2136,6 @@ static long usbdev_do_ioctl(struct file *file, unsigned int cmd,
 		ret = proc_unlinkurb(ps, p);
 		break;
 
-	case USBDEVFS_REAPURB:
-		snoop(&dev->dev, "%s: REAPURB\n", __func__);
-		ret = proc_reapurb(ps, p);
-		break;
-
-	case USBDEVFS_REAPURBNDELAY:
-		snoop(&dev->dev, "%s: REAPURBNDELAY\n", __func__);
-		ret = proc_reapurbnonblock(ps, p);
-		break;
-
 	case USBDEVFS_DISCSIGNAL:
 		snoop(&dev->dev, "%s: DISCSIGNAL\n", __func__);
 		ret = proc_disconnectsignal(ps, p);
@@ -2162,6 +2172,8 @@ static long usbdev_do_ioctl(struct file *file, unsigned int cmd,
 		ret = proc_disconnect_claim(ps, p);
 		break;
 	}
+
+ done:
 	usb_unlock_device(dev);
 	if (ret >= 0)
 		inode->i_atime = CURRENT_TIME;
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 2cdd507..f7310dd 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -461,11 +461,15 @@ static int usb_unbind_interface(struct device *dev)
 int usb_driver_claim_interface(struct usb_driver *driver,
 				struct usb_interface *iface, void *priv)
 {
-	struct device *dev = &iface->dev;
+	struct device *dev;
 	struct usb_device *udev;
 	int retval = 0;
 	int lpm_disable_error;
 
+	if (!iface)
+		return -ENODEV;
+
+	dev = &iface->dev;
 	if (dev->driver)
 		return -EBUSY;
 
diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 4676917..1eac8dd 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -74,6 +74,15 @@ static void for_each_companion(struct pci_dev *pdev, struct usb_hcd *hcd,
 		if (companion->bus != pdev->bus ||
 				PCI_SLOT(companion->devfn) != slot)
 			continue;
+
+		/*
+		 * Companion device should be either UHCI,OHCI or EHCI host
+		 * controller, otherwise skip.
+		 */
+		if (companion->class != CL_UHCI && companion->class != CL_OHCI &&
+				companion->class != CL_EHCI)
+			continue;
+
 		companion_hcd = pci_get_drvdata(companion);
 		if (!companion_hcd || !companion_hcd->self.root_hub)
 			continue;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c9f56ff..4e5156d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -113,6 +113,7 @@ EXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);
 #define HUB_DEBOUNCE_STEP	  25
 #define HUB_DEBOUNCE_STABLE	 100
 
+static void hub_release(struct kref *kref);
 static int usb_reset_and_verify_device(struct usb_device *udev);
 
 static inline char *portspeed(struct usb_hub *hub, int portstatus)
@@ -137,6 +138,10 @@ struct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)
 
 static int usb_device_supports_lpm(struct usb_device *udev)
 {
+	/* Some devices have trouble with LPM */
+	if (udev->quirks & USB_QUIRK_NO_LPM)
+		return 0;
+
 	/* USB 2.1 (and greater) devices indicate LPM support through
 	 * their USB 2.0 Extended Capabilities BOS descriptor.
 	 */
@@ -1020,10 +1025,20 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	unsigned delay;
 
 	/* Continue a partial initialization */
-	if (type == HUB_INIT2)
-		goto init2;
-	if (type == HUB_INIT3)
+	if (type == HUB_INIT2 || type == HUB_INIT3) {
+		device_lock(hub->intfdev);
+
+		/* Was the hub disconnected while we were waiting? */
+		if (hub->disconnected) {
+			device_unlock(hub->intfdev);
+			kref_put(&hub->kref, hub_release);
+			return;
+		}
+		if (type == HUB_INIT2)
+			goto init2;
 		goto init3;
+	}
+	kref_get(&hub->kref);
 
 	/* The superspeed hub except for root hub has to use Hub Depth
 	 * value as an offset into the route string to locate the bits
@@ -1220,6 +1235,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 			PREPARE_DELAYED_WORK(&hub->init_work, hub_init_func3);
 			schedule_delayed_work(&hub->init_work,
 					msecs_to_jiffies(delay));
+			device_unlock(hub->intfdev);
 			return;		/* Continues at init3: below */
 		} else {
 			msleep(delay);
@@ -1240,6 +1256,11 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	/* Allow autosuspend if it was suppressed */
 	if (type <= HUB_INIT3)
 		usb_autopm_put_interface_async(to_usb_interface(hub->intfdev));
+
+	if (type == HUB_INIT2 || type == HUB_INIT3)
+		device_unlock(hub->intfdev);
+
+	kref_put(&hub->kref, hub_release);
 }
 
 /* Implement the continuations for the delays above */
@@ -3282,10 +3303,10 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 		dev_dbg(hub->intfdev, "can't resume port %d, status %d\n",
 				port1, status);
 	} else {
-		/* drive resume for at least 20 msec */
+		/* drive resume for USB_RESUME_TIMEOUT msec */
 		dev_dbg(&udev->dev, "usb %sresume\n",
 				(PMSG_IS_AUTO(msg) ? "auto-" : ""));
-		msleep(25);
+		msleep(USB_RESUME_TIMEOUT);
 
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
 		 * stop resume signaling.  Then finish the resume
@@ -4163,7 +4184,13 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 						r = -EPROTO;
 					break;
 				}
-				if (r == 0)
+				/*
+				 * Some devices time out if they are powered on
+				 * when already connected. They need a second
+				 * reset. But only on the first attempt,
+				 * lest we get into a time out/reset loop
+				 */
+				if (r == 0  || (r == -ETIMEDOUT && j == 0))
 					break;
 			}
 			udev->descriptor.bMaxPacketSize0 =
@@ -4289,6 +4316,8 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 		goto fail;
 	}
 
+	usb_detect_quirks(udev);
+
 	if (udev->wusb == 0 && le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0201) {
 		retval = usb_get_bos_descriptor(udev);
 		if (!retval) {
@@ -4530,7 +4559,6 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		if (status < 0)
 			goto loop;
 
-		usb_detect_quirks(udev);
 		if (udev->quirks & USB_QUIRK_DELAY_INIT)
 			msleep(1000);
 
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index b73f303..aa27ec1 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -53,6 +53,13 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x046d, 0x082d), .driver_info = USB_QUIRK_DELAY_INIT },
 	{ USB_DEVICE(0x046d, 0x0843), .driver_info = USB_QUIRK_DELAY_INIT },
 
+	/* Logitech ConferenceCam CC3000e */
+	{ USB_DEVICE(0x046d, 0x0847), .driver_info = USB_QUIRK_DELAY_INIT },
+	{ USB_DEVICE(0x046d, 0x0848), .driver_info = USB_QUIRK_DELAY_INIT },
+
+	/* Logitech PTZ Pro Camera */
+	{ USB_DEVICE(0x046d, 0x0853), .driver_info = USB_QUIRK_DELAY_INIT },
+
 	/* Logitech Quickcam Fusion */
 	{ USB_DEVICE(0x046d, 0x08c1), .driver_info = USB_QUIRK_RESET_RESUME },
 
@@ -77,6 +84,12 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* Philips PSC805 audio device */
 	{ USB_DEVICE(0x0471, 0x0155), .driver_info = USB_QUIRK_RESET_RESUME },
 
+	/* Plantronic Audio 655 DSP */
+	{ USB_DEVICE(0x047f, 0xc008), .driver_info = USB_QUIRK_RESET_RESUME },
+
+	/* Plantronic Audio 648 USB */
+	{ USB_DEVICE(0x047f, 0xc013), .driver_info = USB_QUIRK_RESET_RESUME },
+
 	/* Artisman Watchdog Dongle */
 	{ USB_DEVICE(0x04b4, 0x0526), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },
@@ -157,6 +170,16 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* INTEL VALUE SSD */
 	{ USB_DEVICE(0x8086, 0xf1a5), .driver_info = USB_QUIRK_RESET_RESUME },
 
+	/* ASUS Base Station(T100) */
+	{ USB_DEVICE(0x0b05, 0x17e0), .driver_info =
+			USB_QUIRK_IGNORE_REMOTE_WAKEUP },
+
+	/* Blackmagic Design Intensity Shuttle */
+	{ USB_DEVICE(0x1edb, 0xbd3b), .driver_info = USB_QUIRK_NO_LPM },
+
+	/* Blackmagic Design UltraStudio SDI */
+	{ USB_DEVICE(0x1edb, 0xbd4f), .driver_info = USB_QUIRK_NO_LPM },
+
 	{ }  /* terminating entry must be last */
 };
 
@@ -165,10 +188,6 @@ static const struct usb_device_id usb_interface_quirk_list[] = {
 	{ USB_VENDOR_AND_INTERFACE_INFO(0x046d, USB_CLASS_VIDEO, 1, 0),
 	  .driver_info = USB_QUIRK_RESET_RESUME },
 
-	/* ASUS Base Station(T100) */
-	{ USB_DEVICE(0x0b05, 0x17e0), .driver_info =
-			USB_QUIRK_IGNORE_REMOTE_WAKEUP },
-
 	{ }  /* terminating entry must be last */
 };
 
diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c
index 6cd418f..27040a6 100644
--- a/drivers/usb/dwc3/ep0.c
+++ b/drivers/usb/dwc3/ep0.c
@@ -718,6 +718,10 @@ static int dwc3_ep0_std_request(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 		dev_vdbg(dwc->dev, "USB_REQ_SET_ISOCH_DELAY\n");
 		ret = dwc3_ep0_set_isoch_delay(dwc, ctrl);
 		break;
+	case USB_REQ_SET_INTERFACE:
+		dev_vdbg(dwc->dev, "USB_REQ_SET_INTERFACE\n");
+		dwc->start_config_issued = false;
+		/* Fall through */
 	default:
 		dev_vdbg(dwc->dev, "Forwarding to gadget driver\n");
 		ret = dwc3_ep0_delegate_req(dwc, ctrl);
@@ -800,6 +804,11 @@ static void dwc3_ep0_complete_data(struct dwc3 *dwc,
 		unsigned maxp = ep0->endpoint.maxpacket;
 
 		transfer_size += (maxp - (transfer_size % maxp));
+
+		/* Maximum of DWC3_EP0_BOUNCE_SIZE can only be received */
+		if (transfer_size > DWC3_EP0_BOUNCE_SIZE)
+			transfer_size = DWC3_EP0_BOUNCE_SIZE;
+
 		transferred = min_t(u32, ur->length,
 				transfer_size - length);
 		memcpy(ur->buf, dwc->ep0_bounce, transferred);
@@ -912,11 +921,14 @@ static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,
 			return;
 		}
 
-		WARN_ON(req->request.length > DWC3_EP0_BOUNCE_SIZE);
-
 		maxpacket = dep->endpoint.maxpacket;
 		transfer_size = roundup(req->request.length, maxpacket);
 
+		if (transfer_size > DWC3_EP0_BOUNCE_SIZE) {
+			dev_WARN(dwc->dev, "bounce buf can't handle req len\n");
+			transfer_size = DWC3_EP0_BOUNCE_SIZE;
+		}
+
 		dwc->ep0_bounced = true;
 
 		/*
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index 87f8fc6..6e70c88 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -319,6 +319,8 @@ int dwc3_send_gadget_generic_command(struct dwc3 *dwc, int cmd, u32 param)
 		if (!(reg & DWC3_DGCMD_CMDACT)) {
 			dev_vdbg(dwc->dev, "Command Complete --> %d\n",
 					DWC3_DGCMD_STATUS(reg));
+			if (DWC3_DGCMD_STATUS(reg))
+				return -EINVAL;
 			return 0;
 		}
 
@@ -355,6 +357,8 @@ int dwc3_send_gadget_ep_cmd(struct dwc3 *dwc, unsigned ep,
 		if (!(reg & DWC3_DEPCMD_CMDACT)) {
 			dev_vdbg(dwc->dev, "Command Complete --> %d\n",
 					DWC3_DEPCMD_STATUS(reg));
+			if (DWC3_DEPCMD_STATUS(reg))
+				return -EINVAL;
 			return 0;
 		}
 
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index a4b0756..1fdee11 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -832,7 +832,8 @@ config USB_G_PRINTER
 
 config USB_AMB_STREAM
 	tristate "Gadget Ambarella Data Streaming"
-	depends on USB_GADGET_AMBARELLA
+	depends on USB_AMBARELLA
+	select USB_LIBCOMPOSITE
 	help
 	  Gadget Ambarella Data Streaming is a single-configuration
 	  single-interface device.
diff --git a/drivers/usb/gadget/amb_stream.c b/drivers/usb/gadget/amb_stream.c
index f222a1a..ae69b4f 100644
--- a/drivers/usb/gadget/amb_stream.c
+++ b/drivers/usb/gadget/amb_stream.c
@@ -11,16 +11,6 @@
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the
-* Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-* Boston, MA  02111-1307, USA.
 */
 
 
@@ -33,34 +23,40 @@
  *
  */
 
-//#define DEBUG 1
-// #define VERBOSE
-
-#include <linux/utsname.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+
+#include <linux/usb/composite.h>
 #include <linux/device.h>
 #include <linux/cdev.h>
 #include <linux/fs.h>
+#include <linux/module.h>
 #include <asm/uaccess.h>
 
-#include <linux/usb/ch9.h>
-#include <linux/usb/gadget.h>
-
 #include "gadget_chips.h"
 
 #include <mach/hardware.h>
 
-#include "usbstring.c"
-#include "config.c"
-#include "epautoconf.c"
-
-#define DRIVER_VERSION		"1 Jan 2009"
+USB_GADGET_COMPOSITE_OPTIONS();
 
-static const char shortname [] = "g_amb_stream";
-static const char longname [] = "Ambarella Data Streaming Gadget";
+#define DRIVER_VERSION		"15 July 2016"
 
+static const char shortname[] = "g_amb_stream";
+static const char longname[] = "Ambarella Data Streaming Gadget";
 
+/* ==========================================================================*/
+#define	AMBA_DEV_MAJOR			(248)
+#define	AMBA_DEV_MINOR_PUBLIC_START	(128)
+#define	AMBA_DEV_MINOR_PUBLIC_END	(240)
 /*-------------------------------------------------------------------------*/
-
 #ifdef DEBUG
 #define AMB_DBG(dev,fmt,args...) \
 	dev_printk(KERN_DEBUG , &(dev)->gadget->dev , fmt , ## args)
@@ -74,8 +70,14 @@ static const char longname [] = "Ambarella Data Streaming Gadget";
 
 #define AMB_INFO(dev,fmt,args...) \
 	dev_printk(KERN_INFO , &(dev)->gadget->dev , fmt , ## args)
+/*-------------------------------------------------------------------------*/
+#define AMB_GADGET_MAJOR			AMBA_DEV_MAJOR
+#define AMB_GADGET_MINOR_START		(AMBA_DEV_MINOR_PUBLIC_START + 0)
+/*-------------------------------------------------------------------------*/
+static struct cdev ag_cdev;
 
-
+/* big enough to hold our biggest descriptor */
+#define USB_BUFSIZ	256
 /*-------------------------------------------------------------------------*/
 #define AG_NOTIFY_INTERVAL		5	/* 1 << 5 == 32 msec */
 #define AG_NOTIFY_MAXPACKET		8
@@ -126,56 +128,42 @@ struct amb_notify g_port = {
 };
 
 /*-------------------------------------------------------------------------*/
-
 #define AMB_DATA_STREAM_MAGIC	'u'
 #define AMB_DATA_STREAM_WR_RSP	_IOW(AMB_DATA_STREAM_MAGIC, 1, struct amb_rsp *)
 #define AMB_DATA_STREAM_RD_CMD	_IOR(AMB_DATA_STREAM_MAGIC, 1, struct amb_cmd *)
 #define AMB_DATA_STREAM_STATUS_CHANGE	_IOW(AMB_DATA_STREAM_MAGIC, 2, struct amb_notify *)
-
 /*-------------------------------------------------------------------------*/
-
-#define AMB_GADGET_MAJOR		AMBA_DEV_MAJOR
-#define AMB_GADGET_MINOR_START		(AMBA_DEV_MINOR_PUBLIC_START + 0)
-
-static struct cdev ag_cdev;
-
-/* big enough to hold our biggest descriptor */
-#define USB_BUFSIZ	256
-
 struct amb_dev {
 	spinlock_t		lock;
 	wait_queue_head_t	wq;
 	struct mutex		mtx;
 
-	u8			config;
-
+	int 				config;
 	struct usb_gadget	*gadget;
-	struct usb_request	*ctrl_req;
 	struct usb_request	*notify_req;
 
 	struct usb_ep		*in_ep;
 	struct usb_ep		*out_ep;
 	struct usb_ep		*notify_ep;
-	/* ep descriptor */
-	struct usb_endpoint_descriptor *in_ep_desc;
-	struct usb_endpoint_descriptor *out_ep_desc;
-	struct usb_endpoint_descriptor *notify_ep_desc;
 
 	struct list_head		in_idle_list;	/* list of idle write requests */
 	struct list_head		in_queue_list;	/* list of queueing write requests */
 	struct list_head		out_req_list;	/* list of bulk out requests */
 
+	struct usb_function		func;
+
 	int			open_count;
 	int			error;
+	char		interface;
 };
 
 struct amb_dev *ag_device;
-
+static dev_t ag_dev_id;
+static struct class *ag_class;
+/*-------------------------------------------------------------------------*/
 static void notify_worker(struct work_struct *work);
 static DECLARE_WORK(notify_work, notify_worker);
-
 /*-------------------------------------------------------------------------*/
-
 static unsigned int buflen = (48*1024);
 module_param (buflen, uint, S_IRUGO);
 MODULE_PARM_DESC(buflen, "buffer length, default=48K");
@@ -183,34 +171,28 @@ MODULE_PARM_DESC(buflen, "buffer length, default=48K");
 static unsigned int qdepth = 5;
 module_param (qdepth, uint, S_IRUGO);
 MODULE_PARM_DESC(qdepth, "bulk transfer queue depth, default=5");
-
 /*-------------------------------------------------------------------------*/
-
 /*
  * DESCRIPTORS ... most are static, but strings and (full)
  * configuration descriptors are built on demand.
  */
 
-#define STRING_MANUFACTURER		25
-#define STRING_PRODUCT			42
-#define STRING_SERIAL			101
-#define STRING_SOURCE_SINK		250
+#define STRING_SOURCE_SINK		USB_GADGET_FIRST_AVAIL_IDX
 
 #define DRIVER_VENDOR_ID	0x4255		/* Ambarella */
 #define DRIVER_PRODUCT_ID	0x0001
 
+#define DEV_CONFIG_VALUE		1
+
 static struct usb_device_descriptor ag_device_desc = {
 	.bLength =		sizeof ag_device_desc,
 	.bDescriptorType =	USB_DT_DEVICE,
 
-	.bcdUSB =		__constant_cpu_to_le16 (0x0200),
+	.bcdUSB =		cpu_to_le16 (0x0200),
 	.bDeviceClass =		USB_CLASS_VENDOR_SPEC,
 
-	.idVendor =		__constant_cpu_to_le16 (DRIVER_VENDOR_ID),
-	.idProduct =		__constant_cpu_to_le16 (DRIVER_PRODUCT_ID),
-	.iManufacturer =	STRING_MANUFACTURER,
-	.iProduct =		STRING_PRODUCT,
-	.iSerialNumber =	STRING_SERIAL,
+	.idVendor =		cpu_to_le16 (DRIVER_VENDOR_ID),
+	.idProduct =		cpu_to_le16 (DRIVER_PRODUCT_ID),
 	.bNumConfigurations =	1,
 };
 
@@ -219,18 +201,9 @@ static struct usb_config_descriptor amb_bulk_config = {
 	.bDescriptorType =	USB_DT_CONFIG,
 
 	.bNumInterfaces =	1,
-	.bConfigurationValue =	1,
+	.bConfigurationValue =	DEV_CONFIG_VALUE,
 	.iConfiguration =	STRING_SOURCE_SINK,
 	.bmAttributes =		USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
-	.bMaxPower =		1,	/* self-powered */
-};
-
-
-static struct usb_otg_descriptor otg_descriptor = {
-	.bLength =		sizeof otg_descriptor,
-	.bDescriptorType =	USB_DT_OTG,
-
-	.bmAttributes =		USB_OTG_SRP,
 };
 
 /* one interface in each configuration */
@@ -243,7 +216,6 @@ static struct usb_interface_descriptor amb_data_stream_intf = {
 	.iInterface =		STRING_SOURCE_SINK,
 };
 
-
 /* two full speed bulk endpoints; their use is config-dependent */
 
 static struct usb_endpoint_descriptor fs_bulk_in_desc = {
@@ -267,12 +239,11 @@ static struct usb_endpoint_descriptor fs_intr_in_desc = {
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
-	.wMaxPacketSize =	__constant_cpu_to_le16(AG_NOTIFY_MAXPACKET),
+	.wMaxPacketSize =	cpu_to_le16(AG_NOTIFY_MAXPACKET),
 	.bInterval =		1 << AG_NOTIFY_INTERVAL,
 };
 
-static const struct usb_descriptor_header *fs_amb_data_stream_function [] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
+static struct usb_descriptor_header *fs_amb_data_stream_function[] = {
 	(struct usb_descriptor_header *) &amb_data_stream_intf,
 	(struct usb_descriptor_header *) &fs_bulk_out_desc,
 	(struct usb_descriptor_header *) &fs_bulk_in_desc,
@@ -280,16 +251,13 @@ static const struct usb_descriptor_header *fs_amb_data_stream_function [] = {
 	NULL,
 };
 
-
-//#ifdef	CONFIG_USB_GADGET_DUALSPEED
-
 static struct usb_endpoint_descriptor hs_bulk_in_desc = {
 	.bLength =		USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
 	/* bEndpointAddress will be copied from fs_bulk_in_desc during amb_bind() */
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
-	.wMaxPacketSize =	__constant_cpu_to_le16 (512),
+	.wMaxPacketSize =	cpu_to_le16 (512),
 };
 
 static struct usb_endpoint_descriptor hs_bulk_out_desc = {
@@ -297,7 +265,7 @@ static struct usb_endpoint_descriptor hs_bulk_out_desc = {
 	.bDescriptorType =	USB_DT_ENDPOINT,
 
 	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
-	.wMaxPacketSize =	__constant_cpu_to_le16 (512),
+	.wMaxPacketSize =	cpu_to_le16 (512),
 };
 
 static struct usb_endpoint_descriptor hs_intr_in_desc = {
@@ -305,7 +273,7 @@ static struct usb_endpoint_descriptor hs_intr_in_desc = {
 	.bDescriptorType =	USB_DT_ENDPOINT,
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
-	.wMaxPacketSize =	__constant_cpu_to_le16(AG_NOTIFY_MAXPACKET),
+	.wMaxPacketSize =	cpu_to_le16(AG_NOTIFY_MAXPACKET),
 	.bInterval =		AG_NOTIFY_INTERVAL + 4,
 };
 
@@ -313,14 +281,13 @@ static struct usb_qualifier_descriptor dev_qualifier = {
 	.bLength =		sizeof dev_qualifier,
 	.bDescriptorType =	USB_DT_DEVICE_QUALIFIER,
 
-	.bcdUSB =		__constant_cpu_to_le16 (0x0200),
+	.bcdUSB =		cpu_to_le16 (0x0200),
 	.bDeviceClass =		USB_CLASS_VENDOR_SPEC,
 
 	.bNumConfigurations =	1,
 };
 
-static const struct usb_descriptor_header *hs_amb_data_stream_function [] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
+static struct usb_descriptor_header *hs_amb_data_stream_function[] = {
 	(struct usb_descriptor_header *) &amb_data_stream_intf,
 	(struct usb_descriptor_header *) &hs_bulk_in_desc,
 	(struct usb_descriptor_header *) &hs_bulk_out_desc,
@@ -328,36 +295,39 @@ static const struct usb_descriptor_header *hs_amb_data_stream_function [] = {
 	NULL,
 };
 
+static struct usb_otg_descriptor otg_descriptor = {
+	.bLength =		sizeof otg_descriptor,
+	.bDescriptorType =	USB_DT_OTG,
+	.bmAttributes =		USB_OTG_SRP,
+};
 
-/* maxpacket and other transfer characteristics vary by speed. */
-#define ep_desc(g,hs,fs) (((g)->speed==USB_SPEED_HIGH)?(hs):(fs))
-
-//#else
-
-/* if there's no high speed support, maxpacket doesn't change. */
-//#define ep_desc(g,hs,fs) fs
-
-//#endif	/* !CONFIG_USB_GADGET_DUALSPEED */
-
-static char manufacturer [50];
-static char serial [40];
+static const struct usb_descriptor_header *otg_desc[] = {
+	(struct usb_descriptor_header *) &otg_descriptor,
+	NULL,
+};
+/*-------------------------------------------------------------------------*/
+static char serial[40] = "123456789ABC";
 
 /* static strings, in UTF-8 */
-static struct usb_string		strings [] = {
-	{ STRING_MANUFACTURER, manufacturer, },
-	{ STRING_PRODUCT, longname, },
-	{ STRING_SERIAL, serial, },
-	{ STRING_SOURCE_SINK, "bulk in and out data", },
+static struct usb_string		strings[] = {
+	[USB_GADGET_MANUFACTURER_IDX].s = "",
+	[USB_GADGET_PRODUCT_IDX].s = longname,
+	[USB_GADGET_SERIAL_IDX].s = serial,
+	[STRING_SOURCE_SINK].s = "bulk in and out data",
 	{  }			/* end of list */
 };
 
-static struct usb_gadget_strings	stringtab = {
+static struct usb_gadget_strings	stringtab_dev = {
 	.language	= 0x0409,	/* en-us */
 	.strings	= strings,
 };
 
-/*-------------------------------------------------------------------------*/
+static struct usb_gadget_strings	*dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
 
+/*-------------------------------------------------------------------------*/
 /* add a request to the tail of a list */
 void req_put(struct amb_dev *dev,
 		struct list_head *head, struct usb_request *req)
@@ -724,7 +694,7 @@ static int ag_write(struct file *file, const char __user *buf,
 	return len;
 }
 
-static struct file_operations ag_fops = {
+static const struct file_operations ag_fops = {
 	.owner = THIS_MODULE,
 	.unlocked_ioctl = ag_ioctl,
 	.open = ag_open,
@@ -733,7 +703,6 @@ static struct file_operations ag_fops = {
 	.release = ag_release
 };
 
-
 static void amb_notify_complete (struct usb_ep *ep, struct usb_request *req);
 
 static void notify_worker(struct work_struct *work)
@@ -762,60 +731,23 @@ static void notify_worker(struct work_struct *work)
 		req->zero = !(req->length % dev->notify_ep->maxpacket);
 		spin_unlock_irqrestore(&dev->lock, flags);
 
-		rval = usb_ep_queue (dev->notify_ep, req, GFP_ATOMIC);
+		rval = usb_ep_queue(dev->notify_ep, req, GFP_ATOMIC);
 		if (rval < 0)
 			AMB_DBG(dev, "status buf queue --> %d\n", rval);
 	}
 }
 
-static int amb_config_buf (struct usb_gadget *gadget,
-		u8 *buf, u8 type, unsigned index)
-{
-	int len;
-	const struct usb_descriptor_header **function;
-
-//#ifdef CONFIG_USB_GADGET_DUALSPEED
-	int hs = (gadget->speed == USB_SPEED_HIGH);
-//#endif
-
-	/* one configuration will always be index 0 */
-	if (index > 0)
-		return -EINVAL;
-
-//#ifdef CONFIG_USB_GADGET_DUALSPEED
-	if (type == USB_DT_OTHER_SPEED_CONFIG)
-		hs = !hs;
-	if (hs)
-		function = hs_amb_data_stream_function;
-	else
-//#endif
-		function = fs_amb_data_stream_function;
-
-	/* for now, don't advertise srp-only devices */
-	if (!gadget->is_otg)
-		function++;
-
-	len = usb_gadget_config_buf (&amb_bulk_config,
-			buf, USB_BUFSIZ, function);
-	if (len < 0)
-		return len;
-
-	((struct usb_config_descriptor *) buf)->bDescriptorType = type;
-
-	return len;
-}
-
 static struct usb_request *amb_alloc_buf_req (struct usb_ep *ep,
 		unsigned length, gfp_t kmalloc_flags)
 {
 	struct usb_request	*req;
 
-	req = usb_ep_alloc_request (ep, kmalloc_flags);
+	req = usb_ep_alloc_request(ep, kmalloc_flags);
 	if (req) {
 		req->length = length;
 		req->buf = kmalloc(length, kmalloc_flags);
 		if (!req->buf) {
-			usb_ep_free_request (ep, req);
+			usb_ep_free_request(ep, req);
 			req = NULL;
 		}
 	}
@@ -829,7 +761,7 @@ static void amb_free_buf_req (struct usb_ep *ep, struct usb_request *req)
 			kfree(req->buf);
 			req->buf = NULL;
 		}
-		usb_ep_free_request (ep, req);
+		usb_ep_free_request(ep, req);
 	}
 }
 
@@ -853,7 +785,7 @@ static void amb_bulk_in_complete (struct usb_ep *ep, struct usb_request *req)
 		break;
 	case -ESHUTDOWN:		/* disconnect from host */
 		dev->error = 1;
-		amb_free_buf_req (ep, req);
+		amb_free_buf_req(ep, req);
 		break;
 	default:
 		AMB_ERROR(dev, "%s complete --> %d, %d/%d\n", ep->name,
@@ -891,7 +823,7 @@ static void amb_bulk_out_complete (struct usb_ep *ep, struct usb_request *req)
 		break;
 	case -ESHUTDOWN:		/* disconnect from host */
 		dev->error = 1;
-		amb_free_buf_req (ep, req);
+		amb_free_buf_req(ep, req);
 		break;
 	default:
 		AMB_ERROR(dev, "%s complete --> %d, %d/%d\n", ep->name,
@@ -911,9 +843,9 @@ static void amb_bulk_out_complete (struct usb_ep *ep, struct usb_request *req)
 
 static void amb_notify_complete (struct usb_ep *ep, struct usb_request *req)
 {
+	struct amb_dev	*dev = ep->driver_data;
 	int				status = req->status;
-	struct amb_dev			*dev = ep->driver_data;
-	unsigned long 			flags;
+	unsigned long	flags;
 
 	spin_lock_irqsave(&dev->lock, flags);
 	req->context = NULL;
@@ -929,7 +861,7 @@ static void amb_notify_complete (struct usb_ep *ep, struct usb_request *req)
 		usb_ep_fifo_flush(ep);
 		break;
 	case -ESHUTDOWN:		/* disconnect from host */
-		amb_free_buf_req (ep, req);
+		amb_free_buf_req(ep, req);
 		break;
 	default:
 		AMB_ERROR(dev, "%s complete --> %d, %d/%d\n", ep->name,
@@ -938,7 +870,7 @@ static void amb_notify_complete (struct usb_ep *ep, struct usb_request *req)
 	}
 	spin_unlock_irqrestore(&dev->lock, flags);
 }
-static struct usb_endpoint_descriptor	*desc_bak;
+
 static void amb_start_notify (struct amb_dev *dev)
 {
 	struct usb_request *req = dev->notify_req;
@@ -948,16 +880,13 @@ static void amb_start_notify (struct amb_dev *dev)
 	/* flush old status
 	 * FIXME iff req->context != null just dequeue it
 	 */
-	usb_ep_disable(dev->notify_ep);
-	if (!dev->notify_ep->desc) {
-		dev->notify_ep->desc = desc_bak;
-	}
-	usb_ep_enable(dev->notify_ep);
+	//usb_ep_disable(dev->notify_ep);
+	//usb_ep_enable(dev->notify_ep);
 
 	event = req->buf;
-	event->bNotifyType = __constant_cpu_to_le16(PORT_NOTIFY_IDLE);
-	event->port_id = __constant_cpu_to_le16 (0);
-	event->value = __constant_cpu_to_le32 (0);
+	event->bNotifyType = cpu_to_le16(PORT_NOTIFY_IDLE);
+	event->port_id = cpu_to_le16 (0);
+	event->value = cpu_to_le32 (0);
 	event->status = DEVICE_NOT_OPEN;
 
 	req->length = AG_NOTIFY_MAXPACKET;
@@ -965,85 +894,49 @@ static void amb_start_notify (struct amb_dev *dev)
 	req->context = dev;
 	req->zero = !(req->length % dev->notify_ep->maxpacket);
 
-	value = usb_ep_queue (dev->notify_ep, req, GFP_ATOMIC);
+	value = usb_ep_queue(dev->notify_ep, req, GFP_ATOMIC);
 	if (value < 0)
 		AMB_DBG (dev, "status buf queue --> %d\n", value);
 }
-
-static void amb_reset_config (struct amb_dev *dev)
+/*-------------------------------------------------------------------------*/
+static void amb_cfg_unbind(struct usb_configuration *c)
 {
-	struct usb_request *req;
-	unsigned long flags;
-
-	if (dev == NULL) {
-		pr_err("amb_reset_config: NULL device pointer\n");
-		return;
-	}
-
-	if (dev->config == 0)
-		return;
-	dev->config = 0;
-
-	spin_lock_irqsave(&dev->lock, flags);
-
-	/* free write requests on the free list */
-	while(!list_empty(&dev->in_idle_list)) {
-		req = list_entry(dev->in_idle_list.next,
-				struct usb_request, list);
-		list_del_init(&req->list);
-		req->length = buflen;
-		amb_free_buf_req(dev->in_ep, req);
-	}
-	while(!list_empty(&dev->in_queue_list)) {
-		req = list_entry(dev->in_queue_list.prev,
-				struct usb_request, list);
-		list_del_init(&req->list);
-		req->length = buflen;
-		amb_free_buf_req(dev->in_ep, req);
-	}
-
-	while(!list_empty(&dev->out_req_list)) {
-		req = list_entry(dev->out_req_list.prev,
-				struct usb_request, list);
-		list_del_init(&req->list);
-		req->length = buflen;
-		amb_free_buf_req(dev->out_ep, req);
-	}
-
-	spin_unlock_irqrestore(&dev->lock, flags);
-	/* just disable endpoints, forcing completion of pending i/o.
-	 * all our completion handlers free their requests in this case.
-	 */
-	/* Disable the endpoints */
-	if (dev->notify_ep)
-		usb_ep_disable(dev->notify_ep);
-	usb_ep_disable(dev->in_ep);
-	usb_ep_disable(dev->out_ep);
+	device_destroy(ag_class, ag_dev_id);
 }
 
-static int amb_set_stream_config (struct amb_dev *dev, gfp_t gfp_flags)
+static struct usb_configuration amb_config_driver = {
+	.label			= "AMB Stream Gadget",
+	.unbind			= amb_cfg_unbind,
+	.bConfigurationValue	= 1,
+	//.iConfiguration	=	STRING_SOURCE_SINK,
+	.bmAttributes	= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,
+	.MaxPower		= 1,
+};
+
+static int amb_set_stream_config(struct amb_dev *dev)
 {
-	int			result = 0, i;
+	int		result = 0, i;
 	struct usb_gadget	*gadget = dev->gadget;
-	struct usb_endpoint_descriptor	*d;
 	struct usb_ep *ep;
 	struct usb_request *req;
 
 	/* one endpoint writes data in (to the host) */
-	d = ep_desc (gadget, &hs_bulk_in_desc, &fs_bulk_in_desc);
-	dev->in_ep->desc = d;
+	result = config_ep_by_speed(gadget, &(dev->func), dev->in_ep);
+	if (result)
+		goto exit;
 	result = usb_ep_enable(dev->in_ep);
-	if (result < 0) {
+	if (result != 0) {
 		AMB_ERROR(dev, "%s: can't enable %s, result=%d\n",
 			__func__, dev->in_ep->name, result);
 		goto exit;
 	}
 
 	/* one endpoint reads data out (from the host) */
-	d = ep_desc (gadget, &hs_bulk_out_desc, &fs_bulk_out_desc);
-	dev->out_ep->desc = d;
+	result = config_ep_by_speed(gadget, &(dev->func), dev->out_ep);
+	if (result)
+		goto exit;
 	result = usb_ep_enable(dev->out_ep);
-	if (result < 0) {
+	if (result != 0) {
 		AMB_ERROR(dev, "%s: can't enable %s, result=%d\n",
 			__func__, dev->out_ep->name, result);
 		usb_ep_disable(dev->in_ep);
@@ -1051,19 +944,23 @@ static int amb_set_stream_config (struct amb_dev *dev, gfp_t gfp_flags)
 	}
 
 	/* one endpoint report status  (to the host) */
-	desc_bak = d = ep_desc (gadget, &hs_intr_in_desc, &fs_intr_in_desc);
-	dev->notify_ep->desc = d;
+	result = config_ep_by_speed(gadget, &(dev->func), dev->notify_ep);
+	if (result)
+		goto exit;
 	result = usb_ep_enable(dev->notify_ep);
-	if (result < 0) {
+	if (result != 0) {
 		AMB_ERROR(dev, "%s: can't enable %s, result=%d\n",
 			__func__, dev->notify_ep->name, result);
 		usb_ep_disable(dev->out_ep);
 		usb_ep_disable(dev->in_ep);
+		dev->out_ep->desc = NULL;
+		dev->in_ep->desc = NULL;
 		goto exit;
 	}
 
 	/* allocate and queue read requests */
 	ep = dev->out_ep;
+	ep->driver_data = dev;
 	for (i = 0; i < qdepth && result == 0; i++) {
 		req = amb_alloc_buf_req(ep, buflen, GFP_ATOMIC);
 		if (req) {
@@ -1082,6 +979,7 @@ static int amb_set_stream_config (struct amb_dev *dev, gfp_t gfp_flags)
 
 	/* allocate write requests, and put on free list */
 	ep = dev->in_ep;
+	ep->driver_data = dev;
 	for (i = 0; i < qdepth; i++) {
 		req = amb_alloc_buf_req(ep, buflen, GFP_ATOMIC);
 		if (req) {
@@ -1094,9 +992,11 @@ static int amb_set_stream_config (struct amb_dev *dev, gfp_t gfp_flags)
 		}
 	}
 
+	ep = dev->notify_ep;
+	ep->driver_data = dev;
 	if (dev->notify_ep) {
-		dev->notify_req = amb_alloc_buf_req(dev->notify_ep,
-			AG_NOTIFY_MAXPACKET, GFP_ATOMIC);
+		dev->notify_req = amb_alloc_buf_req(ep,
+						AG_NOTIFY_MAXPACKET,GFP_ATOMIC);
 		amb_start_notify(dev);
 	}
 
@@ -1105,246 +1005,183 @@ exit:
 	return result;
 }
 
-
-static int amb_set_config (struct amb_dev *dev, unsigned number, gfp_t gfp_flags)
+static void amb_reset_config (struct amb_dev *dev)
 {
-	int			result = 0;
-	struct usb_gadget	*gadget = dev->gadget;
+	struct usb_request *req;
+	unsigned long flags;
 
-	if (number == dev->config)
-		return 0;
+	if (dev->config == 0)
+		return;
+	dev->config = 0;
 
-	amb_reset_config (dev);
+	spin_lock_irqsave(&dev->lock, flags);
 
-	switch (number) {
-	case 1:
-		result = amb_set_stream_config(dev, gfp_flags);
-		break;
-	default:
-		result = -EINVAL;
-		/* FALL THROUGH */
-	case 0:
-		return result;
+	/* free write requests on the free list */
+	while(!list_empty(&dev->in_idle_list)) {
+		req = list_entry(dev->in_idle_list.next,
+				struct usb_request, list);
+		list_del_init(&req->list);
+		req->length = buflen;
+		amb_free_buf_req(dev->in_ep, req);
+	}
+	while(!list_empty(&dev->in_queue_list)) {
+		req = list_entry(dev->in_queue_list.prev,
+				struct usb_request, list);
+		list_del_init(&req->list);
+		req->length = buflen;
+		amb_free_buf_req(dev->in_ep, req);
 	}
 
-	if (!result && (!dev->in_ep || !dev->out_ep))
-		result = -ENODEV;
-	if (result)
-		amb_reset_config (dev);
-	else {
-		char *speed;
-
-		switch (gadget->speed) {
-		case USB_SPEED_LOW:	speed = "low"; break;
-		case USB_SPEED_FULL:	speed = "full"; break;
-		case USB_SPEED_HIGH:	speed = "high"; break;
-		default: 		speed = "?"; break;
-		}
-
-		dev->config = number;
-		AMB_INFO(dev, "%s speed config #%d: \n", speed, number);
-
-		AMB_INFO(dev, "bulk_out address = 0x%02x, bulk_in address = 0x%02x,"
-			" intr_in address = 0x%02x\n",
-			dev->out_ep->desc->bEndpointAddress,
-			dev->in_ep->desc->bEndpointAddress,
-			dev->notify_ep->desc->bEndpointAddress);
+	while(!list_empty(&dev->out_req_list)) {
+		req = list_entry(dev->out_req_list.prev,
+				struct usb_request, list);
+		list_del_init(&req->list);
+		req->length = buflen;
+		amb_free_buf_req(dev->out_ep, req);
 	}
-	return result;
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+	/* just disable endpoints, forcing completion of pending i/o.
+	 * all our completion handlers free their requests in this case.
+	 */
+	/* Disable the endpoints */
+	if (dev->notify_ep)
+		usb_ep_disable(dev->notify_ep);
+	usb_ep_disable(dev->in_ep);
+	usb_ep_disable(dev->out_ep);
 }
 
-static void amb_setup_complete (struct usb_ep *ep, struct usb_request *req)
+static int amb_set_interface(struct amb_dev *dev, unsigned number)
 {
-#ifdef DEBUG
-	struct amb_dev *dev;
+	int result = 0;
 
-	dev = ep->driver_data;
+	/* Free the current interface */
+	//amb_reset_config(dev);
 
-	if (req->status || req->actual != req->length) {
-		AMB_DBG(dev, "setup complete --> %d, %d/%d\n",
-			req->status, req->actual, req->length);
+	result = amb_set_stream_config(dev);
+
+	if (!result) {
+		dev->interface = number;
+		dev->config = 1;
 	}
-#endif
+	return result;
 }
 
-static int amb_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
+static int __init amb_func_bind(struct usb_configuration *c,
+								struct usb_function *f)
 {
-	struct amb_dev		*dev = get_gadget_data (gadget);
-	struct usb_request	*req = dev->ctrl_req;
-	int			value = -EOPNOTSUPP;
-	u16			w_index = le16_to_cpu(ctrl->wIndex);
-	u16			w_value = le16_to_cpu(ctrl->wValue);
-	u16			w_length = le16_to_cpu(ctrl->wLength);
-
-	req->zero = 0;
-	switch (ctrl->bRequest) {
-
-	case USB_REQ_GET_DESCRIPTOR:
-		if (ctrl->bRequestType != USB_DIR_IN)
-			goto unknown;
-
-		switch (w_value >> 8) {
-		case USB_DT_DEVICE:
-			value = min (w_length, (u16) sizeof ag_device_desc);
-			memcpy (req->buf, &ag_device_desc, value);
-			break;
-//#ifdef CONFIG_USB_GADGET_DUALSPEED
-		case USB_DT_DEVICE_QUALIFIER:
-			if (!gadget_is_dualspeed(gadget))
-				break;
-			value = min (w_length, (u16) sizeof dev_qualifier);
-			memcpy (req->buf, &dev_qualifier, value);
-			break;
-
-		case USB_DT_OTHER_SPEED_CONFIG:
-			if (!gadget_is_dualspeed(gadget))
-				break;
-			/* fall through */
-//#endif /* CONFIG_USB_GADGET_DUALSPEED */
-		case USB_DT_CONFIG:
-			value = amb_config_buf (gadget, req->buf,
-					w_value >> 8,
-					w_value & 0xff);
-			if (value >= 0)
-				value = min (w_length, (u16) value);
-			break;
-
-		case USB_DT_STRING:
-			/* wIndex == language code.
-			 * this driver only handles one language, you can
-			 * add string tables for other languages, using
-			 * any UTF-8 characters
-			 */
-			value = usb_gadget_get_string (&stringtab,
-					w_value & 0xff, req->buf);
-			if (value >= 0)
-				value = min (w_length, (u16) value);
-			break;
-		}
-		break;
-
-	/* currently two configs, two speeds */
-	case USB_REQ_SET_CONFIGURATION:
-		if (ctrl->bRequestType != 0)
-			goto unknown;
-		value = amb_set_config (dev, w_value, GFP_ATOMIC);
-		break;
+	struct amb_dev *dev = container_of(f, struct amb_dev, func);
+	struct usb_composite_dev *cdev = c->cdev;
+	struct usb_ep *ep;
+	int id;
+	int ret = 0;
 
-	case USB_REQ_GET_CONFIGURATION:
-		if (ctrl->bRequestType != USB_DIR_IN)
-			goto unknown;
-		*(u8 *)req->buf = dev->config;
-		value = min (w_length, (u16) 1);
-		break;
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	amb_data_stream_intf.bInterfaceNumber = id;
 
-	case USB_REQ_SET_INTERFACE:
-		if (ctrl->bRequestType != USB_RECIP_INTERFACE)
-			goto unknown;
-		if (dev->config && w_index == 0 && w_value == 0) {
-			u8		config = dev->config;
-
-			/* resets interface configuration, forgets about
-			 * previous transaction state (queued bufs, etc)
-			 * and re-inits endpoint state (toggle etc)
-			 * no response queued, just zero status == success.
-			 * if we had more than one interface we couldn't
-			 * use this "reset the config" shortcut.
-			 */
-			amb_set_config (dev, config, GFP_ATOMIC);
-			value = 0;
-		}
-		break;
-	case USB_REQ_GET_INTERFACE:
-		if (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))
-			goto unknown;
-		if (!dev->config)
-			break;
-		if (w_index != 0) {
-			value = -EDOM;
-			break;
-		}
-		*(u8 *)req->buf = 0;
-		value = min (w_length, (u16) 1);
-		break;
+	/* allocate bulk endpoints */
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_bulk_in_desc);
+	if (!ep) {
+autoconf_fail:
+		ERROR(cdev, "%s: can't autoconfigure on %s\n",
+			f->name, cdev->gadget->name);
+		return -ENODEV;
+	}
+	ep->driver_data = dev;	/* claim the endpoint */
+	dev->in_ep = ep;
 
-	default:
-unknown:
-		AMB_DBG(dev, "unknown control req%02x.%02x v%04x i%04x l%d\n",
-			ctrl->bRequestType, ctrl->bRequest,
-			w_value, w_index, w_length);
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_bulk_out_desc);
+	if (!ep) {
+		goto autoconf_fail;
 	}
+	ep->driver_data = dev;	/* claim the endpoint */
+	dev->out_ep = ep;
 
-	/* respond with data transfer before status phase? */
-	if (value >= 0) {
-		req->length = value;
-		req->zero = value < w_length;
-		value = usb_ep_queue (gadget->ep0, req, GFP_ATOMIC);
-		if (value < 0) {
-			AMB_DBG(dev, "ep_queue --> %d\n", value);
-			req->status = 0;
-			amb_setup_complete (gadget->ep0, req);
-		}
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_intr_in_desc);
+	if (!ep) {
+		goto autoconf_fail;
 	}
+	dev->notify_ep = ep;
+	ep->driver_data = dev;	/* claim the endpoint */
 
-	/* device either stalls (value < 0) or reports success */
-	return value;
+	/* support all relevant hardware speeds... we expect that when
+	 * hardware is dual speed, all bulk-capable endpoints work at
+	 * both speeds
+	 */
+	hs_bulk_in_desc.bEndpointAddress = fs_bulk_in_desc.bEndpointAddress;
+	hs_bulk_out_desc.bEndpointAddress = fs_bulk_out_desc.bEndpointAddress;
+	hs_intr_in_desc.bEndpointAddress = fs_intr_in_desc.bEndpointAddress;
+
+	ret = usb_assign_descriptors(f, fs_amb_data_stream_function,
+				hs_amb_data_stream_function, NULL);
+	if (ret)
+		goto fail;
+
+	printk("AMB STREAM: %s speed IN/%s OUT/%s NOTIFY/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			dev->in_ep->name, dev->out_ep->name,dev->notify_ep->name);
+	return 0;
+fail:
+	usb_free_all_descriptors(f);
+	if (dev->in_ep)
+		dev->in_ep->driver_data = NULL;
+	if (dev->out_ep)
+		dev->out_ep->driver_data = NULL;
+	if (dev->notify_ep)
+		dev->notify_ep->driver_data = NULL;
+
+	printk("%s: can't bind, err %d\n", f->name, ret);
+	return ret;
 }
 
-static void amb_disconnect (struct usb_gadget *gadget)
+static void amb_func_unbind(struct usb_configuration *c,
+							struct usb_function *f)
 {
-	struct amb_dev		*dev = get_gadget_data (gadget);
-
-	amb_reset_config (dev);
-
-	/* a more significant application might have some non-usb
-	 * activities to quiesce here, saving resources like power
-	 * or pushing the notification up a network stack.
-	 */
-
-	/* next we may get setup() calls to enumerate new connections;
-	 * or an unbind() during shutdown (including removing module).
-	 */
+	usb_free_all_descriptors(f);
 }
 
-static void __exit amb_unbind (struct usb_gadget *gadget)
+static int amb_func_set_alt(struct usb_function *f,
+							unsigned inf, unsigned alt)
 {
-	struct amb_dev		*dev = get_gadget_data (gadget);
+	struct amb_dev *dev = container_of(f, struct amb_dev, func);
+	int ret = -ENOTSUPP;
 
-	AMB_DBG(dev, "unbind\n");
+	if (!alt)
+		ret = amb_set_interface(dev, inf);
+	return ret;
+}
 
-	/* we've already been disconnected ... no i/o is active */
-	if (dev->ctrl_req) {
-		dev->ctrl_req->length = USB_BUFSIZ;
-		amb_free_buf_req (gadget->ep0, dev->ctrl_req);
-		dev->ctrl_req = NULL;
-	}
+static void amb_func_disable(struct usb_function *f)
+{
+	struct amb_dev *dev = container_of(f, struct amb_dev, func);
+	unsigned long flags;
 
-	kfree (dev);
-	set_gadget_data (gadget, NULL);
-	ag_device = NULL;
+	spin_lock_irqsave(&dev->lock, flags);
+	amb_reset_config(dev);
+	spin_unlock_irqrestore(&dev->lock, flags);
 }
 
-static int __ref amb_bind (struct usb_gadget *gadget,
-		struct usb_gadget_driver *driver)
+static int __init amb_bind_config(struct usb_configuration *c)
 {
+	struct usb_gadget	*gadget = c->cdev->gadget;
 	struct amb_dev		*dev;
-	struct usb_ep		*ep;
-//	int			gcnum;
-
-//	gcnum = usb_gadget_controller_number (gadget);
-//	if (gcnum >= 0)
-//		ag_device_desc.bcdDevice = cpu_to_le16 (0x0200 + gcnum);
-//	else {
-//		pr_warn("%s: controller '%s' not recognized\n",
-//			shortname, gadget->name);
-//		ag_device_desc.bcdDevice = __constant_cpu_to_le16 (0x9999);
-//	}
-
-	/* ok, we made sense of the hardware ... */
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	struct device		*pdev;
+	int status = -ENOMEM;
+
+	usb_ep_autoconfig_reset(gadget);
+
+	dev = kzalloc(sizeof(struct amb_dev), GFP_KERNEL);
 	if (!dev)
 		return -ENOMEM;
 
+	dev->func.name = shortname;
+	dev->func.bind = amb_func_bind;
+	dev->func.unbind = amb_func_unbind;
+	dev->func.set_alt = amb_func_set_alt;
+	dev->func.disable = amb_func_disable;
+
 	spin_lock_init (&dev->lock);
 	mutex_init(&dev->mtx);
 	init_waitqueue_head(&dev->wq);
@@ -1353,103 +1190,105 @@ static int __ref amb_bind (struct usb_gadget *gadget,
 	INIT_LIST_HEAD(&dev->out_req_list);
 
 	dev->gadget = gadget;
-	dev->config = 0;
 	dev->error = 0;
 	ag_device = dev;
-	set_gadget_data (gadget, dev);
-
-	/* configure the endpoints */
-	usb_ep_autoconfig_reset (gadget);
 
-	ep = usb_ep_autoconfig (gadget, &fs_bulk_in_desc);
-	if (!ep) {
-		AMB_ERROR(dev, "amb_bind: cannot get bulk-in endpoint\n");
-		return -ENODEV;
+	status = usb_add_function(c, &dev->func);
+	if (status) {
+		kfree(dev);
+		return status;
 	}
-	ep->driver_data = dev;	/* claim the endpoint */
-	dev->in_ep = ep;
 
-	ep = usb_ep_autoconfig (gadget, &fs_bulk_out_desc);
-	if (!ep) {
-		AMB_ERROR(dev, "amb_bind: cannot get bulk-out endpoint\n");
-		return -ENODEV;
+	/* Setup the sysfs files for the gadget. */
+	pdev = device_create(ag_class, NULL, ag_dev_id,
+				  NULL, "amb_gadget");
+	if (IS_ERR(pdev)) {
+		status = PTR_ERR(pdev);
+		ERROR(dev, "Failed to create device: amb_gadget\n");
+		goto fail;
 	}
-	ep->driver_data = dev;	/* claim the endpoint */
-	dev->out_ep = ep;
 
-	ep = usb_ep_autoconfig(gadget, &fs_intr_in_desc);
-	if (!ep) {
-		AMB_ERROR(dev, "amb_bind: cannot use notify endpoint\n");
-		return -ENODEV;
-	}
-	dev->notify_ep = ep;
-	ep->driver_data = dev;	/* claim the endpoint */
+	usb_gadget_set_selfpowered(gadget);
 
-	/* preallocate control response and buffer */
-	dev->ctrl_req = amb_alloc_buf_req (gadget->ep0, USB_BUFSIZ, GFP_KERNEL);
-	if (dev->ctrl_req == NULL) {
-		AMB_ERROR(dev, "%s: No memory\n", __func__);
-		amb_unbind (gadget);
-		return -ENOMEM;
+	if (gadget->is_otg) {
+		otg_descriptor.bmAttributes |= USB_OTG_HNP;
+		amb_config_driver.descriptors = otg_desc;
+		amb_config_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
-	dev->ctrl_req->complete = amb_setup_complete;
-	gadget->ep0->driver_data = dev;
+#if 0
+	spin_lock_init (&dev->lock);
+	mutex_init(&dev->mtx);
+	init_waitqueue_head(&dev->wq);
+	INIT_LIST_HEAD(&dev->in_idle_list);
+	INIT_LIST_HEAD(&dev->in_queue_list);
+	INIT_LIST_HEAD(&dev->out_req_list);
 
-	ag_device_desc.bMaxPacketSize0 = gadget->ep0->maxpacket;
+	dev->gadget = gadget;
+	dev->error = 0;
+	ag_device = dev;
+#endif
+	return 0;
 
-	if (gadget_is_dualspeed(gadget)) {
-		/* assume ep0 uses the same value for both speeds ... */
-		dev_qualifier.bMaxPacketSize0 = ag_device_desc.bMaxPacketSize0;
+fail:
+	amb_cfg_unbind(c);
+	return status;
+}
 
-		/* and that all endpoints are dual-speed */
-		hs_bulk_in_desc.bEndpointAddress = fs_bulk_in_desc.bEndpointAddress;
-		hs_bulk_out_desc.bEndpointAddress = fs_bulk_out_desc.bEndpointAddress;
-		hs_intr_in_desc.bEndpointAddress = fs_intr_in_desc.bEndpointAddress;
-	}
+static int amb_unbind(struct usb_composite_dev *cdev)
+{
+#if 0
+	struct usb_gadget	*gadget = cdev->gadget;
+	struct amb_dev		*dev = get_gadget_data (gadget);
 
-	if (gadget->is_otg) {
-		otg_descriptor.bmAttributes |= USB_OTG_HNP,
-		amb_bulk_config.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
-	}
+	kfree (dev);
+	set_gadget_data(gadget, NULL);
+	ag_device = NULL;
+#else
+#endif
+	return 0;
+}
 
-	usb_gadget_set_selfpowered (gadget);
+/*-------------------------------------------------------------------------*/
+static int __init amb_bind(struct usb_composite_dev *cdev)
+{
+	int ret;
+	ret = usb_string_ids_tab(cdev, strings);
+	if (ret < 0)
+		return ret;
 
-	gadget->ep0->driver_data = dev;
+	ag_device_desc.iManufacturer = strings[USB_GADGET_MANUFACTURER_IDX].id;
+	ag_device_desc.iProduct = strings[USB_GADGET_PRODUCT_IDX].id;
+	ag_device_desc.iSerialNumber = strings[USB_GADGET_SERIAL_IDX].id;
+	amb_config_driver.iConfiguration = strings[STRING_SOURCE_SINK].id;
 
-	strlcpy (serial, "123456789ABC", sizeof serial);
-	snprintf (manufacturer, sizeof manufacturer, "%s %s with %s",
-		init_utsname()->sysname, init_utsname()->release,
-		gadget->name);
+	ret = usb_add_config(cdev, &amb_config_driver, amb_bind_config);
+	if (ret < 0)
+		return ret;
 
-	AMB_INFO(dev, "%s, version: " DRIVER_VERSION "\n", longname);
+	usb_composite_overwrite_options(cdev, &coverwrite);
+	INFO(cdev, "%s, version: " DRIVER_VERSION "\n", longname);
 
 	return 0;
 }
 
-static __refdata struct usb_gadget_driver amb_gadget_driver = {
-	.max_speed	= USB_SPEED_HIGH,
-	.function	= (char *) longname,
-	.bind			=	amb_bind,
-	.unbind		= __exit_p(amb_unbind),
-	.setup		= amb_setup,
-	.disconnect	= amb_disconnect,
-
-	.driver 	= {
-		.name		= (char *) shortname,
-		.owner		= THIS_MODULE,
-	},
+static __refdata struct usb_composite_driver amb_gadget_driver = {
+	.name		=	shortname,
+	.dev		=	&ag_device_desc,
+	.strings	=	dev_strings,
+	.max_speed	=	USB_SPEED_HIGH,
+	.bind		=	amb_bind,
+	.unbind		=	amb_unbind,
 };
 
 static int __init amb_gadget_init(void)
 {
 	int rval = 0;
-	dev_t dev_id;
 
-	rval = usb_gadget_probe_driver(&amb_gadget_driver);
-	if (rval) {
-		pr_err("amb_gadget_init: cannot register gadget driver, "
-			"rval=%d\n", rval);
-		goto out0;
+	ag_class = class_create(THIS_MODULE, "amb_stream_gadget");
+	if (IS_ERR(ag_class)) {
+		rval = PTR_ERR(ag_class);
+		pr_err("unable to create usb_gadget class %d\n", rval);
+		return rval;
 	}
 
 	if (buflen >= 65536) {
@@ -1458,8 +1297,8 @@ static int __init amb_gadget_init(void)
 		goto out1;
 	}
 
-	dev_id = MKDEV(AMB_GADGET_MAJOR, AMB_GADGET_MINOR_START);
-	rval = register_chrdev_region(dev_id, 1, "amb_gadget");
+	ag_dev_id = MKDEV(AMB_GADGET_MAJOR, AMB_GADGET_MINOR_START);
+	rval = register_chrdev_region(ag_dev_id, 1, "amb_gadget");
 	if(rval < 0){
 		pr_err("amb_gadget_init: register devcie number error!\n");
 		goto out1;
@@ -1467,16 +1306,23 @@ static int __init amb_gadget_init(void)
 
 	cdev_init(&ag_cdev, &ag_fops);
 	ag_cdev.owner = THIS_MODULE;
-	rval = cdev_add(&ag_cdev, dev_id, 1);
+	rval = cdev_add(&ag_cdev, ag_dev_id, 1);
 	if (rval) {
 		pr_err("amb_gadget_init: cdev_add failed\n");
-		unregister_chrdev_region(dev_id, 1);
+		unregister_chrdev_region(ag_dev_id, 1);
 		goto out1;
 	}
 
+	rval = usb_composite_probe(&amb_gadget_driver);
+	if (rval) {
+		pr_err("amb_gadget_init: cannot register gadget driver, "
+			"rval=%d\n", rval);
+		class_destroy(ag_class);
+		goto out0;
+	}
 out1:
 	if(rval)
-		usb_gadget_unregister_driver(&amb_gadget_driver);
+		class_destroy(ag_class);
 out0:
 	return rval;
 }
@@ -1484,17 +1330,14 @@ module_init (amb_gadget_init);
 
 static void __exit amb_gadget_exit (void)
 {
-	dev_t dev_id;
+	usb_composite_unregister(&amb_gadget_driver);
 
-	usb_gadget_unregister_driver (&amb_gadget_driver);
-
-	dev_id = MKDEV(AMB_GADGET_MAJOR, AMB_GADGET_MINOR_START);
-	unregister_chrdev_region(dev_id, 1);
+	unregister_chrdev_region(ag_dev_id, 1);
 	cdev_del(&ag_cdev);
+	class_destroy(ag_class);
 }
 module_exit (amb_gadget_exit);
 
-
 MODULE_AUTHOR ("Cao Rongrong <rrcao@ambarella.com>");
 MODULE_LICENSE ("GPL");
 
diff --git a/drivers/usb/gadget/ambarella_udc.c b/drivers/usb/gadget/ambarella_udc.c
index a3d5c7f..ea855a7 100644
--- a/drivers/usb/gadget/ambarella_udc.c
+++ b/drivers/usb/gadget/ambarella_udc.c
@@ -35,7 +35,6 @@
 #include <linux/usb/gadget.h>
 #include <linux/usb/otg.h>
 #include <linux/proc_fs.h>
-#include <linux/seq_file.h>
 #include <linux/of.h>
 #include <mach/hardware.h>
 #include <plat/rct.h>
@@ -49,8 +48,10 @@
 #define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
 
 static const char		gadget_name[] = "ambarella_udc";
+#if 0
 static const char		driver_desc[] = DRIVER_DESC;
 static const char 		ep0name [] = "ep0";
+#endif
 
 static const char *amb_ep_string[] = {
 	"ep0in", "ep1in", "ep2in", "ep3in",
@@ -136,52 +137,23 @@ static void ambarella_uevent_work(struct work_struct *data)
 }
 
 /* ========================================================================== */
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+#include <linux/seq_file.h>
+
+static const char proc_node_name[] = "driver/udc";
 static int ambarella_udc_proc_show(struct seq_file *m, void *v)
 {
 	struct ambarella_udc *udc;
-	int len = 0;
+	struct usb_ctrlrequest *crq;
 
+	unsigned long	flags;
 	udc = (struct ambarella_udc *)m->private;
+	crq = (struct usb_ctrlrequest *)&udc->setup[0];
 
-	len += seq_printf(m, "AMBUDC_STATUS=%s",
-			usb_state_string(udc->gadget.state));
-	len += seq_printf(m, " (%s: %s)\n", (udc->driver ?
-			udc->driver->driver.name : "NULL"),
-			udc->vbus_status ? "Connected" : "Disconnected");
-
-	return len;
-}
-
-static int ambarella_udc_proc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, ambarella_udc_proc_show, PDE_DATA(inode));
-}
-
-static const struct file_operations ambarella_udc_fops = {
-	.open = ambarella_udc_proc_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-};
-
-#ifdef CONFIG_USB_GADGET_DEBUG_FILES
-
-static const char proc_node_name[] = "driver/udc";
-
-static int ambarella_debugfs_udc_read(char *page, char **start,
-	off_t off, int count, int *eof, void *_dev)
-{
-	char *buf = page;
-	struct ambarella_udc *udc = _dev;
-	char *next = buf;
-	unsigned size = count;
-	int t;
-	struct usb_ctrlrequest *crq = (struct usb_ctrlrequest *)&udc->setup[0];
-
-	if (off != 0)
-		return 0;
+	spin_lock_irqsave(&udc->lock, flags);
 
 	/* basic device status */
-	t = scnprintf(next, size,
+	seq_printf(m,
 		DRIVER_DESC "\n"
 		"Name: %s\n"
 		"Version: %s\n"
@@ -194,35 +166,32 @@ static int ambarella_debugfs_udc_read(char *page, char **start,
 		udc->driver ? udc->driver->driver.name : "(none)",
 		udc->vbus_status ? (udc->gadget.speed == USB_SPEED_HIGH ?
 			"high speed" : "full speed") : "disconnected");
-	size -= t;
-	next += t;
 
-	t = scnprintf(next, size, "the last setup packet is: \n"
+	seq_printf(m, "AMBUDC_STATUS=%s",
+			usb_state_string(udc->gadget.state));
+
+	seq_printf(m,
+		"the last setup packet is: \n"
 		"bRequestType = 0x%02x, bRequest = 0x%02x,\n"
 		"wValue = 0x%04x, wIndex = 0x%04x, wLength = 0x%04x\n\n",
 		crq->bRequestType, crq->bRequest, crq->wValue, crq->wIndex,
 		crq->wLength);
-	size -= t;
-	next += t;
-
-/*
-	t = scnprintf(next, size, "max_cmd_num = %d\tmax_ep0_cmd_num = %d\n\n",
-		udc->max_cmd_num, udc->max_ep0_cmd_num);
-	size -= t;
-	next += t;
-*/
-	*eof = 1;
-	return count - size;
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return 0;
+}
+static int ambarella_udc_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ambarella_udc_proc_show, PDE_DATA(inode));
 }
 
-#define create_debugfs_files() 	create_proc_read_entry(proc_node_name, 0, NULL, ambarella_debugfs_udc_read, udc)
-#define remove_debugfs_files() 	remove_proc_entry(proc_node_name, NULL)
-
-#else	/* !CONFIG_USB_GADGET_DEBUG_FILES */
-
-#define create_debugfs_files() do {} while (0)
-#define remove_debugfs_files() do {} while (0)
+static const struct file_operations ambarella_udc_fops = {
+	.open = ambarella_udc_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
 
+#define remove_debugfs_files() 	remove_proc_entry(proc_node_name, NULL)
 #endif	/* CONFIG_USB_GADGET_DEBUG_FILES */
 
 /**************  PROC FILESYSTEM  END*****************/
@@ -311,9 +280,9 @@ static void ambarella_udc_fifo_flush(struct ambarella_udc *udc)
 
 static void ambarella_udc_reset(void __iomem *reset_reg, struct device_node *np)
 {
-	amba_rct_setbitsl(reset_reg, UDC_SOFT_RESET);
+	amba_rct_setbitsl(reset_reg, UDC_SOFT_RESET_MASK);
 	msleep(1);
-	amba_rct_clrbitsl(reset_reg, UDC_SOFT_RESET);
+	amba_rct_clrbitsl(reset_reg, UDC_SOFT_RESET_MASK);
 };
 
 static void ambarella_init_usb(struct ambarella_udc *udc)
@@ -522,7 +491,7 @@ static u32 ambarella_check_bna_error (struct ambarella_ep *ep, u32 ep_status)
 
 	/* Error: Buffer Not Available */
 	if (ep_status & USB_EP_BUF_NOT_AVAIL) {
-		printk(KERN_ERR "[USB]:BNA error in %s\n", ep->ep.name);
+		//printk(KERN_ERR "[USB]:BNA error in %s\n", ep->ep.name);
 		amba_writel(ep->ep_reg.sts_reg, USB_EP_BUF_NOT_AVAIL);
 		retval = 1;
 	}
@@ -552,7 +521,7 @@ static u32 ambarella_check_dma_error (struct ambarella_ep *ep)
 		sts_tmp1 = ep->last_data_desc->status & USB_DMA_BUF_STS;
 		sts_tmp2 = ep->last_data_desc->status & USB_DMA_RXTX_STS;
 		if ((sts_tmp1 != USB_DMA_BUF_DMA_DONE) || (sts_tmp2 != USB_DMA_RXTX_SUCC)){
-			printk(KERN_ERR "%s: DMA failed\n", ep->ep.name);
+			//printk(KERN_ERR "%s: DMA failed\n", ep->ep.name);
 			retval = 1;
 		}
 	}
@@ -723,7 +692,7 @@ static void ambarella_enable_rx_dma(struct ambarella_ep *ep)
 }
 
 static void ambarella_patch_iso_desc(struct ambarella_udc *udc,
-	struct ambarella_request * req)
+	struct ambarella_request * req, struct ambarella_ep *ep, int frame_fix)
 {
 	struct ambarella_data_desc *data_desc;
 	u32 current_frame, max_packet_num, i, j;
@@ -733,13 +702,13 @@ static void ambarella_patch_iso_desc(struct ambarella_udc *udc,
 
 	/* according to USB2.0 spec, each microframe can send 3 packets at most */
 	for (i = 0; i < req->active_desc_count; i += j) {
-		if ((req->active_desc_count - i) >= ISO_FRAME_ADVANCE)
-			max_packet_num = ISO_FRAME_ADVANCE;
+		if ((req->active_desc_count - i) >= ISO_MAX_PACKET)
+			max_packet_num = ISO_MAX_PACKET;
 		else
 			max_packet_num = req->active_desc_count - i;
 
 		for (j = 0; j < max_packet_num; j++) {
-			data_desc->status |= ((current_frame + ISO_FRAME_ADVANCE) << 16);
+			data_desc->status |= ((current_frame + ep->frame_offset + frame_fix) << 16);
 			data_desc->status |= (max_packet_num << 14);
 			data_desc = data_desc->next_desc_virt;
 		}
@@ -747,13 +716,13 @@ static void ambarella_patch_iso_desc(struct ambarella_udc *udc,
 }
 
 static void ambarella_set_tx_dma(struct ambarella_ep *ep,
-	struct ambarella_request * req)
+	struct ambarella_request * req, int frame_fix)
 {
 	struct ambarella_udc *udc = ep->udc;
 	struct ambarella_ep_reg *ep_reg = &ep->ep_reg;
 
 	if (IS_ISO_IN_EP(ep))
-		ambarella_patch_iso_desc(udc, req);
+		ambarella_patch_iso_desc(udc, req, ep, frame_fix);
 
 	ep->data_desc = req->data_desc;
 	amba_writel(ep_reg->dat_desc_ptr_reg, req->data_desc_addr | udc->dma_fix);
@@ -1002,7 +971,7 @@ static void ambarella_udc_done(struct ambarella_ep *ep,
 			/* no need to wait for IN-token for ISO transfer */
 			if (IS_ISO_IN_EP(ep)) {
 				amba_writel(ep->ep_reg.sts_reg, USB_EP_IN_PKT);
-				ambarella_set_tx_dma(ep, req);
+				ambarella_set_tx_dma(ep, next_req, 1);
 			}
 			ambarella_clr_ep_nak(ep);
 			break;
@@ -1237,13 +1206,15 @@ static void udc_epin_interrupt(struct ambarella_udc *udc, u32 ep_id)
 		}
 		ambarella_handle_data_in(&udc->ep[ep_id]);
 	} else if(ep_status & USB_EP_IN_PKT) {
+#if 0
 		if (IS_ISO_IN_EP(ep))
 			goto finish;
+#endif
 
 		if(!ep->halted && !ep->cancel_transfer && !list_empty(&ep->queue)){
 			req = list_first_entry(&ep->queue,
 				struct ambarella_request, queue);
-			ambarella_set_tx_dma(ep, req);
+			ambarella_set_tx_dma(ep, req, 0);
 		} else if (ep->dma_going == 0 || ep->halted || ep->cancel_transfer) {
 			ambarella_set_ep_nak(ep);
 		}
@@ -1255,7 +1226,7 @@ static void udc_epin_interrupt(struct ambarella_udc *udc, u32 ep_id)
 		return;
 	}
 
-finish:
+//finish:
 	if (ep_status != 0) {
 		ep_status &= (USB_EP_IN_PKT | USB_EP_TRN_DMA_CMPL | USB_EP_TXFIFO_EMPTY);
 //		ep_status &= (USB_EP_IN_PKT | USB_EP_TRN_DMA_CMPL | USB_EP_RCV_CLR_STALL);
@@ -1410,9 +1381,14 @@ static void ambarella_vbus_timer(unsigned long data)
 {
 	struct ambarella_udc *udc = (struct ambarella_udc *)data;
 	enum usb_device_state state;
-	u32 connected;
+	u32 raw_status, connected, suspended;
+
+	suspended = (amba_readl(USB_DEV_STS_REG) & USB_DEV_SUSP_STS);
+	raw_status = amba_readl(AHB_SCRATCHPAD_REG(0x04));
+	connected = !!(raw_status & (1 << 26));
 
-	connected = !!(amba_readl(VIC_REG(VIC_RAW_STA_OFFSET)) & 0x1);
+	if (suspended)
+		usb_gadget_set_state(&udc->gadget, USB_STATE_SUSPENDED);
 
 	if (udc->vbus_status != connected) {
 		state = connected ? USB_STATE_ATTACHED : USB_STATE_NOTATTACHED;
@@ -1488,6 +1464,7 @@ static int ambarella_udc_ep_enable(struct usb_ep *_ep,
 	ep->ctrl_sts_phase = 0;
 	ep->dma_going = 0;
 	ep->cancel_transfer = 0;
+	ep->frame_offset =  (1 << (desc->bInterval - 1));
 
 	if(ep->dir == USB_DIR_IN){
 		idx = ep->id;
@@ -1512,9 +1489,11 @@ static int ambarella_udc_ep_enable(struct usb_ep *_ep,
 	if(ep->dir == USB_DIR_IN) {
 		/* NOTE: total IN fifo size must be less than 576 * 4B */
 		tmp = max_packet / 4;
+#if 0
 		if (IS_ISO_IN_EP(ep))
 			tmp *= max_packet > 1024 ? 1 : max_packet > 512 ? 2 : 3;
 		else
+#endif
 			tmp *= 2;
 		amba_writel(ep->ep_reg.buf_sz_reg, tmp);
 	}
@@ -1592,7 +1571,7 @@ ambarella_udc_free_request(struct usb_ep *_ep, struct usb_request *_req)
 	struct ambarella_ep	*ep = to_ambarella_ep(_ep);
 	struct ambarella_request	*req = to_ambarella_req(_req);
 
-	if (!ep || !_req || (!ep->ep.desc && !IS_EP0(ep)))
+	if (!ep || !_req)
 		return;
 
 	if(req->desc_count > 0)
@@ -1615,6 +1594,7 @@ static int ambarella_udc_queue(struct usb_ep *_ep, struct usb_request *_req,
 	struct ambarella_ep	*ep = NULL;
 	struct ambarella_udc	*udc;
 	unsigned long flags;
+	int i;
 
 	if (unlikely (!_ep)) {
 		pr_err("%s: _ep is NULL\n", __func__);
@@ -1622,12 +1602,27 @@ static int ambarella_udc_queue(struct usb_ep *_ep, struct usb_request *_req,
 	}
 
 	ep = to_ambarella_ep(_ep);
+	udc = ep->udc;
+
+	for(i = 0; i < EP_NUM_MAX; i++) {
+		struct ambarella_ep *endp;
+		endp = &udc->ep[i];
+
+		if (endp != NULL && endp->dma_going) //Check for any ongoing DMA
+			break;
+
+		//If no other onging DMA and the current req is for ISO, enable the DMA
+		if((i == EP_NUM_MAX - 1) && IS_ISO_IN_EP(ep)) {
+			amba_setbitsl(USB_DEV_CTRL_REG,
+				USB_DEV_RCV_DMA_EN | USB_DEV_TRN_DMA_EN);
+		}
+        }
+
 	if (unlikely (!ep->ep.desc && !IS_EP0(ep))) {
 		pr_err("%s: %s, invalid args\n", __func__, _ep->name);
 		return -EINVAL;
 	}
 
-	udc = ep->udc;
 	if( unlikely( !udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)){
 		dprintk(DEBUG_NORMAL, "%s: %01d %01d\n", _ep->name,
 			!udc->driver, udc->gadget.speed==USB_SPEED_UNKNOWN);
@@ -1715,10 +1710,12 @@ static int ambarella_udc_queue(struct usb_ep *_ep, struct usb_request *_req,
 
 		if (ep->dir == USB_DIR_IN) {
 			/* no need to wait for IN-token for ISO transfer */
+#if 0
 			if (IS_ISO_IN_EP(ep)) {
 				amba_writel(ep->ep_reg.sts_reg, USB_EP_IN_PKT);
 				ambarella_set_tx_dma(ep, req);
 			}
+#endif
 			/* enable dma completion interrupt for current TX data */
 			amba_clrbitsl(USB_DEV_EP_INTR_MSK_REG, 1 << ep->id);
 			ambarella_clr_ep_nak(ep);
@@ -2205,14 +2202,14 @@ static int ambarella_udc_probe(struct platform_device *pdev)
 	udc->pre_state = USB_STATE_NOTATTACHED;
 	INIT_WORK(&udc->uevent_work, ambarella_uevent_work);
 
-	udc->proc_file = proc_create_data("udc", S_IRUGO,
-		get_ambarella_proc_dir(), &ambarella_udc_fops, udc);
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+	udc->proc_file = proc_create_data(proc_node_name, 0,
+		NULL, &ambarella_udc_fops, udc);
 	if (udc->proc_file == NULL) {
 		retval = -ENOMEM;
 		goto err_out3;
 	}
-
-	create_debugfs_files();
+#endif
 
 	/* Register gadget driver */
 	retval = usb_add_gadget_udc_release(&pdev->dev, &udc->gadget,
@@ -2226,7 +2223,9 @@ static int ambarella_udc_probe(struct platform_device *pdev)
 	return 0;
 
 err_out4:
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
 	remove_debugfs_files();
+#endif
 err_out3:
 	dma_pool_free(udc->desc_dma_pool, udc->dummy_desc, udc->dummy_desc_addr);
 err_out2:
@@ -2251,10 +2250,9 @@ static int ambarella_udc_remove(struct platform_device *pdev)
 		return -EBUSY;
 
 	del_timer_sync(&udc->vbus_timer);
-
-	remove_proc_entry("udc", get_ambarella_proc_dir());
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
 	remove_debugfs_files();
-
+#endif
 	dma_pool_free(udc->desc_dma_pool, udc->dummy_desc, udc->dummy_desc_addr);
 	dma_pool_free(udc->desc_dma_pool, udc->setup_buf, udc->setup_addr);
 	dma_pool_destroy(udc->desc_dma_pool);
diff --git a/drivers/usb/gadget/ambarella_udc.h b/drivers/usb/gadget/ambarella_udc.h
index d1891c0..fef8433 100644
--- a/drivers/usb/gadget/ambarella_udc.h
+++ b/drivers/usb/gadget/ambarella_udc.h
@@ -36,7 +36,6 @@ USB device controller on Ambarella processors
 
 #define CTRL_OUT_UDC_IDX	11
 
-#define ISO_FRAME_ADVANCE	2
 #define ISO_MAX_PACKET		3
 
 #define IS_EP0(ep)		(ep->id == CTRL_IN || ep->id == CTRL_OUT)
@@ -127,6 +126,7 @@ struct ambarella_ep {
 					ctrl_sts_phase : 1,
 					dma_going : 1;
 
+	unsigned int frame_offset;  /* iso frame num offset */
 };
 
 struct ambarella_udc {
@@ -175,7 +175,7 @@ static void ambarella_udc_done(struct ambarella_ep *ep,
 		struct ambarella_request *req, int status);
 
 static void ambarella_set_tx_dma(struct ambarella_ep *ep,
-	struct ambarella_request * req);
+	struct ambarella_request * req, int fix);
 
 static void ambarella_set_rx_dma(struct ambarella_ep *ep,
 	struct ambarella_request * req);
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 44a292b..a660716 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -528,7 +528,7 @@ static int bos_desc(struct usb_composite_dev *cdev)
 	usb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;
 	usb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;
 	usb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;
-	usb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT);
+	usb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT | USB_BESL_SUPPORT);
 
 	/*
 	 * The Superspeed USB Capability descriptor shall be implemented by all
diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c
index 80e7f75..3dab424 100644
--- a/drivers/usb/gadget/configfs.c
+++ b/drivers/usb/gadget/configfs.c
@@ -757,6 +757,7 @@ static void purge_configs_funcs(struct gadget_info *gi)
 			}
 		}
 		c->next_interface_id = 0;
+		memset(c->interface, 0, sizeof(c->interface));
 		c->superspeed = 0;
 		c->highspeed = 0;
 		c->fullspeed = 0;
diff --git a/drivers/usb/gadget/printer.c b/drivers/usb/gadget/printer.c
index bf7a56b..a0dfdbd 100644
--- a/drivers/usb/gadget/printer.c
+++ b/drivers/usb/gadget/printer.c
@@ -975,6 +975,15 @@ unknown:
 		break;
 	}
 	/* host either stalls (value < 0) or reports success */
+	if (value >= 0) {
+		req->length = value;
+		req->zero = value < wLength;
+		value = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
+		if (value < 0) {
+			ERROR(dev, "%s:%d Error!\n", __func__, __LINE__);
+			req->status = 0;
+		}
+	}
 	return value;
 }
 
diff --git a/drivers/usb/host/ehci-ambarella.c b/drivers/usb/host/ehci-ambarella.c
index 579b004..affec7e 100644
--- a/drivers/usb/host/ehci-ambarella.c
+++ b/drivers/usb/host/ehci-ambarella.c
@@ -163,11 +163,7 @@ amb_ehci_err:
 static int ehci_ambarella_drv_remove(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct ehci_ambarella_priv *priv;
-
-	priv = (struct ehci_ambarella_priv *)hcd_to_ehci(hcd)->priv;
 
-	usb_put_phy(priv->phy);
 	usb_remove_hcd(hcd);
 	usb_put_hcd(hcd);
 
diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index 14ced00..0659024 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -29,7 +29,7 @@ static ssize_t show_companion(struct device *dev,
 	int			count = PAGE_SIZE;
 	char			*ptr = buf;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	nports = HCS_N_PORTS(ehci->hcs_params);
 
 	for (index = 0; index < nports; ++index) {
@@ -54,7 +54,7 @@ static ssize_t store_companion(struct device *dev,
 	struct ehci_hcd		*ehci;
 	int			portnum, new_owner;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	new_owner = PORT_OWNER;		/* Owned by companion */
 	if (sscanf(buf, "%d", &portnum) != 1)
 		return -EINVAL;
@@ -85,7 +85,7 @@ static ssize_t show_uframe_periodic_max(struct device *dev,
 	struct ehci_hcd		*ehci;
 	int			n;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	n = scnprintf(buf, PAGE_SIZE, "%d\n", ehci->uframe_periodic_max);
 	return n;
 }
@@ -102,7 +102,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 	unsigned long		flags;
 	ssize_t			ret;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	if (kstrtouint(buf, 0, &uframe_periodic_max) < 0)
 		return -EINVAL;
 
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index b64e661..baf2807 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -1488,7 +1488,7 @@ static int isp116x_bus_resume(struct usb_hcd *hcd)
 	spin_unlock_irq(&isp116x->lock);
 
 	hcd->state = HC_STATE_RESUMING;
-	msleep(20);
+	msleep(USB_RESUME_TIMEOUT);
 
 	/* Go operational */
 	spin_lock_irq(&isp116x->lock);
diff --git a/drivers/usb/host/ohci-ambarella.c b/drivers/usb/host/ohci-ambarella.c
index e64e7f8..bc5b27d 100644
--- a/drivers/usb/host/ohci-ambarella.c
+++ b/drivers/usb/host/ohci-ambarella.c
@@ -194,9 +194,7 @@ amb_ohci_err:
 static int ohci_hcd_ambarella_drv_remove(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-	struct ohci_ambarella *amb_ohci = hcd_to_ohci_ambarella(hcd);
 
-	usb_put_phy(amb_ohci->phy);
 	usb_remove_hcd(hcd);
 	usb_put_hcd(hcd);
 
diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c
index 0f401db..b5c4f4d 100644
--- a/drivers/usb/host/oxu210hp-hcd.c
+++ b/drivers/usb/host/oxu210hp-hcd.c
@@ -2497,11 +2497,12 @@ static irqreturn_t oxu210_hcd_irq(struct usb_hcd *hcd)
 					|| oxu->reset_done[i] != 0)
 				continue;
 
-			/* start 20 msec resume signaling from this port,
-			 * and make khubd collect PORT_STAT_C_SUSPEND to
+			/* start USB_RESUME_TIMEOUT resume signaling from this
+			 * port, and make hub_wq collect PORT_STAT_C_SUSPEND to
 			 * stop that signaling.
 			 */
-			oxu->reset_done[i] = jiffies + msecs_to_jiffies(20);
+			oxu->reset_done[i] = jiffies +
+				msecs_to_jiffies(USB_RESUME_TIMEOUT);
 			oxu_dbg(oxu, "port %d remote wakeup\n", i + 1);
 			mod_timer(&hcd->rh_timer, oxu->reset_done[i]);
 		}
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index a6fd8f53..6656dfd 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -2301,7 +2301,7 @@ static int r8a66597_bus_resume(struct usb_hcd *hcd)
 		rh->port &= ~USB_PORT_STAT_SUSPEND;
 		rh->port |= USB_PORT_STAT_C_SUSPEND << 16;
 		r8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);
-		msleep(50);
+		msleep(USB_RESUME_TIMEOUT);
 		r8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);
 	}
 
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index b2ec7fe..b4cad93 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -1251,7 +1251,7 @@ sl811h_hub_control(
 			sl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);
 
 			mod_timer(&sl811->timer, jiffies
-					+ msecs_to_jiffies(20));
+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT));
 			break;
 		case USB_PORT_FEAT_POWER:
 			port_power(sl811, 0);
diff --git a/drivers/usb/host/whci/qset.c b/drivers/usb/host/whci/qset.c
index dc31c42..9f1c053 100644
--- a/drivers/usb/host/whci/qset.c
+++ b/drivers/usb/host/whci/qset.c
@@ -377,6 +377,10 @@ static int qset_fill_page_list(struct whc *whc, struct whc_std *std, gfp_t mem_f
 	if (std->pl_virt == NULL)
 		return -ENOMEM;
 	std->dma_addr = dma_map_single(whc->wusbhc.dev, std->pl_virt, pl_len, DMA_TO_DEVICE);
+	if (dma_mapping_error(whc->wusbhc.dev, std->dma_addr)) {
+		kfree(std->pl_virt);
+		return -EFAULT;
+	}
 
 	for (p = 0; p < std->num_pointers; p++) {
 		std->pl_virt[p].buf_ptr = cpu_to_le64(dma_addr);
diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c
index d939376..0f71c3a 100644
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -468,10 +468,13 @@ static void xhci_hub_report_link_state(struct xhci_hcd *xhci,
 	u32 pls = status_reg & PORT_PLS_MASK;
 
 	/* resume state is a xHCI internal state.
-	 * Do not report it to usb core.
+	 * Do not report it to usb core, instead, pretend to be U3,
+	 * thus usb core knows it's not ready for transfer
 	 */
-	if (pls == XDEV_RESUME)
+	if (pls == XDEV_RESUME) {
+		*status |= USB_SS_PORT_LS_U3;
 		return;
+	}
 
 	/* When the CAS bit is set then warm reset
 	 * should be performed on port
@@ -1045,10 +1048,10 @@ int xhci_bus_suspend(struct usb_hcd *hcd)
 	spin_lock_irqsave(&xhci->lock, flags);
 
 	if (hcd->self.root_hub->do_remote_wakeup) {
-		if (bus_state->resuming_ports) {
+		if (bus_state->resuming_ports ||	/* USB2 */
+		    bus_state->port_remote_wakeup) {	/* USB3 */
 			spin_unlock_irqrestore(&xhci->lock, flags);
-			xhci_dbg(xhci, "suspend failed because "
-						"a port is resuming\n");
+			xhci_dbg(xhci, "suspend failed because a port is resuming\n");
 			return -EBUSY;
 		}
 	}
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 677f032..af9e4e8 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -1400,10 +1400,10 @@ int xhci_endpoint_init(struct xhci_hcd *xhci,
 		/* Attempt to use the ring cache */
 		if (virt_dev->num_rings_cached == 0)
 			return -ENOMEM;
+		virt_dev->num_rings_cached--;
 		virt_dev->eps[ep_index].new_ring =
 			virt_dev->ring_cache[virt_dev->num_rings_cached];
 		virt_dev->ring_cache[virt_dev->num_rings_cached] = NULL;
-		virt_dev->num_rings_cached--;
 		xhci_reinit_cached_ring(xhci, virt_dev->eps[ep_index].new_ring,
 					1, type);
 	}
@@ -1473,10 +1473,10 @@ int xhci_endpoint_init(struct xhci_hcd *xhci,
 	 * use Event Data TRBs, and we don't chain in a link TRB on short
 	 * transfers, we're basically dividing by 1.
 	 *
-	 * xHCI 1.0 specification indicates that the Average TRB Length should
-	 * be set to 8 for control endpoints.
+	 * xHCI 1.0 and 1.1 specification indicates that the Average TRB Length
+	 * should be set to 8 for control endpoints.
 	 */
-	if (usb_endpoint_xfer_control(&ep->desc) && xhci->hci_version == 0x100)
+	if (usb_endpoint_xfer_control(&ep->desc) && xhci->hci_version >= 0x100)
 		ep_ctx->tx_info |= cpu_to_le32(AVG_TRB_LENGTH_FOR_EP(8));
 	else
 		ep_ctx->tx_info |=
@@ -1861,6 +1861,11 @@ no_bw:
 	kfree(xhci->port_array);
 	kfree(xhci->rh_bw);
 
+	xhci->usb2_ports = NULL;
+	xhci->usb3_ports = NULL;
+	xhci->port_array = NULL;
+	xhci->rh_bw = NULL;
+
 	xhci->page_size = 0;
 	xhci->page_shift = 0;
 	xhci->bus_state[0].bus_suspended = 0;
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index 0e57bcb..2320e20 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -94,6 +94,7 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
 		xhci->quirks |= XHCI_LPM_SUPPORT;
 		xhci->quirks |= XHCI_INTEL_HOST;
+		xhci->quirks |= XHCI_AVOID_BEI;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
 			pdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {
@@ -109,7 +110,6 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		 * PPT chipsets.
 		 */
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
-		xhci->quirks |= XHCI_AVOID_BEI;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 9948890..98e3b20 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -85,7 +85,7 @@ dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg,
 		return 0;
 	/* offset in TRBs */
 	segment_offset = trb - seg->trbs;
-	if (segment_offset > TRBS_PER_SEGMENT)
+	if (segment_offset >= TRBS_PER_SEGMENT)
 		return 0;
 	return seg->dma + (segment_offset * sizeof(*trb));
 }
@@ -1669,6 +1669,9 @@ static void handle_port_status(struct xhci_hcd *xhci,
 		usb_hcd_resume_root_hub(hcd);
 	}
 
+	if (hcd->speed == HCD_USB3 && (temp & PORT_PLS_MASK) == XDEV_INACTIVE)
+		bus_state->port_remote_wakeup &= ~(1 << faked_port_index);
+
 	if ((temp & PORT_PLC) && (temp & PORT_PLS_MASK) == XDEV_RESUME) {
 		xhci_dbg(xhci, "port resume event for port %d\n", port_id);
 
@@ -1697,7 +1700,7 @@ static void handle_port_status(struct xhci_hcd *xhci,
 		} else {
 			xhci_dbg(xhci, "resume HS port %d\n", port_id);
 			bus_state->resume_done[faked_port_index] = jiffies +
-				msecs_to_jiffies(20);
+				msecs_to_jiffies(USB_RESUME_TIMEOUT);
 			set_bit(faked_port_index, &bus_state->resuming_ports);
 			mod_timer(&hcd->rh_timer,
 				  bus_state->resume_done[faked_port_index]);
@@ -2144,8 +2147,13 @@ static int process_isoc_td(struct xhci_hcd *xhci, struct xhci_td *td,
 		break;
 	case COMP_DEV_ERR:
 	case COMP_STALL:
+		frame->status = -EPROTO;
+		skip_td = true;
+		break;
 	case COMP_TX_ERR:
 		frame->status = -EPROTO;
+		if (event_trb != td->last_trb)
+			return 0;
 		skip_td = true;
 		break;
 	case COMP_STOP:
@@ -2340,6 +2348,7 @@ static int handle_tx_event(struct xhci_hcd *xhci,
 	u32 trb_comp_code;
 	int ret = 0;
 	int td_num = 0;
+	bool handling_skipped_tds = false;
 
 	slot_id = TRB_TO_SLOT_ID(le32_to_cpu(event->flags));
 	xdev = xhci->devs[slot_id];
@@ -2473,6 +2482,10 @@ static int handle_tx_event(struct xhci_hcd *xhci,
 		ep->skip = true;
 		xhci_dbg(xhci, "Miss service interval error, set skip flag\n");
 		goto cleanup;
+	case COMP_PING_ERR:
+		ep->skip = true;
+		xhci_dbg(xhci, "No Ping response error, Skip one Isoc TD\n");
+		goto cleanup;
 	default:
 		if (xhci_is_vendor_info_code(xhci, trb_comp_code)) {
 			status = 0;
@@ -2604,13 +2617,18 @@ static int handle_tx_event(struct xhci_hcd *xhci,
 						 ep, &status);
 
 cleanup:
+
+
+		handling_skipped_tds = ep->skip &&
+			trb_comp_code != COMP_MISSED_INT &&
+			trb_comp_code != COMP_PING_ERR;
+
 		/*
-		 * Do not update event ring dequeue pointer if ep->skip is set.
-		 * Will roll back to continue process missed tds.
+		 * Do not update event ring dequeue pointer if we're in a loop
+		 * processing missed tds.
 		 */
-		if (trb_comp_code == COMP_MISSED_INT || !ep->skip) {
+		if (!handling_skipped_tds)
 			inc_deq(xhci, xhci->event_ring);
-		}
 
 		if (ret) {
 			urb = td->urb;
@@ -2654,7 +2672,7 @@ cleanup:
 	 * Process them as short transfer until reach the td pointed by
 	 * the event.
 	 */
-	} while (ep->skip && trb_comp_code != COMP_MISSED_INT);
+	} while (handling_skipped_tds);
 
 	return 0;
 }
@@ -2762,7 +2780,7 @@ irqreturn_t xhci_irq(struct usb_hcd *hcd)
 		xhci_halt(xhci);
 hw_died:
 		spin_unlock(&xhci->lock);
-		return -ESHUTDOWN;
+		return IRQ_HANDLED;
 	}
 
 	/*
@@ -3159,9 +3177,11 @@ static int queue_bulk_sg_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	struct xhci_td *td;
 	struct scatterlist *sg;
 	int num_sgs;
-	int trb_buff_len, this_sg_len, running_total;
+	int trb_buff_len, this_sg_len, running_total, ret;
 	unsigned int total_packet_count;
+	bool zero_length_needed;
 	bool first_trb;
+	int last_trb_num;
 	u64 addr;
 	bool more_trbs_coming;
 
@@ -3177,13 +3197,27 @@ static int queue_bulk_sg_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	total_packet_count = DIV_ROUND_UP(urb->transfer_buffer_length,
 			usb_endpoint_maxp(&urb->ep->desc));
 
-	trb_buff_len = prepare_transfer(xhci, xhci->devs[slot_id],
+	ret = prepare_transfer(xhci, xhci->devs[slot_id],
 			ep_index, urb->stream_id,
 			num_trbs, urb, 0, mem_flags);
-	if (trb_buff_len < 0)
-		return trb_buff_len;
+	if (ret < 0)
+		return ret;
 
 	urb_priv = urb->hcpriv;
+
+	/* Deal with URB_ZERO_PACKET - need one more td/trb */
+	zero_length_needed = urb->transfer_flags & URB_ZERO_PACKET &&
+		urb_priv->length == 2;
+	if (zero_length_needed) {
+		num_trbs++;
+		xhci_dbg(xhci, "Creating zero length td.\n");
+		ret = prepare_transfer(xhci, xhci->devs[slot_id],
+				ep_index, urb->stream_id,
+				1, urb, 1, mem_flags);
+		if (ret < 0)
+			return ret;
+	}
+
 	td = urb_priv->td[0];
 
 	/*
@@ -3213,6 +3247,7 @@ static int queue_bulk_sg_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		trb_buff_len = urb->transfer_buffer_length;
 
 	first_trb = true;
+	last_trb_num = zero_length_needed ? 2 : 1;
 	/* Queue the first TRB, even if it's zero-length */
 	do {
 		u32 field = 0;
@@ -3230,12 +3265,15 @@ static int queue_bulk_sg_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		/* Chain all the TRBs together; clear the chain bit in the last
 		 * TRB to indicate it's the last TRB in the chain.
 		 */
-		if (num_trbs > 1) {
+		if (num_trbs > last_trb_num) {
 			field |= TRB_CHAIN;
-		} else {
-			/* FIXME - add check for ZERO_PACKET flag before this */
+		} else if (num_trbs == last_trb_num) {
 			td->last_trb = ep_ring->enqueue;
 			field |= TRB_IOC;
+		} else if (zero_length_needed && num_trbs == 1) {
+			trb_buff_len = 0;
+			urb_priv->td[1]->last_trb = ep_ring->enqueue;
+			field |= TRB_IOC;
 		}
 
 		/* Only set interrupt on short packet for IN endpoints */
@@ -3297,7 +3335,7 @@ static int queue_bulk_sg_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		if (running_total + trb_buff_len > urb->transfer_buffer_length)
 			trb_buff_len =
 				urb->transfer_buffer_length - running_total;
-	} while (running_total < urb->transfer_buffer_length);
+	} while (num_trbs > 0);
 
 	check_trb_math(urb, num_trbs, running_total);
 	giveback_first_trb(xhci, slot_id, ep_index, urb->stream_id,
@@ -3315,7 +3353,9 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	int num_trbs;
 	struct xhci_generic_trb *start_trb;
 	bool first_trb;
+	int last_trb_num;
 	bool more_trbs_coming;
+	bool zero_length_needed;
 	int start_cycle;
 	u32 field, length_field;
 
@@ -3346,7 +3386,6 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		num_trbs++;
 		running_total += TRB_MAX_BUFF_SIZE;
 	}
-	/* FIXME: this doesn't deal with URB_ZERO_PACKET - need one more */
 
 	ret = prepare_transfer(xhci, xhci->devs[slot_id],
 			ep_index, urb->stream_id,
@@ -3355,6 +3394,20 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		return ret;
 
 	urb_priv = urb->hcpriv;
+
+	/* Deal with URB_ZERO_PACKET - need one more td/trb */
+	zero_length_needed = urb->transfer_flags & URB_ZERO_PACKET &&
+		urb_priv->length == 2;
+	if (zero_length_needed) {
+		num_trbs++;
+		xhci_dbg(xhci, "Creating zero length td.\n");
+		ret = prepare_transfer(xhci, xhci->devs[slot_id],
+				ep_index, urb->stream_id,
+				1, urb, 1, mem_flags);
+		if (ret < 0)
+			return ret;
+	}
+
 	td = urb_priv->td[0];
 
 	/*
@@ -3376,7 +3429,7 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		trb_buff_len = urb->transfer_buffer_length;
 
 	first_trb = true;
-
+	last_trb_num = zero_length_needed ? 2 : 1;
 	/* Queue the first TRB, even if it's zero-length */
 	do {
 		u32 remainder = 0;
@@ -3393,12 +3446,15 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		/* Chain all the TRBs together; clear the chain bit in the last
 		 * TRB to indicate it's the last TRB in the chain.
 		 */
-		if (num_trbs > 1) {
+		if (num_trbs > last_trb_num) {
 			field |= TRB_CHAIN;
-		} else {
-			/* FIXME - add check for ZERO_PACKET flag before this */
+		} else if (num_trbs == last_trb_num) {
 			td->last_trb = ep_ring->enqueue;
 			field |= TRB_IOC;
+		} else if (zero_length_needed && num_trbs == 1) {
+			trb_buff_len = 0;
+			urb_priv->td[1]->last_trb = ep_ring->enqueue;
+			field |= TRB_IOC;
 		}
 
 		/* Only set interrupt on short packet for IN endpoints */
@@ -3436,7 +3492,7 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		trb_buff_len = urb->transfer_buffer_length - running_total;
 		if (trb_buff_len > TRB_MAX_BUFF_SIZE)
 			trb_buff_len = TRB_MAX_BUFF_SIZE;
-	} while (running_total < urb->transfer_buffer_length);
+	} while (num_trbs > 0);
 
 	check_trb_math(urb, num_trbs, running_total);
 	giveback_first_trb(xhci, slot_id, ep_index, urb->stream_id,
@@ -3503,8 +3559,8 @@ int xhci_queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	if (start_cycle == 0)
 		field |= 0x1;
 
-	/* xHCI 1.0 6.4.1.2.1: Transfer Type field */
-	if (xhci->hci_version == 0x100) {
+	/* xHCI 1.0/1.1 6.4.1.2.1: Transfer Type field */
+	if (xhci->hci_version >= 0x100) {
 		if (urb->transfer_buffer_length > 0) {
 			if (setup->bRequestType & USB_DIR_IN)
 				field |= TRB_TX_TYPE(TRB_DATA_IN);
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 10223f2..507677b 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -139,7 +139,8 @@ static int xhci_start(struct xhci_hcd *xhci)
 				"waited %u microseconds.\n",
 				XHCI_MAX_HALT_USEC);
 	if (!ret)
-		xhci->xhc_state &= ~XHCI_STATE_HALTED;
+		xhci->xhc_state &= ~(XHCI_STATE_HALTED | XHCI_STATE_DYING);
+
 	return ret;
 }
 
@@ -1299,6 +1300,11 @@ int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)
 
 	if (usb_endpoint_xfer_isoc(&urb->ep->desc))
 		size = urb->number_of_packets;
+	else if (usb_endpoint_is_bulk_out(&urb->ep->desc) &&
+	    urb->transfer_buffer_length > 0 &&
+	    urb->transfer_flags & URB_ZERO_PACKET &&
+	    !(urb->transfer_buffer_length % usb_endpoint_maxp(&urb->ep->desc)))
+		size = 2;
 	else
 		size = 1;
 
@@ -1496,7 +1502,9 @@ int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	if (temp == 0xffffffff || (xhci->xhc_state & XHCI_STATE_HALTED)) {
 		xhci_dbg(xhci, "HW died, freeing TD.\n");
 		urb_priv = urb->hcpriv;
-		for (i = urb_priv->td_cnt; i < urb_priv->length; i++) {
+		for (i = urb_priv->td_cnt;
+		     i < urb_priv->length && xhci->devs[urb->dev->slot_id];
+		     i++) {
 			td = urb_priv->td[i];
 			if (!list_empty(&td->td_list))
 				list_del_init(&td->td_list);
@@ -3356,6 +3364,9 @@ int xhci_discover_or_reset_device(struct usb_hcd *hcd, struct usb_device *udev)
 			return -EINVAL;
 	}
 
+	if (virt_dev->tt_info)
+		old_active_eps = virt_dev->tt_info->active_eps;
+
 	if (virt_dev->udev != udev) {
 		/* If the virt_dev and the udev does not match, this virt_dev
 		 * may belong to another udev.
@@ -4606,8 +4617,16 @@ int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,
 	ctrl_ctx->add_flags |= cpu_to_le32(SLOT_FLAG);
 	slot_ctx = xhci_get_slot_ctx(xhci, config_cmd->in_ctx);
 	slot_ctx->dev_info |= cpu_to_le32(DEV_HUB);
+	/*
+	 * refer to section 6.2.2: MTT should be 0 for full speed hub,
+	 * but it may be already set to 1 when setup an xHCI virtual
+	 * device, so clear it anyway.
+	 */
 	if (tt->multi)
 		slot_ctx->dev_info |= cpu_to_le32(DEV_MTT);
+	else if (hdev->speed == USB_SPEED_FULL)
+		slot_ctx->dev_info &= cpu_to_le32(~DEV_MTT);
+
 	if (xhci->hci_version > 0x95) {
 		xhci_dbg(xhci, "xHCI version %x needs hub "
 				"TT think time and number of ports\n",
@@ -4771,6 +4790,9 @@ static int __init xhci_hcd_init(void)
 {
 	int retval;
 
+	if (usb_disabled())
+		return -ENODEV;
+
 	retval = xhci_register_pci();
 	if (retval < 0) {
 		printk(KERN_DEBUG "Problem registering PCI driver.");
@@ -4798,6 +4820,7 @@ static int __init xhci_hcd_init(void)
 	BUILD_BUG_ON(sizeof(struct xhci_intr_reg) != 8*32/8);
 	/* xhci_run_regs has eight fields and embeds 128 xhci_intr_regs */
 	BUILD_BUG_ON(sizeof(struct xhci_run_regs) != (8+8*128)*32/8);
+
 	return 0;
 unreg_pci:
 	xhci_unregister_pci();
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 373d4da..deb2537 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -280,6 +280,7 @@ struct xhci_op_regs {
 #define XDEV_U0		(0x0 << 5)
 #define XDEV_U2		(0x2 << 5)
 #define XDEV_U3		(0x3 << 5)
+#define XDEV_INACTIVE	(0x6 << 5)
 #define XDEV_RESUME	(0xf << 5)
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 << 9)
@@ -1237,7 +1238,7 @@ union xhci_trb {
  * since the command ring is 64-byte aligned.
  * It must also be greater than 16.
  */
-#define TRBS_PER_SEGMENT	64
+#define TRBS_PER_SEGMENT	256
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)
diff --git a/drivers/usb/misc/iowarrior.c b/drivers/usb/misc/iowarrior.c
index d36f34e..4c24ba0 100644
--- a/drivers/usb/misc/iowarrior.c
+++ b/drivers/usb/misc/iowarrior.c
@@ -792,6 +792,12 @@ static int iowarrior_probe(struct usb_interface *interface,
 	iface_desc = interface->cur_altsetting;
 	dev->product_id = le16_to_cpu(udev->descriptor.idProduct);
 
+	if (iface_desc->desc.bNumEndpoints < 1) {
+		dev_err(&interface->dev, "Invalid number of endpoints\n");
+		retval = -EINVAL;
+		goto error;
+	}
+
 	/* set up the endpoint information */
 	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
 		endpoint = &iface_desc->endpoint[i].desc;
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index da0caf3..462a7d5 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -133,7 +133,7 @@ static inline struct musb *dev_to_musb(struct device *dev)
 /*-------------------------------------------------------------------------*/
 
 #ifndef CONFIG_BLACKFIN
-static int musb_ulpi_read(struct usb_phy *phy, u32 offset)
+static int musb_ulpi_read(struct usb_phy *phy, u32 reg)
 {
 	void __iomem *addr = phy->io_priv;
 	int	i = 0;
@@ -152,7 +152,7 @@ static int musb_ulpi_read(struct usb_phy *phy, u32 offset)
 	 * ULPICarKitControlDisableUTMI after clearing POWER_SUSPENDM.
 	 */
 
-	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)offset);
+	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)reg);
 	musb_writeb(addr, MUSB_ULPI_REG_CONTROL,
 			MUSB_ULPI_REG_REQ | MUSB_ULPI_RDN_WR);
 
@@ -177,7 +177,7 @@ out:
 	return ret;
 }
 
-static int musb_ulpi_write(struct usb_phy *phy, u32 offset, u32 data)
+static int musb_ulpi_write(struct usb_phy *phy, u32 val, u32 reg)
 {
 	void __iomem *addr = phy->io_priv;
 	int	i = 0;
@@ -192,8 +192,8 @@ static int musb_ulpi_write(struct usb_phy *phy, u32 offset, u32 data)
 	power &= ~MUSB_POWER_SUSPENDM;
 	musb_writeb(addr, MUSB_POWER, power);
 
-	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)offset);
-	musb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)data);
+	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)reg);
+	musb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)val);
 	musb_writeb(addr, MUSB_ULPI_REG_CONTROL, MUSB_ULPI_REG_REQ);
 
 	while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 9d3044b..c6cc520 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -581,14 +581,13 @@ musb_rx_reinit(struct musb *musb, struct musb_qh *qh, struct musb_hw_ep *ep)
 		musb_writew(ep->regs, MUSB_TXCSR, 0);
 
 	/* scrub all previous state, clearing toggle */
-	} else {
-		csr = musb_readw(ep->regs, MUSB_RXCSR);
-		if (csr & MUSB_RXCSR_RXPKTRDY)
-			WARNING("rx%d, packet/%d ready?\n", ep->epnum,
-				musb_readw(ep->regs, MUSB_RXCOUNT));
-
-		musb_h_flush_rxfifo(ep, MUSB_RXCSR_CLRDATATOG);
 	}
+	csr = musb_readw(ep->regs, MUSB_RXCSR);
+	if (csr & MUSB_RXCSR_RXPKTRDY)
+		WARNING("rx%d, packet/%d ready?\n", ep->epnum,
+			musb_readw(ep->regs, MUSB_RXCOUNT));
+
+	musb_h_flush_rxfifo(ep, MUSB_RXCSR_CLRDATATOG);
 
 	/* target addr and (for multipoint) hub addr/port */
 	if (musb->is_multipoint) {
@@ -948,9 +947,15 @@ static void musb_bulk_nak_timeout(struct musb *musb, struct musb_hw_ep *ep,
 	if (is_in) {
 		dma = is_dma_capable() ? ep->rx_channel : NULL;
 
-		/* clear nak timeout bit */
+		/*
+		 * Need to stop the transaction by clearing REQPKT first
+		 * then the NAK Timeout bit ref MUSBMHDRC USB 2.0 HIGH-SPEED
+		 * DUAL-ROLE CONTROLLER Programmer's Guide, section 9.2.2
+		 */
 		rx_csr = musb_readw(epio, MUSB_RXCSR);
 		rx_csr |= MUSB_RXCSR_H_WZC_BITS;
+		rx_csr &= ~MUSB_RXCSR_H_REQPKT;
+		musb_writew(epio, MUSB_RXCSR, rx_csr);
 		rx_csr &= ~MUSB_RXCSR_DATAERROR;
 		musb_writew(epio, MUSB_RXCSR, rx_csr);
 
diff --git a/drivers/usb/phy/phy-ambarella.c b/drivers/usb/phy/phy-ambarella.c
index 1bb9320..8a44202 100644
--- a/drivers/usb/phy/phy-ambarella.c
+++ b/drivers/usb/phy/phy-ambarella.c
@@ -347,14 +347,10 @@ static int ambarella_init_host_phy(struct platform_device *pdev,
 static int ambarella_phy_init(struct usb_phy *phy)
 {
 	struct ambarella_phy *amb_phy = to_ambarella_phy(phy);
-	u32 ana_val;
+	u32 ana_val = 0x3006;
 
 	/* If there are 2 PHYs, no matter which PHY need to be initialized,
 	 * we initialize all of them at the same time */
-	if (amb_phy->host_phy_num < 2)
-		ana_val = 0x4;
-	else
-		ana_val = 0x1002;
 
 	if (!(amba_readl(amb_phy->ana_reg) & ana_val)) {
 		amba_setbitsl(amb_phy->ana_reg, ana_val);
diff --git a/drivers/usb/phy/phy.c b/drivers/usb/phy/phy.c
index a9984c7..5f79d8e 100644
--- a/drivers/usb/phy/phy.c
+++ b/drivers/usb/phy/phy.c
@@ -78,7 +78,9 @@ static void devm_usb_phy_release(struct device *dev, void *res)
 
 static int devm_usb_phy_match(struct device *dev, void *res, void *match_data)
 {
-	return res == match_data;
+	struct usb_phy **phy = res;
+
+	return *phy == match_data;
 }
 
 /**
diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c
index 45b9401..157a9f9 100644
--- a/drivers/usb/renesas_usbhs/fifo.c
+++ b/drivers/usb/renesas_usbhs/fifo.c
@@ -166,7 +166,8 @@ static int usbhsf_pkt_handler(struct usbhs_pipe *pipe, int type)
 		goto __usbhs_pkt_handler_end;
 	}
 
-	ret = func(pkt, &is_done);
+	if (likely(func))
+		ret = func(pkt, &is_done);
 
 	if (is_done)
 		__usbhsf_pkt_del(pkt);
@@ -933,6 +934,7 @@ static int usbhsf_dma_try_pop(struct usbhs_pkt *pkt, int *is_done)
 
 	pkt->trans = len;
 
+	usbhsf_tx_irq_ctrl(pipe, 0);
 	INIT_WORK(&pkt->work, xfer_work);
 	schedule_work(&pkt->work);
 
diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index ed4949f..64223a9 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -558,6 +558,9 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct usbhs_pipe *pipe;
 	int ret = -EIO;
+	unsigned long flags;
+
+	usbhs_lock(priv, flags);
 
 	/*
 	 * if it already have pipe,
@@ -566,7 +569,8 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 	if (uep->pipe) {
 		usbhs_pipe_clear(uep->pipe);
 		usbhs_pipe_sequence_data0(uep->pipe);
-		return 0;
+		ret = 0;
+		goto usbhsg_ep_enable_end;
 	}
 
 	pipe = usbhs_pipe_malloc(priv,
@@ -594,6 +598,9 @@ static int usbhsg_ep_enable(struct usb_ep *ep,
 		ret = 0;
 	}
 
+usbhsg_ep_enable_end:
+	usbhs_unlock(priv, flags);
+
 	return ret;
 }
 
diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c
index 79e9ea0..0093261 100644
--- a/drivers/usb/serial/cp210x.c
+++ b/drivers/usb/serial/cp210x.c
@@ -98,6 +98,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x10C4, 0x81AC) }, /* MSD Dash Hawk */
 	{ USB_DEVICE(0x10C4, 0x81AD) }, /* INSYS USB Modem */
 	{ USB_DEVICE(0x10C4, 0x81C8) }, /* Lipowsky Industrie Elektronik GmbH, Baby-JTAG */
+	{ USB_DEVICE(0x10C4, 0x81D7) }, /* IAI Corp. RCB-CV-USB USB to RS485 Adaptor */
 	{ USB_DEVICE(0x10C4, 0x81E2) }, /* Lipowsky Industrie Elektronik GmbH, Baby-LIN */
 	{ USB_DEVICE(0x10C4, 0x81E7) }, /* Aerocomm Radio */
 	{ USB_DEVICE(0x10C4, 0x81E8) }, /* Zephyr Bioharness */
@@ -107,6 +108,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x10C4, 0x826B) }, /* Cygnal Integrated Products, Inc., Fasttrax GPS demonstration module */
 	{ USB_DEVICE(0x10C4, 0x8281) }, /* Nanotec Plug & Drive */
 	{ USB_DEVICE(0x10C4, 0x8293) }, /* Telegesis ETRX2USB */
+	{ USB_DEVICE(0x10C4, 0x82F4) }, /* Starizona MicroTouch */
 	{ USB_DEVICE(0x10C4, 0x82F9) }, /* Procyon AVS */
 	{ USB_DEVICE(0x10C4, 0x8341) }, /* Siemens MC35PU GPRS Modem */
 	{ USB_DEVICE(0x10C4, 0x8382) }, /* Cygnal Integrated Products, Inc. */
@@ -116,6 +118,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x10C4, 0x8418) }, /* IRZ Automation Teleport SG-10 GSM/GPRS Modem */
 	{ USB_DEVICE(0x10C4, 0x846E) }, /* BEI USB Sensor Interface (VCP) */
 	{ USB_DEVICE(0x10C4, 0x8477) }, /* Balluff RFID */
+	{ USB_DEVICE(0x10C4, 0x84B6) }, /* Starizona Hyperion */
 	{ USB_DEVICE(0x10C4, 0x85EA) }, /* AC-Services IBUS-IF */
 	{ USB_DEVICE(0x10C4, 0x85EB) }, /* AC-Services CIS-IBUS */
 	{ USB_DEVICE(0x10C4, 0x85F8) }, /* Virtenio Preon32 */
@@ -127,10 +130,11 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x10C4, 0x88A5) }, /* Planet Innovation Ingeni ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x8946) }, /* Ketra N1 Wireless Interface */
 	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
+	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */
+	{ USB_DEVICE(0x10C4, 0x8A2A) }, /* HubZ dual ZigBee and Z-Wave dongle */
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
-	{ USB_DEVICE(0x10C4, 0xEA80) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA71) }, /* Infinity GPS-MIC-1 Radio Monophone */
 	{ USB_DEVICE(0x10C4, 0xF001) }, /* Elan Digital Systems USBscope50 */
 	{ USB_DEVICE(0x10C4, 0xF002) }, /* Elan Digital Systems USBwave12 */
@@ -138,6 +142,8 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x10C4, 0xF004) }, /* Elan Digital Systems USBcount50 */
 	{ USB_DEVICE(0x10C5, 0xEA61) }, /* Silicon Labs MobiData GPRS USB Modem */
 	{ USB_DEVICE(0x10CE, 0xEA6A) }, /* Silicon Labs MobiData GPRS USB Modem 100EU */
+	{ USB_DEVICE(0x12B8, 0xEC60) }, /* Link G4 ECU */
+	{ USB_DEVICE(0x12B8, 0xEC62) }, /* Link G4+ ECU */
 	{ USB_DEVICE(0x13AD, 0x9999) }, /* Baltech card reader */
 	{ USB_DEVICE(0x1555, 0x0004) }, /* Owen AC4 USB-RS485 Converter */
 	{ USB_DEVICE(0x166A, 0x0201) }, /* Clipsal 5500PACA C-Bus Pascal Automation Controller */
@@ -159,6 +165,11 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x17F4, 0xAAAA) }, /* Wavesense Jazz blood glucose meter */
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
+	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */
+	{ USB_DEVICE(0x1901, 0x0190) }, /* GE B850 CP2105 Recorder interface */
+	{ USB_DEVICE(0x1901, 0x0193) }, /* GE B650 CP2104 PMC interface */
+	{ USB_DEVICE(0x1901, 0x0194) },	/* GE Healthcare Remote Alarm Box */
+	{ USB_DEVICE(0x19CF, 0x3000) }, /* Parrot NMEA GPS Flight Recorder */
 	{ USB_DEVICE(0x1ADB, 0x0001) }, /* Schweitzer Engineering C662 Cable */
 	{ USB_DEVICE(0x1B1C, 0x1C00) }, /* Corsair USB Dongle */
 	{ USB_DEVICE(0x1BA4, 0x0002) },	/* Silicon Labs 358x factory default */
@@ -185,6 +196,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(0x1FB9, 0x0602) }, /* Lake Shore Model 648 Magnet Power Supply */
 	{ USB_DEVICE(0x1FB9, 0x0700) }, /* Lake Shore Model 737 VSM Controller */
 	{ USB_DEVICE(0x1FB9, 0x0701) }, /* Lake Shore Model 776 Hall Matrix */
+	{ USB_DEVICE(0x2626, 0xEA60) }, /* Aruba Networks 7xxx USB Serial Console */
 	{ USB_DEVICE(0x3195, 0xF190) }, /* Link Instruments MSO-19 */
 	{ USB_DEVICE(0x3195, 0xF280) }, /* Link Instruments MSO-28 */
 	{ USB_DEVICE(0x3195, 0xF281) }, /* Link Instruments MSO-28 */
diff --git a/drivers/usb/serial/cypress_m8.c b/drivers/usb/serial/cypress_m8.c
index 0821201..09f0f63 100644
--- a/drivers/usb/serial/cypress_m8.c
+++ b/drivers/usb/serial/cypress_m8.c
@@ -449,6 +449,11 @@ static int cypress_generic_port_probe(struct usb_serial_port *port)
 	struct usb_serial *serial = port->serial;
 	struct cypress_private *priv;
 
+	if (!port->interrupt_out_urb || !port->interrupt_in_urb) {
+		dev_err(&port->dev, "required endpoint is missing\n");
+		return -ENODEV;
+	}
+
 	priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
@@ -606,12 +611,6 @@ static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
 		cypress_set_termios(tty, port, &priv->tmp_termios);
 
 	/* setup the port and start reading from the device */
-	if (!port->interrupt_in_urb) {
-		dev_err(&port->dev, "%s - interrupt_in_urb is empty!\n",
-			__func__);
-		return -1;
-	}
-
 	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
 		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
 		port->interrupt_in_urb->transfer_buffer,
diff --git a/drivers/usb/serial/digi_acceleport.c b/drivers/usb/serial/digi_acceleport.c
index 7b807d3..8c34d9c 100644
--- a/drivers/usb/serial/digi_acceleport.c
+++ b/drivers/usb/serial/digi_acceleport.c
@@ -1253,8 +1253,27 @@ static int digi_port_init(struct usb_serial_port *port, unsigned port_num)
 
 static int digi_startup(struct usb_serial *serial)
 {
+	struct device *dev = &serial->interface->dev;
 	struct digi_serial *serial_priv;
 	int ret;
+	int i;
+
+	/* check whether the device has the expected number of endpoints */
+	if (serial->num_port_pointers < serial->type->num_ports + 1) {
+		dev_err(dev, "OOB endpoints missing\n");
+		return -ENODEV;
+	}
+
+	for (i = 0; i < serial->type->num_ports + 1 ; i++) {
+		if (!serial->port[i]->read_urb) {
+			dev_err(dev, "bulk-in endpoint missing\n");
+			return -ENODEV;
+		}
+		if (!serial->port[i]->write_urb) {
+			dev_err(dev, "bulk-out endpoint missing\n");
+			return -ENODEV;
+		}
+	}
 
 	serial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);
 	if (!serial_priv)
diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c
index cf127a0..4e86566 100644
--- a/drivers/usb/serial/ftdi_sio.c
+++ b/drivers/usb/serial/ftdi_sio.c
@@ -620,6 +620,11 @@ static struct usb_device_id id_table_combined [] = {
 		.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },
 	{ USB_DEVICE(FTDI_VID, FTDI_NT_ORIONLXM_PID),
 		.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },
+	{ USB_DEVICE(FTDI_VID, FTDI_SYNAPSE_SS200_PID) },
+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX_PID) },
+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX2_PID) },
+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX2WI_PID) },
+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX3_PID) },
 	/*
 	 * ELV devices:
 	 */
@@ -714,6 +719,7 @@ static struct usb_device_id id_table_combined [] = {
 	{ USB_DEVICE(XSENS_VID, XSENS_AWINDA_DONGLE_PID) },
 	{ USB_DEVICE(XSENS_VID, XSENS_AWINDA_STATION_PID) },
 	{ USB_DEVICE(XSENS_VID, XSENS_CONVERTER_PID) },
+	{ USB_DEVICE(XSENS_VID, XSENS_MTDEVBOARD_PID) },
 	{ USB_DEVICE(XSENS_VID, XSENS_MTW_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_OMNI1509) },
 	{ USB_DEVICE(MOBILITY_VID, MOBILITY_USB_SERIAL_PID) },
@@ -834,6 +840,7 @@ static struct usb_device_id id_table_combined [] = {
 	{ USB_DEVICE(FTDI_VID, FTDI_TURTELIZER_PID),
 		.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },
 	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID_USB60F) },
+	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID_SCU18) },
 	{ USB_DEVICE(FTDI_VID, FTDI_REU_TINY_PID) },
 
 	/* Papouch devices based on FTDI chip */
@@ -1899,8 +1906,12 @@ static int ftdi_8u2232c_probe(struct usb_serial *serial)
 {
 	struct usb_device *udev = serial->dev;
 
-	if ((udev->manufacturer && !strcmp(udev->manufacturer, "CALAO Systems")) ||
-	    (udev->product && !strcmp(udev->product, "BeagleBone/XDS100V2")))
+	if (udev->manufacturer && !strcmp(udev->manufacturer, "CALAO Systems"))
+		return ftdi_jtag_probe(serial);
+
+	if (udev->product &&
+		(!strcmp(udev->product, "BeagleBone/XDS100V2") ||
+		 !strcmp(udev->product, "SNAP Connect E10")))
 		return ftdi_jtag_probe(serial);
 
 	return 0;
diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h
index e8d3526..3eff1d6 100644
--- a/drivers/usb/serial/ftdi_sio_ids.h
+++ b/drivers/usb/serial/ftdi_sio_ids.h
@@ -155,6 +155,7 @@
 #define XSENS_AWINDA_STATION_PID 0x0101
 #define XSENS_AWINDA_DONGLE_PID 0x0102
 #define XSENS_MTW_PID		0x0200	/* Xsens MTw */
+#define XSENS_MTDEVBOARD_PID	0x0300	/* Motion Tracker Development Board */
 #define XSENS_CONVERTER_PID	0xD00D	/* Xsens USB-serial converter */
 
 /* Xsens devices using FTDI VID */
@@ -561,6 +562,20 @@
  */
 #define FTDI_NT_ORIONLXM_PID	0x7c90	/* OrionLXm Substation Automation Platform */
 
+/*
+ * Synapse Wireless product ids (FTDI_VID)
+ * http://www.synapse-wireless.com
+ */
+#define FTDI_SYNAPSE_SS200_PID 0x9090 /* SS200 - SNAP Stick 200 */
+
+/*
+ * CustomWare / ShipModul NMEA multiplexers product ids (FTDI_VID)
+ */
+#define FTDI_CUSTOMWARE_MINIPLEX_PID	0xfd48	/* MiniPlex first generation NMEA Multiplexer */
+#define FTDI_CUSTOMWARE_MINIPLEX2_PID	0xfd49	/* MiniPlex-USB and MiniPlex-2 series */
+#define FTDI_CUSTOMWARE_MINIPLEX2WI_PID	0xfd4a	/* MiniPlex-2Wi */
+#define FTDI_CUSTOMWARE_MINIPLEX3_PID	0xfd4b	/* MiniPlex-3 series */
+
 
 /********************************/
 /** third-party VID/PID combos **/
@@ -600,6 +615,7 @@
  */
 #define RATOC_VENDOR_ID		0x0584
 #define RATOC_PRODUCT_ID_USB60F	0xb020
+#define RATOC_PRODUCT_ID_SCU18	0xb03a
 
 /*
  * Infineon Technologies
diff --git a/drivers/usb/serial/io_edgeport.c b/drivers/usb/serial/io_edgeport.c
index 1477e85..c574d312 100644
--- a/drivers/usb/serial/io_edgeport.c
+++ b/drivers/usb/serial/io_edgeport.c
@@ -2988,16 +2988,9 @@ static void edge_disconnect(struct usb_serial *serial)
 {
 	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);
 
-	/* stop reads and writes on all ports */
-	/* free up our endpoint stuff */
 	if (edge_serial->is_epic) {
 		usb_kill_urb(edge_serial->interrupt_read_urb);
-		usb_free_urb(edge_serial->interrupt_read_urb);
-		kfree(edge_serial->interrupt_in_buffer);
-
 		usb_kill_urb(edge_serial->read_urb);
-		usb_free_urb(edge_serial->read_urb);
-		kfree(edge_serial->bulk_in_buffer);
 	}
 }
 
@@ -3010,6 +3003,16 @@ static void edge_release(struct usb_serial *serial)
 {
 	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);
 
+	if (edge_serial->is_epic) {
+		usb_kill_urb(edge_serial->interrupt_read_urb);
+		usb_free_urb(edge_serial->interrupt_read_urb);
+		kfree(edge_serial->interrupt_in_buffer);
+
+		usb_kill_urb(edge_serial->read_urb);
+		usb_free_urb(edge_serial->read_urb);
+		kfree(edge_serial->bulk_in_buffer);
+	}
+
 	kfree(edge_serial);
 }
 
diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 76c9a84..e03900e 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -532,7 +532,8 @@ static int ipaq_open(struct tty_struct *tty,
 	 * through. Since this has a reasonably high failure rate, we retry
 	 * several times.
 	 */
-	while (retries--) {
+	while (retries) {
+		retries--;
 		result = usb_control_msg(serial->dev,
 				usb_sndctrlpipe(serial->dev, 0), 0x22, 0x21,
 				0x1, 0, NULL, 0, 100);
diff --git a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c
index cec377b..32a67c6 100644
--- a/drivers/usb/serial/keyspan.c
+++ b/drivers/usb/serial/keyspan.c
@@ -2392,6 +2392,10 @@ static void keyspan_release(struct usb_serial *serial)
 
 	s_priv = usb_get_serial_data(serial);
 
+	/* Make sure to unlink the URBs submitted in attach. */
+	usb_kill_urb(s_priv->instat_urb);
+	usb_kill_urb(s_priv->indat_urb);
+
 	usb_free_urb(s_priv->instat_urb);
 	usb_free_urb(s_priv->indat_urb);
 	usb_free_urb(s_priv->glocont_urb);
diff --git a/drivers/usb/serial/mct_u232.c b/drivers/usb/serial/mct_u232.c
index 6a15adf..c14c29f 100644
--- a/drivers/usb/serial/mct_u232.c
+++ b/drivers/usb/serial/mct_u232.c
@@ -377,14 +377,21 @@ static void mct_u232_msr_to_state(struct usb_serial_port *port,
 
 static int mct_u232_port_probe(struct usb_serial_port *port)
 {
+	struct usb_serial *serial = port->serial;
 	struct mct_u232_private *priv;
 
+	/* check first to simplify error handling */
+	if (!serial->port[1] || !serial->port[1]->interrupt_in_urb) {
+		dev_err(&port->dev, "expected endpoint missing\n");
+		return -ENODEV;
+	}
+
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
 	/* Use second interrupt-in endpoint for reading. */
-	priv->read_urb = port->serial->port[1]->interrupt_in_urb;
+	priv->read_urb = serial->port[1]->interrupt_in_urb;
 	priv->read_urb->context = port;
 
 	spin_lock_init(&priv->lock);
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index b62eda5..9e81853 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -162,6 +162,7 @@ static void option_instat_callback(struct urb *urb);
 #define NOVATELWIRELESS_PRODUCT_HSPA_EMBEDDED_HIGHSPEED	0x9001
 #define NOVATELWIRELESS_PRODUCT_E362		0x9010
 #define NOVATELWIRELESS_PRODUCT_E371		0x9011
+#define NOVATELWIRELESS_PRODUCT_U620L		0x9022
 #define NOVATELWIRELESS_PRODUCT_G2		0xA010
 #define NOVATELWIRELESS_PRODUCT_MC551		0xB001
 
@@ -268,14 +269,22 @@ static void option_instat_callback(struct urb *urb);
 #define TELIT_PRODUCT_CC864_SINGLE		0x1006
 #define TELIT_PRODUCT_DE910_DUAL		0x1010
 #define TELIT_PRODUCT_UE910_V2			0x1012
+#define TELIT_PRODUCT_LE922_USBCFG0		0x1042
+#define TELIT_PRODUCT_LE922_USBCFG3		0x1043
+#define TELIT_PRODUCT_LE922_USBCFG5		0x1045
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
+#define TELIT_PRODUCT_LE910_USBCFG4		0x1206
 
 /* ZTE PRODUCTS */
 #define ZTE_VENDOR_ID				0x19d2
 #define ZTE_PRODUCT_MF622			0x0001
 #define ZTE_PRODUCT_MF628			0x0015
 #define ZTE_PRODUCT_MF626			0x0031
+#define ZTE_PRODUCT_ZM8620_X			0x0396
+#define ZTE_PRODUCT_ME3620_MBIM			0x0426
+#define ZTE_PRODUCT_ME3620_X			0x1432
+#define ZTE_PRODUCT_ME3620_L			0x1433
 #define ZTE_PRODUCT_AC2726			0xfff1
 #define ZTE_PRODUCT_CDMA_TECH			0xfffe
 #define ZTE_PRODUCT_AC8710T			0xffff
@@ -308,6 +317,7 @@ static void option_instat_callback(struct urb *urb);
 #define TOSHIBA_PRODUCT_G450			0x0d45
 
 #define ALINK_VENDOR_ID				0x1e0e
+#define SIMCOM_PRODUCT_SIM7100E			0x9001 /* Yes, ALINK_VENDOR_ID */
 #define ALINK_PRODUCT_PH300			0x9100
 #define ALINK_PRODUCT_3GU			0x9200
 
@@ -353,6 +363,7 @@ static void option_instat_callback(struct urb *urb);
 /* This is the 4G XS Stick W14 a.k.a. Mobilcom Debitel Surf-Stick *
  * It seems to contain a Qualcomm QSC6240/6290 chipset            */
 #define FOUR_G_SYSTEMS_PRODUCT_W14		0x9603
+#define FOUR_G_SYSTEMS_PRODUCT_W100		0x9b01
 
 /* iBall 3.5G connect wireless modem */
 #define IBALL_3_5G_CONNECT			0x9605
@@ -368,18 +379,22 @@ static void option_instat_callback(struct urb *urb);
 #define HAIER_PRODUCT_CE81B			0x10f8
 #define HAIER_PRODUCT_CE100			0x2009
 
-/* Cinterion (formerly Siemens) products */
-#define SIEMENS_VENDOR_ID				0x0681
-#define CINTERION_VENDOR_ID				0x1e2d
+/* Gemalto's Cinterion products (formerly Siemens) */
+#define SIEMENS_VENDOR_ID			0x0681
+#define CINTERION_VENDOR_ID			0x1e2d
+#define CINTERION_PRODUCT_HC25_MDMNET		0x0040
 #define CINTERION_PRODUCT_HC25_MDM		0x0047
-#define CINTERION_PRODUCT_HC25_MDMNET	0x0040
+#define CINTERION_PRODUCT_HC28_MDMNET		0x004A /* same for HC28J */
 #define CINTERION_PRODUCT_HC28_MDM		0x004C
-#define CINTERION_PRODUCT_HC28_MDMNET	0x004A /* same for HC28J */
 #define CINTERION_PRODUCT_EU3_E			0x0051
 #define CINTERION_PRODUCT_EU3_P			0x0052
 #define CINTERION_PRODUCT_PH8			0x0053
 #define CINTERION_PRODUCT_AHXX			0x0055
 #define CINTERION_PRODUCT_PLXX			0x0060
+#define CINTERION_PRODUCT_PH8_2RMNET		0x0082
+#define CINTERION_PRODUCT_PH8_AUDIO		0x0083
+#define CINTERION_PRODUCT_AHXX_2RMNET		0x0084
+#define CINTERION_PRODUCT_AHXX_AUDIO		0x0085
 
 /* Olivetti products */
 #define OLIVETTI_VENDOR_ID			0x0b3c
@@ -526,6 +541,11 @@ static const struct option_blacklist_info four_g_w14_blacklist = {
 	.sendsetup = BIT(0) | BIT(1),
 };
 
+static const struct option_blacklist_info four_g_w100_blacklist = {
+	.sendsetup = BIT(1) | BIT(2),
+	.reserved = BIT(3),
+};
+
 static const struct option_blacklist_info alcatel_x200_blacklist = {
 	.sendsetup = BIT(0) | BIT(1),
 	.reserved = BIT(4),
@@ -552,6 +572,18 @@ static const struct option_blacklist_info zte_mc2716_z_blacklist = {
 	.sendsetup = BIT(1) | BIT(2) | BIT(3),
 };
 
+static const struct option_blacklist_info zte_me3620_mbim_blacklist = {
+	.reserved = BIT(2) | BIT(3) | BIT(4),
+};
+
+static const struct option_blacklist_info zte_me3620_xl_blacklist = {
+	.reserved = BIT(3) | BIT(4) | BIT(5),
+};
+
+static const struct option_blacklist_info zte_zm8620_x_blacklist = {
+	.reserved = BIT(3) | BIT(4) | BIT(5),
+};
+
 static const struct option_blacklist_info huawei_cdc12_blacklist = {
 	.reserved = BIT(1) | BIT(2),
 };
@@ -593,6 +625,10 @@ static const struct option_blacklist_info zte_1255_blacklist = {
 	.reserved = BIT(3) | BIT(4),
 };
 
+static const struct option_blacklist_info simcom_sim7100e_blacklist = {
+	.reserved = BIT(5) | BIT(6),
+};
+
 static const struct option_blacklist_info telit_le910_blacklist = {
 	.sendsetup = BIT(0),
 	.reserved = BIT(1) | BIT(2),
@@ -603,9 +639,18 @@ static const struct option_blacklist_info telit_le920_blacklist = {
 	.reserved = BIT(1) | BIT(5),
 };
 
-/*Add for LONGSUNG U8300*/
-static const struct option_blacklist_info longsung_u8300_blacklist = {
-	.reserved = BIT(4),
+static const struct option_blacklist_info telit_le922_blacklist_usbcfg0 = {
+	.sendsetup = BIT(2),
+	.reserved = BIT(0) | BIT(1) | BIT(3),
+};
+
+static const struct option_blacklist_info telit_le922_blacklist_usbcfg3 = {
+	.sendsetup = BIT(0),
+	.reserved = BIT(1) | BIT(2) | BIT(3),
+};
+
+static const struct option_blacklist_info cinterion_rmnet2_blacklist = {
+	.reserved = BIT(4) | BIT(5),
 };
 
 static const struct usb_device_id option_ids[] = {
@@ -1052,6 +1097,7 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_MC551, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_E362, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_E371, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_U620L, 0xff, 0x00, 0x00) },
 
 	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H01) },
 	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H01A) },
@@ -1102,9 +1148,13 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_PRODUCT_KPC650) },
 	{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_PRODUCT_KPC680) },
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x6000)}, /* ZTE AC8700 */
+	{ USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x6001, 0xff, 0xff, 0xff), /* 4G LTE usb-modem U901 */
+	  .driver_info = (kernel_ulong_t)&net_intf3_blacklist },
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x6613)}, /* Onda H600/ZTE MF330 */
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x0023)}, /* ONYX 3G device */
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9000)}, /* SIMCom SIM5218 */
+	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9003), /* Quectel UC20 */
+	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6001) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_CMU_300) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6003),
@@ -1152,8 +1202,16 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_CC864_SINGLE) },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_DE910_DUAL) },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_UE910_V2) },
+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG0),
+		.driver_info = (kernel_ulong_t)&telit_le922_blacklist_usbcfg0 },
+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG3),
+		.driver_info = (kernel_ulong_t)&telit_le922_blacklist_usbcfg3 },
+	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG5, 0xff),
+		.driver_info = (kernel_ulong_t)&telit_le922_blacklist_usbcfg0 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
 		.driver_info = (kernel_ulong_t)&telit_le910_blacklist },
+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910_USBCFG4),
+		.driver_info = (kernel_ulong_t)&telit_le922_blacklist_usbcfg3 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
 		.driver_info = (kernel_ulong_t)&telit_le920_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF622, 0xff, 0xff, 0xff) }, /* ZTE WCDMA products */
@@ -1587,6 +1645,14 @@ static const struct usb_device_id option_ids[] = {
 	 .driver_info = (kernel_ulong_t)&zte_ad3812_z_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MC2716, 0xff, 0xff, 0xff),
 	 .driver_info = (kernel_ulong_t)&zte_mc2716_z_blacklist },
+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_ME3620_L),
+	 .driver_info = (kernel_ulong_t)&zte_me3620_xl_blacklist },
+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_ME3620_MBIM),
+	 .driver_info = (kernel_ulong_t)&zte_me3620_mbim_blacklist },
+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_ME3620_X),
+	 .driver_info = (kernel_ulong_t)&zte_me3620_xl_blacklist },
+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_ZM8620_X),
+	 .driver_info = (kernel_ulong_t)&zte_zm8620_x_blacklist },
 	{ USB_VENDOR_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff, 0x02, 0x01) },
 	{ USB_VENDOR_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff, 0x02, 0x05) },
 	{ USB_VENDOR_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff, 0x86, 0x10) },
@@ -1605,6 +1671,8 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(ALINK_VENDOR_ID, 0x9000) },
 	{ USB_DEVICE(ALINK_VENDOR_ID, ALINK_PRODUCT_PH300) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ALINK_VENDOR_ID, ALINK_PRODUCT_3GU, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE(ALINK_VENDOR_ID, SIMCOM_PRODUCT_SIM7100E),
+	  .driver_info = (kernel_ulong_t)&simcom_sim7100e_blacklist },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_X060S_X200),
 	  .driver_info = (kernel_ulong_t)&alcatel_x200_blacklist
 	},
@@ -1625,9 +1693,8 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W14),
   	  .driver_info = (kernel_ulong_t)&four_g_w14_blacklist
   	},
-	/*LONGSUNG LTE U8300*/
-	{ USB_DEVICE(LONGCHEER_VENDOR_ID, LONGSUNG_U8300_PRODUCT_ID),
-	  .driver_info = (kernel_ulong_t)&longsung_u8300_blacklist
+	{ USB_DEVICE(LONGCHEER_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W100),
+	  .driver_info = (kernel_ulong_t)&four_g_w100_blacklist
 	},
 	{ USB_DEVICE_INTERFACE_CLASS(LONGCHEER_VENDOR_ID, SPEEDUP_PRODUCT_SU9800, 0xff) },
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, ZOOM_PRODUCT_4597) },
@@ -1656,9 +1723,15 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_EU3_P) },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8),
 		.driver_info = (kernel_ulong_t)&net_intf4_blacklist },
-	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX) },
+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX, 0xff) },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PLXX),
 		.driver_info = (kernel_ulong_t)&net_intf4_blacklist },
+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8_2RMNET, 0xff),
+		.driver_info = (kernel_ulong_t)&cinterion_rmnet2_blacklist },
+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8_AUDIO, 0xff),
+		.driver_info = (kernel_ulong_t)&net_intf4_blacklist },
+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX_2RMNET, 0xff) },
+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX_AUDIO, 0xff) },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDMNET) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDM) },
@@ -1765,8 +1838,11 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d02, 0xff, 0x00, 0x00) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x02, 0x01) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x00, 0x00) },
+	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7e19, 0xff),			/* D-Link DWM-221 B1 */
+	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
+	{ USB_DEVICE_INTERFACE_CLASS(0x2020, 0x4000, 0xff) },                /* OLICARD300 - MT6225 */
 	{ USB_DEVICE(INOVIA_VENDOR_ID, INOVIA_SEW858) },
 	{ USB_DEVICE(VIATELECOM_VENDOR_ID, VIATELECOM_PRODUCT_CDS7) },
 	{ } /* Terminating entry */
diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index de3e15d..33313ca 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -63,7 +63,6 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },
 	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75) },
diff --git a/drivers/usb/serial/pl2303.h b/drivers/usb/serial/pl2303.h
index 71fd9da..e3b7af8 100644
--- a/drivers/usb/serial/pl2303.h
+++ b/drivers/usb/serial/pl2303.h
@@ -62,10 +62,6 @@
 #define ALCATEL_VENDOR_ID	0x11f7
 #define ALCATEL_PRODUCT_ID	0x02df
 
-/* Samsung I330 phone cradle */
-#define SAMSUNG_VENDOR_ID	0x04e8
-#define SAMSUNG_PRODUCT_ID	0x8001
-
 #define SIEMENS_VENDOR_ID	0x11f5
 #define SIEMENS_PRODUCT_ID_SX1	0x0001
 #define SIEMENS_PRODUCT_ID_X65	0x0003
diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c
index 02b0803..13824b5 100644
--- a/drivers/usb/serial/quatech2.c
+++ b/drivers/usb/serial/quatech2.c
@@ -141,6 +141,7 @@ static void qt2_release(struct usb_serial *serial)
 
 	serial_priv = usb_get_serial_data(serial);
 
+	usb_kill_urb(serial_priv->read_urb);
 	usb_free_urb(serial_priv->read_urb);
 	kfree(serial_priv);
 }
diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c
index 5aaa2b6..af9f82a 100644
--- a/drivers/usb/serial/sierra.c
+++ b/drivers/usb/serial/sierra.c
@@ -289,6 +289,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x68AA, 0xFF, 0xFF, 0xFF),
 	  .driver_info = (kernel_ulong_t)&direct_ip_interface_blacklist
 	},
+	{ USB_DEVICE(0x1199, 0x68AB) }, /* Sierra Wireless AR8550 */
 	/* AT&T Direct IP LTE modems */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x0F3D, 0x68AA, 0xFF, 0xFF, 0xFF),
 	  .driver_info = (kernel_ulong_t)&direct_ip_interface_blacklist
diff --git a/drivers/usb/serial/symbolserial.c b/drivers/usb/serial/symbolserial.c
index 9b16489..1e2d86d 100644
--- a/drivers/usb/serial/symbolserial.c
+++ b/drivers/usb/serial/symbolserial.c
@@ -97,7 +97,7 @@ exit:
 
 static int symbol_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
-	struct symbol_private *priv = usb_get_serial_data(port->serial);
+	struct symbol_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	int result = 0;
 
@@ -123,7 +123,7 @@ static void symbol_close(struct usb_serial_port *port)
 static void symbol_throttle(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty->driver_data;
-	struct symbol_private *priv = usb_get_serial_data(port->serial);
+	struct symbol_private *priv = usb_get_serial_port_data(port);
 
 	spin_lock_irq(&priv->lock);
 	priv->throttled = true;
@@ -133,7 +133,7 @@ static void symbol_throttle(struct tty_struct *tty)
 static void symbol_unthrottle(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty->driver_data;
-	struct symbol_private *priv = usb_get_serial_data(port->serial);
+	struct symbol_private *priv = usb_get_serial_port_data(port);
 	int result;
 	bool was_throttled;
 
diff --git a/drivers/usb/serial/ti_usb_3410_5052.c b/drivers/usb/serial/ti_usb_3410_5052.c
index 4cc84c0..0a7c68f 100644
--- a/drivers/usb/serial/ti_usb_3410_5052.c
+++ b/drivers/usb/serial/ti_usb_3410_5052.c
@@ -158,7 +158,7 @@ static unsigned int product_5052_count;
 /* the array dimension is the number of default entries plus */
 /* TI_EXTRA_VID_PID_COUNT user defined entries plus 1 terminating */
 /* null entry */
-static struct usb_device_id ti_id_table_3410[15+TI_EXTRA_VID_PID_COUNT+1] = {
+static struct usb_device_id ti_id_table_3410[16+TI_EXTRA_VID_PID_COUNT+1] = {
 	{ USB_DEVICE(TI_VENDOR_ID, TI_3410_PRODUCT_ID) },
 	{ USB_DEVICE(TI_VENDOR_ID, TI_3410_EZ430_ID) },
 	{ USB_DEVICE(MTS_VENDOR_ID, MTS_GSM_NO_FW_PRODUCT_ID) },
@@ -184,7 +184,7 @@ static struct usb_device_id ti_id_table_5052[5+TI_EXTRA_VID_PID_COUNT+1] = {
 	{ USB_DEVICE(TI_VENDOR_ID, TI_5052_FIRMWARE_PRODUCT_ID) },
 };
 
-static struct usb_device_id ti_id_table_combined[19+2*TI_EXTRA_VID_PID_COUNT+1] = {
+static struct usb_device_id ti_id_table_combined[20+2*TI_EXTRA_VID_PID_COUNT+1] = {
 	{ USB_DEVICE(TI_VENDOR_ID, TI_3410_PRODUCT_ID) },
 	{ USB_DEVICE(TI_VENDOR_ID, TI_3410_EZ430_ID) },
 	{ USB_DEVICE(MTS_VENDOR_ID, MTS_GSM_NO_FW_PRODUCT_ID) },
diff --git a/drivers/usb/serial/visor.c b/drivers/usb/serial/visor.c
index 9910aa2..605068e 100644
--- a/drivers/usb/serial/visor.c
+++ b/drivers/usb/serial/visor.c
@@ -96,7 +96,7 @@ static struct usb_device_id id_table [] = {
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(ACER_VENDOR_ID, ACER_S10_ID),
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID),
+	{ USB_DEVICE_INTERFACE_CLASS(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID, 0xff),
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID),
 		.driver_info = (kernel_ulong_t)&palm_os_4_probe },
@@ -551,6 +551,11 @@ static int treo_attach(struct usb_serial *serial)
 		(serial->num_interrupt_in == 0))
 		return 0;
 
+	if (serial->num_bulk_in < 2 || serial->num_interrupt_in < 2) {
+		dev_err(&serial->interface->dev, "missing endpoints\n");
+		return -ENODEV;
+	}
+
 	/*
 	* It appears that Treos and Kyoceras want to use the
 	* 1st bulk in endpoint to communicate with the 2nd bulk out endpoint,
@@ -604,8 +609,10 @@ static int clie_5_attach(struct usb_serial *serial)
 	 */
 
 	/* some sanity check */
-	if (serial->num_ports < 2)
-		return -1;
+	if (serial->num_bulk_out < 2) {
+		dev_err(&serial->interface->dev, "missing bulk out endpoints\n");
+		return -ENODEV;
+	}
 
 	/* port 0 now uses the modified endpoint Address */
 	port = serial->port[0];
diff --git a/drivers/usb/serial/whiteheat.c b/drivers/usb/serial/whiteheat.c
index 5e3dd9f..ae79c22 100644
--- a/drivers/usb/serial/whiteheat.c
+++ b/drivers/usb/serial/whiteheat.c
@@ -81,6 +81,8 @@ static int  whiteheat_firmware_download(struct usb_serial *serial,
 static int  whiteheat_firmware_attach(struct usb_serial *serial);
 
 /* function prototypes for the Connect Tech WhiteHEAT serial converter */
+static int whiteheat_probe(struct usb_serial *serial,
+				const struct usb_device_id *id);
 static int  whiteheat_attach(struct usb_serial *serial);
 static void whiteheat_release(struct usb_serial *serial);
 static int  whiteheat_port_probe(struct usb_serial_port *port);
@@ -117,6 +119,7 @@ static struct usb_serial_driver whiteheat_device = {
 	.description =		"Connect Tech - WhiteHEAT",
 	.id_table =		id_table_std,
 	.num_ports =		4,
+	.probe =		whiteheat_probe,
 	.attach =		whiteheat_attach,
 	.release =		whiteheat_release,
 	.port_probe =		whiteheat_port_probe,
@@ -218,6 +221,34 @@ static int whiteheat_firmware_attach(struct usb_serial *serial)
 /*****************************************************************************
  * Connect Tech's White Heat serial driver functions
  *****************************************************************************/
+
+static int whiteheat_probe(struct usb_serial *serial,
+				const struct usb_device_id *id)
+{
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	size_t num_bulk_in = 0;
+	size_t num_bulk_out = 0;
+	size_t min_num_bulk;
+	unsigned int i;
+
+	iface_desc = serial->interface->cur_altsetting;
+
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
+		endpoint = &iface_desc->endpoint[i].desc;
+		if (usb_endpoint_is_bulk_in(endpoint))
+			++num_bulk_in;
+		if (usb_endpoint_is_bulk_out(endpoint))
+			++num_bulk_out;
+	}
+
+	min_num_bulk = COMMAND_PORT + 1;
+	if (num_bulk_in < min_num_bulk || num_bulk_out < min_num_bulk)
+		return -ENODEV;
+
+	return 0;
+}
+
 static int whiteheat_attach(struct usb_serial *serial)
 {
 	struct usb_serial_port *command_port;
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 7f62530..da380a9 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -760,6 +760,13 @@ UNUSUAL_DEV(  0x059f, 0x0643, 0x0000, 0x0000,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_GO_SLOW ),
 
+/* Reported by Christian Schaller <cschalle@redhat.com> */
+UNUSUAL_DEV(  0x059f, 0x0651, 0x0000, 0x0000,
+		"LaCie",
+		"External HDD",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_NO_WP_DETECT ),
+
 /* Submitted by Joel Bourquard <numlock@freesurf.ch>
  * Some versions of this device need the SubClass and Protocol overrides
  * while others don't.
@@ -2025,6 +2032,18 @@ UNUSUAL_DEV( 0x1908, 0x3335, 0x0200, 0x0200,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_NO_READ_DISC_INFO ),
 
+/* Reported by Oliver Neukum <oneukum@suse.com>
+ * This device morphes spontaneously into another device if the access
+ * pattern of Windows isn't followed. Thus writable media would be dirty
+ * if the initial instance is used. So the device is limited to its
+ * virtual CD.
+ * And yes, the concept that BCD goes up to 9 is not heeded */
+UNUSUAL_DEV( 0x19d2, 0x1225, 0x0000, 0xffff,
+		"ZTE,Incorporated",
+		"ZTE WCDMA Technologies MSM",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_SINGLE_LUN ),
+
 /* Reported by Sven Geggus <sven-usbst@geggus.net>
  * This encrypted pen drive returns bogus data for the initial READ(10).
  */
diff --git a/drivers/vhost/scsi.c b/drivers/vhost/scsi.c
index fb97bc0..2947eda 100644
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@ -1088,7 +1088,7 @@ static void tcm_vhost_send_evt(struct vhost_scsi *vs, struct tcm_vhost_tpg *tpg,
 		 * lun[4-7] need to be zero according to virtio-scsi spec.
 		 */
 		evt->event.lun[0] = 0x01;
-		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
+		evt->event.lun[1] = tpg->tport_tpgt;
 		if (lun->unpacked_lun >= 256)
 			evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
 		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
@@ -1894,12 +1894,12 @@ static struct se_portal_group *tcm_vhost_make_tpg(struct se_wwn *wwn,
 			struct tcm_vhost_tport, tport_wwn);
 
 	struct tcm_vhost_tpg *tpg;
-	unsigned long tpgt;
+	u16 tpgt;
 	int ret;
 
 	if (strstr(name, "tpgt_") != name)
 		return ERR_PTR(-EINVAL);
-	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
+	if (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)
 		return ERR_PTR(-EINVAL);
 
 	tpg = kzalloc(sizeof(struct tcm_vhost_tpg), GFP_KERNEL);
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 60aa5ad..3aabc65 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -855,6 +855,7 @@ long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)
 		}
 		if (eventfp != d->log_file) {
 			filep = d->log_file;
+			d->log_file = eventfp;
 			ctx = d->log_ctx;
 			d->log_ctx = eventfp ?
 				eventfd_ctx_fileget(eventfp) : NULL;
diff --git a/drivers/video/ambarella/ambarella_fb.c b/drivers/video/ambarella/ambarella_fb.c
index 600fba0..3f35e94 100644
--- a/drivers/video/ambarella/ambarella_fb.c
+++ b/drivers/video/ambarella/ambarella_fb.c
@@ -62,663 +62,634 @@
 #ifdef CONFIG_PROC_FS
 static int ambarella_fb_proc_show(struct seq_file *m, void *v)
 {
-	int len;
-	struct ambarella_platform_fb *ambfb_data;
-	struct fb_info *info;
-
-	ambfb_data = (struct ambarella_platform_fb *)m->private;
-	info = ambfb_data->proc_fb_info;
-
-	wait_event_interruptible(ambfb_data->proc_wait,
-		(ambfb_data->proc_wait_flag > 0));
-	ambfb_data->proc_wait_flag = 0;
-	dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__,
-		ambfb_data->proc_wait_flag);
-	len = seq_printf(m, "%04d %04d %04d %04d %04d %04d\n",
-		info->var.xres, info->var.yres,
-		info->fix.line_length,
-		info->var.xoffset, info->var.yoffset,
-		ambfb_data->color_format);
-
-	return len;
+        int len;
+        struct ambarella_platform_fb *ambfb_data;
+        struct fb_info *info;
+
+        ambfb_data = (struct ambarella_platform_fb *)m->private;
+        info = ambfb_data->proc_fb_info;
+
+        wait_event_interruptible(ambfb_data->proc_wait,
+                                 (ambfb_data->proc_wait_flag > 0));
+        ambfb_data->proc_wait_flag = 0;
+        dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__,
+                ambfb_data->proc_wait_flag);
+        len = seq_printf(m, "%04d %04d %04d %04d %04d %04d\n",
+                         info->var.xres, info->var.yres,
+                         info->fix.line_length,
+                         info->var.xoffset, info->var.yoffset,
+                         ambfb_data->color_format);
+
+        return len;
 }
 
 static int ambarella_fb_proc_open(struct inode *inode, struct file *file)
 {
-	return single_open(file, ambarella_fb_proc_show, PDE_DATA(inode));
+        return single_open(file, ambarella_fb_proc_show, PDE_DATA(inode));
 }
 
 static const struct file_operations ambarella_fb_fops = {
-	.open = ambarella_fb_proc_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
+        .open = ambarella_fb_proc_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
 };
 #endif
 
 /* ========================================================================== */
 static int ambfb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
 {
-	int					errorCode = 0;
-	struct ambarella_platform_fb		*ambfb_data;
-	int					pos;
-	u16					*r, *g, *b, *t;
-	u8					*pclut_table, *pblend_table;
-
-	if (cmap == &info->cmap) {
-		errorCode = 0;
-		goto ambfb_setcmap_exit;
-	}
-
-	if (cmap->start != 0 || cmap->len != 256) {
-		dev_dbg(info->device,
-			"%s: Incorrect parameters: start = %d, len = %d\n",
-			__func__, cmap->start, cmap->len);
-		errorCode = -1;
-		goto ambfb_setcmap_exit;
-	}
-
-	if (!cmap->red || !cmap->green || !cmap->blue) {
-		dev_dbg(info->device, "%s: Incorrect rgb pointers!\n",
-			__func__);
-		errorCode = -1;
-		goto ambfb_setcmap_exit;
-	}
-
-	ambfb_data = (struct ambarella_platform_fb *)info->par;
-
-	mutex_lock(&ambfb_data->lock);
-
-	r = cmap->red;
-	g = cmap->green;
-	b = cmap->blue;
-	t = cmap->transp;
-	pclut_table = ambfb_data->clut_table;
-	pblend_table = ambfb_data->blend_table;
-	for (pos = 0; pos < 256; pos++) {
-		*pclut_table++ = *r++;
-		*pclut_table++ = *g++;
-		*pclut_table++ = *b++;
-		if (t) *pblend_table++ = *t++;
-	}
-
-	if (ambfb_data->setcmap) {
-		mutex_unlock(&ambfb_data->lock);
-		errorCode = ambfb_data->setcmap(cmap, info);
-	} else {
-		mutex_unlock(&ambfb_data->lock);
-	}
+        int					errorCode = 0;
+        struct ambarella_platform_fb		*ambfb_data;
+        int					pos;
+        u16					*r, *g, *b, *t;
+        u8					*pclut_table, *pblend_table;
+
+        if (cmap == &info->cmap) {
+                errorCode = 0;
+                goto ambfb_setcmap_exit;
+        }
+
+        if (cmap->start != 0 || cmap->len != 256) {
+                dev_dbg(info->device,
+                        "%s: Incorrect parameters: start = %d, len = %d\n",
+                        __func__, cmap->start, cmap->len);
+                errorCode = -1;
+                goto ambfb_setcmap_exit;
+        }
+
+        if (!cmap->red || !cmap->green || !cmap->blue) {
+                dev_dbg(info->device, "%s: Incorrect rgb pointers!\n",
+                        __func__);
+                errorCode = -1;
+                goto ambfb_setcmap_exit;
+        }
+
+        ambfb_data = (struct ambarella_platform_fb *)info->par;
+
+        mutex_lock(&ambfb_data->lock);
+
+        r = cmap->red;
+        g = cmap->green;
+        b = cmap->blue;
+        t = cmap->transp;
+        pclut_table = ambfb_data->clut_table;
+        pblend_table = ambfb_data->blend_table;
+        for (pos = 0; pos < 256; pos++) {
+                *pclut_table++ = *r++;
+                *pclut_table++ = *g++;
+                *pclut_table++ = *b++;
+                if (t) *pblend_table++ = *t++;
+        }
+
+        if (ambfb_data->setcmap) {
+                mutex_unlock(&ambfb_data->lock);
+                errorCode = ambfb_data->setcmap(cmap, info);
+        } else {
+                mutex_unlock(&ambfb_data->lock);
+        }
 
 ambfb_setcmap_exit:
-	dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__, errorCode);
-	return errorCode;
+        dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__, errorCode);
+        return errorCode;
 }
 
 static int ambfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 {
-	int					errorCode = 0;
-	struct ambarella_platform_fb		*ambfb_data;
-	u32					framesize = 0;
-
-	ambfb_data = (struct ambarella_platform_fb *)info->par;
-
-	mutex_lock(&ambfb_data->lock);
-	if (ambfb_data->check_var) {
-		errorCode = ambfb_data->check_var(var, info);
-	}
-	mutex_unlock(&ambfb_data->lock);
-
-	if (var->xres_virtual * var->bits_per_pixel / 8 > info->fix.line_length) {
-		errorCode = -ENOMEM;
-		dev_err(info->device, "%s: xres_virtual[%d] too big [%d]!\n",
-			__func__, var->xres_virtual * var->bits_per_pixel / 8,
-			info->fix.line_length);
-	}
-
-	framesize = info->fix.line_length * var->yres_virtual;
-	if (framesize > info->fix.smem_len) {
-		errorCode = -ENOMEM;
-		dev_err(info->device, "%s: framesize[%d] too big [%d]!\n",
-			__func__, framesize, info->fix.smem_len);
-	}
-
-	dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__, errorCode);
-
-	return errorCode;
+        int					errorCode = 0;
+        struct ambarella_platform_fb		*ambfb_data;
+        u32					framesize = 0;
+
+        ambfb_data = (struct ambarella_platform_fb *)info->par;
+
+        mutex_lock(&ambfb_data->lock);
+        if (ambfb_data->check_var) {
+                errorCode = ambfb_data->check_var(var, info);
+        }
+        mutex_unlock(&ambfb_data->lock);
+
+        if (var->xres_virtual * var->bits_per_pixel / 8 > info->fix.line_length) {
+                errorCode = -ENOMEM;
+                dev_err(info->device, "%s: xres_virtual[%d] too big [%d]!\n",
+                        __func__, var->xres_virtual * var->bits_per_pixel / 8,
+                        info->fix.line_length);
+        }
+
+        framesize = info->fix.line_length * var->yres_virtual;
+        if (framesize > info->fix.smem_len) {
+                errorCode = -ENOMEM;
+                dev_err(info->device, "%s: framesize[%d] too big [%d]!\n",
+                        __func__, framesize, info->fix.smem_len);
+        }
+
+        dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__, errorCode);
+
+        return errorCode;
 }
 
 static int ambfb_set_par(struct fb_info *info)
 {
-	int					errorCode = 0, i;
-	struct ambarella_platform_fb		*ambfb_data;
-	struct fb_var_screeninfo		*pvar;
-	static struct fb_var_screeninfo		*cur_var;
-	int					res_changed = 0;
-	int					color_format_changed = 0;
-	enum ambarella_fb_color_format		new_color_format;
-	const struct ambarella_fb_color_table	*pTable;
-
-	ambfb_data = (struct ambarella_platform_fb *)info->par;
-	mutex_lock(&ambfb_data->lock);
-	cur_var = &ambfb_data->screen_var;
-	pvar = &info->var;
-
-	if (!ambfb_data->set_par)
-		goto ambfb_set_par_quick_exit;
-
-	/* Resolution changed */
-	if (pvar->xres != cur_var->xres || pvar->yres != cur_var->yres) {
-		res_changed = 1;
-	}
-
-	/* Color format changed */
-	if (pvar->bits_per_pixel != cur_var->bits_per_pixel ||
-		pvar->red.offset != cur_var->red.offset ||
-		pvar->red.length != cur_var->red.length ||
-		pvar->red.msb_right != cur_var->red.msb_right ||
-		pvar->green.offset != cur_var->green.offset ||
-		pvar->green.length != cur_var->green.length ||
-		pvar->green.msb_right != cur_var->green.msb_right ||
-		pvar->blue.offset != cur_var->blue.offset ||
-		pvar->blue.length != cur_var->blue.length ||
-		pvar->blue.msb_right != cur_var->blue.msb_right ||
-		pvar->transp.offset != cur_var->transp.offset ||
-		pvar->transp.length != cur_var->transp.length ||
-		pvar->transp.msb_right != cur_var->transp.msb_right) {
-
-		color_format_changed = 1;
-	}
-
-	if (!res_changed && !color_format_changed)
-		goto ambfb_set_par_quick_exit;
-
-	/* Find color format */
-	new_color_format = ambfb_data->color_format;
-	pTable = ambarella_fb_color_format_table;
-	for (i = 0; i < ARRAY_SIZE(ambarella_fb_color_format_table); i++) {
-		if (pTable->bits_per_pixel == pvar->bits_per_pixel &&
-			pTable->red.offset == pvar->red.offset &&
-			pTable->red.length == pvar->red.length &&
-			pTable->red.msb_right == pvar->red.msb_right &&
-			pTable->green.offset == pvar->green.offset &&
-			pTable->green.length == pvar->green.length &&
-			pTable->green.msb_right == pvar->green.msb_right &&
-			pTable->blue.offset == pvar->blue.offset &&
-			pTable->blue.length == pvar->blue.length &&
-			pTable->blue.msb_right == pvar->blue.msb_right &&
-			pTable->transp.offset == pvar->transp.offset &&
-			pTable->transp.length == pvar->transp.length &&
-			pTable->transp.msb_right == pvar->transp.msb_right) {
-
-			new_color_format = pTable->color_format;
-			break;
-		}
-		pTable++;
-	}
-
-	ambfb_data->color_format = new_color_format;
-	memcpy(cur_var, pvar, sizeof(*pvar));
-	mutex_unlock(&ambfb_data->lock);
-
-	errorCode = ambfb_data->set_par(info);
-	goto ambfb_set_par_normal_exit;
+        int					errorCode = 0, i;
+        struct ambarella_platform_fb		*ambfb_data;
+        struct fb_var_screeninfo		*pvar;
+        static struct fb_var_screeninfo		*cur_var;
+        int					res_changed = 0;
+        int					color_format_changed = 0;
+        enum ambarella_fb_color_format		new_color_format;
+        const struct ambarella_fb_color_table	*pTable;
+
+        ambfb_data = (struct ambarella_platform_fb *)info->par;
+        mutex_lock(&ambfb_data->lock);
+        cur_var = &ambfb_data->screen_var;
+        pvar = &info->var;
+
+        if (!ambfb_data->set_par)
+                goto ambfb_set_par_quick_exit;
+
+        /* Resolution changed */
+        if (pvar->xres != cur_var->xres || pvar->yres != cur_var->yres) {
+                res_changed = 1;
+        }
+
+        /* Color format changed */
+        if (pvar->bits_per_pixel != cur_var->bits_per_pixel ||
+            pvar->red.offset != cur_var->red.offset ||
+            pvar->red.length != cur_var->red.length ||
+            pvar->red.msb_right != cur_var->red.msb_right ||
+            pvar->green.offset != cur_var->green.offset ||
+            pvar->green.length != cur_var->green.length ||
+            pvar->green.msb_right != cur_var->green.msb_right ||
+            pvar->blue.offset != cur_var->blue.offset ||
+            pvar->blue.length != cur_var->blue.length ||
+            pvar->blue.msb_right != cur_var->blue.msb_right ||
+            pvar->transp.offset != cur_var->transp.offset ||
+            pvar->transp.length != cur_var->transp.length ||
+            pvar->transp.msb_right != cur_var->transp.msb_right) {
+
+                color_format_changed = 1;
+        }
+
+        if (!res_changed && !color_format_changed)
+                goto ambfb_set_par_quick_exit;
+
+        /* Find color format */
+        new_color_format = ambfb_data->color_format;
+        pTable = ambarella_fb_color_format_table;
+        for (i = 0; i < ARRAY_SIZE(ambarella_fb_color_format_table); i++) {
+                if (pTable->bits_per_pixel == pvar->bits_per_pixel &&
+                    pTable->red.offset == pvar->red.offset &&
+                    pTable->red.length == pvar->red.length &&
+                    pTable->red.msb_right == pvar->red.msb_right &&
+                    pTable->green.offset == pvar->green.offset &&
+                    pTable->green.length == pvar->green.length &&
+                    pTable->green.msb_right == pvar->green.msb_right &&
+                    pTable->blue.offset == pvar->blue.offset &&
+                    pTable->blue.length == pvar->blue.length &&
+                    pTable->blue.msb_right == pvar->blue.msb_right &&
+                    pTable->transp.offset == pvar->transp.offset &&
+                    pTable->transp.length == pvar->transp.length &&
+                    pTable->transp.msb_right == pvar->transp.msb_right) {
+
+                        new_color_format = pTable->color_format;
+                        break;
+                }
+                pTable++;
+        }
+
+        ambfb_data->color_format = new_color_format;
+        memcpy(cur_var, pvar, sizeof(*pvar));
+        mutex_unlock(&ambfb_data->lock);
+
+        errorCode = ambfb_data->set_par(info);
+        goto ambfb_set_par_normal_exit;
 
 ambfb_set_par_quick_exit:
-	memcpy(cur_var, pvar, sizeof(*pvar));
-	mutex_unlock(&ambfb_data->lock);
+        memcpy(cur_var, pvar, sizeof(*pvar));
+        mutex_unlock(&ambfb_data->lock);
 
 ambfb_set_par_normal_exit:
-	dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__, errorCode);
+        dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__, errorCode);
 
-	return errorCode;
+        return errorCode;
 }
 
 static int ambfb_pan_display(struct fb_var_screeninfo *var,
-	struct fb_info *info)
+                             struct fb_info *info)
 {
-	int					errorCode = 0;
-	struct ambarella_platform_fb		*ambfb_data;
+        int					errorCode = 0;
+        struct ambarella_platform_fb		*ambfb_data;
 
-	ambfb_data = (struct ambarella_platform_fb *)info->par;
+        ambfb_data = (struct ambarella_platform_fb *)info->par;
 
-	ambfb_data->proc_wait_flag++;
-	wake_up(&(ambfb_data->proc_wait));
-	mutex_lock(&ambfb_data->lock);
-	ambfb_data->screen_var.xoffset = var->xoffset;
-	ambfb_data->screen_var.yoffset = var->yoffset;
-	if (ambfb_data->pan_display) {
-		errorCode = ambfb_data->pan_display(var, info);
-	}
-	mutex_unlock(&ambfb_data->lock);
+        ambfb_data->proc_wait_flag++;
+        wake_up(&(ambfb_data->proc_wait));
+        mutex_lock(&ambfb_data->lock);
+        ambfb_data->screen_var.xoffset = var->xoffset;
+        ambfb_data->screen_var.yoffset = var->yoffset;
+        if (ambfb_data->pan_display) {
+                errorCode = ambfb_data->pan_display(var, info);
+        }
+        mutex_unlock(&ambfb_data->lock);
 
-	dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__, errorCode);
+        dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__, errorCode);
 
-	return 0;
+        return 0;
 }
 
 static int ambfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
 {
-	unsigned long size = vma->vm_end - vma->vm_start;
-	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
-       struct ambarella_platform_fb *ambfb_data = NULL;
+        unsigned long size = vma->vm_end - vma->vm_start;
+        unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+        struct ambarella_platform_fb *ambfb_data = NULL;
 
-       ambfb_data = ambfb_data_ptr[info->dev->id];
+        ambfb_data = ambfb_data_ptr[info->dev->id];
 
-	if (offset + size > info->fix.smem_len)
-		return -EINVAL;
+        if (offset + size > info->fix.smem_len)
+                return -EINVAL;
 
-	offset += info->fix.smem_start;
+        offset += info->fix.smem_start;
 
-       if(ambfb_data->conversion_buf.available)
+        if(ambfb_data->conversion_buf.available)
                 vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
-	if (remap_pfn_range(vma, vma->vm_start, offset >> PAGE_SHIFT,
-			    size, vma->vm_page_prot))
-		return -EAGAIN;
+        if (remap_pfn_range(vma, vma->vm_start, offset >> PAGE_SHIFT,
+                            size, vma->vm_page_prot))
+                return -EAGAIN;
 
-	dev_dbg(info->device, "%s: P(0x%08lx)->V(0x%08lx), size = 0x%08lx.\n",
-		__func__, offset, vma->vm_start, size);
+        dev_dbg(info->device, "%s: P(0x%08lx)->V(0x%08lx), size = 0x%08lx.\n",
+                __func__, offset, vma->vm_start, size);
 
-	return 0;
+        return 0;
 }
 
 static int ambfb_blank(int blank_mode, struct fb_info *info)
 {
-	int					errorCode = 0;
-	struct ambarella_platform_fb		*ambfb_data;
+        int					errorCode = 0;
+        struct ambarella_platform_fb		*ambfb_data;
 
-	ambfb_data = (struct ambarella_platform_fb *)info->par;
+        ambfb_data = (struct ambarella_platform_fb *)info->par;
 
-	mutex_lock(&ambfb_data->lock);
-	if (ambfb_data->set_blank) {
-		errorCode = ambfb_data->set_blank(blank_mode, info);
-	}
-	mutex_unlock(&ambfb_data->lock);
+        mutex_lock(&ambfb_data->lock);
+        if (ambfb_data->set_blank) {
+                errorCode = ambfb_data->set_blank(blank_mode, info);
+        }
+        mutex_unlock(&ambfb_data->lock);
 
-	dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__, errorCode);
+        dev_dbg(info->device, "%s:%d %d.\n", __func__, __LINE__, errorCode);
 
-	return errorCode;
+        return errorCode;
 }
 
 static struct fb_ops ambfb_ops = {
-	.owner          = THIS_MODULE,
-	.fb_check_var	= ambfb_check_var,
-	.fb_set_par	= ambfb_set_par,
-	.fb_pan_display	= ambfb_pan_display,
-	.fb_fillrect	= sys_fillrect,
-	.fb_copyarea	= sys_copyarea,
-	.fb_imageblit	= sys_imageblit,
-	.fb_mmap	= ambfb_mmap,
-	.fb_setcmap	= ambfb_setcmap,
-	.fb_blank	= ambfb_blank,
+        .owner          = THIS_MODULE,
+        .fb_check_var	= ambfb_check_var,
+        .fb_set_par	= ambfb_set_par,
+        .fb_pan_display	= ambfb_pan_display,
+        .fb_fillrect	= sys_fillrect,
+        .fb_copyarea	= sys_copyarea,
+        .fb_imageblit	= sys_imageblit,
+        .fb_mmap	= ambfb_mmap,
+        .fb_setcmap	= ambfb_setcmap,
+        .fb_blank	= ambfb_blank,
 };
 
 static int ambfb_setup(struct device *dev, char *options,
-	struct ambarella_platform_fb *ambfb_data)
+                       struct ambarella_platform_fb *ambfb_data)
 {
-	int					retval = -1;
-	int					ssret;
-	int					cl_xres;
-	int					cl_yres;
-	int					cl_xvirtual;
-	int					cl_yvirtual;
-	int					cl_format;
-	int					cl_cvs_buf;
-	unsigned int				cl_prealloc_start;
-	unsigned int				cl_prealloc_length;
-
-	if (!options || !*options) {
-		goto ambfb_setup_exit;
-	}
-
-	ssret = sscanf(options, "%dx%d,%dx%d,%d,%d,%x,%x", &cl_xres, &cl_yres,
-		&cl_xvirtual, &cl_yvirtual, &cl_format, &cl_cvs_buf,
-		&cl_prealloc_start, &cl_prealloc_length);
-	if (ssret == 6) {
-		ambfb_data->screen_var.xres = cl_xres;
-		ambfb_data->screen_var.yres = cl_yres;
-		ambfb_data->screen_var.xres_virtual = cl_xvirtual;
-		ambfb_data->screen_var.yres_virtual = cl_yvirtual;
-		ambfb_data->color_format = cl_format;
-		ambfb_data->conversion_buf.available = cl_cvs_buf;
-		dev_dbg(dev, "%dx%d,%dx%d,%d,%d\n", cl_xres, cl_yres,
-			cl_xvirtual, cl_yvirtual, cl_format, cl_cvs_buf);
-		retval = 0;
-	} else
-	if (ssret == 8) {
-		ambfb_data->screen_var.xres = cl_xres;
-		ambfb_data->screen_var.yres = cl_yres;
-		ambfb_data->screen_var.xres_virtual = cl_xvirtual;
-		ambfb_data->screen_var.yres_virtual = cl_yvirtual;
-		ambfb_data->color_format = cl_format;
-		ambfb_data->conversion_buf.available = cl_cvs_buf;
-
-		ambfb_data->screen_fix.smem_start = cl_prealloc_start;
-		ambfb_data->screen_fix.smem_len = cl_prealloc_length;
-		ambfb_data->use_prealloc = 1;
-		dev_dbg(dev, "%dx%d,%dx%d,%d,%d,%x,%x\n", cl_xres, cl_yres,
-			cl_xvirtual, cl_yvirtual, cl_format, cl_cvs_buf,
-			cl_prealloc_start, cl_prealloc_length);
-		retval = 0;
-	} else {
-		dev_err(dev, "Can not support %s@%d!\n", options, ssret);
-	}
+        int					retval = -1;
+        int					ssret;
+        int					cl_xres;
+        int					cl_yres;
+        int					cl_xvirtual;
+        int					cl_yvirtual;
+        int					cl_format;
+        int					cl_cvs_buf;
+        unsigned int				cl_prealloc_start;
+        unsigned int				cl_prealloc_length;
+
+        if (!options || !*options) {
+                goto ambfb_setup_exit;
+        }
+
+        ssret = sscanf(options, "%dx%d,%dx%d,%d,%d,%x,%x", &cl_xres, &cl_yres,
+                       &cl_xvirtual, &cl_yvirtual, &cl_format, &cl_cvs_buf,
+                       &cl_prealloc_start, &cl_prealloc_length);
+        if (ssret == 6) {
+                ambfb_data->screen_var.xres = cl_xres;
+                ambfb_data->screen_var.yres = cl_yres;
+                ambfb_data->screen_var.xres_virtual = cl_xvirtual;
+                ambfb_data->screen_var.yres_virtual = cl_yvirtual;
+                ambfb_data->color_format = cl_format;
+                ambfb_data->conversion_buf.available = cl_cvs_buf;
+                dev_dbg(dev, "%dx%d,%dx%d,%d,%d\n", cl_xres, cl_yres,
+                        cl_xvirtual, cl_yvirtual, cl_format, cl_cvs_buf);
+                retval = 0;
+        } else if (ssret == 8) {
+                ambfb_data->screen_var.xres = cl_xres;
+                ambfb_data->screen_var.yres = cl_yres;
+                ambfb_data->screen_var.xres_virtual = cl_xvirtual;
+                ambfb_data->screen_var.yres_virtual = cl_yvirtual;
+                ambfb_data->color_format = cl_format;
+                ambfb_data->conversion_buf.available = cl_cvs_buf;
+
+                ambfb_data->screen_fix.smem_start = cl_prealloc_start;
+                ambfb_data->screen_fix.smem_len = cl_prealloc_length;
+                ambfb_data->use_prealloc = 1;
+                dev_dbg(dev, "%dx%d,%dx%d,%d,%d,%x,%x\n", cl_xres, cl_yres,
+                        cl_xvirtual, cl_yvirtual, cl_format, cl_cvs_buf,
+                        cl_prealloc_start, cl_prealloc_length);
+                retval = 0;
+        } else {
+                dev_err(dev, "Can not support %s@%d!\n", options, ssret);
+        }
 
 ambfb_setup_exit:
-	return retval;
+        return retval;
 }
 
-//do not support amboot BAPI
 static int ambfb_probe(struct platform_device *pdev)
 {
-	int                                errorCode = 0;
-	struct fb_info                     *info;
-	char                               fb_name[64];
-	char                               *option;
-	struct ambarella_platform_fb       *ambfb_data = NULL;
-	u32                                i,framesize,line_length;
-
-	ambfb_data = ambfb_data_ptr[pdev->id];
-
-	snprintf(fb_name, sizeof(fb_name), "amb%dfb", pdev->id);
-	if (fb_get_options(fb_name, &option)) {
-              dev_err(&pdev->dev, "%s: get fb options fail!\n", __func__);
-		errorCode = -ENODEV;
-		goto ambfb_probe_exit;
-	}
-	if (ambfb_setup(&pdev->dev, option, ambfb_data)) {
-		errorCode = -ENODEV;
-		goto ambfb_probe_exit;
-	}
-
-	info = framebuffer_alloc(sizeof(ambfb_data), &pdev->dev);
-	if (info == NULL) {
-		dev_err(&pdev->dev, "%s: framebuffer_alloc fail!\n", __func__);
-		errorCode = -ENOMEM;
-		goto ambfb_probe_exit;
-	}
-
-       if(get_ambarella_fbmem_size()){
-              ambfb_data->use_prealloc =1;
-              ambfb_data->conversion_buf.available = 1;
-              ambfb_data->screen_fix.smem_start = get_ambarella_fbmem_phys();
-              ambfb_data->screen_fix.smem_len = get_ambarella_fbmem_size();
-       }else{
-              ambfb_data->use_prealloc =0;
-              ambfb_data->conversion_buf.available = 0;
-       }
-
-	mutex_lock(&ambfb_data->lock);
-
-	info->fbops = &ambfb_ops;
-	info->par = ambfb_data;
-	info->var = ambfb_data->screen_var;
-	info->fix = ambfb_data->screen_fix;
-	info->flags = FBINFO_FLAG_DEFAULT;
-
-	/* Fill Color-related Variables */
-	for (i = 0; i < ARRAY_SIZE(ambarella_fb_color_format_table); i++) {
-		if (ambarella_fb_color_format_table[i].color_format ==
-			ambfb_data->color_format)
-			break;
-	}
-	if (i < ARRAY_SIZE(ambarella_fb_color_format_table)) {
-		info->var.bits_per_pixel =
-			ambarella_fb_color_format_table[i].bits_per_pixel;
-		info->var.red = ambarella_fb_color_format_table[i].red;
-		info->var.green = ambarella_fb_color_format_table[i].green;
-		info->var.blue = ambarella_fb_color_format_table[i].blue;
-		info->var.transp = ambarella_fb_color_format_table[i].transp;
-	}else{
-              dev_err(&pdev->dev, "%s: do not support color formate:%d!\n",
-                     __func__,ambfb_data->color_format);
-              errorCode = -EINVAL;
-              goto ambfb_probe_release_framebuffer;
-       }
-
-	/* Malloc Framebuffer Memory */
-	line_length = (info->var.xres_virtual *
-		(info->var.bits_per_pixel / 8) + 31) & 0xffffffe0;
-	if (ambfb_data->use_prealloc == 0) {
-		info->fix.line_length = line_length;
-	} else {
-		info->fix.line_length =
-			(line_length > ambfb_data->prealloc_line_length) ?
-			line_length : ambfb_data->prealloc_line_length;
-	}
-
-	framesize = info->fix.line_length * info->var.yres_virtual;
-	if (framesize % PAGE_SIZE) {
-		framesize /= PAGE_SIZE;
-		framesize++;
-		framesize *= PAGE_SIZE;
-	}
-
-	if (ambfb_data->use_prealloc == 0) {
-		info->screen_base = kzalloc(framesize, GFP_KERNEL);
-		if (info->screen_base == NULL) {
-			dev_err(&pdev->dev, "%s(%d): Can't get %d bytes fbmem!\n",
-				__func__, __LINE__,framesize);
-			errorCode = -ENOMEM;
-			goto ambfb_probe_release_framebuffer;
-		}
-		info->fix.smem_start = virt_to_phys(info->screen_base);
-		info->fix.smem_len = framesize;
-	} else {
-		if ((info->fix.smem_start == 0) ||
-			(info->fix.smem_len < framesize)) {
-			dev_err(&pdev->dev, "%s: prealloc[0x%08x < 0x%08x]!\n",
-				__func__, info->fix.smem_len, framesize);
-			errorCode = -ENOMEM;
-			goto ambfb_probe_release_framebuffer;
-		}
-
-              info->screen_base = ioremap(info->fix.smem_start,info->fix.smem_len);
-              memset(info->screen_base, 0, info->fix.smem_len);
-              if (!info->screen_base) {
-                     dev_err(&pdev->dev, "%s: ioremap() failed\n",__func__);
-                     errorCode = -ENOMEM;
-                     goto ambfb_probe_exit;
-              }
-
-		if (ambfb_data->conversion_buf.available) {
-			if (info->fix.smem_len < 3 * framesize) {
-				ambfb_data->conversion_buf.available = 0;
-				dev_err(&pdev->dev,
-					"%s: prealloc[0x%08x < 0x%08x]!\n",
-					__func__, info->fix.smem_len,
-					3 * framesize);
-				errorCode = -ENOMEM;
-				goto ambfb_probe_release_framebuffer;
-			} else {
-				ambfb_data->conversion_buf.ping_buf =
-					info->screen_base + framesize;
-                                ambfb_data->conversion_buf.ping_buf_phy =
-                                        info->fix.smem_start + framesize;
-				ambfb_data->conversion_buf.ping_buf_size =
-					framesize;
-				ambfb_data->conversion_buf.pong_buf =
-					ambfb_data->conversion_buf.ping_buf + framesize;
-                                ambfb_data->conversion_buf.pong_buf_phy =
-                                        ambfb_data->conversion_buf.ping_buf_phy + framesize;
-				ambfb_data->conversion_buf.pong_buf_size =
-					framesize;
-                                ambfb_data->conversion_buf.base_buf_phy =
-                                        ambfb_data->screen_fix.smem_start;
-			}
-		}
-	}
-
-	errorCode = fb_alloc_cmap(&info->cmap, 256, 1);
-	if (errorCode < 0) {
-		dev_err(&pdev->dev, "%s: fb_alloc_cmap fail!\n", __func__);
-		errorCode = -ENOMEM;
-		goto ambfb_probe_release_framebuffer;
-	}
-	for (i = info->cmap.start; i < info->cmap.len; i++) {
-		info->cmap.red[i] = i << 8;
-		info->cmap.green[i] = 128 << 8;
-		info->cmap.blue[i] = 128 << 8;
-		if (info->cmap.transp)
-			info->cmap.transp[i] = 12 << 8;
-	}
-
-	platform_set_drvdata(pdev, info);
-	ambfb_data->fb_status = AMBFB_ACTIVE_MODE;
-	mutex_unlock(&ambfb_data->lock);
-
-	errorCode = register_framebuffer(info);
-	if (errorCode < 0) {
-		dev_err(&pdev->dev, "%s: register_framebuffer fail!\n",
-			__func__);
-		errorCode = -ENOMEM;
-		mutex_lock(&ambfb_data->lock);
-		goto ambfb_probe_dealloc_cmap;
-	}
-
-	ambfb_data->proc_fb_info = info;
+        int                                errorCode = 0;
+        struct fb_info                     *info;
+        char                               fb_name[64];
+        char                               *option;
+        struct ambarella_platform_fb       *ambfb_data = NULL;
+        u32                                i, framesize, line_length;
+
+        ambfb_data = ambfb_data_ptr[pdev->id];
+
+        snprintf(fb_name, sizeof(fb_name), "amb%dfb", pdev->id);
+        if (fb_get_options(fb_name, &option)) {
+                dev_err(&pdev->dev, "%s: get fb options fail!\n", __func__);
+                errorCode = -ENODEV;
+                goto ambfb_probe_exit;
+        }
+        if (ambfb_setup(&pdev->dev, option, ambfb_data)) {
+                errorCode = -ENODEV;
+                goto ambfb_probe_exit;
+        }
+
+        info = framebuffer_alloc(sizeof(ambfb_data), &pdev->dev);
+        if (info == NULL) {
+                dev_err(&pdev->dev, "%s: framebuffer_alloc fail!\n", __func__);
+                errorCode = -ENOMEM;
+                goto ambfb_probe_exit;
+        }
+
+        if(get_ambarella_fbmem_size()) {
+                ambfb_data->use_prealloc = 1;
+                ambfb_data->conversion_buf.available = 1;
+                if((ambfb_data->screen_fix.smem_start == 0) ||
+                        (ambfb_data->screen_fix.smem_len == 0) ||
+                        (ambfb_data->screen_fix.smem_len > get_ambarella_fbmem_size())) {
+                        errorCode = -EINVAL;
+                        dev_err(&pdev->dev, "please set right fbmem start address in dts file\n");
+                        goto ambfb_probe_release_framebuffer;
+                }
+        } else {
+                ambfb_data->use_prealloc = 0;
+                ambfb_data->conversion_buf.available = 0;
+        }
+
+        mutex_lock(&ambfb_data->lock);
+
+        info->fbops = &ambfb_ops;
+        info->par = ambfb_data;
+        info->var = ambfb_data->screen_var;
+        info->fix = ambfb_data->screen_fix;
+        info->flags = FBINFO_FLAG_DEFAULT;
+
+        /* Fill Color-related Variables */
+        for (i = 0; i < ARRAY_SIZE(ambarella_fb_color_format_table); i++) {
+                if (ambarella_fb_color_format_table[i].color_format ==
+                    ambfb_data->color_format)
+                        break;
+        }
+        if (i < ARRAY_SIZE(ambarella_fb_color_format_table)) {
+                info->var.bits_per_pixel =
+                        ambarella_fb_color_format_table[i].bits_per_pixel;
+                info->var.red = ambarella_fb_color_format_table[i].red;
+                info->var.green = ambarella_fb_color_format_table[i].green;
+                info->var.blue = ambarella_fb_color_format_table[i].blue;
+                info->var.transp = ambarella_fb_color_format_table[i].transp;
+        } else {
+                dev_err(&pdev->dev, "%s: do not support color formate:%d!\n",
+                        __func__, ambfb_data->color_format);
+                errorCode = -EINVAL;
+                goto ambfb_probe_release_framebuffer;
+        }
+
+        /* Malloc Framebuffer Memory */
+        line_length = (info->var.xres_virtual *
+                       (info->var.bits_per_pixel / 8) + 31) & 0xffffffe0;
+        if (ambfb_data->use_prealloc == 0) {
+                info->fix.line_length = line_length;
+        } else {
+                info->fix.line_length =
+                        (line_length > ambfb_data->prealloc_line_length) ?
+                        line_length : ambfb_data->prealloc_line_length;
+        }
+
+        framesize = info->fix.line_length * info->var.yres_virtual;
+        if (framesize % PAGE_SIZE) {
+                framesize /= PAGE_SIZE;
+                framesize++;
+                framesize *= PAGE_SIZE;
+        }
+
+        if (ambfb_data->use_prealloc == 0) {
+                info->screen_base = kzalloc(framesize, GFP_KERNEL);
+                if (info->screen_base == NULL) {
+                        dev_err(&pdev->dev, "%s(%d): Can't get %d bytes fbmem!\n",
+                                __func__, __LINE__, framesize);
+                        errorCode = -ENOMEM;
+                        goto ambfb_probe_release_framebuffer;
+                }
+                info->fix.smem_start = virt_to_phys(info->screen_base);
+                info->fix.smem_len = framesize;
+        } else {
+                if ((info->fix.smem_start == 0) ||
+                    (info->fix.smem_len < framesize)) {
+                        dev_err(&pdev->dev, "%s: prealloc[0x%08x < 0x%08x]!\n",
+                                __func__, info->fix.smem_len, framesize);
+                        errorCode = -ENOMEM;
+                        goto ambfb_probe_release_framebuffer;
+                }
+
+                info->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);
+                memset(info->screen_base, 0, info->fix.smem_len);
+                if (!info->screen_base) {
+                        dev_err(&pdev->dev, "%s: ioremap() failed\n", __func__);
+                        errorCode = -ENOMEM;
+                        goto ambfb_probe_exit;
+                }
+
+                if (ambfb_data->conversion_buf.available) {
+                        ambfb_data->conversion_buf.base_buf_phy =
+                                ambfb_data->screen_fix.smem_start;
+                }
+        }
+
+        errorCode = fb_alloc_cmap(&info->cmap, 256, 1);
+        if (errorCode < 0) {
+                dev_err(&pdev->dev, "%s: fb_alloc_cmap fail!\n", __func__);
+                errorCode = -ENOMEM;
+                goto ambfb_probe_release_framebuffer;
+        }
+        for (i = info->cmap.start; i < info->cmap.len; i++) {
+                info->cmap.red[i] = i << 8;
+                info->cmap.green[i] = 128 << 8;
+                info->cmap.blue[i] = 128 << 8;
+                if (info->cmap.transp)
+                        info->cmap.transp[i] = 12 << 8;
+        }
+
+        platform_set_drvdata(pdev, info);
+        ambfb_data->fb_status = AMBFB_ACTIVE_MODE;
+        mutex_unlock(&ambfb_data->lock);
+
+        errorCode = register_framebuffer(info);
+        if (errorCode < 0) {
+                dev_err(&pdev->dev, "%s: register_framebuffer fail!\n",
+                        __func__);
+                errorCode = -ENOMEM;
+                mutex_lock(&ambfb_data->lock);
+                goto ambfb_probe_dealloc_cmap;
+        }
+
+        ambfb_data->proc_fb_info = info;
 
 #ifdef CONFIG_PROC_FS
-	ambfb_data->proc_file = proc_create_data(dev_name(&pdev->dev),
-		(S_IRUGO | S_IWUSR), get_ambarella_proc_dir(),
-		&ambarella_fb_fops, ambfb_data);
-	if (ambfb_data->proc_file == NULL) {
-		errorCode = -ENOMEM;
-		goto ambfb_probe_unregister_framebuffer;
-	}
+        ambfb_data->proc_file = proc_create_data(dev_name(&pdev->dev),
+                                                 (S_IRUGO | S_IWUSR), get_ambarella_proc_dir(),
+                                                 &ambarella_fb_fops, ambfb_data);
+        if (ambfb_data->proc_file == NULL) {
+                errorCode = -ENOMEM;
+                goto ambfb_probe_unregister_framebuffer;
+        }
 #endif
 
-	mutex_lock(&ambfb_data->lock);
-	ambfb_data->screen_var = info->var;
-	ambfb_data->screen_fix = info->fix;
-	mutex_unlock(&ambfb_data->lock);
+        mutex_lock(&ambfb_data->lock);
+        ambfb_data->screen_var = info->var;
+        ambfb_data->screen_fix = info->fix;
+        mutex_unlock(&ambfb_data->lock);
 
-	dev_info(&pdev->dev,
-		"probe p[%dx%d] v[%dx%d] c[%d] b[%d] l[%d] @ [0x%08lx:0x%08x],base:0x%p!\n",
-		info->var.xres, info->var.yres, info->var.xres_virtual,
-		info->var.yres_virtual, ambfb_data->color_format,
-		ambfb_data->conversion_buf.available,
-		info->fix.line_length,
-		info->fix.smem_start, info->fix.smem_len,info->screen_base);
-	goto ambfb_probe_exit;
+        dev_info(&pdev->dev,
+                 "probe p[%dx%d] v[%dx%d] c[%d] b[%d] l[%d] @ [0x%08lx:0x%08x],base:0x%p!\n",
+                 info->var.xres, info->var.yres, info->var.xres_virtual,
+                 info->var.yres_virtual, ambfb_data->color_format,
+                 ambfb_data->conversion_buf.available,
+                 info->fix.line_length,
+                 info->fix.smem_start, info->fix.smem_len, info->screen_base);
+        goto ambfb_probe_exit;
 
 ambfb_probe_unregister_framebuffer:
-	unregister_framebuffer(info);
+        unregister_framebuffer(info);
 
 ambfb_probe_dealloc_cmap:
-	fb_dealloc_cmap(&info->cmap);
+        fb_dealloc_cmap(&info->cmap);
 
 ambfb_probe_release_framebuffer:
-	framebuffer_release(info);
-	ambfb_data->fb_status = AMBFB_STOP_MODE;
-	mutex_unlock(&ambfb_data->lock);
+        framebuffer_release(info);
+        ambfb_data->fb_status = AMBFB_STOP_MODE;
+        mutex_unlock(&ambfb_data->lock);
 
 ambfb_probe_exit:
-	return errorCode;
+        return errorCode;
 }
 
 static int ambfb_remove(struct platform_device *pdev)
 {
-	struct fb_info				*info;
-	struct ambarella_platform_fb		*ambfb_data = NULL;
+        struct fb_info				*info;
+        struct ambarella_platform_fb		*ambfb_data = NULL;
 
-	info = platform_get_drvdata(pdev);
-	if (info) {
-		ambfb_data = (struct ambarella_platform_fb *)info->par;
+        info = platform_get_drvdata(pdev);
+        if (info) {
+                ambfb_data = (struct ambarella_platform_fb *)info->par;
 
 #ifdef CONFIG_PROC_FS
-		proc_remove(ambfb_data->proc_file);
+                proc_remove(ambfb_data->proc_file);
 #endif
-		unregister_framebuffer(info);
-
-		mutex_lock(&ambfb_data->lock);
-		ambfb_data->fb_status = AMBFB_STOP_MODE;
-		fb_dealloc_cmap(&info->cmap);
-		if (ambfb_data->use_prealloc == 0) {
-			if (info->screen_base) {
-				kfree(info->screen_base);
-			}
-			if (ambfb_data->conversion_buf.available) {
-				if (ambfb_data->conversion_buf.ping_buf) {
-					kfree(ambfb_data->conversion_buf.ping_buf);
-				}
-				if (ambfb_data->conversion_buf.pong_buf) {
-					kfree(ambfb_data->conversion_buf.pong_buf);
-				}
-			}
-			ambfb_data->screen_fix.smem_start = 0;
-			ambfb_data->screen_fix.smem_len = 0;
-		}
-		framebuffer_release(info);
-		mutex_unlock(&ambfb_data->lock);
-	}
-
-	return 0;
+                unregister_framebuffer(info);
+
+                mutex_lock(&ambfb_data->lock);
+                ambfb_data->fb_status = AMBFB_STOP_MODE;
+                fb_dealloc_cmap(&info->cmap);
+                if (ambfb_data->use_prealloc == 0) {
+                        if (info->screen_base) {
+                                kfree(info->screen_base);
+                        }
+                        if (ambfb_data->conversion_buf.available) {
+                                if (ambfb_data->conversion_buf.ping_buf) {
+                                        kfree(ambfb_data->conversion_buf.ping_buf);
+                                }
+                                if (ambfb_data->conversion_buf.pong_buf) {
+                                        kfree(ambfb_data->conversion_buf.pong_buf);
+                                }
+                        }
+                        ambfb_data->screen_fix.smem_start = 0;
+                        ambfb_data->screen_fix.smem_len = 0;
+                }
+                framebuffer_release(info);
+                mutex_unlock(&ambfb_data->lock);
+        }
+
+        return 0;
 }
 
 #ifdef CONFIG_PM
 static int ambfb_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	int					errorCode = 0;
+        int					errorCode = 0;
 
-	dev_dbg(&pdev->dev, "%s exit with %d @ %d\n",
-		__func__, errorCode, state.event);
+        dev_dbg(&pdev->dev, "%s exit with %d @ %d\n",
+                __func__, errorCode, state.event);
 
-	return errorCode;
+        return errorCode;
 }
 
 static int ambfb_resume(struct platform_device *pdev)
 {
-	int					errorCode = 0;
+        int					errorCode = 0;
 
-	dev_dbg(&pdev->dev, "%s exit with %d\n", __func__, errorCode);
+        dev_dbg(&pdev->dev, "%s exit with %d\n", __func__, errorCode);
 
-	return errorCode;
+        return errorCode;
 }
 #endif
 
 static struct platform_driver ambfb_driver = {
-	.probe		= ambfb_probe,
-	.remove 	= ambfb_remove,
+        .probe		= ambfb_probe,
+        .remove 	= ambfb_remove,
 #ifdef CONFIG_PM
-	.suspend        = ambfb_suspend,
-	.resume		= ambfb_resume,
+        .suspend        = ambfb_suspend,
+        .resume		= ambfb_resume,
 #endif
-	.driver = {
-		.name	= "ambarella-fb",
-	},
+        .driver = {
+                .name	= "ambarella-fb",
+        },
 };
 
-static void ambfb_dev_release(struct device *dev)
-{
-}
-
 static struct platform_device ambarella_fb0 = {
-	.name			= "ambarella-fb",
-	.id			= 0,
-	.dev		= {
-		.release      = &ambfb_dev_release,
-	}
+        .name			= "ambarella-fb",
+        .id			= 0,
 };
 
 static struct platform_device ambarella_fb1 = {
-	.name			= "ambarella-fb",
-	.id			= 1,
-	.dev		= {
-		.release      = &ambfb_dev_release,
-	}
+        .name			= "ambarella-fb",
+        .id			= 1,
 };
 
 static int __init ambavoutfb_init(void)
 {
-	platform_device_register(&ambarella_fb0);
-	platform_device_register(&ambarella_fb1);
-	return platform_driver_register(&ambfb_driver);
+        platform_device_register(&ambarella_fb0);
+        platform_device_register(&ambarella_fb1);
+        return platform_driver_register(&ambfb_driver);
 }
 
 static void __exit ambavoutfb_exit(void)
 {
-	platform_driver_unregister(&ambfb_driver);
-	platform_device_unregister(&ambarella_fb1);
-	platform_device_unregister(&ambarella_fb0);
+        platform_driver_unregister(&ambfb_driver);
+        platform_device_unregister(&ambarella_fb1);
+        platform_device_unregister(&ambarella_fb0);
 }
 
 MODULE_LICENSE("GPL");
diff --git a/drivers/video/console/Kconfig b/drivers/video/console/Kconfig
index bc922c4..37e62c7b 100644
--- a/drivers/video/console/Kconfig
+++ b/drivers/video/console/Kconfig
@@ -6,7 +6,10 @@ menu "Console display driver support"
 
 config VGA_CONSOLE
 	bool "VGA text console" if EXPERT || !X86
-	depends on !4xx && !8xx && !SPARC && !M68K && !PARISC && !FRV && !SUPERH && !BLACKFIN && !AVR32 && !MN10300 && (!ARM || ARCH_FOOTBRIDGE || ARCH_INTEGRATOR || ARCH_NETWINDER)
+	depends on !4xx && !8xx && !SPARC && !M68K && !PARISC && !FRV && \
+		!SUPERH && !BLACKFIN && !AVR32 && !MN10300 && !CRIS && \
+		(!ARM || ARCH_FOOTBRIDGE || ARCH_INTEGRATOR || ARCH_NETWINDER) && \
+		!ARM64
 	default y
 	help
 	  Saying Y here will allow you to use Linux in text mode through a
diff --git a/drivers/video/da8xx-fb.c b/drivers/video/da8xx-fb.c
index 0810939..b13bfb2 100644
--- a/drivers/video/da8xx-fb.c
+++ b/drivers/video/da8xx-fb.c
@@ -226,8 +226,7 @@ static struct fb_videomode known_lcd_panels[] = {
 		.lower_margin   = 2,
 		.hsync_len      = 0,
 		.vsync_len      = 0,
-		.sync           = FB_SYNC_CLK_INVERT |
-			FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		.sync           = FB_SYNC_CLK_INVERT,
 	},
 	/* Sharp LK043T1DG01 */
 	[1] = {
@@ -241,7 +240,7 @@ static struct fb_videomode known_lcd_panels[] = {
 		.lower_margin   = 2,
 		.hsync_len      = 41,
 		.vsync_len      = 10,
-		.sync           = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		.sync           = 0,
 		.flag           = 0,
 	},
 	[2] = {
@@ -256,7 +255,7 @@ static struct fb_videomode known_lcd_panels[] = {
 		.lower_margin   = 10,
 		.hsync_len      = 10,
 		.vsync_len      = 10,
-		.sync           = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		.sync           = 0,
 		.flag           = 0,
 	},
 };
diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index ee59b74..beaa7cc 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -238,6 +238,7 @@ static int virtio_init(void)
 static void __exit virtio_exit(void)
 {
 	bus_unregister(&virtio_bus);
+	ida_destroy(&virtio_index_ida);
 }
 core_initcall(virtio_init);
 module_exit(virtio_exit);
diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c
index 7d7add5..148e8ea 100644
--- a/drivers/virtio/virtio_balloon.c
+++ b/drivers/virtio/virtio_balloon.c
@@ -177,6 +177,8 @@ static void leak_balloon(struct virtio_balloon *vb, size_t num)
 	num = min(num, ARRAY_SIZE(vb->pfns));
 
 	mutex_lock(&vb->balloon_lock);
+	/* We can't release more pages than taken */
+	num = min(num, (size_t)vb->num_pages);
 	for (vb->num_pfns = 0; vb->num_pfns < num;
 	     vb->num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {
 		page = balloon_page_dequeue(vb_dev_info);
diff --git a/drivers/watchdog/ambarella_wdt.c b/drivers/watchdog/ambarella_wdt.c
index 8e868d0..39fb976 100644
--- a/drivers/watchdog/ambarella_wdt.c
+++ b/drivers/watchdog/ambarella_wdt.c
@@ -234,7 +234,8 @@ static int ambarella_wdt_suspend(struct platform_device *pdev,
 
 	ambwdt = platform_get_drvdata(pdev);
 
-	ambarella_wdt_stop(&ambwdt->wdd);
+	if (watchdog_active(&ambwdt->wdd))
+		ambarella_wdt_stop(&ambwdt->wdd);
 
 	dev_dbg(&pdev->dev, "%s exit with %d @ %d\n",
 				__func__, rval, state.event);
@@ -249,8 +250,10 @@ static int ambarella_wdt_resume(struct platform_device *pdev)
 
 	ambwdt = platform_get_drvdata(pdev);
 
-	if (ambwdt->enabled)
+	if (watchdog_active(&ambwdt->wdd)) {
 		ambarella_wdt_start(&ambwdt->wdd);
+		ambarella_wdt_keepalive(&ambwdt->wdd);
+	}
 
 	dev_dbg(&pdev->dev, "%s exit with %d\n", __func__, rval);
 
diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c
index af88ffd..2b7e073 100644
--- a/drivers/watchdog/omap_wdt.c
+++ b/drivers/watchdog/omap_wdt.c
@@ -134,6 +134,13 @@ static int omap_wdt_start(struct watchdog_device *wdog)
 
 	pm_runtime_get_sync(wdev->dev);
 
+	/*
+	 * Make sure the watchdog is disabled. This is unfortunately required
+	 * because writing to various registers with the watchdog running has no
+	 * effect.
+	 */
+	omap_wdt_disable(wdev);
+
 	/* initialize prescaler */
 	while (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x01)
 		cpu_relax();
diff --git a/drivers/watchdog/rc32434_wdt.c b/drivers/watchdog/rc32434_wdt.c
index f78bc00..ea8f582 100644
--- a/drivers/watchdog/rc32434_wdt.c
+++ b/drivers/watchdog/rc32434_wdt.c
@@ -237,7 +237,7 @@ static long rc32434_wdt_ioctl(struct file *file, unsigned int cmd,
 			return -EINVAL;
 		/* Fall through */
 	case WDIOC_GETTIMEOUT:
-		return copy_to_user(argp, &timeout, sizeof(int));
+		return copy_to_user(argp, &timeout, sizeof(int)) ? -EFAULT : 0;
 	default:
 		return -ENOTTY;
 	}
diff --git a/drivers/xen/gntdev.c b/drivers/xen/gntdev.c
index 3c8803f..3d8e609 100644
--- a/drivers/xen/gntdev.c
+++ b/drivers/xen/gntdev.c
@@ -65,7 +65,7 @@ struct gntdev_priv {
 	 * Only populated if populate_freeable_maps == 1 */
 	struct list_head freeable_maps;
 	/* lock protects maps and freeable_maps */
-	spinlock_t lock;
+	struct mutex lock;
 	struct mm_struct *mm;
 	struct mmu_notifier mn;
 };
@@ -214,9 +214,9 @@ static void gntdev_put_map(struct gntdev_priv *priv, struct grant_map *map)
 	}
 
 	if (populate_freeable_maps && priv) {
-		spin_lock(&priv->lock);
+		mutex_lock(&priv->lock);
 		list_del(&map->next);
-		spin_unlock(&priv->lock);
+		mutex_unlock(&priv->lock);
 	}
 
 	if (map->pages && !use_ptemod)
@@ -392,9 +392,9 @@ static void gntdev_vma_close(struct vm_area_struct *vma)
 		 * not do any unmapping, since that has been done prior to
 		 * closing the vma, but it may still iterate the unmap_ops list.
 		 */
-		spin_lock(&priv->lock);
+		mutex_lock(&priv->lock);
 		map->vma = NULL;
-		spin_unlock(&priv->lock);
+		mutex_unlock(&priv->lock);
 	}
 	vma->vm_private_data = NULL;
 	gntdev_put_map(priv, map);
@@ -438,14 +438,14 @@ static void mn_invl_range_start(struct mmu_notifier *mn,
 	struct gntdev_priv *priv = container_of(mn, struct gntdev_priv, mn);
 	struct grant_map *map;
 
-	spin_lock(&priv->lock);
+	mutex_lock(&priv->lock);
 	list_for_each_entry(map, &priv->maps, next) {
 		unmap_if_in_range(map, start, end);
 	}
 	list_for_each_entry(map, &priv->freeable_maps, next) {
 		unmap_if_in_range(map, start, end);
 	}
-	spin_unlock(&priv->lock);
+	mutex_unlock(&priv->lock);
 }
 
 static void mn_invl_page(struct mmu_notifier *mn,
@@ -462,7 +462,7 @@ static void mn_release(struct mmu_notifier *mn,
 	struct grant_map *map;
 	int err;
 
-	spin_lock(&priv->lock);
+	mutex_lock(&priv->lock);
 	list_for_each_entry(map, &priv->maps, next) {
 		if (!map->vma)
 			continue;
@@ -481,7 +481,7 @@ static void mn_release(struct mmu_notifier *mn,
 		err = unmap_grant_pages(map, /* offset */ 0, map->count);
 		WARN_ON(err);
 	}
-	spin_unlock(&priv->lock);
+	mutex_unlock(&priv->lock);
 }
 
 static struct mmu_notifier_ops gntdev_mmu_ops = {
@@ -503,7 +503,7 @@ static int gntdev_open(struct inode *inode, struct file *flip)
 
 	INIT_LIST_HEAD(&priv->maps);
 	INIT_LIST_HEAD(&priv->freeable_maps);
-	spin_lock_init(&priv->lock);
+	mutex_init(&priv->lock);
 
 	if (use_ptemod) {
 		priv->mm = get_task_mm(current);
@@ -534,12 +534,14 @@ static int gntdev_release(struct inode *inode, struct file *flip)
 
 	pr_debug("priv %p\n", priv);
 
+	mutex_lock(&priv->lock);
 	while (!list_empty(&priv->maps)) {
 		map = list_entry(priv->maps.next, struct grant_map, next);
 		list_del(&map->next);
 		gntdev_put_map(NULL /* already removed */, map);
 	}
 	WARN_ON(!list_empty(&priv->freeable_maps));
+	mutex_unlock(&priv->lock);
 
 	if (use_ptemod)
 		mmu_notifier_unregister(&priv->mn, priv->mm);
@@ -577,10 +579,10 @@ static long gntdev_ioctl_map_grant_ref(struct gntdev_priv *priv,
 		return -EFAULT;
 	}
 
-	spin_lock(&priv->lock);
+	mutex_lock(&priv->lock);
 	gntdev_add_map(priv, map);
 	op.index = map->index << PAGE_SHIFT;
-	spin_unlock(&priv->lock);
+	mutex_unlock(&priv->lock);
 
 	if (copy_to_user(u, &op, sizeof(op)) != 0)
 		return -EFAULT;
@@ -599,7 +601,7 @@ static long gntdev_ioctl_unmap_grant_ref(struct gntdev_priv *priv,
 		return -EFAULT;
 	pr_debug("priv %p, del %d+%d\n", priv, (int)op.index, (int)op.count);
 
-	spin_lock(&priv->lock);
+	mutex_lock(&priv->lock);
 	map = gntdev_find_map_index(priv, op.index >> PAGE_SHIFT, op.count);
 	if (map) {
 		list_del(&map->next);
@@ -607,7 +609,7 @@ static long gntdev_ioctl_unmap_grant_ref(struct gntdev_priv *priv,
 			list_add_tail(&map->next, &priv->freeable_maps);
 		err = 0;
 	}
-	spin_unlock(&priv->lock);
+	mutex_unlock(&priv->lock);
 	if (map)
 		gntdev_put_map(priv, map);
 	return err;
@@ -675,7 +677,7 @@ static long gntdev_ioctl_notify(struct gntdev_priv *priv, void __user *u)
 	out_flags = op.action;
 	out_event = op.event_channel_port;
 
-	spin_lock(&priv->lock);
+	mutex_lock(&priv->lock);
 
 	list_for_each_entry(map, &priv->maps, next) {
 		uint64_t begin = map->index << PAGE_SHIFT;
@@ -703,7 +705,7 @@ static long gntdev_ioctl_notify(struct gntdev_priv *priv, void __user *u)
 	rc = 0;
 
  unlock_out:
-	spin_unlock(&priv->lock);
+	mutex_unlock(&priv->lock);
 
 	/* Drop the reference to the event channel we did not save in the map */
 	if (out_flags & UNMAP_NOTIFY_SEND_EVENT)
@@ -753,7 +755,7 @@ static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)
 	pr_debug("map %d+%d at %lx (pgoff %lx)\n",
 			index, count, vma->vm_start, vma->vm_pgoff);
 
-	spin_lock(&priv->lock);
+	mutex_lock(&priv->lock);
 	map = gntdev_find_map_index(priv, index, count);
 	if (!map)
 		goto unlock_out;
@@ -768,7 +770,7 @@ static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)
 
 	vma->vm_ops = &gntdev_vmops;
 
-	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
+	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO;
 
 	if (use_ptemod)
 		vma->vm_flags |= VM_DONTCOPY;
@@ -788,7 +790,7 @@ static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)
 			map->flags |= GNTMAP_readonly;
 	}
 
-	spin_unlock(&priv->lock);
+	mutex_unlock(&priv->lock);
 
 	if (use_ptemod) {
 		err = apply_to_page_range(vma->vm_mm, vma->vm_start,
@@ -816,11 +818,11 @@ static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)
 	return 0;
 
 unlock_out:
-	spin_unlock(&priv->lock);
+	mutex_unlock(&priv->lock);
 	return err;
 
 out_unlock_put:
-	spin_unlock(&priv->lock);
+	mutex_unlock(&priv->lock);
 out_put_map:
 	if (use_ptemod)
 		map->vma = NULL;
diff --git a/drivers/xen/xen-acpi-processor.c b/drivers/xen/xen-acpi-processor.c
index 8abd7d5..2e45172 100644
--- a/drivers/xen/xen-acpi-processor.c
+++ b/drivers/xen/xen-acpi-processor.c
@@ -426,36 +426,7 @@ upload:
 
 	return 0;
 }
-static int __init check_prereq(void)
-{
-	struct cpuinfo_x86 *c = &cpu_data(0);
-
-	if (!xen_initial_domain())
-		return -ENODEV;
-
-	if (!acpi_gbl_FADT.smi_command)
-		return -ENODEV;
-
-	if (c->x86_vendor == X86_VENDOR_INTEL) {
-		if (!cpu_has(c, X86_FEATURE_EST))
-			return -ENODEV;
 
-		return 0;
-	}
-	if (c->x86_vendor == X86_VENDOR_AMD) {
-		/* Copied from powernow-k8.h, can't include ../cpufreq/powernow
-		 * as we get compile warnings for the static functions.
-		 */
-#define CPUID_FREQ_VOLT_CAPABILITIES    0x80000007
-#define USE_HW_PSTATE                   0x00000080
-		u32 eax, ebx, ecx, edx;
-		cpuid(CPUID_FREQ_VOLT_CAPABILITIES, &eax, &ebx, &ecx, &edx);
-		if ((edx & USE_HW_PSTATE) != USE_HW_PSTATE)
-			return -ENODEV;
-		return 0;
-	}
-	return -ENODEV;
-}
 /* acpi_perf_data is a pointer to percpu data. */
 static struct acpi_processor_performance __percpu *acpi_perf_data;
 
@@ -511,10 +482,10 @@ static struct syscore_ops xap_syscore_ops = {
 static int __init xen_acpi_processor_init(void)
 {
 	unsigned int i;
-	int rc = check_prereq();
+	int rc;
 
-	if (rc)
-		return rc;
+	if (!xen_initial_domain())
+		return -ENODEV;
 
 	nr_acpi_bits = get_max_acpi_id() + 1;
 	acpi_ids_done = kcalloc(BITS_TO_LONGS(nr_acpi_bits), sizeof(unsigned long), GFP_KERNEL);
diff --git a/drivers/xen/xen-pciback/conf_space.c b/drivers/xen/xen-pciback/conf_space.c
index 75fe3d4..ba3fac8 100644
--- a/drivers/xen/xen-pciback/conf_space.c
+++ b/drivers/xen/xen-pciback/conf_space.c
@@ -183,8 +183,7 @@ int xen_pcibk_config_read(struct pci_dev *dev, int offset, int size,
 		field_start = OFFSET(cfg_entry);
 		field_end = OFFSET(cfg_entry) + field->size;
 
-		if ((req_start >= field_start && req_start < field_end)
-		    || (req_end > field_start && req_end <= field_end)) {
+		 if (req_end > field_start && field_end > req_start) {
 			err = conf_space_read(dev, cfg_entry, field_start,
 					      &tmp_val);
 			if (err)
@@ -230,8 +229,7 @@ int xen_pcibk_config_write(struct pci_dev *dev, int offset, int size, u32 value)
 		field_start = OFFSET(cfg_entry);
 		field_end = OFFSET(cfg_entry) + field->size;
 
-		if ((req_start >= field_start && req_start < field_end)
-		    || (req_end > field_start && req_end <= field_end)) {
+		 if (req_end > field_start && field_end > req_start) {
 			tmp_val = 0;
 
 			err = xen_pcibk_config_read(dev, field_start,
diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c
index d86edc8..4c7d309 100644
--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@ -537,8 +537,7 @@ static struct inode *v9fs_qid_iget(struct super_block *sb,
 	unlock_new_inode(inode);
 	return inode;
 error:
-	unlock_new_inode(inode);
-	iput(inode);
+	iget_failed(inode);
 	return ERR_PTR(retval);
 
 }
diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c
index 53687bb..65b21a2 100644
--- a/fs/9p/vfs_inode_dotl.c
+++ b/fs/9p/vfs_inode_dotl.c
@@ -151,8 +151,7 @@ static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,
 	unlock_new_inode(inode);
 	return inode;
 error:
-	unlock_new_inode(inode);
-	iput(inode);
+	iget_failed(inode);
 	return ERR_PTR(retval);
 
 }
diff --git a/fs/affs/amigaffs.c b/fs/affs/amigaffs.c
index d9a4367..9cca0ea 100644
--- a/fs/affs/amigaffs.c
+++ b/fs/affs/amigaffs.c
@@ -126,7 +126,7 @@ affs_fix_dcache(struct inode *inode, u32 entry_ino)
 {
 	struct dentry *dentry;
 	spin_lock(&inode->i_lock);
-	hlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {
+	hlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {
 		if (entry_ino == (u32)(long)dentry->d_fsdata) {
 			dentry->d_fsdata = (void *)inode->i_ino;
 			break;
diff --git a/fs/aio.c b/fs/aio.c
index ded94c4..9798d4e 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -977,12 +977,17 @@ static ssize_t aio_setup_vectored_rw(int rw, struct kiocb *kiocb, bool compat)
 
 static ssize_t aio_setup_single_vector(int rw, struct kiocb *kiocb)
 {
-	if (unlikely(!access_ok(!rw, kiocb->ki_buf, kiocb->ki_nbytes)))
-		return -EFAULT;
+	size_t len = kiocb->ki_nbytes;
+
+	if (len > MAX_RW_COUNT)
+		len = MAX_RW_COUNT;
+
+	if (unlikely(!access_ok(!rw, kiocb->ki_buf, len)))
+                return -EFAULT;
 
 	kiocb->ki_iovec = &kiocb->ki_inline_vec;
 	kiocb->ki_iovec->iov_base = kiocb->ki_buf;
-	kiocb->ki_iovec->iov_len = kiocb->ki_nbytes;
+	kiocb->ki_iovec->iov_len = len;
 	kiocb->ki_nr_segs = 1;
 	return 0;
 }
diff --git a/fs/autofs4/expire.c b/fs/autofs4/expire.c
index 13ddec9..8ad2779 100644
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@ -91,7 +91,7 @@ static struct dentry *get_next_positive_subdir(struct dentry *prev,
 	spin_lock(&root->d_lock);
 
 	if (prev)
-		next = prev->d_u.d_child.next;
+		next = prev->d_child.next;
 	else {
 		prev = dget_dlock(root);
 		next = prev->d_subdirs.next;
@@ -105,13 +105,13 @@ cont:
 		return NULL;
 	}
 
-	q = list_entry(next, struct dentry, d_u.d_child);
+	q = list_entry(next, struct dentry, d_child);
 
 	spin_lock_nested(&q->d_lock, DENTRY_D_LOCK_NESTED);
 	/* Already gone or negative dentry (under construction) - try next */
 	if (q->d_count == 0 || !simple_positive(q)) {
 		spin_unlock(&q->d_lock);
-		next = q->d_u.d_child.next;
+		next = q->d_child.next;
 		goto cont;
 	}
 	dget_dlock(q);
@@ -161,13 +161,13 @@ again:
 				goto relock;
 			}
 			spin_unlock(&p->d_lock);
-			next = p->d_u.d_child.next;
+			next = p->d_child.next;
 			p = parent;
 			if (next != &parent->d_subdirs)
 				break;
 		}
 	}
-	ret = list_entry(next, struct dentry, d_u.d_child);
+	ret = list_entry(next, struct dentry, d_child);
 
 	spin_lock_nested(&ret->d_lock, DENTRY_D_LOCK_NESTED);
 	/* Negative dentry - try next */
@@ -447,7 +447,7 @@ found:
 	spin_lock(&sbi->lookup_lock);
 	spin_lock(&expired->d_parent->d_lock);
 	spin_lock_nested(&expired->d_lock, DENTRY_D_LOCK_NESTED);
-	list_move(&expired->d_parent->d_subdirs, &expired->d_u.d_child);
+	list_move(&expired->d_parent->d_subdirs, &expired->d_child);
 	spin_unlock(&expired->d_lock);
 	spin_unlock(&expired->d_parent->d_lock);
 	spin_unlock(&sbi->lookup_lock);
diff --git a/fs/autofs4/root.c b/fs/autofs4/root.c
index 085da86..79ab4cb3 100644
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@ -655,7 +655,7 @@ static void autofs_clear_leaf_automount_flags(struct dentry *dentry)
 	/* only consider parents below dentrys in the root */
 	if (IS_ROOT(parent->d_parent))
 		return;
-	d_child = &dentry->d_u.d_child;
+	d_child = &dentry->d_child;
 	/* Set parent managed if it's becoming empty */
 	if (d_child->next == &parent->d_subdirs &&
 	    d_child->prev == &parent->d_subdirs)
diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c
index 3c4d879..948e6f2 100644
--- a/fs/binfmt_elf.c
+++ b/fs/binfmt_elf.c
@@ -682,16 +682,16 @@ static int load_elf_binary(struct linux_binprm *bprm)
 			 */
 			would_dump(bprm, interpreter);
 
-			retval = kernel_read(interpreter, 0, bprm->buf,
-					     BINPRM_BUF_SIZE);
-			if (retval != BINPRM_BUF_SIZE) {
+			/* Get the exec headers */
+			retval = kernel_read(interpreter, 0,
+					     (void *)&loc->interp_elf_ex,
+					     sizeof(loc->interp_elf_ex));
+			if (retval != sizeof(loc->interp_elf_ex)) {
 				if (retval >= 0)
 					retval = -EIO;
 				goto out_free_dentry;
 			}
 
-			/* Get the exec headers */
-			loc->interp_elf_ex = *((struct elfhdr *)bprm->buf);
 			break;
 		}
 		elf_ppnt++;
@@ -756,6 +756,7 @@ static int load_elf_binary(struct linux_binprm *bprm)
 	    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {
 		int elf_prot = 0, elf_flags;
 		unsigned long k, vaddr;
+		unsigned long total_size = 0;
 
 		if (elf_ppnt->p_type != PT_LOAD)
 			continue;
@@ -820,10 +821,16 @@ static int load_elf_binary(struct linux_binprm *bprm)
 #else
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
 #endif
+			total_size = total_mapping_size(elf_phdata,
+							loc->elf_ex.e_phnum);
+			if (!total_size) {
+				retval = -EINVAL;
+				goto out_free_dentry;
+			}
 		}
 
 		error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,
-				elf_prot, elf_flags, 0);
+				elf_prot, elf_flags, total_size);
 		if (BAD_ADDR(error)) {
 			send_sig(SIGKILL, current, 0);
 			retval = IS_ERR((void *)error) ?
diff --git a/fs/btrfs/backref.c b/fs/btrfs/backref.c
index d85f90c..bca854b 100644
--- a/fs/btrfs/backref.c
+++ b/fs/btrfs/backref.c
@@ -1228,7 +1228,8 @@ char *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,
 			read_extent_buffer(eb, dest + bytes_left,
 					   name_off, name_len);
 		if (eb != eb_in) {
-			btrfs_tree_read_unlock_blocking(eb);
+			if (!path->skip_locking)
+				btrfs_tree_read_unlock_blocking(eb);
 			free_extent_buffer(eb);
 		}
 		ret = inode_ref_info(parent, 0, fs_root, path, &found_key);
@@ -1247,9 +1248,10 @@ char *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,
 		eb = path->nodes[0];
 		/* make sure we can use eb after releasing the path */
 		if (eb != eb_in) {
-			atomic_inc(&eb->refs);
-			btrfs_tree_read_lock(eb);
-			btrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);
+			if (!path->skip_locking)
+				btrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);
+			path->nodes[0] = NULL;
+			path->locks[0] = 0;
 		}
 		btrfs_release_path(path);
 		iref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);
diff --git a/fs/btrfs/ctree.c b/fs/btrfs/ctree.c
index 7fb054b..82f14a1 100644
--- a/fs/btrfs/ctree.c
+++ b/fs/btrfs/ctree.c
@@ -2769,7 +2769,7 @@ done:
 	 */
 	if (!p->leave_spinning)
 		btrfs_set_path_blocking(p);
-	if (ret < 0)
+	if (ret < 0 && !p->skip_release_on_error)
 		btrfs_release_path(p);
 	return ret;
 }
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index d6dd49b..c19444e 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -586,6 +586,7 @@ struct btrfs_path {
 	unsigned int skip_locking:1;
 	unsigned int leave_spinning:1;
 	unsigned int search_commit_root:1;
+	unsigned int skip_release_on_error:1;
 };
 
 /*
@@ -3406,6 +3407,10 @@ struct btrfs_dir_item *btrfs_lookup_xattr(struct btrfs_trans_handle *trans,
 int verify_dir_item(struct btrfs_root *root,
 		    struct extent_buffer *leaf,
 		    struct btrfs_dir_item *dir_item);
+struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,
+						 struct btrfs_path *path,
+						 const char *name,
+						 int name_len);
 
 /* orphan.c */
 int btrfs_insert_orphan_item(struct btrfs_trans_handle *trans,
diff --git a/fs/btrfs/dir-item.c b/fs/btrfs/dir-item.c
index 79e594e..6f61b9b 100644
--- a/fs/btrfs/dir-item.c
+++ b/fs/btrfs/dir-item.c
@@ -21,10 +21,6 @@
 #include "hash.h"
 #include "transaction.h"
 
-static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,
-			      struct btrfs_path *path,
-			      const char *name, int name_len);
-
 /*
  * insert a name into a directory, doing overflow properly if there is a hash
  * collision.  data_size indicates how big the item inserted should be.  On
@@ -383,9 +379,9 @@ struct btrfs_dir_item *btrfs_lookup_xattr(struct btrfs_trans_handle *trans,
  * this walks through all the entries in a dir item and finds one
  * for a specific name.
  */
-static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,
-			      struct btrfs_path *path,
-			      const char *name, int name_len)
+struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,
+						 struct btrfs_path *path,
+						 const char *name, int name_len)
 {
 	struct btrfs_dir_item *dir_item;
 	unsigned long name_ptr;
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index 7360f03..9612a01 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -2437,6 +2437,7 @@ int open_ctree(struct super_block *sb,
 		       "unsupported option features (%Lx).\n",
 		       (unsigned long long)features);
 		err = -EINVAL;
+		brelse(bh);
 		goto fail_alloc;
 	}
 
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index f99c71e..07f167a 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -6363,12 +6363,11 @@ static int __btrfs_free_reserved_extent(struct btrfs_root *root,
 		return -ENOSPC;
 	}
 
-	if (btrfs_test_opt(root, DISCARD))
-		ret = btrfs_discard_extent(root, start, len, NULL);
-
 	if (pin)
 		pin_down_extent(root, cache, start, len, 1);
 	else {
+		if (btrfs_test_opt(root, DISCARD))
+			ret = btrfs_discard_extent(root, start, len, NULL);
 		btrfs_add_free_space(cache, start, len);
 		btrfs_update_reserved_bytes(cache, len, RESERVE_FREE);
 	}
diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c
index 84ceff6..be7e31a 100644
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@ -4080,8 +4080,11 @@ int extent_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
 		}
 		ret = fiemap_fill_next_extent(fieinfo, em_start, disko,
 					      em_len, flags);
-		if (ret)
+		if (ret) {
+			if (ret == 1)
+				ret = 0;
 			goto out_free;
+		}
 	}
 out_free:
 	free_extent_map(em);
diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 2c66ddb..0389e90 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -283,7 +283,7 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 		__btrfs_add_free_space(ctl, info->offset, count);
 free:
 		rb_erase(&info->offset_index, rbroot);
-		kfree(info);
+		kmem_cache_free(btrfs_free_space_cachep, info);
 	}
 }
 
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index d20db64..b5d13c4 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -1286,8 +1286,14 @@ next_slot:
 		num_bytes = 0;
 		btrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);
 
-		if (found_key.objectid > ino ||
-		    found_key.type > BTRFS_EXTENT_DATA_KEY ||
+		if (found_key.objectid > ino)
+			break;
+		if (WARN_ON_ONCE(found_key.objectid < ino) ||
+		    found_key.type < BTRFS_EXTENT_DATA_KEY) {
+			path->slots[0]++;
+			goto next_slot;
+		}
+		if (found_key.type > BTRFS_EXTENT_DATA_KEY ||
 		    found_key.offset > end)
 			break;
 
@@ -4650,7 +4656,8 @@ void btrfs_evict_inode(struct inode *inode)
 		goto no_delete;
 	}
 	/* do we really want it for ->i_nlink > 0 and zero btrfs_root_refs? */
-	btrfs_wait_ordered_range(inode, 0, (u64)-1);
+	if (!special_file(inode->i_mode))
+		btrfs_wait_ordered_range(inode, 0, (u64)-1);
 
 	if (root->fs_info->log_root_recovering) {
 		BUG_ON(test_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,
@@ -7470,15 +7477,28 @@ int btrfs_readpage(struct file *file, struct page *page)
 static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
 {
 	struct extent_io_tree *tree;
-
+	struct inode *inode = page->mapping->host;
+	int ret;
 
 	if (current->flags & PF_MEMALLOC) {
 		redirty_page_for_writepage(wbc, page);
 		unlock_page(page);
 		return 0;
 	}
+
+	/*
+	 * If we are under memory pressure we will call this directly from the
+	 * VM, we need to make sure we have the inode referenced for the ordered
+	 * extent.  If not just return like we didn't do anything.
+	 */
+	if (!igrab(inode)) {
+		redirty_page_for_writepage(wbc, page);
+		return AOP_WRITEPAGE_ACTIVATE;
+	}
 	tree = &BTRFS_I(page->mapping->host)->io_tree;
-	return extent_write_full_page(tree, page, btrfs_get_extent, wbc);
+	ret = extent_write_full_page(tree, page, btrfs_get_extent, wbc);
+	btrfs_add_delayed_iput(inode);
+	return ret;
 }
 
 static int btrfs_writepages(struct address_space *mapping,
@@ -8467,9 +8487,11 @@ static int btrfs_symlink(struct inode *dir, struct dentry *dentry,
 	/*
 	 * 2 items for inode item and ref
 	 * 2 items for dir items
+	 * 1 item for updating parent inode item
+	 * 1 item for the inline extent item
 	 * 1 item for xattr if selinux is on
 	 */
-	trans = btrfs_start_transaction(root, 5);
+	trans = btrfs_start_transaction(root, 7);
 	if (IS_ERR(trans))
 		return PTR_ERR(trans);
 
diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index 783906c..dbefa6c 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -2572,6 +2572,11 @@ static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,
 	if (off + len == src->i_size)
 		len = ALIGN(src->i_size, bs) - off;
 
+	if (len == 0) {
+		ret = 0;
+		goto out_unlock;
+	}
+
 	/* verify the end result is block aligned */
 	if (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||
 	    !IS_ALIGNED(destoff, bs))
diff --git a/fs/btrfs/send.c b/fs/btrfs/send.c
index 414c1b9..3104e0e 100644
--- a/fs/btrfs/send.c
+++ b/fs/btrfs/send.c
@@ -1338,7 +1338,21 @@ static int read_symlink(struct send_ctx *sctx,
 	ret = btrfs_search_slot(NULL, root, &key, path, 0, 0);
 	if (ret < 0)
 		goto out;
-	BUG_ON(ret);
+	if (ret) {
+		/*
+		 * An empty symlink inode. Can happen in rare error paths when
+		 * creating a symlink (transaction committed before the inode
+		 * eviction handler removed the symlink inode items and a crash
+		 * happened in between or the subvol was snapshoted in between).
+		 * Print an informative message to dmesg/syslog so that the user
+		 * can delete the symlink.
+		 */
+		btrfs_err(root->fs_info,
+			  "Found empty symlink inode %llu at root %llu",
+			  ino, root->root_key.objectid);
+		ret = -EIO;
+		goto out;
+	}
 
 	ei = btrfs_item_ptr(path->nodes[0], path->slots[0],
 			struct btrfs_file_extent_item);
diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index f0857e0..68891ff 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -779,6 +779,15 @@ find_root:
 	if (btrfs_root_refs(&new_root->root_item) == 0)
 		return ERR_PTR(-ENOENT);
 
+	if (!(sb->s_flags & MS_RDONLY)) {
+		int ret;
+		down_read(&fs_info->cleanup_work_sem);
+		ret = btrfs_orphan_cleanup(new_root);
+		up_read(&fs_info->cleanup_work_sem);
+		if (ret)
+			return ERR_PTR(ret);
+	}
+
 	dir_id = btrfs_root_dirid(&new_root->root_item);
 setup_root:
 	location.objectid = dir_id;
diff --git a/fs/btrfs/xattr.c b/fs/btrfs/xattr.c
index 05740b9..9cf20d6 100644
--- a/fs/btrfs/xattr.c
+++ b/fs/btrfs/xattr.c
@@ -27,6 +27,7 @@
 #include "transaction.h"
 #include "xattr.h"
 #include "disk-io.h"
+#include "locking.h"
 
 
 ssize_t __btrfs_getxattr(struct inode *inode, const char *name,
@@ -89,7 +90,7 @@ static int do_setxattr(struct btrfs_trans_handle *trans,
 		       struct inode *inode, const char *name,
 		       const void *value, size_t size, int flags)
 {
-	struct btrfs_dir_item *di;
+	struct btrfs_dir_item *di = NULL;
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 	struct btrfs_path *path;
 	size_t name_len = strlen(name);
@@ -101,84 +102,128 @@ static int do_setxattr(struct btrfs_trans_handle *trans,
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
+	path->skip_release_on_error = 1;
+
+	if (!value) {
+		di = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),
+					name, name_len, -1);
+		if (!di && (flags & XATTR_REPLACE))
+			ret = -ENODATA;
+		else if (di)
+			ret = btrfs_delete_one_dir_name(trans, root, path, di);
+		goto out;
+	}
 
+	/*
+	 * For a replace we can't just do the insert blindly.
+	 * Do a lookup first (read-only btrfs_search_slot), and return if xattr
+	 * doesn't exist. If it exists, fall down below to the insert/replace
+	 * path - we can't race with a concurrent xattr delete, because the VFS
+	 * locks the inode's i_mutex before calling setxattr or removexattr.
+	 */
 	if (flags & XATTR_REPLACE) {
-		di = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode), name,
-					name_len, -1);
-		if (IS_ERR(di)) {
-			ret = PTR_ERR(di);
-			goto out;
-		} else if (!di) {
+		if(!mutex_is_locked(&inode->i_mutex)) {
+			pr_err("BTRFS: assertion failed: %s, file: %s, line: %d",
+			       "mutex_is_locked(&inode->i_mutex)", __FILE__,
+			       __LINE__);
+			BUG();
+		}
+		di = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),
+					name, name_len, 0);
+		if (!di) {
 			ret = -ENODATA;
 			goto out;
 		}
-		ret = btrfs_delete_one_dir_name(trans, root, path, di);
-		if (ret)
-			goto out;
 		btrfs_release_path(path);
+		di = NULL;
+	}
 
+	ret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),
+				      name, name_len, value, size);
+	if (ret == -EOVERFLOW) {
 		/*
-		 * remove the attribute
+		 * We have an existing item in a leaf, split_leaf couldn't
+		 * expand it. That item might have or not a dir_item that
+		 * matches our target xattr, so lets check.
 		 */
-		if (!value)
-			goto out;
-	} else {
-		di = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),
-					name, name_len, 0);
-		if (IS_ERR(di)) {
-			ret = PTR_ERR(di);
+		ret = 0;
+		btrfs_assert_tree_locked(path->nodes[0]);
+		di = btrfs_match_dir_item_name(root, path, name, name_len);
+		if (!di && !(flags & XATTR_REPLACE)) {
+			ret = -ENOSPC;
 			goto out;
 		}
-		if (!di && !value)
-			goto out;
-		btrfs_release_path(path);
+	} else if (ret == -EEXIST) {
+		ret = 0;
+		di = btrfs_match_dir_item_name(root, path, name, name_len);
+		if(!di) { /* logic error */
+			pr_err("BTRFS: assertion failed: %s, file: %s, line: %d",
+			       "di", __FILE__, __LINE__);
+			BUG();
+		}
+	} else if (ret) {
+		goto out;
 	}
 
-again:
-	ret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),
-				      name, name_len, value, size);
-	/*
-	 * If we're setting an xattr to a new value but the new value is say
-	 * exactly BTRFS_MAX_XATTR_SIZE, we could end up with EOVERFLOW getting
-	 * back from split_leaf.  This is because it thinks we'll be extending
-	 * the existing item size, but we're asking for enough space to add the
-	 * item itself.  So if we get EOVERFLOW just set ret to EEXIST and let
-	 * the rest of the function figure it out.
-	 */
-	if (ret == -EOVERFLOW)
+	if (di && (flags & XATTR_CREATE)) {
 		ret = -EEXIST;
+		goto out;
+	}
 
-	if (ret == -EEXIST) {
-		if (flags & XATTR_CREATE)
-			goto out;
+	if (di) {
 		/*
-		 * We can't use the path we already have since we won't have the
-		 * proper locking for a delete, so release the path and
-		 * re-lookup to delete the thing.
+		 * We're doing a replace, and it must be atomic, that is, at
+		 * any point in time we have either the old or the new xattr
+		 * value in the tree. We don't want readers (getxattr and
+		 * listxattrs) to miss a value, this is specially important
+		 * for ACLs.
 		 */
-		btrfs_release_path(path);
-		di = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),
-					name, name_len, -1);
-		if (IS_ERR(di)) {
-			ret = PTR_ERR(di);
-			goto out;
-		} else if (!di) {
-			/* Shouldn't happen but just in case... */
-			btrfs_release_path(path);
-			goto again;
+		const int slot = path->slots[0];
+		struct extent_buffer *leaf = path->nodes[0];
+		const u16 old_data_len = btrfs_dir_data_len(leaf, di);
+		const u32 item_size = btrfs_item_size_nr(leaf, slot);
+		const u32 data_size = sizeof(*di) + name_len + size;
+		struct btrfs_item *item;
+		unsigned long data_ptr;
+		char *ptr;
+
+		if (size > old_data_len) {
+			if (btrfs_leaf_free_space(root, leaf) <
+			    (size - old_data_len)) {
+				ret = -ENOSPC;
+				goto out;
+			}
 		}
 
-		ret = btrfs_delete_one_dir_name(trans, root, path, di);
-		if (ret)
-			goto out;
+		if (old_data_len + name_len + sizeof(*di) == item_size) {
+			/* No other xattrs packed in the same leaf item. */
+			if (size > old_data_len)
+				btrfs_extend_item(root, path,
+						  size - old_data_len);
+			else if (size < old_data_len)
+				btrfs_truncate_item(root, path, data_size, 1);
+		} else {
+			/* There are other xattrs packed in the same item. */
+			ret = btrfs_delete_one_dir_name(trans, root, path, di);
+			if (ret)
+				goto out;
+			btrfs_extend_item(root, path, data_size);
+		}
 
+		item = btrfs_item_nr(NULL, slot);
+		ptr = btrfs_item_ptr(leaf, slot, char);
+		ptr += btrfs_item_size(leaf, item) - data_size;
+		di = (struct btrfs_dir_item *)ptr;
+		btrfs_set_dir_data_len(leaf, di, size);
+		data_ptr = ((unsigned long)(di + 1)) + name_len;
+		write_extent_buffer(leaf, value, data_ptr, size);
+		btrfs_mark_buffer_dirty(leaf);
+	} else {
 		/*
-		 * We have a value to set, so go back and try to insert it now.
+		 * Insert, and we had space for the xattr, so path->slots[0] is
+		 * where our xattr dir_item is and btrfs_insert_xattr_item()
+		 * filled it.
 		 */
-		if (value) {
-			btrfs_release_path(path);
-			goto again;
-		}
 	}
 out:
 	btrfs_free_path(path);
diff --git a/fs/ceph/dir.c b/fs/ceph/dir.c
index f02d82b..ccb4329 100644
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@ -103,7 +103,7 @@ static unsigned fpos_off(loff_t p)
 /*
  * When possible, we try to satisfy a readdir by peeking at the
  * dcache.  We make this work by carefully ordering dentries on
- * d_u.d_child when we initially get results back from the MDS, and
+ * d_child when we initially get results back from the MDS, and
  * falling back to a "normal" sync readdir if any dentries in the dir
  * are dropped.
  *
@@ -139,11 +139,11 @@ static int __dcache_readdir(struct file *filp,
 		p = parent->d_subdirs.prev;
 		dout(" initial p %p/%p\n", p->prev, p->next);
 	} else {
-		p = last->d_u.d_child.prev;
+		p = last->d_child.prev;
 	}
 
 more:
-	dentry = list_entry(p, struct dentry, d_u.d_child);
+	dentry = list_entry(p, struct dentry, d_child);
 	di = ceph_dentry(dentry);
 	while (1) {
 		dout(" p %p/%p %s d_subdirs %p/%p\n", p->prev, p->next,
@@ -165,7 +165,7 @@ more:
 		     !dentry->d_inode ? " null" : "");
 		spin_unlock(&dentry->d_lock);
 		p = p->prev;
-		dentry = list_entry(p, struct dentry, d_u.d_child);
+		dentry = list_entry(p, struct dentry, d_child);
 		di = ceph_dentry(dentry);
 	}
 
diff --git a/fs/ceph/inode.c b/fs/ceph/inode.c
index be0f7e2..0cf23a7 100644
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@ -867,9 +867,9 @@ static void ceph_set_dentry_offset(struct dentry *dn)
 
 	spin_lock(&dir->d_lock);
 	spin_lock_nested(&dn->d_lock, DENTRY_D_LOCK_NESTED);
-	list_move(&dn->d_u.d_child, &dir->d_subdirs);
+	list_move(&dn->d_child, &dir->d_subdirs);
 	dout("set_dentry_offset %p %lld (%p %p)\n", dn, di->offset,
-	     dn->d_u.d_child.prev, dn->d_u.d_child.next);
+	     dn->d_child.prev, dn->d_child.next);
 	spin_unlock(&dn->d_lock);
 	spin_unlock(&dir->d_lock);
 }
@@ -1296,7 +1296,7 @@ retry_lookup:
 			/* reorder parent's d_subdirs */
 			spin_lock(&parent->d_lock);
 			spin_lock_nested(&dn->d_lock, DENTRY_D_LOCK_NESTED);
-			list_move(&dn->d_u.d_child, &parent->d_subdirs);
+			list_move(&dn->d_child, &parent->d_subdirs);
 			spin_unlock(&dn->d_lock);
 			spin_unlock(&parent->d_lock);
 		}
diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c
index 5c807b2..182e82f 100644
--- a/fs/cifs/cifsencrypt.c
+++ b/fs/cifs/cifsencrypt.c
@@ -591,7 +591,7 @@ setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)
 
 	ses->auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);
 	if (!ses->auth_key.response) {
-		rc = ENOMEM;
+		rc = -ENOMEM;
 		ses->auth_key.len = 0;
 		goto setup_ntlmv2_rsp_ret;
 	}
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index d17c5d7..4c86850 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -1389,11 +1389,10 @@ openRetry:
  * current bigbuf.
  */
 static int
-cifs_readv_discard(struct TCP_Server_Info *server, struct mid_q_entry *mid)
+discard_remaining_data(struct TCP_Server_Info *server)
 {
 	unsigned int rfclen = get_rfc1002_length(server->smallbuf);
 	int remaining = rfclen + 4 - server->total_read;
-	struct cifs_readdata *rdata = mid->callback_data;
 
 	while (remaining > 0) {
 		int length;
@@ -1407,10 +1406,20 @@ cifs_readv_discard(struct TCP_Server_Info *server, struct mid_q_entry *mid)
 		remaining -= length;
 	}
 
-	dequeue_mid(mid, rdata->result);
 	return 0;
 }
 
+static int
+cifs_readv_discard(struct TCP_Server_Info *server, struct mid_q_entry *mid)
+{
+	int length;
+	struct cifs_readdata *rdata = mid->callback_data;
+
+	length = discard_remaining_data(server);
+	dequeue_mid(mid, rdata->result);
+	return length;
+}
+
 int
 cifs_readv_receive(struct TCP_Server_Info *server, struct mid_q_entry *mid)
 {
@@ -1439,6 +1448,12 @@ cifs_readv_receive(struct TCP_Server_Info *server, struct mid_q_entry *mid)
 		return length;
 	server->total_read += length;
 
+	if (server->ops->is_status_pending &&
+	    server->ops->is_status_pending(buf, server, 0)) {
+		discard_remaining_data(server);
+		return -1;
+	}
+
 	/* Was the SMB read successful? */
 	rdata->result = server->ops->map_error(buf, false);
 	if (rdata->result != 0) {
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index d05a300..7c33afd 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -408,7 +408,9 @@ cifs_echo_request(struct work_struct *work)
 	 * server->ops->need_neg() == true. Also, no need to ping if
 	 * we got a response recently.
 	 */
-	if (!server->ops->need_neg || server->ops->need_neg(server) ||
+
+	if (server->tcpStatus == CifsNeedReconnect ||
+	    server->tcpStatus == CifsExiting || server->tcpStatus == CifsNew ||
 	    (server->ops->can_echo && !server->ops->can_echo(server)) ||
 	    time_before(jiffies, server->lstrp + SMB_ECHO_INTERVAL - HZ))
 		goto requeue_echo;
diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c
index 0c2425b..a998c92 100644
--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@ -227,6 +227,13 @@ cifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,
 				goto cifs_create_get_file_info;
 			}
 
+			if (S_ISDIR(newinode->i_mode)) {
+				CIFSSMBClose(xid, tcon, fid->netfid);
+				iput(newinode);
+				rc = -EISDIR;
+				goto out;
+			}
+
 			if (!S_ISREG(newinode->i_mode)) {
 				/*
 				 * The server may allow us to open things like
@@ -391,10 +398,14 @@ cifs_create_set_dentry:
 	if (rc != 0) {
 		cifs_dbg(FYI, "Create worked, get_inode_info failed rc = %d\n",
 			 rc);
-		if (server->ops->close)
-			server->ops->close(xid, tcon, fid);
-		goto out;
+		goto out_err;
 	}
+
+	if (S_ISDIR(newinode->i_mode)) {
+		rc = -EISDIR;
+		goto out_err;
+	}
+
 	d_drop(direntry);
 	d_add(direntry, newinode);
 
@@ -402,6 +413,13 @@ out:
 	kfree(buf);
 	kfree(full_path);
 	return rc;
+
+out_err:
+	if (server->ops->close)
+		server->ops->close(xid, tcon, fid);
+	if (newinode)
+		iput(newinode);
+	goto out;
 }
 
 int
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index 5fcc10f..f4a8577 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -1789,6 +1789,7 @@ refind_writable:
 			cifsFileInfo_put(inv_file);
 			spin_lock(&cifs_file_list_lock);
 			++refind;
+			inv_file = NULL;
 			goto refind_writable;
 		}
 	}
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index 0dee937..54304cc 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -832,7 +832,7 @@ inode_has_hashed_dentries(struct inode *inode)
 	struct dentry *dentry;
 
 	spin_lock(&inode->i_lock);
-	hlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {
+	hlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {
 		if (!d_unhashed(dentry) || IS_ROOT(dentry)) {
 			spin_unlock(&inode->i_lock);
 			return true;
diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c
index 8edc9eb..d65e16e 100644
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@ -487,19 +487,27 @@ int build_ntlmssp_auth_blob(unsigned char *pbuffer,
 	sec_blob->LmChallengeResponse.MaximumLength = 0;
 
 	sec_blob->NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);
-	rc = setup_ntlmv2_rsp(ses, nls_cp);
-	if (rc) {
-		cifs_dbg(VFS, "Error %d during NTLMSSP authentication\n", rc);
-		goto setup_ntlmv2_ret;
-	}
-	memcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,
-			ses->auth_key.len - CIFS_SESS_KEY_SIZE);
-	tmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;
+	if (ses->user_name != NULL) {
+		rc = setup_ntlmv2_rsp(ses, nls_cp);
+		if (rc) {
+			cifs_dbg(VFS, "Error %d during NTLMSSP authentication\n", rc);
+			goto setup_ntlmv2_ret;
+		}
+		memcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,
+				ses->auth_key.len - CIFS_SESS_KEY_SIZE);
+		tmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;
 
-	sec_blob->NtChallengeResponse.Length =
-			cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
-	sec_blob->NtChallengeResponse.MaximumLength =
-			cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
+		sec_blob->NtChallengeResponse.Length =
+				cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
+		sec_blob->NtChallengeResponse.MaximumLength =
+				cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
+	} else {
+		/*
+		 * don't send an NT Response for anonymous access
+		 */
+		sec_blob->NtChallengeResponse.Length = 0;
+		sec_blob->NtChallengeResponse.MaximumLength = 0;
+	}
 
 	if (ses->domainName == NULL) {
 		sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);
diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c
index e12f258..66202da 100644
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@ -48,9 +48,13 @@ change_conf(struct TCP_Server_Info *server)
 		break;
 	default:
 		server->echoes = true;
-		server->oplocks = true;
+		if (enable_oplocks) {
+			server->oplocks = true;
+			server->oplock_credits = 1;
+		} else
+			server->oplocks = false;
+
 		server->echo_credits = 1;
-		server->oplock_credits = 1;
 	}
 	server->credits -= server->echo_credits + server->oplock_credits;
 	return 0;
diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c
index eb0de4c..9dd8c96 100644
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@ -1250,6 +1250,33 @@ SMB2_echo(struct TCP_Server_Info *server)
 
 	cifs_dbg(FYI, "In echo request\n");
 
+	if (server->tcpStatus == CifsNeedNegotiate) {
+		struct list_head *tmp, *tmp2;
+		struct cifs_ses *ses;
+		struct cifs_tcon *tcon;
+
+		cifs_dbg(FYI, "Need negotiate, reconnecting tcons\n");
+		spin_lock(&cifs_tcp_ses_lock);
+		list_for_each(tmp, &server->smb_ses_list) {
+			ses = list_entry(tmp, struct cifs_ses, smb_ses_list);
+			list_for_each(tmp2, &ses->tcon_list) {
+				tcon = list_entry(tmp2, struct cifs_tcon,
+						  tcon_list);
+				/* add check for persistent handle reconnect */
+				if (tcon && tcon->need_reconnect) {
+					spin_unlock(&cifs_tcp_ses_lock);
+					rc = smb2_reconnect(SMB2_ECHO, tcon);
+					spin_lock(&cifs_tcp_ses_lock);
+				}
+			}
+		}
+		spin_unlock(&cifs_tcp_ses_lock);
+	}
+
+	/* if no session, renegotiate failed above */
+	if (server->tcpStatus == CifsNeedNegotiate)
+		return -EIO;
+
 	rc = small_smb2_init(SMB2_ECHO, NULL, (void **)&req);
 	if (rc)
 		return rc;
diff --git a/fs/coda/cache.c b/fs/coda/cache.c
index 1da168c..9bc1147 100644
--- a/fs/coda/cache.c
+++ b/fs/coda/cache.c
@@ -92,7 +92,7 @@ static void coda_flag_children(struct dentry *parent, int flag)
 	struct dentry *de;
 
 	spin_lock(&parent->d_lock);
-	list_for_each_entry(de, &parent->d_subdirs, d_u.d_child) {
+	list_for_each_entry(de, &parent->d_subdirs, d_child) {
 		/* don't know what to do with negative dentries */
 		if (de->d_inode ) 
 			coda_flag_inode(de->d_inode, flag);
diff --git a/fs/coredump.c b/fs/coredump.c
index 1d402ce..4f03b2b 100644
--- a/fs/coredump.c
+++ b/fs/coredump.c
@@ -491,10 +491,10 @@ void do_coredump(siginfo_t *siginfo)
 	const struct cred *old_cred;
 	struct cred *cred;
 	int retval = 0;
-	int flag = 0;
 	int ispipe;
 	struct files_struct *displaced;
-	bool need_nonrelative = false;
+	/* require nonrelative corefile path and be extra careful */
+	bool need_suid_safe = false;
 	bool core_dumped = false;
 	static atomic_t core_dump_count = ATOMIC_INIT(0);
 	struct coredump_params cprm = {
@@ -528,9 +528,8 @@ void do_coredump(siginfo_t *siginfo)
 	 */
 	if (__get_dumpable(cprm.mm_flags) == SUID_DUMP_ROOT) {
 		/* Setuid core dump mode */
-		flag = O_EXCL;		/* Stop rewrite attacks */
 		cred->fsuid = GLOBAL_ROOT_UID;	/* Dump root private */
-		need_nonrelative = true;
+		need_suid_safe = true;
 	}
 
 	retval = coredump_wait(siginfo->si_signo, &core_state);
@@ -611,7 +610,7 @@ void do_coredump(siginfo_t *siginfo)
 		if (cprm.limit < binfmt->min_coredump)
 			goto fail_unlock;
 
-		if (need_nonrelative && cn.corename[0] != '/') {
+		if (need_suid_safe && cn.corename[0] != '/') {
 			printk(KERN_WARNING "Pid %d(%s) can only dump core "\
 				"to fully qualified path!\n",
 				task_tgid_vnr(current), current->comm);
@@ -619,8 +618,35 @@ void do_coredump(siginfo_t *siginfo)
 			goto fail_unlock;
 		}
 
+		/*
+		 * Unlink the file if it exists unless this is a SUID
+		 * binary - in that case, we're running around with root
+		 * privs and don't want to unlink another user's coredump.
+		 */
+		if (!need_suid_safe) {
+			mm_segment_t old_fs;
+
+			old_fs = get_fs();
+			set_fs(KERNEL_DS);
+			/*
+			 * If it doesn't exist, that's fine. If there's some
+			 * other problem, we'll catch it at the filp_open().
+			 */
+			(void) sys_unlink((const char __user *)cn.corename);
+			set_fs(old_fs);
+		}
+
+		/*
+		 * There is a race between unlinking and creating the
+		 * file, but if that causes an EEXIST here, that's
+		 * fine - another process raced with us while creating
+		 * the corefile, and the other process won. To userspace,
+		 * what matters is that at least one of the two processes
+		 * writes its coredump successfully, not which one.
+		 */
 		cprm.file = filp_open(cn.corename,
-				 O_CREAT | 2 | O_NOFOLLOW | O_LARGEFILE | flag,
+				 O_CREAT | 2 | O_NOFOLLOW |
+				 O_LARGEFILE | O_EXCL,
 				 0600);
 		if (IS_ERR(cprm.file))
 			goto fail_unlock;
diff --git a/fs/dcache.c b/fs/dcache.c
index 25c0a1b..2d0b9d2 100644
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -43,7 +43,7 @@
 /*
  * Usage:
  * dcache->d_inode->i_lock protects:
- *   - i_dentry, d_alias, d_inode of aliases
+ *   - i_dentry, d_u.d_alias, d_inode of aliases
  * dcache_hash_bucket lock protects:
  *   - the dcache hash table
  * s_anon bl list spinlock protects:
@@ -58,7 +58,7 @@
  *   - d_unhashed()
  *   - d_parent and d_subdirs
  *   - childrens' d_child and d_parent
- *   - d_alias, d_inode
+ *   - d_u.d_alias, d_inode
  *
  * Ordering:
  * dentry->d_inode->i_lock
@@ -215,7 +215,6 @@ static void __d_free(struct rcu_head *head)
 {
 	struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);
 
-	WARN_ON(!hlist_unhashed(&dentry->d_alias));
 	if (dname_external(dentry))
 		kfree(dentry->d_name.name);
 	kmem_cache_free(dentry_cache, dentry); 
@@ -226,6 +225,7 @@ static void __d_free(struct rcu_head *head)
  */
 static void d_free(struct dentry *dentry)
 {
+	WARN_ON(!hlist_unhashed(&dentry->d_u.d_alias));
 	BUG_ON(dentry->d_count);
 	this_cpu_dec(nr_dentry);
 	if (dentry->d_op && dentry->d_op->d_release)
@@ -264,7 +264,7 @@ static void dentry_iput(struct dentry * dentry)
 	struct inode *inode = dentry->d_inode;
 	if (inode) {
 		dentry->d_inode = NULL;
-		hlist_del_init(&dentry->d_alias);
+		hlist_del_init(&dentry->d_u.d_alias);
 		spin_unlock(&dentry->d_lock);
 		spin_unlock(&inode->i_lock);
 		if (!inode->i_nlink)
@@ -288,7 +288,7 @@ static void dentry_unlink_inode(struct dentry * dentry)
 {
 	struct inode *inode = dentry->d_inode;
 	dentry->d_inode = NULL;
-	hlist_del_init(&dentry->d_alias);
+	hlist_del_init(&dentry->d_u.d_alias);
 	dentry_rcuwalk_barrier(dentry);
 	spin_unlock(&dentry->d_lock);
 	spin_unlock(&inode->i_lock);
@@ -364,9 +364,9 @@ static struct dentry *d_kill(struct dentry *dentry, struct dentry *parent)
 	__releases(parent->d_lock)
 	__releases(dentry->d_inode->i_lock)
 {
-	list_del(&dentry->d_u.d_child);
+	__list_del_entry(&dentry->d_child);
 	/*
-	 * Inform try_to_ascend() that we are no longer attached to the
+	 * Inform ascending readers that we are no longer attached to the
 	 * dentry tree
 	 */
 	dentry->d_flags |= DCACHE_DENTRY_KILLED;
@@ -520,6 +520,9 @@ repeat:
 		return;
 	}
 
+	if (unlikely(dentry->d_flags & DCACHE_DISCONNECTED))
+		goto kill_it;
+
 	if (dentry->d_flags & DCACHE_OP_DELETE) {
 		if (dentry->d_op->d_delete(dentry))
 			goto kill_it;
@@ -660,7 +663,7 @@ static struct dentry *__d_find_alias(struct inode *inode, int want_discon)
 
 again:
 	discon_alias = NULL;
-	hlist_for_each_entry(alias, &inode->i_dentry, d_alias) {
+	hlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {
 		spin_lock(&alias->d_lock);
  		if (S_ISDIR(inode->i_mode) || !d_unhashed(alias)) {
 			if (IS_ROOT(alias) &&
@@ -713,7 +716,7 @@ void d_prune_aliases(struct inode *inode)
 	struct dentry *dentry;
 restart:
 	spin_lock(&inode->i_lock);
-	hlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {
+	hlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {
 		spin_lock(&dentry->d_lock);
 		if (!dentry->d_count) {
 			__dget_dlock(dentry);
@@ -893,7 +896,7 @@ static void shrink_dcache_for_umount_subtree(struct dentry *dentry)
 		/* descend to the first leaf in the current subtree */
 		while (!list_empty(&dentry->d_subdirs))
 			dentry = list_entry(dentry->d_subdirs.next,
-					    struct dentry, d_u.d_child);
+					    struct dentry, d_child);
 
 		/* consume the dentries from this leaf up through its parents
 		 * until we find one with children or run out altogether */
@@ -927,17 +930,17 @@ static void shrink_dcache_for_umount_subtree(struct dentry *dentry)
 
 			if (IS_ROOT(dentry)) {
 				parent = NULL;
-				list_del(&dentry->d_u.d_child);
+				list_del(&dentry->d_child);
 			} else {
 				parent = dentry->d_parent;
 				parent->d_count--;
-				list_del(&dentry->d_u.d_child);
+				list_del(&dentry->d_child);
 			}
 
 			inode = dentry->d_inode;
 			if (inode) {
 				dentry->d_inode = NULL;
-				hlist_del_init(&dentry->d_alias);
+				hlist_del_init(&dentry->d_u.d_alias);
 				if (dentry->d_op && dentry->d_op->d_iput)
 					dentry->d_op->d_iput(dentry, inode);
 				else
@@ -955,7 +958,7 @@ static void shrink_dcache_for_umount_subtree(struct dentry *dentry)
 		} while (list_empty(&dentry->d_subdirs));
 
 		dentry = list_entry(dentry->d_subdirs.next,
-				    struct dentry, d_u.d_child);
+				    struct dentry, d_child);
 	}
 }
 
@@ -988,35 +991,6 @@ void shrink_dcache_for_umount(struct super_block *sb)
 }
 
 /*
- * This tries to ascend one level of parenthood, but
- * we can race with renaming, so we need to re-check
- * the parenthood after dropping the lock and check
- * that the sequence number still matches.
- */
-static struct dentry *try_to_ascend(struct dentry *old, int locked, unsigned seq)
-{
-	struct dentry *new = old->d_parent;
-
-	rcu_read_lock();
-	spin_unlock(&old->d_lock);
-	spin_lock(&new->d_lock);
-
-	/*
-	 * might go back up the wrong parent if we have had a rename
-	 * or deletion
-	 */
-	if (new != old->d_parent ||
-		 (old->d_flags & DCACHE_DENTRY_KILLED) ||
-		 (!locked && read_seqretry(&rename_lock, seq))) {
-		spin_unlock(&new->d_lock);
-		new = NULL;
-	}
-	rcu_read_unlock();
-	return new;
-}
-
-
-/*
  * Search for at least 1 mount point in the dentry's subdirs.
  * We descend to the next level whenever the d_subdirs
  * list is non-empty and continue searching.
@@ -1048,7 +1022,7 @@ repeat:
 resume:
 	while (next != &this_parent->d_subdirs) {
 		struct list_head *tmp = next;
-		struct dentry *dentry = list_entry(tmp, struct dentry, d_u.d_child);
+		struct dentry *dentry = list_entry(tmp, struct dentry, d_child);
 		next = tmp->next;
 
 		spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
@@ -1070,30 +1044,48 @@ resume:
 	/*
 	 * All done at this level ... ascend and resume the search.
 	 */
+	rcu_read_lock();
+ascend:
 	if (this_parent != parent) {
 		struct dentry *child = this_parent;
-		this_parent = try_to_ascend(this_parent, locked, seq);
-		if (!this_parent)
+		this_parent = child->d_parent;
+
+		spin_unlock(&child->d_lock);
+		spin_lock(&this_parent->d_lock);
+
+		/* might go back up the wrong parent if we have had a rename. */
+		if (!locked && read_seqretry(&rename_lock, seq))
 			goto rename_retry;
-		next = child->d_u.d_child.next;
+		/* go into the first sibling still alive */
+		do {
+			next = child->d_child.next;
+			if (next == &this_parent->d_subdirs)
+				goto ascend;
+			child = list_entry(next, struct dentry, d_child);
+		} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));
+		rcu_read_unlock();
 		goto resume;
 	}
-	spin_unlock(&this_parent->d_lock);
 	if (!locked && read_seqretry(&rename_lock, seq))
 		goto rename_retry;
+	spin_unlock(&this_parent->d_lock);
+	rcu_read_unlock();
 	if (locked)
 		write_sequnlock(&rename_lock);
 	return 0; /* No mount points found in tree */
 positive:
 	if (!locked && read_seqretry(&rename_lock, seq))
-		goto rename_retry;
+		goto rename_retry_unlocked;
 	if (locked)
 		write_sequnlock(&rename_lock);
 	return 1;
 
 rename_retry:
+	spin_unlock(&this_parent->d_lock);
+	rcu_read_unlock();
 	if (locked)
 		goto again;
+rename_retry_unlocked:
 	locked = 1;
 	write_seqlock(&rename_lock);
 	goto again;
@@ -1131,7 +1123,7 @@ repeat:
 resume:
 	while (next != &this_parent->d_subdirs) {
 		struct list_head *tmp = next;
-		struct dentry *dentry = list_entry(tmp, struct dentry, d_u.d_child);
+		struct dentry *dentry = list_entry(tmp, struct dentry, d_child);
 		next = tmp->next;
 
 		spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
@@ -1158,6 +1150,7 @@ resume:
 		 */
 		if (found && need_resched()) {
 			spin_unlock(&dentry->d_lock);
+			rcu_read_lock();
 			goto out;
 		}
 
@@ -1177,23 +1170,40 @@ resume:
 	/*
 	 * All done at this level ... ascend and resume the search.
 	 */
+	rcu_read_lock();
+ascend:
 	if (this_parent != parent) {
 		struct dentry *child = this_parent;
-		this_parent = try_to_ascend(this_parent, locked, seq);
-		if (!this_parent)
+		this_parent = child->d_parent;
+
+		spin_unlock(&child->d_lock);
+		spin_lock(&this_parent->d_lock);
+
+		/* might go back up the wrong parent if we have had a rename. */
+		if (!locked && read_seqretry(&rename_lock, seq))
 			goto rename_retry;
-		next = child->d_u.d_child.next;
+		/* go into the first sibling still alive */
+		do {
+			next = child->d_child.next;
+			if (next == &this_parent->d_subdirs)
+				goto ascend;
+			child = list_entry(next, struct dentry, d_child);
+		} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));
+		rcu_read_unlock();
 		goto resume;
 	}
 out:
-	spin_unlock(&this_parent->d_lock);
 	if (!locked && read_seqretry(&rename_lock, seq))
 		goto rename_retry;
+	spin_unlock(&this_parent->d_lock);
+	rcu_read_unlock();
 	if (locked)
 		write_sequnlock(&rename_lock);
 	return found;
 
 rename_retry:
+	spin_unlock(&this_parent->d_lock);
+	rcu_read_unlock();
 	if (found)
 		return found;
 	if (locked)
@@ -1278,8 +1288,8 @@ struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)
 	INIT_HLIST_BL_NODE(&dentry->d_hash);
 	INIT_LIST_HEAD(&dentry->d_lru);
 	INIT_LIST_HEAD(&dentry->d_subdirs);
-	INIT_HLIST_NODE(&dentry->d_alias);
-	INIT_LIST_HEAD(&dentry->d_u.d_child);
+	INIT_HLIST_NODE(&dentry->d_u.d_alias);
+	INIT_LIST_HEAD(&dentry->d_child);
 	d_set_d_op(dentry, dentry->d_sb->s_d_op);
 
 	this_cpu_inc(nr_dentry);
@@ -1301,7 +1311,7 @@ struct dentry *d_alloc(struct dentry * parent, const struct qstr *name)
 	struct dentry *dentry = __d_alloc(parent->d_sb, name);
 	if (!dentry)
 		return NULL;
-
+	dentry->d_flags |= DCACHE_RCUACCESS;
 	spin_lock(&parent->d_lock);
 	/*
 	 * don't need child lock because it is not subject
@@ -1309,7 +1319,7 @@ struct dentry *d_alloc(struct dentry * parent, const struct qstr *name)
 	 */
 	__dget_dlock(parent);
 	dentry->d_parent = parent;
-	list_add(&dentry->d_u.d_child, &parent->d_subdirs);
+	list_add(&dentry->d_child, &parent->d_subdirs);
 	spin_unlock(&parent->d_lock);
 
 	return dentry;
@@ -1369,7 +1379,7 @@ static void __d_instantiate(struct dentry *dentry, struct inode *inode)
 	if (inode) {
 		if (unlikely(IS_AUTOMOUNT(inode)))
 			dentry->d_flags |= DCACHE_NEED_AUTOMOUNT;
-		hlist_add_head(&dentry->d_alias, &inode->i_dentry);
+		hlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);
 	}
 	dentry->d_inode = inode;
 	dentry_rcuwalk_barrier(dentry);
@@ -1394,7 +1404,7 @@ static void __d_instantiate(struct dentry *dentry, struct inode *inode)
  
 void d_instantiate(struct dentry *entry, struct inode * inode)
 {
-	BUG_ON(!hlist_unhashed(&entry->d_alias));
+	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
 	if (inode)
 		spin_lock(&inode->i_lock);
 	__d_instantiate(entry, inode);
@@ -1433,7 +1443,7 @@ static struct dentry *__d_instantiate_unique(struct dentry *entry,
 		return NULL;
 	}
 
-	hlist_for_each_entry(alias, &inode->i_dentry, d_alias) {
+	hlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {
 		/*
 		 * Don't need alias->d_lock here, because aliases with
 		 * d_parent == entry->d_parent are not subject to name or
@@ -1459,7 +1469,7 @@ struct dentry *d_instantiate_unique(struct dentry *entry, struct inode *inode)
 {
 	struct dentry *result;
 
-	BUG_ON(!hlist_unhashed(&entry->d_alias));
+	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
 
 	if (inode)
 		spin_lock(&inode->i_lock);
@@ -1502,7 +1512,7 @@ static struct dentry * __d_find_any_alias(struct inode *inode)
 
 	if (hlist_empty(&inode->i_dentry))
 		return NULL;
-	alias = hlist_entry(inode->i_dentry.first, struct dentry, d_alias);
+	alias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);
 	__dget(alias);
 	return alias;
 }
@@ -1576,7 +1586,7 @@ struct dentry *d_obtain_alias(struct inode *inode)
 	spin_lock(&tmp->d_lock);
 	tmp->d_inode = inode;
 	tmp->d_flags |= DCACHE_DISCONNECTED;
-	hlist_add_head(&tmp->d_alias, &inode->i_dentry);
+	hlist_add_head(&tmp->d_u.d_alias, &inode->i_dentry);
 	hlist_bl_lock(&tmp->d_sb->s_anon);
 	hlist_bl_add_head(&tmp->d_hash, &tmp->d_sb->s_anon);
 	hlist_bl_unlock(&tmp->d_sb->s_anon);
@@ -2019,7 +2029,7 @@ int d_validate(struct dentry *dentry, struct dentry *dparent)
 	struct dentry *child;
 
 	spin_lock(&dparent->d_lock);
-	list_for_each_entry(child, &dparent->d_subdirs, d_u.d_child) {
+	list_for_each_entry(child, &dparent->d_subdirs, d_child) {
 		if (dentry == child) {
 			spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
 			__dget_dlock(dentry);
@@ -2091,7 +2101,6 @@ static void __d_rehash(struct dentry * entry, struct hlist_bl_head *b)
 {
 	BUG_ON(!d_unhashed(entry));
 	hlist_bl_lock(b);
-	entry->d_flags |= DCACHE_RCUACCESS;
 	hlist_bl_add_head_rcu(&entry->d_hash, b);
 	hlist_bl_unlock(b);
 }
@@ -2266,8 +2275,8 @@ static void __d_move(struct dentry * dentry, struct dentry * target)
 	/* Unhash the target: dput() will then get rid of it */
 	__d_drop(target);
 
-	list_del(&dentry->d_u.d_child);
-	list_del(&target->d_u.d_child);
+	list_del(&dentry->d_child);
+	list_del(&target->d_child);
 
 	/* Switch the names.. */
 	switch_names(dentry, target);
@@ -2275,17 +2284,18 @@ static void __d_move(struct dentry * dentry, struct dentry * target)
 
 	/* ... and switch the parents */
 	if (IS_ROOT(dentry)) {
+		dentry->d_flags |= DCACHE_RCUACCESS;
 		dentry->d_parent = target->d_parent;
 		target->d_parent = target;
-		INIT_LIST_HEAD(&target->d_u.d_child);
+		INIT_LIST_HEAD(&target->d_child);
 	} else {
 		swap(dentry->d_parent, target->d_parent);
 
 		/* And add them back to the (new) parent lists */
-		list_add(&target->d_u.d_child, &target->d_parent->d_subdirs);
+		list_add(&target->d_child, &target->d_parent->d_subdirs);
 	}
 
-	list_add(&dentry->d_u.d_child, &dentry->d_parent->d_subdirs);
+	list_add(&dentry->d_child, &dentry->d_parent->d_subdirs);
 
 	write_seqcount_end(&target->d_seq);
 	write_seqcount_end(&dentry->d_seq);
@@ -2391,10 +2401,11 @@ static void __d_materialise_dentry(struct dentry *dentry, struct dentry *anon)
 	switch_names(dentry, anon);
 	swap(dentry->d_name.hash, anon->d_name.hash);
 
+	dentry->d_flags |= DCACHE_RCUACCESS;
 	dentry->d_parent = dentry;
-	list_del_init(&dentry->d_u.d_child);
+	list_del_init(&dentry->d_child);
 	anon->d_parent = dparent;
-	list_move(&anon->d_u.d_child, &dparent->d_subdirs);
+	list_move(&anon->d_child, &dparent->d_subdirs);
 
 	write_seqcount_end(&dentry->d_seq);
 	write_seqcount_end(&anon->d_seq);
@@ -2524,6 +2535,8 @@ static int prepend_path(const struct path *path,
 	struct dentry *dentry = path->dentry;
 	struct vfsmount *vfsmnt = path->mnt;
 	struct mount *mnt = real_mount(vfsmnt);
+	char *orig_buffer = *buffer;
+	int orig_len = *buflen;
 	bool slash = false;
 	int error = 0;
 
@@ -2531,6 +2544,14 @@ static int prepend_path(const struct path *path,
 		struct dentry * parent;
 
 		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
+			/* Escaped? */
+			if (dentry != vfsmnt->mnt_root) {
+				*buffer = orig_buffer;
+				*buflen = orig_len;
+				slash = false;
+				error = 3;
+				goto global_root;
+			}
 			/* Global root? */
 			if (!mnt_has_parent(mnt))
 				goto global_root;
@@ -2559,15 +2580,6 @@ static int prepend_path(const struct path *path,
 	return error;
 
 global_root:
-	/*
-	 * Filesystems needing to implement special "root names"
-	 * should do so with ->d_dname()
-	 */
-	if (IS_ROOT(dentry) &&
-	    (dentry->d_name.len != 1 || dentry->d_name.name[0] != '/')) {
-		WARN(1, "Root dentry has weird name <%.*s>\n",
-		     (int) dentry->d_name.len, dentry->d_name.name);
-	}
 	if (!slash)
 		error = prepend(buffer, buflen, "/", 1);
 	if (!error)
@@ -2933,7 +2945,7 @@ repeat:
 resume:
 	while (next != &this_parent->d_subdirs) {
 		struct list_head *tmp = next;
-		struct dentry *dentry = list_entry(tmp, struct dentry, d_u.d_child);
+		struct dentry *dentry = list_entry(tmp, struct dentry, d_child);
 		next = tmp->next;
 
 		spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
@@ -2954,26 +2966,43 @@ resume:
 		}
 		spin_unlock(&dentry->d_lock);
 	}
+	rcu_read_lock();
+ascend:
 	if (this_parent != root) {
 		struct dentry *child = this_parent;
 		if (!(this_parent->d_flags & DCACHE_GENOCIDE)) {
 			this_parent->d_flags |= DCACHE_GENOCIDE;
 			this_parent->d_count--;
 		}
-		this_parent = try_to_ascend(this_parent, locked, seq);
-		if (!this_parent)
+		this_parent = child->d_parent;
+
+		spin_unlock(&child->d_lock);
+		spin_lock(&this_parent->d_lock);
+
+		/* might go back up the wrong parent if we have had a rename. */
+		if (!locked && read_seqretry(&rename_lock, seq))
 			goto rename_retry;
-		next = child->d_u.d_child.next;
+		/* go into the first sibling still alive */
+		do {
+			next = child->d_child.next;
+			if (next == &this_parent->d_subdirs)
+				goto ascend;
+			child = list_entry(next, struct dentry, d_child);
+		} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));
+		rcu_read_unlock();
 		goto resume;
 	}
-	spin_unlock(&this_parent->d_lock);
 	if (!locked && read_seqretry(&rename_lock, seq))
 		goto rename_retry;
+	spin_unlock(&this_parent->d_lock);
+	rcu_read_unlock();
 	if (locked)
 		write_sequnlock(&rename_lock);
 	return;
 
 rename_retry:
+	spin_unlock(&this_parent->d_lock);
+	rcu_read_unlock();
 	if (locked)
 		goto again;
 	locked = 1;
diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c
index 7269ec3..26d7fff 100644
--- a/fs/debugfs/inode.c
+++ b/fs/debugfs/inode.c
@@ -545,7 +545,7 @@ void debugfs_remove_recursive(struct dentry *dentry)
 	parent = dentry;
  down:
 	mutex_lock(&parent->d_inode->i_mutex);
-	list_for_each_entry_safe(child, next, &parent->d_subdirs, d_u.d_child) {
+	list_for_each_entry_safe(child, next, &parent->d_subdirs, d_child) {
 		if (!debugfs_positive(child))
 			continue;
 
@@ -566,8 +566,8 @@ void debugfs_remove_recursive(struct dentry *dentry)
 	mutex_lock(&parent->d_inode->i_mutex);
 
 	if (child != dentry) {
-		next = list_entry(child->d_u.d_child.next, struct dentry,
-					d_u.d_child);
+		next = list_entry(child->d_child.next, struct dentry,
+					d_child);
 		goto up;
 	}
 
diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c
index a726b9f..61af24e 100644
--- a/fs/devpts/inode.c
+++ b/fs/devpts/inode.c
@@ -564,6 +564,26 @@ void devpts_kill_index(struct inode *ptmx_inode, int idx)
 	mutex_unlock(&allocated_ptys_lock);
 }
 
+/*
+ * pty code needs to hold extra references in case of last /dev/tty close
+ */
+
+void devpts_add_ref(struct inode *ptmx_inode)
+{
+	struct super_block *sb = pts_sb_from_inode(ptmx_inode);
+
+	atomic_inc(&sb->s_active);
+	ihold(ptmx_inode);
+}
+
+void devpts_del_ref(struct inode *ptmx_inode)
+{
+	struct super_block *sb = pts_sb_from_inode(ptmx_inode);
+
+	iput(ptmx_inode);
+	deactivate_super(sb);
+}
+
 /**
  * devpts_pty_new -- create a new inode in /dev/pts/
  * @ptmx_inode: inode of the master
diff --git a/fs/ecryptfs/file.c b/fs/ecryptfs/file.c
index 9ff3664..d4644cc 100644
--- a/fs/ecryptfs/file.c
+++ b/fs/ecryptfs/file.c
@@ -183,6 +183,19 @@ out:
 	return rc;
 }
 
+static int ecryptfs_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct file *lower_file = ecryptfs_file_to_lower(file);
+	/*
+	 * Don't allow mmap on top of file systems that don't support it
+	 * natively.  If FILESYSTEM_MAX_STACK_DEPTH > 2 or ecryptfs
+	 * allows recursive mounting, this will need to be extended.
+	 */
+	if (!lower_file->f_op->mmap)
+		return -ENODEV;
+	return generic_file_mmap(file, vma);
+}
+
 /**
  * ecryptfs_open
  * @inode: inode speciying file to open
@@ -358,7 +371,7 @@ const struct file_operations ecryptfs_main_fops = {
 #ifdef CONFIG_COMPAT
 	.compat_ioctl = ecryptfs_compat_ioctl,
 #endif
-	.mmap = generic_file_mmap,
+	.mmap = ecryptfs_mmap,
 	.open = ecryptfs_open,
 	.flush = ecryptfs_flush,
 	.release = ecryptfs_release,
diff --git a/fs/efivarfs/file.c b/fs/efivarfs/file.c
index 8dd524f..08f105a 100644
--- a/fs/efivarfs/file.c
+++ b/fs/efivarfs/file.c
@@ -10,6 +10,7 @@
 #include <linux/efi.h>
 #include <linux/fs.h>
 #include <linux/slab.h>
+#include <linux/mount.h>
 
 #include "internal.h"
 
@@ -108,9 +109,79 @@ out_free:
 	return size;
 }
 
+static int
+efivarfs_ioc_getxflags(struct file *file, void __user *arg)
+{
+	struct inode *inode = file->f_mapping->host;
+	unsigned int i_flags;
+	unsigned int flags = 0;
+
+	i_flags = inode->i_flags;
+	if (i_flags & S_IMMUTABLE)
+		flags |= FS_IMMUTABLE_FL;
+
+	if (copy_to_user(arg, &flags, sizeof(flags)))
+		return -EFAULT;
+	return 0;
+}
+
+static int
+efivarfs_ioc_setxflags(struct file *file, void __user *arg)
+{
+	struct inode *inode = file->f_mapping->host;
+	unsigned int flags;
+	unsigned int i_flags = 0;
+	int error;
+
+	if (!inode_owner_or_capable(inode))
+		return -EACCES;
+
+	if (copy_from_user(&flags, arg, sizeof(flags)))
+		return -EFAULT;
+
+	if (flags & ~FS_IMMUTABLE_FL)
+		return -EOPNOTSUPP;
+
+	if (!capable(CAP_LINUX_IMMUTABLE))
+		return -EPERM;
+
+	if (flags & FS_IMMUTABLE_FL)
+		i_flags |= S_IMMUTABLE;
+
+
+	error = mnt_want_write_file(file);
+	if (error)
+		return error;
+
+	mutex_lock(&inode->i_mutex);
+	inode->i_flags &= ~S_IMMUTABLE;
+	inode->i_flags |= i_flags;
+	mutex_unlock(&inode->i_mutex);
+
+	mnt_drop_write_file(file);
+
+	return 0;
+}
+
+long
+efivarfs_file_ioctl(struct file *file, unsigned int cmd, unsigned long p)
+{
+	void __user *arg = (void __user *)p;
+
+	switch (cmd) {
+	case FS_IOC_GETFLAGS:
+		return efivarfs_ioc_getxflags(file, arg);
+	case FS_IOC_SETFLAGS:
+		return efivarfs_ioc_setxflags(file, arg);
+	}
+
+	return -ENOTTY;
+}
+
 const struct file_operations efivarfs_file_operations = {
 	.open	= simple_open,
 	.read	= efivarfs_file_read,
 	.write	= efivarfs_file_write,
 	.llseek	= no_llseek,
+	.unlocked_ioctl = efivarfs_file_ioctl,
 };
diff --git a/fs/efivarfs/inode.c b/fs/efivarfs/inode.c
index 7e787fb..d0351bc 100644
--- a/fs/efivarfs/inode.c
+++ b/fs/efivarfs/inode.c
@@ -15,7 +15,8 @@
 #include "internal.h"
 
 struct inode *efivarfs_get_inode(struct super_block *sb,
-				const struct inode *dir, int mode, dev_t dev)
+				const struct inode *dir, int mode,
+				dev_t dev, bool is_removable)
 {
 	struct inode *inode = new_inode(sb);
 
@@ -23,6 +24,7 @@ struct inode *efivarfs_get_inode(struct super_block *sb,
 		inode->i_ino = get_next_ino();
 		inode->i_mode = mode;
 		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+		inode->i_flags = is_removable ? 0 : S_IMMUTABLE;
 		switch (mode & S_IFMT) {
 		case S_IFREG:
 			inode->i_fop = &efivarfs_file_operations;
@@ -102,22 +104,17 @@ static void efivarfs_hex_to_guid(const char *str, efi_guid_t *guid)
 static int efivarfs_create(struct inode *dir, struct dentry *dentry,
 			  umode_t mode, bool excl)
 {
-	struct inode *inode;
+	struct inode *inode = NULL;
 	struct efivar_entry *var;
 	int namelen, i = 0, err = 0;
+	bool is_removable = false;
 
 	if (!efivarfs_valid_name(dentry->d_name.name, dentry->d_name.len))
 		return -EINVAL;
 
-	inode = efivarfs_get_inode(dir->i_sb, dir, mode, 0);
-	if (!inode)
-		return -ENOMEM;
-
 	var = kzalloc(sizeof(struct efivar_entry), GFP_KERNEL);
-	if (!var) {
-		err = -ENOMEM;
-		goto out;
-	}
+	if (!var)
+		return -ENOMEM;
 
 	/* length of the variable name itself: remove GUID and separator */
 	namelen = dentry->d_name.len - EFI_VARIABLE_GUID_LEN - 1;
@@ -125,6 +122,16 @@ static int efivarfs_create(struct inode *dir, struct dentry *dentry,
 	efivarfs_hex_to_guid(dentry->d_name.name + namelen + 1,
 			&var->var.VendorGuid);
 
+	if (efivar_variable_is_removable(var->var.VendorGuid,
+					 dentry->d_name.name, namelen))
+		is_removable = true;
+
+	inode = efivarfs_get_inode(dir->i_sb, dir, mode, 0, is_removable);
+	if (!inode) {
+		err = -ENOMEM;
+		goto out;
+	}
+
 	for (i = 0; i < namelen; i++)
 		var->var.VariableName[i] = dentry->d_name.name[i];
 
@@ -138,7 +145,8 @@ static int efivarfs_create(struct inode *dir, struct dentry *dentry,
 out:
 	if (err) {
 		kfree(var);
-		iput(inode);
+		if (inode)
+			iput(inode);
 	}
 	return err;
 }
diff --git a/fs/efivarfs/internal.h b/fs/efivarfs/internal.h
index b5ff16a..b450518 100644
--- a/fs/efivarfs/internal.h
+++ b/fs/efivarfs/internal.h
@@ -15,7 +15,8 @@ extern const struct file_operations efivarfs_file_operations;
 extern const struct inode_operations efivarfs_dir_inode_operations;
 extern bool efivarfs_valid_name(const char *str, int len);
 extern struct inode *efivarfs_get_inode(struct super_block *sb,
-			const struct inode *dir, int mode, dev_t dev);
+			const struct inode *dir, int mode, dev_t dev,
+			bool is_removable);
 
 extern struct list_head efivarfs_list;
 
diff --git a/fs/efivarfs/super.c b/fs/efivarfs/super.c
index 141aee3..5a3655f 100644
--- a/fs/efivarfs/super.c
+++ b/fs/efivarfs/super.c
@@ -128,8 +128,9 @@ static int efivarfs_callback(efi_char16_t *name16, efi_guid_t vendor,
 	struct dentry *dentry, *root = sb->s_root;
 	unsigned long size = 0;
 	char *name;
-	int len, i;
+	int len;
 	int err = -ENOMEM;
+	bool is_removable = false;
 
 	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
@@ -138,15 +139,17 @@ static int efivarfs_callback(efi_char16_t *name16, efi_guid_t vendor,
 	memcpy(entry->var.VariableName, name16, name_size);
 	memcpy(&(entry->var.VendorGuid), &vendor, sizeof(efi_guid_t));
 
-	len = ucs2_strlen(entry->var.VariableName);
+	len = ucs2_utf8size(entry->var.VariableName);
 
 	/* name, plus '-', plus GUID, plus NUL*/
 	name = kmalloc(len + 1 + EFI_VARIABLE_GUID_LEN + 1, GFP_KERNEL);
 	if (!name)
 		goto fail;
 
-	for (i = 0; i < len; i++)
-		name[i] = entry->var.VariableName[i] & 0xFF;
+	ucs2_as_utf8(name, entry->var.VariableName, len);
+
+	if (efivar_variable_is_removable(entry->var.VendorGuid, name, len))
+		is_removable = true;
 
 	name[len] = '-';
 
@@ -154,7 +157,8 @@ static int efivarfs_callback(efi_char16_t *name16, efi_guid_t vendor,
 
 	name[len + EFI_VARIABLE_GUID_LEN+1] = '\0';
 
-	inode = efivarfs_get_inode(sb, root->d_inode, S_IFREG | 0644, 0);
+	inode = efivarfs_get_inode(sb, root->d_inode, S_IFREG | 0644, 0,
+				   is_removable);
 	if (!inode)
 		goto fail_name;
 
@@ -210,7 +214,7 @@ static int efivarfs_fill_super(struct super_block *sb, void *data, int silent)
 	sb->s_d_op		= &efivarfs_d_ops;
 	sb->s_time_gran         = 1;
 
-	inode = efivarfs_get_inode(sb, NULL, S_IFDIR | 0755, 0);
+	inode = efivarfs_get_inode(sb, NULL, S_IFDIR | 0755, 0, true);
 	if (!inode)
 		return -ENOMEM;
 	inode->i_op = &efivarfs_dir_inode_operations;
diff --git a/fs/exec.c b/fs/exec.c
index dd6aa61..acbd7ac 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1265,6 +1265,53 @@ static int check_unsafe_exec(struct linux_binprm *bprm)
 	return res;
 }
 
+static void bprm_fill_uid(struct linux_binprm *bprm)
+{
+	struct inode *inode;
+	unsigned int mode;
+	kuid_t uid;
+	kgid_t gid;
+
+	/* clear any previous set[ug]id data from a previous binary */
+	bprm->cred->euid = current_euid();
+	bprm->cred->egid = current_egid();
+
+	if (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)
+		return;
+
+	if (current->no_new_privs)
+		return;
+
+	inode = file_inode(bprm->file);
+	mode = ACCESS_ONCE(inode->i_mode);
+	if (!(mode & (S_ISUID|S_ISGID)))
+		return;
+
+	/* Be careful if suid/sgid is set */
+	mutex_lock(&inode->i_mutex);
+
+	/* reload atomically mode/uid/gid now that lock held */
+	mode = inode->i_mode;
+	uid = inode->i_uid;
+	gid = inode->i_gid;
+	mutex_unlock(&inode->i_mutex);
+
+	/* We ignore suid/sgid if there are no mappings for them in the ns */
+	if (!kuid_has_mapping(bprm->cred->user_ns, uid) ||
+		 !kgid_has_mapping(bprm->cred->user_ns, gid))
+		return;
+
+	if (mode & S_ISUID) {
+		bprm->per_clear |= PER_CLEAR_ON_SETID;
+		bprm->cred->euid = uid;
+	}
+
+	if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
+		bprm->per_clear |= PER_CLEAR_ON_SETID;
+		bprm->cred->egid = gid;
+	}
+}
+
 /* 
  * Fill the binprm structure from the inode. 
  * Check permissions, then read the first 128 (BINPRM_BUF_SIZE) bytes
@@ -1273,39 +1320,12 @@ static int check_unsafe_exec(struct linux_binprm *bprm)
  */
 int prepare_binprm(struct linux_binprm *bprm)
 {
-	umode_t mode;
-	struct inode * inode = file_inode(bprm->file);
 	int retval;
 
-	mode = inode->i_mode;
 	if (bprm->file->f_op == NULL)
 		return -EACCES;
 
-	/* clear any previous set[ug]id data from a previous binary */
-	bprm->cred->euid = current_euid();
-	bprm->cred->egid = current_egid();
-
-	if (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&
-	    !current->no_new_privs &&
-	    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&
-	    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {
-		/* Set-uid? */
-		if (mode & S_ISUID) {
-			bprm->per_clear |= PER_CLEAR_ON_SETID;
-			bprm->cred->euid = inode->i_uid;
-		}
-
-		/* Set-gid? */
-		/*
-		 * If setgid is set but no group execute bit then this
-		 * is a candidate for mandatory locking, not a setgid
-		 * executable.
-		 */
-		if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
-			bprm->per_clear |= PER_CLEAR_ON_SETID;
-			bprm->cred->egid = inode->i_gid;
-		}
-	}
+	bprm_fill_uid(bprm);
 
 	/* fill in binprm security blob */
 	retval = security_bprm_set_creds(bprm);
diff --git a/fs/exportfs/expfs.c b/fs/exportfs/expfs.c
index 262fc99..b4eec4c 100644
--- a/fs/exportfs/expfs.c
+++ b/fs/exportfs/expfs.c
@@ -50,7 +50,7 @@ find_acceptable_alias(struct dentry *result,
 
 	inode = result->d_inode;
 	spin_lock(&inode->i_lock);
-	hlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {
+	hlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {
 		dget(dentry);
 		spin_unlock(&inode->i_lock);
 		if (toput)
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 2a71466..046e3e9 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -26,6 +26,7 @@
 #include <linux/seqlock.h>
 #include <linux/mutex.h>
 #include <linux/timer.h>
+#include <linux/version.h>
 #include <linux/wait.h>
 #include <linux/blockgroup_lock.h>
 #include <linux/percpu_counter.h>
@@ -728,19 +729,55 @@ struct move_extent {
 	<= (EXT4_GOOD_OLD_INODE_SIZE +			\
 	    (einode)->i_extra_isize))			\
 
+/*
+ * We use an encoding that preserves the times for extra epoch "00":
+ *
+ * extra  msb of                         adjust for signed
+ * epoch  32-bit                         32-bit tv_sec to
+ * bits   time    decoded 64-bit tv_sec  64-bit tv_sec      valid time range
+ * 0 0    1    -0x80000000..-0x00000001  0x000000000 1901-12-13..1969-12-31
+ * 0 0    0    0x000000000..0x07fffffff  0x000000000 1970-01-01..2038-01-19
+ * 0 1    1    0x080000000..0x0ffffffff  0x100000000 2038-01-19..2106-02-07
+ * 0 1    0    0x100000000..0x17fffffff  0x100000000 2106-02-07..2174-02-25
+ * 1 0    1    0x180000000..0x1ffffffff  0x200000000 2174-02-25..2242-03-16
+ * 1 0    0    0x200000000..0x27fffffff  0x200000000 2242-03-16..2310-04-04
+ * 1 1    1    0x280000000..0x2ffffffff  0x300000000 2310-04-04..2378-04-22
+ * 1 1    0    0x300000000..0x37fffffff  0x300000000 2378-04-22..2446-05-10
+ *
+ * Note that previous versions of the kernel on 64-bit systems would
+ * incorrectly use extra epoch bits 1,1 for dates between 1901 and
+ * 1970.  e2fsck will correct this, assuming that it is run on the
+ * affected filesystem before 2242.
+ */
+
 static inline __le32 ext4_encode_extra_time(struct timespec *time)
 {
-       return cpu_to_le32((sizeof(time->tv_sec) > 4 ?
-			   (time->tv_sec >> 32) & EXT4_EPOCH_MASK : 0) |
-                          ((time->tv_nsec << EXT4_EPOCH_BITS) & EXT4_NSEC_MASK));
+	u32 extra = sizeof(time->tv_sec) > 4 ?
+		((time->tv_sec - (s32)time->tv_sec) >> 32) & EXT4_EPOCH_MASK : 0;
+	return cpu_to_le32(extra | (time->tv_nsec << EXT4_EPOCH_BITS));
 }
 
 static inline void ext4_decode_extra_time(struct timespec *time, __le32 extra)
 {
-       if (sizeof(time->tv_sec) > 4)
-	       time->tv_sec |= (__u64)(le32_to_cpu(extra) & EXT4_EPOCH_MASK)
-			       << 32;
-       time->tv_nsec = (le32_to_cpu(extra) & EXT4_NSEC_MASK) >> EXT4_EPOCH_BITS;
+	if (unlikely(sizeof(time->tv_sec) > 4 &&
+			(extra & cpu_to_le32(EXT4_EPOCH_MASK)))) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0)
+		/* Handle legacy encoding of pre-1970 dates with epoch
+		 * bits 1,1.  We assume that by kernel version 4.20,
+		 * everyone will have run fsck over the affected
+		 * filesystems to correct the problem.  (This
+		 * backwards compatibility may be removed before this
+		 * time, at the discretion of the ext4 developers.)
+		 */
+		u64 extra_bits = le32_to_cpu(extra) & EXT4_EPOCH_MASK;
+		if (extra_bits == 3 && ((time->tv_sec) & 0x80000000) != 0)
+			extra_bits = 0;
+		time->tv_sec += extra_bits << 32;
+#else
+		time->tv_sec += (u64)(le32_to_cpu(extra) & EXT4_EPOCH_MASK) << 32;
+#endif
+	}
+	time->tv_nsec = (le32_to_cpu(extra) & EXT4_NSEC_MASK) >> EXT4_EPOCH_BITS;
 }
 
 #define EXT4_INODE_SET_XTIME(xtime, inode, raw_inode)			       \
@@ -814,6 +851,29 @@ do {									       \
 #include "extents_status.h"
 
 /*
+ * Lock subclasses for i_data_sem in the ext4_inode_info structure.
+ *
+ * These are needed to avoid lockdep false positives when we need to
+ * allocate blocks to the quota inode during ext4_map_blocks(), while
+ * holding i_data_sem for a normal (non-quota) inode.  Since we don't
+ * do quota tracking for the quota inode, this avoids deadlock (as
+ * well as infinite recursion, since it isn't turtles all the way
+ * down...)
+ *
+ *  I_DATA_SEM_NORMAL - Used for most inodes
+ *  I_DATA_SEM_OTHER  - Used by move_inode.c for the second normal inode
+ *			  where the second inode has larger inode number
+ *			  than the first
+ *  I_DATA_SEM_QUOTA  - Used for quota inodes only
+ */
+enum {
+	I_DATA_SEM_NORMAL = 0,
+	I_DATA_SEM_OTHER,
+	I_DATA_SEM_QUOTA,
+};
+
+
+/*
  * fourth extended file system inode data in memory
  */
 struct ext4_inode_info {
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 7fbd1c5..7eea761 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -361,9 +361,13 @@ static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)
 	ext4_fsblk_t block = ext4_ext_pblock(ext);
 	int len = ext4_ext_get_actual_len(ext);
 	ext4_lblk_t lblock = le32_to_cpu(ext->ee_block);
-	ext4_lblk_t last = lblock + len - 1;
 
-	if (lblock > last)
+	/*
+	 * We allow neither:
+	 *  - zero length
+	 *  - overflow/wrap-around
+	 */
+	if (lblock + len <= lblock)
 		return 0;
 	return ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);
 }
@@ -454,6 +458,10 @@ static int __ext4_ext_check(const char *function, unsigned int line,
 		error_msg = "invalid extent entries";
 		goto corrupted;
 	}
+	if (unlikely(depth > 32)) {
+		error_msg = "too large eh_depth";
+		goto corrupted;
+	}
 	/* Verify checksum on non-root extent tree nodes */
 	if (ext_depth(inode) != depth &&
 	    !ext4_extent_block_csum_verify(inode, eh)) {
diff --git a/fs/ext4/extents_status.c b/fs/ext4/extents_status.c
index e6941e6..1fefeb7 100644
--- a/fs/ext4/extents_status.c
+++ b/fs/ext4/extents_status.c
@@ -655,6 +655,14 @@ int ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,
 
 	BUG_ON(end < lblk);
 
+	if ((status & EXTENT_STATUS_DELAYED) &&
+	    (status & EXTENT_STATUS_WRITTEN)) {
+		ext4_warning(inode->i_sb, "Inserting extent [%u/%u] as "
+				" delayed and written which can potentially "
+				" cause data loss.\n", lblk, len);
+		WARN_ON(1);
+	}
+
 	newes.es_lblk = lblk;
 	newes.es_len = len;
 	ext4_es_store_pblock(&newes, pblk);
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 4d4718c..00cbc64 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -1027,11 +1027,13 @@ struct inode *ext4_orphan_get(struct super_block *sb, unsigned long ino)
 		goto iget_failed;
 
 	/*
-	 * If the orphans has i_nlinks > 0 then it should be able to be
-	 * truncated, otherwise it won't be removed from the orphan list
-	 * during processing and an infinite loop will result.
+	 * If the orphans has i_nlinks > 0 then it should be able to
+	 * be truncated, otherwise it won't be removed from the orphan
+	 * list during processing and an infinite loop will result.
+	 * Similarly, it must not be a bad inode.
 	 */
-	if (inode->i_nlink && !ext4_can_truncate(inode))
+	if ((inode->i_nlink && !ext4_can_truncate(inode)) ||
+	    is_bad_inode(inode))
 		goto bad_orphan;
 
 	if (NEXT_ORPHAN(inode) > max_ino)
diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c
index 5890614..b07a221 100644
--- a/fs/ext4/indirect.c
+++ b/fs/ext4/indirect.c
@@ -577,7 +577,7 @@ int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {
 		EXT4_ERROR_INODE(inode, "Can't allocate blocks for "
 				 "non-extent mapped inodes with bigalloc");
-		return -ENOSPC;
+		return -EUCLEAN;
 	}
 
 	goal = ext4_find_goal(inode, map->m_lblk, partial);
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index e48bd5a..221b582 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -206,9 +206,9 @@ void ext4_evict_inode(struct inode *inode)
 		 * Note that directories do not have this problem because they
 		 * don't use page cache.
 		 */
-		if (ext4_should_journal_data(inode) &&
-		    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&
-		    inode->i_ino != EXT4_JOURNAL_INO) {
+		if (inode->i_ino != EXT4_JOURNAL_INO &&
+		    ext4_should_journal_data(inode) &&
+		    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode))) {
 			journal_t *journal = EXT4_SB(inode->i_sb)->s_journal;
 			tid_t commit_tid = EXT4_I(inode)->i_datasync_tid;
 
@@ -626,6 +626,7 @@ int ext4_map_blocks(handle_t *handle, struct inode *inode,
 		status = map->m_flags & EXT4_MAP_UNWRITTEN ?
 				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
 		if (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&
+		    !(status & EXTENT_STATUS_WRITTEN) &&
 		    ext4_find_delalloc_range(inode, map->m_lblk,
 					     map->m_lblk + map->m_len - 1))
 			status |= EXTENT_STATUS_DELAYED;
@@ -736,6 +737,7 @@ found:
 		status = map->m_flags & EXT4_MAP_UNWRITTEN ?
 				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
 		if (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&
+		    !(status & EXTENT_STATUS_WRITTEN) &&
 		    ext4_find_delalloc_range(inode, map->m_lblk,
 					     map->m_lblk + map->m_len - 1))
 			status |= EXTENT_STATUS_DELAYED;
@@ -1030,7 +1032,8 @@ retry_journal:
 		ext4_journal_stop(handle);
 		goto retry_grab;
 	}
-	wait_on_page_writeback(page);
+	/* In case writeback began while the page was unlocked */
+	wait_for_stable_page(page);
 
 	if (ext4_should_dioread_nolock(inode))
 		ret = __block_write_begin(page, pos, len, ext4_get_block_write);
@@ -1409,7 +1412,7 @@ static void ext4_da_release_space(struct inode *inode, int to_free)
 static void ext4_da_page_release_reservation(struct page *page,
 					     unsigned long offset)
 {
-	int to_release = 0;
+	int to_release = 0, contiguous_blks = 0;
 	struct buffer_head *head, *bh;
 	unsigned int curr_off = 0;
 	struct inode *inode = page->mapping->host;
@@ -1424,14 +1427,23 @@ static void ext4_da_page_release_reservation(struct page *page,
 
 		if ((offset <= curr_off) && (buffer_delay(bh))) {
 			to_release++;
+			contiguous_blks++;
 			clear_buffer_delay(bh);
+		} else if (contiguous_blks) {
+			lblk = page->index <<
+			       (PAGE_CACHE_SHIFT - inode->i_blkbits);
+			lblk += (curr_off >> inode->i_blkbits) -
+				contiguous_blks;
+			ext4_es_remove_extent(inode, lblk, contiguous_blks);
+			contiguous_blks = 0;
 		}
 		curr_off = next_off;
 	} while ((bh = bh->b_this_page) != head);
 
-	if (to_release) {
+	if (contiguous_blks) {
 		lblk = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);
-		ext4_es_remove_extent(inode, lblk, to_release);
+		lblk += (curr_off >> inode->i_blkbits) - contiguous_blks;
+		ext4_es_remove_extent(inode, lblk, contiguous_blks);
 	}
 
 	/* If we have released all the blocks belonging to a cluster, then we
@@ -2096,19 +2108,32 @@ static int __ext4_journalled_writepage(struct page *page,
 		ext4_walk_page_buffers(handle, page_bufs, 0, len,
 				       NULL, bget_one);
 	}
-	/* As soon as we unlock the page, it can go away, but we have
-	 * references to buffers so we are safe */
+	/*
+	 * We need to release the page lock before we start the
+	 * journal, so grab a reference so the page won't disappear
+	 * out from under us.
+	 */
+	get_page(page);
 	unlock_page(page);
 
 	handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,
 				    ext4_writepage_trans_blocks(inode));
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
-		goto out;
+		put_page(page);
+		goto out_no_pagelock;
 	}
-
 	BUG_ON(!ext4_handle_valid(handle));
 
+	lock_page(page);
+	put_page(page);
+	if (page->mapping != mapping) {
+		/* The page got truncated from under us */
+		ext4_journal_stop(handle);
+		ret = 0;
+		goto out;
+	}
+
 	if (inline_data) {
 		ret = ext4_journal_get_write_access(handle, inode_bh);
 
@@ -2133,6 +2158,8 @@ static int __ext4_journalled_writepage(struct page *page,
 				       NULL, bput_one);
 	ext4_set_inode_state(inode, EXT4_STATE_JDATA);
 out:
+	unlock_page(page);
+out_no_pagelock:
 	brelse(inode_bh);
 	return ret;
 }
@@ -2727,7 +2754,7 @@ retry_journal:
 		goto retry_grab;
 	}
 	/* In case writeback began while the page was unlocked */
-	wait_on_page_writeback(page);
+	wait_for_stable_page(page);
 
 	ret = __block_write_begin(page, pos, len, ext4_da_get_block_prep);
 	if (ret < 0) {
@@ -5036,6 +5063,8 @@ int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)
 	might_sleep();
 	trace_ext4_mark_inode_dirty(inode, _RET_IP_);
 	err = ext4_reserve_inode_write(handle, inode, &iloc);
+	if (err)
+		return err;
 	if (ext4_handle_valid(handle) &&
 	    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&
 	    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {
@@ -5066,9 +5095,7 @@ int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)
 			}
 		}
 	}
-	if (!err)
-		err = ext4_mark_iloc_dirty(handle, inode, &iloc);
-	return err;
+	return ext4_mark_iloc_dirty(handle, inode, &iloc);
 }
 
 /*
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index df5050f..08b4495 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -1232,6 +1232,7 @@ static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)
 static int mb_find_order_for_block(struct ext4_buddy *e4b, int block)
 {
 	int order = 1;
+	int bb_incr = 1 << (e4b->bd_blkbits - 1);
 	void *bb;
 
 	BUG_ON(e4b->bd_bitmap == e4b->bd_buddy);
@@ -1244,7 +1245,8 @@ static int mb_find_order_for_block(struct ext4_buddy *e4b, int block)
 			/* this block is part of buddy of order 'order' */
 			return order;
 		}
-		bb += 1 << (e4b->bd_blkbits - order);
+		bb += bb_incr;
+		bb_incr >>= 1;
 		order++;
 	}
 	return 0;
@@ -2514,7 +2516,7 @@ int ext4_mb_init(struct super_block *sb)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
 	unsigned i, j;
-	unsigned offset;
+	unsigned offset, offset_incr;
 	unsigned max;
 	int ret;
 
@@ -2543,11 +2545,13 @@ int ext4_mb_init(struct super_block *sb)
 
 	i = 1;
 	offset = 0;
+	offset_incr = 1 << (sb->s_blocksize_bits - 1);
 	max = sb->s_blocksize << 2;
 	do {
 		sbi->s_mb_offsets[i] = offset;
 		sbi->s_mb_maxs[i] = max;
-		offset += 1 << (sb->s_blocksize_bits - i);
+		offset += offset_incr;
+		offset_incr = offset_incr >> 1;
 		max = max >> 1;
 		i++;
 	} while (i <= sb->s_blocksize_bits + 1);
@@ -2872,7 +2876,7 @@ ext4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,
 		ext4_error(sb, "Allocating blocks %llu-%llu which overlap "
 			   "fs metadata", block, block+len);
 		/* File system mounted not to panic on error
-		 * Fix the bitmap and repeat the block allocation
+		 * Fix the bitmap and return EUCLEAN
 		 * We leak some of the blocks here.
 		 */
 		ext4_lock_group(sb, ac->ac_b_ex.fe_group);
@@ -2881,7 +2885,7 @@ ext4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,
 		ext4_unlock_group(sb, ac->ac_b_ex.fe_group);
 		err = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);
 		if (!err)
-			err = -EAGAIN;
+			err = -EUCLEAN;
 		goto out_err;
 	}
 
@@ -4448,18 +4452,7 @@ repeat:
 	}
 	if (likely(ac->ac_status == AC_STATUS_FOUND)) {
 		*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);
-		if (*errp == -EAGAIN) {
-			/*
-			 * drop the reference that we took
-			 * in ext4_mb_use_best_found
-			 */
-			ext4_mb_release_context(ac);
-			ac->ac_b_ex.fe_group = 0;
-			ac->ac_b_ex.fe_start = 0;
-			ac->ac_b_ex.fe_len = 0;
-			ac->ac_status = AC_STATUS_CONTINUE;
-			goto repeat;
-		} else if (*errp) {
+		if (*errp) {
 			ext4_discard_allocated_blocks(ac);
 			goto errout;
 		} else {
@@ -4764,18 +4757,12 @@ do_more:
 		/*
 		 * blocks being freed are metadata. these blocks shouldn't
 		 * be used until this transaction is committed
+		 *
+		 * We use __GFP_NOFAIL because ext4_free_blocks() is not allowed
+		 * to fail.
 		 */
-	retry:
-		new_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);
-		if (!new_entry) {
-			/*
-			 * We use a retry loop because
-			 * ext4_free_blocks() is not allowed to fail.
-			 */
-			cond_resched();
-			congestion_wait(BLK_RW_ASYNC, HZ/50);
-			goto retry;
-		}
+		new_entry = kmem_cache_alloc(ext4_free_data_cachep,
+				GFP_NOFS|__GFP_NOFAIL);
 		new_entry->efd_start_cluster = bit;
 		new_entry->efd_group = block_group;
 		new_entry->efd_count = count_clusters;
diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c
index 49e8bdf..d19efab 100644
--- a/fs/ext4/migrate.c
+++ b/fs/ext4/migrate.c
@@ -616,6 +616,7 @@ int ext4_ind_migrate(struct inode *inode)
 	struct ext4_inode_info		*ei = EXT4_I(inode);
 	struct ext4_extent		*ex;
 	unsigned int			i, len;
+	ext4_lblk_t			start, end;
 	ext4_fsblk_t			blk;
 	handle_t			*handle;
 	int				ret;
@@ -629,6 +630,14 @@ int ext4_ind_migrate(struct inode *inode)
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC))
 		return -EOPNOTSUPP;
 
+	/*
+	 * In order to get correct extent info, force all delayed allocation
+	 * blocks to be allocated, otherwise delayed allocation blocks may not
+	 * be reflected and bypass the checks on extent header.
+	 */
+	if (test_opt(inode->i_sb, DELALLOC))
+		ext4_alloc_da_blocks(inode);
+
 	handle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
@@ -646,11 +655,13 @@ int ext4_ind_migrate(struct inode *inode)
 		goto errout;
 	}
 	if (eh->eh_entries == 0)
-		blk = len = 0;
+		blk = len = start = end = 0;
 	else {
 		len = le16_to_cpu(ex->ee_len);
 		blk = ext4_ext_pblock(ex);
-		if (len > EXT4_NDIR_BLOCKS) {
+		start = le32_to_cpu(ex->ee_block);
+		end = start + len - 1;
+		if (end >= EXT4_NDIR_BLOCKS) {
 			ret = -EOPNOTSUPP;
 			goto errout;
 		}
@@ -658,7 +669,7 @@ int ext4_ind_migrate(struct inode *inode)
 
 	ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);
 	memset(ei->i_data, 0, sizeof(ei->i_data));
-	for (i=0; i < len; i++)
+	for (i = start; i <= end; i++)
 		ei->i_data[i] = cpu_to_le32(blk++);
 	ext4_mark_inode_dirty(handle, inode);
 errout:
diff --git a/fs/ext4/move_extent.c b/fs/ext4/move_extent.c
index 3dcbf36..ad52ace 100644
--- a/fs/ext4/move_extent.c
+++ b/fs/ext4/move_extent.c
@@ -154,10 +154,10 @@ ext4_double_down_write_data_sem(struct inode *first, struct inode *second)
 {
 	if (first < second) {
 		down_write(&EXT4_I(first)->i_data_sem);
-		down_write_nested(&EXT4_I(second)->i_data_sem, SINGLE_DEPTH_NESTING);
+		down_write_nested(&EXT4_I(second)->i_data_sem, I_DATA_SEM_OTHER);
 	} else {
 		down_write(&EXT4_I(second)->i_data_sem);
-		down_write_nested(&EXT4_I(first)->i_data_sem, SINGLE_DEPTH_NESTING);
+		down_write_nested(&EXT4_I(first)->i_data_sem, I_DATA_SEM_OTHER);
 
 	}
 }
@@ -1117,6 +1117,13 @@ mext_check_arguments(struct inode *orig_inode,
 		return -EINVAL;
 	}
 
+	if (IS_NOQUOTA(orig_inode) || IS_NOQUOTA(donor_inode)) {
+		ext4_debug("ext4 move extent: The argument files should "
+			"not be quota files [ino:orig %lu, donor %lu]\n",
+			orig_inode->i_ino, donor_inode->i_ino);
+		return -EBUSY;
+	}
+
 	/* Ext4 move extent supports only extent based file */
 	if (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {
 		ext4_debug("ext4 move extent: orig file is not extents "
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index f131217..facf8590 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -1880,7 +1880,7 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 			  struct inode *inode)
 {
 	struct inode *dir = dentry->d_parent->d_inode;
-	struct buffer_head *bh;
+	struct buffer_head *bh = NULL;
 	struct ext4_dir_entry_2 *de;
 	struct ext4_dir_entry_tail *t;
 	struct super_block *sb;
@@ -1905,14 +1905,14 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 			return retval;
 		if (retval == 1) {
 			retval = 0;
-			return retval;
+			goto out;
 		}
 	}
 
 	if (is_dx(dir)) {
 		retval = ext4_dx_add_entry(handle, dentry, inode);
 		if (!retval || (retval != ERR_BAD_DX_DIR))
-			return retval;
+			goto out;
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
 		dx_fallback++;
 		ext4_mark_inode_dirty(handle, dir);
@@ -1924,14 +1924,15 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 			return PTR_ERR(bh);
 
 		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
-		if (retval != -ENOSPC) {
-			brelse(bh);
-			return retval;
-		}
+		if (retval != -ENOSPC)
+			goto out;
 
 		if (blocks == 1 && !dx_fallback &&
-		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))
-			return make_indexed_dir(handle, dentry, inode, bh);
+		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {
+			retval = make_indexed_dir(handle, dentry, inode, bh);
+			bh = NULL; /* make_indexed_dir releases bh */
+			goto out;
+		}
 		brelse(bh);
 	}
 	bh = ext4_append(handle, dir, &block);
@@ -1947,6 +1948,7 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 	}
 
 	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
+out:
 	brelse(bh);
 	if (retval == 0)
 		ext4_set_inode_state(inode, EXT4_STATE_NEWENTRY);
diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index a69bd74..cf0a704 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -181,7 +181,7 @@ static struct ext4_new_flex_group_data *alloc_flex_gd(unsigned long flexbg_size)
 	if (flex_gd == NULL)
 		goto out3;
 
-	if (flexbg_size >= UINT_MAX / sizeof(struct ext4_new_flex_group_data))
+	if (flexbg_size >= UINT_MAX / sizeof(struct ext4_new_group_data))
 		goto out2;
 	flex_gd->count = flexbg_size;
 
@@ -1025,7 +1025,7 @@ exit_free:
  * do not copy the full number of backups at this time.  The resize
  * which changed s_groups_count will backup again.
  */
-static void update_backups(struct super_block *sb, int blk_off, char *data,
+static void update_backups(struct super_block *sb, sector_t blk_off, char *data,
 			   int size, int meta_bg)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
@@ -1050,7 +1050,7 @@ static void update_backups(struct super_block *sb, int blk_off, char *data,
 		group = ext4_list_backups(sb, &three, &five, &seven);
 		last = sbi->s_groups_count;
 	} else {
-		group = ext4_meta_bg_first_group(sb, group) + 1;
+		group = ext4_get_group_number(sb, blk_off) + 1;
 		last = (ext4_group_t)(group + EXT4_DESC_PER_BLOCK(sb) - 2);
 	}
 
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 21a0b43..15a8189 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -400,9 +400,13 @@ static void ext4_handle_error(struct super_block *sb)
 		ext4_msg(sb, KERN_CRIT, "Remounting filesystem read-only");
 		sb->s_flags |= MS_RDONLY;
 	}
-	if (test_opt(sb, ERRORS_PANIC))
+	if (test_opt(sb, ERRORS_PANIC)) {
+		if (EXT4_SB(sb)->s_journal &&
+		  !(EXT4_SB(sb)->s_journal->j_flags & JBD2_REC_ERR))
+			return;
 		panic("EXT4-fs (device %s): panic forced after error\n",
 			sb->s_id);
+	}
 }
 
 void __ext4_error(struct super_block *sb, const char *function,
@@ -576,8 +580,12 @@ void __ext4_abort(struct super_block *sb, const char *function,
 			jbd2_journal_abort(EXT4_SB(sb)->s_journal, -EIO);
 		save_error_info(sb, function, line);
 	}
-	if (test_opt(sb, ERRORS_PANIC))
+	if (test_opt(sb, ERRORS_PANIC)) {
+		if (EXT4_SB(sb)->s_journal &&
+		  !(EXT4_SB(sb)->s_journal->j_flags & JBD2_REC_ERR))
+			return;
 		panic("EXT4-fs panic from previous error\n");
+	}
 }
 
 void ext4_msg(struct super_block *sb, const char *prefix, const char *fmt, ...)
@@ -803,6 +811,7 @@ static void ext4_put_super(struct super_block *sb)
 		dump_orphan_list(sb, sbi);
 	J_ASSERT(list_empty(&sbi->s_orphan));
 
+	sync_blockdev(sb->s_bdev);
 	invalidate_bdev(sb->s_bdev);
 	if (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {
 		/*
@@ -2144,6 +2153,16 @@ static void ext4_orphan_cleanup(struct super_block *sb,
 	while (es->s_last_orphan) {
 		struct inode *inode;
 
+		/*
+		 * We may have encountered an error during cleanup; if
+		 * so, skip the rest.
+		 */
+		if (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {
+			jbd_debug(1, "Skipping orphan recovery on fs with errors.\n");
+			es->s_last_orphan = 0;
+			break;
+		}
+
 		inode = ext4_orphan_get(sb, le32_to_cpu(es->s_last_orphan));
 		if (IS_ERR(inode)) {
 			es->s_last_orphan = 0;
@@ -4975,6 +4994,20 @@ static int ext4_quota_on_mount(struct super_block *sb, int type)
 					EXT4_SB(sb)->s_jquota_fmt, type);
 }
 
+static void lockdep_set_quota_inode(struct inode *inode, int subclass)
+{
+	struct ext4_inode_info *ei = EXT4_I(inode);
+
+	/* The first argument of lockdep_set_subclass has to be
+	 * *exactly* the same as the argument to init_rwsem() --- in
+	 * this case, in init_once() --- or lockdep gets unhappy
+	 * because the name of the lock is set using the
+	 * stringification of the argument to init_rwsem().
+	 */
+	(void) ei;	/* shut up clang warning if !CONFIG_LOCKDEP */
+	lockdep_set_subclass(&ei->i_data_sem, subclass);
+}
+
 /*
  * Standard function to be called on quota_on
  */
@@ -5014,8 +5047,12 @@ static int ext4_quota_on(struct super_block *sb, int type, int format_id,
 		if (err)
 			return err;
 	}
-
-	return dquot_quota_on(sb, type, format_id, path);
+	lockdep_set_quota_inode(path->dentry->d_inode, I_DATA_SEM_QUOTA);
+	err = dquot_quota_on(sb, type, format_id, path);
+	if (err)
+		lockdep_set_quota_inode(path->dentry->d_inode,
+					     I_DATA_SEM_NORMAL);
+	return err;
 }
 
 static int ext4_quota_enable(struct super_block *sb, int type, int format_id,
@@ -5041,8 +5078,11 @@ static int ext4_quota_enable(struct super_block *sb, int type, int format_id,
 
 	/* Don't account quota for quota files to avoid recursion */
 	qf_inode->i_flags |= S_NOQUOTA;
+	lockdep_set_quota_inode(qf_inode, I_DATA_SEM_QUOTA);
 	err = dquot_enable(qf_inode, type, format_id, flags);
 	iput(qf_inode);
+	if (err)
+		lockdep_set_quota_inode(qf_inode, I_DATA_SEM_NORMAL);
 
 	return err;
 }
diff --git a/fs/fhandle.c b/fs/fhandle.c
index 999ff5c..d59712d 100644
--- a/fs/fhandle.c
+++ b/fs/fhandle.c
@@ -195,8 +195,9 @@ static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,
 		goto out_err;
 	}
 	/* copy the full handle */
-	if (copy_from_user(handle, ufh,
-			   sizeof(struct file_handle) +
+	*handle = f_handle;
+	if (copy_from_user(&handle->f_handle,
+			   &ufh->f_handle,
 			   f_handle.handle_bytes)) {
 		retval = -EFAULT;
 		goto out_handle;
diff --git a/fs/file_table.c b/fs/file_table.c
index 54a34be..28f02a7 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -36,8 +36,6 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_STATIC_LGLOCK(files_lglock);
-
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
 
@@ -134,7 +132,6 @@ struct file *get_empty_filp(void)
 		return ERR_PTR(error);
 	}
 
-	INIT_LIST_HEAD(&f->f_u.fu_list);
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
@@ -265,18 +262,15 @@ static void __fput(struct file *file)
 	mntput(mnt);
 }
 
-static DEFINE_SPINLOCK(delayed_fput_lock);
-static LIST_HEAD(delayed_fput_list);
+static LLIST_HEAD(delayed_fput_list);
 static void delayed_fput(struct work_struct *unused)
 {
-	LIST_HEAD(head);
-	spin_lock_irq(&delayed_fput_lock);
-	list_splice_init(&delayed_fput_list, &head);
-	spin_unlock_irq(&delayed_fput_lock);
-	while (!list_empty(&head)) {
-		struct file *f = list_first_entry(&head, struct file, f_u.fu_list);
-		list_del_init(&f->f_u.fu_list);
-		__fput(f);
+	struct llist_node *node = llist_del_all(&delayed_fput_list);
+	struct llist_node *next;
+
+	for (; node; node = next) {
+		next = llist_next(node);
+		__fput(llist_entry(node, struct file, f_u.fu_llist));
 	}
 }
 
@@ -306,18 +300,15 @@ void fput(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		unsigned long flags;
 
-		file_sb_list_del(file);
 		if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {
 			init_task_work(&file->f_u.fu_rcuhead, ____fput);
 			if (!task_work_add(task, &file->f_u.fu_rcuhead, true))
 				return;
 		}
-		spin_lock_irqsave(&delayed_fput_lock, flags);
-		list_add(&file->f_u.fu_list, &delayed_fput_list);
-		schedule_work(&delayed_fput_work);
-		spin_unlock_irqrestore(&delayed_fput_lock, flags);
+
+		if (llist_add(&file->f_u.fu_llist, &delayed_fput_list))
+			schedule_work(&delayed_fput_work);
 	}
 }
 
@@ -333,7 +324,6 @@ void __fput_sync(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		struct task_struct *task = current;
-		file_sb_list_del(file);
 		BUG_ON(!(task->flags & PF_KTHREAD));
 		__fput(file);
 	}
@@ -345,127 +335,10 @@ void put_filp(struct file *file)
 {
 	if (atomic_long_dec_and_test(&file->f_count)) {
 		security_file_free(file);
-		file_sb_list_del(file);
 		file_free(file);
 	}
 }
 
-static inline int file_list_cpu(struct file *file)
-{
-#ifdef CONFIG_SMP
-	return file->f_sb_list_cpu;
-#else
-	return smp_processor_id();
-#endif
-}
-
-/* helper for file_sb_list_add to reduce ifdefs */
-static inline void __file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	struct list_head *list;
-#ifdef CONFIG_SMP
-	int cpu;
-	cpu = smp_processor_id();
-	file->f_sb_list_cpu = cpu;
-	list = per_cpu_ptr(sb->s_files, cpu);
-#else
-	list = &sb->s_files;
-#endif
-	list_add(&file->f_u.fu_list, list);
-}
-
-/**
- * file_sb_list_add - add a file to the sb's file list
- * @file: file to add
- * @sb: sb to add it to
- *
- * Use this function to associate a file with the superblock of the inode it
- * refers to.
- */
-void file_sb_list_add(struct file *file, struct super_block *sb)
-{
-	lg_local_lock(&files_lglock);
-	__file_sb_list_add(file, sb);
-	lg_local_unlock(&files_lglock);
-}
-
-/**
- * file_sb_list_del - remove a file from the sb's file list
- * @file: file to remove
- * @sb: sb to remove it from
- *
- * Use this function to remove a file from its superblock.
- */
-void file_sb_list_del(struct file *file)
-{
-	if (!list_empty(&file->f_u.fu_list)) {
-		lg_local_lock_cpu(&files_lglock, file_list_cpu(file));
-		list_del_init(&file->f_u.fu_list);
-		lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));
-	}
-}
-
-#ifdef CONFIG_SMP
-
-/*
- * These macros iterate all files on all CPUs for a given superblock.
- * files_lglock must be held globally.
- */
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	int i;							\
-	for_each_possible_cpu(i) {				\
-		struct list_head *list;				\
-		list = per_cpu_ptr((__sb)->s_files, i);		\
-		list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-	}							\
-}
-
-#else
-
-#define do_file_list_for_each_entry(__sb, __file)		\
-{								\
-	struct list_head *list;					\
-	list = &(sb)->s_files;					\
-	list_for_each_entry((__file), list, f_u.fu_list)
-
-#define while_file_list_for_each_entry				\
-}
-
-#endif
-
-/**
- *	mark_files_ro - mark all files read-only
- *	@sb: superblock in question
- *
- *	All files are marked read-only.  We don't care about pending
- *	delete files so this should be used in 'force' mode only.
- */
-void mark_files_ro(struct super_block *sb)
-{
-	struct file *f;
-
-	lg_global_lock(&files_lglock);
-	do_file_list_for_each_entry(sb, f) {
-		if (!S_ISREG(file_inode(f)->i_mode))
-		       continue;
-		if (!file_count(f))
-			continue;
-		if (!(f->f_mode & FMODE_WRITE))
-			continue;
-		spin_lock(&f->f_lock);
-		f->f_mode &= ~FMODE_WRITE;
-		spin_unlock(&f->f_lock);
-		if (file_check_writeable(f) != 0)
-			continue;
-		__mnt_drop_write(f->f_path.mnt);
-		file_release_write(f);
-	} while_file_list_for_each_entry;
-	lg_global_unlock(&files_lglock);
-}
-
 void __init files_init(unsigned long mempages)
 { 
 	unsigned long n;
@@ -481,6 +354,5 @@ void __init files_init(unsigned long mempages)
 	n = (mempages * (PAGE_SIZE / 1024)) / 10;
 	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
 	files_defer_init();
-	lg_lock_init(&files_lglock, "files_lglock");
 	percpu_counter_init(&nr_files, 0);
 } 
diff --git a/fs/fscache/netfs.c b/fs/fscache/netfs.c
index e028b8e..0912b90 100644
--- a/fs/fscache/netfs.c
+++ b/fs/fscache/netfs.c
@@ -45,9 +45,6 @@ int __fscache_register_netfs(struct fscache_netfs *netfs)
 	netfs->primary_index->parent		= &fscache_fsdef_index;
 	netfs->primary_index->netfs_data	= netfs;
 
-	atomic_inc(&netfs->primary_index->parent->usage);
-	atomic_inc(&netfs->primary_index->parent->n_children);
-
 	spin_lock_init(&netfs->primary_index->lock);
 	INIT_HLIST_HEAD(&netfs->primary_index->backing_objects);
 
@@ -60,6 +57,9 @@ int __fscache_register_netfs(struct fscache_netfs *netfs)
 			goto already_registered;
 	}
 
+	atomic_inc(&netfs->primary_index->parent->usage);
+	atomic_inc(&netfs->primary_index->parent->n_children);
+
 	list_add(&netfs->link, &fscache_netfs_list);
 	ret = 0;
 
@@ -70,8 +70,7 @@ already_registered:
 	up_write(&fscache_addremove_sem);
 
 	if (ret < 0) {
-		netfs->primary_index->parent = NULL;
-		__fscache_cookie_put(netfs->primary_index);
+		kmem_cache_free(fscache_cookie_jar, netfs->primary_index);
 		netfs->primary_index = NULL;
 	}
 
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 4fafb84..35f604b 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -993,6 +993,7 @@ static ssize_t fuse_fill_write_pages(struct fuse_req *req,
 
 		mark_page_accessed(page);
 
+		iov_iter_advance(ii, tmp);
 		if (!tmp) {
 			unlock_page(page);
 			page_cache_release(page);
@@ -1005,7 +1006,6 @@ static ssize_t fuse_fill_write_pages(struct fuse_req *req,
 		req->page_descs[req->num_pages].length = tmp;
 		req->num_pages++;
 
-		iov_iter_advance(ii, tmp);
 		count += tmp;
 		pos += tmp;
 		offset += tmp;
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index 39a986e..efe802e 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -913,7 +913,7 @@ static void fuse_send_init(struct fuse_conn *fc, struct fuse_req *req)
 	arg->flags |= FUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC |
 		FUSE_EXPORT_SUPPORT | FUSE_BIG_WRITES | FUSE_DONT_MASK |
 		FUSE_SPLICE_WRITE | FUSE_SPLICE_MOVE | FUSE_SPLICE_READ |
-		FUSE_FLOCK_LOCKS | FUSE_IOCTL_DIR | FUSE_AUTO_INVAL_DATA |
+		FUSE_FLOCK_LOCKS | FUSE_HAS_IOCTL_DIR | FUSE_AUTO_INVAL_DATA |
 		FUSE_DO_READDIRPLUS | FUSE_READDIRPLUS_AUTO | FUSE_ASYNC_DIO;
 	req->in.h.opcode = FUSE_INIT;
 	req->in.numargs = 1;
@@ -1028,6 +1028,7 @@ static int fuse_fill_super(struct super_block *sb, void *data, int silent)
 		goto err_fput;
 
 	fuse_conn_init(fc);
+	fc->release = fuse_free_conn;
 
 	fc->dev = sb->s_dev;
 	fc->sb = sb;
@@ -1042,7 +1043,6 @@ static int fuse_fill_super(struct super_block *sb, void *data, int silent)
 		fc->dont_mask = 1;
 	sb->s_flags |= MS_POSIXACL;
 
-	fc->release = fuse_free_conn;
 	fc->flags = d.flags;
 	fc->user_id = d.user_id;
 	fc->group_id = d.group_id;
diff --git a/fs/hfs/bnode.c b/fs/hfs/bnode.c
index d3fa6bd..221719e 100644
--- a/fs/hfs/bnode.c
+++ b/fs/hfs/bnode.c
@@ -288,7 +288,6 @@ static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)
 			page_cache_release(page);
 			goto fail;
 		}
-		page_cache_release(page);
 		node->page[i] = page;
 	}
 
@@ -398,11 +397,11 @@ node_error:
 
 void hfs_bnode_free(struct hfs_bnode *node)
 {
-	//int i;
+	int i;
 
-	//for (i = 0; i < node->tree->pages_per_bnode; i++)
-	//	if (node->page[i])
-	//		page_cache_release(node->page[i]);
+	for (i = 0; i < node->tree->pages_per_bnode; i++)
+		if (node->page[i])
+			page_cache_release(node->page[i]);
 	kfree(node);
 }
 
diff --git a/fs/hfs/brec.c b/fs/hfs/brec.c
index 9f4ee7f..6fc766d 100644
--- a/fs/hfs/brec.c
+++ b/fs/hfs/brec.c
@@ -131,13 +131,16 @@ skip:
 	hfs_bnode_write(node, entry, data_off + key_len, entry_len);
 	hfs_bnode_dump(node);
 
-	if (new_node) {
-		/* update parent key if we inserted a key
-		 * at the start of the first node
-		 */
-		if (!rec && new_node != node)
-			hfs_brec_update_parent(fd);
+	/*
+	 * update parent key if we inserted a key
+	 * at the start of the node and it is not the new node
+	 */
+	if (!rec && new_node != node) {
+		hfs_bnode_read_key(node, fd->search_key, data_off + size);
+		hfs_brec_update_parent(fd);
+	}
 
+	if (new_node) {
 		hfs_bnode_put(fd->bnode);
 		if (!new_node->parent) {
 			hfs_btree_inc_height(tree);
@@ -166,9 +169,6 @@ skip:
 		goto again;
 	}
 
-	if (!rec)
-		hfs_brec_update_parent(fd);
-
 	return 0;
 }
 
@@ -366,6 +366,8 @@ again:
 	if (IS_ERR(parent))
 		return PTR_ERR(parent);
 	__hfs_brec_find(parent, fd);
+	if (fd->record < 0)
+		return -ENOENT;
 	hfs_bnode_dump(parent);
 	rec = fd->record;
 
diff --git a/fs/hfsplus/bnode.c b/fs/hfsplus/bnode.c
index 11c8602..bedfe5f 100644
--- a/fs/hfsplus/bnode.c
+++ b/fs/hfsplus/bnode.c
@@ -456,7 +456,6 @@ static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)
 			page_cache_release(page);
 			goto fail;
 		}
-		page_cache_release(page);
 		node->page[i] = page;
 	}
 
@@ -568,13 +567,11 @@ node_error:
 
 void hfs_bnode_free(struct hfs_bnode *node)
 {
-#if 0
 	int i;
 
 	for (i = 0; i < node->tree->pages_per_bnode; i++)
 		if (node->page[i])
 			page_cache_release(node->page[i]);
-#endif
 	kfree(node);
 }
 
diff --git a/fs/hfsplus/brec.c b/fs/hfsplus/brec.c
index 6e560d5..754fdf8 100644
--- a/fs/hfsplus/brec.c
+++ b/fs/hfsplus/brec.c
@@ -131,13 +131,16 @@ skip:
 	hfs_bnode_write(node, entry, data_off + key_len, entry_len);
 	hfs_bnode_dump(node);
 
-	if (new_node) {
-		/* update parent key if we inserted a key
-		 * at the start of the first node
-		 */
-		if (!rec && new_node != node)
-			hfs_brec_update_parent(fd);
+	/*
+	 * update parent key if we inserted a key
+	 * at the start of the node and it is not the new node
+	 */
+	if (!rec && new_node != node) {
+		hfs_bnode_read_key(node, fd->search_key, data_off + size);
+		hfs_brec_update_parent(fd);
+	}
 
+	if (new_node) {
 		hfs_bnode_put(fd->bnode);
 		if (!new_node->parent) {
 			hfs_btree_inc_height(tree);
@@ -168,9 +171,6 @@ skip:
 		goto again;
 	}
 
-	if (!rec)
-		hfs_brec_update_parent(fd);
-
 	return 0;
 }
 
@@ -370,6 +370,8 @@ again:
 	if (IS_ERR(parent))
 		return PTR_ERR(parent);
 	__hfs_brec_find(parent, fd, hfs_find_rec_by_key);
+	if (fd->record < 0)
+		return -ENOENT;
 	hfs_bnode_dump(parent);
 	rec = fd->record;
 
diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c
index 32f35f1..b58a9cb 100644
--- a/fs/hostfs/hostfs_kern.c
+++ b/fs/hostfs/hostfs_kern.c
@@ -720,15 +720,13 @@ static int hostfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
 
 	init_special_inode(inode, mode, dev);
 	err = do_mknod(name, mode, MAJOR(dev), MINOR(dev));
-	if (!err)
+	if (err)
 		goto out_free;
 
 	err = read_name(inode, name);
 	__putname(name);
 	if (err)
 		goto out_put;
-	if (err)
-		goto out_put;
 
 	d_instantiate(dentry, inode);
 	return 0;
diff --git a/fs/hpfs/namei.c b/fs/hpfs/namei.c
index 345713d..6b42789 100644
--- a/fs/hpfs/namei.c
+++ b/fs/hpfs/namei.c
@@ -8,6 +8,17 @@
 #include <linux/sched.h>
 #include "hpfs_fn.h"
 
+static void hpfs_update_directory_times(struct inode *dir)
+{
+	time_t t = get_seconds();
+	if (t == dir->i_mtime.tv_sec &&
+	    t == dir->i_ctime.tv_sec)
+		return;
+	dir->i_mtime.tv_sec = dir->i_ctime.tv_sec = t;
+	dir->i_mtime.tv_nsec = dir->i_ctime.tv_nsec = 0;
+	hpfs_write_inode_nolock(dir);
+}
+
 static int hpfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
 	const unsigned char *name = dentry->d_name.name;
@@ -99,6 +110,7 @@ static int hpfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 		result->i_mode = mode | S_IFDIR;
 		hpfs_write_inode_nolock(result);
 	}
+	hpfs_update_directory_times(dir);
 	d_instantiate(dentry, result);
 	hpfs_unlock(dir->i_sb);
 	return 0;
@@ -187,6 +199,7 @@ static int hpfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, b
 		result->i_mode = mode | S_IFREG;
 		hpfs_write_inode_nolock(result);
 	}
+	hpfs_update_directory_times(dir);
 	d_instantiate(dentry, result);
 	hpfs_unlock(dir->i_sb);
 	return 0;
@@ -262,6 +275,7 @@ static int hpfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, de
 	insert_inode_hash(result);
 
 	hpfs_write_inode_nolock(result);
+	hpfs_update_directory_times(dir);
 	d_instantiate(dentry, result);
 	brelse(bh);
 	hpfs_unlock(dir->i_sb);
@@ -340,6 +354,7 @@ static int hpfs_symlink(struct inode *dir, struct dentry *dentry, const char *sy
 	insert_inode_hash(result);
 
 	hpfs_write_inode_nolock(result);
+	hpfs_update_directory_times(dir);
 	d_instantiate(dentry, result);
 	hpfs_unlock(dir->i_sb);
 	return 0;
@@ -423,6 +438,8 @@ again:
 out1:
 	hpfs_brelse4(&qbh);
 out:
+	if (!err)
+		hpfs_update_directory_times(dir);
 	hpfs_unlock(dir->i_sb);
 	return err;
 }
@@ -477,6 +494,8 @@ static int hpfs_rmdir(struct inode *dir, struct dentry *dentry)
 out1:
 	hpfs_brelse4(&qbh);
 out:
+	if (!err)
+		hpfs_update_directory_times(dir);
 	hpfs_unlock(dir->i_sb);
 	return err;
 }
@@ -595,7 +614,7 @@ static int hpfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		goto end1;
 	}
 
-	end:
+end:
 	hpfs_i(i)->i_parent_dir = new_dir->i_ino;
 	if (S_ISDIR(i->i_mode)) {
 		inc_nlink(new_dir);
@@ -610,6 +629,10 @@ static int hpfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 		brelse(bh);
 	}
 end1:
+	if (!err) {
+		hpfs_update_directory_times(old_dir);
+		hpfs_update_directory_times(new_dir);
+	}
 	hpfs_unlock(i->i_sb);
 	return err;
 }
diff --git a/fs/hpfs/super.c b/fs/hpfs/super.c
index 962e90c..2c1ce19 100644
--- a/fs/hpfs/super.c
+++ b/fs/hpfs/super.c
@@ -52,17 +52,20 @@ static void unmark_dirty(struct super_block *s)
 }
 
 /* Filesystem error... */
-static char err_buf[1024];
-
 void hpfs_error(struct super_block *s, const char *fmt, ...)
 {
+	struct va_format vaf;
 	va_list args;
 
 	va_start(args, fmt);
-	vsnprintf(err_buf, sizeof(err_buf), fmt, args);
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	pr_err("filesystem error: %pV", &vaf);
+
 	va_end(args);
 
-	printk("HPFS: filesystem error: %s", err_buf);
 	if (!hpfs_sb(s)->sb_was_error) {
 		if (hpfs_sb(s)->sb_err == 2) {
 			printk("; crashing the system because you wanted it\n");
diff --git a/fs/inode.c b/fs/inode.c
index 1b300a0..17f95b4 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -1628,8 +1628,8 @@ int file_remove_suid(struct file *file)
 		error = security_inode_killpriv(dentry);
 	if (!error && killsuid)
 		error = __remove_suid(dentry, killsuid);
-	if (!error && (inode->i_sb->s_flags & MS_NOSEC))
-		inode->i_flags |= S_NOSEC;
+	if (!error)
+		inode_has_no_xattr(inode);
 
 	return error;
 }
diff --git a/fs/internal.h b/fs/internal.h
index 6812158..2ffa65a 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -74,9 +74,6 @@ extern void chroot_fs_refs(const struct path *, const struct path *);
 /*
  * file_table.c
  */
-extern void file_sb_list_add(struct file *f, struct super_block *sb);
-extern void file_sb_list_del(struct file *f);
-extern void mark_files_ro(struct super_block *);
 extern struct file *get_empty_filp(void);
 
 /*
diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 735d752..204659a 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -203,6 +203,8 @@ int get_rock_ridge_filename(struct iso_directory_record *de,
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
+	char *p;
+	int len;
 
 	if (!ISOFS_SB(inode->i_sb)->s_rock)
 		return 0;
@@ -267,12 +269,17 @@ repeat:
 					rr->u.NM.flags);
 				break;
 			}
-			if ((strlen(retname) + rr->len - 5) >= 254) {
+			len = rr->len - 5;
+			if (retnamlen + len >= 254) {
 				truncate = 1;
 				break;
 			}
-			strncat(retname, rr->u.NM.name, rr->len - 5);
-			retnamlen += rr->len - 5;
+			p = memchr(rr->u.NM.name, '\0', len);
+			if (unlikely(p))
+				len = p - rr->u.NM.name;
+			memcpy(retname + retnamlen, rr->u.NM.name, len);
+			retnamlen += len;
+			retname[retnamlen] = '\0';
 			break;
 		case SIG('R', 'E'):
 			kfree(rs.buffer);
diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c
index c78841e..6bb5285 100644
--- a/fs/jbd2/checkpoint.c
+++ b/fs/jbd2/checkpoint.c
@@ -440,7 +440,7 @@ int jbd2_cleanup_journal_tail(journal_t *journal)
 	unsigned long	blocknr;
 
 	if (is_journal_aborted(journal))
-		return 1;
+		return -EIO;
 
 	if (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))
 		return 1;
@@ -455,10 +455,9 @@ int jbd2_cleanup_journal_tail(journal_t *journal)
 	 * jbd2_cleanup_journal_tail() doesn't get called all that often.
 	 */
 	if (journal->j_flags & JBD2_BARRIER)
-		blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);
+		blkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL);
 
-	__jbd2_update_log_tail(journal, first_tid, blocknr);
-	return 0;
+	return __jbd2_update_log_tail(journal, first_tid, blocknr);
 }
 
 
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index aaa1a3f..85733dd 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -869,9 +869,10 @@ int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,
  *
  * Requires j_checkpoint_mutex
  */
-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)
+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)
 {
 	unsigned long freed;
+	int ret;
 
 	BUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));
 
@@ -881,7 +882,10 @@ void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)
 	 * space and if we lose sb update during power failure we'd replay
 	 * old transaction with possibly newly overwritten data.
 	 */
-	jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);
+	ret = jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);
+	if (ret)
+		goto out;
+
 	write_lock(&journal->j_state_lock);
 	freed = block - journal->j_tail;
 	if (block < journal->j_tail)
@@ -897,6 +901,9 @@ void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)
 	journal->j_tail_sequence = tid;
 	journal->j_tail = block;
 	write_unlock(&journal->j_state_lock);
+
+out:
+	return ret;
 }
 
 /*
@@ -1315,7 +1322,7 @@ static int journal_reset(journal_t *journal)
 	return jbd2_journal_start_thread(journal);
 }
 
-static void jbd2_write_superblock(journal_t *journal, int write_op)
+static int jbd2_write_superblock(journal_t *journal, int write_op)
 {
 	struct buffer_head *bh = journal->j_sb_buffer;
 	journal_superblock_t *sb = journal->j_superblock;
@@ -1354,7 +1361,10 @@ static void jbd2_write_superblock(journal_t *journal, int write_op)
 		printk(KERN_ERR "JBD2: Error %d detected when updating "
 		       "journal superblock for %s.\n", ret,
 		       journal->j_devname);
+		jbd2_journal_abort(journal, ret);
 	}
+
+	return ret;
 }
 
 /**
@@ -1367,10 +1377,11 @@ static void jbd2_write_superblock(journal_t *journal, int write_op)
  * Update a journal's superblock information about log tail and write it to
  * disk, waiting for the IO to complete.
  */
-void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,
+int jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,
 				     unsigned long tail_block, int write_op)
 {
 	journal_superblock_t *sb = journal->j_superblock;
+	int ret;
 
 	BUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));
 	jbd_debug(1, "JBD2: updating superblock (start %lu, seq %u)\n",
@@ -1379,23 +1390,29 @@ void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,
 	sb->s_sequence = cpu_to_be32(tail_tid);
 	sb->s_start    = cpu_to_be32(tail_block);
 
-	jbd2_write_superblock(journal, write_op);
+	ret = jbd2_write_superblock(journal, write_op);
+	if (ret)
+		goto out;
 
 	/* Log is no longer empty */
 	write_lock(&journal->j_state_lock);
 	WARN_ON(!sb->s_sequence);
 	journal->j_flags &= ~JBD2_FLUSHED;
 	write_unlock(&journal->j_state_lock);
+
+out:
+	return ret;
 }
 
 /**
  * jbd2_mark_journal_empty() - Mark on disk journal as empty.
  * @journal: The journal to update.
+ * @write_op: With which operation should we write the journal sb
  *
  * Update a journal's dynamic superblock fields to show that journal is empty.
  * Write updated superblock to disk waiting for IO to complete.
  */
-static void jbd2_mark_journal_empty(journal_t *journal)
+static void jbd2_mark_journal_empty(journal_t *journal, int write_op)
 {
 	journal_superblock_t *sb = journal->j_superblock;
 
@@ -1413,7 +1430,7 @@ static void jbd2_mark_journal_empty(journal_t *journal)
 	sb->s_start    = cpu_to_be32(0);
 	read_unlock(&journal->j_state_lock);
 
-	jbd2_write_superblock(journal, WRITE_FUA);
+	jbd2_write_superblock(journal, write_op);
 
 	/* Log is no longer empty */
 	write_lock(&journal->j_state_lock);
@@ -1681,7 +1698,13 @@ int jbd2_journal_destroy(journal_t *journal)
 	if (journal->j_sb_buffer) {
 		if (!is_journal_aborted(journal)) {
 			mutex_lock(&journal->j_checkpoint_mutex);
-			jbd2_mark_journal_empty(journal);
+
+			write_lock(&journal->j_state_lock);
+			journal->j_tail_sequence =
+				++journal->j_transaction_sequence;
+			write_unlock(&journal->j_state_lock);
+
+			jbd2_mark_journal_empty(journal, WRITE_FLUSH_FUA);
 			mutex_unlock(&journal->j_checkpoint_mutex);
 		} else
 			err = -EIO;
@@ -1922,14 +1945,21 @@ int jbd2_journal_flush(journal_t *journal)
 		return -EIO;
 
 	mutex_lock(&journal->j_checkpoint_mutex);
-	jbd2_cleanup_journal_tail(journal);
+	if (!err) {
+		err = jbd2_cleanup_journal_tail(journal);
+		if (err < 0) {
+			mutex_unlock(&journal->j_checkpoint_mutex);
+			goto out;
+		}
+		err = 0;
+	}
 
 	/* Finally, mark the journal as really needing no recovery.
 	 * This sets s_start==0 in the underlying superblock, which is
 	 * the magic code for a fully-recovered superblock.  Any future
 	 * commits of data to the journal will restore the current
 	 * s_start value. */
-	jbd2_mark_journal_empty(journal);
+	jbd2_mark_journal_empty(journal, WRITE_FUA);
 	mutex_unlock(&journal->j_checkpoint_mutex);
 	write_lock(&journal->j_state_lock);
 	J_ASSERT(!journal->j_running_transaction);
@@ -1938,7 +1968,8 @@ int jbd2_journal_flush(journal_t *journal)
 	J_ASSERT(journal->j_head == journal->j_tail);
 	J_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);
 	write_unlock(&journal->j_state_lock);
-	return 0;
+out:
+	return err;
 }
 
 /**
@@ -1974,7 +2005,7 @@ int jbd2_journal_wipe(journal_t *journal, int write)
 	if (write) {
 		/* Lock to make assertions happy... */
 		mutex_lock(&journal->j_checkpoint_mutex);
-		jbd2_mark_journal_empty(journal);
+		jbd2_mark_journal_empty(journal, WRITE_FUA);
 		mutex_unlock(&journal->j_checkpoint_mutex);
 	}
 
@@ -2025,8 +2056,12 @@ static void __journal_abort_soft (journal_t *journal, int errno)
 
 	__jbd2_journal_abort_hard(journal);
 
-	if (errno)
+	if (errno) {
 		jbd2_journal_update_sb_errno(journal);
+		write_lock(&journal->j_state_lock);
+		journal->j_flags |= JBD2_REC_ERR;
+		write_unlock(&journal->j_state_lock);
+	}
 }
 
 /**
diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c
index ec34e11..21b828c 100644
--- a/fs/jbd2/transaction.c
+++ b/fs/jbd2/transaction.c
@@ -1936,6 +1936,7 @@ static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,
 
 		if (!buffer_dirty(bh)) {
 			/* bdflush has written it.  We can drop it now */
+			__jbd2_journal_remove_checkpoint(jh);
 			goto zap_buffer;
 		}
 
@@ -1965,6 +1966,7 @@ static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,
 				/* The orphan record's transaction has
 				 * committed.  We can cleanse this buffer */
 				clear_buffer_jbddirty(bh);
+				__jbd2_journal_remove_checkpoint(jh);
 				goto zap_buffer;
 			}
 		}
diff --git a/fs/jffs2/README.Locking b/fs/jffs2/README.Locking
index 3ea3655..8918ac9 100644
--- a/fs/jffs2/README.Locking
+++ b/fs/jffs2/README.Locking
@@ -2,10 +2,6 @@
 	JFFS2 LOCKING DOCUMENTATION
 	---------------------------
 
-At least theoretically, JFFS2 does not require the Big Kernel Lock
-(BKL), which was always helpfully obtained for it by Linux 2.4 VFS
-code. It has its own locking, as described below.
-
 This document attempts to describe the existing locking rules for
 JFFS2. It is not expected to remain perfectly up to date, but ought to
 be fairly close.
@@ -69,6 +65,7 @@ Ordering constraints:
 	   any f->sem held.
 	2. Never attempt to lock two file mutexes in one thread.
 	   No ordering rules have been made for doing so.
+	3. Never lock a page cache page with f->sem held.
 
 
 	erase_completion_lock spinlock
diff --git a/fs/jffs2/build.c b/fs/jffs2/build.c
index a3750f9..c1f0494 100644
--- a/fs/jffs2/build.c
+++ b/fs/jffs2/build.c
@@ -49,7 +49,8 @@ next_inode(int *i, struct jffs2_inode_cache *ic, struct jffs2_sb_info *c)
 
 
 static void jffs2_build_inode_pass1(struct jffs2_sb_info *c,
-				    struct jffs2_inode_cache *ic)
+				    struct jffs2_inode_cache *ic,
+				    int *dir_hardlinks)
 {
 	struct jffs2_full_dirent *fd;
 
@@ -68,19 +69,21 @@ static void jffs2_build_inode_pass1(struct jffs2_sb_info *c,
 			dbg_fsbuild("child \"%s\" (ino #%u) of dir ino #%u doesn't exist!\n",
 				  fd->name, fd->ino, ic->ino);
 			jffs2_mark_node_obsolete(c, fd->raw);
+			/* Clear the ic/raw union so it doesn't cause problems later. */
+			fd->ic = NULL;
 			continue;
 		}
 
+		/* From this point, fd->raw is no longer used so we can set fd->ic */
+		fd->ic = child_ic;
+		child_ic->pino_nlink++;
+		/* If we appear (at this stage) to have hard-linked directories,
+		 * set a flag to trigger a scan later */
 		if (fd->type == DT_DIR) {
-			if (child_ic->pino_nlink) {
-				JFFS2_ERROR("child dir \"%s\" (ino #%u) of dir ino #%u appears to be a hard link\n",
-					    fd->name, fd->ino, ic->ino);
-				/* TODO: What do we do about it? */
-			} else {
-				child_ic->pino_nlink = ic->ino;
-			}
-		} else
-			child_ic->pino_nlink++;
+			child_ic->flags |= INO_FLAGS_IS_DIR;
+			if (child_ic->pino_nlink > 1)
+				*dir_hardlinks = 1;
+		}
 
 		dbg_fsbuild("increased nlink for child \"%s\" (ino #%u)\n", fd->name, fd->ino);
 		/* Can't free scan_dents so far. We might need them in pass 2 */
@@ -94,8 +97,7 @@ static void jffs2_build_inode_pass1(struct jffs2_sb_info *c,
 */
 static int jffs2_build_filesystem(struct jffs2_sb_info *c)
 {
-	int ret;
-	int i;
+	int ret, i, dir_hardlinks = 0;
 	struct jffs2_inode_cache *ic;
 	struct jffs2_full_dirent *fd;
 	struct jffs2_full_dirent *dead_fds = NULL;
@@ -119,7 +121,7 @@ static int jffs2_build_filesystem(struct jffs2_sb_info *c)
 	/* Now scan the directory tree, increasing nlink according to every dirent found. */
 	for_each_inode(i, c, ic) {
 		if (ic->scan_dents) {
-			jffs2_build_inode_pass1(c, ic);
+			jffs2_build_inode_pass1(c, ic, &dir_hardlinks);
 			cond_resched();
 		}
 	}
@@ -155,6 +157,20 @@ static int jffs2_build_filesystem(struct jffs2_sb_info *c)
 	}
 
 	dbg_fsbuild("pass 2a complete\n");
+
+	if (dir_hardlinks) {
+		/* If we detected directory hardlinks earlier, *hopefully*
+		 * they are gone now because some of the links were from
+		 * dead directories which still had some old dirents lying
+		 * around and not yet garbage-collected, but which have
+		 * been discarded above. So clear the pino_nlink field
+		 * in each directory, so that the final scan below can
+		 * print appropriate warnings. */
+		for_each_inode(i, c, ic) {
+			if (ic->flags & INO_FLAGS_IS_DIR)
+				ic->pino_nlink = 0;
+		}
+	}
 	dbg_fsbuild("freeing temporary data structures\n");
 
 	/* Finally, we can scan again and free the dirent structs */
@@ -162,6 +178,33 @@ static int jffs2_build_filesystem(struct jffs2_sb_info *c)
 		while(ic->scan_dents) {
 			fd = ic->scan_dents;
 			ic->scan_dents = fd->next;
+			/* We do use the pino_nlink field to count nlink of
+			 * directories during fs build, so set it to the
+			 * parent ino# now. Now that there's hopefully only
+			 * one. */
+			if (fd->type == DT_DIR) {
+				if (!fd->ic) {
+					/* We'll have complained about it and marked the coresponding
+					   raw node obsolete already. Just skip it. */
+					continue;
+				}
+
+				/* We *have* to have set this in jffs2_build_inode_pass1() */
+				BUG_ON(!(fd->ic->flags & INO_FLAGS_IS_DIR));
+
+				/* We clear ic->pino_nlink ∀ directories' ic *only* if dir_hardlinks
+				 * is set. Otherwise, we know this should never trigger anyway, so
+				 * we don't do the check. And ic->pino_nlink still contains the nlink
+				 * value (which is 1). */
+				if (dir_hardlinks && fd->ic->pino_nlink) {
+					JFFS2_ERROR("child dir \"%s\" (ino #%u) of dir ino #%u is also hard linked from dir ino #%u\n",
+						    fd->name, fd->ino, ic->ino, fd->ic->pino_nlink);
+					/* Should we unlink it from its previous parent? */
+				}
+
+				/* For directories, ic->pino_nlink holds that parent inode # */
+				fd->ic->pino_nlink = ic->ino;
+			}
 			jffs2_free_full_dirent(fd);
 		}
 		ic->scan_dents = NULL;
@@ -240,11 +283,7 @@ static void jffs2_build_remove_unlinked_inode(struct jffs2_sb_info *c,
 
 			/* Reduce nlink of the child. If it's now zero, stick it on the
 			   dead_fds list to be cleaned up later. Else just free the fd */
-
-			if (fd->type == DT_DIR)
-				child_ic->pino_nlink = 0;
-			else
-				child_ic->pino_nlink--;
+			child_ic->pino_nlink--;
 
 			if (!child_ic->pino_nlink) {
 				dbg_fsbuild("inode #%u (\"%s\") now has no links; adding to dead_fds list.\n",
diff --git a/fs/jffs2/file.c b/fs/jffs2/file.c
index 1506673..60ef3fb 100644
--- a/fs/jffs2/file.c
+++ b/fs/jffs2/file.c
@@ -138,39 +138,33 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 	struct page *pg;
 	struct inode *inode = mapping->host;
 	struct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);
-	struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
-	struct jffs2_raw_inode ri;
-	uint32_t alloc_len = 0;
 	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
 	uint32_t pageofs = index << PAGE_CACHE_SHIFT;
 	int ret = 0;
 
-	jffs2_dbg(1, "%s()\n", __func__);
-
-	if (pageofs > inode->i_size) {
-		ret = jffs2_reserve_space(c, sizeof(ri), &alloc_len,
-					  ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);
-		if (ret)
-			return ret;
-	}
-
-	mutex_lock(&f->sem);
 	pg = grab_cache_page_write_begin(mapping, index, flags);
-	if (!pg) {
-		if (alloc_len)
-			jffs2_complete_reservation(c);
-		mutex_unlock(&f->sem);
+	if (!pg)
 		return -ENOMEM;
-	}
 	*pagep = pg;
 
-	if (alloc_len) {
+	jffs2_dbg(1, "%s()\n", __func__);
+
+	if (pageofs > inode->i_size) {
 		/* Make new hole frag from old EOF to new page */
+		struct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);
+		struct jffs2_raw_inode ri;
 		struct jffs2_full_dnode *fn;
+		uint32_t alloc_len;
 
 		jffs2_dbg(1, "Writing new hole frag 0x%x-0x%x between current EOF and new page\n",
 			  (unsigned int)inode->i_size, pageofs);
 
+		ret = jffs2_reserve_space(c, sizeof(ri), &alloc_len,
+					  ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);
+		if (ret)
+			goto out_page;
+
+		mutex_lock(&f->sem);
 		memset(&ri, 0, sizeof(ri));
 
 		ri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
@@ -197,6 +191,7 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 		if (IS_ERR(fn)) {
 			ret = PTR_ERR(fn);
 			jffs2_complete_reservation(c);
+			mutex_unlock(&f->sem);
 			goto out_page;
 		}
 		ret = jffs2_add_full_dnode_to_inode(c, f, fn);
@@ -211,10 +206,12 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 			jffs2_mark_node_obsolete(c, fn->raw);
 			jffs2_free_full_dnode(fn);
 			jffs2_complete_reservation(c);
+			mutex_unlock(&f->sem);
 			goto out_page;
 		}
 		jffs2_complete_reservation(c);
 		inode->i_size = pageofs;
+		mutex_unlock(&f->sem);
 	}
 
 	/*
@@ -223,18 +220,18 @@ static int jffs2_write_begin(struct file *filp, struct address_space *mapping,
 	 * case of a short-copy.
 	 */
 	if (!PageUptodate(pg)) {
+		mutex_lock(&f->sem);
 		ret = jffs2_do_readpage_nolock(inode, pg);
+		mutex_unlock(&f->sem);
 		if (ret)
 			goto out_page;
 	}
-	mutex_unlock(&f->sem);
 	jffs2_dbg(1, "end write_begin(). pg->flags %lx\n", pg->flags);
 	return ret;
 
 out_page:
 	unlock_page(pg);
 	page_cache_release(pg);
-	mutex_unlock(&f->sem);
 	return ret;
 }
 
diff --git a/fs/jffs2/gc.c b/fs/jffs2/gc.c
index 5a2dec2..95d5880 100644
--- a/fs/jffs2/gc.c
+++ b/fs/jffs2/gc.c
@@ -1296,14 +1296,17 @@ static int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_era
 		BUG_ON(start > orig_start);
 	}
 
-	/* First, use readpage() to read the appropriate page into the page cache */
-	/* Q: What happens if we actually try to GC the _same_ page for which commit_write()
-	 *    triggered garbage collection in the first place?
-	 * A: I _think_ it's OK. read_cache_page shouldn't deadlock, we'll write out the
-	 *    page OK. We'll actually write it out again in commit_write, which is a little
-	 *    suboptimal, but at least we're correct.
-	 */
+	/* The rules state that we must obtain the page lock *before* f->sem, so
+	 * drop f->sem temporarily. Since we also hold c->alloc_sem, nothing's
+	 * actually going to *change* so we're safe; we only allow reading.
+	 *
+	 * It is important to note that jffs2_write_begin() will ensure that its
+	 * page is marked Uptodate before allocating space. That means that if we
+	 * end up here trying to GC the *same* page that jffs2_write_begin() is
+	 * trying to write out, read_cache_page() will not deadlock. */
+	mutex_unlock(&f->sem);
 	pg_ptr = jffs2_gc_fetch_page(c, f, start, &pg);
+	mutex_lock(&f->sem);
 
 	if (IS_ERR(pg_ptr)) {
 		pr_warn("read_cache_page() returned error: %ld\n",
diff --git a/fs/jffs2/nodelist.h b/fs/jffs2/nodelist.h
index fa35ff7..0637271 100644
--- a/fs/jffs2/nodelist.h
+++ b/fs/jffs2/nodelist.h
@@ -194,6 +194,7 @@ struct jffs2_inode_cache {
 #define INO_STATE_CLEARING	6	/* In clear_inode() */
 
 #define INO_FLAGS_XATTR_CHECKED	0x01	/* has no duplicate xattr_ref */
+#define INO_FLAGS_IS_DIR	0x02	/* is a directory */
 
 #define RAWNODE_CLASS_INODE_CACHE	0
 #define RAWNODE_CLASS_XATTR_DATUM	1
@@ -249,7 +250,10 @@ struct jffs2_readinode_info
 
 struct jffs2_full_dirent
 {
-	struct jffs2_raw_node_ref *raw;
+	union {
+		struct jffs2_raw_node_ref *raw;
+		struct jffs2_inode_cache *ic; /* Just during part of build */
+	};
 	struct jffs2_full_dirent *next;
 	uint32_t version;
 	uint32_t ino; /* == zero for unlink */
diff --git a/fs/jfs/jfs_dtree.c b/fs/jfs/jfs_dtree.c
index c450fdb..5d876b1 100644
--- a/fs/jfs/jfs_dtree.c
+++ b/fs/jfs/jfs_dtree.c
@@ -3103,7 +3103,7 @@ int jfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 				 * self "."
 				 */
 				filp->f_pos = 1;
-				if (filldir(dirent, ".", 1, 0, ip->i_ino,
+				if (filldir(dirent, ".", 1, 1, ip->i_ino,
 					    DT_DIR))
 					return 0;
 			}
@@ -3111,7 +3111,7 @@ int jfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 			 * parent ".."
 			 */
 			filp->f_pos = 2;
-			if (filldir(dirent, "..", 2, 1, PARENT(ip), DT_DIR))
+			if (filldir(dirent, "..", 2, 2, PARENT(ip), DT_DIR))
 				return 0;
 
 			/*
diff --git a/fs/libfs.c b/fs/libfs.c
index 916da8c..1299bd5 100644
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@ -104,18 +104,18 @@ loff_t dcache_dir_lseek(struct file *file, loff_t offset, int whence)
 
 			spin_lock(&dentry->d_lock);
 			/* d_lock not required for cursor */
-			list_del(&cursor->d_u.d_child);
+			list_del(&cursor->d_child);
 			p = dentry->d_subdirs.next;
 			while (n && p != &dentry->d_subdirs) {
 				struct dentry *next;
-				next = list_entry(p, struct dentry, d_u.d_child);
+				next = list_entry(p, struct dentry, d_child);
 				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
 				if (simple_positive(next))
 					n--;
 				spin_unlock(&next->d_lock);
 				p = p->next;
 			}
-			list_add_tail(&cursor->d_u.d_child, p);
+			list_add_tail(&cursor->d_child, p);
 			spin_unlock(&dentry->d_lock);
 		}
 	}
@@ -139,7 +139,7 @@ int dcache_readdir(struct file * filp, void * dirent, filldir_t filldir)
 {
 	struct dentry *dentry = filp->f_path.dentry;
 	struct dentry *cursor = filp->private_data;
-	struct list_head *p, *q = &cursor->d_u.d_child;
+	struct list_head *p, *q = &cursor->d_child;
 	ino_t ino;
 	int i = filp->f_pos;
 
@@ -165,7 +165,7 @@ int dcache_readdir(struct file * filp, void * dirent, filldir_t filldir)
 
 			for (p=q->next; p != &dentry->d_subdirs; p=p->next) {
 				struct dentry *next;
-				next = list_entry(p, struct dentry, d_u.d_child);
+				next = list_entry(p, struct dentry, d_child);
 				spin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);
 				if (!simple_positive(next)) {
 					spin_unlock(&next->d_lock);
@@ -289,7 +289,7 @@ int simple_empty(struct dentry *dentry)
 	int ret = 0;
 
 	spin_lock(&dentry->d_lock);
-	list_for_each_entry(child, &dentry->d_subdirs, d_u.d_child) {
+	list_for_each_entry(child, &dentry->d_subdirs, d_child) {
 		spin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);
 		if (simple_positive(child)) {
 			spin_unlock(&child->d_lock);
diff --git a/fs/lockd/host.c b/fs/lockd/host.c
index 969d589..b5f3c3ab 100644
--- a/fs/lockd/host.c
+++ b/fs/lockd/host.c
@@ -116,7 +116,7 @@ static struct nlm_host *nlm_alloc_host(struct nlm_lookup_host_info *ni,
 		atomic_inc(&nsm->sm_count);
 	else {
 		host = NULL;
-		nsm = nsm_get_handle(ni->sap, ni->salen,
+		nsm = nsm_get_handle(ni->net, ni->sap, ni->salen,
 					ni->hostname, ni->hostname_len);
 		if (unlikely(nsm == NULL)) {
 			dprintk("lockd: %s failed; no nsm handle\n",
@@ -534,17 +534,18 @@ static struct nlm_host *next_host_state(struct hlist_head *cache,
 
 /**
  * nlm_host_rebooted - Release all resources held by rebooted host
+ * @net:  network namespace
  * @info: pointer to decoded results of NLM_SM_NOTIFY call
  *
  * We were notified that the specified host has rebooted.  Release
  * all resources held by that peer.
  */
-void nlm_host_rebooted(const struct nlm_reboot *info)
+void nlm_host_rebooted(const struct net *net, const struct nlm_reboot *info)
 {
 	struct nsm_handle *nsm;
 	struct nlm_host	*host;
 
-	nsm = nsm_reboot_lookup(info);
+	nsm = nsm_reboot_lookup(net, info);
 	if (unlikely(nsm == NULL))
 		return;
 
diff --git a/fs/lockd/mon.c b/fs/lockd/mon.c
index 6ae664b..13fac49 100644
--- a/fs/lockd/mon.c
+++ b/fs/lockd/mon.c
@@ -51,7 +51,6 @@ struct nsm_res {
 };
 
 static const struct rpc_program	nsm_program;
-static				LIST_HEAD(nsm_handles);
 static				DEFINE_SPINLOCK(nsm_lock);
 
 /*
@@ -259,33 +258,35 @@ void nsm_unmonitor(const struct nlm_host *host)
 	}
 }
 
-static struct nsm_handle *nsm_lookup_hostname(const char *hostname,
-					      const size_t len)
+static struct nsm_handle *nsm_lookup_hostname(const struct list_head *nsm_handles,
+					const char *hostname, const size_t len)
 {
 	struct nsm_handle *nsm;
 
-	list_for_each_entry(nsm, &nsm_handles, sm_link)
+	list_for_each_entry(nsm, nsm_handles, sm_link)
 		if (strlen(nsm->sm_name) == len &&
 		    memcmp(nsm->sm_name, hostname, len) == 0)
 			return nsm;
 	return NULL;
 }
 
-static struct nsm_handle *nsm_lookup_addr(const struct sockaddr *sap)
+static struct nsm_handle *nsm_lookup_addr(const struct list_head *nsm_handles,
+					const struct sockaddr *sap)
 {
 	struct nsm_handle *nsm;
 
-	list_for_each_entry(nsm, &nsm_handles, sm_link)
+	list_for_each_entry(nsm, nsm_handles, sm_link)
 		if (rpc_cmp_addr(nsm_addr(nsm), sap))
 			return nsm;
 	return NULL;
 }
 
-static struct nsm_handle *nsm_lookup_priv(const struct nsm_private *priv)
+static struct nsm_handle *nsm_lookup_priv(const struct list_head *nsm_handles,
+					const struct nsm_private *priv)
 {
 	struct nsm_handle *nsm;
 
-	list_for_each_entry(nsm, &nsm_handles, sm_link)
+	list_for_each_entry(nsm, nsm_handles, sm_link)
 		if (memcmp(nsm->sm_priv.data, priv->data,
 					sizeof(priv->data)) == 0)
 			return nsm;
@@ -350,6 +351,7 @@ static struct nsm_handle *nsm_create_handle(const struct sockaddr *sap,
 
 /**
  * nsm_get_handle - Find or create a cached nsm_handle
+ * @net: network namespace
  * @sap: pointer to socket address of handle to find
  * @salen: length of socket address
  * @hostname: pointer to C string containing hostname to find
@@ -362,11 +364,13 @@ static struct nsm_handle *nsm_create_handle(const struct sockaddr *sap,
  * @hostname cannot be found in the handle cache.  Returns NULL if
  * an error occurs.
  */
-struct nsm_handle *nsm_get_handle(const struct sockaddr *sap,
+struct nsm_handle *nsm_get_handle(const struct net *net,
+				  const struct sockaddr *sap,
 				  const size_t salen, const char *hostname,
 				  const size_t hostname_len)
 {
 	struct nsm_handle *cached, *new = NULL;
+	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 	if (hostname && memchr(hostname, '/', hostname_len) != NULL) {
 		if (printk_ratelimit()) {
@@ -381,9 +385,10 @@ retry:
 	spin_lock(&nsm_lock);
 
 	if (nsm_use_hostnames && hostname != NULL)
-		cached = nsm_lookup_hostname(hostname, hostname_len);
+		cached = nsm_lookup_hostname(&ln->nsm_handles,
+					hostname, hostname_len);
 	else
-		cached = nsm_lookup_addr(sap);
+		cached = nsm_lookup_addr(&ln->nsm_handles, sap);
 
 	if (cached != NULL) {
 		atomic_inc(&cached->sm_count);
@@ -397,7 +402,7 @@ retry:
 	}
 
 	if (new != NULL) {
-		list_add(&new->sm_link, &nsm_handles);
+		list_add(&new->sm_link, &ln->nsm_handles);
 		spin_unlock(&nsm_lock);
 		dprintk("lockd: created nsm_handle for %s (%s)\n",
 				new->sm_name, new->sm_addrbuf);
@@ -414,19 +419,22 @@ retry:
 
 /**
  * nsm_reboot_lookup - match NLMPROC_SM_NOTIFY arguments to an nsm_handle
+ * @net:  network namespace
  * @info: pointer to NLMPROC_SM_NOTIFY arguments
  *
  * Returns a matching nsm_handle if found in the nsm cache. The returned
  * nsm_handle's reference count is bumped. Otherwise returns NULL if some
  * error occurred.
  */
-struct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info)
+struct nsm_handle *nsm_reboot_lookup(const struct net *net,
+				const struct nlm_reboot *info)
 {
 	struct nsm_handle *cached;
+	struct lockd_net *ln = net_generic(net, lockd_net_id);
 
 	spin_lock(&nsm_lock);
 
-	cached = nsm_lookup_priv(&info->priv);
+	cached = nsm_lookup_priv(&ln->nsm_handles, &info->priv);
 	if (unlikely(cached == NULL)) {
 		spin_unlock(&nsm_lock);
 		dprintk("lockd: never saw rebooted peer '%.*s' before\n",
diff --git a/fs/lockd/netns.h b/fs/lockd/netns.h
index 5010b55..414da99 100644
--- a/fs/lockd/netns.h
+++ b/fs/lockd/netns.h
@@ -16,6 +16,7 @@ struct lockd_net {
 	spinlock_t nsm_clnt_lock;
 	unsigned int nsm_users;
 	struct rpc_clnt *nsm_clnt;
+	struct list_head nsm_handles;
 };
 
 extern int lockd_net_id;
diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index 7a31848..ce05c60 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -583,6 +583,7 @@ static int lockd_init_net(struct net *net)
 	INIT_DELAYED_WORK(&ln->grace_period_end, grace_ender);
 	INIT_LIST_HEAD(&ln->grace_list);
 	spin_lock_init(&ln->nsm_clnt_lock);
+	INIT_LIST_HEAD(&ln->nsm_handles);
 	return 0;
 }
 
diff --git a/fs/lockd/svc4proc.c b/fs/lockd/svc4proc.c
index b147d1a..09c576f 100644
--- a/fs/lockd/svc4proc.c
+++ b/fs/lockd/svc4proc.c
@@ -421,7 +421,7 @@ nlm4svc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,
 		return rpc_system_err;
 	}
 
-	nlm_host_rebooted(argp);
+	nlm_host_rebooted(SVC_NET(rqstp), argp);
 	return rpc_success;
 }
 
diff --git a/fs/lockd/svcproc.c b/fs/lockd/svcproc.c
index 21171f0..fb26b9f 100644
--- a/fs/lockd/svcproc.c
+++ b/fs/lockd/svcproc.c
@@ -464,7 +464,7 @@ nlmsvc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,
 		return rpc_system_err;
 	}
 
-	nlm_host_rebooted(argp);
+	nlm_host_rebooted(SVC_NET(rqstp), argp);
 	return rpc_success;
 }
 
diff --git a/fs/locks.c b/fs/locks.c
index 0274c95..f7b1de7 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1852,7 +1852,6 @@ int fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,
 		goto out;
 	}
 
-again:
 	error = flock_to_posix_lock(filp, file_lock, &flock);
 	if (error)
 		goto out;
@@ -1883,19 +1882,22 @@ again:
 	 * Attempt to detect a close/fcntl race and recover by
 	 * releasing the lock that was just acquired.
 	 */
-	/*
-	 * we need that spin_lock here - it prevents reordering between
-	 * update of inode->i_flock and check for it done in close().
-	 * rcu_read_lock() wouldn't do.
-	 */
-	spin_lock(&current->files->file_lock);
-	f = fcheck(fd);
-	spin_unlock(&current->files->file_lock);
-	if (!error && f != filp && flock.l_type != F_UNLCK) {
-		flock.l_type = F_UNLCK;
-		goto again;
+	if (!error && file_lock->fl_type != F_UNLCK) {
+		/*
+		 * We need that spin_lock here - it prevents reordering between
+		 * update of inode->i_flock and check for it done in
+		 * close(). rcu_read_lock() wouldn't do.
+		 */
+		spin_lock(&current->files->file_lock);
+		f = fcheck(fd);
+		spin_unlock(&current->files->file_lock);
+		if (f != filp) {
+			file_lock->fl_type = F_UNLCK;
+			error = do_lock_file_wait(filp, cmd, file_lock);
+			WARN_ON_ONCE(error);
+			error = -EBADF;
+		}
 	}
-
 out:
 	locks_free_lock(file_lock);
 	return error;
@@ -1970,7 +1972,6 @@ int fcntl_setlk64(unsigned int fd, struct file *filp, unsigned int cmd,
 		goto out;
 	}
 
-again:
 	error = flock64_to_posix_lock(filp, file_lock, &flock);
 	if (error)
 		goto out;
@@ -2001,14 +2002,22 @@ again:
 	 * Attempt to detect a close/fcntl race and recover by
 	 * releasing the lock that was just acquired.
 	 */
-	spin_lock(&current->files->file_lock);
-	f = fcheck(fd);
-	spin_unlock(&current->files->file_lock);
-	if (!error && f != filp && flock.l_type != F_UNLCK) {
-		flock.l_type = F_UNLCK;
-		goto again;
+	if (!error && file_lock->fl_type != F_UNLCK) {
+		/*
+		 * We need that spin_lock here - it prevents reordering between
+		 * update of inode->i_flock and check for it done in
+		 * close(). rcu_read_lock() wouldn't do.
+		 */
+		spin_lock(&current->files->file_lock);
+		f = fcheck(fd);
+		spin_unlock(&current->files->file_lock);
+		if (f != filp) {
+			file_lock->fl_type = F_UNLCK;
+			error = do_lock_file_wait(filp, cmd, file_lock);
+			WARN_ON_ONCE(error);
+			error = -EBADF;
+		}
 	}
-
 out:
 	locks_free_lock(file_lock);
 	return error;
diff --git a/fs/namei.c b/fs/namei.c
index f7c4393..c87e15e 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -473,6 +473,24 @@ void path_put(const struct path *path)
 }
 EXPORT_SYMBOL(path_put);
 
+/**
+ * path_connected - Verify that a path->dentry is below path->mnt.mnt_root
+ * @path: nameidate to verify
+ *
+ * Rename can sometimes move a file or directory outside of a bind
+ * mount, path_connected allows those cases to be detected.
+ */
+static bool path_connected(const struct path *path)
+{
+	struct vfsmount *mnt = path->mnt;
+
+	/* Only bind mounts can have disconnected paths */
+	if (mnt->mnt_root == mnt->mnt_sb->s_root)
+		return true;
+
+	return is_subdir(path->dentry, mnt->mnt_root);
+}
+
 /*
  * Path walking has 2 modes, rcu-walk and ref-walk (see
  * Documentation/filesystems/path-lookup.txt).  In situations when we can't
@@ -1148,6 +1166,8 @@ static int follow_dotdot_rcu(struct nameidata *nd)
 				goto failed;
 			nd->path.dentry = parent;
 			nd->seq = seq;
+			if (unlikely(!path_connected(&nd->path)))
+				goto failed;
 			break;
 		}
 		if (!follow_up_rcu(&nd->path))
@@ -1231,7 +1251,7 @@ static void follow_mount(struct path *path)
 	}
 }
 
-static void follow_dotdot(struct nameidata *nd)
+static int follow_dotdot(struct nameidata *nd)
 {
 	set_root(nd);
 
@@ -1246,6 +1266,10 @@ static void follow_dotdot(struct nameidata *nd)
 			/* rare case of legitimate dget_parent()... */
 			nd->path.dentry = dget_parent(nd->path.dentry);
 			dput(old);
+			if (unlikely(!path_connected(&nd->path))) {
+				path_put(&nd->path);
+				return -ENOENT;
+			}
 			break;
 		}
 		if (!follow_up(&nd->path))
@@ -1253,6 +1277,7 @@ static void follow_dotdot(struct nameidata *nd)
 	}
 	follow_mount(&nd->path);
 	nd->inode = nd->path.dentry->d_inode;
+	return 0;
 }
 
 /*
@@ -1476,7 +1501,7 @@ static inline int handle_dots(struct nameidata *nd, int type)
 			if (follow_dotdot_rcu(nd))
 				return -ECHILD;
 		} else
-			follow_dotdot(nd);
+			return follow_dotdot(nd);
 	}
 	return 0;
 }
@@ -1542,7 +1567,8 @@ static inline int walk_component(struct nameidata *nd, struct path *path,
 
 	if (should_follow_link(inode, follow)) {
 		if (nd->flags & LOOKUP_RCU) {
-			if (unlikely(unlazy_walk(nd, path->dentry))) {
+			if (unlikely(nd->path.mnt != path->mnt ||
+				     unlazy_walk(nd, path->dentry))) {
 				err = -ECHILD;
 				goto out_err;
 			}
@@ -2824,7 +2850,8 @@ finish_lookup:
 
 	if (should_follow_link(inode, !symlink_ok)) {
 		if (nd->flags & LOOKUP_RCU) {
-			if (unlikely(unlazy_walk(nd, path->dentry))) {
+			if (unlikely(nd->path.mnt != path->mnt ||
+				     unlazy_walk(nd, path->dentry))) {
 				error = -ECHILD;
 				goto out;
 			}
@@ -2890,6 +2917,10 @@ opened:
 			goto exit_fput;
 	}
 out:
+	if (unlikely(error > 0)) {
+		WARN_ON(1);
+		error = -EINVAL;
+	}
 	if (got_write)
 		mnt_drop_write(nd->path.mnt);
 	path_put(&save_parent);
diff --git a/fs/ncpfs/dir.c b/fs/ncpfs/dir.c
index 6792ce1..c578ba9 100644
--- a/fs/ncpfs/dir.c
+++ b/fs/ncpfs/dir.c
@@ -391,7 +391,7 @@ ncp_dget_fpos(struct dentry *dentry, struct dentry *parent, unsigned long fpos)
 	spin_lock(&parent->d_lock);
 	next = parent->d_subdirs.next;
 	while (next != &parent->d_subdirs) {
-		dent = list_entry(next, struct dentry, d_u.d_child);
+		dent = list_entry(next, struct dentry, d_child);
 		if ((unsigned long)dent->d_fsdata == fpos) {
 			if (dent->d_inode)
 				dget(dent);
diff --git a/fs/ncpfs/ncplib_kernel.h b/fs/ncpfs/ncplib_kernel.h
index 32c0658..6d5e7c5 100644
--- a/fs/ncpfs/ncplib_kernel.h
+++ b/fs/ncpfs/ncplib_kernel.h
@@ -194,7 +194,7 @@ ncp_renew_dentries(struct dentry *parent)
 	spin_lock(&parent->d_lock);
 	next = parent->d_subdirs.next;
 	while (next != &parent->d_subdirs) {
-		dentry = list_entry(next, struct dentry, d_u.d_child);
+		dentry = list_entry(next, struct dentry, d_child);
 
 		if (dentry->d_fsdata == NULL)
 			ncp_age_dentry(server, dentry);
@@ -216,7 +216,7 @@ ncp_invalidate_dircache_entries(struct dentry *parent)
 	spin_lock(&parent->d_lock);
 	next = parent->d_subdirs.next;
 	while (next != &parent->d_subdirs) {
-		dentry = list_entry(next, struct dentry, d_u.d_child);
+		dentry = list_entry(next, struct dentry, d_child);
 		dentry->d_fsdata = NULL;
 		ncp_age_dentry(server, dentry);
 		next = next->next;
diff --git a/fs/nfs/getroot.c b/fs/nfs/getroot.c
index 44efaa8..0fe3ced 100644
--- a/fs/nfs/getroot.c
+++ b/fs/nfs/getroot.c
@@ -58,7 +58,7 @@ static int nfs_superblock_set_dummy_root(struct super_block *sb, struct inode *i
 		 */
 		spin_lock(&sb->s_root->d_inode->i_lock);
 		spin_lock(&sb->s_root->d_lock);
-		hlist_del_init(&sb->s_root->d_alias);
+		hlist_del_init(&sb->s_root->d_u.d_alias);
 		spin_unlock(&sb->s_root->d_lock);
 		spin_unlock(&sb->s_root->d_inode->i_lock);
 	}
diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c
index e9be01b..02c6ead 100644
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -1503,7 +1503,11 @@ static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)
 			nfsi->attrtimeo_timestamp = now;
 		}
 	}
-	invalid &= ~NFS_INO_INVALID_ATTR;
+
+	/* Don't declare attrcache up to date if there were no attrs! */
+	if (fattr->valid != 0)
+		invalid &= ~NFS_INO_INVALID_ATTR;
+
 	/* Don't invalidate the data if we were to blame */
 	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)
 				|| S_ISLNK(inode->i_mode)))
diff --git a/fs/nfs/nfs3xdr.c b/fs/nfs/nfs3xdr.c
index fa6d721..4495cad 100644
--- a/fs/nfs/nfs3xdr.c
+++ b/fs/nfs/nfs3xdr.c
@@ -1342,7 +1342,7 @@ static void nfs3_xdr_enc_setacl3args(struct rpc_rqst *req,
 	if (args->npages != 0)
 		xdr_write_pages(xdr, args->pages, 0, args->len);
 	else
-		xdr_reserve_space(xdr, NFS_ACL_INLINE_BUFSIZE);
+		xdr_reserve_space(xdr, args->len);
 
 	error = nfsacl_encode(xdr->buf, base, args->inode,
 			    (args->mask & NFS_ACL) ?
diff --git a/fs/nfs/nfs4client.c b/fs/nfs/nfs4client.c
index 5f8d5ff..498811c 100644
--- a/fs/nfs/nfs4client.c
+++ b/fs/nfs/nfs4client.c
@@ -32,7 +32,7 @@ static int nfs_get_cb_ident_idr(struct nfs_client *clp, int minorversion)
 		return ret;
 	idr_preload(GFP_KERNEL);
 	spin_lock(&nn->nfs_client_lock);
-	ret = idr_alloc(&nn->cb_ident_idr, clp, 0, 0, GFP_NOWAIT);
+	ret = idr_alloc(&nn->cb_ident_idr, clp, 1, 0, GFP_NOWAIT);
 	if (ret >= 0)
 		clp->cl_cb_ident = ret;
 	spin_unlock(&nn->nfs_client_lock);
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 20ebcfa..c2b89a1 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -1005,6 +1005,7 @@ static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_s
 	 * Protect the call to nfs4_state_set_mode_locked and
 	 * serialise the stateid update
 	 */
+	spin_lock(&state->owner->so_lock);
 	write_seqlock(&state->seqlock);
 	if (deleg_stateid != NULL) {
 		nfs4_stateid_copy(&state->stateid, deleg_stateid);
@@ -1013,7 +1014,6 @@ static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_s
 	if (open_stateid != NULL)
 		nfs_set_open_stateid_locked(state, open_stateid, fmode);
 	write_sequnlock(&state->seqlock);
-	spin_lock(&state->owner->so_lock);
 	update_open_stateflags(state, fmode);
 	spin_unlock(&state->owner->so_lock);
 }
@@ -2043,7 +2043,7 @@ static int _nfs4_do_open(struct inode *dir,
 	if (status != 0)
 		goto err_opendata_put;
 
-	if ((opendata->o_arg.open_flags & O_EXCL) &&
+	if ((opendata->o_arg.open_flags & (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL) &&
 	    (opendata->o_arg.createmode != NFS4_CREATE_GUARDED)) {
 		nfs4_exclusive_attrset(opendata, sattr);
 
@@ -2332,12 +2332,11 @@ static void nfs4_close_prepare(struct rpc_task *task, void *data)
 			call_close |= is_wronly;
 		else if (is_wronly)
 			calldata->arg.fmode |= FMODE_WRITE;
+		if (calldata->arg.fmode != (FMODE_READ|FMODE_WRITE))
+			call_close |= is_rdwr;
 	} else if (is_rdwr)
 		calldata->arg.fmode |= FMODE_READ|FMODE_WRITE;
 
-	if (calldata->arg.fmode == 0)
-		call_close |= is_rdwr;
-
 	if (!nfs4_valid_open_stateid(state))
 		call_close = 0;
 	spin_unlock(&state->owner->so_lock);
diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c
index d482b86..2bdaf57 100644
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@ -1452,6 +1452,8 @@ restart:
 				}
 				spin_unlock(&state->state_lock);
 				nfs4_put_open_state(state);
+				clear_bit(NFS_STATE_RECLAIM_NOGRACE,
+					&state->flags);
 				spin_lock(&sp->so_lock);
 				goto restart;
 			}
diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c
index 29cfb7a..d852ca2 100644
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@ -60,8 +60,8 @@ EXPORT_SYMBOL_GPL(nfs_pgheader_init);
 void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos)
 {
 	spin_lock(&hdr->lock);
-	if (pos < hdr->io_start + hdr->good_bytes) {
-		set_bit(NFS_IOHDR_ERROR, &hdr->flags);
+	if (!test_and_set_bit(NFS_IOHDR_ERROR, &hdr->flags)
+	    || pos < hdr->io_start + hdr->good_bytes) {
 		clear_bit(NFS_IOHDR_EOF, &hdr->flags);
 		hdr->good_bytes = pos - hdr->io_start;
 		hdr->error = error;
diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c
index ecdbae1..090d8ce 100644
--- a/fs/nilfs2/btree.c
+++ b/fs/nilfs2/btree.c
@@ -388,7 +388,7 @@ static int nilfs_btree_root_broken(const struct nilfs_btree_node *node,
 	nchildren = nilfs_btree_node_get_nchildren(node);
 
 	if (unlikely(level < NILFS_BTREE_LEVEL_NODE_MIN ||
-		     level > NILFS_BTREE_LEVEL_MAX ||
+		     level >= NILFS_BTREE_LEVEL_MAX ||
 		     nchildren < 0 ||
 		     nchildren > NILFS_BTREE_ROOT_NCHILDREN_MAX)) {
 		pr_crit("NILFS: bad btree root (inode number=%lu): level = %d, flags = 0x%x, nchildren = %d\n",
diff --git a/fs/nilfs2/the_nilfs.c b/fs/nilfs2/the_nilfs.c
index 41e6a04..0f9a5b4 100644
--- a/fs/nilfs2/the_nilfs.c
+++ b/fs/nilfs2/the_nilfs.c
@@ -431,7 +431,7 @@ static int nilfs_valid_sb(struct nilfs_super_block *sbp)
 	if (!sbp || le16_to_cpu(sbp->s_magic) != NILFS_SUPER_MAGIC)
 		return 0;
 	bytes = le16_to_cpu(sbp->s_bytes);
-	if (bytes > BLOCK_SIZE)
+	if (bytes < sumoff + 4 || bytes > BLOCK_SIZE)
 		return 0;
 	crc = crc32_le(le32_to_cpu(sbp->s_crc_seed), (unsigned char *)sbp,
 		       sumoff);
diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.c
index 4bb21d6..a3153e2 100644
--- a/fs/notify/fsnotify.c
+++ b/fs/notify/fsnotify.c
@@ -63,14 +63,14 @@ void __fsnotify_update_child_dentry_flags(struct inode *inode)
 	spin_lock(&inode->i_lock);
 	/* run all of the dentries associated with this inode.  Since this is a
 	 * directory, there damn well better only be one item on this list */
-	hlist_for_each_entry(alias, &inode->i_dentry, d_alias) {
+	hlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {
 		struct dentry *child;
 
 		/* run all of the children of the original inode and fix their
 		 * d_flags to indicate parental interest (their parent is the
 		 * original inode) */
 		spin_lock(&alias->d_lock);
-		list_for_each_entry(child, &alias->d_subdirs, d_u.d_child) {
+		list_for_each_entry(child, &alias->d_subdirs, d_child) {
 			if (!child->d_inode)
 				continue;
 
diff --git a/fs/notify/mark.c b/fs/notify/mark.c
index fc6b49b..f08b3b7 100644
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@ -299,16 +299,36 @@ void fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group,
 					 unsigned int flags)
 {
 	struct fsnotify_mark *lmark, *mark;
+	LIST_HEAD(to_free);
 
+	/*
+	 * We have to be really careful here. Anytime we drop mark_mutex, e.g.
+	 * fsnotify_clear_marks_by_inode() can come and free marks. Even in our
+	 * to_free list so we have to use mark_mutex even when accessing that
+	 * list. And freeing mark requires us to drop mark_mutex. So we can
+	 * reliably free only the first mark in the list. That's why we first
+	 * move marks to free to to_free list in one go and then free marks in
+	 * to_free list one by one.
+	 */
 	mutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);
 	list_for_each_entry_safe(mark, lmark, &group->marks_list, g_list) {
-		if (mark->flags & flags) {
-			fsnotify_get_mark(mark);
-			fsnotify_destroy_mark_locked(mark, group);
-			fsnotify_put_mark(mark);
-		}
+		if (mark->flags & flags)
+			list_move(&mark->g_list, &to_free);
 	}
 	mutex_unlock(&group->mark_mutex);
+
+	while (1) {
+		mutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);
+		if (list_empty(&to_free)) {
+			mutex_unlock(&group->mark_mutex);
+			break;
+		}
+		mark = list_first_entry(&to_free, struct fsnotify_mark, g_list);
+		fsnotify_get_mark(mark);
+		fsnotify_destroy_mark_locked(mark, group);
+		mutex_unlock(&group->mark_mutex);
+		fsnotify_put_mark(mark);
+	}
 }
 
 /*
diff --git a/fs/ocfs2/dcache.c b/fs/ocfs2/dcache.c
index ef99972..ce37013 100644
--- a/fs/ocfs2/dcache.c
+++ b/fs/ocfs2/dcache.c
@@ -172,7 +172,7 @@ struct dentry *ocfs2_find_local_alias(struct inode *inode,
 	struct dentry *dentry;
 
 	spin_lock(&inode->i_lock);
-	hlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {
+	hlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {
 		spin_lock(&dentry->d_lock);
 		if (ocfs2_match_dentry(dentry, parent_blkno, skip_unhashed)) {
 			trace_ocfs2_find_local_alias(dentry->d_name.len,
diff --git a/fs/ocfs2/dlm/dlmconvert.c b/fs/ocfs2/dlm/dlmconvert.c
index 29a886d..f65bdcf 100644
--- a/fs/ocfs2/dlm/dlmconvert.c
+++ b/fs/ocfs2/dlm/dlmconvert.c
@@ -265,6 +265,7 @@ enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,
 				  struct dlm_lock *lock, int flags, int type)
 {
 	enum dlm_status status;
+	u8 old_owner = res->owner;
 
 	mlog(0, "type=%d, convert_type=%d, busy=%d\n", lock->ml.type,
 	     lock->ml.convert_type, res->state & DLM_LOCK_RES_IN_PROGRESS);
@@ -290,6 +291,19 @@ enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,
 		status = DLM_DENIED;
 		goto bail;
 	}
+
+	if (lock->ml.type == type && lock->ml.convert_type == LKM_IVMODE) {
+		mlog(0, "last convert request returned DLM_RECOVERING, but "
+		     "owner has already queued and sent ast to me. res %.*s, "
+		     "(cookie=%u:%llu, type=%d, conv=%d)\n",
+		     res->lockname.len, res->lockname.name,
+		     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),
+		     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),
+		     lock->ml.type, lock->ml.convert_type);
+		status = DLM_NORMAL;
+		goto bail;
+	}
+
 	res->state |= DLM_LOCK_RES_IN_PROGRESS;
 	/* move lock to local convert queue */
 	/* do not alter lock refcount.  switching lists. */
@@ -319,11 +333,19 @@ enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,
 	spin_lock(&res->spinlock);
 	res->state &= ~DLM_LOCK_RES_IN_PROGRESS;
 	lock->convert_pending = 0;
-	/* if it failed, move it back to granted queue */
+	/* if it failed, move it back to granted queue.
+	 * if master returns DLM_NORMAL and then down before sending ast,
+	 * it may have already been moved to granted queue, reset to
+	 * DLM_RECOVERING and retry convert */
 	if (status != DLM_NORMAL) {
 		if (status != DLM_NOTQUEUED)
 			dlm_error(status);
 		dlm_revert_pending_convert(res, lock);
+	} else if ((res->state & DLM_LOCK_RES_RECOVERING) ||
+			(old_owner != res->owner)) {
+		mlog(0, "res %.*s is in recovering or has been recovered.\n",
+				res->lockname.len, res->lockname.name);
+		status = DLM_RECOVERING;
 	}
 bail:
 	spin_unlock(&res->spinlock);
diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c
index 2b94111..d084200 100644
--- a/fs/ocfs2/dlm/dlmmaster.c
+++ b/fs/ocfs2/dlm/dlmmaster.c
@@ -729,6 +729,19 @@ lookup:
 	if (tmpres) {
 		spin_unlock(&dlm->spinlock);
 		spin_lock(&tmpres->spinlock);
+
+		/*
+		 * Right after dlm spinlock was released, dlm_thread could have
+		 * purged the lockres. Check if lockres got unhashed. If so
+		 * start over.
+		 */
+		if (hlist_unhashed(&tmpres->hash_node)) {
+			spin_unlock(&tmpres->spinlock);
+			dlm_lockres_put(tmpres);
+			tmpres = NULL;
+			goto lookup;
+		}
+
 		/* Wait on the thread that is mastering the resource */
 		if (tmpres->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {
 			__dlm_wait_on_lockres(tmpres);
@@ -2443,6 +2456,11 @@ static int dlm_migrate_lockres(struct dlm_ctxt *dlm,
 	spin_lock(&dlm->master_lock);
 	ret = dlm_add_migration_mle(dlm, res, mle, &oldmle, name,
 				    namelen, target, dlm->node_num);
+	/* get an extra reference on the mle.
+	 * otherwise the assert_master from the new
+	 * master will destroy this.
+	 */
+	dlm_get_mle_inuse(mle);
 	spin_unlock(&dlm->master_lock);
 	spin_unlock(&dlm->spinlock);
 
@@ -2478,6 +2496,7 @@ fail:
 		if (mle_added) {
 			dlm_mle_detach_hb_events(dlm, mle);
 			dlm_put_mle(mle);
+			dlm_put_mle_inuse(mle);
 		} else if (mle) {
 			kmem_cache_free(dlm_mle_cache, mle);
 			mle = NULL;
@@ -2495,17 +2514,6 @@ fail:
 	 * ensure that all assert_master work is flushed. */
 	flush_workqueue(dlm->dlm_worker);
 
-	/* get an extra reference on the mle.
-	 * otherwise the assert_master from the new
-	 * master will destroy this.
-	 * also, make sure that all callers of dlm_get_mle
-	 * take both dlm->spinlock and dlm->master_lock */
-	spin_lock(&dlm->spinlock);
-	spin_lock(&dlm->master_lock);
-	dlm_get_mle_inuse(mle);
-	spin_unlock(&dlm->master_lock);
-	spin_unlock(&dlm->spinlock);
-
 	/* notify new node and send all lock state */
 	/* call send_one_lockres with migration flag.
 	 * this serves as notice to the target node that a
@@ -3233,6 +3241,15 @@ top:
 			    mle->new_master != dead_node)
 				continue;
 
+			if (mle->new_master == dead_node && mle->inuse) {
+				mlog(ML_NOTICE, "%s: target %u died during "
+						"migration from %u, the MLE is "
+						"still keep used, ignore it!\n",
+						dlm->name, dead_node,
+						mle->master);
+				continue;
+			}
+
 			/* If we have reached this point, this mle needs to be
 			 * removed from the list and freed. */
 			dlm_clean_migration_mle(dlm, mle);
diff --git a/fs/ocfs2/dlm/dlmrecovery.c b/fs/ocfs2/dlm/dlmrecovery.c
index 9bd981c..33e9d70 100644
--- a/fs/ocfs2/dlm/dlmrecovery.c
+++ b/fs/ocfs2/dlm/dlmrecovery.c
@@ -2034,7 +2034,6 @@ void dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,
 			dlm_lock_get(lock);
 			if (lock->convert_pending) {
 				/* move converting lock back to granted */
-				BUG_ON(i != DLM_CONVERTING_LIST);
 				mlog(0, "node died with convert pending "
 				     "on %.*s. move back to granted list.\n",
 				     res->lockname.len, res->lockname.name);
@@ -2326,6 +2325,8 @@ static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node)
 						break;
 					}
 				}
+				dlm_lockres_clear_refmap_bit(dlm, res,
+						dead_node);
 				spin_unlock(&res->spinlock);
 				continue;
 			}
diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c
index 3a44a64..b294deb27 100644
--- a/fs/ocfs2/dlmglue.c
+++ b/fs/ocfs2/dlmglue.c
@@ -3971,9 +3971,13 @@ static void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)
 	osb->dc_work_sequence = osb->dc_wake_sequence;
 
 	processed = osb->blocked_lock_count;
-	while (processed) {
-		BUG_ON(list_empty(&osb->blocked_lock_list));
-
+	/*
+	 * blocked lock processing in this loop might call iput which can
+	 * remove items off osb->blocked_lock_list. Downconvert up to
+	 * 'processed' number of locks, but stop short if we had some
+	 * removed in ocfs2_mark_lockres_freeing when downconverting.
+	 */
+	while (processed && !list_empty(&osb->blocked_lock_list)) {
 		lockres = list_entry(osb->blocked_lock_list.next,
 				     struct ocfs2_lock_res, l_blocked_list);
 		list_del_init(&lockres->l_blocked_list);
diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c
index 46387e4..d0e8c0b 100644
--- a/fs/ocfs2/file.c
+++ b/fs/ocfs2/file.c
@@ -2372,10 +2372,14 @@ out_dio:
 	/* buffered aio wouldn't have proper lock coverage today */
 	BUG_ON(ret == -EIOCBQUEUED && !(file->f_flags & O_DIRECT));
 
+	if (unlikely(written <= 0))
+		goto no_sync;
+
 	if (((file->f_flags & O_DSYNC) && !direct_io) || IS_SYNC(inode) ||
 	    ((file->f_flags & O_DIRECT) && !direct_io)) {
-		ret = filemap_fdatawrite_range(file->f_mapping, *ppos,
-					       *ppos + count - 1);
+		ret = filemap_fdatawrite_range(file->f_mapping,
+					       iocb->ki_pos - written,
+					       iocb->ki_pos - 1);
 		if (ret < 0)
 			written = ret;
 
@@ -2388,10 +2392,12 @@ out_dio:
 		}
 
 		if (!ret)
-			ret = filemap_fdatawait_range(file->f_mapping, *ppos,
-						      *ppos + count - 1);
+			ret = filemap_fdatawait_range(file->f_mapping,
+						      iocb->ki_pos - written,
+						      iocb->ki_pos - 1);
 	}
 
+no_sync:
 	/*
 	 * deep in g_f_a_w_n()->ocfs2_direct_IO we pass in a ocfs2_dio_end_io
 	 * function pointer which is called when o_direct io completes so that
@@ -2453,12 +2459,14 @@ static ssize_t ocfs2_file_splice_write(struct pipe_inode_info *pipe,
 	struct address_space *mapping = out->f_mapping;
 	struct inode *inode = mapping->host;
 	struct splice_desc sd = {
-		.total_len = len,
 		.flags = flags,
-		.pos = *ppos,
 		.u.file = out,
 	};
-
+	ret = generic_write_checks(out, ppos, &len, 0);
+	if(ret)
+		return ret;
+	sd.total_len = len;
+	sd.pos = *ppos;
 
 	trace_ocfs2_file_splice_write(inode, out, out->f_path.dentry,
 			(unsigned long long)OCFS2_I(inode)->ip_blkno,
diff --git a/fs/omfs/inode.c b/fs/omfs/inode.c
index d8b0afd..2dba0ca 100644
--- a/fs/omfs/inode.c
+++ b/fs/omfs/inode.c
@@ -361,7 +361,7 @@ nomem:
 }
 
 enum {
-	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask
+	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask, Opt_err
 };
 
 static const match_table_t tokens = {
@@ -370,6 +370,7 @@ static const match_table_t tokens = {
 	{Opt_umask, "umask=%o"},
 	{Opt_dmask, "dmask=%o"},
 	{Opt_fmask, "fmask=%o"},
+	{Opt_err, NULL},
 };
 
 static int parse_options(char *options, struct omfs_sb_info *sbi)
diff --git a/fs/open.c b/fs/open.c
index 86092bd..5f129683 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -674,7 +674,6 @@ static int do_dentry_open(struct file *f,
 	}
 
 	f->f_mapping = inode->i_mapping;
-	file_sb_list_add(f, inode->i_sb);
 
 	if (unlikely(f->f_mode & FMODE_PATH)) {
 		f->f_op = &empty_fops;
@@ -709,7 +708,6 @@ static int do_dentry_open(struct file *f,
 
 cleanup_all:
 	fops_put(f->f_op);
-	file_sb_list_del(f);
 	if (f->f_mode & FMODE_WRITE) {
 		if (!special_file(inode->i_mode)) {
 			/*
diff --git a/fs/pipe.c b/fs/pipe.c
index 0e0752e..c281867 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -39,6 +39,12 @@ unsigned int pipe_max_size = 1048576;
  */
 unsigned int pipe_min_size = PAGE_SIZE;
 
+/* Maximum allocatable pages per user. Hard limit is unset by default, soft
+ * matches default values.
+ */
+unsigned long pipe_user_pages_hard;
+unsigned long pipe_user_pages_soft = PIPE_DEF_BUFFERS * INR_OPEN_CUR;
+
 /*
  * We use a start+len construction, which provides full use of the 
  * allocated memory.
@@ -117,25 +123,27 @@ void pipe_wait(struct pipe_inode_info *pipe)
 }
 
 static int
-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
-			int atomic)
+pipe_iov_copy_from_user(void *addr, int *offset, struct iovec *iov,
+			size_t *remaining, int atomic)
 {
 	unsigned long copy;
 
-	while (len > 0) {
+	while (*remaining > 0) {
 		while (!iov->iov_len)
 			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
+		copy = min_t(unsigned long, *remaining, iov->iov_len);
 
 		if (atomic) {
-			if (__copy_from_user_inatomic(to, iov->iov_base, copy))
+			if (__copy_from_user_inatomic(addr + *offset,
+						      iov->iov_base, copy))
 				return -EFAULT;
 		} else {
-			if (copy_from_user(to, iov->iov_base, copy))
+			if (copy_from_user(addr + *offset,
+					   iov->iov_base, copy))
 				return -EFAULT;
 		}
-		to += copy;
-		len -= copy;
+		*offset += copy;
+		*remaining -= copy;
 		iov->iov_base += copy;
 		iov->iov_len -= copy;
 	}
@@ -143,25 +151,27 @@ pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
 }
 
 static int
-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
-		      int atomic)
+pipe_iov_copy_to_user(struct iovec *iov, void *addr, int *offset,
+		      size_t *remaining, int atomic)
 {
 	unsigned long copy;
 
-	while (len > 0) {
+	while (*remaining > 0) {
 		while (!iov->iov_len)
 			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
+		copy = min_t(unsigned long, *remaining, iov->iov_len);
 
 		if (atomic) {
-			if (__copy_to_user_inatomic(iov->iov_base, from, copy))
+			if (__copy_to_user_inatomic(iov->iov_base,
+						    addr + *offset, copy))
 				return -EFAULT;
 		} else {
-			if (copy_to_user(iov->iov_base, from, copy))
+			if (copy_to_user(iov->iov_base,
+					 addr + *offset, copy))
 				return -EFAULT;
 		}
-		from += copy;
-		len -= copy;
+		*offset += copy;
+		*remaining -= copy;
 		iov->iov_base += copy;
 		iov->iov_len -= copy;
 	}
@@ -395,8 +405,9 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 			struct pipe_buffer *buf = pipe->bufs + curbuf;
 			const struct pipe_buf_operations *ops = buf->ops;
 			void *addr;
-			size_t chars = buf->len;
+			size_t chars = buf->len, remaining;
 			int error, atomic;
+			int offset;
 
 			if (chars > total_len)
 				chars = total_len;
@@ -409,9 +420,12 @@ pipe_read(struct kiocb *iocb, const struct iovec *_iov,
 			}
 
 			atomic = !iov_fault_in_pages_write(iov, chars);
+			remaining = chars;
+			offset = buf->offset;
 redo:
 			addr = ops->map(pipe, buf, atomic);
-			error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);
+			error = pipe_iov_copy_to_user(iov, addr, &offset,
+						      &remaining, atomic);
 			ops->unmap(pipe, buf, addr);
 			if (unlikely(error)) {
 				/*
@@ -531,6 +545,7 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 		if (ops->can_merge && offset + chars <= PAGE_SIZE) {
 			int error, atomic = 1;
 			void *addr;
+			size_t remaining = chars;
 
 			error = ops->confirm(pipe, buf);
 			if (error)
@@ -539,8 +554,8 @@ pipe_write(struct kiocb *iocb, const struct iovec *_iov,
 			iov_fault_in_pages_read(iov, chars);
 redo1:
 			addr = ops->map(pipe, buf, atomic);
-			error = pipe_iov_copy_from_user(offset + addr, iov,
-							chars, atomic);
+			error = pipe_iov_copy_from_user(addr, &offset, iov,
+							&remaining, atomic);
 			ops->unmap(pipe, buf, addr);
 			ret = error;
 			do_wakeup = 1;
@@ -575,6 +590,8 @@ redo1:
 			struct page *page = pipe->tmp_page;
 			char *src;
 			int error, atomic = 1;
+			int offset = 0;
+			size_t remaining;
 
 			if (!page) {
 				page = alloc_page(GFP_HIGHUSER);
@@ -595,14 +612,15 @@ redo1:
 				chars = total_len;
 
 			iov_fault_in_pages_read(iov, chars);
+			remaining = chars;
 redo2:
 			if (atomic)
 				src = kmap_atomic(page);
 			else
 				src = kmap(page);
 
-			error = pipe_iov_copy_from_user(src, iov, chars,
-							atomic);
+			error = pipe_iov_copy_from_user(src, &offset, iov,
+							&remaining, atomic);
 			if (atomic)
 				kunmap_atomic(src);
 			else
@@ -782,20 +800,49 @@ pipe_fasync(int fd, struct file *filp, int on)
 	return retval;
 }
 
+static void account_pipe_buffers(struct pipe_inode_info *pipe,
+                                 unsigned long old, unsigned long new)
+{
+	atomic_long_add(new - old, &pipe->user->pipe_bufs);
+}
+
+static bool too_many_pipe_buffers_soft(struct user_struct *user)
+{
+	return pipe_user_pages_soft &&
+	       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_soft;
+}
+
+static bool too_many_pipe_buffers_hard(struct user_struct *user)
+{
+	return pipe_user_pages_hard &&
+	       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_hard;
+}
+
 struct pipe_inode_info *alloc_pipe_info(void)
 {
 	struct pipe_inode_info *pipe;
 
 	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);
 	if (pipe) {
-		pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);
+		unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
+		struct user_struct *user = get_current_user();
+
+		if (!too_many_pipe_buffers_hard(user)) {
+			if (too_many_pipe_buffers_soft(user))
+				pipe_bufs = 1;
+			pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);
+		}
+
 		if (pipe->bufs) {
 			init_waitqueue_head(&pipe->wait);
 			pipe->r_counter = pipe->w_counter = 1;
-			pipe->buffers = PIPE_DEF_BUFFERS;
+			pipe->buffers = pipe_bufs;
+			pipe->user = user;
+			account_pipe_buffers(pipe, 0, pipe_bufs);
 			mutex_init(&pipe->mutex);
 			return pipe;
 		}
+		free_uid(user);
 		kfree(pipe);
 	}
 
@@ -806,6 +853,8 @@ void free_pipe_info(struct pipe_inode_info *pipe)
 {
 	int i;
 
+	account_pipe_buffers(pipe, pipe->buffers, 0);
+	free_uid(pipe->user);
 	for (i = 0; i < pipe->buffers; i++) {
 		struct pipe_buffer *buf = pipe->bufs + i;
 		if (buf->ops)
@@ -1196,6 +1245,7 @@ static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
 			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
 	}
 
+	account_pipe_buffers(pipe, pipe->buffers, nr_pages);
 	pipe->curbuf = 0;
 	kfree(pipe->bufs);
 	pipe->bufs = bufs;
@@ -1267,6 +1317,11 @@ long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
 		if (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {
 			ret = -EPERM;
 			goto out;
+		} else if ((too_many_pipe_buffers_hard(pipe->user) ||
+			    too_many_pipe_buffers_soft(pipe->user)) &&
+		           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {
+			ret = -EPERM;
+			goto out;
 		}
 		ret = pipe_set_size(pipe, nr_pages);
 		break;
diff --git a/fs/proc/array.c b/fs/proc/array.c
index 09f0d9c..5c45eb5 100644
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -398,7 +398,7 @@ static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,
 
 	state = *get_task_state(task);
 	vsize = eip = esp = 0;
-	permitted = ptrace_may_access(task, PTRACE_MODE_READ | PTRACE_MODE_NOAUDIT);
+	permitted = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);
 	mm = get_task_mm(task);
 	if (mm) {
 		vsize = task_vsize(mm);
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 8fc784a..e5160b7 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -239,7 +239,7 @@ out:
 
 static int proc_pid_auxv(struct task_struct *task, char *buffer)
 {
-	struct mm_struct *mm = mm_access(task, PTRACE_MODE_READ);
+	struct mm_struct *mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);
 	int res = PTR_ERR(mm);
 	if (mm && !IS_ERR(mm)) {
 		unsigned int nwords = 0;
@@ -269,7 +269,7 @@ static int proc_pid_wchan(struct task_struct *task, char *buffer)
 	wchan = get_wchan(task);
 
 	if (lookup_symbol_name(wchan, symname) < 0)
-		if (!ptrace_may_access(task, PTRACE_MODE_READ))
+		if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
 			return 0;
 		else
 			return sprintf(buffer, "%lu", wchan);
@@ -283,7 +283,7 @@ static int lock_trace(struct task_struct *task)
 	int err = mutex_lock_killable(&task->signal->cred_guard_mutex);
 	if (err)
 		return err;
-	if (!ptrace_may_access(task, PTRACE_MODE_ATTACH)) {
+	if (!ptrace_may_access(task, PTRACE_MODE_ATTACH_FSCREDS)) {
 		mutex_unlock(&task->signal->cred_guard_mutex);
 		return -EPERM;
 	}
@@ -557,7 +557,7 @@ static int proc_fd_access_allowed(struct inode *inode)
 	 */
 	task = get_proc_task(inode);
 	if (task) {
-		allowed = ptrace_may_access(task, PTRACE_MODE_READ);
+		allowed = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);
 		put_task_struct(task);
 	}
 	return allowed;
@@ -592,7 +592,7 @@ static bool has_pid_permissions(struct pid_namespace *pid,
 		return true;
 	if (in_group_p(pid->pid_gid))
 		return true;
-	return ptrace_may_access(task, PTRACE_MODE_READ);
+	return ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);
 }
 
 
@@ -707,7 +707,7 @@ static int __mem_open(struct inode *inode, struct file *file, unsigned int mode)
 	if (!task)
 		return -ESRCH;
 
-	mm = mm_access(task, mode);
+	mm = mm_access(task, mode | PTRACE_MODE_FSCREDS);
 	put_task_struct(task);
 
 	if (IS_ERR(mm))
@@ -844,7 +844,8 @@ static ssize_t environ_read(struct file *file, char __user *buf,
 	int ret = 0;
 	struct mm_struct *mm = file->private_data;
 
-	if (!mm)
+	/* Ensure the process spawned far enough to have an environment. */
+	if (!mm || !mm->env_end)
 		return 0;
 
 	page = (char *)__get_free_page(GFP_TEMPORARY);
@@ -1761,7 +1762,7 @@ static int map_files_d_revalidate(struct dentry *dentry, unsigned int flags)
 	if (!task)
 		goto out_notask;
 
-	mm = mm_access(task, PTRACE_MODE_READ);
+	mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);
 	if (IS_ERR_OR_NULL(mm))
 		goto out;
 
@@ -1896,7 +1897,7 @@ static struct dentry *proc_map_files_lookup(struct inode *dir,
 		goto out;
 
 	result = ERR_PTR(-EACCES);
-	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
 		goto out_put_task;
 
 	result = ERR_PTR(-ENOENT);
@@ -1952,7 +1953,7 @@ proc_map_files_readdir(struct file *filp, void *dirent, filldir_t filldir)
 		goto out;
 
 	ret = -EACCES;
-	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
 		goto out_put_task;
 
 	ret = 0;
@@ -2488,7 +2489,7 @@ static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
 	if (result)
 		return result;
 
-	if (!ptrace_may_access(task, PTRACE_MODE_READ)) {
+	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)) {
 		result = -EACCES;
 		goto out_unlock;
 	}
diff --git a/fs/proc/namespaces.c b/fs/proc/namespaces.c
index 54bdc67..ac49a8d 100644
--- a/fs/proc/namespaces.c
+++ b/fs/proc/namespaces.c
@@ -125,7 +125,7 @@ static void *proc_ns_follow_link(struct dentry *dentry, struct nameidata *nd)
 	if (!task)
 		goto out;
 
-	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
 		goto out_put_task;
 
 	ns_path.dentry = proc_ns_get_dentry(sb, task, ei->ns.ns_ops);
@@ -158,7 +158,7 @@ static int proc_ns_readlink(struct dentry *dentry, char __user *buffer, int bufl
 	if (!task)
 		goto out;
 
-	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))
 		goto out_put_task;
 
 	len = -ENOENT;
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 65fc60a..b86db12 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -170,7 +170,7 @@ static void *m_start(struct seq_file *m, loff_t *pos)
 	if (!priv->task)
 		return ERR_PTR(-ESRCH);
 
-	mm = mm_access(priv->task, PTRACE_MODE_READ);
+	mm = mm_access(priv->task, PTRACE_MODE_READ_FSCREDS);
 	if (!mm || IS_ERR(mm))
 		return mm;
 	down_read(&mm->mmap_sem);
@@ -1044,7 +1044,7 @@ static ssize_t pagemap_read(struct file *file, char __user *buf,
 	if (!pm.buffer)
 		goto out_task;
 
-	mm = mm_access(task, PTRACE_MODE_READ);
+	mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);
 	ret = PTR_ERR(mm);
 	if (!mm || IS_ERR(mm))
 		goto out_free;
@@ -1110,9 +1110,19 @@ out:
 	return ret;
 }
 
+static int pagemap_open(struct inode *inode, struct file *file)
+{
+	/* do not disclose physical addresses to unprivileged
+	   userspace (closes a rowhammer attack vector) */
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	return 0;
+}
+
 const struct file_operations proc_pagemap_operations = {
 	.llseek		= mem_lseek, /* borrow this */
 	.read		= pagemap_read,
+	.open		= pagemap_open,
 };
 #endif /* CONFIG_PROC_PAGE_MONITOR */
 
diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c
index 56123a6..123c198 100644
--- a/fs/proc/task_nommu.c
+++ b/fs/proc/task_nommu.c
@@ -223,7 +223,7 @@ static void *m_start(struct seq_file *m, loff_t *pos)
 	if (!priv->task)
 		return ERR_PTR(-ESRCH);
 
-	mm = mm_access(priv->task, PTRACE_MODE_READ);
+	mm = mm_access(priv->task, PTRACE_MODE_READ_FSCREDS);
 	if (!mm || IS_ERR(mm)) {
 		put_task_struct(priv->task);
 		priv->task = NULL;
diff --git a/fs/reiserfs/reiserfs.h b/fs/reiserfs/reiserfs.h
index 157e474..635a142 100644
--- a/fs/reiserfs/reiserfs.h
+++ b/fs/reiserfs/reiserfs.h
@@ -1954,8 +1954,6 @@ struct treepath var = {.path_length = ILLEGAL_PATH_ELEMENT_OFFSET, .reada = 0,}
 #define MAX_US_INT 0xffff
 
 // reiserfs version 2 has max offset 60 bits. Version 1 - 32 bit offset
-#define U32_MAX (~(__u32)0)
-
 static inline loff_t max_reiserfs_offset(struct inode *inode)
 {
 	if (get_inode_item_key_version(inode) == KEY_FORMAT_3_5)
diff --git a/fs/signalfd.c b/fs/signalfd.c
index 424b7b6..148f8e7 100644
--- a/fs/signalfd.c
+++ b/fs/signalfd.c
@@ -121,8 +121,9 @@ static int signalfd_copyinfo(struct signalfd_siginfo __user *uinfo,
 		 * Other callers might not initialize the si_lsb field,
 		 * so check explicitly for the right codes here.
 		 */
-		if (kinfo->si_code == BUS_MCEERR_AR ||
-		    kinfo->si_code == BUS_MCEERR_AO)
+		if (kinfo->si_signo == SIGBUS &&
+		    (kinfo->si_code == BUS_MCEERR_AR ||
+		     kinfo->si_code == BUS_MCEERR_AO))
 			err |= __put_user((short) kinfo->si_addr_lsb,
 					  &uinfo->ssi_addr_lsb);
 #endif
diff --git a/fs/splice.c b/fs/splice.c
index 4b5a5fa..2ffa7b0 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -189,6 +189,9 @@ ssize_t splice_to_pipe(struct pipe_inode_info *pipe,
 	unsigned int spd_pages = spd->nr_pages;
 	int ret, do_wakeup, page_nr;
 
+	if (!spd_pages)
+		return 0;
+
 	ret = 0;
 	do_wakeup = 0;
 	page_nr = 0;
@@ -949,6 +952,7 @@ ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,
 
 	splice_from_pipe_begin(sd);
 	do {
+		cond_resched();
 		ret = splice_from_pipe_next(pipe, sd);
 		if (ret > 0)
 			ret = splice_from_pipe_feed(pipe, sd, actor);
@@ -1012,13 +1016,17 @@ generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,
 	struct address_space *mapping = out->f_mapping;
 	struct inode *inode = mapping->host;
 	struct splice_desc sd = {
-		.total_len = len,
 		.flags = flags,
-		.pos = *ppos,
 		.u.file = out,
 	};
 	ssize_t ret;
 
+	ret = generic_write_checks(out, ppos, &len, S_ISBLK(inode->i_mode));
+	if (ret)
+		return ret;
+	sd.total_len = len;
+	sd.pos = *ppos;
+
 	pipe_lock(pipe);
 
 	splice_from_pipe_begin(&sd);
@@ -1185,7 +1193,7 @@ ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,
 	long ret, bytes;
 	umode_t i_mode;
 	size_t len;
-	int i, flags;
+	int i, flags, more;
 
 	/*
 	 * We require the input being a regular file, as we don't want to
@@ -1228,6 +1236,7 @@ ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,
 	 * Don't block on output, we have to drain the direct pipe.
 	 */
 	sd->flags &= ~SPLICE_F_NONBLOCK;
+	more = sd->flags & SPLICE_F_MORE;
 
 	while (len) {
 		size_t read_len;
@@ -1241,6 +1250,15 @@ ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,
 		sd->total_len = read_len;
 
 		/*
+		 * If more data is pending, set SPLICE_F_MORE
+		 * If this is the last data and SPLICE_F_MORE was not set
+		 * initially, clears it.
+		 */
+		if (read_len < len)
+			sd->flags |= SPLICE_F_MORE;
+		else if (!more)
+			sd->flags &= ~SPLICE_F_MORE;
+		/*
 		 * NOTE: nonblocking mode only applies to the input. We
 		 * must not do the output in nonblocking mode as then we
 		 * could get stuck data in the internal pipe:
diff --git a/fs/super.c b/fs/super.c
index e028b50..97280e7 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -163,19 +163,6 @@ static struct super_block *alloc_super(struct file_system_type *type, int flags)
 			s = NULL;
 			goto out;
 		}
-#ifdef CONFIG_SMP
-		s->s_files = alloc_percpu(struct list_head);
-		if (!s->s_files)
-			goto err_out;
-		else {
-			int i;
-
-			for_each_possible_cpu(i)
-				INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));
-		}
-#else
-		INIT_LIST_HEAD(&s->s_files);
-#endif
 		if (init_sb_writers(s, type))
 			goto err_out;
 		s->s_flags = flags;
@@ -225,10 +212,6 @@ out:
 	return s;
 err_out:
 	security_sb_free(s);
-#ifdef CONFIG_SMP
-	if (s->s_files)
-		free_percpu(s->s_files);
-#endif
 	destroy_sb_writers(s);
 	kfree(s);
 	s = NULL;
@@ -243,9 +226,6 @@ err_out:
  */
 static inline void destroy_super(struct super_block *s)
 {
-#ifdef CONFIG_SMP
-	free_percpu(s->s_files);
-#endif
 	destroy_sb_writers(s);
 	security_sb_free(s);
 	WARN_ON(!list_empty(&s->s_mounts));
@@ -727,7 +707,8 @@ int do_remount_sb(struct super_block *sb, int flags, void *data, int force)
 	   make sure there are no rw files opened */
 	if (remount_ro) {
 		if (force) {
-			mark_files_ro(sb);
+			sb->s_readonly_remount = 1;
+			smp_wmb();
 		} else {
 			retval = sb_prepare_remount_readonly(sb);
 			if (retval)
diff --git a/fs/sysv/inode.c b/fs/sysv/inode.c
index c327d4e..7b3792e 100644
--- a/fs/sysv/inode.c
+++ b/fs/sysv/inode.c
@@ -161,14 +161,8 @@ void sysv_set_inode(struct inode *inode, dev_t rdev)
 		inode->i_fop = &sysv_dir_operations;
 		inode->i_mapping->a_ops = &sysv_aops;
 	} else if (S_ISLNK(inode->i_mode)) {
-		if (inode->i_blocks) {
-			inode->i_op = &sysv_symlink_inode_operations;
-			inode->i_mapping->a_ops = &sysv_aops;
-		} else {
-			inode->i_op = &sysv_fast_symlink_inode_operations;
-			nd_terminate_link(SYSV_I(inode)->i_data, inode->i_size,
-				sizeof(SYSV_I(inode)->i_data) - 1);
-		}
+		inode->i_op = &sysv_symlink_inode_operations;
+		inode->i_mapping->a_ops = &sysv_aops;
 	} else
 		init_special_inode(inode, inode->i_mode, rdev);
 }
diff --git a/fs/ubifs/file.c b/fs/ubifs/file.c
index 881324c..a335e4e 100644
--- a/fs/ubifs/file.c
+++ b/fs/ubifs/file.c
@@ -54,6 +54,7 @@
 #include <linux/mount.h>
 #include <linux/namei.h>
 #include <linux/slab.h>
+#include <linux/migrate.h>
 
 static int read_block(struct inode *inode, void *addr, unsigned int block,
 		      struct ubifs_data_node *dn)
@@ -1422,6 +1423,26 @@ static int ubifs_set_page_dirty(struct page *page)
 	return ret;
 }
 
+#ifdef CONFIG_MIGRATION
+static int ubifs_migrate_page(struct address_space *mapping,
+		struct page *newpage, struct page *page, enum migrate_mode mode)
+{
+	int rc;
+
+	rc = migrate_page_move_mapping(mapping, newpage, page, NULL, mode);
+	if (rc != MIGRATEPAGE_SUCCESS)
+		return rc;
+
+	if (PagePrivate(page)) {
+		ClearPagePrivate(page);
+		SetPagePrivate(newpage);
+	}
+
+	migrate_page_copy(newpage, page);
+	return MIGRATEPAGE_SUCCESS;
+}
+#endif
+
 static int ubifs_releasepage(struct page *page, gfp_t unused_gfp_flags)
 {
 	/*
@@ -1558,6 +1579,9 @@ const struct address_space_operations ubifs_file_address_operations = {
 	.write_end      = ubifs_write_end,
 	.invalidatepage = ubifs_invalidatepage,
 	.set_page_dirty = ubifs_set_page_dirty,
+#ifdef CONFIG_MIGRATION
+	.migratepage	= ubifs_migrate_page,
+#endif
 	.releasepage    = ubifs_releasepage,
 };
 
diff --git a/fs/udf/inode.c b/fs/udf/inode.c
index aa02328..5c1120a 100644
--- a/fs/udf/inode.c
+++ b/fs/udf/inode.c
@@ -1495,6 +1495,16 @@ static void udf_fill_inode(struct inode *inode, struct buffer_head *bh)
 		iinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);
 	}
 
+	/*
+	 * Sanity check length of allocation descriptors and extended attrs to
+	 * avoid integer overflows
+	 */
+	if (iinfo->i_lenEAttr > inode->i_sb->s_blocksize || iinfo->i_lenAlloc > inode->i_sb->s_blocksize)
+		return;
+	/* Now do exact checks */
+	if (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > inode->i_sb->s_blocksize)
+		return;
+
 	switch (fe->icbTag.fileType) {
 	case ICBTAG_FILE_TYPE_DIRECTORY:
 		inode->i_op = &udf_dir_inode_operations;
@@ -2045,14 +2055,29 @@ void udf_write_aext(struct inode *inode, struct extent_position *epos,
 		epos->offset += adsize;
 }
 
+/*
+ * Only 1 indirect extent in a row really makes sense but allow upto 16 in case
+ * someone does some weird stuff.
+ */
+#define UDF_MAX_INDIR_EXTS 16
+
 int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,
 		     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)
 {
 	int8_t etype;
+	unsigned int indirections = 0;
 
 	while ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==
 	       (EXT_NEXT_EXTENT_ALLOCDECS >> 30)) {
 		int block;
+
+		if (++indirections > UDF_MAX_INDIR_EXTS) {
+			udf_err(inode->i_sb,
+				"too many indirect extents in inode %lu\n",
+				inode->i_ino);
+			return -1;
+		}
+
 		epos->block = *eloc;
 		epos->offset = sizeof(struct allocExtDesc);
 		brelse(epos->bh);
diff --git a/fs/udf/unicode.c b/fs/udf/unicode.c
index 44b815e..685fbd8 100644
--- a/fs/udf/unicode.c
+++ b/fs/udf/unicode.c
@@ -132,11 +132,15 @@ int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)
 		if (c < 0x80U)
 			utf_o->u_name[utf_o->u_len++] = (uint8_t)c;
 		else if (c < 0x800U) {
+			if (utf_o->u_len > (UDF_NAME_LEN - 4))
+				break;
 			utf_o->u_name[utf_o->u_len++] =
 						(uint8_t)(0xc0 | (c >> 6));
 			utf_o->u_name[utf_o->u_len++] =
 						(uint8_t)(0x80 | (c & 0x3f));
 		} else {
+			if (utf_o->u_len > (UDF_NAME_LEN - 5))
+				break;
 			utf_o->u_name[utf_o->u_len++] =
 						(uint8_t)(0xe0 | (c >> 12));
 			utf_o->u_name[utf_o->u_len++] =
@@ -177,17 +181,22 @@ int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)
 static int udf_UTF8toCS0(dstring *ocu, struct ustr *utf, int length)
 {
 	unsigned c, i, max_val, utf_char;
-	int utf_cnt, u_len;
+	int utf_cnt, u_len, u_ch;
 
 	memset(ocu, 0, sizeof(dstring) * length);
 	ocu[0] = 8;
 	max_val = 0xffU;
+	u_ch = 1;
 
 try_again:
 	u_len = 0U;
 	utf_char = 0U;
 	utf_cnt = 0U;
 	for (i = 0U; i < utf->u_len; i++) {
+		/* Name didn't fit? */
+		if (u_len + 1 + u_ch >= length)
+			return 0;
+
 		c = (uint8_t)utf->u_name[i];
 
 		/* Complete a multi-byte UTF-8 character */
@@ -229,6 +238,7 @@ try_again:
 			if (max_val == 0xffU) {
 				max_val = 0xffffU;
 				ocu[0] = (uint8_t)0x10U;
+				u_ch = 2;
 				goto try_again;
 			}
 			goto error_out;
@@ -281,7 +291,7 @@ static int udf_CS0toNLS(struct nls_table *nls, struct ustr *utf_o,
 			c = (c << 8) | ocu[i++];
 
 		len = nls->uni2char(c, &utf_o->u_name[utf_o->u_len],
-				    UDF_NAME_LEN - utf_o->u_len);
+				    UDF_NAME_LEN - 2 - utf_o->u_len);
 		/* Valid character? */
 		if (len >= 0)
 			utf_o->u_len += len;
@@ -299,15 +309,19 @@ static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,
 	int len;
 	unsigned i, max_val;
 	uint16_t uni_char;
-	int u_len;
+	int u_len, u_ch;
 
 	memset(ocu, 0, sizeof(dstring) * length);
 	ocu[0] = 8;
 	max_val = 0xffU;
+	u_ch = 1;
 
 try_again:
 	u_len = 0U;
 	for (i = 0U; i < uni->u_len; i++) {
+		/* Name didn't fit? */
+		if (u_len + 1 + u_ch >= length)
+			return 0;
 		len = nls->char2uni(&uni->u_name[i], uni->u_len - i, &uni_char);
 		if (!len)
 			continue;
@@ -320,6 +334,7 @@ try_again:
 		if (uni_char > max_val) {
 			max_val = 0xffffU;
 			ocu[0] = (uint8_t)0x10U;
+			u_ch = 2;
 			goto try_again;
 		}
 
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index f010ab45..06dec55 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -2604,13 +2604,14 @@ xfs_iflush_cluster(
 		 * We need to check under the i_flags_lock for a valid inode
 		 * here. Skip it if it is not valid or the wrong inode.
 		 */
-		spin_lock(&ip->i_flags_lock);
-		if (!ip->i_ino ||
+		spin_lock(&iq->i_flags_lock);
+		if (!iq->i_ino ||
+		    __xfs_iflags_test(iq, XFS_ISTALE) ||
 		    (XFS_INO_TO_AGINO(mp, iq->i_ino) & mask) != first_index) {
-			spin_unlock(&ip->i_flags_lock);
+			spin_unlock(&iq->i_flags_lock);
 			continue;
 		}
-		spin_unlock(&ip->i_flags_lock);
+		spin_unlock(&iq->i_flags_lock);
 
 		/*
 		 * Do an un-protected check to see if the inode is dirty and
@@ -2726,7 +2727,7 @@ xfs_iflush(
 	struct xfs_buf		**bpp)
 {
 	struct xfs_mount	*mp = ip->i_mount;
-	struct xfs_buf		*bp;
+	struct xfs_buf		*bp = NULL;
 	struct xfs_dinode	*dip;
 	int			error;
 
@@ -2768,14 +2769,22 @@ xfs_iflush(
 	}
 
 	/*
-	 * Get the buffer containing the on-disk inode.
+	 * Get the buffer containing the on-disk inode. We are doing a try-lock
+	 * operation here, so we may get  an EAGAIN error. In that case, we
+	 * simply want to return with the inode still dirty.
+	 *
+	 * If we get any other error, we effectively have a corruption situation
+	 * and we cannot flush the inode, so we treat it the same as failing
+	 * xfs_iflush_int().
 	 */
 	error = xfs_imap_to_bp(mp, NULL, &ip->i_imap, &dip, &bp, XBF_TRYLOCK,
 			       0);
-	if (error || !bp) {
+	if (error == EAGAIN) {
 		xfs_ifunlock(ip);
 		return error;
 	}
+	if (error)
+		goto corrupt_out;
 
 	/*
 	 * First flush out the inode that xfs_iflush was called with.
@@ -2803,7 +2812,8 @@ xfs_iflush(
 	return 0;
 
 corrupt_out:
-	xfs_buf_relse(bp);
+	if (bp)
+		xfs_buf_relse(bp);
 	xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
 cluster_corrupt_out:
 	error = XFS_ERROR(EFSCORRUPTED);
diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c
index 195a403..61dbe19 100644
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@ -272,7 +272,7 @@ xfs_readlink_bmap(
 			cur_chunk += sizeof(struct xfs_dsymlink_hdr);
 		}
 
-		memcpy(link + offset, bp->b_addr, byte_cnt);
+		memcpy(link + offset, cur_chunk, byte_cnt);
 
 		pathlen -= byte_cnt;
 		offset += byte_cnt;
diff --git a/include/acpi/acpixf.h b/include/acpi/acpixf.h
index 454881e..fcabb15 100644
--- a/include/acpi/acpixf.h
+++ b/include/acpi/acpixf.h
@@ -177,7 +177,7 @@ acpi_status acpi_load_tables(void);
  */
 acpi_status acpi_reallocate_root_table(void);
 
-acpi_status acpi_find_root_pointer(acpi_size *rsdp_address);
+acpi_status acpi_find_root_pointer(acpi_physical_address *rsdp_address);
 
 acpi_status acpi_unload_table_id(acpi_owner_id id);
 
diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h
index a64adcc..4407354 100644
--- a/include/acpi/actypes.h
+++ b/include/acpi/actypes.h
@@ -198,9 +198,29 @@ typedef int INT32;
 typedef s32 acpi_native_int;
 
 typedef u32 acpi_size;
+
+#ifdef ACPI_32BIT_PHYSICAL_ADDRESS
+
+/*
+ * OSPMs can define this to shrink the size of the structures for 32-bit
+ * none PAE environment. ASL compiler may always define this to generate
+ * 32-bit OSPM compliant tables.
+ */
 typedef u32 acpi_io_address;
 typedef u32 acpi_physical_address;
 
+#else				/* ACPI_32BIT_PHYSICAL_ADDRESS */
+
+/*
+ * It is reported that, after some calculations, the physical addresses can
+ * wrap over the 32-bit boundary on 32-bit PAE environment.
+ * https://bugzilla.kernel.org/show_bug.cgi?id=87971
+ */
+typedef u64 acpi_io_address;
+typedef u64 acpi_physical_address;
+
+#endif				/* ACPI_32BIT_PHYSICAL_ADDRESS */
+
 #define ACPI_MAX_PTR                    ACPI_UINT32_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
@@ -491,6 +511,7 @@ typedef u64 acpi_integer;
 #define ACPI_NO_ACPI_ENABLE             0x10
 #define ACPI_NO_DEVICE_INIT             0x20
 #define ACPI_NO_OBJECT_INIT             0x40
+#define ACPI_NO_FACS_INIT               0x80
 
 /*
  * Initialization state
diff --git a/include/acpi/platform/acenv.h b/include/acpi/platform/acenv.h
index ef04b36..f7db107 100644
--- a/include/acpi/platform/acenv.h
+++ b/include/acpi/platform/acenv.h
@@ -76,6 +76,7 @@
 #define ACPI_LARGE_NAMESPACE_NODE
 #define ACPI_DATA_TABLE_DISASSEMBLY
 #define ACPI_SINGLE_THREADED
+#define ACPI_32BIT_PHYSICAL_ADDRESS
 #endif
 
 /* acpi_exec configuration. Multithreaded with full AML debugger */
diff --git a/include/asm-generic/pgtable.h b/include/asm-generic/pgtable.h
index 17bccd3..dd6d9b8 100644
--- a/include/asm-generic/pgtable.h
+++ b/include/asm-generic/pgtable.h
@@ -550,11 +550,10 @@ static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 	barrier();
 #endif
-	if (pmd_none(pmdval))
+	if (pmd_none(pmdval) || pmd_trans_huge(pmdval))
 		return 1;
 	if (unlikely(pmd_bad(pmdval))) {
-		if (!pmd_trans_huge(pmdval))
-			pmd_clear_bad(pmd);
+		pmd_clear_bad(pmd);
 		return 1;
 	}
 	return 0;
diff --git a/include/asm-generic/sections.h b/include/asm-generic/sections.h
index c1a1216..87b2726 100644
--- a/include/asm-generic/sections.h
+++ b/include/asm-generic/sections.h
@@ -3,6 +3,8 @@
 
 /* References to section boundaries */
 
+#include <linux/compiler.h>
+
 extern char _text[], _stext[], _etext[];
 extern char _data[], _sdata[], _edata[];
 extern char __bss_start[], __bss_stop[];
@@ -18,6 +20,8 @@ extern char __start_rodata[], __end_rodata[];
 /* Start and end of .ctors section - used for constructor calls. */
 extern char __ctors_start[], __ctors_end[];
 
+extern __visible const void __nosave_begin, __nosave_end;
+
 /* function descriptor handling (if any).  Override
  * in asm/sections.h */
 #ifndef dereference_function_descriptor
diff --git a/include/drm/drm_pciids.h b/include/drm/drm_pciids.h
index d7b7170..2b5c3bc 100644
--- a/include/drm/drm_pciids.h
+++ b/include/drm/drm_pciids.h
@@ -150,6 +150,7 @@
 	{0x1002, 0x6610, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6611, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6613, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x6617, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6620, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6621, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6623, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
diff --git a/include/linux/ambpriv_device.h b/include/linux/ambpriv_device.h
index 4ed5a87..6f1c70a 100644
--- a/include/linux/ambpriv_device.h
+++ b/include/linux/ambpriv_device.h
@@ -41,6 +41,11 @@ extern int ambpriv_device_add(struct ambpriv_device *pdev);
 extern void ambpriv_device_del(struct ambpriv_device *pdev);
 extern void ambpriv_device_put(struct ambpriv_device *pdev);
 
+extern struct ambpriv_device *of_find_ambpriv_device_by_match(struct of_device_id *match);
+extern struct ambpriv_device *of_find_ambpriv_device_by_node(struct device_node *np);
+extern int ambpriv_get_irq(struct ambpriv_device *dev, unsigned int num);
+extern int ambpriv_get_irq_by_name(struct ambpriv_device *dev, const char *name);
+
 struct ambpriv_driver {
 	int (*probe)(struct ambpriv_device *);
 	int (*remove)(struct ambpriv_device *);
diff --git a/include/linux/ata.h b/include/linux/ata.h
index ee0bd95..f60ffe2 100644
--- a/include/linux/ata.h
+++ b/include/linux/ata.h
@@ -477,8 +477,8 @@ enum ata_tf_protocols {
 };
 
 enum ata_ioctls {
-	ATA_IOC_GET_IO32	= 0x309,
-	ATA_IOC_SET_IO32	= 0x324,
+	ATA_IOC_GET_IO32	= 0x309, /* HDIO_GET_32BIT */
+	ATA_IOC_SET_IO32	= 0x324, /* HDIO_SET_32BIT */
 };
 
 /* core structures */
diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h
index fa1abeb..49c48dd 100644
--- a/include/linux/blk_types.h
+++ b/include/linux/blk_types.h
@@ -170,7 +170,9 @@ enum rq_flag_bits {
 	__REQ_ELVPRIV,		/* elevator private data attached */
 	__REQ_FAILED,		/* set if the request failed */
 	__REQ_QUIET,		/* don't worry about errors */
-	__REQ_PREEMPT,		/* set for "ide_preempt" requests */
+	__REQ_PREEMPT,		/* set for "ide_preempt" requests and also
+				   for requests for which the SCSI "quiesce"
+				   state must be ignored. */
 	__REQ_ALLOCED,		/* request came from our alloc pool */
 	__REQ_COPY_USER,	/* contains copies of user pages */
 	__REQ_FLUSH_SEQ,	/* request for flush sequence */
diff --git a/include/linux/ceph/decode.h b/include/linux/ceph/decode.h
index 0442c3d..a6ef9cc 100644
--- a/include/linux/ceph/decode.h
+++ b/include/linux/ceph/decode.h
@@ -8,23 +8,6 @@
 
 #include <linux/ceph/types.h>
 
-/* This seemed to be the easiest place to define these */
-
-#define	U8_MAX	((u8)(~0U))
-#define	U16_MAX	((u16)(~0U))
-#define	U32_MAX	((u32)(~0U))
-#define	U64_MAX	((u64)(~0ULL))
-
-#define	S8_MAX	((s8)(U8_MAX >> 1))
-#define	S16_MAX	((s16)(U16_MAX >> 1))
-#define	S32_MAX	((s32)(U32_MAX >> 1))
-#define	S64_MAX	((s64)(U64_MAX >> 1LL))
-
-#define	S8_MIN	((s8)(-S8_MAX - 1))
-#define	S16_MIN	((s16)(-S16_MAX - 1))
-#define	S32_MIN	((s32)(-S32_MAX - 1))
-#define	S64_MIN	((s64)(-S64_MAX - 1LL))
-
 /*
  * in all cases,
  *   void **p     pointer to position pointer
diff --git a/include/linux/compiler-gcc.h b/include/linux/compiler-gcc.h
index 02ae99e..953cd121 100644
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@ -100,10 +100,116 @@
 #define __maybe_unused			__attribute__((unused))
 #define __always_unused			__attribute__((unused))
 
-#define __gcc_header(x) #x
-#define _gcc_header(x) __gcc_header(linux/compiler-gcc##x.h)
-#define gcc_header(x) _gcc_header(x)
-#include gcc_header(__GNUC__)
+/* gcc version specific checks */
+
+#if GCC_VERSION < 30200
+# error Sorry, your compiler is too old - please upgrade it.
+#endif
+
+#if GCC_VERSION < 30300
+# define __used			__attribute__((__unused__))
+#else
+# define __used			__attribute__((__used__))
+#endif
+
+#ifdef CONFIG_GCOV_KERNEL
+# if GCC_VERSION < 30400
+#   error "GCOV profiling support for gcc versions below 3.4 not included"
+# endif /* __GNUC_MINOR__ */
+#endif /* CONFIG_GCOV_KERNEL */
+
+#if GCC_VERSION >= 30400
+#define __must_check		__attribute__((warn_unused_result))
+#endif
+
+#if GCC_VERSION >= 40000
+
+/* GCC 4.1.[01] miscompiles __weak */
+#ifdef __KERNEL__
+# if GCC_VERSION >= 40100 &&  GCC_VERSION <= 40101
+#  error Your version of gcc miscompiles the __weak directive
+# endif
+#endif
+
+#define __used			__attribute__((__used__))
+#define __compiler_offsetof(a, b)					\
+	__builtin_offsetof(a, b)
+
+#if GCC_VERSION >= 40100 && GCC_VERSION < 40600
+# define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
+#endif
+
+#if GCC_VERSION >= 40300
+/* Mark functions as cold. gcc will assume any path leading to a call
+ * to them will be unlikely.  This means a lot of manual unlikely()s
+ * are unnecessary now for any paths leading to the usual suspects
+ * like BUG(), printk(), panic() etc. [but let's keep them for now for
+ * older compilers]
+ *
+ * Early snapshots of gcc 4.3 don't support this and we can't detect this
+ * in the preprocessor, but we can live with this because they're unreleased.
+ * Maketime probing would be overkill here.
+ *
+ * gcc also has a __attribute__((__hot__)) to move hot functions into
+ * a special section, but I don't see any sense in this right now in
+ * the kernel context
+ */
+#define __cold			__attribute__((__cold__))
+
+#define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
+
+#ifndef __CHECKER__
+# define __compiletime_warning(message) __attribute__((warning(message)))
+# define __compiletime_error(message) __attribute__((error(message)))
+#endif /* __CHECKER__ */
+#endif /* GCC_VERSION >= 40300 */
+
+#if GCC_VERSION >= 40500
+/*
+ * Mark a position in code as unreachable.  This can be used to
+ * suppress control flow warnings after asm blocks that transfer
+ * control elsewhere.
+ *
+ * Early snapshots of gcc 4.5 don't support this and we can't detect
+ * this in the preprocessor, but we can live with this because they're
+ * unreleased.  Really, we need to have autoconf for the kernel.
+ */
+#define unreachable() __builtin_unreachable()
+
+/* Mark a function definition as prohibited from being cloned. */
+#define __noclone	__attribute__((__noclone__, __optimize__("no-tracer")))
+
+#endif /* GCC_VERSION >= 40500 */
+
+#if GCC_VERSION >= 40600
+/*
+ * Tell the optimizer that something else uses this function or variable.
+ */
+#define __visible	__attribute__((externally_visible))
+#endif
+
+/*
+ * GCC 'asm goto' miscompiles certain code sequences:
+ *
+ *   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=58670
+ *
+ * Work it around via a compiler barrier quirk suggested by Jakub Jelinek.
+ *
+ * (asm goto is automatically volatile - the naming reflects this.)
+ */
+#define asm_volatile_goto(x...)	do { asm goto(x); asm (""); } while (0)
+
+#ifdef CONFIG_ARCH_USE_BUILTIN_BSWAP
+#if GCC_VERSION >= 40400
+#define __HAVE_BUILTIN_BSWAP32__
+#define __HAVE_BUILTIN_BSWAP64__
+#endif
+#if GCC_VERSION >= 40800 || (defined(__powerpc__) && GCC_VERSION >= 40600)
+#define __HAVE_BUILTIN_BSWAP16__
+#endif
+#endif /* CONFIG_ARCH_USE_BUILTIN_BSWAP */
+
+#endif	/* gcc version >= 40000 specific checks */
 
 #if !defined(__noclone)
 #define __noclone	/* not needed */
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index a2329c5..a2ce6f8 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -131,7 +131,7 @@ void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);
  */
 #define if(cond, ...) __trace_if( (cond , ## __VA_ARGS__) )
 #define __trace_if(cond) \
-	if (__builtin_constant_p((cond)) ? !!(cond) :			\
+	if (__builtin_constant_p(!!(cond)) ? !!(cond) :			\
 	({								\
 		int ______r;						\
 		static struct ftrace_branch_data			\
diff --git a/include/linux/console.h b/include/linux/console.h
index 73bab0f..6877ffc 100644
--- a/include/linux/console.h
+++ b/include/linux/console.h
@@ -153,6 +153,7 @@ extern int console_trylock(void);
 extern void console_unlock(void);
 extern void console_conditional_schedule(void);
 extern void console_unblank(void);
+extern void console_flush_on_panic(void);
 extern struct tty_driver *console_device(int *);
 extern void console_stop(struct console *);
 extern void console_start(struct console *);
diff --git a/include/linux/dcache.h b/include/linux/dcache.h
index 9be5ac9..c1999d1 100644
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -120,15 +120,15 @@ struct dentry {
 	void *d_fsdata;			/* fs-specific data */
 
 	struct list_head d_lru;		/* LRU list */
+	struct list_head d_child;	/* child of parent list */
+	struct list_head d_subdirs;	/* our children */
 	/*
-	 * d_child and d_rcu can share memory
+	 * d_alias and d_rcu can share memory
 	 */
 	union {
-		struct list_head d_child;	/* child of parent list */
+		struct hlist_node d_alias;	/* inode alias list */
 	 	struct rcu_head d_rcu;
 	} d_u;
-	struct list_head d_subdirs;	/* our children */
-	struct hlist_node d_alias;	/* inode alias list */
 };
 
 /*
diff --git a/include/linux/devpts_fs.h b/include/linux/devpts_fs.h
index 251a209..e0ee0b3 100644
--- a/include/linux/devpts_fs.h
+++ b/include/linux/devpts_fs.h
@@ -19,6 +19,8 @@
 
 int devpts_new_index(struct inode *ptmx_inode);
 void devpts_kill_index(struct inode *ptmx_inode, int idx);
+void devpts_add_ref(struct inode *ptmx_inode);
+void devpts_del_ref(struct inode *ptmx_inode);
 /* mknod in devpts */
 struct inode *devpts_pty_new(struct inode *ptmx_inode, dev_t device, int index,
 		void *priv);
@@ -32,6 +34,8 @@ void devpts_pty_kill(struct inode *inode);
 /* Dummy stubs in the no-pty case */
 static inline int devpts_new_index(struct inode *ptmx_inode) { return -EINVAL; }
 static inline void devpts_kill_index(struct inode *ptmx_inode, int idx) { }
+static inline void devpts_add_ref(struct inode *ptmx_inode) { }
+static inline void devpts_del_ref(struct inode *ptmx_inode) { }
 static inline struct inode *devpts_pty_new(struct inode *ptmx_inode,
 		dev_t device, int index, void *priv)
 {
diff --git a/include/linux/efi.h b/include/linux/efi.h
index 2bc0ad7..63fa51c 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -769,8 +769,10 @@ struct efivars {
  * and we use a page for reading/writing.
  */
 
+#define EFI_VAR_NAME_LEN	1024
+
 struct efi_variable {
-	efi_char16_t  VariableName[1024/sizeof(efi_char16_t)];
+	efi_char16_t  VariableName[EFI_VAR_NAME_LEN/sizeof(efi_char16_t)];
 	efi_guid_t    VendorGuid;
 	unsigned long DataSize;
 	__u8          Data[1024];
@@ -832,7 +834,10 @@ int efivar_entry_iter(int (*func)(struct efivar_entry *, void *),
 struct efivar_entry *efivar_entry_find(efi_char16_t *name, efi_guid_t guid,
 				       struct list_head *head, bool remove);
 
-bool efivar_validate(struct efi_variable *var, u8 *data, unsigned long len);
+bool efivar_validate(efi_guid_t vendor, efi_char16_t *var_name, u8 *data,
+		     unsigned long data_size);
+bool efivar_variable_is_removable(efi_guid_t vendor, const char *name,
+				  size_t len);
 
 extern struct work_struct efivar_work;
 void efivar_run_worker(void);
diff --git a/include/linux/enclosure.h b/include/linux/enclosure.h
index 9a33c5f..f6c229e 100644
--- a/include/linux/enclosure.h
+++ b/include/linux/enclosure.h
@@ -29,7 +29,11 @@
 /* A few generic types ... taken from ses-2 */
 enum enclosure_component_type {
 	ENCLOSURE_COMPONENT_DEVICE = 0x01,
+	ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS = 0x07,
+	ENCLOSURE_COMPONENT_SCSI_TARGET_PORT = 0x14,
+	ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT = 0x15,
 	ENCLOSURE_COMPONENT_ARRAY_DEVICE = 0x17,
+	ENCLOSURE_COMPONENT_SAS_EXPANDER = 0x18,
 };
 
 /* ses-2 common element status */
diff --git a/include/linux/fs.h b/include/linux/fs.h
index d57bc5d..5c9dc84 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -10,6 +10,7 @@
 #include <linux/stat.h>
 #include <linux/cache.h>
 #include <linux/list.h>
+#include <linux/llist.h>
 #include <linux/radix-tree.h>
 #include <linux/rbtree.h>
 #include <linux/init.h>
@@ -761,12 +762,8 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)
 #define FILE_MNT_WRITE_RELEASED	2
 
 struct file {
-	/*
-	 * fu_list becomes invalid after file_free is called and queued via
-	 * fu_rcuhead for RCU freeing
-	 */
 	union {
-		struct list_head	fu_list;
+		struct llist_node	fu_llist;
 		struct rcu_head 	fu_rcuhead;
 	} f_u;
 	struct path		f_path;
@@ -779,9 +776,6 @@ struct file {
 	 * Must not be taken from IRQ context.
 	 */
 	spinlock_t		f_lock;
-#ifdef CONFIG_SMP
-	int			f_sb_list_cpu;
-#endif
 	atomic_long_t		f_count;
 	unsigned int 		f_flags;
 	fmode_t			f_mode;
@@ -1257,11 +1251,6 @@ struct super_block {
 
 	struct list_head	s_inodes;	/* all inodes */
 	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */
-#ifdef CONFIG_SMP
-	struct list_head __percpu *s_files;
-#else
-	struct list_head	s_files;
-#endif
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
 	/* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */
 	struct list_head	s_dentry_lru;	/* unused dentry lru */
diff --git a/include/linux/ftrace.h b/include/linux/ftrace.h
index 7a13848..38eb5db 100644
--- a/include/linux/ftrace.h
+++ b/include/linux/ftrace.h
@@ -611,25 +611,27 @@ static inline void __ftrace_enabled_restore(int enabled)
 #endif
 }
 
-#ifndef HAVE_ARCH_CALLER_ADDR
+/* All archs should have this, but we define it for consistency */
+#ifndef ftrace_return_address0
+# define ftrace_return_address0 __builtin_return_address(0)
+#endif
+
+/* Archs may use other ways for ADDR1 and beyond */
+#ifndef ftrace_return_address
 # ifdef CONFIG_FRAME_POINTER
-#  define CALLER_ADDR0 ((unsigned long)__builtin_return_address(0))
-#  define CALLER_ADDR1 ((unsigned long)__builtin_return_address(1))
-#  define CALLER_ADDR2 ((unsigned long)__builtin_return_address(2))
-#  define CALLER_ADDR3 ((unsigned long)__builtin_return_address(3))
-#  define CALLER_ADDR4 ((unsigned long)__builtin_return_address(4))
-#  define CALLER_ADDR5 ((unsigned long)__builtin_return_address(5))
-#  define CALLER_ADDR6 ((unsigned long)__builtin_return_address(6))
+#  define ftrace_return_address(n) __builtin_return_address(n)
 # else
-#  define CALLER_ADDR0 ((unsigned long)__builtin_return_address(0))
-#  define CALLER_ADDR1 0UL
-#  define CALLER_ADDR2 0UL
-#  define CALLER_ADDR3 0UL
-#  define CALLER_ADDR4 0UL
-#  define CALLER_ADDR5 0UL
-#  define CALLER_ADDR6 0UL
+#  define ftrace_return_address(n) 0UL
 # endif
-#endif /* ifndef HAVE_ARCH_CALLER_ADDR */
+#endif
+
+#define CALLER_ADDR0 ((unsigned long)ftrace_return_address0)
+#define CALLER_ADDR1 ((unsigned long)ftrace_return_address(1))
+#define CALLER_ADDR2 ((unsigned long)ftrace_return_address(2))
+#define CALLER_ADDR3 ((unsigned long)ftrace_return_address(3))
+#define CALLER_ADDR4 ((unsigned long)ftrace_return_address(4))
+#define CALLER_ADDR5 ((unsigned long)ftrace_return_address(5))
+#define CALLER_ADDR6 ((unsigned long)ftrace_return_address(6))
 
 #ifdef CONFIG_IRQSOFF_TRACER
   extern void time_hardirqs_on(unsigned long a0, unsigned long a1);
diff --git a/include/linux/iio/iio.h b/include/linux/iio/iio.h
index 3d35b70..0d908f4 100644
--- a/include/linux/iio/iio.h
+++ b/include/linux/iio/iio.h
@@ -13,6 +13,16 @@
 #include <linux/device.h>
 #include <linux/cdev.h>
 #include <linux/iio/types.h>
+
+/**
+ * struct iio_mount_matrix - iio mounting matrix
+ * @rotation: 3 dimensional space rotation matrix defining sensor alignment with
+ *            main hardware
+ */
+struct iio_mount_matrix {
+	const char *rotation[9];
+};
+
 /* IIO TODO LIST */
 /*
  * Provide means of adjusting timer accuracy.
@@ -569,6 +579,15 @@ int iio_str_to_fixpoint(const char *str, int fract_mult, int *integer,
 #define IIO_DEGREE_TO_RAD(deg) (((deg) * 314159ULL + 9000000ULL) / 18000000ULL)
 
 /**
+ * IIO_RAD_TO_DEGREE() - Convert rad to degree
+ * @rad: A value in rad
+ *
+ * Returns the given value converted from rad to degree
+ */
+#define IIO_RAD_TO_DEGREE(rad) \
+	(((rad) * 18000000ULL + 314159ULL / 2) / 314159ULL)
+
+/**
  * IIO_G_TO_M_S_2() - Convert g to meter / second**2
  * @g: A value in g
  *
@@ -576,4 +595,12 @@ int iio_str_to_fixpoint(const char *str, int fract_mult, int *integer,
  */
 #define IIO_G_TO_M_S_2(g) ((g) * 980665ULL / 100000ULL)
 
+/**
+ * IIO_M_S_2_TO_G() - Convert meter / second**2 to g
+ * @ms2: A value in meter / second**2
+ *
+ * Returns the given value converted from meter / second**2 to g
+ */
+#define IIO_M_S_2_TO_G(ms2) (((ms2) * 100000ULL + 980665ULL / 2) / 980665ULL)
+
 #endif /* _INDUSTRIAL_IO_H_ */
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 6de0f2c..f05efb1 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -11,8 +11,6 @@
 #include <linux/irqnr.h>
 #include <linux/hardirq.h>
 #include <linux/irqflags.h>
-#include <linux/smp.h>
-#include <linux/percpu.h>
 #include <linux/hrtimer.h>
 #include <linux/kref.h>
 #include <linux/workqueue.h>
@@ -488,15 +486,6 @@ extern void __raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq(unsigned int nr);
 
-/* This is the worklist that queues up per-cpu softirq work.
- *
- * send_remote_sendirq() adds work to these lists, and
- * the softirq handler itself dequeues from them.  The queues
- * are protected by disabling local cpu interrupts and they must
- * only be accessed by the local cpu that they are for.
- */
-DECLARE_PER_CPU(struct list_head [NR_SOFTIRQS], softirq_work_list);
-
 DECLARE_PER_CPU(struct task_struct *, ksoftirqd);
 
 static inline struct task_struct *this_cpu_ksoftirqd(void)
@@ -504,17 +493,6 @@ static inline struct task_struct *this_cpu_ksoftirqd(void)
 	return this_cpu_read(ksoftirqd);
 }
 
-/* Try to send a softirq to a remote cpu.  If this cannot be done, the
- * work will be queued to the local cpu.
- */
-extern void send_remote_softirq(struct call_single_data *cp, int cpu, int softirq);
-
-/* Like send_remote_softirq(), but the caller must disable local cpu interrupts
- * and compute the current cpu, passed in as 'this_cpu'.
- */
-extern void __send_remote_softirq(struct call_single_data *cp, int cpu,
-				  int this_cpu, int softirq);
-
 /* Tasklets --- multithreaded analogue of BHs.
 
    Main feature differing them of generic softirqs: tasklet
diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h
index 6e051f4..7d4a932 100644
--- a/include/linux/jbd2.h
+++ b/include/linux/jbd2.h
@@ -977,6 +977,7 @@ struct journal_s
 #define JBD2_ABORT_ON_SYNCDATA_ERR	0x040	/* Abort the journal on file
 						 * data write error in ordered
 						 * mode */
+#define JBD2_REC_ERR	0x080	/* The errno in the sb has been recorded */
 
 /*
  * Function declarations for the journaling transaction and buffer
@@ -997,7 +998,7 @@ extern struct journal_head * jbd2_journal_get_descriptor_buffer(journal_t *);
 int jbd2_journal_next_log_block(journal_t *, unsigned long long *);
 int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,
 			      unsigned long *block);
-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);
+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);
 void jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);
 
 /* Commit management */
@@ -1116,7 +1117,7 @@ extern int	   jbd2_journal_recover    (journal_t *journal);
 extern int	   jbd2_journal_wipe       (journal_t *, int);
 extern int	   jbd2_journal_skip_recovery	(journal_t *);
 extern void	   jbd2_journal_update_sb_errno(journal_t *);
-extern void	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,
+extern int	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,
 				unsigned long, int);
 extern void	   __jbd2_journal_abort_hard	(journal_t *);
 extern void	   jbd2_journal_abort      (journal_t *, int);
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 0c5aba9..e36ae10 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -29,6 +29,19 @@
 #define ULLONG_MAX	(~0ULL)
 #define SIZE_MAX	(~(size_t)0)
 
+#define U8_MAX		((u8)~0U)
+#define S8_MAX		((s8)(U8_MAX>>1))
+#define S8_MIN		((s8)(-S8_MAX - 1))
+#define U16_MAX		((u16)~0U)
+#define S16_MAX		((s16)(U16_MAX>>1))
+#define S16_MIN		((s16)(-S16_MAX - 1))
+#define U32_MAX		((u32)~0U)
+#define S32_MAX		((s32)(U32_MAX>>1))
+#define S32_MIN		((s32)(-S32_MAX - 1))
+#define U64_MAX		((u64)~0ULL)
+#define S64_MAX		((s64)(U64_MAX>>1))
+#define S64_MIN		((s64)(-S64_MAX - 1))
+
 #define STACK_MAGIC	0xdeadbeef
 
 #define REPEAT_BYTE(x)	((~0ul / 0xff) * (x))
@@ -556,7 +569,7 @@ do {							\
 
 #define do_trace_printk(fmt, args...)					\
 do {									\
-	static const char *trace_printk_fmt				\
+	static const char *trace_printk_fmt __used			\
 		__attribute__((section("__trace_printk_fmt"))) =	\
 		__builtin_constant_p(fmt) ? fmt : NULL;			\
 									\
@@ -603,7 +616,7 @@ extern int __trace_puts(unsigned long ip, const char *str, int size);
  */
 
 #define trace_puts(str) ({						\
-	static const char *trace_printk_fmt				\
+	static const char *trace_printk_fmt __used			\
 		__attribute__((section("__trace_printk_fmt"))) =	\
 		__builtin_constant_p(str) ? str : NULL;			\
 									\
@@ -623,7 +636,7 @@ extern void trace_dump_stack(int skip);
 #define ftrace_vprintk(fmt, vargs)					\
 do {									\
 	if (__builtin_constant_p(fmt)) {				\
-		static const char *trace_printk_fmt			\
+		static const char *trace_printk_fmt __used		\
 		  __attribute__((section("__trace_printk_fmt"))) =	\
 			__builtin_constant_p(fmt) ? fmt : NULL;		\
 									\
diff --git a/include/linux/libata.h b/include/linux/libata.h
index cc82cfb..8017e5c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -187,6 +187,7 @@ enum {
 	ATA_LFLAG_SW_ACTIVITY	= (1 << 7), /* keep activity stats */
 	ATA_LFLAG_NO_LPM	= (1 << 8), /* disable LPM on this link */
 	ATA_LFLAG_RST_ONCE	= (1 << 9), /* limit recovery to one reset */
+	ATA_LFLAG_CHANGED	= (1 << 10), /* LPM state changed on this link */
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 << 0), /* host supports slave dev */
@@ -289,6 +290,12 @@ enum {
 	 */
 	ATA_TMOUT_PMP_SRST_WAIT	= 5000,
 
+	/* When the LPM policy is set to ATA_LPM_MAX_POWER, there might
+	 * be a spurious PHY event, so ignore the first PHY event that
+	 * occurs within 10s after the policy change.
+	 */
+	ATA_TMOUT_SPURIOUS_PHY	= 10000,
+
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
 	BUS_DMA			= 1,
@@ -402,6 +409,7 @@ enum {
 	ATA_HORKAGE_ATAPI_DMADIR = (1 << 18),	/* device requires dmadir */
 	ATA_HORKAGE_NOLPM	= (1 << 20),	/* don't use LPM */
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 << 21),	/* some WDs have broken LPM */
+	ATA_HORKAGE_NOTRIM = (1 << 24),		/* don't use TRIM */
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */
@@ -658,7 +666,7 @@ struct ata_device {
 	union {
 		u16		id[ATA_ID_WORDS]; /* IDENTIFY xxx DEVICE data */
 		u32		gscr[SATA_PMP_GSCR_DWORDS]; /* PMP GSCR block */
-	};
+	} ____cacheline_aligned;
 
 	/* DEVSLP Timing Variables from Identify Device Data Log */
 	u8			devslp_timing[ATA_LOG_DEVSLP_SIZE];
@@ -736,6 +744,8 @@ struct ata_link {
 	struct ata_eh_context	eh_context;
 
 	struct ata_device	device[ATA_MAX_DEVICES];
+
+	unsigned long		last_lpm_change; /* when last LPM change happened */
 };
 #define ATA_LINK_CLEAR_BEGIN		offsetof(struct ata_link, active_tag)
 #define ATA_LINK_CLEAR_END		offsetof(struct ata_link, device[0])
@@ -1085,6 +1095,7 @@ extern struct ata_device *ata_dev_pair(struct ata_device *adev);
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
 extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
+extern bool sata_lpm_ignore_phy_events(struct ata_link *link);
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);
diff --git a/include/linux/lockd/lockd.h b/include/linux/lockd/lockd.h
index dcaad79..0adf073 100644
--- a/include/linux/lockd/lockd.h
+++ b/include/linux/lockd/lockd.h
@@ -236,7 +236,8 @@ void		  nlm_rebind_host(struct nlm_host *);
 struct nlm_host * nlm_get_host(struct nlm_host *);
 void		  nlm_shutdown_hosts(void);
 void		  nlm_shutdown_hosts_net(struct net *net);
-void		  nlm_host_rebooted(const struct nlm_reboot *);
+void		  nlm_host_rebooted(const struct net *net,
+					const struct nlm_reboot *);
 
 /*
  * Host monitoring
@@ -244,11 +245,13 @@ void		  nlm_host_rebooted(const struct nlm_reboot *);
 int		  nsm_monitor(const struct nlm_host *host);
 void		  nsm_unmonitor(const struct nlm_host *host);
 
-struct nsm_handle *nsm_get_handle(const struct sockaddr *sap,
+struct nsm_handle *nsm_get_handle(const struct net *net,
+					const struct sockaddr *sap,
 					const size_t salen,
 					const char *hostname,
 					const size_t hostname_len);
-struct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info);
+struct nsm_handle *nsm_reboot_lookup(const struct net *net,
+					const struct nlm_reboot *info);
 void		  nsm_release(struct nsm_handle *nsm);
 
 /*
diff --git a/include/linux/mbus.h b/include/linux/mbus.h
index dba482e..e80b9c7e 100644
--- a/include/linux/mbus.h
+++ b/include/linux/mbus.h
@@ -67,6 +67,6 @@ int mvebu_mbus_add_window(const char *devname, phys_addr_t base,
 int mvebu_mbus_del_window(phys_addr_t base, size_t size);
 int mvebu_mbus_init(const char *soc, phys_addr_t mbus_phys_base,
 		    size_t mbus_size, phys_addr_t sdram_phys_base,
-		    size_t sdram_size);
+		    size_t sdram_size, int is_coherent);
 
 #endif /* __LINUX_MBUS_H */
diff --git a/include/linux/mdio-gpio.h b/include/linux/mdio-gpio.h
index 7c9fe3c..fd43597 100644
--- a/include/linux/mdio-gpio.h
+++ b/include/linux/mdio-gpio.h
@@ -17,6 +17,9 @@ struct mdio_gpio_platform_data {
 	/* GPIO numbers for bus pins */
 	unsigned int mdc;
 	unsigned int mdio;
+	unsigned int rst;
+
+	bool rst_active_low;
 
 	unsigned int phy_mask;
 	int irqs[PHY_MAX_ADDR];
diff --git a/include/linux/migrate.h b/include/linux/migrate.h
index a405d3dc..e986927 100644
--- a/include/linux/migrate.h
+++ b/include/linux/migrate.h
@@ -55,6 +55,9 @@ extern int migrate_vmas(struct mm_struct *mm,
 extern void migrate_page_copy(struct page *newpage, struct page *page);
 extern int migrate_huge_page_move_mapping(struct address_space *mapping,
 				  struct page *newpage, struct page *page);
+extern int migrate_page_move_mapping(struct address_space *mapping,
+               struct page *newpage, struct page *page,
+               struct buffer_head *head, enum migrate_mode mode);
 #else
 
 static inline void putback_lru_pages(struct list_head *l) {}
diff --git a/include/linux/mm.h b/include/linux/mm.h
index c408519..55590f4 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -891,6 +891,7 @@ static inline int page_mapped(struct page *page)
 #define VM_FAULT_WRITE	0x0008	/* Special case for get_user_pages */
 #define VM_FAULT_HWPOISON 0x0010	/* Hit poisoned small page */
 #define VM_FAULT_HWPOISON_LARGE 0x0020  /* Hit poisoned large page. Index encoded in upper bits */
+#define VM_FAULT_SIGSEGV 0x0040
 
 #define VM_FAULT_NOPAGE	0x0100	/* ->fault installed the pte, not return page */
 #define VM_FAULT_LOCKED	0x0200	/* ->fault locked the returned page */
@@ -898,8 +899,8 @@ static inline int page_mapped(struct page *page)
 
 #define VM_FAULT_HWPOISON_LARGE_MASK 0xf000 /* encodes hpage index for large hwpoison */
 
-#define VM_FAULT_ERROR	(VM_FAULT_OOM | VM_FAULT_SIGBUS | VM_FAULT_HWPOISON | \
-			 VM_FAULT_HWPOISON_LARGE)
+#define VM_FAULT_ERROR	(VM_FAULT_OOM | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | \
+			 VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE)
 
 /* Encode hstate index for a hwpoisoned large page */
 #define VM_FAULT_SET_HINDEX(x) ((x) << 12)
@@ -1714,6 +1715,7 @@ static inline struct page *follow_page(struct vm_area_struct *vma,
 #define FOLL_HWPOISON	0x100	/* check page is hwpoisoned */
 #define FOLL_NUMA	0x200	/* force NUMA hinting page fault */
 #define FOLL_MIGRATION	0x400	/* wait for page to replace migration entry */
+#define FOLL_COW	0x4000	/* internal GUP flag */
 
 typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,
 			void *data);
diff --git a/include/linux/mod_devicetable.h b/include/linux/mod_devicetable.h
index b3bd7e7..d313648 100644
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@ -397,6 +397,7 @@ struct virtio_device_id {
 /*
  * For Hyper-V devices we use the device guid as the id.
  */
+#define vmbus_device_id hv_vmbus_device_id
 struct hv_vmbus_device_id {
 	__u8 guid[16];
 	kernel_ulong_t driver_data;	/* Data private to the driver */
@@ -547,6 +548,11 @@ struct amba_id {
  * See documentation of "x86_match_cpu" for details.
  */
 
+/*
+ * MODULE_DEVICE_TABLE expects this struct to be called x86cpu_device_id.
+ * Although gcc seems to ignore this error, clang fails without this define.
+ */
+#define x86cpu_device_id x86_cpu_id
 struct x86_cpu_id {
 	__u16 vendor;
 	__u16 family;
@@ -574,6 +580,7 @@ struct ipack_device_id {
 #define MEI_CL_MODULE_PREFIX "mei:"
 #define MEI_CL_NAME_SIZE 32
 
+#define mei_device_id mei_cl_device_id
 struct mei_cl_device_id {
 	char name[MEI_CL_NAME_SIZE];
 	kernel_ulong_t driver_info;
diff --git a/include/linux/module.h b/include/linux/module.h
index 46f1ea0..761dc28 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -220,6 +220,12 @@ struct module_ref {
 	unsigned long decs;
 } __attribute((aligned(2 * sizeof(unsigned long))));
 
+struct mod_kallsyms {
+	Elf_Sym *symtab;
+	unsigned int num_symtab;
+	char *strtab;
+};
+
 struct module
 {
 	enum module_state state;
@@ -308,14 +314,9 @@ struct module
 #endif
 
 #ifdef CONFIG_KALLSYMS
-	/*
-	 * We keep the symbol and string tables for kallsyms.
-	 * The core_* fields below are temporary, loader-only (they
-	 * could really be discarded after module init).
-	 */
-	Elf_Sym *symtab, *core_symtab;
-	unsigned int num_symtab, core_num_syms;
-	char *strtab, *core_strtab;
+	/* Protected by RCU and/or module_mutex: use rcu_dereference() */
+	struct mod_kallsyms *kallsyms;
+	struct mod_kallsyms core_kallsyms;
 
 	/* Section attributes */
 	struct module_sect_attrs *sect_attrs;
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ab63634..8152ba7 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -549,6 +549,7 @@ struct nand_chip {
 #define NAND_MFR_AMD		0x01
 #define NAND_MFR_MACRONIX	0xc2
 #define NAND_MFR_EON		0x92
+#define NAND_MFR_GD			0xc8
 
 /* The maximum expected count of bytes in the NAND ID sequence */
 #define NAND_MAX_ID_LEN 8
diff --git a/include/linux/net.h b/include/linux/net.h
index 65545ac..d00f1f7 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -291,4 +291,17 @@ extern int kernel_sock_shutdown(struct socket *sock,
 #define MODULE_ALIAS_NET_PF_PROTO_NAME(pf, proto, name) \
 	MODULE_ALIAS("net-pf-" __stringify(pf) "-proto-" __stringify(proto) \
 		     name)
+
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+#define SOCK_SEQ_UPDATE  	0xBADBEEF
+struct sock_sequence_update
+{
+	struct sock *sock;
+	unsigned short ident;
+	unsigned int seq;
+	unsigned int ack;
+	unsigned int seq_offset;
+	unsigned int ack_offset;
+};
+#endif
 #endif	/* _LINUX_NET_H */
diff --git a/include/linux/netfilter/x_tables.h b/include/linux/netfilter/x_tables.h
index dd49566..547a584 100644
--- a/include/linux/netfilter/x_tables.h
+++ b/include/linux/netfilter/x_tables.h
@@ -239,11 +239,18 @@ extern void xt_unregister_match(struct xt_match *target);
 extern int xt_register_matches(struct xt_match *match, unsigned int n);
 extern void xt_unregister_matches(struct xt_match *match, unsigned int n);
 
+int xt_check_entry_offsets(const void *base, const char *elems,
+                           unsigned int target_offset,
+                           unsigned int next_offset);
+
 extern int xt_check_match(struct xt_mtchk_param *,
 			  unsigned int size, u_int8_t proto, bool inv_proto);
 extern int xt_check_target(struct xt_tgchk_param *,
 			   unsigned int size, u_int8_t proto, bool inv_proto);
 
+void *xt_copy_counters_from_user(const void __user *user, unsigned int len,
+				 struct xt_counters_info *info, bool compat);
+
 extern struct xt_table *xt_register_table(struct net *net,
 					  const struct xt_table *table,
 					  struct xt_table_info *bootstrap,
@@ -423,7 +430,7 @@ extern void xt_compat_init_offsets(u_int8_t af, unsigned int number);
 extern int xt_compat_calc_jump(u_int8_t af, unsigned int offset);
 
 extern int xt_compat_match_offset(const struct xt_match *match);
-extern int xt_compat_match_from_user(struct xt_entry_match *m,
+extern void xt_compat_match_from_user(struct xt_entry_match *m,
 				     void **dstptr, unsigned int *size);
 extern int xt_compat_match_to_user(const struct xt_entry_match *m,
 				   void __user **dstptr, unsigned int *size);
@@ -433,6 +440,9 @@ extern void xt_compat_target_from_user(struct xt_entry_target *t,
 				       void **dstptr, unsigned int *size);
 extern int xt_compat_target_to_user(const struct xt_entry_target *t,
 				    void __user **dstptr, unsigned int *size);
+int xt_compat_check_entry_offsets(const void *base, const char *elems,
+                                  unsigned int target_offset,
+                                  unsigned int next_offset);
 
 #endif /* CONFIG_COMPAT */
 #endif /* _X_TABLES_H */
diff --git a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h
index fc01d5c..7d2021d 100644
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@ -578,9 +578,7 @@ static inline void nfs3_forget_cached_acls(struct inode *inode)
 
 static inline loff_t nfs_size_to_loff_t(__u64 size)
 {
-	if (size > (__u64) OFFSET_MAX - 1)
-		return OFFSET_MAX - 1;
-	return (loff_t) size;
+	return min_t(u64, size, OFFSET_MAX);
 }
 
 static inline ino_t
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 54e351a..a9e5134 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1094,7 +1094,7 @@ struct pnfs_ds_commit_info {
 	struct pnfs_commit_bucket *buckets;
 };
 
-#define NFS4_EXCHANGE_ID_LEN	(48)
+#define NFS4_EXCHANGE_ID_LEN	(127)
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
 	nfs4_verifier			*verifier;
diff --git a/include/linux/nilfs2_fs.h b/include/linux/nilfs2_fs.h
index 9875576..1108aca 100644
--- a/include/linux/nilfs2_fs.h
+++ b/include/linux/nilfs2_fs.h
@@ -458,7 +458,7 @@ struct nilfs_btree_node {
 /* level */
 #define NILFS_BTREE_LEVEL_DATA          0
 #define NILFS_BTREE_LEVEL_NODE_MIN      (NILFS_BTREE_LEVEL_DATA + 1)
-#define NILFS_BTREE_LEVEL_MAX           14
+#define NILFS_BTREE_LEVEL_MAX           14	/* Max level (exclusive) */
 
 /**
  * struct nilfs_palloc_group_desc - block group descriptor
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 102136a..655ef37 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -330,6 +330,7 @@ struct pci_dev {
 	unsigned int	__aer_firmware_first:1;
 	unsigned int	broken_intx_masking:1;
 	unsigned int	io_window_1k:1;	/* Intel P2P bridge 1K I/O windows */
+	unsigned int	non_compliant_bars:1;	/* broken BARs; ignore them */
 	pci_dev_flags_t dev_flags;
 	atomic_t	enable_cnt;	/* pci_enable_device has been called */
 
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 6c7bb35..302182a 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2472,6 +2472,13 @@
 #define PCI_DEVICE_ID_KORENIX_JETCARDF2	0x1700
 #define PCI_DEVICE_ID_KORENIX_JETCARDF3	0x17ff
 
+#define PCI_VENDOR_ID_NETRONOME		0x19ee
+#define PCI_DEVICE_ID_NETRONOME_NFP3200	0x3200
+#define PCI_DEVICE_ID_NETRONOME_NFP3240	0x3240
+#define PCI_DEVICE_ID_NETRONOME_NFP4000	0x4000
+#define PCI_DEVICE_ID_NETRONOME_NFP6000	0x6000
+#define PCI_DEVICE_ID_NETRONOME_NFP6000_VF	0x6003
+
 #define PCI_VENDOR_ID_QMI		0x1a32
 
 #define PCI_VENDOR_ID_AZWAVE		0x1a3b
diff --git a/include/linux/pipe_fs_i.h b/include/linux/pipe_fs_i.h
index ab57526..b3374f6 100644
--- a/include/linux/pipe_fs_i.h
+++ b/include/linux/pipe_fs_i.h
@@ -42,6 +42,7 @@ struct pipe_buffer {
  *	@fasync_readers: reader side fasync
  *	@fasync_writers: writer side fasync
  *	@bufs: the circular array of pipe buffers
+ *	@user: the user who created this pipe
  **/
 struct pipe_inode_info {
 	struct mutex mutex;
@@ -57,6 +58,7 @@ struct pipe_inode_info {
 	struct fasync_struct *fasync_readers;
 	struct fasync_struct *fasync_writers;
 	struct pipe_buffer *bufs;
+	struct user_struct *user;
 };
 
 /*
@@ -140,6 +142,8 @@ void pipe_unlock(struct pipe_inode_info *);
 void pipe_double_lock(struct pipe_inode_info *, struct pipe_inode_info *);
 
 extern unsigned int pipe_max_size, pipe_min_size;
+extern unsigned long pipe_user_pages_hard;
+extern unsigned long pipe_user_pages_soft;
 int pipe_proc_fn(struct ctl_table *, int, void __user *, size_t *, loff_t *);
 
 
diff --git a/include/linux/poison.h b/include/linux/poison.h
index 2110a81..253c9b4 100644
--- a/include/linux/poison.h
+++ b/include/linux/poison.h
@@ -19,8 +19,8 @@
  * under normal circumstances, used to verify that nobody uses
  * non-initialized list entries.
  */
-#define LIST_POISON1  ((void *) 0x00100100 + POISON_POINTER_DELTA)
-#define LIST_POISON2  ((void *) 0x00200200 + POISON_POINTER_DELTA)
+#define LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)
+#define LIST_POISON2  ((void *) 0x200 + POISON_POINTER_DELTA)
 
 /********** include/linux/timer.h **********/
 /*
diff --git a/include/linux/ptrace.h b/include/linux/ptrace.h
index bb980ae..6af8988 100644
--- a/include/linux/ptrace.h
+++ b/include/linux/ptrace.h
@@ -56,7 +56,29 @@ extern void exit_ptrace(struct task_struct *tracer);
 #define PTRACE_MODE_READ	0x01
 #define PTRACE_MODE_ATTACH	0x02
 #define PTRACE_MODE_NOAUDIT	0x04
-/* Returns true on success, false on denial. */
+#define PTRACE_MODE_FSCREDS 0x08
+#define PTRACE_MODE_REALCREDS 0x10
+
+/* shorthands for READ/ATTACH and FSCREDS/REALCREDS combinations */
+#define PTRACE_MODE_READ_FSCREDS (PTRACE_MODE_READ | PTRACE_MODE_FSCREDS)
+#define PTRACE_MODE_READ_REALCREDS (PTRACE_MODE_READ | PTRACE_MODE_REALCREDS)
+#define PTRACE_MODE_ATTACH_FSCREDS (PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS)
+#define PTRACE_MODE_ATTACH_REALCREDS (PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS)
+
+/**
+ * ptrace_may_access - check whether the caller is permitted to access
+ * a target task.
+ * @task: target task
+ * @mode: selects type of access and caller credentials
+ *
+ * Returns true on success, false on denial.
+ *
+ * One of the flags PTRACE_MODE_FSCREDS and PTRACE_MODE_REALCREDS must
+ * be set in @mode to specify whether the access was requested through
+ * a filesystem syscall (should use effective capabilities and fsuid
+ * of the caller) or through an explicit syscall such as
+ * process_vm_writev or ptrace (and should use the real credentials).
+ */
 extern bool ptrace_may_access(struct task_struct *task, unsigned int mode);
 
 static inline int ptrace_reparented(struct task_struct *child)
diff --git a/include/linux/radix-tree.h b/include/linux/radix-tree.h
index ffc444c..e02e09f 100644
--- a/include/linux/radix-tree.h
+++ b/include/linux/radix-tree.h
@@ -322,12 +322,28 @@ void **radix_tree_next_chunk(struct radix_tree_root *root,
 			     struct radix_tree_iter *iter, unsigned flags);
 
 /**
+ * radix_tree_iter_retry - retry this chunk of the iteration
+ * @iter:	iterator state
+ *
+ * If we iterate over a tree protected only by the RCU lock, a race
+ * against deletion or creation may result in seeing a slot for which
+ * radix_tree_deref_retry() returns true.  If so, call this function
+ * and continue the iteration.
+ */
+static inline __must_check
+void **radix_tree_iter_retry(struct radix_tree_iter *iter)
+{
+	iter->next_index = iter->index;
+	return NULL;
+}
+
+/**
  * radix_tree_chunk_size - get current chunk size
  *
  * @iter:	pointer to radix tree iterator
  * Returns:	current chunk size
  */
-static __always_inline unsigned
+static __always_inline long
 radix_tree_chunk_size(struct radix_tree_iter *iter)
 {
 	return iter->next_index - iter->index;
@@ -361,9 +377,9 @@ radix_tree_next_slot(void **slot, struct radix_tree_iter *iter, unsigned flags)
 			return slot + offset + 1;
 		}
 	} else {
-		unsigned size = radix_tree_chunk_size(iter) - 1;
+		long size = radix_tree_chunk_size(iter);
 
-		while (size--) {
+		while (--size > 0) {
 			slot++;
 			iter->index++;
 			if (likely(*slot))
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 00c1d4f..7728941 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -670,6 +670,8 @@ struct user_struct {
 	unsigned long mq_bytes;	/* How many bytes can be allocated to mqueue? */
 #endif
 	unsigned long locked_shm; /* How many pages of mlocked shm ? */
+	unsigned long unix_inflight;	/* How many files in flight in unix sockets */
+	atomic_long_t pipe_bufs;  /* how many pages are allocated in pipe buffers */
 
 #ifdef CONFIG_KEYS
 	struct key *uid_keyring;	/* UID specific keyring */
@@ -2203,15 +2205,15 @@ static inline bool thread_group_leader(struct task_struct *p)
  * all we care about is that we have a task with the appropriate
  * pid, we don't actually care if we have the right task.
  */
-static inline int has_group_leader_pid(struct task_struct *p)
+static inline bool has_group_leader_pid(struct task_struct *p)
 {
-	return p->pid == p->tgid;
+	return task_pid(p) == p->signal->leader_pid;
 }
 
 static inline
-int same_thread_group(struct task_struct *p1, struct task_struct *p2)
+bool same_thread_group(struct task_struct *p1, struct task_struct *p2)
 {
-	return p1->tgid == p2->tgid;
+	return p1->signal == p2->signal;
 }
 
 static inline struct task_struct *next_thread(const struct task_struct *p)
diff --git a/include/linux/security.h b/include/linux/security.h
index 4686491..4e50307 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -2394,7 +2394,7 @@ static inline int security_task_prctl(int option, unsigned long arg2,
 				      unsigned long arg4,
 				      unsigned long arg5)
 {
-	return cap_task_prctl(option, arg2, arg3, arg3, arg5);
+	return cap_task_prctl(option, arg2, arg3, arg4, arg5);
 }
 
 static inline void security_task_to_inode(struct task_struct *p, struct inode *inode)
diff --git a/include/linux/signal.h b/include/linux/signal.h
index 2ac423b..53944e5 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -247,7 +247,6 @@ extern int sigprocmask(int, sigset_t *, sigset_t *);
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
-extern int sigsuspend(sigset_t *);
 
 struct sigaction {
 #ifndef __ARCH_HAS_IRIX_SIGACTION
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 478120a..993e347 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -2363,6 +2363,9 @@ static inline void skb_postpull_rcsum(struct sk_buff *skb,
 {
 	if (skb->ip_summed == CHECKSUM_COMPLETE)
 		skb->csum = csum_sub(skb->csum, csum_partial(start, len, 0));
+	else if (skb->ip_summed == CHECKSUM_PARTIAL &&
+		 skb_checksum_start_offset(skb) < 0)
+		skb->ip_summed = CHECKSUM_NONE;
 }
 
 unsigned char *skb_pull_rcsum(struct sk_buff *skb, unsigned int len);
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 84662ec..e1bc430 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -498,7 +498,7 @@ asmlinkage long sys_chown(const char __user *filename,
 asmlinkage long sys_lchown(const char __user *filename,
 				uid_t user, gid_t group);
 asmlinkage long sys_fchown(unsigned int fd, uid_t user, gid_t group);
-#ifdef CONFIG_UID16
+#ifdef CONFIG_HAVE_UID16
 asmlinkage long sys_chown16(const char __user *filename,
 				old_uid_t user, old_gid_t group);
 asmlinkage long sys_lchown16(const char __user *filename,
diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h
index ba60501..36e5e99 100644
--- a/include/linux/tracepoint.h
+++ b/include/linux/tracepoint.h
@@ -14,8 +14,11 @@
  * See the file COPYING for more details.
  */
 
+#include <linux/smp.h>
 #include <linux/errno.h>
 #include <linux/types.h>
+#include <linux/percpu.h>
+#include <linux/cpumask.h>
 #include <linux/rcupdate.h>
 #include <linux/static_key.h>
 
@@ -259,15 +262,19 @@ static inline void tracepoint_synchronize_unregister(void)
  * "void *__data, proto" as the callback prototype.
  */
 #define DECLARE_TRACE_NOARGS(name)					\
-		__DECLARE_TRACE(name, void, , 1, void *__data, __data)
+	__DECLARE_TRACE(name, void, ,					\
+			cpu_online(raw_smp_processor_id()),		\
+			void *__data, __data)
 
 #define DECLARE_TRACE(name, proto, args)				\
-		__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args), 1,	\
-				PARAMS(void *__data, proto),		\
-				PARAMS(__data, args))
+	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),		\
+			cpu_online(raw_smp_processor_id()),		\
+			PARAMS(void *__data, proto),			\
+			PARAMS(__data, args))
 
 #define DECLARE_TRACE_CONDITION(name, proto, args, cond)		\
-	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args), PARAMS(cond), \
+	__DECLARE_TRACE(name, PARAMS(proto), PARAMS(args),		\
+			cpu_online(raw_smp_processor_id()) && (PARAMS(cond)), \
 			PARAMS(void *__data, proto),			\
 			PARAMS(__data, args))
 
diff --git a/include/linux/types.h b/include/linux/types.h
index 4d118ba..83db8e5 100644
--- a/include/linux/types.h
+++ b/include/linux/types.h
@@ -35,7 +35,7 @@ typedef __kernel_gid16_t        gid16_t;
 
 typedef unsigned long		uintptr_t;
 
-#ifdef CONFIG_UID16
+#ifdef CONFIG_HAVE_UID16
 /* This is defined by include/asm-{arch}/posix_types.h */
 typedef __kernel_old_uid_t	old_uid_t;
 typedef __kernel_old_gid_t	old_gid_t;
diff --git a/include/linux/ucs2_string.h b/include/linux/ucs2_string.h
index cbb20af..bb679b4 100644
--- a/include/linux/ucs2_string.h
+++ b/include/linux/ucs2_string.h
@@ -11,4 +11,8 @@ unsigned long ucs2_strlen(const ucs2_char_t *s);
 unsigned long ucs2_strsize(const ucs2_char_t *data, unsigned long maxlength);
 int ucs2_strncmp(const ucs2_char_t *a, const ucs2_char_t *b, size_t len);
 
+unsigned long ucs2_utf8size(const ucs2_char_t *src);
+unsigned long ucs2_as_utf8(u8 *dest, const ucs2_char_t *src,
+			   unsigned long maxlength);
+
 #endif /* _LINUX_UCS2_STRING_H_ */
diff --git a/include/linux/usb.h b/include/linux/usb.h
index a0bee5a..28bd3a8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -206,6 +206,32 @@ void usb_put_intf(struct usb_interface *intf);
 #define USB_MAXINTERFACES	32
 #define USB_MAXIADS		(USB_MAXINTERFACES/2)
 
+/*
+ * USB Resume Timer: Every Host controller driver should drive the resume
+ * signalling on the bus for the amount of time defined by this macro.
+ *
+ * That way we will have a 'stable' behavior among all HCDs supported by Linux.
+ *
+ * Note that the USB Specification states we should drive resume for *at least*
+ * 20 ms, but it doesn't give an upper bound. This creates two possible
+ * situations which we want to avoid:
+ *
+ * (a) sometimes an msleep(20) might expire slightly before 20 ms, which causes
+ * us to fail USB Electrical Tests, thus failing Certification
+ *
+ * (b) Some (many) devices actually need more than 20 ms of resume signalling,
+ * and while we can argue that's against the USB Specification, we don't have
+ * control over which devices a certification laboratory will be using for
+ * certification. If CertLab uses a device which was tested against Windows and
+ * that happens to have relaxed resume signalling rules, we might fall into
+ * situations where we fail interoperability and electrical tests.
+ *
+ * In order to avoid both conditions, we're using a 40 ms resume timeout, which
+ * should cope with both LPJ calibration errors and devices not following every
+ * detail of the USB Specification.
+ */
+#define USB_RESUME_TIMEOUT	40 /* ms */
+
 /**
  * struct usb_interface_cache - long-term representation of a device interface
  * @num_altsetting: number of altsettings defined.
diff --git a/include/linux/usb/ehci_def.h b/include/linux/usb/ehci_def.h
index daec99a..1c88b17 100644
--- a/include/linux/usb/ehci_def.h
+++ b/include/linux/usb/ehci_def.h
@@ -178,11 +178,11 @@ struct ehci_regs {
  * PORTSCx
  */
 	/* HOSTPC: offset 0x84 */
-	u32		hostpc[1];	/* HOSTPC extension */
+	u32		hostpc[0];	/* HOSTPC extension */
 #define HOSTPC_PHCD	(1<<22)		/* Phy clock disable */
 #define HOSTPC_PSPD	(3<<25)		/* Port speed detection */
 
-	u32		reserved5[16];
+	u32		reserved5[17];
 
 	/* USBMODE_EX: offset 0xc8 */
 	u32		usbmode_ex;	/* USB Device mode extension */
diff --git a/include/linux/usb/quirks.h b/include/linux/usb/quirks.h
index 49587dc..41ea53c 100644
--- a/include/linux/usb/quirks.h
+++ b/include/linux/usb/quirks.h
@@ -33,4 +33,7 @@
 /* device generates spurious wakeup, ignore remote wakeup capability */
 #define USB_QUIRK_IGNORE_REMOTE_WAKEUP	0x00000200
 
+/* device can't handle Link Power Management */
+#define USB_QUIRK_NO_LPM			BIT(10)
+
 #endif /* __LINUX_USB_QUIRKS_H */
diff --git a/include/net/af_unix.h b/include/net/af_unix.h
index dbdfd2b..6278e4d 100644
--- a/include/net/af_unix.h
+++ b/include/net/af_unix.h
@@ -6,8 +6,8 @@
 #include <linux/mutex.h>
 #include <net/sock.h>
 
-extern void unix_inflight(struct file *fp);
-extern void unix_notinflight(struct file *fp);
+extern void unix_inflight(struct user_struct *user, struct file *fp);
+extern void unix_notinflight(struct user_struct *user, struct file *fp);
 extern void unix_gc(void);
 extern void wait_for_unix_gc(void);
 extern struct sock *unix_get_socket(struct file *filp);
@@ -62,8 +62,13 @@ struct unix_sock {
 #define UNIX_GC_CANDIDATE	0
 #define UNIX_GC_MAYBE_CYCLE	1
 	struct socket_wq	peer_wq;
+	wait_queue_t		peer_wake;
 };
-#define unix_sk(__sk) ((struct unix_sock *)__sk)
+
+static inline struct unix_sock *unix_sk(struct sock *sk)
+{
+	return (struct unix_sock *)sk;
+}
 
 #define peer_wait peer_wq.wait
 
diff --git a/include/net/inet_common.h b/include/net/inet_common.h
index 2340087..102fc42 100644
--- a/include/net/inet_common.h
+++ b/include/net/inet_common.h
@@ -40,7 +40,8 @@ extern int inet_ctl_sock_create(struct sock **sk, unsigned short family,
 
 static inline void inet_ctl_sock_destroy(struct sock *sk)
 {
-	sk_release_kernel(sk);
+	if (sk)
+		sk_release_kernel(sk);
 }
 
 #endif
diff --git a/include/net/ip.h b/include/net/ip.h
index 0a62365..ea9be6b 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -141,6 +141,7 @@ static inline struct sk_buff *ip_finish_skb(struct sock *sk, struct flowi4 *fl4)
 }
 
 /* datagram.c */
+int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
 extern int		ip4_datagram_connect(struct sock *sk, 
 					     struct sockaddr *uaddr, int addr_len);
 
diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h
index 665e0ce..5e661a9 100644
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -301,7 +301,7 @@ extern void			inet6_rt_notify(int event, struct rt6_info *rt,
 						struct nl_info *info);
 
 extern void			fib6_run_gc(unsigned long expires,
-					    struct net *net);
+					    struct net *net, bool force);
 
 extern void			fib6_gc_cleanup(void);
 
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index 087370f..413e23b 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -478,6 +478,7 @@ struct ip6_create_arg {
 	u32 user;
 	const struct in6_addr *src;
 	const struct in6_addr *dst;
+	int iif;
 	u8 ecn;
 };
 
diff --git a/include/net/netns/sctp.h b/include/net/netns/sctp.h
index 3573a81..8ba379f 100644
--- a/include/net/netns/sctp.h
+++ b/include/net/netns/sctp.h
@@ -31,6 +31,7 @@ struct netns_sctp {
 	struct list_head addr_waitq;
 	struct timer_list addr_wq_timer;
 	struct list_head auto_asconf_splist;
+	/* Lock that protects both addr_waitq and auto_asconf_splist */
 	spinlock_t addr_wq_lock;
 
 	/* Lock that protects the local_addr_list writers */
diff --git a/include/net/scm.h b/include/net/scm.h
index 8de2d37..d00cd43 100644
--- a/include/net/scm.h
+++ b/include/net/scm.h
@@ -21,6 +21,7 @@ struct scm_creds {
 struct scm_fp_list {
 	short			count;
 	short			max;
+	struct user_struct	*user;
 	struct file		*fp[SCM_MAX_FD];
 };
 
diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index da6b9a0..b30c1d9 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -228,6 +228,10 @@ struct sctp_sock {
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */
 	struct sk_buff_head pd_lobby;
+
+	/* These must be the last fields, as they will skipped on copies,
+	 * like on accept and peeloff operations
+	 */
 	struct list_head auto_asconf_list;
 	int do_auto_asconf;
 };
diff --git a/include/net/sock.h b/include/net/sock.h
index c0aad07..1dbd6fac 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -352,6 +352,7 @@ struct sock {
 				sk_no_check  : 2,
 				sk_userlocks : 4,
 				sk_protocol  : 8,
+#define SK_PROTOCOL_MAX U8_MAX
 				sk_type      : 16;
 	kmemcheck_bitfield_end(flags);
 	int			sk_wmem_queued;
@@ -672,6 +673,8 @@ enum sock_flags {
 	SOCK_SELECT_ERR_QUEUE, /* Wake select on error queue */
 };
 
+#define SK_FLAGS_TIMESTAMP ((1UL << SOCK_TIMESTAMP) | (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE))
+
 static inline void sock_copy_flags(struct sock *nsk, struct sock *osk)
 {
 	nsk->sk_flags = osk->sk_flags;
@@ -782,6 +785,14 @@ static inline __must_check int sk_add_backlog(struct sock *sk, struct sk_buff *s
 	if (sk_rcvqueues_full(sk, skb, limit))
 		return -ENOBUFS;
 
+	/*
+	 * If the skb was allocated from pfmemalloc reserves, only
+	 * allow SOCK_MEMALLOC sockets to use it as this socket is
+	 * helping free memory
+	 */
+	if (skb_pfmemalloc(skb) && !sock_flag(sk, SOCK_MEMALLOC))
+		return -ENOMEM;
+
 	__sk_add_backlog(sk, skb);
 	sk->sk_backlog.len += skb->truesize;
 	return 0;
@@ -1650,8 +1661,15 @@ static inline void sk_filter_charge(struct sock *sk, struct sk_filter *fp)
 /* Ungrab socket and destroy it, if it was the last reference. */
 static inline void sock_put(struct sock *sk)
 {
-	if (atomic_dec_and_test(&sk->sk_refcnt))
+	if (atomic_dec_and_test(&sk->sk_refcnt)){
+		#ifdef CONFIG_WLAN_UPDATE_SEQ
+		extern struct sock_sequence_update ipv4_update;
+		if(ipv4_update.sock == sk){
+			ipv4_update.sock = NULL;
+		}
+		#endif
 		sk_free(sk);
+    }
 }
 
 extern int sk_receive_skb(struct sock *sk, struct sk_buff *skb,
diff --git a/include/rdma/ib.h b/include/rdma/ib.h
new file mode 100644
index 0000000..f09331a
--- /dev/null
+++ b/include/rdma/ib.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2010 Intel Corporation.  All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined(_RDMA_IB_H)
+#define _RDMA_IB_H
+
+#include <linux/types.h>
+#include <linux/sched.h>
+
+/*
+ * The IB interfaces that use write() as bi-directional ioctl() are
+ * fundamentally unsafe, since there are lots of ways to trigger "write()"
+ * calls from various contexts with elevated privileges. That includes the
+ * traditional suid executable error message writes, but also various kernel
+ * interfaces that can write to file descriptors.
+ *
+ * This function provides protection for the legacy API by restricting the
+ * calling context.
+ */
+static inline bool ib_safe_file_access(struct file *filp)
+{
+	return filp->f_cred == current_cred() && segment_eq(get_fs(), USER_DS);
+}
+
+#endif /* _RDMA_IB_H */
diff --git a/include/sound/ak7755_pdata.h b/include/sound/ak7755_pdata.h
new file mode 100644
index 0000000..1350b1d
--- /dev/null
+++ b/include/sound/ak7755_pdata.h
@@ -0,0 +1,19 @@
+/*
+ * ak7755_pdata.h  --  audio driver for ak4482
+ *
+ * Copyright (C) 2015 Asahi Kasei Microdevices Corporation
+ *  Author                Date        Revision
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *                      15/06/15	    1.0
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
+ */
+
+#ifndef _AK7755_PDADA_H
+#define _AK7755_PDADA_H
+
+struct ak7755_platform_data {
+	int pdn_gpio;
+};
+
+#endif
+
diff --git a/include/sound/emu10k1.h b/include/sound/emu10k1.h
index dfb42ca..8898cde 100644
--- a/include/sound/emu10k1.h
+++ b/include/sound/emu10k1.h
@@ -41,7 +41,8 @@
 
 #define EMUPAGESIZE     4096
 #define MAXREQVOICES    8
-#define MAXPAGES        8192
+#define MAXPAGES0       4096	/* 32 bit mode */
+#define MAXPAGES1       8192	/* 31 bit mode */
 #define RESERVED        0
 #define NUM_MIDI        16
 #define NUM_G           64              /* use all channels */
@@ -50,8 +51,7 @@
 
 /* FIXME? - according to the OSS driver the EMU10K1 needs a 29 bit DMA mask */
 #define EMU10K1_DMA_MASK	0x7fffffffUL	/* 31bit */
-#define AUDIGY_DMA_MASK		0x7fffffffUL	/* 31bit FIXME - 32 should work? */
-						/* See ALSA bug #1276 - rlrevell */
+#define AUDIGY_DMA_MASK		0xffffffffUL	/* 32bit mode */
 
 #define TMEMSIZE        256*1024
 #define TMEMSIZEREG     4
@@ -468,8 +468,11 @@
 
 #define MAPB			0x0d		/* Cache map B						*/
 
-#define MAP_PTE_MASK		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/
-#define MAP_PTI_MASK		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/
+#define MAP_PTE_MASK0		0xfffff000	/* The 20 MSBs of the PTE indexed by the PTI		*/
+#define MAP_PTI_MASK0		0x00000fff	/* The 12 bit index to one of the 4096 PTE dwords      	*/
+
+#define MAP_PTE_MASK1		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/
+#define MAP_PTI_MASK1		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/
 
 /* 0x0e, 0x0f: Not used */
 
@@ -1706,6 +1709,7 @@ struct snd_emu10k1 {
 	unsigned short model;			/* subsystem id */
 	unsigned int card_type;			/* EMU10K1_CARD_* */
 	unsigned int ecard_ctrl;		/* ecard control bits */
+	unsigned int address_mode;		/* address mode */
 	unsigned long dma_mask;			/* PCI DMA mask */
 	unsigned int delay_pcm_irq;		/* in samples */
 	int max_cache_pages;			/* max memory size / PAGE_SIZE */
diff --git a/include/sound/wm8904.h b/include/sound/wm8904.h
index 898be3a..6d8f8fb 100644
--- a/include/sound/wm8904.h
+++ b/include/sound/wm8904.h
@@ -119,7 +119,7 @@
 #define WM8904_MIC_REGS  2
 #define WM8904_GPIO_REGS 4
 #define WM8904_DRC_REGS  4
-#define WM8904_EQ_REGS   25
+#define WM8904_EQ_REGS   24
 
 /**
  * DRC configurations are specified with a label and a set of register
diff --git a/include/uapi/linux/const.h b/include/uapi/linux/const.h
index c22c707..c872bfd 100644
--- a/include/uapi/linux/const.h
+++ b/include/uapi/linux/const.h
@@ -21,4 +21,7 @@
 #define _AT(T,X)	((T)(X))
 #endif
 
+#define _BITUL(x)	(_AC(1,UL) << (x))
+#define _BITULL(x)	(_AC(1,ULL) << (x))
+
 #endif /* !(_LINUX_CONST_H) */
diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 0c65e4b..ef29266 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -125,11 +125,12 @@ struct usbdevfs_hub_portinfo {
 	char port [127];	/* e.g. port 3 connects to device 27 */
 };
 
-/* Device capability flags */
+/* System and bus capability flags */
 #define USBDEVFS_CAP_ZERO_PACKET		0x01
 #define USBDEVFS_CAP_BULK_CONTINUATION		0x02
 #define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
 #define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
+#define USBDEVFS_CAP_REAP_AFTER_DISCONNECT	0x10
 
 /* USBDEVFS_DISCONNECT_CLAIM flags & struct */
 
diff --git a/include/xen/interface/sched.h b/include/xen/interface/sched.h
index 9ce0839..f184909 100644
--- a/include/xen/interface/sched.h
+++ b/include/xen/interface/sched.h
@@ -107,5 +107,13 @@ struct sched_watchdog {
 #define SHUTDOWN_suspend    2  /* Clean up, save suspend info, kill.         */
 #define SHUTDOWN_crash      3  /* Tell controller we've crashed.             */
 #define SHUTDOWN_watchdog   4  /* Restart because watchdog time expired.     */
+/*
+ * Domain asked to perform 'soft reset' for it. The expected behavior is to
+ * reset internal Xen state for the domain returning it to the point where it
+ * was created but leaving the domain's memory contents and vCPU contexts
+ * intact. This will allow the domain to start over and set up all Xen specific
+ * interfaces again.
+ */
+#define SHUTDOWN_soft_reset 5
 
 #endif /* __XEN_PUBLIC_SCHED_H__ */
diff --git a/ipc/compat.c b/ipc/compat.c
index 892f658..d3b3760 100644
--- a/ipc/compat.c
+++ b/ipc/compat.c
@@ -381,7 +381,7 @@ COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
 			uptr = compat_ptr(ipck.msgp);
 			fifth = ipck.msgtyp;
 		}
-		return do_msgrcv(first, uptr, second, fifth, third,
+		return do_msgrcv(first, uptr, second, (s32)fifth, third,
 				 compat_do_msg_fill);
 	}
 	case MSGGET:
diff --git a/ipc/mqueue.c b/ipc/mqueue.c
index bb0248f..82bb5e8 100644
--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -143,7 +143,6 @@ static int msg_insert(struct msg_msg *msg, struct mqueue_inode_info *info)
 		if (!leaf)
 			return -ENOMEM;
 		INIT_LIST_HEAD(&leaf->msg_list);
-		info->qsize += sizeof(*leaf);
 	}
 	leaf->priority = msg->m_type;
 	rb_link_node(&leaf->rb_node, parent, p);
@@ -188,7 +187,6 @@ try_again:
 			     "lazy leaf delete!\n");
 		rb_erase(&leaf->rb_node, &info->msg_tree);
 		if (info->node_cache) {
-			info->qsize -= sizeof(*leaf);
 			kfree(leaf);
 		} else {
 			info->node_cache = leaf;
@@ -201,7 +199,6 @@ try_again:
 		if (list_empty(&leaf->msg_list)) {
 			rb_erase(&leaf->rb_node, &info->msg_tree);
 			if (info->node_cache) {
-				info->qsize -= sizeof(*leaf);
 				kfree(leaf);
 			} else {
 				info->node_cache = leaf;
@@ -1026,7 +1023,6 @@ SYSCALL_DEFINE5(mq_timedsend, mqd_t, mqdes, const char __user *, u_msg_ptr,
 		/* Save our speculative allocation into the cache */
 		INIT_LIST_HEAD(&new_leaf->msg_list);
 		info->node_cache = new_leaf;
-		info->qsize += sizeof(*new_leaf);
 		new_leaf = NULL;
 	} else {
 		kfree(new_leaf);
@@ -1133,7 +1129,6 @@ SYSCALL_DEFINE5(mq_timedreceive, mqd_t, mqdes, char __user *, u_msg_ptr,
 		/* Save our speculative allocation into the cache */
 		INIT_LIST_HEAD(&new_leaf->msg_list);
 		info->node_cache = new_leaf;
-		info->qsize += sizeof(*new_leaf);
 	} else {
 		kfree(new_leaf);
 	}
diff --git a/ipc/msg.c b/ipc/msg.c
index 52770bf..32aaaab 100644
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -202,13 +202,6 @@ static int newque(struct ipc_namespace *ns, struct ipc_params *params)
 		return retval;
 	}
 
-	/* ipc_addid() locks msq upon success. */
-	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
-	if (id < 0) {
-		ipc_rcu_putref(msq, msg_rcu_free);
-		return id;
-	}
-
 	msq->q_stime = msq->q_rtime = 0;
 	msq->q_ctime = get_seconds();
 	msq->q_cbytes = msq->q_qnum = 0;
@@ -218,6 +211,13 @@ static int newque(struct ipc_namespace *ns, struct ipc_params *params)
 	INIT_LIST_HEAD(&msq->q_receivers);
 	INIT_LIST_HEAD(&msq->q_senders);
 
+	/* ipc_addid() locks msq upon success. */
+	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
+	if (id < 0) {
+		ipc_rcu_putref(msq, msg_rcu_free);
+		return id;
+	}
+
 	ipc_unlock_object(&msq->q_perm);
 	rcu_read_unlock();
 
diff --git a/ipc/sem.c b/ipc/sem.c
index db9d241..47a1519 100644
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -253,6 +253,16 @@ static void sem_rcu_free(struct rcu_head *head)
 }
 
 /*
+ * spin_unlock_wait() and !spin_is_locked() are not memory barriers, they
+ * are only control barriers.
+ * The code must pair with spin_unlock(&sem->lock) or
+ * spin_unlock(&sem_perm.lock), thus just the control barrier is insufficient.
+ *
+ * smp_rmb() is sufficient, as writes cannot pass the control barrier.
+ */
+#define ipc_smp_acquire__after_spin_is_unlocked()	smp_rmb()
+
+/*
  * Wait until all currently ongoing simple ops have completed.
  * Caller must own sem_perm.lock.
  * New simple ops cannot start, because simple ops first check
@@ -275,6 +285,7 @@ static void sem_wait_array(struct sem_array *sma)
 		sem = sma->sem_base + i;
 		spin_unlock_wait(&sem->lock);
 	}
+	ipc_smp_acquire__after_spin_is_unlocked();
 }
 
 /*
@@ -326,8 +337,13 @@ static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,
 
 		/* Then check that the global lock is free */
 		if (!spin_is_locked(&sma->sem_perm.lock)) {
-			/* spin_is_locked() is not a memory barrier */
-			smp_mb();
+			/*
+			 * We need a memory barrier with acquire semantics,
+			 * otherwise we can race with another thread that does:
+			 *	complex_count++;
+			 *	spin_unlock(sem_perm.lock);
+			 */
+			ipc_smp_acquire__after_spin_is_unlocked();
 
 			/* Now repeat the test of complex_count:
 			 * It can't change anymore until we drop sem->lock.
@@ -2049,17 +2065,28 @@ void exit_sem(struct task_struct *tsk)
 		rcu_read_lock();
 		un = list_entry_rcu(ulp->list_proc.next,
 				    struct sem_undo, list_proc);
-		if (&un->list_proc == &ulp->list_proc)
-			semid = -1;
-		 else
-			semid = un->semid;
+		if (&un->list_proc == &ulp->list_proc) {
+			/*
+			 * We must wait for freeary() before freeing this ulp,
+			 * in case we raced with last sem_undo. There is a small
+			 * possibility where we exit while freeary() didn't
+			 * finish unlocking sem_undo_list.
+			 */
+			spin_unlock_wait(&ulp->lock);
+			rcu_read_unlock();
+			break;
+		}
+		spin_lock(&ulp->lock);
+		semid = un->semid;
+		spin_unlock(&ulp->lock);
 
+		/* exit_sem raced with IPC_RMID, nothing to do */
 		if (semid == -1) {
 			rcu_read_unlock();
-			break;
+			continue;
 		}
 
-		sma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);
+		sma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, semid);
 		/* exit_sem raced with IPC_RMID, nothing to do */
 		if (IS_ERR(sma)) {
 			rcu_read_unlock();
diff --git a/ipc/shm.c b/ipc/shm.c
index 6dc55af..08b14f6 100644
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -544,12 +544,6 @@ static int newseg(struct ipc_namespace *ns, struct ipc_params *params)
 	if (IS_ERR(file))
 		goto no_file;
 
-	id = ipc_addid(&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni);
-	if (id < 0) {
-		error = id;
-		goto no_id;
-	}
-
 	shp->shm_cprid = task_tgid_vnr(current);
 	shp->shm_lprid = 0;
 	shp->shm_atim = shp->shm_dtim = 0;
@@ -559,6 +553,12 @@ static int newseg(struct ipc_namespace *ns, struct ipc_params *params)
 	shp->shm_file = file;
 	shp->shm_creator = current;
 
+	id = ipc_addid(&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni);
+	if (id < 0) {
+		error = id;
+		goto no_id;
+	}
+
 	/*
 	 * shmid gets reported as "inode#" in /proc/pid/maps.
 	 * proc-ps tools use this. Changing this will break them.
diff --git a/ipc/util.c b/ipc/util.c
index 7684f41..73534257 100644
--- a/ipc/util.c
+++ b/ipc/util.c
@@ -292,6 +292,10 @@ int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size)
 	rcu_read_lock();
 	spin_lock(&new->lock);
 
+	current_euid_egid(&euid, &egid);
+	new->cuid = new->uid = euid;
+	new->gid = new->cgid = egid;
+
 	id = idr_alloc(&ids->ipcs_idr, new,
 		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
 		       GFP_NOWAIT);
@@ -304,10 +308,6 @@ int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size)
 
 	ids->in_use++;
 
-	current_euid_egid(&euid, &egid);
-	new->cuid = new->uid = euid;
-	new->gid = new->cgid = egid;
-
 	if (next_id < 0) {
 		new->seq = ids->seq++;
 		if (ids->seq > ids->seq_max)
diff --git a/kernel/cgroup.c b/kernel/cgroup.c
index d0def7f..ef13060 100644
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@ -984,7 +984,7 @@ static void cgroup_d_remove_dir(struct dentry *dentry)
 	parent = dentry->d_parent;
 	spin_lock(&parent->d_lock);
 	spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
-	list_del_init(&dentry->d_u.d_child);
+	list_del_init(&dentry->d_child);
 	spin_unlock(&dentry->d_lock);
 	spin_unlock(&parent->d_lock);
 	remove_dir(dentry);
diff --git a/kernel/events/core.c b/kernel/events/core.c
index 7bf4d51..0f52078 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -2938,7 +2938,7 @@ find_lively_task_by_vpid(pid_t vpid)
 
 	/* Reuse ptrace permission checks for now. */
 	err = -EACCES;
-	if (!ptrace_may_access(task, PTRACE_MODE_READ))
+	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
 		goto errout;
 
 	return task;
@@ -3993,12 +3993,20 @@ static const struct file_operations perf_fops = {
  * to user-space before waking everybody up.
  */
 
+static inline struct fasync_struct **perf_event_fasync(struct perf_event *event)
+{
+	/* only the parent has fasync state */
+	if (event->parent)
+		event = event->parent;
+	return &event->fasync;
+}
+
 void perf_event_wakeup(struct perf_event *event)
 {
 	ring_buffer_wakeup(event);
 
 	if (event->pending_kill) {
-		kill_fasync(&event->fasync, SIGIO, event->pending_kill);
+		kill_fasync(perf_event_fasync(event), SIGIO, event->pending_kill);
 		event->pending_kill = 0;
 	}
 }
@@ -4007,6 +4015,13 @@ static void perf_pending_event(struct irq_work *entry)
 {
 	struct perf_event *event = container_of(entry,
 			struct perf_event, pending);
+	int rctx;
+
+	rctx = perf_swevent_get_recursion_context();
+	/*
+	 * If we 'fail' here, that's OK, it means recursion is already disabled
+	 * and we won't recurse 'further'.
+	 */
 
 	if (event->pending_disable) {
 		event->pending_disable = 0;
@@ -4017,6 +4032,9 @@ static void perf_pending_event(struct irq_work *entry)
 		event->pending_wakeup = 0;
 		perf_event_wakeup(event);
 	}
+
+	if (rctx >= 0)
+		perf_swevent_put_recursion_context(rctx);
 }
 
 /*
@@ -5143,7 +5161,7 @@ static int __perf_event_overflow(struct perf_event *event,
 	else
 		perf_event_output(event, data, regs);
 
-	if (event->fasync && event->pending_kill) {
+	if (*perf_event_fasync(event) && event->pending_kill) {
 		event->pending_wakeup = 1;
 		irq_work_queue(&event->pending);
 	}
@@ -5621,6 +5639,10 @@ static int perf_tp_filter_match(struct perf_event *event,
 {
 	void *record = data->raw->data;
 
+	/* only top level events have filters set */
+	if (event->parent)
+		event = event->parent;
+
 	if (likely(!event->filter) || filter_match_preds(event->filter, record))
 		return 1;
 	return 0;
diff --git a/kernel/fork.c b/kernel/fork.c
index 514dbc4..2358bd4 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1760,13 +1760,21 @@ static int check_unshare_flags(unsigned long unshare_flags)
 				CLONE_NEWUSER|CLONE_NEWPID))
 		return -EINVAL;
 	/*
-	 * Not implemented, but pretend it works if there is nothing to
-	 * unshare. Note that unsharing CLONE_THREAD or CLONE_SIGHAND
-	 * needs to unshare vm.
+	 * Not implemented, but pretend it works if there is nothing
+	 * to unshare.  Note that unsharing the address space or the
+	 * signal handlers also need to unshare the signal queues (aka
+	 * CLONE_THREAD).
 	 */
 	if (unshare_flags & (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {
-		/* FIXME: get_task_mm() increments ->mm_users */
-		if (atomic_read(&current->mm->mm_users) > 1)
+		if (!thread_group_empty(current))
+			return -EINVAL;
+	}
+	if (unshare_flags & (CLONE_SIGHAND | CLONE_VM)) {
+		if (atomic_read(&current->sighand->count) > 1)
+			return -EINVAL;
+	}
+	if (unshare_flags & CLONE_VM) {
+		if (!current_is_single_threaded())
 			return -EINVAL;
 	}
 
@@ -1840,16 +1848,16 @@ SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)
 	if (unshare_flags & CLONE_NEWPID)
 		unshare_flags |= CLONE_THREAD;
 	/*
-	 * If unsharing a thread from a thread group, must also unshare vm.
-	 */
-	if (unshare_flags & CLONE_THREAD)
-		unshare_flags |= CLONE_VM;
-	/*
 	 * If unsharing vm, must also unshare signal handlers.
 	 */
 	if (unshare_flags & CLONE_VM)
 		unshare_flags |= CLONE_SIGHAND;
 	/*
+	 * If unsharing a signal handlers, must also unshare the signal queues.
+	 */
+	if (unshare_flags & CLONE_SIGHAND)
+		unshare_flags |= CLONE_THREAD;
+	/*
 	 * If unsharing namespace, must also unshare filesystem information.
 	 */
 	if (unshare_flags & CLONE_NEWNS)
diff --git a/kernel/futex.c b/kernel/futex.c
index 625a4e6..edc4bea 100644
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@ -2494,6 +2494,11 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,
 		if (q.pi_state && (q.pi_state->owner != current)) {
 			spin_lock(q.lock_ptr);
 			ret = fixup_pi_state_owner(uaddr2, &q, current);
+			/*
+			 * Drop the reference to the pi state which
+			 * the requeue_pi() code acquired for us.
+			 */
+			free_pi_state(q.pi_state);
 			spin_unlock(q.lock_ptr);
 		}
 	} else {
@@ -2620,7 +2625,7 @@ SYSCALL_DEFINE3(get_robust_list, int, pid,
 	}
 
 	ret = -EPERM;
-	if (!ptrace_may_access(p, PTRACE_MODE_READ))
+	if (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))
 		goto err_unlock;
 
 	head = p->robust_list;
diff --git a/kernel/futex_compat.c b/kernel/futex_compat.c
index f9f44fd..3888617 100644
--- a/kernel/futex_compat.c
+++ b/kernel/futex_compat.c
@@ -155,7 +155,7 @@ COMPAT_SYSCALL_DEFINE3(get_robust_list, int, pid,
 	}
 
 	ret = -EPERM;
-	if (!ptrace_may_access(p, PTRACE_MODE_READ))
+	if (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))
 		goto err_unlock;
 
 	head = p->compat_robust_list;
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index a79d267..7b0d31b 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -1229,6 +1229,7 @@ static struct irqaction *__free_irq(unsigned int irq, void *dev_id)
 	if (!desc)
 		return NULL;
 
+	chip_bus_lock(desc);
 	raw_spin_lock_irqsave(&desc->lock, flags);
 
 	/*
@@ -1242,7 +1243,7 @@ static struct irqaction *__free_irq(unsigned int irq, void *dev_id)
 		if (!action) {
 			WARN(1, "Trying to free already-free IRQ %d\n", irq);
 			raw_spin_unlock_irqrestore(&desc->lock, flags);
-
+			chip_bus_sync_unlock(desc);
 			return NULL;
 		}
 
@@ -1265,6 +1266,7 @@ static struct irqaction *__free_irq(unsigned int irq, void *dev_id)
 #endif
 
 	raw_spin_unlock_irqrestore(&desc->lock, flags);
+	chip_bus_sync_unlock(desc);
 
 	unregister_handler_proc(irq, action);
 
@@ -1338,9 +1340,7 @@ void free_irq(unsigned int irq, void *dev_id)
 		desc->affinity_notify = NULL;
 #endif
 
-	chip_bus_lock(desc);
 	kfree(__free_irq(irq, dev_id));
-	chip_bus_sync_unlock(desc);
 }
 EXPORT_SYMBOL(free_irq);
 
diff --git a/kernel/irq/proc.c b/kernel/irq/proc.c
index 19ed5c4..349e5bb 100644
--- a/kernel/irq/proc.c
+++ b/kernel/irq/proc.c
@@ -12,6 +12,7 @@
 #include <linux/seq_file.h>
 #include <linux/interrupt.h>
 #include <linux/kernel_stat.h>
+#include <linux/mutex.h>
 
 #include "internals.h"
 
@@ -309,18 +310,29 @@ void register_handler_proc(unsigned int irq, struct irqaction *action)
 
 void register_irq_proc(unsigned int irq, struct irq_desc *desc)
 {
+	static DEFINE_MUTEX(register_lock);
 	char name [MAX_NAMELEN];
 
-	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip) || desc->dir)
+	if (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))
 		return;
 
+	/*
+	 * irq directories are registered only when a handler is
+	 * added, not when the descriptor is created, so multiple
+	 * tasks might try to register at the same time.
+	 */
+	mutex_lock(&register_lock);
+
+	if (desc->dir)
+		goto out_unlock;
+
 	memset(name, 0, MAX_NAMELEN);
 	sprintf(name, "%d", irq);
 
 	/* create /proc/irq/1234 */
 	desc->dir = proc_mkdir(name, root_irq_dir);
 	if (!desc->dir)
-		return;
+		goto out_unlock;
 
 #ifdef CONFIG_SMP
 	/* create /proc/irq/<irq>/smp_affinity */
@@ -341,6 +353,9 @@ void register_irq_proc(unsigned int irq, struct irq_desc *desc)
 
 	proc_create_data("spurious", 0444, desc->dir,
 			 &irq_spurious_proc_fops, (void *)(long)irq);
+
+out_unlock:
+	mutex_unlock(&register_lock);
 }
 
 void unregister_irq_proc(unsigned int irq, struct irq_desc *desc)
diff --git a/kernel/irq/resend.c b/kernel/irq/resend.c
index 9065107..7a5237a 100644
--- a/kernel/irq/resend.c
+++ b/kernel/irq/resend.c
@@ -75,13 +75,21 @@ void check_irq_resend(struct irq_desc *desc, unsigned int irq)
 		    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {
 #ifdef CONFIG_HARDIRQS_SW_RESEND
 			/*
-			 * If the interrupt has a parent irq and runs
-			 * in the thread context of the parent irq,
-			 * retrigger the parent.
+			 * If the interrupt is running in the thread
+			 * context of the parent irq we need to be
+			 * careful, because we cannot trigger it
+			 * directly.
 			 */
-			if (desc->parent_irq &&
-			    irq_settings_is_nested_thread(desc))
+			if (irq_settings_is_nested_thread(desc)) {
+				/*
+				 * If the parent_irq is valid, we
+				 * retrigger the parent, otherwise we
+				 * do nothing.
+				 */
+				if (!desc->parent_irq)
+					return;
 				irq = desc->parent_irq;
+			}
 			/* Set it pending and activate the softirq: */
 			set_bit(irq, irqs_resend);
 			tasklet_schedule(&resend_tasklet);
diff --git a/kernel/kcmp.c b/kernel/kcmp.c
index 0aa69ea..3a47fa9 100644
--- a/kernel/kcmp.c
+++ b/kernel/kcmp.c
@@ -122,8 +122,8 @@ SYSCALL_DEFINE5(kcmp, pid_t, pid1, pid_t, pid2, int, type,
 			&task2->signal->cred_guard_mutex);
 	if (ret)
 		goto err;
-	if (!ptrace_may_access(task1, PTRACE_MODE_READ) ||
-	    !ptrace_may_access(task2, PTRACE_MODE_READ)) {
+	if (!ptrace_may_access(task1, PTRACE_MODE_READ_REALCREDS) ||
+	    !ptrace_may_access(task2, PTRACE_MODE_READ_REALCREDS)) {
 		ret = -EPERM;
 		goto err_unlock;
 	}
diff --git a/kernel/module.c b/kernel/module.c
index 61fb677..2c87e52 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -179,6 +179,9 @@ struct load_info {
 	struct _ddebug *debug;
 	unsigned int num_debug;
 	bool sig_ok;
+#ifdef CONFIG_KALLSYMS
+	unsigned long mod_kallsyms_init_off;
+#endif
 	struct {
 		unsigned int sym, str, mod, vers, info, pcpu;
 	} index;
@@ -942,11 +945,15 @@ void symbol_put_addr(void *addr)
 	if (core_kernel_text(a))
 		return;
 
-	/* module_text_address is safe here: we're supposed to have reference
-	 * to module from symbol_get, so it can't go away. */
+	/*
+	 * Even though we hold a reference on the module; we still need to
+	 * disable preemption in order to safely traverse the data structure.
+	 */
+	preempt_disable();
 	modaddr = __module_text_address(a);
 	BUG_ON(!modaddr);
 	module_put(modaddr);
+	preempt_enable();
 }
 EXPORT_SYMBOL_GPL(symbol_put_addr);
 
@@ -2342,8 +2349,20 @@ static void layout_symtab(struct module *mod, struct load_info *info)
 	strsect->sh_entsize = get_offset(mod, &mod->init_size, strsect,
 					 info->index.str) | INIT_OFFSET_MASK;
 	pr_debug("\t%s\n", info->secstrings + strsect->sh_name);
+
+	/* We'll tack temporary mod_kallsyms on the end. */
+	mod->init_size = ALIGN(mod->init_size,
+			       __alignof__(struct mod_kallsyms));
+	info->mod_kallsyms_init_off = mod->init_size;
+	mod->init_size += sizeof(struct mod_kallsyms);
+	mod->init_size = debug_align(mod->init_size);
 }
 
+/*
+ * We use the full symtab and strtab which layout_symtab arranged to
+ * be appended to the init section.  Later we switch to the cut-down
+ * core-only ones.
+ */
 static void add_kallsyms(struct module *mod, const struct load_info *info)
 {
 	unsigned int i, ndst;
@@ -2352,28 +2371,33 @@ static void add_kallsyms(struct module *mod, const struct load_info *info)
 	char *s;
 	Elf_Shdr *symsec = &info->sechdrs[info->index.sym];
 
-	mod->symtab = (void *)symsec->sh_addr;
-	mod->num_symtab = symsec->sh_size / sizeof(Elf_Sym);
+	/* Set up to point into init section. */
+	mod->kallsyms = mod->module_init + info->mod_kallsyms_init_off;
+
+	mod->kallsyms->symtab = (void *)symsec->sh_addr;
+	mod->kallsyms->num_symtab = symsec->sh_size / sizeof(Elf_Sym);
 	/* Make sure we get permanent strtab: don't use info->strtab. */
-	mod->strtab = (void *)info->sechdrs[info->index.str].sh_addr;
+	mod->kallsyms->strtab = (void *)info->sechdrs[info->index.str].sh_addr;
 
 	/* Set types up while we still have access to sections. */
-	for (i = 0; i < mod->num_symtab; i++)
-		mod->symtab[i].st_info = elf_type(&mod->symtab[i], info);
-
-	mod->core_symtab = dst = mod->module_core + info->symoffs;
-	mod->core_strtab = s = mod->module_core + info->stroffs;
-	src = mod->symtab;
-	for (ndst = i = 0; i < mod->num_symtab; i++) {
+	for (i = 0; i < mod->kallsyms->num_symtab; i++)
+		mod->kallsyms->symtab[i].st_info
+			= elf_type(&mod->kallsyms->symtab[i], info);
+
+	/* Now populate the cut down core kallsyms for after init. */
+	mod->core_kallsyms.symtab = dst = mod->module_core + info->symoffs;
+	mod->core_kallsyms.strtab = s = mod->module_core + info->stroffs;
+	src = mod->kallsyms->symtab;
+	for (ndst = i = 0; i < mod->kallsyms->num_symtab; i++) {
 		if (i == 0 ||
 		    is_core_symbol(src+i, info->sechdrs, info->hdr->e_shnum)) {
 			dst[ndst] = src[i];
-			dst[ndst++].st_name = s - mod->core_strtab;
-			s += strlcpy(s, &mod->strtab[src[i].st_name],
+			dst[ndst++].st_name = s - mod->core_kallsyms.strtab;
+			s += strlcpy(s, &mod->kallsyms->strtab[src[i].st_name],
 				     KSYM_NAME_LEN) + 1;
 		}
 	}
-	mod->core_num_syms = ndst;
+	mod->core_kallsyms.num_symtab = ndst;
 }
 #else
 static inline void layout_symtab(struct module *mod, struct load_info *info)
@@ -2451,13 +2475,18 @@ static inline void kmemleak_load_module(const struct module *mod,
 #endif
 
 #ifdef CONFIG_MODULE_SIG
-static int module_sig_check(struct load_info *info)
+static int module_sig_check(struct load_info *info, int flags)
 {
 	int err = -ENOKEY;
 	const unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;
 	const void *mod = info->hdr;
 
-	if (info->len > markerlen &&
+	/*
+	 * Require flags == 0, as a module with version information
+	 * removed is no longer the module that was signed
+	 */
+	if (flags == 0 &&
+	    info->len > markerlen &&
 	    memcmp(mod + info->len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {
 		/* We truncate the module to discard the signature */
 		info->len -= markerlen;
@@ -2479,7 +2508,7 @@ static int module_sig_check(struct load_info *info)
 	return err;
 }
 #else /* !CONFIG_MODULE_SIG */
-static int module_sig_check(struct load_info *info)
+static int module_sig_check(struct load_info *info, int flags)
 {
 	return 0;
 }
@@ -3113,9 +3142,8 @@ static int do_init_module(struct module *mod)
 	module_put(mod);
 	trim_init_extable(mod);
 #ifdef CONFIG_KALLSYMS
-	mod->num_symtab = mod->core_num_syms;
-	mod->symtab = mod->core_symtab;
-	mod->strtab = mod->core_strtab;
+	/* Switch to core kallsyms now init is done: kallsyms may be walking! */
+	rcu_assign_pointer(mod->kallsyms, &mod->core_kallsyms);
 #endif
 	unset_module_init_ro_nx(mod);
 	module_free(mod, mod->module_init);
@@ -3205,7 +3233,7 @@ static int load_module(struct load_info *info, const char __user *uargs,
 	struct module *mod;
 	long err;
 
-	err = module_sig_check(info);
+	err = module_sig_check(info, flags);
 	if (err)
 		goto free_copy;
 
@@ -3394,6 +3422,11 @@ static inline int is_arm_mapping_symbol(const char *str)
 	       && (str[2] == '\0' || str[2] == '.');
 }
 
+static const char *symname(struct mod_kallsyms *kallsyms, unsigned int symnum)
+{
+	return kallsyms->strtab + kallsyms->symtab[symnum].st_name;
+}
+
 static const char *get_ksymbol(struct module *mod,
 			       unsigned long addr,
 			       unsigned long *size,
@@ -3401,6 +3434,7 @@ static const char *get_ksymbol(struct module *mod,
 {
 	unsigned int i, best = 0;
 	unsigned long nextval;
+	struct mod_kallsyms *kallsyms = rcu_dereference_sched(mod->kallsyms);
 
 	/* At worse, next value is at end of module */
 	if (within_module_init(addr, mod))
@@ -3410,32 +3444,32 @@ static const char *get_ksymbol(struct module *mod,
 
 	/* Scan for closest preceding symbol, and next symbol. (ELF
 	   starts real symbols at 1). */
-	for (i = 1; i < mod->num_symtab; i++) {
-		if (mod->symtab[i].st_shndx == SHN_UNDEF)
+	for (i = 1; i < kallsyms->num_symtab; i++) {
+		if (kallsyms->symtab[i].st_shndx == SHN_UNDEF)
 			continue;
 
 		/* We ignore unnamed symbols: they're uninformative
 		 * and inserted at a whim. */
-		if (mod->symtab[i].st_value <= addr
-		    && mod->symtab[i].st_value > mod->symtab[best].st_value
-		    && *(mod->strtab + mod->symtab[i].st_name) != '\0'
-		    && !is_arm_mapping_symbol(mod->strtab + mod->symtab[i].st_name))
+		if (*symname(kallsyms, i) == '\0'
+		    || is_arm_mapping_symbol(symname(kallsyms, i)))
+			continue;
+
+		if (kallsyms->symtab[i].st_value <= addr
+		    && kallsyms->symtab[i].st_value > kallsyms->symtab[best].st_value)
 			best = i;
-		if (mod->symtab[i].st_value > addr
-		    && mod->symtab[i].st_value < nextval
-		    && *(mod->strtab + mod->symtab[i].st_name) != '\0'
-		    && !is_arm_mapping_symbol(mod->strtab + mod->symtab[i].st_name))
-			nextval = mod->symtab[i].st_value;
+		if (kallsyms->symtab[i].st_value > addr
+		    && kallsyms->symtab[i].st_value < nextval)
+			nextval = kallsyms->symtab[i].st_value;
 	}
 
 	if (!best)
 		return NULL;
 
 	if (size)
-		*size = nextval - mod->symtab[best].st_value;
+		*size = nextval - kallsyms->symtab[best].st_value;
 	if (offset)
-		*offset = addr - mod->symtab[best].st_value;
-	return mod->strtab + mod->symtab[best].st_name;
+		*offset = addr - kallsyms->symtab[best].st_value;
+	return symname(kallsyms, best);
 }
 
 /* For kallsyms to ask for address resolution.  NULL means not found.  Careful
@@ -3531,19 +3565,21 @@ int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
 
 	preempt_disable();
 	list_for_each_entry_rcu(mod, &modules, list) {
+		struct mod_kallsyms *kallsyms;
+
 		if (mod->state == MODULE_STATE_UNFORMED)
 			continue;
-		if (symnum < mod->num_symtab) {
-			*value = mod->symtab[symnum].st_value;
-			*type = mod->symtab[symnum].st_info;
-			strlcpy(name, mod->strtab + mod->symtab[symnum].st_name,
-				KSYM_NAME_LEN);
+		kallsyms = rcu_dereference_sched(mod->kallsyms);
+		if (symnum < kallsyms->num_symtab) {
+			*value = kallsyms->symtab[symnum].st_value;
+			*type = kallsyms->symtab[symnum].st_info;
+			strlcpy(name, symname(kallsyms, symnum), KSYM_NAME_LEN);
 			strlcpy(module_name, mod->name, MODULE_NAME_LEN);
 			*exported = is_exported(name, *value, mod);
 			preempt_enable();
 			return 0;
 		}
-		symnum -= mod->num_symtab;
+		symnum -= kallsyms->num_symtab;
 	}
 	preempt_enable();
 	return -ERANGE;
@@ -3552,11 +3588,12 @@ int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,
 static unsigned long mod_find_symname(struct module *mod, const char *name)
 {
 	unsigned int i;
+	struct mod_kallsyms *kallsyms = rcu_dereference_sched(mod->kallsyms);
 
-	for (i = 0; i < mod->num_symtab; i++)
-		if (strcmp(name, mod->strtab+mod->symtab[i].st_name) == 0 &&
-		    mod->symtab[i].st_info != 'U')
-			return mod->symtab[i].st_value;
+	for (i = 0; i < kallsyms->num_symtab; i++)
+		if (strcmp(name, symname(kallsyms, i)) == 0 &&
+		    kallsyms->symtab[i].st_info != 'U')
+			return kallsyms->symtab[i].st_value;
 	return 0;
 }
 
@@ -3595,11 +3632,14 @@ int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,
 	int ret;
 
 	list_for_each_entry(mod, &modules, list) {
+		/* We hold module_mutex: no need for rcu_dereference_sched */
+		struct mod_kallsyms *kallsyms = mod->kallsyms;
+
 		if (mod->state == MODULE_STATE_UNFORMED)
 			continue;
-		for (i = 0; i < mod->num_symtab; i++) {
-			ret = fn(data, mod->strtab + mod->symtab[i].st_name,
-				 mod, mod->symtab[i].st_value);
+		for (i = 0; i < kallsyms->num_symtab; i++) {
+			ret = fn(data, symname(kallsyms, i),
+				 mod, kallsyms->symtab[i].st_value);
 			if (ret != 0)
 				return ret;
 		}
diff --git a/kernel/panic.c b/kernel/panic.c
index 167ec097..d3d74c4 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -22,6 +22,7 @@
 #include <linux/sysrq.h>
 #include <linux/init.h>
 #include <linux/nmi.h>
+#include <linux/console.h>
 
 #define PANIC_TIMER_STEP 100
 #define PANIC_BLINK_SPD 18
@@ -128,6 +129,8 @@ void panic(const char *fmt, ...)
 
 	bust_spinlocks(0);
 
+	console_flush_on_panic();
+
 	if (!panic_blink)
 		panic_blink = no_blink;
 
diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c
index d1c887b..86c0101 100644
--- a/kernel/power/hibernate.c
+++ b/kernel/power/hibernate.c
@@ -680,6 +680,8 @@ int hibernate(void)
 		pr_debug("PM: writing image.\n");
 #ifdef CONFIG_ARCH_AMBARELLA
 		error = swsusp_write_mtd(flags);
+		if (error)
+			outer_resume();
 #else
 		error = swsusp_write(flags);
 #endif
diff --git a/kernel/power/power.h b/kernel/power/power.h
index f41b5d7..70db88d 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -12,8 +12,10 @@ struct swsusp_info {
 	unsigned long		pages;
 	unsigned long		size;
 #ifdef CONFIG_ARCH_AMBARELLA
-	unsigned long       magic;
-	unsigned long       addr;
+	unsigned long		magic;
+	unsigned long		addr;
+	unsigned long		lzo_enable;
+	unsigned long		crc32;
 #endif
 } __attribute__((aligned(PAGE_SIZE)));
 
diff --git a/kernel/printk.c b/kernel/printk.c
index f7aff4b..ee8f6be 100644
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -107,7 +107,7 @@ static struct console *exclusive_console;
  */
 struct console_cmdline
 {
-	char	name[8];			/* Name of the driver	    */
+	char	name[16];			/* Name of the driver	    */
 	int	index;				/* Minor dev. to use	    */
 	char	*options;			/* Options for the driver   */
 #ifdef CONFIG_A11Y_BRAILLE_CONSOLE
@@ -2033,13 +2033,24 @@ void console_unlock(void)
 	static u64 seen_seq;
 	unsigned long flags;
 	bool wake_klogd = false;
-	bool retry;
+	bool do_cond_resched, retry;
 
 	if (console_suspended) {
 		up(&console_sem);
 		return;
 	}
 
+	/*
+	 * Console drivers are called under logbuf_lock, so
+	 * @console_may_schedule should be cleared before; however, we may
+	 * end up dumping a lot of lines, for example, if called from
+	 * console registration path, and should invoke cond_resched()
+	 * between lines if allowable.  Not doing so can cause a very long
+	 * scheduling stall on a slow console leading to RCU stall and
+	 * softlockup warnings which exacerbate the issue with more
+	 * messages practically incapacitating the system.
+	 */
+	do_cond_resched = console_may_schedule;
 	console_may_schedule = 0;
 
 	/* flush buffered message fragment immediately to console */
@@ -2096,6 +2107,9 @@ skip:
 		call_console_drivers(level, text, len);
 		start_critical_timings();
 		local_irq_restore(flags);
+
+		if (do_cond_resched)
+			cond_resched();
 	}
 	console_locked = 0;
 	mutex_release(&console_lock_dep_map, 1, _RET_IP_);
@@ -2164,6 +2178,25 @@ void console_unblank(void)
 	console_unlock();
 }
 
+/**
+ * console_flush_on_panic - flush console content on panic
+ *
+ * Immediately output all pending messages no matter what.
+ */
+void console_flush_on_panic(void)
+{
+	/*
+	 * If someone else is holding the console lock, trylock will fail
+	 * and may_schedule may be set.  Ignore and proceed to unlock so
+	 * that messages are flushed out.  As this can be called from any
+	 * context and we don't want to get preempted while flushing,
+	 * ensure may_schedule is cleared.
+	 */
+	console_trylock();
+	console_may_schedule = 0;
+	console_unlock();
+}
+
 /*
  * Return the console tty driver structure and its associated index
  */
@@ -2290,6 +2323,8 @@ void register_console(struct console *newcon)
 	 */
 	for (i = 0; i < MAX_CMDLINECONSOLES && console_cmdline[i].name[0];
 			i++) {
+		BUILD_BUG_ON(sizeof(console_cmdline[i].name) !=
+			     sizeof(newcon->name));
 		if (strcmp(console_cmdline[i].name, newcon->name) != 0)
 			continue;
 		if (newcon->index >= 0 &&
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index afadcf7..72b0b3e 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -225,6 +225,14 @@ static int ptrace_has_cap(struct user_namespace *ns, unsigned int mode)
 static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 {
 	const struct cred *cred = current_cred(), *tcred;
+	int dumpable = 0;
+	kuid_t caller_uid;
+	kgid_t caller_gid;
+
+	if (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {
+		WARN(1, "denying ptrace access check without PTRACE_MODE_*CREDS\n");
+		return -EPERM;
+	}
 
 	/* May we inspect the given task?
 	 * This check is used both for attaching with ptrace
@@ -234,18 +242,33 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 	 * because setting up the necessary parent/child relationship
 	 * or halting the specified task is impossible.
 	 */
-	int dumpable = 0;
+
 	/* Don't let security modules deny introspection */
-	if (task == current)
+	if (same_thread_group(task, current))
 		return 0;
 	rcu_read_lock();
+	if (mode & PTRACE_MODE_FSCREDS) {
+		caller_uid = cred->fsuid;
+		caller_gid = cred->fsgid;
+	} else {
+		/*
+		 * Using the euid would make more sense here, but something
+		 * in userland might rely on the old behavior, and this
+		 * shouldn't be a security problem since
+		 * PTRACE_MODE_REALCREDS implies that the caller explicitly
+		 * used a syscall that requests access to another process
+		 * (and not a filesystem syscall to procfs).
+		 */
+		caller_uid = cred->uid;
+		caller_gid = cred->gid;
+	}
 	tcred = __task_cred(task);
-	if (uid_eq(cred->uid, tcred->euid) &&
-	    uid_eq(cred->uid, tcred->suid) &&
-	    uid_eq(cred->uid, tcred->uid)  &&
-	    gid_eq(cred->gid, tcred->egid) &&
-	    gid_eq(cred->gid, tcred->sgid) &&
-	    gid_eq(cred->gid, tcred->gid))
+	if (uid_eq(caller_uid, tcred->euid) &&
+	    uid_eq(caller_uid, tcred->suid) &&
+	    uid_eq(caller_uid, tcred->uid)  &&
+	    gid_eq(caller_gid, tcred->egid) &&
+	    gid_eq(caller_gid, tcred->sgid) &&
+	    gid_eq(caller_gid, tcred->gid))
 		goto ok;
 	if (ptrace_has_cap(tcred->user_ns, mode))
 		goto ok;
@@ -312,7 +335,7 @@ static int ptrace_attach(struct task_struct *task, long request,
 		goto out;
 
 	task_lock(task);
-	retval = __ptrace_may_access(task, PTRACE_MODE_ATTACH);
+	retval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);
 	task_unlock(task);
 	if (retval)
 		goto unlock_creds;
@@ -720,6 +743,8 @@ static int ptrace_peek_siginfo(struct task_struct *child,
 static int ptrace_resume(struct task_struct *child, long request,
 			 unsigned long data)
 {
+	bool need_siglock;
+
 	if (!valid_signal(data))
 		return -EIO;
 
@@ -747,8 +772,26 @@ static int ptrace_resume(struct task_struct *child, long request,
 		user_disable_single_step(child);
 	}
 
+	/*
+	 * Change ->exit_code and ->state under siglock to avoid the race
+	 * with wait_task_stopped() in between; a non-zero ->exit_code will
+	 * wrongly look like another report from tracee.
+	 *
+	 * Note that we need siglock even if ->exit_code == data and/or this
+	 * status was not reported yet, the new status must not be cleared by
+	 * wait_task_stopped() after resume.
+	 *
+	 * If data == 0 we do not care if wait_task_stopped() reports the old
+	 * status and clears the code too; this can't race with the tracee, it
+	 * takes siglock after resume.
+	 */
+	need_siglock = data && !thread_group_empty(current);
+	if (need_siglock)
+		spin_lock_irq(&child->sighand->siglock);
 	child->exit_code = data;
 	wake_up_state(child, __TASK_TRACED);
+	if (need_siglock)
+		spin_unlock_irq(&child->sighand->siglock);
 
 	return 0;
 }
diff --git a/kernel/resource.c b/kernel/resource.c
index d738698..b8422b1 100644
--- a/kernel/resource.c
+++ b/kernel/resource.c
@@ -961,9 +961,10 @@ struct resource * __request_region(struct resource *parent,
 		if (!conflict)
 			break;
 		if (conflict != parent) {
-			parent = conflict;
-			if (!(conflict->flags & IORESOURCE_BUSY))
+			if (!(conflict->flags & IORESOURCE_BUSY)) {
+				parent = conflict;
 				continue;
+			}
 		}
 		if (conflict->flags & flags & IORESOURCE_MUXED) {
 			add_wait_queue(&muxed_resource_wait, &wait);
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index c771f25..655d611 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -1587,7 +1587,6 @@ out:
  */
 int wake_up_process(struct task_struct *p)
 {
-	WARN_ON(task_is_stopped_or_traced(p));
 	return try_to_wake_up(p, TASK_NORMAL, 0);
 }
 EXPORT_SYMBOL(wake_up_process);
@@ -5218,6 +5217,7 @@ migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu)
 
 	case CPU_UP_PREPARE:
 		rq->calc_load_update = calc_load_update;
+		account_reset_rq(rq);
 		break;
 
 	case CPU_ONLINE:
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index dfa31d5..e7f4d55 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -1378,3 +1378,16 @@ static inline u64 irq_time_read(int cpu)
 }
 #endif /* CONFIG_64BIT */
 #endif /* CONFIG_IRQ_TIME_ACCOUNTING */
+
+static inline void account_reset_rq(struct rq *rq)
+{
+#ifdef CONFIG_IRQ_TIME_ACCOUNTING
+	rq->prev_irq_time = 0;
+#endif
+#ifdef CONFIG_PARAVIRT
+	rq->prev_steal_time = 0;
+#endif
+#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING
+	rq->prev_steal_time_rq = 0;
+#endif
+}
diff --git a/kernel/signal.c b/kernel/signal.c
index 113411b..7b81c53 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -2768,7 +2768,8 @@ int copy_siginfo_to_user(siginfo_t __user *to, siginfo_t *from)
 		 * Other callers might not initialize the si_lsb field,
 		 * so check explicitly for the right codes here.
 		 */
-		if (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO)
+		if (from->si_signo == SIGBUS &&
+		    (from->si_code == BUS_MCEERR_AR || from->si_code == BUS_MCEERR_AO))
 			err |= __put_user(from->si_addr_lsb, &to->si_addr_lsb);
 #endif
 		break;
@@ -3003,11 +3004,9 @@ static int do_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t *info)
 	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
 	 */
 	if ((info->si_code >= 0 || info->si_code == SI_TKILL) &&
-	    (task_pid_vnr(current) != pid)) {
-		/* We used to allow any < 0 si_code */
-		WARN_ON_ONCE(info->si_code < 0);
+	    (task_pid_vnr(current) != pid))
 		return -EPERM;
-	}
+
 	info->si_signo = sig;
 
 	/* POSIX.1b doesn't mention process groups.  */
@@ -3035,7 +3034,7 @@ COMPAT_SYSCALL_DEFINE3(rt_sigqueueinfo,
 			int, sig,
 			struct compat_siginfo __user *, uinfo)
 {
-	siginfo_t info;
+	siginfo_t info = {};
 	int ret = copy_siginfo_from_user32(&info, uinfo);
 	if (unlikely(ret))
 		return ret;
@@ -3052,12 +3051,10 @@ static int do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)
 	/* Not even root can pretend to send signals from the kernel.
 	 * Nor can they impersonate a kill()/tgkill(), which adds source info.
 	 */
-	if (((info->si_code >= 0 || info->si_code == SI_TKILL)) &&
-	    (task_pid_vnr(current) != pid)) {
-		/* We used to allow any < 0 si_code */
-		WARN_ON_ONCE(info->si_code < 0);
+	if ((info->si_code >= 0 || info->si_code == SI_TKILL) &&
+	    (task_pid_vnr(current) != pid))
 		return -EPERM;
-	}
+
 	info->si_signo = sig;
 
 	return do_send_specific(tgid, pid, sig, info);
@@ -3081,7 +3078,7 @@ COMPAT_SYSCALL_DEFINE4(rt_tgsigqueueinfo,
 			int, sig,
 			struct compat_siginfo __user *, uinfo)
 {
-	siginfo_t info;
+	siginfo_t info = {};
 
 	if (copy_siginfo_from_user32(&info, uinfo))
 		return -EFAULT;
@@ -3550,7 +3547,7 @@ SYSCALL_DEFINE0(pause)
 
 #endif
 
-int sigsuspend(sigset_t *set)
+static int sigsuspend(sigset_t *set)
 {
 	current->saved_sigmask = current->blocked;
 	set_current_blocked(set);
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 787b3a0..b538df3 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -6,8 +6,6 @@
  *	Distribute under GPLv2.
  *
  *	Rewritten. Old one was good in 2.2, but in 2.3 it was immoral. --ANK (990903)
- *
- *	Remote softirq infrastructure is by Jens Axboe.
  */
 
 #include <linux/export.h>
@@ -620,146 +618,17 @@ void tasklet_hrtimer_init(struct tasklet_hrtimer *ttimer,
 }
 EXPORT_SYMBOL_GPL(tasklet_hrtimer_init);
 
-/*
- * Remote softirq bits
- */
-
-DEFINE_PER_CPU(struct list_head [NR_SOFTIRQS], softirq_work_list);
-EXPORT_PER_CPU_SYMBOL(softirq_work_list);
-
-static void __local_trigger(struct call_single_data *cp, int softirq)
-{
-	struct list_head *head = &__get_cpu_var(softirq_work_list[softirq]);
-
-	list_add_tail(&cp->list, head);
-
-	/* Trigger the softirq only if the list was previously empty.  */
-	if (head->next == &cp->list)
-		raise_softirq_irqoff(softirq);
-}
-
-#ifdef CONFIG_USE_GENERIC_SMP_HELPERS
-static void remote_softirq_receive(void *data)
-{
-	struct call_single_data *cp = data;
-	unsigned long flags;
-	int softirq;
-
-	softirq = *(int *)cp->info;
-	local_irq_save(flags);
-	__local_trigger(cp, softirq);
-	local_irq_restore(flags);
-}
-
-static int __try_remote_softirq(struct call_single_data *cp, int cpu, int softirq)
-{
-	if (cpu_online(cpu)) {
-		cp->func = remote_softirq_receive;
-		cp->info = &softirq;
-		cp->flags = 0;
-
-		__smp_call_function_single(cpu, cp, 0);
-		return 0;
-	}
-	return 1;
-}
-#else /* CONFIG_USE_GENERIC_SMP_HELPERS */
-static int __try_remote_softirq(struct call_single_data *cp, int cpu, int softirq)
-{
-	return 1;
-}
-#endif
-
-/**
- * __send_remote_softirq - try to schedule softirq work on a remote cpu
- * @cp: private SMP call function data area
- * @cpu: the remote cpu
- * @this_cpu: the currently executing cpu
- * @softirq: the softirq for the work
- *
- * Attempt to schedule softirq work on a remote cpu.  If this cannot be
- * done, the work is instead queued up on the local cpu.
- *
- * Interrupts must be disabled.
- */
-void __send_remote_softirq(struct call_single_data *cp, int cpu, int this_cpu, int softirq)
-{
-	if (cpu == this_cpu || __try_remote_softirq(cp, cpu, softirq))
-		__local_trigger(cp, softirq);
-}
-EXPORT_SYMBOL(__send_remote_softirq);
-
-/**
- * send_remote_softirq - try to schedule softirq work on a remote cpu
- * @cp: private SMP call function data area
- * @cpu: the remote cpu
- * @softirq: the softirq for the work
- *
- * Like __send_remote_softirq except that disabling interrupts and
- * computing the current cpu is done for the caller.
- */
-void send_remote_softirq(struct call_single_data *cp, int cpu, int softirq)
-{
-	unsigned long flags;
-	int this_cpu;
-
-	local_irq_save(flags);
-	this_cpu = smp_processor_id();
-	__send_remote_softirq(cp, cpu, this_cpu, softirq);
-	local_irq_restore(flags);
-}
-EXPORT_SYMBOL(send_remote_softirq);
-
-static int __cpuinit remote_softirq_cpu_notify(struct notifier_block *self,
-					       unsigned long action, void *hcpu)
-{
-	/*
-	 * If a CPU goes away, splice its entries to the current CPU
-	 * and trigger a run of the softirq
-	 */
-	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN) {
-		int cpu = (unsigned long) hcpu;
-		int i;
-
-		local_irq_disable();
-		for (i = 0; i < NR_SOFTIRQS; i++) {
-			struct list_head *head = &per_cpu(softirq_work_list[i], cpu);
-			struct list_head *local_head;
-
-			if (list_empty(head))
-				continue;
-
-			local_head = &__get_cpu_var(softirq_work_list[i]);
-			list_splice_init(head, local_head);
-			raise_softirq_irqoff(i);
-		}
-		local_irq_enable();
-	}
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block __cpuinitdata remote_softirq_cpu_notifier = {
-	.notifier_call	= remote_softirq_cpu_notify,
-};
-
 void __init softirq_init(void)
 {
 	int cpu;
 
 	for_each_possible_cpu(cpu) {
-		int i;
-
 		per_cpu(tasklet_vec, cpu).tail =
 			&per_cpu(tasklet_vec, cpu).head;
 		per_cpu(tasklet_hi_vec, cpu).tail =
 			&per_cpu(tasklet_hi_vec, cpu).head;
-		for (i = 0; i < NR_SOFTIRQS; i++)
-			INIT_LIST_HEAD(&per_cpu(softirq_work_list[i], cpu));
 	}
 
-	register_hotcpu_notifier(&remote_softirq_cpu_notifier);
-
 	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
 	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
 }
@@ -774,9 +643,13 @@ static void run_ksoftirqd(unsigned int cpu)
 	local_irq_disable();
 	if (local_softirq_pending()) {
 		__do_softirq();
-		rcu_note_context_switch(cpu);
 		local_irq_enable();
 		cond_resched();
+
+		preempt_disable();
+		rcu_note_context_switch(cpu);
+		preempt_enable();
+
 		return;
 	}
 	local_irq_enable();
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 9469f4c..4fd49fe 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -1632,6 +1632,20 @@ static struct ctl_table fs_table[] = {
 		.proc_handler	= &pipe_proc_fn,
 		.extra1		= &pipe_min_size,
 	},
+	{
+		.procname	= "pipe-user-pages-hard",
+		.data		= &pipe_user_pages_hard,
+		.maxlen		= sizeof(pipe_user_pages_hard),
+		.mode		= 0644,
+		.proc_handler	= proc_doulongvec_minmax,
+	},
+	{
+		.procname	= "pipe-user-pages-soft",
+		.data		= &pipe_user_pages_soft,
+		.maxlen		= sizeof(pipe_user_pages_soft),
+		.mode		= 0644,
+		.proc_handler	= proc_doulongvec_minmax,
+	},
 	{ }
 };
 
diff --git a/kernel/time/posix-clock.c b/kernel/time/posix-clock.c
index ce033c7..9cff0ab 100644
--- a/kernel/time/posix-clock.c
+++ b/kernel/time/posix-clock.c
@@ -69,10 +69,10 @@ static ssize_t posix_clock_read(struct file *fp, char __user *buf,
 static unsigned int posix_clock_poll(struct file *fp, poll_table *wait)
 {
 	struct posix_clock *clk = get_posix_clock(fp);
-	int result = 0;
+	unsigned int result = 0;
 
 	if (!clk)
-		return -ENODEV;
+		return POLLERR;
 
 	if (clk->ops.poll)
 		result = clk->ops.poll(clk, fp, wait);
diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c
index 3d9fee3..c4ce3a9 100644
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -463,7 +463,7 @@ struct ring_buffer_per_cpu {
 	raw_spinlock_t			reader_lock;	/* serialize readers */
 	arch_spinlock_t			lock;
 	struct lock_class_key		lock_key;
-	unsigned int			nr_pages;
+	unsigned long			nr_pages;
 	struct list_head		*pages;
 	struct buffer_page		*head_page;	/* read from head */
 	struct buffer_page		*tail_page;	/* write to tail */
@@ -483,7 +483,7 @@ struct ring_buffer_per_cpu {
 	u64				write_stamp;
 	u64				read_stamp;
 	/* ring buffer pages to update, > 0 to add, < 0 to remove */
-	int				nr_pages_to_update;
+	long				nr_pages_to_update;
 	struct list_head		new_pages; /* new pages to add */
 	struct work_struct		update_pages_work;
 	struct completion		update_done;
@@ -1120,10 +1120,10 @@ static int rb_check_pages(struct ring_buffer_per_cpu *cpu_buffer)
 	return 0;
 }
 
-static int __rb_allocate_pages(int nr_pages, struct list_head *pages, int cpu)
+static int __rb_allocate_pages(long nr_pages, struct list_head *pages, int cpu)
 {
-	int i;
 	struct buffer_page *bpage, *tmp;
+	long i;
 
 	for (i = 0; i < nr_pages; i++) {
 		struct page *page;
@@ -1160,7 +1160,7 @@ free_pages:
 }
 
 static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
-			     unsigned nr_pages)
+			     unsigned long nr_pages)
 {
 	LIST_HEAD(pages);
 
@@ -1185,7 +1185,7 @@ static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
 }
 
 static struct ring_buffer_per_cpu *
-rb_allocate_cpu_buffer(struct ring_buffer *buffer, int nr_pages, int cpu)
+rb_allocate_cpu_buffer(struct ring_buffer *buffer, long nr_pages, int cpu)
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
 	struct buffer_page *bpage;
@@ -1284,8 +1284,9 @@ struct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,
 					struct lock_class_key *key)
 {
 	struct ring_buffer *buffer;
+	long nr_pages;
 	int bsize;
-	int cpu, nr_pages;
+	int cpu;
 
 	/* keep it in its own cache line */
 	buffer = kzalloc(ALIGN(sizeof(*buffer), cache_line_size()),
@@ -1408,12 +1409,12 @@ static inline unsigned long rb_page_write(struct buffer_page *bpage)
 }
 
 static int
-rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned int nr_pages)
+rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)
 {
 	struct list_head *tail_page, *to_remove, *next_page;
 	struct buffer_page *to_remove_page, *tmp_iter_page;
 	struct buffer_page *last_page, *first_page;
-	unsigned int nr_removed;
+	unsigned long nr_removed;
 	unsigned long head_bit;
 	int page_entries;
 
@@ -1629,7 +1630,7 @@ int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,
 			int cpu_id)
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
-	unsigned nr_pages;
+	unsigned long nr_pages;
 	int cpu, err = 0;
 
 	/*
@@ -1643,14 +1644,13 @@ int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,
 	    !cpumask_test_cpu(cpu_id, buffer->cpumask))
 		return size;
 
-	size = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
-	size *= BUF_PAGE_SIZE;
+	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
 
 	/* we need a minimum of two pages */
-	if (size < BUF_PAGE_SIZE * 2)
-		size = BUF_PAGE_SIZE * 2;
+	if (nr_pages < 2)
+		nr_pages = 2;
 
-	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);
+	size = nr_pages * BUF_PAGE_SIZE;
 
 	/*
 	 * Don't succeed if resizing is disabled, as a reader might be
@@ -1948,12 +1948,6 @@ rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)
 		goto again;
 }
 
-static void rb_reset_reader_page(struct ring_buffer_per_cpu *cpu_buffer)
-{
-	cpu_buffer->read_stamp = cpu_buffer->reader_page->page->time_stamp;
-	cpu_buffer->reader_page->read = 0;
-}
-
 static void rb_inc_iter(struct ring_buffer_iter *iter)
 {
 	struct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;
@@ -2650,7 +2644,7 @@ static DEFINE_PER_CPU(unsigned int, current_context);
 
 static __always_inline int trace_recursive_lock(void)
 {
-	unsigned int val = this_cpu_read(current_context);
+	unsigned int val = __this_cpu_read(current_context);
 	int bit;
 
 	if (in_interrupt()) {
@@ -2667,18 +2661,17 @@ static __always_inline int trace_recursive_lock(void)
 		return 1;
 
 	val |= (1 << bit);
-	this_cpu_write(current_context, val);
+	__this_cpu_write(current_context, val);
 
 	return 0;
 }
 
 static __always_inline void trace_recursive_unlock(void)
 {
-	unsigned int val = this_cpu_read(current_context);
+	unsigned int val = __this_cpu_read(current_context);
 
-	val--;
-	val &= this_cpu_read(current_context);
-	this_cpu_write(current_context, val);
+	val &= val & (val - 1);
+	__this_cpu_write(current_context, val);
 }
 
 #else
@@ -3592,7 +3585,7 @@ rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)
 
 	/* Finally update the reader page to the new head */
 	cpu_buffer->reader_page = reader;
-	rb_reset_reader_page(cpu_buffer);
+	cpu_buffer->reader_page->read = 0;
 
 	if (overwrite != cpu_buffer->last_overrun) {
 		cpu_buffer->lost_events = overwrite - cpu_buffer->last_overrun;
@@ -3602,6 +3595,10 @@ rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)
 	goto again;
 
  out:
+	/* Update the read_stamp on the first event */
+	if (reader && reader->read == 0)
+		cpu_buffer->read_stamp = reader->page->time_stamp;
+
 	arch_spin_unlock(&cpu_buffer->lock);
 	local_irq_restore(flags);
 
@@ -4610,8 +4607,9 @@ static int rb_cpu_notify(struct notifier_block *self,
 	struct ring_buffer *buffer =
 		container_of(self, struct ring_buffer, cpu_notify);
 	long cpu = (long)hcpu;
-	int cpu_i, nr_pages_same;
-	unsigned int nr_pages;
+	long nr_pages_same;
+	int cpu_i;
+	unsigned long nr_pages;
 
 	switch (action) {
 	case CPU_UP_PREPARE:
diff --git a/kernel/trace/ring_buffer_benchmark.c b/kernel/trace/ring_buffer_benchmark.c
index a5457d5..6ad2e2d 100644
--- a/kernel/trace/ring_buffer_benchmark.c
+++ b/kernel/trace/ring_buffer_benchmark.c
@@ -455,7 +455,7 @@ static int __init ring_buffer_benchmark_init(void)
 
 	if (producer_fifo >= 0) {
 		struct sched_param param = {
-			.sched_priority = consumer_fifo
+			.sched_priority = producer_fifo
 		};
 		sched_setscheduler(producer, SCHED_FIFO, &param);
 	} else
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 8d7e809..eff26a9 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -4351,7 +4351,10 @@ static ssize_t tracing_splice_read_pipe(struct file *filp,
 
 	spd.nr_pages = i;
 
-	ret = splice_to_pipe(pipe, &spd);
+	if (i)
+		ret = splice_to_pipe(pipe, &spd);
+	else
+		ret = 0;
 out:
 	splice_shrink_spd(&spd);
 	return ret;
@@ -6063,7 +6066,7 @@ static int instance_mkdir (struct inode *inode, struct dentry *dentry, umode_t m
 	int ret;
 
 	/* Paranoid: Make sure the parent is the "instances" directory */
-	parent = hlist_entry(inode->i_dentry.first, struct dentry, d_alias);
+	parent = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);
 	if (WARN_ON_ONCE(parent != trace_instance_dir))
 		return -ENOENT;
 
@@ -6090,7 +6093,7 @@ static int instance_rmdir(struct inode *inode, struct dentry *dentry)
 	int ret;
 
 	/* Paranoid: Make sure the parent is the "instances" directory */
-	parent = hlist_entry(inode->i_dentry.first, struct dentry, d_alias);
+	parent = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);
 	if (WARN_ON_ONCE(parent != trace_instance_dir))
 		return -ENOENT;
 
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index aa0e736..fe57607 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -428,6 +428,7 @@ enum {
 
 	TRACE_CONTROL_BIT,
 
+	TRACE_BRANCH_BIT,
 /*
  * Abuse of the trace_recursion.
  * As we need a way to maintain state if we are tracing the function
diff --git a/kernel/trace/trace_branch.c b/kernel/trace/trace_branch.c
index d594da0..cb89197 100644
--- a/kernel/trace/trace_branch.c
+++ b/kernel/trace/trace_branch.c
@@ -37,9 +37,12 @@ probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)
 	struct trace_branch *entry;
 	struct ring_buffer *buffer;
 	unsigned long flags;
-	int cpu, pc;
+	int pc;
 	const char *p;
 
+	if (current->trace_recursion & TRACE_BRANCH_BIT)
+		return;
+
 	/*
 	 * I would love to save just the ftrace_likely_data pointer, but
 	 * this code can also be used by modules. Ugly things can happen
@@ -50,10 +53,10 @@ probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)
 	if (unlikely(!tr))
 		return;
 
-	local_irq_save(flags);
-	cpu = raw_smp_processor_id();
-	data = per_cpu_ptr(tr->trace_buffer.data, cpu);
-	if (atomic_inc_return(&data->disabled) != 1)
+	raw_local_irq_save(flags);
+	current->trace_recursion |= TRACE_BRANCH_BIT;
+	data = this_cpu_ptr(tr->trace_buffer.data);
+	if (atomic_read(&data->disabled))
 		goto out;
 
 	pc = preempt_count();
@@ -82,8 +85,8 @@ probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)
 		__buffer_unlock_commit(buffer, event);
 
  out:
-	atomic_dec(&data->disabled);
-	local_irq_restore(flags);
+	current->trace_recursion &= ~TRACE_BRANCH_BIT;
+	raw_local_irq_restore(flags);
 }
 
 static inline
diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c
index 001b349..7d054b7 100644
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -425,7 +425,7 @@ static void remove_event_file_dir(struct ftrace_event_file *file)
 
 	if (dir) {
 		spin_lock(&dir->d_lock);	/* probably unneeded */
-		list_for_each_entry(child, &dir->d_subdirs, d_u.d_child) {
+		list_for_each_entry(child, &dir->d_subdirs, d_child) {
 			if (child->d_inode)	/* probably unneeded */
 				child->d_inode->i_private = NULL;
 		}
@@ -602,7 +602,8 @@ t_next(struct seq_file *m, void *v, loff_t *pos)
 		 * The ftrace subsystem is for showing formats only.
 		 * They can not be enabled or disabled via the event files.
 		 */
-		if (call->class && call->class->reg)
+		if (call->class && call->class->reg &&
+		    !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))
 			return file;
 	}
 
diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c
index 0a1edc6..67654bb 100644
--- a/kernel/trace/trace_events_filter.c
+++ b/kernel/trace/trace_events_filter.c
@@ -1015,6 +1015,9 @@ static void parse_init(struct filter_parse_state *ps,
 
 static char infix_next(struct filter_parse_state *ps)
 {
+	if (!ps->infix.cnt)
+		return 0;
+
 	ps->infix.cnt--;
 
 	return ps->infix.string[ps->infix.tail++];
@@ -1030,6 +1033,9 @@ static char infix_peek(struct filter_parse_state *ps)
 
 static void infix_advance(struct filter_parse_state *ps)
 {
+	if (!ps->infix.cnt)
+		return;
+
 	ps->infix.cnt--;
 	ps->infix.tail++;
 }
@@ -1328,19 +1334,26 @@ static int check_preds(struct filter_parse_state *ps)
 {
 	int n_normal_preds = 0, n_logical_preds = 0;
 	struct postfix_elt *elt;
+	int cnt = 0;
 
 	list_for_each_entry(elt, &ps->postfix, list) {
-		if (elt->op == OP_NONE)
+		if (elt->op == OP_NONE) {
+			cnt++;
 			continue;
+		}
 
+		cnt--;
 		if (elt->op == OP_AND || elt->op == OP_OR) {
 			n_logical_preds++;
 			continue;
 		}
 		n_normal_preds++;
+		/* all ops should have operands */
+		if (cnt < 0)
+			break;
 	}
 
-	if (!n_normal_preds || n_logical_preds >= n_normal_preds) {
+	if (cnt != 1 || !n_normal_preds || n_logical_preds >= n_normal_preds) {
 		parse_error(ps, FILT_ERR_INVALID_FILTER, 0);
 		return -EINVAL;
 	}
diff --git a/kernel/trace/trace_irqsoff.c b/kernel/trace/trace_irqsoff.c
index 2aefbee..56e083e 100644
--- a/kernel/trace/trace_irqsoff.c
+++ b/kernel/trace/trace_irqsoff.c
@@ -118,8 +118,12 @@ static int func_prolog_dec(struct trace_array *tr,
 		return 0;
 
 	local_save_flags(*flags);
-	/* slight chance to get a false positive on tracing_cpu */
-	if (!irqs_disabled_flags(*flags))
+	/*
+	 * Slight chance to get a false positive on tracing_cpu,
+	 * although I'm starting to think there isn't a chance.
+	 * Leave this for now just to be paranoid.
+	 */
+	if (!irqs_disabled_flags(*flags) && !preempt_count())
 		return 0;
 
 	*data = per_cpu_ptr(tr->trace_buffer.data, cpu);
diff --git a/kernel/trace/trace_printk.c b/kernel/trace/trace_printk.c
index a9077c1..7be4d67 100644
--- a/kernel/trace/trace_printk.c
+++ b/kernel/trace/trace_printk.c
@@ -38,6 +38,10 @@ struct trace_bprintk_fmt {
 static inline struct trace_bprintk_fmt *lookup_format(const char *fmt)
 {
 	struct trace_bprintk_fmt *pos;
+
+	if (!fmt)
+		return ERR_PTR(-EINVAL);
+
 	list_for_each_entry(pos, &trace_bprintk_fmt_list, list) {
 		if (!strcmp(pos->fmt, fmt))
 			return pos;
@@ -59,7 +63,8 @@ void hold_module_trace_bprintk_format(const char **start, const char **end)
 	for (iter = start; iter < end; iter++) {
 		struct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);
 		if (tb_fmt) {
-			*iter = tb_fmt->fmt;
+			if (!IS_ERR(tb_fmt))
+				*iter = tb_fmt->fmt;
 			continue;
 		}
 
@@ -272,6 +277,9 @@ static int t_show(struct seq_file *m, void *v)
 	const char *str = *fmt;
 	int i;
 
+	if (!*fmt)
+		return 0;
+
 	seq_printf(m, "0x%lx : \"", *(unsigned long *)fmt);
 
 	/*
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index fe7c4b91..66972ac 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -606,6 +606,35 @@ static void set_work_pool_and_clear_pending(struct work_struct *work,
 	 */
 	smp_wmb();
 	set_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);
+	/*
+	 * The following mb guarantees that previous clear of a PENDING bit
+	 * will not be reordered with any speculative LOADS or STORES from
+	 * work->current_func, which is executed afterwards.  This possible
+	 * reordering can lead to a missed execution on attempt to qeueue
+	 * the same @work.  E.g. consider this case:
+	 *
+	 *   CPU#0                         CPU#1
+	 *   ----------------------------  --------------------------------
+	 *
+	 * 1  STORE event_indicated
+	 * 2  queue_work_on() {
+	 * 3    test_and_set_bit(PENDING)
+	 * 4 }                             set_..._and_clear_pending() {
+	 * 5                                 set_work_data() # clear bit
+	 * 6                                 smp_mb()
+	 * 7                               work->current_func() {
+	 * 8				      LOAD event_indicated
+	 *				   }
+	 *
+	 * Without an explicit full barrier speculative LOAD on line 8 can
+	 * be executed before CPU#0 does STORE on line 1.  If that happens,
+	 * CPU#0 observes the PENDING bit is still set and new execution of
+	 * a @work is not queued in a hope, that CPU#1 will eventually
+	 * finish the queued @work.  Meanwhile CPU#1 does not see
+	 * event_indicated is set, because speculative LOAD was executed
+	 * before actual STORE.
+	 */
+	smp_mb();
 }
 
 static void clear_work_data(struct work_struct *work)
diff --git a/lib/bitmap.c b/lib/bitmap.c
index e5c4ebe..c0634aa 100644
--- a/lib/bitmap.c
+++ b/lib/bitmap.c
@@ -603,12 +603,12 @@ static int __bitmap_parselist(const char *buf, unsigned int buflen,
 	unsigned a, b;
 	int c, old_c, totaldigits;
 	const char __user __force *ubuf = (const char __user __force *)buf;
-	int exp_digit, in_range;
+	int at_start, in_range;
 
 	totaldigits = c = 0;
 	bitmap_zero(maskp, nmaskbits);
 	do {
-		exp_digit = 1;
+		at_start = 1;
 		in_range = 0;
 		a = b = 0;
 
@@ -637,11 +637,10 @@ static int __bitmap_parselist(const char *buf, unsigned int buflen,
 				break;
 
 			if (c == '-') {
-				if (exp_digit || in_range)
+				if (at_start || in_range)
 					return -EINVAL;
 				b = 0;
 				in_range = 1;
-				exp_digit = 1;
 				continue;
 			}
 
@@ -651,16 +650,18 @@ static int __bitmap_parselist(const char *buf, unsigned int buflen,
 			b = b * 10 + (c - '0');
 			if (!in_range)
 				a = b;
-			exp_digit = 0;
+			at_start = 0;
 			totaldigits++;
 		}
 		if (!(a <= b))
 			return -EINVAL;
 		if (b >= nmaskbits)
 			return -ERANGE;
-		while (a <= b) {
-			set_bit(a, maskp);
-			a++;
+		if (!at_start) {
+			while (a <= b) {
+				set_bit(a, maskp);
+				a++;
+			}
 		}
 	} while (buflen && c == ',');
 	return 0;
diff --git a/lib/devres.c b/lib/devres.c
index 8235331..20afaf1 100644
--- a/lib/devres.c
+++ b/lib/devres.c
@@ -423,7 +423,7 @@ void pcim_iounmap_regions(struct pci_dev *pdev, int mask)
 	if (!iomap)
 		return;
 
-	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+	for (i = 0; i < PCIM_IOMAP_MAX; i++) {
 		if (!(mask & (1 << i)))
 			continue;
 
diff --git a/lib/dma-debug.c b/lib/dma-debug.c
index d87a17a..c32437f 100644
--- a/lib/dma-debug.c
+++ b/lib/dma-debug.c
@@ -445,9 +445,9 @@ static struct dma_debug_entry *dma_entry_alloc(void)
 	spin_lock_irqsave(&free_entries_lock, flags);
 
 	if (list_empty(&free_entries)) {
-		pr_err("DMA-API: debugging out of memory - disabling\n");
 		global_disable = true;
 		spin_unlock_irqrestore(&free_entries_lock, flags);
+		pr_err("DMA-API: debugging out of memory - disabling\n");
 		return NULL;
 	}
 
@@ -962,7 +962,7 @@ static inline bool overlap(void *addr, unsigned long len, void *start, void *end
 
 static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)
 {
-	if (overlap(addr, len, _text, _etext) ||
+	if (overlap(addr, len, _stext, _etext) ||
 	    overlap(addr, len, __start_rodata, __end_rodata))
 		err_printk(dev, NULL, "DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\n", addr, len);
 }
diff --git a/lib/klist.c b/lib/klist.c
index 358a368a..2e59aec 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -282,9 +282,9 @@ void klist_iter_init_node(struct klist *k, struct klist_iter *i,
 			  struct klist_node *n)
 {
 	i->i_klist = k;
-	i->i_cur = n;
-	if (n)
-		kref_get(&n->n_ref);
+	i->i_cur = NULL;
+	if (n && kref_get_unless_zero(&n->n_ref))
+		i->i_cur = n;
 }
 EXPORT_SYMBOL_GPL(klist_iter_init_node);
 
diff --git a/lib/radix-tree.c b/lib/radix-tree.c
index e796429..936a02c 100644
--- a/lib/radix-tree.c
+++ b/lib/radix-tree.c
@@ -1015,9 +1015,13 @@ radix_tree_gang_lookup(struct radix_tree_root *root, void **results,
 		return 0;
 
 	radix_tree_for_each_slot(slot, root, &iter, first_index) {
-		results[ret] = indirect_to_ptr(rcu_dereference_raw(*slot));
+		results[ret] = rcu_dereference_raw(*slot);
 		if (!results[ret])
 			continue;
+		if (radix_tree_is_indirect_ptr(results[ret])) {
+			slot = radix_tree_iter_retry(&iter);
+			continue;
+		}
 		if (++ret == max_items)
 			break;
 	}
@@ -1094,9 +1098,13 @@ radix_tree_gang_lookup_tag(struct radix_tree_root *root, void **results,
 		return 0;
 
 	radix_tree_for_each_tagged(slot, root, &iter, first_index, tag) {
-		results[ret] = indirect_to_ptr(rcu_dereference_raw(*slot));
+		results[ret] = rcu_dereference_raw(*slot);
 		if (!results[ret])
 			continue;
+		if (radix_tree_is_indirect_ptr(results[ret])) {
+			slot = radix_tree_iter_retry(&iter);
+			continue;
+		}
 		if (++ret == max_items)
 			break;
 	}
diff --git a/lib/string.c b/lib/string.c
index 43d0781..cb9ea21 100644
--- a/lib/string.c
+++ b/lib/string.c
@@ -598,7 +598,7 @@ EXPORT_SYMBOL(memset);
 void memzero_explicit(void *s, size_t count)
 {
 	memset(s, 0, count);
-	OPTIMIZER_HIDE_VAR(s);
+	barrier();
 }
 EXPORT_SYMBOL(memzero_explicit);
 
diff --git a/lib/strnlen_user.c b/lib/strnlen_user.c
index a28df52..1164961 100644
--- a/lib/strnlen_user.c
+++ b/lib/strnlen_user.c
@@ -57,7 +57,8 @@ static inline long do_strnlen_user(const char __user *src, unsigned long count,
 			return res + find_zero(data) + 1 - align;
 		}
 		res += sizeof(unsigned long);
-		if (unlikely(max < sizeof(unsigned long)))
+		/* We already handled 'unsigned long' bytes. Did we do it all ? */
+		if (unlikely(max <= sizeof(unsigned long)))
 			break;
 		max -= sizeof(unsigned long);
 		if (unlikely(__get_user(c,(unsigned long __user *)(src+res))))
diff --git a/lib/ucs2_string.c b/lib/ucs2_string.c
index 6f500ef..f0b323a 100644
--- a/lib/ucs2_string.c
+++ b/lib/ucs2_string.c
@@ -49,3 +49,65 @@ ucs2_strncmp(const ucs2_char_t *a, const ucs2_char_t *b, size_t len)
         }
 }
 EXPORT_SYMBOL(ucs2_strncmp);
+
+unsigned long
+ucs2_utf8size(const ucs2_char_t *src)
+{
+	unsigned long i;
+	unsigned long j = 0;
+
+	for (i = 0; i < ucs2_strlen(src); i++) {
+		u16 c = src[i];
+
+		if (c >= 0x800)
+			j += 3;
+		else if (c >= 0x80)
+			j += 2;
+		else
+			j += 1;
+	}
+
+	return j;
+}
+EXPORT_SYMBOL(ucs2_utf8size);
+
+/*
+ * copy at most maxlength bytes of whole utf8 characters to dest from the
+ * ucs2 string src.
+ *
+ * The return value is the number of characters copied, not including the
+ * final NUL character.
+ */
+unsigned long
+ucs2_as_utf8(u8 *dest, const ucs2_char_t *src, unsigned long maxlength)
+{
+	unsigned int i;
+	unsigned long j = 0;
+	unsigned long limit = ucs2_strnlen(src, maxlength);
+
+	for (i = 0; maxlength && i < limit; i++) {
+		u16 c = src[i];
+
+		if (c >= 0x800) {
+			if (maxlength < 3)
+				break;
+			maxlength -= 3;
+			dest[j++] = 0xe0 | (c & 0xf000) >> 12;
+			dest[j++] = 0x80 | (c & 0x0fc0) >> 6;
+			dest[j++] = 0x80 | (c & 0x003f);
+		} else if (c >= 0x80) {
+			if (maxlength < 2)
+				break;
+			maxlength -= 2;
+			dest[j++] = 0xc0 | (c & 0x7c0) >> 6;
+			dest[j++] = 0x80 | (c & 0x03f);
+		} else {
+			maxlength -= 1;
+			dest[j++] = c & 0x7f;
+		}
+	}
+	if (maxlength)
+		dest[j] = '\0';
+	return j;
+}
+EXPORT_SYMBOL(ucs2_as_utf8);
diff --git a/make.inc b/make.inc
index 549e410..5bc285f 100644
--- a/make.inc
+++ b/make.inc
@@ -30,7 +30,7 @@ LOCAL_PATH:=$(call my-dir)
 linux: $(DOT_CONFIG)
 	@mkdir -p $(LINUX_OUT_DIR)
 	@if [ -f $(LINUX_OUT_DIR)/.config ]; then \
-		echo "Build Linux with previous configuration ..."; \
+		echo "Build Linux-$(CONFIG_LINUX_KERNEL_VERSION) with previous configuration ..."; \
 	else \
 		$(MAKE) $(AMBA_MAKE_PARA) defconfig_public_linux; \
 	fi
@@ -62,10 +62,11 @@ menuconfig_public_linux: $(DOT_CONFIG)
 .PHONY: defconfig_public_linux
 
 defconfig_public_linux: $(DOT_CONFIG)
-	@echo "Build Linux with $(KERNEL_DEFCONFIG) ..."
+	@echo "Build Linux-$(CONFIG_LINUX_KERNEL_VERSION) with $(KERNEL_DEFCONFIG) ..."
 	@mkdir -p $(LINUX_OUT_DIR)
 	@if [ -f $(AMB_BOARD_DIR)/config/kernel/$(KERNEL_DEFCONFIG) ]; then \
 		cp -dpRf $(AMB_BOARD_DIR)/config/kernel/$(KERNEL_DEFCONFIG) $(LINUX_OUT_DIR)/.config; \
+		$(MAKE) $(AMBA_MAKE_PARA) -C $(LINUX_SRC_DIR) O=$(LINUX_OUT_DIR) olddefconfig; \
 	else \
 		$(MAKE) $(AMBA_MAKE_PARA) -C $(LINUX_SRC_DIR) O=$(LINUX_OUT_DIR) $(KERNEL_DEFCONFIG); \
 	fi
diff --git a/mm/filemap.c b/mm/filemap.c
index 7905fe7..725a100 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -2340,6 +2340,11 @@ again:
 			break;
 		}
 
+		if (fatal_signal_pending(current)) {
+			status = -EINTR;
+			break;
+		}
+
 		status = a_ops->write_begin(file, mapping, pos, bytes, flags,
 						&page, &fsdata);
 		if (unlikely(status))
@@ -2380,10 +2385,6 @@ again:
 		written += copied;
 
 		balance_dirty_pages_ratelimited(mapping);
-		if (fatal_signal_pending(current)) {
-			status = -EINTR;
-			break;
-		}
 	} while (iov_iter_count(i));
 
 	return written ? written : status;
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index d9bc87c..e9fd382 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -2573,6 +2573,14 @@ static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,
 			continue;
 
 		/*
+		 * Shared VMAs have their own reserves and do not affect
+		 * MAP_PRIVATE accounting but it is possible that a shared
+		 * VMA is using the same page so check and skip such VMAs.
+		 */
+		if (iter_vma->vm_flags & VM_MAYSHARE)
+			continue;
+
+		/*
 		 * Unmap the page from other VMAs without their own reserves.
 		 * They get marked to be SIGKILLed if they fault in these
 		 * areas. This is because a future no-page fault on this VMA
diff --git a/mm/ksm.c b/mm/ksm.c
index 784d1e4..7bf748f 100644
--- a/mm/ksm.c
+++ b/mm/ksm.c
@@ -376,7 +376,7 @@ static int break_ksm(struct vm_area_struct *vma, unsigned long addr)
 		else
 			ret = VM_FAULT_WRITE;
 		put_page(page);
-	} while (!(ret & (VM_FAULT_WRITE | VM_FAULT_SIGBUS | VM_FAULT_OOM)));
+	} while (!(ret & (VM_FAULT_WRITE | VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV | VM_FAULT_OOM)));
 	/*
 	 * We must loop because handle_mm_fault() may back out if there's
 	 * any difficulty e.g. if pte accessed bit gets updated concurrently.
diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index eaa3acc..437ae2c 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -5790,16 +5790,17 @@ static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,
 swap_buffers:
 	/* Swap primary and spare array */
 	thresholds->spare = thresholds->primary;
-	/* If all events are unregistered, free the spare array */
-	if (!new) {
-		kfree(thresholds->spare);
-		thresholds->spare = NULL;
-	}
 
 	rcu_assign_pointer(thresholds->primary, new);
 
 	/* To be sure that nobody uses thresholds */
 	synchronize_rcu();
+
+	/* If all events are unregistered, free the spare array */
+	if (!new) {
+		kfree(thresholds->spare);
+		thresholds->spare = NULL;
+	}
 unlock:
 	mutex_unlock(&memcg->thresholds_lock);
 }
diff --git a/mm/memory-failure.c b/mm/memory-failure.c
index 603f1fa..37df20f 100644
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@ -1117,10 +1117,10 @@ int memory_failure(unsigned long pfn, int trapno, int flags)
 	 * The check (unnecessarily) ignores LRU pages being isolated and
 	 * walked by the page reclaim code, however that's not a big loss.
 	 */
-	if (!PageHuge(p) && !PageTransTail(p)) {
-		if (!PageLRU(p))
-			shake_page(p, 0);
-		if (!PageLRU(p)) {
+	if (!PageHuge(p)) {
+		if (!PageLRU(hpage))
+			shake_page(hpage, 0);
+		if (!PageLRU(hpage)) {
 			/*
 			 * shake_page could have turned it free.
 			 */
@@ -1472,7 +1472,9 @@ static int get_any_page(struct page *page, unsigned long pfn, int flags)
 		 * Did it turn free?
 		 */
 		ret = __get_any_page(page, pfn, 0);
-		if (!PageLRU(page)) {
+		if (ret == 1 && !PageLRU(page)) {
+			/* Drop page reference which is from __get_any_page() */
+			put_page(page);
 			pr_info("soft_offline: %#lx: unknown non LRU page type %lx\n",
 				pfn, page->flags);
 			return -EIO;
diff --git a/mm/memory.c b/mm/memory.c
index 04232bb..2ca2ee1 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1462,6 +1462,16 @@ int zap_vma_ptes(struct vm_area_struct *vma, unsigned long address,
 }
 EXPORT_SYMBOL_GPL(zap_vma_ptes);
 
+/*
+ * FOLL_FORCE can write to even unwritable pte's, but only
+ * after we've gone through a COW cycle and they are dirty.
+ */
+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
+{
+	return pte_write(pte) ||
+		((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
+}
+
 /**
  * follow_page_mask - look up a page descriptor from a user-virtual address
  * @vma: vm_area_struct mapping @address
@@ -1569,7 +1579,7 @@ split_fallthrough:
 	}
 	if ((flags & FOLL_NUMA) && pte_numa(pte))
 		goto no_page;
-	if ((flags & FOLL_WRITE) && !pte_write(pte))
+	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags))
 		goto unlock;
 
 	page = vm_normal_page(vma, address, pte);
@@ -1844,7 +1854,8 @@ long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 						else
 							return -EFAULT;
 					}
-					if (ret & VM_FAULT_SIGBUS)
+					if (ret & (VM_FAULT_SIGBUS |
+						   VM_FAULT_SIGSEGV))
 						return i ? i : -EFAULT;
 					BUG();
 				}
@@ -1876,7 +1887,7 @@ long __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
 				 */
 				if ((ret & VM_FAULT_WRITE) &&
 				    !(vma->vm_flags & VM_WRITE))
-					foll_flags &= ~FOLL_WRITE;
+					foll_flags |= FOLL_COW;
 
 				cond_resched();
 			}
@@ -1954,7 +1965,7 @@ int fixup_user_fault(struct task_struct *tsk, struct mm_struct *mm,
 			return -ENOMEM;
 		if (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))
 			return -EHWPOISON;
-		if (ret & VM_FAULT_SIGBUS)
+		if (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))
 			return -EFAULT;
 		BUG();
 	}
@@ -3229,9 +3240,13 @@ static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
 
 	pte_unmap(page_table);
 
+	/* File mapping without ->vm_ops ? */
+	if (vma->vm_flags & VM_SHARED)
+		return VM_FAULT_SIGBUS;
+
 	/* Check if we need to add a guard page to the stack */
 	if (check_stack_guard_page(vma, address) < 0)
-		return VM_FAULT_SIGBUS;
+		return VM_FAULT_SIGSEGV;
 
 	/* Use the zero-page for reads */
 	if (!(flags & FAULT_FLAG_WRITE)) {
@@ -3494,6 +3509,9 @@ static int do_linear_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 			- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
 
 	pte_unmap(page_table);
+	/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */
+	if (!vma->vm_ops->fault)
+		return VM_FAULT_SIGBUS;
 	return __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);
 }
 
@@ -3705,11 +3723,9 @@ int handle_pte_fault(struct mm_struct *mm,
 	entry = *pte;
 	if (!pte_present(entry)) {
 		if (pte_none(entry)) {
-			if (vma->vm_ops) {
-				if (likely(vma->vm_ops->fault))
-					return do_linear_fault(mm, vma, address,
+			if (vma->vm_ops)
+				return do_linear_fault(mm, vma, address,
 						pte, pmd, flags, entry);
-			}
 			return do_anonymous_page(mm, vma, address,
 						 pte, pmd, flags);
 		}
@@ -3828,8 +3844,18 @@ retry:
 	if (unlikely(pmd_none(*pmd)) &&
 	    unlikely(__pte_alloc(mm, vma, pmd, address)))
 		return VM_FAULT_OOM;
-	/* if an huge pmd materialized from under us just retry later */
-	if (unlikely(pmd_trans_huge(*pmd)))
+	/*
+	 * If a huge pmd materialized under us just retry later.  Use
+	 * pmd_trans_unstable() instead of pmd_trans_huge() to ensure the pmd
+	 * didn't become pmd_trans_huge under us and then back to pmd_none, as
+	 * a result of MADV_DONTNEED running immediately after a huge pmd fault
+	 * in a different thread of this mm, in turn leading to a misleading
+	 * pmd_trans_huge() retval.  All we have to ensure is that it is a
+	 * regular pmd that we can walk with pte_offset_map() and we can do that
+	 * through an atomic read in C, which is what pmd_trans_unstable()
+	 * provides.
+	 */
+	if (unlikely(pmd_trans_unstable(pmd)))
 		return 0;
 	/*
 	 * A regular pmd is established and it can't morph into a huge pmd
diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c
index 1ad92b4..7f1bf93 100644
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@ -1039,6 +1039,10 @@ static pg_data_t __ref *hotadd_new_pgdat(int nid, u64 start)
 			return NULL;
 
 		arch_refresh_nodedata(nid, pgdat);
+	} else {
+		/* Reset the nr_zones and classzone_idx to 0 before reuse */
+		pgdat->nr_zones = 0;
+		pgdat->classzone_idx = 0;
 	}
 
 	/* we can use NODE_DATA(nid) from here */
@@ -1205,23 +1209,30 @@ int is_mem_section_removable(unsigned long start_pfn, unsigned long nr_pages)
  */
 static int test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn)
 {
-	unsigned long pfn;
+	unsigned long pfn, sec_end_pfn;
 	struct zone *zone = NULL;
 	struct page *page;
 	int i;
-	for (pfn = start_pfn;
+	for (pfn = start_pfn, sec_end_pfn = SECTION_ALIGN_UP(start_pfn);
 	     pfn < end_pfn;
-	     pfn += MAX_ORDER_NR_PAGES) {
-		i = 0;
-		/* This is just a CONFIG_HOLES_IN_ZONE check.*/
-		while ((i < MAX_ORDER_NR_PAGES) && !pfn_valid_within(pfn + i))
-			i++;
-		if (i == MAX_ORDER_NR_PAGES)
+	     pfn = sec_end_pfn + 1, sec_end_pfn += PAGES_PER_SECTION) {
+		/* Make sure the memory section is present first */
+		if (!present_section_nr(pfn_to_section_nr(pfn)))
 			continue;
-		page = pfn_to_page(pfn + i);
-		if (zone && page_zone(page) != zone)
-			return 0;
-		zone = page_zone(page);
+		for (; pfn < sec_end_pfn && pfn < end_pfn;
+		     pfn += MAX_ORDER_NR_PAGES) {
+			i = 0;
+			/* This is just a CONFIG_HOLES_IN_ZONE check.*/
+			while ((i < MAX_ORDER_NR_PAGES) &&
+				!pfn_valid_within(pfn + i))
+				i++;
+			if (i == MAX_ORDER_NR_PAGES)
+				continue;
+			page = pfn_to_page(pfn + i);
+			if (zone && page_zone(page) != zone)
+				return 0;
+			zone = page_zone(page);
+		}
 	}
 	return 1;
 }
@@ -1799,18 +1810,11 @@ void try_offline_node(int nid)
 		 * wait_table may be allocated from boot memory,
 		 * here only free if it's allocated by vmalloc.
 		 */
-		if (is_vmalloc_addr(zone->wait_table))
+		if (is_vmalloc_addr(zone->wait_table)) {
 			vfree(zone->wait_table);
+			zone->wait_table = NULL;
+		}
 	}
-
-	/*
-	 * Since there is no way to guarentee the address of pgdat/zone is not
-	 * on stack of any kernel threads or used by other kernel objects
-	 * without reference counting or other symchronizing method, do not
-	 * reset node_data and free pgdat here. Just reset it to 0 and reuse
-	 * the memory when the node is online again.
-	 */
-	memset(pgdat, 0, sizeof(*pgdat));
 }
 EXPORT_SYMBOL(try_offline_node);
 
diff --git a/mm/migrate.c b/mm/migrate.c
index a88c12f..808f8ab 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -30,6 +30,7 @@
 #include <linux/mempolicy.h>
 #include <linux/vmalloc.h>
 #include <linux/security.h>
+#include <linux/backing-dev.h>
 #include <linux/memcontrol.h>
 #include <linux/syscalls.h>
 #include <linux/hugetlb.h>
@@ -307,10 +308,12 @@ static inline bool buffer_migrate_lock_buffers(struct buffer_head *head,
  * 2 for pages with a mapping
  * 3 for pages with a mapping and PagePrivate/PagePrivate2 set.
  */
-static int migrate_page_move_mapping(struct address_space *mapping,
+int migrate_page_move_mapping(struct address_space *mapping,
 		struct page *newpage, struct page *page,
 		struct buffer_head *head, enum migrate_mode mode)
 {
+	struct zone *oldzone, *newzone;
+	int dirty;
 	int expected_count = 0;
 	void **pslot;
 
@@ -321,6 +324,9 @@ static int migrate_page_move_mapping(struct address_space *mapping,
 		return MIGRATEPAGE_SUCCESS;
 	}
 
+	oldzone = page_zone(page);
+	newzone = page_zone(newpage);
+
 	spin_lock_irq(&mapping->tree_lock);
 
 	pslot = radix_tree_lookup_slot(&mapping->page_tree,
@@ -361,6 +367,13 @@ static int migrate_page_move_mapping(struct address_space *mapping,
 		set_page_private(newpage, page_private(page));
 	}
 
+	/* Move dirty while page refs frozen and newpage not yet exposed */
+	dirty = PageDirty(page);
+	if (dirty) {
+		ClearPageDirty(page);
+		SetPageDirty(newpage);
+	}
+
 	radix_tree_replace_slot(pslot, newpage);
 
 	/*
@@ -370,6 +383,9 @@ static int migrate_page_move_mapping(struct address_space *mapping,
 	 */
 	page_unfreeze_refs(page, expected_count - 1);
 
+	spin_unlock(&mapping->tree_lock);
+	/* Leave irq disabled to prevent preemption while updating stats */
+
 	/*
 	 * If moved to a different zone then also account
 	 * the page for that zone. Other VM counters will be
@@ -380,16 +396,23 @@ static int migrate_page_move_mapping(struct address_space *mapping,
 	 * via NR_FILE_PAGES and NR_ANON_PAGES if they
 	 * are mapped to swap space.
 	 */
-	__dec_zone_page_state(page, NR_FILE_PAGES);
-	__inc_zone_page_state(newpage, NR_FILE_PAGES);
-	if (!PageSwapCache(page) && PageSwapBacked(page)) {
-		__dec_zone_page_state(page, NR_SHMEM);
-		__inc_zone_page_state(newpage, NR_SHMEM);
+	if (newzone != oldzone) {
+		__dec_zone_state(oldzone, NR_FILE_PAGES);
+		__inc_zone_state(newzone, NR_FILE_PAGES);
+		if (PageSwapBacked(page) && !PageSwapCache(page)) {
+			__dec_zone_state(oldzone, NR_SHMEM);
+			__inc_zone_state(newzone, NR_SHMEM);
+		}
+		if (dirty && mapping_cap_account_dirty(mapping)) {
+			__dec_zone_state(oldzone, NR_FILE_DIRTY);
+			__inc_zone_state(newzone, NR_FILE_DIRTY);
+		}
 	}
-	spin_unlock_irq(&mapping->tree_lock);
+	local_irq_enable();
 
 	return MIGRATEPAGE_SUCCESS;
 }
+EXPORT_SYMBOL(migrate_page_move_mapping);
 
 /*
  * The expected number of remaining references is the same as that
@@ -460,20 +483,9 @@ void migrate_page_copy(struct page *newpage, struct page *page)
 	if (PageMappedToDisk(page))
 		SetPageMappedToDisk(newpage);
 
-	if (PageDirty(page)) {
-		clear_page_dirty_for_io(page);
-		/*
-		 * Want to mark the page and the radix tree as dirty, and
-		 * redo the accounting that clear_page_dirty_for_io undid,
-		 * but we can't use set_page_dirty because that function
-		 * is actually a signal that all of the page has become dirty.
-		 * Whereas only part of our page may be dirty.
-		 */
-		if (PageSwapBacked(page))
-			SetPageDirty(newpage);
-		else
-			__set_page_dirty_nobuffers(newpage);
- 	}
+	/* Move dirty on pages not done by migrate_page_move_mapping() */
+	if (PageDirty(page))
+		SetPageDirty(newpage);
 
 	mlock_migrate_page(newpage, page);
 	ksm_migrate_page(newpage, page);
@@ -492,6 +504,7 @@ void migrate_page_copy(struct page *newpage, struct page *page)
 	if (PageWriteback(newpage))
 		end_page_writeback(newpage);
 }
+EXPORT_SYMBOL(migrate_page_copy);
 
 /************************************************************
  *                    Migration functions
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 73cbc5d..b034f79 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -793,8 +793,11 @@ static void bdi_update_write_bandwidth(struct backing_dev_info *bdi,
 	 *                   bw * elapsed + write_bandwidth * (period - elapsed)
 	 * write_bandwidth = ---------------------------------------------------
 	 *                                          period
+	 *
+	 * @written may have decreased due to account_page_redirty().
+	 * Avoid underflowing @bw calculation.
 	 */
-	bw = written - bdi->written_stamp;
+	bw = written - min(written, bdi->written_stamp);
 	bw *= HZ;
 	if (unlikely(elapsed > period)) {
 		do_div(bw, elapsed);
@@ -858,7 +861,7 @@ static void global_update_bandwidth(unsigned long thresh,
 				    unsigned long now)
 {
 	static DEFINE_SPINLOCK(dirty_lock);
-	static unsigned long update_time;
+	static unsigned long update_time = INITIAL_JIFFIES;
 
 	/*
 	 * check locklessly first to optimize away locking for the most time
diff --git a/mm/process_vm_access.c b/mm/process_vm_access.c
index fd26d04..e739825 100644
--- a/mm/process_vm_access.c
+++ b/mm/process_vm_access.c
@@ -298,7 +298,7 @@ static ssize_t process_vm_rw_core(pid_t pid, const struct iovec *lvec,
 		goto free_proc_pages;
 	}
 
-	mm = mm_access(task, PTRACE_MODE_ATTACH);
+	mm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);
 	if (!mm || IS_ERR(mm)) {
 		rc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;
 		/*
diff --git a/mm/shmem.c b/mm/shmem.c
index 4e4a734..cc02b6c 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -1948,9 +1948,11 @@ static long shmem_fallocate(struct file *file, int mode, loff_t offset,
 									NULL);
 		if (error) {
 			/* Remove the !PageUptodate pages we added */
-			shmem_undo_range(inode,
-				(loff_t)start << PAGE_CACHE_SHIFT,
-				(loff_t)index << PAGE_CACHE_SHIFT, true);
+			if (index > start) {
+				shmem_undo_range(inode,
+				 (loff_t)start << PAGE_CACHE_SHIFT,
+				 ((loff_t)index << PAGE_CACHE_SHIFT) - 1, true);
+			}
 			goto undone;
 		}
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index a2fd7e75..a1e3bec 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -730,20 +730,15 @@ static unsigned long shrink_page_list(struct list_head *page_list,
 			 * could easily OOM just because too many pages are in
 			 * writeback and there is nothing else to reclaim.
 			 *
-			 * Check __GFP_IO, certainly because a loop driver
+			 * Require may_enter_fs to wait on writeback, because
+			 * fs may not have submitted IO yet. And a loop driver
 			 * thread might enter reclaim, and deadlock if it waits
 			 * on a page for which it is needed to do the write
 			 * (loop masks off __GFP_IO|__GFP_FS for this reason);
 			 * but more thought would probably show more reasons.
-			 *
-			 * Don't require __GFP_FS, since we're not going into
-			 * the FS, just waiting on its writeback completion.
-			 * Worryingly, ext4 gfs2 and xfs allocate pages with
-			 * grab_cache_page_write_begin(,,AOP_FLAG_NOFS), so
-			 * testing may_enter_fs here is liable to OOM on them.
 			 */
 			if (global_reclaim(sc) ||
-			    !PageReclaim(page) || !(sc->gfp_mask & __GFP_IO)) {
+			    !PageReclaim(page) || !may_enter_fs) {
 				/*
 				 * This is slightly racy - end_page_writeback()
 				 * might have just cleared PageReclaim, then
@@ -930,7 +925,7 @@ cull_mlocked:
 		if (PageSwapCache(page))
 			try_to_free_swap(page);
 		unlock_page(page);
-		putback_lru_page(page);
+		list_add(&page->lru, &ret_pages);
 		continue;
 
 activate_locked:
diff --git a/net/9p/client.c b/net/9p/client.c
index addc116c..853d623 100644
--- a/net/9p/client.c
+++ b/net/9p/client.c
@@ -828,7 +828,8 @@ static struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,
 	if (err < 0) {
 		if (err == -EIO)
 			c->status = Disconnected;
-		goto reterr;
+		if (err != -ERESTARTSYS)
+			goto reterr;
 	}
 	if (req->status == REQ_STATUS_ERROR) {
 		p9_debug(P9_DEBUG_ERROR, "req_status error %d\n", req->t_err);
diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index ba6db78..69940a7 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -806,6 +806,9 @@ static int ax25_create(struct net *net, struct socket *sock, int protocol,
 	struct sock *sk;
 	ax25_cb *ax25;
 
+	if (protocol < 0 || protocol > SK_PROTOCOL_MAX)
+		return -EINVAL;
+
 	if (!net_eq(net, &init_net))
 		return -EAFNOSUPPORT;
 
diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
index 263cfd1..cf5b766 100644
--- a/net/batman-adv/send.c
+++ b/net/batman-adv/send.c
@@ -353,6 +353,9 @@ batadv_purge_outstanding_packets(struct batadv_priv *bat_priv,
 
 		if (pending) {
 			hlist_del(&forw_packet->list);
+			if (!forw_packet->own)
+				atomic_inc(&bat_priv->batman_queue_left);
+
 			batadv_forw_packet_free(forw_packet);
 		}
 	}
@@ -379,6 +382,9 @@ batadv_purge_outstanding_packets(struct batadv_priv *bat_priv,
 
 		if (pending) {
 			hlist_del(&forw_packet->list);
+			if (!forw_packet->own)
+				atomic_inc(&bat_priv->bcast_queue_left);
+
 			batadv_forw_packet_free(forw_packet);
 		}
 	}
diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
index de030f5..c6056339 100644
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -396,6 +396,20 @@ static void hidp_idle_timeout(unsigned long arg)
 {
 	struct hidp_session *session = (struct hidp_session *) arg;
 
+	/* The HIDP user-space API only contains calls to add and remove
+	 * devices. There is no way to forward events of any kind. Therefore,
+	 * we have to forcefully disconnect a device on idle-timeouts. This is
+	 * unfortunate and weird API design, but it is spec-compliant and
+	 * required for backwards-compatibility. Hence, on idle-timeout, we
+	 * signal driver-detach events, so poll() will be woken up with an
+	 * error-condition on both sockets.
+	 */
+
+	session->intr_sock->sk->sk_err = EUNATCH;
+	session->ctrl_sock->sk->sk_err = EUNATCH;
+	wake_up_interruptible(sk_sleep(session->intr_sock->sk));
+	wake_up_interruptible(sk_sleep(session->ctrl_sock->sk));
+
 	hidp_session_terminate(session);
 }
 
diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index 5f36f70..4b966c6 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -725,7 +725,7 @@ static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,
 			break;
 		}
 
-		if (get_user(opt, (u32 __user *) optval)) {
+		if (get_user(opt, (u16 __user *) optval)) {
 			err = -EFAULT;
 			break;
 		}
diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c
index c9ae6b7..b586a32 100644
--- a/net/bluetooth/sco.c
+++ b/net/bluetooth/sco.c
@@ -456,6 +456,9 @@ static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_le
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
+	if (addr_len < sizeof(struct sockaddr_sco))
+		return -EINVAL;
+
 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c
index cd8c3a4..a882db4 100644
--- a/net/bridge/br_ioctl.c
+++ b/net/bridge/br_ioctl.c
@@ -21,18 +21,19 @@
 #include <asm/uaccess.h>
 #include "br_private.h"
 
-/* called with RTNL */
 static int get_bridge_ifindices(struct net *net, int *indices, int num)
 {
 	struct net_device *dev;
 	int i = 0;
 
-	for_each_netdev(net, dev) {
+	rcu_read_lock();
+	for_each_netdev_rcu(net, dev) {
 		if (i >= num)
 			break;
 		if (dev->priv_flags & IFF_EBRIDGE)
 			indices[i++] = dev->ifindex;
 	}
+	rcu_read_unlock();
 
 	return i;
 }
@@ -247,9 +248,7 @@ static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		if (!ns_capable(dev_net(dev)->user_ns, CAP_NET_ADMIN))
 			return -EPERM;
 
-		spin_lock_bh(&br->lock);
 		br_stp_set_bridge_priority(br, args[1]);
-		spin_unlock_bh(&br->lock);
 		return 0;
 
 	case BRCTL_SET_PORT_PRIORITY:
diff --git a/net/bridge/br_mdb.c b/net/bridge/br_mdb.c
index 19942e3..4e76d2a 100644
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@ -345,7 +345,6 @@ static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
 		return -ENOMEM;
 	rcu_assign_pointer(*pp, p);
 
-	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
 	return 0;
 }
 
@@ -368,6 +367,7 @@ static int __br_mdb_add(struct net *net, struct net_bridge *br,
 	if (!p || p->br != br || p->state == BR_STATE_DISABLED)
 		return -EINVAL;
 
+	memset(&ip, 0, sizeof(ip));
 	ip.proto = entry->addr.proto;
 	if (ip.proto == htons(ETH_P_IP))
 		ip.u.ip4 = entry->addr.u.ip4;
@@ -417,6 +417,7 @@ static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)
 	if (timer_pending(&br->multicast_querier_timer))
 		return -EBUSY;
 
+	memset(&ip, 0, sizeof(ip));
 	ip.proto = entry->addr.proto;
 	if (ip.proto == htons(ETH_P_IP))
 		ip.u.ip4 = entry->addr.u.ip4;
diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c
index 81de010..a09ea17 100644
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@ -1007,7 +1007,7 @@ static int br_ip6_multicast_mld2_report(struct net_bridge *br,
 
 		err = br_ip6_multicast_add_group(br, port, &grec->grec_mca,
 						 vid);
-		if (!err)
+		if (err)
 			break;
 	}
 
@@ -1026,6 +1026,9 @@ static void br_multicast_add_router(struct net_bridge *br,
 	struct net_bridge_port *p;
 	struct hlist_node *slot = NULL;
 
+	if (!hlist_unhashed(&port->rlist))
+		return;
+
 	hlist_for_each_entry(p, &br->router_list, rlist) {
 		if ((unsigned long) port >= (unsigned long) p)
 			break;
@@ -1053,12 +1056,8 @@ static void br_multicast_mark_router(struct net_bridge *br,
 	if (port->multicast_router != 1)
 		return;
 
-	if (!hlist_unhashed(&port->rlist))
-		goto timer;
-
 	br_multicast_add_router(br, port);
 
-timer:
 	mod_timer(&port->multicast_router_timer,
 		  now + br->multicast_querier_interval);
 }
diff --git a/net/bridge/br_stp_if.c b/net/bridge/br_stp_if.c
index 656a6f3..3995a66 100644
--- a/net/bridge/br_stp_if.c
+++ b/net/bridge/br_stp_if.c
@@ -128,7 +128,10 @@ static void br_stp_start(struct net_bridge *br)
 	char *argv[] = { BR_STP_PROG, br->dev->name, "start", NULL };
 	char *envp[] = { NULL };
 
-	r = call_usermodehelper(BR_STP_PROG, argv, envp, UMH_WAIT_PROC);
+	if (net_eq(dev_net(br->dev), &init_net))
+		r = call_usermodehelper(BR_STP_PROG, argv, envp, UMH_WAIT_PROC);
+	else
+		r = -ENOENT;
 
 	spin_lock_bh(&br->lock);
 
@@ -241,12 +244,13 @@ bool br_stp_recalculate_bridge_id(struct net_bridge *br)
 	return true;
 }
 
-/* called under bridge lock */
+/* Acquires and releases bridge lock */
 void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)
 {
 	struct net_bridge_port *p;
 	int wasroot;
 
+	spin_lock_bh(&br->lock);
 	wasroot = br_is_root_bridge(br);
 
 	list_for_each_entry(p, &br->port_list, list) {
@@ -264,6 +268,7 @@ void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)
 	br_port_state_selection(br);
 	if (br_is_root_bridge(br) && !wasroot)
 		br_become_root_bridge(br);
+	spin_unlock_bh(&br->lock);
 }
 
 /* called under bridge lock */
diff --git a/net/caif/caif_socket.c b/net/caif/caif_socket.c
index 526bf56..afeb8e0 100644
--- a/net/caif/caif_socket.c
+++ b/net/caif/caif_socket.c
@@ -332,6 +332,10 @@ static long caif_stream_data_wait(struct sock *sk, long timeo)
 		release_sock(sk);
 		timeo = schedule_timeout(timeo);
 		lock_sock(sk);
+
+		if (sock_flag(sk, SOCK_DEAD))
+			break;
+
 		clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
 	}
 
@@ -376,6 +380,10 @@ static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 		struct sk_buff *skb;
 
 		lock_sock(sk);
+		if (sock_flag(sk, SOCK_DEAD)) {
+			err = -ECONNRESET;
+			goto unlock;
+		}
 		skb = skb_dequeue(&sk->sk_receive_queue);
 		caif_check_flow_release(sk);
 
diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c
index e3bea2e..025ced8 100644
--- a/net/ceph/messenger.c
+++ b/net/ceph/messenger.c
@@ -2277,7 +2277,7 @@ static int read_partial_message(struct ceph_connection *con)
 		con->in_base_pos = -front_len - middle_len - data_len -
 			sizeof(m->footer);
 		con->in_tag = CEPH_MSGR_TAG_READY;
-		return 0;
+		return 1;
 	} else if ((s64)seq - (s64)con->in_seq > 1) {
 		pr_err("read_partial_message bad seq %lld expected %lld\n",
 		       seq, con->in_seq + 1);
@@ -2310,7 +2310,7 @@ static int read_partial_message(struct ceph_connection *con)
 				sizeof(m->footer);
 			con->in_tag = CEPH_MSGR_TAG_READY;
 			con->in_seq++;
-			return 0;
+			return 1;
 		}
 
 		BUG_ON(!con->in_msg);
diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index 1b51d92..7665ce3 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -1702,20 +1702,29 @@ static void kick_requests(struct ceph_osd_client *osdc, bool force_resend,
 		err = __map_request(osdc, req,
 				    force_resend || force_resend_writes);
 		dout("__map_request returned %d\n", err);
-		if (err == 0)
-			continue;  /* no change and no osd was specified */
 		if (err < 0)
 			continue;  /* hrm! */
-		if (req->r_osd == NULL) {
-			dout("tid %llu maps to no valid osd\n", req->r_tid);
-			needmap++;  /* request a newer map */
-			continue;
-		}
+		if (req->r_osd == NULL || err > 0) {
+			if (req->r_osd == NULL) {
+				dout("lingering %p tid %llu maps to no osd\n",
+				     req, req->r_tid);
+				/*
+				 * A homeless lingering request makes
+				 * no sense, as it's job is to keep
+				 * a particular OSD connection open.
+				 * Request a newer map and kick the
+				 * request, knowing that it won't be
+				 * resent until we actually get a map
+				 * that can tell us where to send it.
+				 */
+				needmap++;
+			}
 
-		dout("kicking lingering %p tid %llu osd%d\n", req, req->r_tid,
-		     req->r_osd ? req->r_osd->o_osd : -1);
-		__register_request(osdc, req);
-		__unregister_linger_request(osdc, req);
+			dout("kicking lingering %p tid %llu osd%d\n", req,
+			     req->r_tid, req->r_osd ? req->r_osd->o_osd : -1);
+			__register_request(osdc, req);
+			__unregister_linger_request(osdc, req);
+		}
 	}
 	reset_changed_osds(osdc);
 	mutex_unlock(&osdc->request_mutex);
diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c
index dbd9a47..c1de8d4 100644
--- a/net/ceph/osdmap.c
+++ b/net/ceph/osdmap.c
@@ -89,7 +89,7 @@ static int crush_decode_tree_bucket(void **p, void *end,
 {
 	int j;
 	dout("crush_decode_tree_bucket %p to %p\n", *p, end);
-	ceph_decode_32_safe(p, end, b->num_nodes, bad);
+	ceph_decode_8_safe(p, end, b->num_nodes, bad);
 	b->node_weights = kcalloc(b->num_nodes, sizeof(u32), GFP_NOFS);
 	if (b->node_weights == NULL)
 		return -ENOMEM;
@@ -798,6 +798,110 @@ bad:
 }
 
 /*
+ * Encoding order is (new_up_client, new_state, new_weight).  Need to
+ * apply in the (new_weight, new_state, new_up_client) order, because
+ * an incremental map may look like e.g.
+ *
+ *     new_up_client: { osd=6, addr=... } # set osd_state and addr
+ *     new_state: { osd=6, xorstate=EXISTS } # clear osd_state
+ */
+static int decode_new_up_state_weight(void **p, void *end,
+				      struct ceph_osdmap *map)
+{
+	void *new_up_client;
+	void *new_state;
+	void *new_weight_end;
+	u32 len;
+
+	new_up_client = *p;
+	ceph_decode_32_safe(p, end, len, e_inval);
+	len *= sizeof(u32) + sizeof(struct ceph_entity_addr);
+	ceph_decode_need(p, end, len, e_inval);
+	*p += len;
+
+	new_state = *p;
+	ceph_decode_32_safe(p, end, len, e_inval);
+	len *= sizeof(u32) + sizeof(u8);
+	ceph_decode_need(p, end, len, e_inval);
+	*p += len;
+
+	/* new_weight */
+	ceph_decode_32_safe(p, end, len, e_inval);
+	while (len--) {
+		s32 osd;
+		u32 w;
+
+		ceph_decode_need(p, end, 2*sizeof(u32), e_inval);
+		osd = ceph_decode_32(p);
+		w = ceph_decode_32(p);
+		BUG_ON(osd >= map->max_osd);
+		pr_info("osd%d weight 0x%x %s\n", osd, w,
+		     w == CEPH_OSD_IN ? "(in)" :
+		     (w == CEPH_OSD_OUT ? "(out)" : ""));
+		map->osd_weight[osd] = w;
+
+		/*
+		 * If we are marking in, set the EXISTS, and clear the
+		 * AUTOOUT and NEW bits.
+		 */
+		if (w) {
+			map->osd_state[osd] |= CEPH_OSD_EXISTS;
+			map->osd_state[osd] &= ~(CEPH_OSD_AUTOOUT |
+						 CEPH_OSD_NEW);
+		}
+	}
+	new_weight_end = *p;
+
+	/* new_state (up/down) */
+	*p = new_state;
+	len = ceph_decode_32(p);
+	while (len--) {
+		s32 osd;
+		u8 xorstate;
+
+		osd = ceph_decode_32(p);
+		xorstate = ceph_decode_8(p);
+		if (xorstate == 0)
+			xorstate = CEPH_OSD_UP;
+		BUG_ON(osd >= map->max_osd);
+		if ((map->osd_state[osd] & CEPH_OSD_UP) &&
+		    (xorstate & CEPH_OSD_UP))
+			pr_info("osd%d down\n", osd);
+		if ((map->osd_state[osd] & CEPH_OSD_EXISTS) &&
+		    (xorstate & CEPH_OSD_EXISTS)) {
+			pr_info("osd%d does not exist\n", osd);
+			map->osd_weight[osd] = CEPH_OSD_IN;
+			memset(map->osd_addr + osd, 0, sizeof(*map->osd_addr));
+			map->osd_state[osd] = 0;
+		} else {
+			map->osd_state[osd] ^= xorstate;
+		}
+	}
+
+	/* new_up_client */
+	*p = new_up_client;
+	len = ceph_decode_32(p);
+	while (len--) {
+		s32 osd;
+		struct ceph_entity_addr addr;
+
+		osd = ceph_decode_32(p);
+		ceph_decode_copy(p, &addr, sizeof(addr));
+		ceph_decode_addr(&addr);
+		BUG_ON(osd >= map->max_osd);
+		pr_info("osd%d up\n", osd);
+		map->osd_state[osd] |= CEPH_OSD_EXISTS | CEPH_OSD_UP;
+		map->osd_addr[osd] = addr;
+	}
+
+	*p = new_weight_end;
+	return 0;
+
+e_inval:
+	return -EINVAL;
+}
+
+/*
  * decode and apply an incremental map update.
  */
 struct ceph_osdmap *osdmap_apply_incremental(void **p, void *end,
@@ -912,50 +1016,10 @@ struct ceph_osdmap *osdmap_apply_incremental(void **p, void *end,
 			__remove_pg_pool(&map->pg_pools, pi);
 	}
 
-	/* new_up */
-	err = -EINVAL;
-	ceph_decode_32_safe(p, end, len, bad);
-	while (len--) {
-		u32 osd;
-		struct ceph_entity_addr addr;
-		ceph_decode_32_safe(p, end, osd, bad);
-		ceph_decode_copy_safe(p, end, &addr, sizeof(addr), bad);
-		ceph_decode_addr(&addr);
-		pr_info("osd%d up\n", osd);
-		BUG_ON(osd >= map->max_osd);
-		map->osd_state[osd] |= CEPH_OSD_UP;
-		map->osd_addr[osd] = addr;
-	}
-
-	/* new_state */
-	ceph_decode_32_safe(p, end, len, bad);
-	while (len--) {
-		u32 osd;
-		u8 xorstate;
-		ceph_decode_32_safe(p, end, osd, bad);
-		xorstate = **(u8 **)p;
-		(*p)++;  /* clean flag */
-		if (xorstate == 0)
-			xorstate = CEPH_OSD_UP;
-		if (xorstate & CEPH_OSD_UP)
-			pr_info("osd%d down\n", osd);
-		if (osd < map->max_osd)
-			map->osd_state[osd] ^= xorstate;
-	}
-
-	/* new_weight */
-	ceph_decode_32_safe(p, end, len, bad);
-	while (len--) {
-		u32 osd, off;
-		ceph_decode_need(p, end, sizeof(u32)*2, bad);
-		osd = ceph_decode_32(p);
-		off = ceph_decode_32(p);
-		pr_info("osd%d weight 0x%x %s\n", osd, off,
-		     off == CEPH_OSD_IN ? "(in)" :
-		     (off == CEPH_OSD_OUT ? "(out)" : ""));
-		if (osd < map->max_osd)
-			map->osd_weight[osd] = off;
-	}
+	/* new_up_client, new_state, new_weight */
+	err = decode_new_up_state_weight(p, end, map);
+	if (err)
+		goto bad;
 
 	/* new_pg_temp */
 	ceph_decode_32_safe(p, end, len, bad);
diff --git a/net/core/datagram.c b/net/core/datagram.c
index b71423d..052b71c 100644
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@ -128,6 +128,35 @@ out_noerr:
 	goto out;
 }
 
+static struct sk_buff *skb_set_peeked(struct sk_buff *skb)
+{
+	struct sk_buff *nskb;
+
+	if (skb->peeked)
+		return skb;
+
+	/* We have to unshare an skb before modifying it. */
+	if (!skb_shared(skb))
+		goto done;
+
+	nskb = skb_clone(skb, GFP_ATOMIC);
+	if (!nskb)
+		return ERR_PTR(-ENOMEM);
+
+	skb->prev->next = nskb;
+	skb->next->prev = nskb;
+	nskb->prev = skb->prev;
+	nskb->next = skb->next;
+
+	consume_skb(skb);
+	skb = nskb;
+
+done:
+	skb->peeked = 1;
+
+	return skb;
+}
+
 /**
  *	__skb_recv_datagram - Receive a datagram skbuff
  *	@sk: socket
@@ -162,7 +191,9 @@ out_noerr:
 struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,
 				    int *peeked, int *off, int *err)
 {
+	struct sk_buff_head *queue = &sk->sk_receive_queue;
 	struct sk_buff *skb, *last;
+	unsigned long cpu_flags;
 	long timeo;
 	/*
 	 * Caller is allowed not to check sk->sk_err before skb_recv_datagram()
@@ -181,8 +212,6 @@ struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,
 		 * Look at current nfs client by the way...
 		 * However, this function was correct in any case. 8)
 		 */
-		unsigned long cpu_flags;
-		struct sk_buff_head *queue = &sk->sk_receive_queue;
 		int _off = *off;
 
 		last = (struct sk_buff *)queue;
@@ -196,7 +225,12 @@ struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,
 					_off -= skb->len;
 					continue;
 				}
-				skb->peeked = 1;
+
+				skb = skb_set_peeked(skb);
+				error = PTR_ERR(skb);
+				if (IS_ERR(skb))
+					goto unlock_err;
+
 				atomic_inc(&skb->users);
 			} else
 				__skb_unlink(skb, queue);
@@ -216,6 +250,8 @@ struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,
 
 	return NULL;
 
+unlock_err:
+	spin_unlock_irqrestore(&queue->lock, cpu_flags);
 no_packet:
 	*err = error;
 	return NULL;
@@ -665,7 +701,8 @@ __sum16 __skb_checksum_complete_head(struct sk_buff *skb, int len)
 	if (likely(!sum)) {
 		if (unlikely(skb->ip_summed == CHECKSUM_COMPLETE))
 			netdev_rx_csum_fault(skb->dev);
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		if (!skb_shared(skb))
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
 	}
 	return sum;
 }
diff --git a/net/core/dev.c b/net/core/dev.c
index aeca8dd..1ccfc49 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3443,8 +3443,6 @@ static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)
 
 	pt_prev = NULL;
 
-	rcu_read_lock();
-
 another_round:
 	skb->skb_iif = skb->dev->ifindex;
 
@@ -3454,7 +3452,7 @@ another_round:
 	    skb->protocol == cpu_to_be16(ETH_P_8021AD)) {
 		skb = vlan_untag(skb);
 		if (unlikely(!skb))
-			goto unlock;
+			goto out;
 	}
 
 #ifdef CONFIG_NET_CLS_ACT
@@ -3479,7 +3477,7 @@ skip_taps:
 #ifdef CONFIG_NET_CLS_ACT
 	skb = handle_ing(skb, &pt_prev, &ret, orig_dev);
 	if (!skb)
-		goto unlock;
+		goto out;
 ncls:
 #endif
 
@@ -3494,7 +3492,7 @@ ncls:
 		if (vlan_do_receive(&skb))
 			goto another_round;
 		else if (unlikely(!skb))
-			goto unlock;
+			goto out;
 	}
 
 	rx_handler = rcu_dereference(skb->dev->rx_handler);
@@ -3506,7 +3504,7 @@ ncls:
 		switch (rx_handler(&skb)) {
 		case RX_HANDLER_CONSUMED:
 			ret = NET_RX_SUCCESS;
-			goto unlock;
+			goto out;
 		case RX_HANDLER_ANOTHER:
 			goto another_round;
 		case RX_HANDLER_EXACT:
@@ -3558,8 +3556,6 @@ drop:
 		ret = NET_RX_DROP;
 	}
 
-unlock:
-	rcu_read_unlock();
 out:
 	return ret;
 }
@@ -3606,29 +3602,30 @@ static int __netif_receive_skb(struct sk_buff *skb)
  */
 int netif_receive_skb(struct sk_buff *skb)
 {
+	int ret;
+
 	net_timestamp_check(netdev_tstamp_prequeue, skb);
 
 	if (skb_defer_rx_timestamp(skb))
 		return NET_RX_SUCCESS;
 
+	rcu_read_lock();
+
 #ifdef CONFIG_RPS
 	if (static_key_false(&rps_needed)) {
 		struct rps_dev_flow voidflow, *rflow = &voidflow;
-		int cpu, ret;
-
-		rcu_read_lock();
-
-		cpu = get_rps_cpu(skb->dev, skb, &rflow);
+		int cpu = get_rps_cpu(skb->dev, skb, &rflow);
 
 		if (cpu >= 0) {
 			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
 			rcu_read_unlock();
 			return ret;
 		}
-		rcu_read_unlock();
 	}
 #endif
-	return __netif_receive_skb(skb);
+	ret = __netif_receive_skb(skb);
+	rcu_read_unlock();
+	return ret;
 }
 EXPORT_SYMBOL(netif_receive_skb);
 
@@ -4038,8 +4035,10 @@ static int process_backlog(struct napi_struct *napi, int quota)
 		unsigned int qlen;
 
 		while ((skb = __skb_dequeue(&sd->process_queue))) {
+			rcu_read_lock();
 			local_irq_enable();
 			__netif_receive_skb(skb);
+			rcu_read_unlock();
 			local_irq_disable();
 			input_queue_head_incr(sd);
 			if (++work >= quota) {
diff --git a/net/core/dst.c b/net/core/dst.c
index c0e0218..1bf6842 100644
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@ -280,10 +280,11 @@ void dst_release(struct dst_entry *dst)
 {
 	if (dst) {
 		int newrefcnt;
+		unsigned short nocache = dst->flags & DST_NOCACHE;
 
 		newrefcnt = atomic_dec_return(&dst->__refcnt);
 		WARN_ON(newrefcnt < 0);
-		if (unlikely(dst->flags & DST_NOCACHE) && !newrefcnt)
+		if (!newrefcnt && unlikely(nocache))
 			call_rcu(&dst->rcu_head, dst_destroy_rcu);
 	}
 }
diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index ce91766..213b612 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -1066,7 +1066,7 @@ static int ethtool_get_strings(struct net_device *dev, void __user *useraddr)
 
 	gstrings.len = ret;
 
-	data = kmalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);
+	data = kcalloc(gstrings.len, ETH_GSTRING_LEN, GFP_USER);
 	if (!data)
 		return -ENOMEM;
 
diff --git a/net/core/fib_rules.c b/net/core/fib_rules.c
index 55e08e2..84340a2 100644
--- a/net/core/fib_rules.c
+++ b/net/core/fib_rules.c
@@ -596,15 +596,17 @@ static int dump_rules(struct sk_buff *skb, struct netlink_callback *cb,
 {
 	int idx = 0;
 	struct fib_rule *rule;
+	int err = 0;
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(rule, &ops->rules_list, list) {
 		if (idx < cb->args[1])
 			goto skip;
 
-		if (fib_nl_fill_rule(skb, rule, NETLINK_CB(cb->skb).portid,
-				     cb->nlh->nlmsg_seq, RTM_NEWRULE,
-				     NLM_F_MULTI, ops) < 0)
+		err = fib_nl_fill_rule(skb, rule, NETLINK_CB(cb->skb).portid,
+				       cb->nlh->nlmsg_seq, RTM_NEWRULE,
+				       NLM_F_MULTI, ops);
+		if (err < 0)
 			break;
 skip:
 		idx++;
@@ -613,7 +615,7 @@ skip:
 	cb->args[1] = idx;
 	rules_ops_put(ops);
 
-	return skb->len;
+	return err;
 }
 
 static int fib_nl_dumprule(struct sk_buff *skb, struct netlink_callback *cb)
@@ -629,7 +631,9 @@ static int fib_nl_dumprule(struct sk_buff *skb, struct netlink_callback *cb)
 		if (ops == NULL)
 			return -EAFNOSUPPORT;
 
-		return dump_rules(skb, cb, ops);
+		dump_rules(skb, cb, ops);
+
+		return skb->len;
 	}
 
 	rcu_read_lock();
diff --git a/net/core/pktgen.c b/net/core/pktgen.c
index ebbea53..21a23d9 100644
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@ -3377,8 +3377,10 @@ static int pktgen_thread_worker(void *arg)
 	pktgen_rem_thread(t);
 
 	/* Wait for kthread_stop */
-	while (!kthread_should_stop()) {
+	for (;;) {
 		set_current_state(TASK_INTERRUPTIBLE);
+		if (kthread_should_stop())
+			break;
 		schedule();
 	}
 	__set_current_state(TASK_RUNNING);
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index a67310e..602c6d0 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -899,14 +899,16 @@ static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
 		goto nla_put_failure;
 
 	if (1) {
-		struct rtnl_link_ifmap map = {
-			.mem_start   = dev->mem_start,
-			.mem_end     = dev->mem_end,
-			.base_addr   = dev->base_addr,
-			.irq         = dev->irq,
-			.dma         = dev->dma,
-			.port        = dev->if_port,
-		};
+		struct rtnl_link_ifmap map;
+
+		memset(&map, 0, sizeof(map));
+		map.mem_start   = dev->mem_start;
+		map.mem_end     = dev->mem_end;
+		map.base_addr   = dev->base_addr;
+		map.irq         = dev->irq;
+		map.dma         = dev->dma;
+		map.port        = dev->if_port;
+
 		if (nla_put(skb, IFLA_MAP, sizeof(map), &map))
 			goto nla_put_failure;
 	}
diff --git a/net/core/scm.c b/net/core/scm.c
index b4da80b..7a6cf83 100644
--- a/net/core/scm.c
+++ b/net/core/scm.c
@@ -87,6 +87,7 @@ static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)
 		*fplp = fpl;
 		fpl->count = 0;
 		fpl->max = SCM_MAX_FD;
+		fpl->user = NULL;
 	}
 	fpp = &fpl->fp[fpl->count];
 
@@ -107,6 +108,10 @@ static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)
 		*fpp++ = file;
 		fpl->count++;
 	}
+
+	if (!fpl->user)
+		fpl->user = get_uid(current_user());
+
 	return num;
 }
 
@@ -119,6 +124,7 @@ void __scm_destroy(struct scm_cookie *scm)
 		scm->fp = NULL;
 		for (i=fpl->count-1; i>=0; i--)
 			fput(fpl->fp[i]);
+		free_uid(fpl->user);
 		kfree(fpl);
 	}
 }
@@ -306,6 +312,8 @@ void scm_detach_fds(struct msghdr *msg, struct scm_cookie *scm)
 			err = put_user(cmlen, &cm->cmsg_len);
 		if (!err) {
 			cmlen = CMSG_SPACE(i*sizeof(int));
+			if (msg->msg_controllen < cmlen)
+				cmlen = msg->msg_controllen;
 			msg->msg_control += cmlen;
 			msg->msg_controllen -= cmlen;
 		}
@@ -335,6 +343,7 @@ struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
 		for (i = 0; i < fpl->count; i++)
 			get_file(fpl->fp[i]);
 		new_fpl->max = new_fpl->count;
+		new_fpl->user = get_uid(fpl->user);
 	}
 	return new_fpl;
 }
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 6148716..05195b8 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -2711,11 +2711,12 @@ EXPORT_SYMBOL(skb_append_datato_frags);
  */
 unsigned char *skb_pull_rcsum(struct sk_buff *skb, unsigned int len)
 {
+	unsigned char *data = skb->data;
+
 	BUG_ON(len > skb->len);
-	skb->len -= len;
-	BUG_ON(skb->len < skb->data_len);
-	skb_postpull_rcsum(skb, skb->data, len);
-	return skb->data += len;
+	__skb_pull(skb, len);
+	skb_postpull_rcsum(skb, data, len);
+	return skb->data;
 }
 EXPORT_SYMBOL_GPL(skb_pull_rcsum);
 
diff --git a/net/core/sock.c b/net/core/sock.c
index af65d17..5a954fc 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -419,8 +419,6 @@ static void sock_warn_obsolete_bsdism(const char *name)
 	}
 }
 
-#define SK_FLAGS_TIMESTAMP ((1UL << SOCK_TIMESTAMP) | (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE))
-
 static void sock_disable_timestamp(struct sock *sk, unsigned long flags)
 {
 	if (sk->sk_flags & flags) {
diff --git a/net/decnet/af_decnet.c b/net/decnet/af_decnet.c
index c21f200..ca61065 100644
--- a/net/decnet/af_decnet.c
+++ b/net/decnet/af_decnet.c
@@ -677,6 +677,9 @@ static int dn_create(struct net *net, struct socket *sock, int protocol,
 {
 	struct sock *sk;
 
+	if (protocol < 0 || protocol > SK_PROTOCOL_MAX)
+		return -EINVAL;
+
 	if (!net_eq(net, &init_net))
 		return -EAFNOSUPPORT;
 
diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c
index fe32388..b961005 100644
--- a/net/decnet/dn_route.c
+++ b/net/decnet/dn_route.c
@@ -1030,10 +1030,13 @@ source_ok:
 	if (!fld.daddr) {
 		fld.daddr = fld.saddr;
 
-		err = -EADDRNOTAVAIL;
 		if (dev_out)
 			dev_put(dev_out);
+		err = -EINVAL;
 		dev_out = init_net.loopback_dev;
+		if (!dev_out->dn_ptr)
+			goto out;
+		err = -EADDRNOTAVAIL;
 		dev_hold(dev_out);
 		if (!fld.daddr) {
 			fld.daddr =
@@ -1106,6 +1109,8 @@ source_ok:
 		if (dev_out == NULL)
 			goto out;
 		dn_db = rcu_dereference_raw(dev_out->dn_ptr);
+		if (!dn_db)
+			goto e_inval;
 		/* Possible improvement - check all devices for local addr */
 		if (dn_dev_islocal(dev_out, fld.daddr)) {
 			dev_put(dev_out);
@@ -1147,6 +1152,8 @@ select_source:
 			dev_put(dev_out);
 		dev_out = init_net.loopback_dev;
 		dev_hold(dev_out);
+		if (!dev_out->dn_ptr)
+			goto e_inval;
 		fld.flowidn_oif = dev_out->ifindex;
 		if (res.fi)
 			dn_fib_info_put(res.fi);
diff --git a/net/ipv4/Kconfig b/net/ipv4/Kconfig
index 8603ca8..3d55679 100644
--- a/net/ipv4/Kconfig
+++ b/net/ipv4/Kconfig
@@ -639,3 +639,5 @@ config TCP_MD5SIG
 	  on the Internet.
 
 	  If unsure, say N.
+config WLAN_UPDATE_SEQ
+	bool "Ambarella cooperate with wlan to update socket sequence"
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index c4adc31..975c369 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -288,6 +288,9 @@ static int inet_create(struct net *net, struct socket *sock, int protocol,
 		if (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)
 			build_ehash_secret();
 
+	if (protocol < 0 || protocol >= IPPROTO_MAX)
+		return -EINVAL;
+
 	sock->state = SS_UNCONNECTED;
 
 	/* Look for the requested type/protocol pair. */
diff --git a/net/ipv4/datagram.c b/net/ipv4/datagram.c
index 5f3dc1d..291b082 100644
--- a/net/ipv4/datagram.c
+++ b/net/ipv4/datagram.c
@@ -20,7 +20,7 @@
 #include <net/route.h>
 #include <net/tcp_states.h>
 
-int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct sockaddr_in *usin = (struct sockaddr_in *) uaddr;
@@ -39,8 +39,6 @@ int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 
 	sk_dst_reset(sk);
 
-	lock_sock(sk);
-
 	oif = sk->sk_bound_dev_if;
 	saddr = inet->inet_saddr;
 	if (ipv4_is_multicast(usin->sin_addr.s_addr)) {
@@ -81,9 +79,19 @@ int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	sk_dst_set(sk, &rt->dst);
 	err = 0;
 out:
-	release_sock(sk);
 	return err;
 }
+EXPORT_SYMBOL(__ip4_datagram_connect);
+
+int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+{
+	int res;
+
+	lock_sock(sk);
+	res = __ip4_datagram_connect(sk, uaddr, addr_len);
+	release_sock(sk);
+	return res;
+}
 EXPORT_SYMBOL(ip4_datagram_connect);
 
 /* Because UDP xmit path can manipulate sk_dst_cache without holding
diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c
index 31ee5c6..479e8a6 100644
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@ -126,6 +126,9 @@ int ip_forward(struct sk_buff *skb)
 	struct rtable *rt;	/* Route we use */
 	struct ip_options *opt	= &(IPCB(skb)->opt);
 
+	if (unlikely(skb->sk))
+		goto drop;
+
 	if (skb_warn_if_lro(skb))
 		goto drop;
 
diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c
index 4c1884f..4d98a6b 100644
--- a/net/ipv4/ip_fragment.c
+++ b/net/ipv4/ip_fragment.c
@@ -356,7 +356,7 @@ static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)
 	ihl = ip_hdrlen(skb);
 
 	/* Determine the position of this fragment. */
-	end = offset + skb->len - ihl;
+	end = offset + skb->len - skb_network_offset(skb) - ihl;
 	err = -EINVAL;
 
 	/* Is this the final fragment? */
@@ -386,7 +386,7 @@ static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)
 		goto err;
 
 	err = -ENOMEM;
-	if (pskb_pull(skb, ihl) == NULL)
+	if (!pskb_pull(skb, skb_network_offset(skb) + ihl))
 		goto err;
 
 	err = pskb_trim_rcsum(skb, end - offset);
@@ -627,6 +627,9 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,
 	iph->frag_off = qp->q.max_size ? htons(IP_DF) : 0;
 	iph->tot_len = htons(len);
 	iph->tos |= ecn;
+
+	ip_send_check(iph);
+
 	IP_INC_STATS_BH(net, IPSTATS_MIB_REASMOKS);
 	qp->q.fragments = NULL;
 	qp->q.fragments_tail = NULL;
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 57e7450..e4f3f05 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -80,6 +80,10 @@
 #include <linux/netlink.h>
 #include <linux/tcp.h>
 
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+extern int iphdr_updatebywlan(struct sock *sk, struct iphdr *iph);
+#endif
+
 int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
 EXPORT_SYMBOL(sysctl_ip_default_ttl);
 
@@ -395,6 +399,9 @@ packet_routed:
 	}
 
 	ip_select_ident_segs(skb, sk, skb_shinfo(skb)->gso_segs ?: 1);
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+	iphdr_updatebywlan(sk, iph);
+#endif
 
 	skb->priority = sk->sk_priority;
 	skb->mark = sk->sk_mark;
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index 56d079b..89570f0 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -136,7 +136,7 @@ static int __ipmr_fill_mroute(struct mr_table *mrt, struct sk_buff *skb,
 			      struct mfc_cache *c, struct rtmsg *rtm);
 static void mroute_netlink_event(struct mr_table *mrt, struct mfc_cache *mfc,
 				 int cmd);
-static void mroute_clean_tables(struct mr_table *mrt);
+static void mroute_clean_tables(struct mr_table *mrt, bool all);
 static void ipmr_expire_process(unsigned long arg);
 
 #ifdef CONFIG_IP_MROUTE_MULTIPLE_TABLES
@@ -348,7 +348,7 @@ static struct mr_table *ipmr_new_table(struct net *net, u32 id)
 static void ipmr_free_table(struct mr_table *mrt)
 {
 	del_timer_sync(&mrt->ipmr_expire_timer);
-	mroute_clean_tables(mrt);
+	mroute_clean_tables(mrt, true);
 	kfree(mrt);
 }
 
@@ -881,8 +881,10 @@ static struct mfc_cache *ipmr_cache_alloc(void)
 {
 	struct mfc_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_KERNEL);
 
-	if (c)
+	if (c) {
+		c->mfc_un.res.last_assert = jiffies - MFC_ASSERT_THRESH - 1;
 		c->mfc_un.res.minvif = MAXVIFS;
+	}
 	return c;
 }
 
@@ -1199,7 +1201,7 @@ static int ipmr_mfc_add(struct net *net, struct mr_table *mrt,
  *	Close the multicast socket, and clear the vif tables etc
  */
 
-static void mroute_clean_tables(struct mr_table *mrt)
+static void mroute_clean_tables(struct mr_table *mrt, bool all)
 {
 	int i;
 	LIST_HEAD(list);
@@ -1208,8 +1210,9 @@ static void mroute_clean_tables(struct mr_table *mrt)
 	/* Shut down all active vif entries */
 
 	for (i = 0; i < mrt->maxvif; i++) {
-		if (!(mrt->vif_table[i].flags & VIFF_STATIC))
-			vif_delete(mrt, i, 0, &list);
+		if (!all && (mrt->vif_table[i].flags & VIFF_STATIC))
+			continue;
+		vif_delete(mrt, i, 0, &list);
 	}
 	unregister_netdevice_many(&list);
 
@@ -1217,7 +1220,7 @@ static void mroute_clean_tables(struct mr_table *mrt)
 
 	for (i = 0; i < MFC_LINES; i++) {
 		list_for_each_entry_safe(c, next, &mrt->mfc_cache_array[i], list) {
-			if (c->mfc_flags & MFC_STATIC)
+			if (!all && (c->mfc_flags & MFC_STATIC))
 				continue;
 			list_del_rcu(&c->list);
 			mroute_netlink_event(mrt, c, RTM_DELROUTE);
@@ -1252,7 +1255,7 @@ static void mrtsock_destruct(struct sock *sk)
 						    NETCONFA_IFINDEX_ALL,
 						    net->ipv4.devconf_all);
 			RCU_INIT_POINTER(mrt->mroute_sk, NULL);
-			mroute_clean_tables(mrt);
+			mroute_clean_tables(mrt, false);
 		}
 	}
 	rtnl_unlock();
@@ -1672,8 +1675,8 @@ static inline int ipmr_forward_finish(struct sk_buff *skb)
 {
 	struct ip_options *opt = &(IPCB(skb)->opt);
 
-	IP_INC_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_OUTFORWDATAGRAMS);
-	IP_ADD_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_OUTOCTETS, skb->len);
+	IP_INC_STATS(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_OUTFORWDATAGRAMS);
+	IP_ADD_STATS(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_OUTOCTETS, skb->len);
 
 	if (unlikely(opt->optlen))
 		ip_forward_options(skb);
@@ -1735,7 +1738,7 @@ static void ipmr_queue_xmit(struct net *net, struct mr_table *mrt,
 		 * to blackhole.
 		 */
 
-		IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_FRAGFAILS);
+		IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGFAILS);
 		ip_rt_put(rt);
 		goto out_free;
 	}
diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c
index c8abe31..95a5f26 100644
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@ -350,11 +350,12 @@ unsigned int arpt_do_table(struct sk_buff *skb,
 }
 
 /* All zeroes == unconditional rule. */
-static inline bool unconditional(const struct arpt_arp *arp)
+static inline bool unconditional(const struct arpt_entry *e)
 {
 	static const struct arpt_arp uncond;
 
-	return memcmp(arp, &uncond, sizeof(uncond)) == 0;
+	return e->target_offset == sizeof(struct arpt_entry) &&
+	       memcmp(&e->arp, &uncond, sizeof(uncond)) == 0;
 }
 
 /* Figures out from what hook each rule can be called: returns 0 if
@@ -393,11 +394,10 @@ static int mark_source_chains(const struct xt_table_info *newinfo,
 				|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));
 
 			/* Unconditional return/END. */
-			if ((e->target_offset == sizeof(struct arpt_entry) &&
+			if ((unconditional(e) &&
 			     (strcmp(t->target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &&
-			     t->verdict < 0 && unconditional(&e->arp)) ||
-			    visited) {
+			     t->verdict < 0) || visited) {
 				unsigned int oldpos, size;
 
 				if ((strcmp(t->target.u.user.name,
@@ -430,6 +430,8 @@ static int mark_source_chains(const struct xt_table_info *newinfo,
 				size = e->next_offset;
 				e = (struct arpt_entry *)
 					(entry0 + pos + size);
+				if (pos + size >= newinfo->size)
+					return 0;
 				e->counters.pcnt = pos;
 				pos += size;
 			} else {
@@ -452,6 +454,8 @@ static int mark_source_chains(const struct xt_table_info *newinfo,
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e->next_offset;
+					if (newpos >= newinfo->size)
+						return 0;
 				}
 				e = (struct arpt_entry *)
 					(entry0 + newpos);
@@ -465,25 +469,6 @@ static int mark_source_chains(const struct xt_table_info *newinfo,
 	return 1;
 }
 
-static inline int check_entry(const struct arpt_entry *e, const char *name)
-{
-	const struct xt_entry_target *t;
-
-	if (!arp_checkentry(&e->arp)) {
-		duprintf("arp_tables: arp check failed %p %s.\n", e, name);
-		return -EINVAL;
-	}
-
-	if (e->target_offset + sizeof(struct xt_entry_target) > e->next_offset)
-		return -EINVAL;
-
-	t = arpt_get_target_c(e);
-	if (e->target_offset + t->u.target_size > e->next_offset)
-		return -EINVAL;
-
-	return 0;
-}
-
 static inline int check_target(struct arpt_entry *e, const char *name)
 {
 	struct xt_entry_target *t = arpt_get_target(e);
@@ -513,10 +498,6 @@ find_check_entry(struct arpt_entry *e, const char *name, unsigned int size)
 	struct xt_target *target;
 	int ret;
 
-	ret = check_entry(e, name);
-	if (ret)
-		return ret;
-
 	t = arpt_get_target(e);
 	target = xt_request_find_target(NFPROTO_ARP, t->u.user.name,
 					t->u.user.revision);
@@ -542,7 +523,7 @@ static bool check_underflow(const struct arpt_entry *e)
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
-	if (!unconditional(&e->arp))
+	if (!unconditional(e))
 		return false;
 	t = arpt_get_target_c(e);
 	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
@@ -561,9 +542,11 @@ static inline int check_entry_size_and_hooks(struct arpt_entry *e,
 					     unsigned int valid_hooks)
 {
 	unsigned int h;
+	int err;
 
 	if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf("Bad offset %p\n", e);
 		return -EINVAL;
 	}
@@ -575,6 +558,14 @@ static inline int check_entry_size_and_hooks(struct arpt_entry *e,
 		return -EINVAL;
 	}
 
+	if (!arp_checkentry(&e->arp))
+		return -EINVAL;
+
+	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
+				     e->next_offset);
+	if (err)
+		return err;
+
 	/* Check hooks & underflows */
 	for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
 		if (!(valid_hooks & (1 << h)))
@@ -583,9 +574,9 @@ static inline int check_entry_size_and_hooks(struct arpt_entry *e,
 			newinfo->hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e - base == underflows[h]) {
 			if (!check_underflow(e)) {
-				pr_err("Underflows must be unconditional and "
-				       "use the STANDARD target with "
-				       "ACCEPT/DROP\n");
+				pr_debug("Underflows must be unconditional and "
+					 "use the STANDARD target with "
+					 "ACCEPT/DROP\n");
 				return -EINVAL;
 			}
 			newinfo->underflow[h] = underflows[h];
@@ -675,10 +666,8 @@ static int translate_table(struct xt_table_info *newinfo, void *entry0,
 		}
 	}
 
-	if (!mark_source_chains(newinfo, repl->valid_hooks, entry0)) {
-		duprintf("Looping hook\n");
+	if (!mark_source_chains(newinfo, repl->valid_hooks, entry0))
 		return -ELOOP;
-	}
 
 	/* Finally, each sanity check must pass */
 	i = 0;
@@ -1071,6 +1060,9 @@ static int do_replace(struct net *net, const void __user *user,
 	/* overflow check */
 	if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
+	if (tmp.num_counters == 0)
+		return -EINVAL;
+
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
@@ -1111,56 +1103,18 @@ static int do_add_counters(struct net *net, const void __user *user,
 	unsigned int i, curcpu;
 	struct xt_counters_info tmp;
 	struct xt_counters *paddc;
-	unsigned int num_counters;
-	const char *name;
-	int size;
-	void *ptmp;
 	struct xt_table *t;
 	const struct xt_table_info *private;
 	int ret = 0;
 	void *loc_cpu_entry;
 	struct arpt_entry *iter;
 	unsigned int addend;
-#ifdef CONFIG_COMPAT
-	struct compat_xt_counters_info compat_tmp;
-
-	if (compat) {
-		ptmp = &compat_tmp;
-		size = sizeof(struct compat_xt_counters_info);
-	} else
-#endif
-	{
-		ptmp = &tmp;
-		size = sizeof(struct xt_counters_info);
-	}
 
-	if (copy_from_user(ptmp, user, size) != 0)
-		return -EFAULT;
+	paddc = xt_copy_counters_from_user(user, len, &tmp, compat);
+	if (IS_ERR(paddc))
+		return PTR_ERR(paddc);
 
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		num_counters = compat_tmp.num_counters;
-		name = compat_tmp.name;
-	} else
-#endif
-	{
-		num_counters = tmp.num_counters;
-		name = tmp.name;
-	}
-
-	if (len != size + num_counters * sizeof(struct xt_counters))
-		return -EINVAL;
-
-	paddc = vmalloc(len - size);
-	if (!paddc)
-		return -ENOMEM;
-
-	if (copy_from_user(paddc, user + size, len - size) != 0) {
-		ret = -EFAULT;
-		goto free;
-	}
-
-	t = xt_find_table_lock(net, NFPROTO_ARP, name);
+	t = xt_find_table_lock(net, NFPROTO_ARP, tmp.name);
 	if (IS_ERR_OR_NULL(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
@@ -1168,7 +1122,7 @@ static int do_add_counters(struct net *net, const void __user *user,
 
 	local_bh_disable();
 	private = t->private;
-	if (private->number != num_counters) {
+	if (private->number != tmp.num_counters) {
 		ret = -EINVAL;
 		goto unlock_up_free;
 	}
@@ -1194,6 +1148,18 @@ static int do_add_counters(struct net *net, const void __user *user,
 }
 
 #ifdef CONFIG_COMPAT
+struct compat_arpt_replace {
+	char				name[XT_TABLE_MAXNAMELEN];
+	u32				valid_hooks;
+	u32				num_entries;
+	u32				size;
+	u32				hook_entry[NF_ARP_NUMHOOKS];
+	u32				underflow[NF_ARP_NUMHOOKS];
+	u32				num_counters;
+	compat_uptr_t			counters;
+	struct compat_arpt_entry	entries[0];
+};
+
 static inline void compat_release_entry(struct compat_arpt_entry *e)
 {
 	struct xt_entry_target *t;
@@ -1202,24 +1168,22 @@ static inline void compat_release_entry(struct compat_arpt_entry *e)
 	module_put(t->u.kernel.target->me);
 }
 
-static inline int
+static int
 check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
 				  struct xt_table_info *newinfo,
 				  unsigned int *size,
 				  const unsigned char *base,
-				  const unsigned char *limit,
-				  const unsigned int *hook_entries,
-				  const unsigned int *underflows,
-				  const char *name)
+				  const unsigned char *limit)
 {
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	unsigned int entry_offset;
-	int ret, off, h;
+	int ret, off;
 
 	duprintf("check_compat_entry_size_and_hooks %p\n", e);
 	if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf("Bad offset %p, limit = %p\n", e, limit);
 		return -EINVAL;
 	}
@@ -1231,8 +1195,11 @@ check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
 		return -EINVAL;
 	}
 
-	/* For purposes of check_entry casting the compat entry is fine */
-	ret = check_entry((struct arpt_entry *)e, name);
+	if (!arp_checkentry(&e->arp))
+		return -EINVAL;
+
+	ret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
+					    e->next_offset);
 	if (ret)
 		return ret;
 
@@ -1256,17 +1223,6 @@ check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
 	if (ret)
 		goto release_target;
 
-	/* Check hooks & underflows */
-	for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
-		if ((unsigned char *)e - base == hook_entries[h])
-			newinfo->hook_entry[h] = hook_entries[h];
-		if ((unsigned char *)e - base == underflows[h])
-			newinfo->underflow[h] = underflows[h];
-	}
-
-	/* Clear counters and comefrom */
-	memset(&e->counters, 0, sizeof(e->counters));
-	e->comefrom = 0;
 	return 0;
 
 release_target:
@@ -1275,18 +1231,17 @@ out:
 	return ret;
 }
 
-static int
+static void
 compat_copy_entry_from_user(struct compat_arpt_entry *e, void **dstptr,
-			    unsigned int *size, const char *name,
+			    unsigned int *size,
 			    struct xt_table_info *newinfo, unsigned char *base)
 {
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	struct arpt_entry *de;
 	unsigned int origsize;
-	int ret, h;
+	int h;
 
-	ret = 0;
 	origsize = *size;
 	de = (struct arpt_entry *)*dstptr;
 	memcpy(de, e, sizeof(struct arpt_entry));
@@ -1307,144 +1262,81 @@ compat_copy_entry_from_user(struct compat_arpt_entry *e, void **dstptr,
 		if ((unsigned char *)de - base < newinfo->underflow[h])
 			newinfo->underflow[h] -= origsize - *size;
 	}
-	return ret;
 }
 
-static int translate_compat_table(const char *name,
-				  unsigned int valid_hooks,
-				  struct xt_table_info **pinfo,
+static int translate_compat_table(struct xt_table_info **pinfo,
 				  void **pentry0,
-				  unsigned int total_size,
-				  unsigned int number,
-				  unsigned int *hook_entries,
-				  unsigned int *underflows)
+				  const struct compat_arpt_replace *compatr)
 {
 	unsigned int i, j;
 	struct xt_table_info *newinfo, *info;
 	void *pos, *entry0, *entry1;
 	struct compat_arpt_entry *iter0;
-	struct arpt_entry *iter1;
+	struct arpt_replace repl;
 	unsigned int size;
 	int ret = 0;
 
 	info = *pinfo;
 	entry0 = *pentry0;
-	size = total_size;
-	info->number = number;
-
-	/* Init all hooks to impossible value. */
-	for (i = 0; i < NF_ARP_NUMHOOKS; i++) {
-		info->hook_entry[i] = 0xFFFFFFFF;
-		info->underflow[i] = 0xFFFFFFFF;
-	}
+	size = compatr->size;
+	info->number = compatr->num_entries;
 
 	duprintf("translate_compat_table: size %u\n", info->size);
 	j = 0;
 	xt_compat_lock(NFPROTO_ARP);
-	xt_compat_init_offsets(NFPROTO_ARP, number);
+	xt_compat_init_offsets(NFPROTO_ARP, compatr->num_entries);
 	/* Walk through entries, checking offsets. */
-	xt_entry_foreach(iter0, entry0, total_size) {
+	xt_entry_foreach(iter0, entry0, compatr->size) {
 		ret = check_compat_entry_size_and_hooks(iter0, info, &size,
 							entry0,
-							entry0 + total_size,
-							hook_entries,
-							underflows,
-							name);
+							entry0 + compatr->size);
 		if (ret != 0)
 			goto out_unlock;
 		++j;
 	}
 
 	ret = -EINVAL;
-	if (j != number) {
+	if (j != compatr->num_entries) {
 		duprintf("translate_compat_table: %u not %u entries\n",
-			 j, number);
+			 j, compatr->num_entries);
 		goto out_unlock;
 	}
 
-	/* Check hooks all assigned */
-	for (i = 0; i < NF_ARP_NUMHOOKS; i++) {
-		/* Only hooks which are valid */
-		if (!(valid_hooks & (1 << i)))
-			continue;
-		if (info->hook_entry[i] == 0xFFFFFFFF) {
-			duprintf("Invalid hook entry %u %u\n",
-				 i, hook_entries[i]);
-			goto out_unlock;
-		}
-		if (info->underflow[i] == 0xFFFFFFFF) {
-			duprintf("Invalid underflow %u %u\n",
-				 i, underflows[i]);
-			goto out_unlock;
-		}
-	}
-
 	ret = -ENOMEM;
 	newinfo = xt_alloc_table_info(size);
 	if (!newinfo)
 		goto out_unlock;
 
-	newinfo->number = number;
+	newinfo->number = compatr->num_entries;
 	for (i = 0; i < NF_ARP_NUMHOOKS; i++) {
 		newinfo->hook_entry[i] = info->hook_entry[i];
 		newinfo->underflow[i] = info->underflow[i];
 	}
 	entry1 = newinfo->entries[raw_smp_processor_id()];
 	pos = entry1;
-	size = total_size;
-	xt_entry_foreach(iter0, entry0, total_size) {
-		ret = compat_copy_entry_from_user(iter0, &pos, &size,
-						  name, newinfo, entry1);
-		if (ret != 0)
-			break;
-	}
+	size = compatr->size;
+	xt_entry_foreach(iter0, entry0, compatr->size)
+		compat_copy_entry_from_user(iter0, &pos, &size,
+					    newinfo, entry1);
+
+	/* all module references in entry0 are now gone */
+
 	xt_compat_flush_offsets(NFPROTO_ARP);
 	xt_compat_unlock(NFPROTO_ARP);
-	if (ret)
-		goto free_newinfo;
 
-	ret = -ELOOP;
-	if (!mark_source_chains(newinfo, valid_hooks, entry1))
-		goto free_newinfo;
+	memcpy(&repl, compatr, sizeof(*compatr));
 
-	i = 0;
-	xt_entry_foreach(iter1, entry1, newinfo->size) {
-		ret = check_target(iter1, name);
-		if (ret != 0)
-			break;
-		++i;
-		if (strcmp(arpt_get_target(iter1)->u.user.name,
-		    XT_ERROR_TARGET) == 0)
-			++newinfo->stacksize;
-	}
-	if (ret) {
-		/*
-		 * The first i matches need cleanup_entry (calls ->destroy)
-		 * because they had called ->check already. The other j-i
-		 * entries need only release.
-		 */
-		int skip = i;
-		j -= i;
-		xt_entry_foreach(iter0, entry0, newinfo->size) {
-			if (skip-- > 0)
-				continue;
-			if (j-- == 0)
-				break;
-			compat_release_entry(iter0);
-		}
-		xt_entry_foreach(iter1, entry1, newinfo->size) {
-			if (i-- == 0)
-				break;
-			cleanup_entry(iter1);
-		}
-		xt_free_table_info(newinfo);
-		return ret;
+	for (i = 0; i < NF_ARP_NUMHOOKS; i++) {
+		repl.hook_entry[i] = newinfo->hook_entry[i];
+		repl.underflow[i] = newinfo->underflow[i];
 	}
 
-	/* And one copy for every other CPU */
-	for_each_possible_cpu(i)
-		if (newinfo->entries[i] && newinfo->entries[i] != entry1)
-			memcpy(newinfo->entries[i], entry1, newinfo->size);
+	repl.num_counters = 0;
+	repl.counters = NULL;
+	repl.size = newinfo->size;
+	ret = translate_table(newinfo, entry1, &repl);
+	if (ret)
+		goto free_newinfo;
 
 	*pinfo = newinfo;
 	*pentry0 = entry1;
@@ -1453,31 +1345,18 @@ static int translate_compat_table(const char *name,
 
 free_newinfo:
 	xt_free_table_info(newinfo);
-out:
-	xt_entry_foreach(iter0, entry0, total_size) {
+	return ret;
+out_unlock:
+	xt_compat_flush_offsets(NFPROTO_ARP);
+	xt_compat_unlock(NFPROTO_ARP);
+	xt_entry_foreach(iter0, entry0, compatr->size) {
 		if (j-- == 0)
 			break;
 		compat_release_entry(iter0);
 	}
 	return ret;
-out_unlock:
-	xt_compat_flush_offsets(NFPROTO_ARP);
-	xt_compat_unlock(NFPROTO_ARP);
-	goto out;
 }
 
-struct compat_arpt_replace {
-	char				name[XT_TABLE_MAXNAMELEN];
-	u32				valid_hooks;
-	u32				num_entries;
-	u32				size;
-	u32				hook_entry[NF_ARP_NUMHOOKS];
-	u32				underflow[NF_ARP_NUMHOOKS];
-	u32				num_counters;
-	compat_uptr_t			counters;
-	struct compat_arpt_entry	entries[0];
-};
-
 static int compat_do_replace(struct net *net, void __user *user,
 			     unsigned int len)
 {
@@ -1495,6 +1374,9 @@ static int compat_do_replace(struct net *net, void __user *user,
 		return -ENOMEM;
 	if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
+	if (tmp.num_counters == 0)
+		return -EINVAL;
+
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
@@ -1508,10 +1390,7 @@ static int compat_do_replace(struct net *net, void __user *user,
 		goto free_newinfo;
 	}
 
-	ret = translate_compat_table(tmp.name, tmp.valid_hooks,
-				     &newinfo, &loc_cpu_entry, tmp.size,
-				     tmp.num_entries, tmp.hook_entry,
-				     tmp.underflow);
+	ret = translate_compat_table(&newinfo, &loc_cpu_entry, &tmp);
 	if (ret != 0)
 		goto free_newinfo;
 
diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
index 651c107..92c8f27 100644
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@ -168,11 +168,12 @@ get_entry(const void *base, unsigned int offset)
 
 /* All zeroes == unconditional rule. */
 /* Mildly perf critical (only if packet tracing is on) */
-static inline bool unconditional(const struct ipt_ip *ip)
+static inline bool unconditional(const struct ipt_entry *e)
 {
 	static const struct ipt_ip uncond;
 
-	return memcmp(ip, &uncond, sizeof(uncond)) == 0;
+	return e->target_offset == sizeof(struct ipt_entry) &&
+	       memcmp(&e->ip, &uncond, sizeof(uncond)) == 0;
 #undef FWINV
 }
 
@@ -229,11 +230,10 @@ get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,
 	} else if (s == e) {
 		(*rulenum)++;
 
-		if (s->target_offset == sizeof(struct ipt_entry) &&
+		if (unconditional(s) &&
 		    strcmp(t->target.u.kernel.target->name,
 			   XT_STANDARD_TARGET) == 0 &&
-		   t->verdict < 0 &&
-		   unconditional(&s->ip)) {
+		   t->verdict < 0) {
 			/* Tail of chains: STANDARD target (return/policy) */
 			*comment = *chainname == hookname
 				? comments[NF_IP_TRACE_COMMENT_POLICY]
@@ -467,11 +467,10 @@ mark_source_chains(const struct xt_table_info *newinfo,
 			e->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));
 
 			/* Unconditional return/END. */
-			if ((e->target_offset == sizeof(struct ipt_entry) &&
+			if ((unconditional(e) &&
 			     (strcmp(t->target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &&
-			     t->verdict < 0 && unconditional(&e->ip)) ||
-			    visited) {
+			     t->verdict < 0) || visited) {
 				unsigned int oldpos, size;
 
 				if ((strcmp(t->target.u.user.name,
@@ -512,6 +511,8 @@ mark_source_chains(const struct xt_table_info *newinfo,
 				size = e->next_offset;
 				e = (struct ipt_entry *)
 					(entry0 + pos + size);
+				if (pos + size >= newinfo->size)
+					return 0;
 				e->counters.pcnt = pos;
 				pos += size;
 			} else {
@@ -533,6 +534,8 @@ mark_source_chains(const struct xt_table_info *newinfo,
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e->next_offset;
+					if (newpos >= newinfo->size)
+						return 0;
 				}
 				e = (struct ipt_entry *)
 					(entry0 + newpos);
@@ -560,27 +563,6 @@ static void cleanup_match(struct xt_entry_match *m, struct net *net)
 }
 
 static int
-check_entry(const struct ipt_entry *e, const char *name)
-{
-	const struct xt_entry_target *t;
-
-	if (!ip_checkentry(&e->ip)) {
-		duprintf("ip check failed %p %s.\n", e, name);
-		return -EINVAL;
-	}
-
-	if (e->target_offset + sizeof(struct xt_entry_target) >
-	    e->next_offset)
-		return -EINVAL;
-
-	t = ipt_get_target_c(e);
-	if (e->target_offset + t->u.target_size > e->next_offset)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int
 check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)
 {
 	const struct ipt_ip *ip = par->entryinfo;
@@ -657,10 +639,6 @@ find_check_entry(struct ipt_entry *e, struct net *net, const char *name,
 	struct xt_mtchk_param mtpar;
 	struct xt_entry_match *ematch;
 
-	ret = check_entry(e, name);
-	if (ret)
-		return ret;
-
 	j = 0;
 	mtpar.net	= net;
 	mtpar.table     = name;
@@ -704,7 +682,7 @@ static bool check_underflow(const struct ipt_entry *e)
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
-	if (!unconditional(&e->ip))
+	if (!unconditional(e))
 		return false;
 	t = ipt_get_target_c(e);
 	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
@@ -724,9 +702,11 @@ check_entry_size_and_hooks(struct ipt_entry *e,
 			   unsigned int valid_hooks)
 {
 	unsigned int h;
+	int err;
 
 	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf("Bad offset %p\n", e);
 		return -EINVAL;
 	}
@@ -738,6 +718,14 @@ check_entry_size_and_hooks(struct ipt_entry *e,
 		return -EINVAL;
 	}
 
+	if (!ip_checkentry(&e->ip))
+		return -EINVAL;
+
+	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
+				     e->next_offset);
+	if (err)
+		return err;
+
 	/* Check hooks & underflows */
 	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
 		if (!(valid_hooks & (1 << h)))
@@ -746,9 +734,9 @@ check_entry_size_and_hooks(struct ipt_entry *e,
 			newinfo->hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e - base == underflows[h]) {
 			if (!check_underflow(e)) {
-				pr_err("Underflows must be unconditional and "
-				       "use the STANDARD target with "
-				       "ACCEPT/DROP\n");
+				pr_debug("Underflows must be unconditional and "
+					 "use the STANDARD target with "
+					 "ACCEPT/DROP\n");
 				return -EINVAL;
 			}
 			newinfo->underflow[h] = underflows[h];
@@ -1258,6 +1246,9 @@ do_replace(struct net *net, const void __user *user, unsigned int len)
 	/* overflow check */
 	if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
+	if (tmp.num_counters == 0)
+		return -EINVAL;
+
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
@@ -1299,56 +1290,18 @@ do_add_counters(struct net *net, const void __user *user,
 	unsigned int i, curcpu;
 	struct xt_counters_info tmp;
 	struct xt_counters *paddc;
-	unsigned int num_counters;
-	const char *name;
-	int size;
-	void *ptmp;
 	struct xt_table *t;
 	const struct xt_table_info *private;
 	int ret = 0;
 	void *loc_cpu_entry;
 	struct ipt_entry *iter;
 	unsigned int addend;
-#ifdef CONFIG_COMPAT
-	struct compat_xt_counters_info compat_tmp;
-
-	if (compat) {
-		ptmp = &compat_tmp;
-		size = sizeof(struct compat_xt_counters_info);
-	} else
-#endif
-	{
-		ptmp = &tmp;
-		size = sizeof(struct xt_counters_info);
-	}
-
-	if (copy_from_user(ptmp, user, size) != 0)
-		return -EFAULT;
-
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		num_counters = compat_tmp.num_counters;
-		name = compat_tmp.name;
-	} else
-#endif
-	{
-		num_counters = tmp.num_counters;
-		name = tmp.name;
-	}
 
-	if (len != size + num_counters * sizeof(struct xt_counters))
-		return -EINVAL;
-
-	paddc = vmalloc(len - size);
-	if (!paddc)
-		return -ENOMEM;
-
-	if (copy_from_user(paddc, user + size, len - size) != 0) {
-		ret = -EFAULT;
-		goto free;
-	}
+	paddc = xt_copy_counters_from_user(user, len, &tmp, compat);
+	if (IS_ERR(paddc))
+		return PTR_ERR(paddc);
 
-	t = xt_find_table_lock(net, AF_INET, name);
+	t = xt_find_table_lock(net, AF_INET, tmp.name);
 	if (IS_ERR_OR_NULL(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
@@ -1356,7 +1309,7 @@ do_add_counters(struct net *net, const void __user *user,
 
 	local_bh_disable();
 	private = t->private;
-	if (private->number != num_counters) {
+	if (private->number != tmp.num_counters) {
 		ret = -EINVAL;
 		goto unlock_up_free;
 	}
@@ -1435,7 +1388,6 @@ compat_copy_entry_to_user(struct ipt_entry *e, void __user **dstptr,
 
 static int
 compat_find_calc_match(struct xt_entry_match *m,
-		       const char *name,
 		       const struct ipt_ip *ip,
 		       unsigned int hookmask,
 		       int *size)
@@ -1471,21 +1423,19 @@ check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,
 				  struct xt_table_info *newinfo,
 				  unsigned int *size,
 				  const unsigned char *base,
-				  const unsigned char *limit,
-				  const unsigned int *hook_entries,
-				  const unsigned int *underflows,
-				  const char *name)
+				  const unsigned char *limit)
 {
 	struct xt_entry_match *ematch;
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	unsigned int entry_offset;
 	unsigned int j;
-	int ret, off, h;
+	int ret, off;
 
 	duprintf("check_compat_entry_size_and_hooks %p\n", e);
 	if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf("Bad offset %p, limit = %p\n", e, limit);
 		return -EINVAL;
 	}
@@ -1497,8 +1447,11 @@ check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,
 		return -EINVAL;
 	}
 
-	/* For purposes of check_entry casting the compat entry is fine */
-	ret = check_entry((struct ipt_entry *)e, name);
+	if (!ip_checkentry(&e->ip))
+		return -EINVAL;
+
+	ret = xt_compat_check_entry_offsets(e, e->elems,
+					    e->target_offset, e->next_offset);
 	if (ret)
 		return ret;
 
@@ -1506,8 +1459,8 @@ check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,
 	entry_offset = (void *)e - (void *)base;
 	j = 0;
 	xt_ematch_foreach(ematch, e) {
-		ret = compat_find_calc_match(ematch, name,
-					     &e->ip, e->comefrom, &off);
+		ret = compat_find_calc_match(ematch, &e->ip, e->comefrom,
+					     &off);
 		if (ret != 0)
 			goto release_matches;
 		++j;
@@ -1530,17 +1483,6 @@ check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,
 	if (ret)
 		goto out;
 
-	/* Check hooks & underflows */
-	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
-		if ((unsigned char *)e - base == hook_entries[h])
-			newinfo->hook_entry[h] = hook_entries[h];
-		if ((unsigned char *)e - base == underflows[h])
-			newinfo->underflow[h] = underflows[h];
-	}
-
-	/* Clear counters and comefrom */
-	memset(&e->counters, 0, sizeof(e->counters));
-	e->comefrom = 0;
 	return 0;
 
 out:
@@ -1554,19 +1496,18 @@ release_matches:
 	return ret;
 }
 
-static int
+static void
 compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr,
-			    unsigned int *size, const char *name,
+			    unsigned int *size,
 			    struct xt_table_info *newinfo, unsigned char *base)
 {
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	struct ipt_entry *de;
 	unsigned int origsize;
-	int ret, h;
+	int h;
 	struct xt_entry_match *ematch;
 
-	ret = 0;
 	origsize = *size;
 	de = (struct ipt_entry *)*dstptr;
 	memcpy(de, e, sizeof(struct ipt_entry));
@@ -1575,198 +1516,104 @@ compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr,
 	*dstptr += sizeof(struct ipt_entry);
 	*size += sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
 
-	xt_ematch_foreach(ematch, e) {
-		ret = xt_compat_match_from_user(ematch, dstptr, size);
-		if (ret != 0)
-			return ret;
-	}
+	xt_ematch_foreach(ematch, e)
+		xt_compat_match_from_user(ematch, dstptr, size);
+
 	de->target_offset = e->target_offset - (origsize - *size);
 	t = compat_ipt_get_target(e);
 	target = t->u.kernel.target;
 	xt_compat_target_from_user(t, dstptr, size);
 
 	de->next_offset = e->next_offset - (origsize - *size);
+
 	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
 		if ((unsigned char *)de - base < newinfo->hook_entry[h])
 			newinfo->hook_entry[h] -= origsize - *size;
 		if ((unsigned char *)de - base < newinfo->underflow[h])
 			newinfo->underflow[h] -= origsize - *size;
 	}
-	return ret;
-}
-
-static int
-compat_check_entry(struct ipt_entry *e, struct net *net, const char *name)
-{
-	struct xt_entry_match *ematch;
-	struct xt_mtchk_param mtpar;
-	unsigned int j;
-	int ret = 0;
-
-	j = 0;
-	mtpar.net	= net;
-	mtpar.table     = name;
-	mtpar.entryinfo = &e->ip;
-	mtpar.hook_mask = e->comefrom;
-	mtpar.family    = NFPROTO_IPV4;
-	xt_ematch_foreach(ematch, e) {
-		ret = check_match(ematch, &mtpar);
-		if (ret != 0)
-			goto cleanup_matches;
-		++j;
-	}
-
-	ret = check_target(e, net, name);
-	if (ret)
-		goto cleanup_matches;
-	return 0;
-
- cleanup_matches:
-	xt_ematch_foreach(ematch, e) {
-		if (j-- == 0)
-			break;
-		cleanup_match(ematch, net);
-	}
-	return ret;
 }
 
 static int
 translate_compat_table(struct net *net,
-		       const char *name,
-		       unsigned int valid_hooks,
 		       struct xt_table_info **pinfo,
 		       void **pentry0,
-		       unsigned int total_size,
-		       unsigned int number,
-		       unsigned int *hook_entries,
-		       unsigned int *underflows)
+		       const struct compat_ipt_replace *compatr)
 {
 	unsigned int i, j;
 	struct xt_table_info *newinfo, *info;
 	void *pos, *entry0, *entry1;
 	struct compat_ipt_entry *iter0;
-	struct ipt_entry *iter1;
+	struct ipt_replace repl;
 	unsigned int size;
 	int ret;
 
 	info = *pinfo;
 	entry0 = *pentry0;
-	size = total_size;
-	info->number = number;
-
-	/* Init all hooks to impossible value. */
-	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
-		info->hook_entry[i] = 0xFFFFFFFF;
-		info->underflow[i] = 0xFFFFFFFF;
-	}
+	size = compatr->size;
+	info->number = compatr->num_entries;
 
 	duprintf("translate_compat_table: size %u\n", info->size);
 	j = 0;
 	xt_compat_lock(AF_INET);
-	xt_compat_init_offsets(AF_INET, number);
+	xt_compat_init_offsets(AF_INET, compatr->num_entries);
 	/* Walk through entries, checking offsets. */
-	xt_entry_foreach(iter0, entry0, total_size) {
+	xt_entry_foreach(iter0, entry0, compatr->size) {
 		ret = check_compat_entry_size_and_hooks(iter0, info, &size,
 							entry0,
-							entry0 + total_size,
-							hook_entries,
-							underflows,
-							name);
+							entry0 + compatr->size);
 		if (ret != 0)
 			goto out_unlock;
 		++j;
 	}
 
 	ret = -EINVAL;
-	if (j != number) {
+	if (j != compatr->num_entries) {
 		duprintf("translate_compat_table: %u not %u entries\n",
-			 j, number);
+			 j, compatr->num_entries);
 		goto out_unlock;
 	}
 
-	/* Check hooks all assigned */
-	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
-		/* Only hooks which are valid */
-		if (!(valid_hooks & (1 << i)))
-			continue;
-		if (info->hook_entry[i] == 0xFFFFFFFF) {
-			duprintf("Invalid hook entry %u %u\n",
-				 i, hook_entries[i]);
-			goto out_unlock;
-		}
-		if (info->underflow[i] == 0xFFFFFFFF) {
-			duprintf("Invalid underflow %u %u\n",
-				 i, underflows[i]);
-			goto out_unlock;
-		}
-	}
-
 	ret = -ENOMEM;
 	newinfo = xt_alloc_table_info(size);
 	if (!newinfo)
 		goto out_unlock;
 
-	newinfo->number = number;
+	newinfo->number = compatr->num_entries;
 	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
-		newinfo->hook_entry[i] = info->hook_entry[i];
-		newinfo->underflow[i] = info->underflow[i];
+		newinfo->hook_entry[i] = compatr->hook_entry[i];
+		newinfo->underflow[i] = compatr->underflow[i];
 	}
 	entry1 = newinfo->entries[raw_smp_processor_id()];
 	pos = entry1;
-	size = total_size;
-	xt_entry_foreach(iter0, entry0, total_size) {
-		ret = compat_copy_entry_from_user(iter0, &pos, &size,
-						  name, newinfo, entry1);
-		if (ret != 0)
-			break;
-	}
+	size = compatr->size;
+	xt_entry_foreach(iter0, entry0, compatr->size)
+		compat_copy_entry_from_user(iter0, &pos, &size,
+					    newinfo, entry1);
+
+	/* all module references in entry0 are now gone.
+	 * entry1/newinfo contains a 64bit ruleset that looks exactly as
+	 * generated by 64bit userspace.
+	 *
+	 * Call standard translate_table() to validate all hook_entrys,
+	 * underflows, check for loops, etc.
+	 */
 	xt_compat_flush_offsets(AF_INET);
 	xt_compat_unlock(AF_INET);
-	if (ret)
-		goto free_newinfo;
 
-	ret = -ELOOP;
-	if (!mark_source_chains(newinfo, valid_hooks, entry1))
-		goto free_newinfo;
+	memcpy(&repl, compatr, sizeof(*compatr));
 
-	i = 0;
-	xt_entry_foreach(iter1, entry1, newinfo->size) {
-		ret = compat_check_entry(iter1, net, name);
-		if (ret != 0)
-			break;
-		++i;
-		if (strcmp(ipt_get_target(iter1)->u.user.name,
-		    XT_ERROR_TARGET) == 0)
-			++newinfo->stacksize;
-	}
-	if (ret) {
-		/*
-		 * The first i matches need cleanup_entry (calls ->destroy)
-		 * because they had called ->check already. The other j-i
-		 * entries need only release.
-		 */
-		int skip = i;
-		j -= i;
-		xt_entry_foreach(iter0, entry0, newinfo->size) {
-			if (skip-- > 0)
-				continue;
-			if (j-- == 0)
-				break;
-			compat_release_entry(iter0);
-		}
-		xt_entry_foreach(iter1, entry1, newinfo->size) {
-			if (i-- == 0)
-				break;
-			cleanup_entry(iter1, net);
-		}
-		xt_free_table_info(newinfo);
-		return ret;
+	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
+		repl.hook_entry[i] = newinfo->hook_entry[i];
+		repl.underflow[i] = newinfo->underflow[i];
 	}
 
-	/* And one copy for every other CPU */
-	for_each_possible_cpu(i)
-		if (newinfo->entries[i] && newinfo->entries[i] != entry1)
-			memcpy(newinfo->entries[i], entry1, newinfo->size);
+	repl.num_counters = 0;
+	repl.counters = NULL;
+	repl.size = newinfo->size;
+	ret = translate_table(net, newinfo, entry1, &repl);
+	if (ret)
+		goto free_newinfo;
 
 	*pinfo = newinfo;
 	*pentry0 = entry1;
@@ -1775,17 +1622,16 @@ translate_compat_table(struct net *net,
 
 free_newinfo:
 	xt_free_table_info(newinfo);
-out:
-	xt_entry_foreach(iter0, entry0, total_size) {
+	return ret;
+out_unlock:
+	xt_compat_flush_offsets(AF_INET);
+	xt_compat_unlock(AF_INET);
+	xt_entry_foreach(iter0, entry0, compatr->size) {
 		if (j-- == 0)
 			break;
 		compat_release_entry(iter0);
 	}
 	return ret;
-out_unlock:
-	xt_compat_flush_offsets(AF_INET);
-	xt_compat_unlock(AF_INET);
-	goto out;
 }
 
 static int
@@ -1805,6 +1651,9 @@ compat_do_replace(struct net *net, void __user *user, unsigned int len)
 		return -ENOMEM;
 	if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
+	if (tmp.num_counters == 0)
+		return -EINVAL;
+
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
@@ -1819,10 +1668,7 @@ compat_do_replace(struct net *net, void __user *user, unsigned int len)
 		goto free_newinfo;
 	}
 
-	ret = translate_compat_table(net, tmp.name, tmp.valid_hooks,
-				     &newinfo, &loc_cpu_entry, tmp.size,
-				     tmp.num_entries, tmp.hook_entry,
-				     tmp.underflow);
+	ret = translate_compat_table(net, &newinfo, &loc_cpu_entry, &tmp);
 	if (ret != 0)
 		goto free_newinfo;
 
diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c
index 698f3a2..459b957 100644
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@ -139,6 +139,7 @@ static void ping_v4_unhash(struct sock *sk)
 	if (sk_hashed(sk)) {
 		write_lock_bh(&ping_table.lock);
 		hlist_nulls_del(&sk->sk_nulls_node);
+		sk_nulls_node_init(&sk->sk_nulls_node);
 		sock_put(sk);
 		isk->inet_num = 0;
 		isk->inet_sport = 0;
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index e23c5f6..624ca8e 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -871,6 +871,10 @@ static int ip_error(struct sk_buff *skb)
 	bool send;
 	int code;
 
+	/* IP on this device is disabled. */
+	if (!in_dev)
+		goto out;
+
 	net = dev_net(rt->dst.dev);
 	if (!IN_DEV_FORWARD(in_dev)) {
 		switch (rt->dst.error) {
@@ -1872,6 +1876,18 @@ static struct rtable *__mkroute_output(const struct fib_result *res,
 		 */
 		if (fi && res->prefixlen < 4)
 			fi = NULL;
+	} else if ((type == RTN_LOCAL) && (orig_oif != 0) &&
+		   (orig_oif != dev_out->ifindex)) {
+		/* For local routes that require a particular output interface
+		 * we do not want to cache the result.  Caching the result
+		 * causes incorrect behaviour when there are multiple source
+		 * addresses on the interface, the end result being that if the
+		 * intended recipient is waiting on that interface for the
+		 * packet he won't receive it because it will be delivered on
+		 * the loopback interface and the IP_PKTINFO ipi_ifindex will
+		 * be set to the loopback interface as well.
+		 */
+		fi = NULL;
 	}
 
 	fnhe = NULL;
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 5d4bd6c..9e30385 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -302,6 +302,11 @@ EXPORT_SYMBOL(tcp_memory_allocated);
 struct percpu_counter tcp_sockets_allocated;
 EXPORT_SYMBOL(tcp_sockets_allocated);
 
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+struct sock_sequence_update ipv4_update = {0};
+EXPORT_SYMBOL(ipv4_update);
+#endif
+
 /*
  * TCP splice context
  */
@@ -532,6 +537,9 @@ int tcp_ioctl(struct sock *sk, int cmd, unsigned long arg)
 	struct tcp_sock *tp = tcp_sk(sk);
 	int answ;
 	bool slow;
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+	unsigned int sequence[3];
+#endif
 
 	switch (cmd) {
 	case SIOCINQ:
@@ -576,6 +584,20 @@ int tcp_ioctl(struct sock *sk, int cmd, unsigned long arg)
 		else
 			answ = tp->write_seq - tp->snd_nxt;
 		break;
+
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+	case SOCK_SEQ_UPDATE:
+		if (copy_from_user(sequence, (int __user *)arg, sizeof(sequence)))
+			return -EFAULT;
+
+
+		ipv4_update.sock = sk;
+		ipv4_update.ident = (u16)sequence[0];
+		ipv4_update.seq = sequence[1];
+		ipv4_update.ack = sequence[2];
+
+		return 0;
+#endif
 	default:
 		return -ENOIOCTLCMD;
 	}
@@ -584,6 +606,44 @@ int tcp_ioctl(struct sock *sk, int cmd, unsigned long arg)
 }
 EXPORT_SYMBOL(tcp_ioctl);
 
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+int tcphr_updatebywlan(struct sock *sk, struct tcphdr *th, struct sk_buff *skb)
+{
+	if (ipv4_update.sock != sk)
+		return 0;
+
+	if (ipv4_update.seq > 0){
+		ipv4_update.seq_offset = ipv4_update.seq - ntohl(th->seq);
+		ipv4_update.seq = 0;
+	}
+
+	if (ipv4_update.ack > 0){
+		ipv4_update.ack_offset = ipv4_update.ack - ntohl(th->ack_seq);
+		ipv4_update.ack = 0;
+	}
+
+	th->seq = htonl(ipv4_update.seq_offset + ntohl(th->seq));
+	th->ack_seq = htonl(ipv4_update.ack_offset + ntohl(th->ack_seq));
+
+	return 0;
+}
+
+EXPORT_SYMBOL(tcphr_updatebywlan);
+
+int iphdr_updatebywlan(struct sock *sk, struct iphdr *iph)
+{
+	if (ipv4_update.sock != sk)
+		return 0;
+
+	if (ipv4_update.ident > 0) {
+		iph->id = htons(ipv4_update.ident);
+		ipv4_update.ident = 0;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(iphdr_updatebywlan);
+#endif
+
 static inline void tcp_mark_push(struct tcp_sock *tp, struct sk_buff *skb)
 {
 	TCP_SKB_CB(skb)->tcp_flags |= TCPHDR_PSH;
diff --git a/net/ipv4/tcp_cubic.c b/net/ipv4/tcp_cubic.c
index 894b7ce..872b3a0 100644
--- a/net/ipv4/tcp_cubic.c
+++ b/net/ipv4/tcp_cubic.c
@@ -153,6 +153,27 @@ static void bictcp_init(struct sock *sk)
 		tcp_sk(sk)->snd_ssthresh = initial_ssthresh;
 }
 
+static void bictcp_cwnd_event(struct sock *sk, enum tcp_ca_event event)
+{
+	if (event == CA_EVENT_TX_START) {
+		struct bictcp *ca = inet_csk_ca(sk);
+		u32 now = tcp_time_stamp;
+		s32 delta;
+
+		delta = now - tcp_sk(sk)->lsndtime;
+
+		/* We were application limited (idle) for a while.
+		 * Shift epoch_start to keep cwnd growth to cubic curve.
+		 */
+		if (ca->epoch_start && delta > 0) {
+			ca->epoch_start += delta;
+			if (after(ca->epoch_start, now))
+				ca->epoch_start = now;
+		}
+		return;
+	}
+}
+
 /* calculate the cubic root of x using a table lookup followed by one
  * Newton-Raphson iteration.
  * Avg err ~= 0.195%
@@ -439,6 +460,7 @@ static struct tcp_congestion_ops cubictcp __read_mostly = {
 	.cong_avoid	= bictcp_cong_avoid,
 	.set_state	= bictcp_state,
 	.undo_cwnd	= bictcp_undo_cwnd,
+	.cwnd_event	= bictcp_cwnd_event,
 	.pkts_acked     = bictcp_acked,
 	.owner		= THIS_MODULE,
 	.name		= "cubic",
diff --git a/net/ipv4/tcp_illinois.c b/net/ipv4/tcp_illinois.c
index 834857f..86183c4 100644
--- a/net/ipv4/tcp_illinois.c
+++ b/net/ipv4/tcp_illinois.c
@@ -23,7 +23,6 @@
 #define ALPHA_MIN	((3*ALPHA_SCALE)/10)	/* ~0.3 */
 #define ALPHA_MAX	(10*ALPHA_SCALE)	/* 10.0 */
 #define ALPHA_BASE	ALPHA_SCALE		/* 1.0 */
-#define U32_MAX		((u32)~0U)
 #define RTT_MAX		(U32_MAX / ALPHA_MAX)	/* 3.3 secs */
 
 #define BETA_SHIFT	6
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index ea7f52f..d78de1b 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -68,6 +68,7 @@
 #include <linux/module.h>
 #include <linux/sysctl.h>
 #include <linux/kernel.h>
+#include <linux/reciprocal_div.h>
 #include <net/dst.h>
 #include <net/tcp.h>
 #include <net/inet_common.h>
@@ -75,6 +76,11 @@
 #include <asm/unaligned.h>
 #include <net/netdma.h>
 
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+extern struct sock_sequence_update ipv4_update;
+struct tcphdr th_copy;
+#endif
+
 int sysctl_tcp_timestamps __read_mostly = 1;
 int sysctl_tcp_window_scaling __read_mostly = 1;
 int sysctl_tcp_sack __read_mostly = 1;
@@ -87,7 +93,7 @@ int sysctl_tcp_adv_win_scale __read_mostly = 1;
 EXPORT_SYMBOL(sysctl_tcp_adv_win_scale);
 
 /* rfc5961 challenge ack rate limiting */
-int sysctl_tcp_challenge_ack_limit = 100;
+int sysctl_tcp_challenge_ack_limit = 1000;
 
 int sysctl_tcp_stdurg __read_mostly;
 int sysctl_tcp_rfc1337 __read_mostly;
@@ -3076,10 +3082,11 @@ static int tcp_clean_rtx_queue(struct sock *sk, int prior_fackets,
 			if (seq_rtt < 0) {
 				seq_rtt = ca_seq_rtt;
 			}
-			if (!(sacked & TCPCB_SACKED_ACKED))
+			if (!(sacked & TCPCB_SACKED_ACKED)) {
 				reord = min(pkts_acked, reord);
-			if (!after(scb->end_seq, tp->high_seq))
-				flag |= FLAG_ORIG_SACK_ACKED;
+				if (!after(scb->end_seq, tp->high_seq))
+					flag |= FLAG_ORIG_SACK_ACKED;
+			}
 		}
 
 		if (sacked & TCPCB_SACKED_ACKED)
@@ -3287,12 +3294,19 @@ static void tcp_send_challenge_ack(struct sock *sk)
 	static u32 challenge_timestamp;
 	static unsigned int challenge_count;
 	u32 now = jiffies / HZ;
+	u32 count;
 
 	if (now != challenge_timestamp) {
+		u32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;
+
 		challenge_timestamp = now;
-		challenge_count = 0;
+		ACCESS_ONCE(challenge_count) = half +
+				  reciprocal_divide(prandom_u32(),
+					sysctl_tcp_challenge_ack_limit);
 	}
-	if (++challenge_count <= sysctl_tcp_challenge_ack_limit) {
+	count = ACCESS_ONCE(challenge_count);
+	if (count > 0) {
+		ACCESS_ONCE(challenge_count) = count - 1;
 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
 		tcp_send_ack(sk);
 	}
@@ -5105,13 +5119,29 @@ discard:
  *	the rest is checked inline. Fast processing is turned on in
  *	tcp_data_queue when everything is OK.
  */
+
+#ifndef CONFIG_WLAN_UPDATE_SEQ
 int tcp_rcv_established(struct sock *sk, struct sk_buff *skb,
 			const struct tcphdr *th, unsigned int len)
+#else
+int tcp_rcv_established(struct sock *sk, struct sk_buff *skb,
+			const struct tcphdr *t, unsigned int len)
+#endif
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+	struct tcphdr *th = &th_copy;
+	memcpy(th, t, sizeof(struct tcphdr));
+	if (sk == ipv4_update.sock) {
+		th->seq -= ipv4_update.ack_offset;
+		th->ack_seq -= ipv4_update.seq_offset;
+	}
+#endif
+
 	if (unlikely(sk->sk_rx_dst == NULL))
 		inet_csk(sk)->icsk_af_ops->sk_rx_dst_set(sk, skb);
+
 	/*
 	 *	Header prediction.
 	 *	The code loosely follows the one in the famous
@@ -5574,6 +5604,7 @@ discard:
 		}
 
 		tp->rcv_nxt = TCP_SKB_CB(skb)->seq + 1;
+		tp->copied_seq = tp->rcv_nxt;
 		tp->rcv_wup = TCP_SKB_CB(skb)->seq + 1;
 
 		/* RFC1323: The window in SYN & SYN/ACK segments is
@@ -5629,14 +5660,28 @@ reset_and_undo:
  *	address independent.
  */
 
+#ifndef CONFIG_WLAN_UPDATE_SEQ
 int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 			  const struct tcphdr *th, unsigned int len)
+#else
+int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
+			  const struct tcphdr *t, unsigned int len)
+#endif
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct request_sock *req;
 	int queued = 0;
 
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+	struct tcphdr *th = &th_copy;
+	memcpy(th, t, sizeof(struct tcphdr));
+	if (sk == ipv4_update.sock) {
+		th->seq -= ipv4_update.ack_offset;
+		th->ack_seq -= ipv4_update.seq_offset;
+	}
+#endif
+
 	tp->rx_opt.saw_tstamp = 0;
 
 	switch (sk->sk_state) {
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index cce35e5..6c33acb 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -89,6 +89,9 @@ int sysctl_tcp_tw_reuse __read_mostly;
 int sysctl_tcp_low_latency __read_mostly;
 EXPORT_SYMBOL(sysctl_tcp_low_latency);
 
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+extern struct sock_sequence_update ipv4_update;
+#endif
 
 #ifdef CONFIG_TCP_MD5SIG
 static int tcp_v4_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,
@@ -1015,7 +1018,8 @@ int tcp_md5_do_add(struct sock *sk, const union tcp_md5_addr *addr,
 	}
 
 	md5sig = rcu_dereference_protected(tp->md5sig_info,
-					   sock_owned_by_user(sk));
+					   sock_owned_by_user(sk) ||
+					   lockdep_is_held(&sk->sk_lock.slock));
 	if (!md5sig) {
 		md5sig = kmalloc(sizeof(*md5sig), gfp);
 		if (!md5sig)
@@ -1901,7 +1905,7 @@ void tcp_v4_early_demux(struct sk_buff *skb)
 		skb->sk = sk;
 		skb->destructor = sock_edemux;
 		if (sk->sk_state != TCP_TIME_WAIT) {
-			struct dst_entry *dst = sk->sk_rx_dst;
+			struct dst_entry *dst = ACCESS_ONCE(sk->sk_rx_dst);
 
 			if (dst)
 				dst = dst_check(dst, 0);
@@ -2006,6 +2010,16 @@ int tcp_v4_rcv(struct sk_buff *skb)
 	if (!sk)
 		goto no_tcp_socket;
 
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+	if (ipv4_update.sock && sk == ipv4_update.sock){
+
+		TCP_SKB_CB(skb)->seq = ntohl(th->seq) - ipv4_update.ack_offset;
+		TCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +
+				skb->len - th->doff * 4);
+		TCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq) - ipv4_update.seq_offset;
+	}
+#endif
+
 process:
 	if (sk->sk_state == TCP_TIME_WAIT)
 		goto do_time_wait;
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 913dc4f..5eb597c 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -42,6 +42,10 @@
 #include <linux/gfp.h>
 #include <linux/module.h>
 
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+extern int tcphr_updatebywlan(struct sock *sk, struct tcphdr *th, struct sk_buff *skb);
+#endif
+
 /* People can turn this off for buggy TCP's found in printers etc. */
 int sysctl_tcp_retrans_collapse __read_mostly = 1;
 
@@ -222,7 +226,8 @@ void tcp_select_initial_window(int __space, __u32 mss,
 		/* Set window scaling on max possible window
 		 * See RFC1323 for an explanation of the limit to 14
 		 */
-		space = max_t(u32, sysctl_tcp_rmem[2], sysctl_rmem_max);
+		space = max_t(u32, space, sysctl_tcp_rmem[2]);
+		space = max_t(u32, space, sysctl_rmem_max);
 		space = min_t(u32, space, *window_clamp);
 		while (space > 65535 && (*rcv_wscale) < 14) {
 			space >>= 1;
@@ -908,6 +913,10 @@ static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,
 	th->dest		= inet->inet_dport;
 	th->seq			= htonl(tcb->seq);
 	th->ack_seq		= htonl(tp->rcv_nxt);
+
+#ifdef CONFIG_WLAN_UPDATE_SEQ
+	tcphr_updatebywlan(sk, th, skb);
+#endif
 	*(((__be16 *)th) + 6)	= htons(((tcp_header_size >> 2) << 12) |
 					tcb->tcp_flags);
 
@@ -2571,39 +2580,65 @@ begin_fwd:
 	}
 }
 
-/* Send a fin.  The caller locks the socket for us.  This cannot be
- * allowed to fail queueing a FIN frame under any circumstances.
+/* We allow to exceed memory limits for FIN packets to expedite
+ * connection tear down and (memory) recovery.
+ * Otherwise tcp_send_fin() could be tempted to either delay FIN
+ * or even be forced to close flow without any FIN.
+ */
+static void sk_forced_wmem_schedule(struct sock *sk, int size)
+{
+	int amt, status;
+
+	if (size <= sk->sk_forward_alloc)
+		return;
+	amt = sk_mem_pages(size);
+	sk->sk_forward_alloc += amt * SK_MEM_QUANTUM;
+	sk_memory_allocated_add(sk, amt, &status);
+}
+
+/* Send a FIN. The caller locks the socket for us.
+ * We should try to send a FIN packet really hard, but eventually give up.
  */
 void tcp_send_fin(struct sock *sk)
 {
+	struct sk_buff *skb, *tskb = tcp_write_queue_tail(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
-	struct sk_buff *skb = tcp_write_queue_tail(sk);
-	int mss_now;
 
-	/* Optimization, tack on the FIN if we have a queue of
-	 * unsent frames.  But be careful about outgoing SACKS
-	 * and IP options.
+	/* Optimization, tack on the FIN if we have one skb in write queue and
+	 * this skb was not yet sent, or we are under memory pressure.
+	 * Note: in the latter case, FIN packet will be sent after a timeout,
+	 * as TCP stack thinks it has already been transmitted.
 	 */
-	mss_now = tcp_current_mss(sk);
-
-	if (tcp_send_head(sk) != NULL) {
-		TCP_SKB_CB(skb)->tcp_flags |= TCPHDR_FIN;
-		TCP_SKB_CB(skb)->end_seq++;
+	if (tskb && (tcp_send_head(sk) || sk_under_memory_pressure(sk))) {
+coalesce:
+		TCP_SKB_CB(tskb)->tcp_flags |= TCPHDR_FIN;
+		TCP_SKB_CB(tskb)->end_seq++;
 		tp->write_seq++;
+		if (!tcp_send_head(sk)) {
+			/* This means tskb was already sent.
+			 * Pretend we included the FIN on previous transmit.
+			 * We need to set tp->snd_nxt to the value it would have
+			 * if FIN had been sent. This is because retransmit path
+			 * does not change tp->snd_nxt.
+			 */
+			tp->snd_nxt++;
+			return;
+		}
 	} else {
-		/* Socket is locked, keep trying until memory is available. */
-		for (;;) {
-			skb = sk_stream_alloc_skb(sk, 0, sk->sk_allocation);
-			if (skb)
-				break;
-			yield();
+		skb = alloc_skb_fclone(MAX_TCP_HEADER, sk->sk_allocation);
+		if (unlikely(!skb)) {
+			if (tskb)
+				goto coalesce;
+			return;
 		}
+		skb_reserve(skb, MAX_TCP_HEADER);
+		sk_forced_wmem_schedule(sk, skb->truesize);
 		/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */
 		tcp_init_nondata_skb(skb, tp->write_seq,
 				     TCPHDR_ACK | TCPHDR_FIN);
 		tcp_queue_skb(sk, skb);
 	}
-	__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_OFF);
+	__tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);
 }
 
 /* We get here when a process closes a file descriptor (either due to
@@ -2772,6 +2807,8 @@ struct sk_buff *tcp_make_synack(struct sock *sk, struct dst_entry *dst,
 	}
 #endif
 
+	/* Do not fool tcpdump (if any), clean our debris */
+	skb->tstamp.tv64 = 0;
 	return skb;
 }
 EXPORT_SYMBOL(tcp_make_synack);
@@ -2909,6 +2946,7 @@ static int tcp_send_syn_data(struct sock *sk, struct sk_buff *syn)
 		goto fallback;
 	syn_data->ip_summed = CHECKSUM_PARTIAL;
 	memcpy(syn_data->cb, syn->cb, sizeof(syn->cb));
+	skb_shinfo(syn_data)->gso_segs = 1;
 	if (unlikely(memcpy_fromiovecend(skb_put(syn_data, space),
 					 fo->data->msg_iov, 0, space))) {
 		kfree_skb(syn_data);
diff --git a/net/ipv4/tcp_yeah.c b/net/ipv4/tcp_yeah.c
index 05c3b6f..bf8321d 100644
--- a/net/ipv4/tcp_yeah.c
+++ b/net/ipv4/tcp_yeah.c
@@ -222,7 +222,7 @@ static u32 tcp_yeah_ssthresh(struct sock *sk) {
 	yeah->fast_count = 0;
 	yeah->reno_count = max(yeah->reno_count>>1, 2U);
 
-	return tp->snd_cwnd - reduction;
+	return max_t(int, tp->snd_cwnd - reduction, 2);
 }
 
 static struct tcp_congestion_ops tcp_yeah __read_mostly = {
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index c3075b5..68174e4 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1208,6 +1208,7 @@ int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
+	bool checksum_valid = false;
 	bool slow;
 
 	if (flags & MSG_ERRQUEUE)
@@ -1233,11 +1234,12 @@ try_again:
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
-		if (udp_lib_checksum_complete(skb))
+		checksum_valid = !udp_lib_checksum_complete(skb);
+		if (!checksum_valid)
 			goto csum_copy_err;
 	}
 
-	if (skb_csum_unnecessary(skb))
+	if (checksum_valid || skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),
 					      msg->msg_iov, copied);
 	else {
@@ -1293,10 +1295,8 @@ csum_copy_err:
 	}
 	unlock_sock_fast(sk, slow);
 
-	if (noblock)
-		return -EAGAIN;
-
-	/* starting over for a new packet */
+	/* starting over for a new packet, but check if we need to yield */
+	cond_resched();
 	msg->msg_flags &= ~MSG_TRUNC;
 	goto try_again;
 }
diff --git a/net/ipv4/xfrm4_policy.c b/net/ipv4/xfrm4_policy.c
index 9a459be..9b5b5dd 100644
--- a/net/ipv4/xfrm4_policy.c
+++ b/net/ipv4/xfrm4_policy.c
@@ -235,7 +235,7 @@ static struct dst_ops xfrm4_dst_ops = {
 	.destroy =		xfrm4_dst_destroy,
 	.ifdown =		xfrm4_dst_ifdown,
 	.local_out =		__ip_local_out,
-	.gc_thresh =		1024,
+	.gc_thresh =		32768,
 };
 
 static struct xfrm_policy_afinfo xfrm4_policy_afinfo = {
diff --git a/net/ipv6/addrlabel.c b/net/ipv6/addrlabel.c
index b30ad37..d5c9189 100644
--- a/net/ipv6/addrlabel.c
+++ b/net/ipv6/addrlabel.c
@@ -558,7 +558,7 @@ static int ip6addrlbl_get(struct sk_buff *in_skb, struct nlmsghdr* nlh)
 
 	rcu_read_lock();
 	p = __ipv6_addr_label(net, addr, ipv6_addr_type(addr), ifal->ifal_index);
-	if (p && ip6addrlbl_hold(p))
+	if (p && !ip6addrlbl_hold(p))
 		p = NULL;
 	lseq = ip6addrlbl_table.seq;
 	rcu_read_unlock();
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index ab5c7ad..a944f13 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -113,6 +113,9 @@ static int inet6_create(struct net *net, struct socket *sock, int protocol,
 	    !inet_ehash_secret)
 		build_ehash_secret();
 
+	if (protocol < 0 || protocol >= IPPROTO_MAX)
+		return -EINVAL;
+
 	/* Look for the requested type/protocol pair. */
 lookup_protocol:
 	err = -ESOCKTNOSUPPORT;
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index ce17d3d..b0d5d7e 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -40,7 +40,7 @@ static bool ipv6_mapped_addr_any(const struct in6_addr *a)
 	return ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);
 }
 
-int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
 	struct sockaddr_in6	*usin = (struct sockaddr_in6 *) uaddr;
 	struct inet_sock      	*inet = inet_sk(sk);
@@ -56,7 +56,7 @@ int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	if (usin->sin6_family == AF_INET) {
 		if (__ipv6_only_sock(sk))
 			return -EAFNOSUPPORT;
-		err = ip4_datagram_connect(sk, uaddr, addr_len);
+		err = __ip4_datagram_connect(sk, uaddr, addr_len);
 		goto ipv4_connected;
 	}
 
@@ -99,9 +99,9 @@ int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 		sin.sin_addr.s_addr = daddr->s6_addr32[3];
 		sin.sin_port = usin->sin6_port;
 
-		err = ip4_datagram_connect(sk,
-					   (struct sockaddr *) &sin,
-					   sizeof(sin));
+		err = __ip4_datagram_connect(sk,
+					     (struct sockaddr *) &sin,
+					     sizeof(sin));
 
 ipv4_connected:
 		if (err)
@@ -204,6 +204,16 @@ out:
 	fl6_sock_release(flowlabel);
 	return err;
 }
+
+int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+{
+	int res;
+
+	lock_sock(sk);
+	res = __ip6_datagram_connect(sk, uaddr, addr_len);
+	release_sock(sk);
+	return res;
+}
 EXPORT_SYMBOL_GPL(ip6_datagram_connect);
 
 void ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,
diff --git a/net/ipv6/exthdrs_core.c b/net/ipv6/exthdrs_core.c
index 51af9d0..f66c1b6 100644
--- a/net/ipv6/exthdrs_core.c
+++ b/net/ipv6/exthdrs_core.c
@@ -257,7 +257,11 @@ int ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
 						*fragoff = _frag_off;
 					return hp->nexthdr;
 				}
-				return -ENOENT;
+				if (!found)
+					return -ENOENT;
+				if (fragoff)
+					*fragoff = _frag_off;
+				break;
 			}
 			hdrlen = 8;
 		} else if (nexthdr == NEXTHDR_AUTH) {
diff --git a/net/ipv6/exthdrs_offload.c b/net/ipv6/exthdrs_offload.c
index 447a7fb..f5e2ba1 100644
--- a/net/ipv6/exthdrs_offload.c
+++ b/net/ipv6/exthdrs_offload.c
@@ -36,6 +36,6 @@ out:
 	return ret;
 
 out_rt:
-	inet_del_offload(&rthdr_offload, IPPROTO_ROUTING);
+	inet6_del_offload(&rthdr_offload, IPPROTO_ROUTING);
 	goto out;
 }
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index ceeb945..46458ee 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -1648,27 +1648,28 @@ static int fib6_age(struct rt6_info *rt, void *arg)
 
 static DEFINE_SPINLOCK(fib6_gc_lock);
 
-void fib6_run_gc(unsigned long expires, struct net *net)
+void fib6_run_gc(unsigned long expires, struct net *net, bool force)
 {
-	if (expires != ~0UL) {
+	unsigned long now;
+
+	if (force) {
 		spin_lock_bh(&fib6_gc_lock);
-		gc_args.timeout = expires ? (int)expires :
-			net->ipv6.sysctl.ip6_rt_gc_interval;
-	} else {
-		if (!spin_trylock_bh(&fib6_gc_lock)) {
-			mod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);
-			return;
-		}
-		gc_args.timeout = net->ipv6.sysctl.ip6_rt_gc_interval;
+	} else if (!spin_trylock_bh(&fib6_gc_lock)) {
+		mod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);
+		return;
 	}
+	gc_args.timeout = expires ? (int)expires :
+			  net->ipv6.sysctl.ip6_rt_gc_interval;
 
 	gc_args.more = icmp6_dst_gc();
 
 	fib6_clean_all(net, fib6_age, 0, NULL);
+	now = jiffies;
+	net->ipv6.ip6_rt_last_gc = now;
 
 	if (gc_args.more)
 		mod_timer(&net->ipv6.ip6_fib_timer,
-			  round_jiffies(jiffies
+			  round_jiffies(now
 					+ net->ipv6.sysctl.ip6_rt_gc_interval));
 	else
 		del_timer(&net->ipv6.ip6_fib_timer);
@@ -1677,7 +1678,7 @@ void fib6_run_gc(unsigned long expires, struct net *net)
 
 static void fib6_gc_timer_cb(unsigned long arg)
 {
-	fib6_run_gc(0, (struct net *)arg);
+	fib6_run_gc(0, (struct net *)arg, true);
 }
 
 static int __net_init fib6_net_init(struct net *net)
diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c
index 65156a7..7eb7267 100644
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@ -359,6 +359,7 @@ static void ip6gre_tunnel_uninit(struct net_device *dev)
 	struct ip6gre_net *ign = net_generic(net, ip6gre_net_id);
 
 	ip6gre_tunnel_unlink(ign, netdev_priv(dev));
+	ip6_tnl_dst_reset(netdev_priv(dev));
 	dev_put(dev);
 }
 
@@ -1540,13 +1541,11 @@ static int ip6gre_changelink(struct net_device *dev, struct nlattr *tb[],
 			return -EEXIST;
 	} else {
 		t = nt;
-
-		ip6gre_tunnel_unlink(ign, t);
-		ip6gre_tnl_change(t, &p, !tb[IFLA_MTU]);
-		ip6gre_tunnel_link(ign, t);
-		netdev_state_change(dev);
 	}
 
+	ip6gre_tunnel_unlink(ign, t);
+	ip6gre_tnl_change(t, &p, !tb[IFLA_MTU]);
+	ip6gre_tunnel_link(ign, t);
 	return 0;
 }
 
diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c
index 774b09c..63264c9 100644
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -325,10 +325,10 @@ int ip6_mc_input(struct sk_buff *skb)
 				if (offset < 0)
 					goto out;
 
-				if (!ipv6_is_mld(skb, nexthdr, offset))
-					goto out;
+				if (ipv6_is_mld(skb, nexthdr, offset))
+					deliver = true;
 
-				deliver = true;
+				goto out;
 			}
 			/* unknown RA - process it normally */
 		}
diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c
index 14f46af..31bab1a 100644
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -266,12 +266,12 @@ static int ip6_tnl_create2(struct net_device *dev)
 
 	t = netdev_priv(dev);
 
+	dev->rtnl_link_ops = &ip6_link_ops;
 	err = register_netdevice(dev);
 	if (err < 0)
 		goto out;
 
 	strcpy(t->parms.name, dev->name);
-	dev->rtnl_link_ops = &ip6_link_ops;
 
 	dev_hold(dev);
 	ip6_tnl_link(ip6n, t);
diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c
index 2c84072..107f7528 100644
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -120,7 +120,7 @@ static void mr6_netlink_event(struct mr6_table *mrt, struct mfc6_cache *mfc,
 			      int cmd);
 static int ip6mr_rtm_dumproute(struct sk_buff *skb,
 			       struct netlink_callback *cb);
-static void mroute_clean_tables(struct mr6_table *mrt);
+static void mroute_clean_tables(struct mr6_table *mrt, bool all);
 static void ipmr_expire_process(unsigned long arg);
 
 #ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES
@@ -336,8 +336,8 @@ static struct mr6_table *ip6mr_new_table(struct net *net, u32 id)
 
 static void ip6mr_free_table(struct mr6_table *mrt)
 {
-	del_timer(&mrt->ipmr_expire_timer);
-	mroute_clean_tables(mrt);
+	del_timer_sync(&mrt->ipmr_expire_timer);
+	mroute_clean_tables(mrt, true);
 	kfree(mrt);
 }
 
@@ -552,7 +552,7 @@ static void ipmr_mfc_seq_stop(struct seq_file *seq, void *v)
 
 	if (it->cache == &mrt->mfc6_unres_queue)
 		spin_unlock_bh(&mfc_unres_lock);
-	else if (it->cache == mrt->mfc6_cache_array)
+	else if (it->cache == &mrt->mfc6_cache_array[it->ct])
 		read_unlock(&mrt_lock);
 }
 
@@ -1077,6 +1077,7 @@ static struct mfc6_cache *ip6mr_cache_alloc(void)
 	struct mfc6_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_KERNEL);
 	if (c == NULL)
 		return NULL;
+	c->mfc_un.res.last_assert = jiffies - MFC_ASSERT_THRESH - 1;
 	c->mfc_un.res.minvif = MAXMIFS;
 	return c;
 }
@@ -1537,7 +1538,7 @@ static int ip6mr_mfc_add(struct net *net, struct mr6_table *mrt,
  *	Close the multicast socket, and clear the vif tables etc
  */
 
-static void mroute_clean_tables(struct mr6_table *mrt)
+static void mroute_clean_tables(struct mr6_table *mrt, bool all)
 {
 	int i;
 	LIST_HEAD(list);
@@ -1547,8 +1548,9 @@ static void mroute_clean_tables(struct mr6_table *mrt)
 	 *	Shut down all active vif entries
 	 */
 	for (i = 0; i < mrt->maxvif; i++) {
-		if (!(mrt->vif6_table[i].flags & VIFF_STATIC))
-			mif6_delete(mrt, i, &list);
+		if (!all && (mrt->vif6_table[i].flags & VIFF_STATIC))
+			continue;
+		mif6_delete(mrt, i, &list);
 	}
 	unregister_netdevice_many(&list);
 
@@ -1557,7 +1559,7 @@ static void mroute_clean_tables(struct mr6_table *mrt)
 	 */
 	for (i = 0; i < MFC6_LINES; i++) {
 		list_for_each_entry_safe(c, next, &mrt->mfc6_cache_array[i], list) {
-			if (c->mfc_flags & MFC_STATIC)
+			if (!all && (c->mfc_flags & MFC_STATIC))
 				continue;
 			write_lock_bh(&mrt_lock);
 			list_del(&c->list);
@@ -1620,7 +1622,7 @@ int ip6mr_sk_done(struct sock *sk)
 						     net->ipv6.devconf_all);
 			write_unlock_bh(&mrt_lock);
 
-			mroute_clean_tables(mrt);
+			mroute_clean_tables(mrt, false);
 			err = 0;
 			break;
 		}
diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c
index 734aec0..7ba6180 100644
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -1441,7 +1441,6 @@ out:
 	if (!err) {
 		ICMP6MSGOUT_INC_STATS(net, idev, ICMPV6_MLD2_REPORT);
 		ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);
-		IP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUTMCAST, payload_len);
 	} else {
 		IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);
 	}
@@ -1805,7 +1804,6 @@ out:
 	if (!err) {
 		ICMP6MSGOUT_INC_STATS(net, idev, type);
 		ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);
-		IP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUTMCAST, full_len);
 	} else
 		IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);
 
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index 060a044..deedf7d 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -1193,7 +1193,14 @@ static void ndisc_router_discovery(struct sk_buff *skb)
 	if (rt)
 		rt6_set_expires(rt, jiffies + (HZ * lifetime));
 	if (ra_msg->icmph.icmp6_hop_limit) {
-		in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
+		/* Only set hop_limit on the interface if it is higher than
+		 * the current hop_limit.
+		 */
+		if (in6_dev->cnf.hop_limit < ra_msg->icmph.icmp6_hop_limit) {
+			in6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;
+		} else {
+			ND_PRINTK(2, warn, "RA: Got route advertisement with lower hop_limit than current\n");
+		}
 		if (rt)
 			dst_metric_set(&rt->dst, RTAX_HOPLIMIT,
 				       ra_msg->icmph.icmp6_hop_limit);
@@ -1577,7 +1584,7 @@ static int ndisc_netdev_event(struct notifier_block *this, unsigned long event,
 	switch (event) {
 	case NETDEV_CHANGEADDR:
 		neigh_changeaddr(&nd_tbl, dev);
-		fib6_run_gc(~0UL, net);
+		fib6_run_gc(0, net, false);
 		idev = in6_dev_get(dev);
 		if (!idev)
 			break;
@@ -1587,7 +1594,7 @@ static int ndisc_netdev_event(struct notifier_block *this, unsigned long event,
 		break;
 	case NETDEV_DOWN:
 		neigh_ifdown(&nd_tbl, dev);
-		fib6_run_gc(~0UL, net);
+		fib6_run_gc(0, net, false);
 		break;
 	case NETDEV_NOTIFY_PEERS:
 		ndisc_send_unsol_na(dev);
diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c
index 89a4e4d..e214222 100644
--- a/net/ipv6/netfilter/ip6_tables.c
+++ b/net/ipv6/netfilter/ip6_tables.c
@@ -195,11 +195,12 @@ get_entry(const void *base, unsigned int offset)
 
 /* All zeroes == unconditional rule. */
 /* Mildly perf critical (only if packet tracing is on) */
-static inline bool unconditional(const struct ip6t_ip6 *ipv6)
+static inline bool unconditional(const struct ip6t_entry *e)
 {
 	static const struct ip6t_ip6 uncond;
 
-	return memcmp(ipv6, &uncond, sizeof(uncond)) == 0;
+	return e->target_offset == sizeof(struct ip6t_entry) &&
+	       memcmp(&e->ipv6, &uncond, sizeof(uncond)) == 0;
 }
 
 static inline const struct xt_entry_target *
@@ -255,11 +256,10 @@ get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,
 	} else if (s == e) {
 		(*rulenum)++;
 
-		if (s->target_offset == sizeof(struct ip6t_entry) &&
+		if (unconditional(s) &&
 		    strcmp(t->target.u.kernel.target->name,
 			   XT_STANDARD_TARGET) == 0 &&
-		    t->verdict < 0 &&
-		    unconditional(&s->ipv6)) {
+		    t->verdict < 0) {
 			/* Tail of chains: STANDARD target (return/policy) */
 			*comment = *chainname == hookname
 				? comments[NF_IP6_TRACE_COMMENT_POLICY]
@@ -477,11 +477,10 @@ mark_source_chains(const struct xt_table_info *newinfo,
 			e->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));
 
 			/* Unconditional return/END. */
-			if ((e->target_offset == sizeof(struct ip6t_entry) &&
+			if ((unconditional(e) &&
 			     (strcmp(t->target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &&
-			     t->verdict < 0 &&
-			     unconditional(&e->ipv6)) || visited) {
+			     t->verdict < 0) || visited) {
 				unsigned int oldpos, size;
 
 				if ((strcmp(t->target.u.user.name,
@@ -522,6 +521,8 @@ mark_source_chains(const struct xt_table_info *newinfo,
 				size = e->next_offset;
 				e = (struct ip6t_entry *)
 					(entry0 + pos + size);
+				if (pos + size >= newinfo->size)
+					return 0;
 				e->counters.pcnt = pos;
 				pos += size;
 			} else {
@@ -543,6 +544,8 @@ mark_source_chains(const struct xt_table_info *newinfo,
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e->next_offset;
+					if (newpos >= newinfo->size)
+						return 0;
 				}
 				e = (struct ip6t_entry *)
 					(entry0 + newpos);
@@ -569,27 +572,6 @@ static void cleanup_match(struct xt_entry_match *m, struct net *net)
 	module_put(par.match->me);
 }
 
-static int
-check_entry(const struct ip6t_entry *e, const char *name)
-{
-	const struct xt_entry_target *t;
-
-	if (!ip6_checkentry(&e->ipv6)) {
-		duprintf("ip_tables: ip check failed %p %s.\n", e, name);
-		return -EINVAL;
-	}
-
-	if (e->target_offset + sizeof(struct xt_entry_target) >
-	    e->next_offset)
-		return -EINVAL;
-
-	t = ip6t_get_target_c(e);
-	if (e->target_offset + t->u.target_size > e->next_offset)
-		return -EINVAL;
-
-	return 0;
-}
-
 static int check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)
 {
 	const struct ip6t_ip6 *ipv6 = par->entryinfo;
@@ -668,10 +650,6 @@ find_check_entry(struct ip6t_entry *e, struct net *net, const char *name,
 	struct xt_mtchk_param mtpar;
 	struct xt_entry_match *ematch;
 
-	ret = check_entry(e, name);
-	if (ret)
-		return ret;
-
 	j = 0;
 	mtpar.net	= net;
 	mtpar.table     = name;
@@ -715,7 +693,7 @@ static bool check_underflow(const struct ip6t_entry *e)
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
-	if (!unconditional(&e->ipv6))
+	if (!unconditional(e))
 		return false;
 	t = ip6t_get_target_c(e);
 	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
@@ -735,9 +713,11 @@ check_entry_size_and_hooks(struct ip6t_entry *e,
 			   unsigned int valid_hooks)
 {
 	unsigned int h;
+	int err;
 
 	if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf("Bad offset %p\n", e);
 		return -EINVAL;
 	}
@@ -749,6 +729,14 @@ check_entry_size_and_hooks(struct ip6t_entry *e,
 		return -EINVAL;
 	}
 
+	if (!ip6_checkentry(&e->ipv6))
+		return -EINVAL;
+
+	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
+				     e->next_offset);
+	if (err)
+		return err;
+
 	/* Check hooks & underflows */
 	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
 		if (!(valid_hooks & (1 << h)))
@@ -757,9 +745,9 @@ check_entry_size_and_hooks(struct ip6t_entry *e,
 			newinfo->hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e - base == underflows[h]) {
 			if (!check_underflow(e)) {
-				pr_err("Underflows must be unconditional and "
-				       "use the STANDARD target with "
-				       "ACCEPT/DROP\n");
+				pr_debug("Underflows must be unconditional and "
+					 "use the STANDARD target with "
+					 "ACCEPT/DROP\n");
 				return -EINVAL;
 			}
 			newinfo->underflow[h] = underflows[h];
@@ -1268,6 +1256,9 @@ do_replace(struct net *net, const void __user *user, unsigned int len)
 	/* overflow check */
 	if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
+	if (tmp.num_counters == 0)
+		return -EINVAL;
+
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
@@ -1309,56 +1300,17 @@ do_add_counters(struct net *net, const void __user *user, unsigned int len,
 	unsigned int i, curcpu;
 	struct xt_counters_info tmp;
 	struct xt_counters *paddc;
-	unsigned int num_counters;
-	char *name;
-	int size;
-	void *ptmp;
 	struct xt_table *t;
 	const struct xt_table_info *private;
 	int ret = 0;
 	const void *loc_cpu_entry;
 	struct ip6t_entry *iter;
 	unsigned int addend;
-#ifdef CONFIG_COMPAT
-	struct compat_xt_counters_info compat_tmp;
-
-	if (compat) {
-		ptmp = &compat_tmp;
-		size = sizeof(struct compat_xt_counters_info);
-	} else
-#endif
-	{
-		ptmp = &tmp;
-		size = sizeof(struct xt_counters_info);
-	}
-
-	if (copy_from_user(ptmp, user, size) != 0)
-		return -EFAULT;
-
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		num_counters = compat_tmp.num_counters;
-		name = compat_tmp.name;
-	} else
-#endif
-	{
-		num_counters = tmp.num_counters;
-		name = tmp.name;
-	}
 
-	if (len != size + num_counters * sizeof(struct xt_counters))
-		return -EINVAL;
-
-	paddc = vmalloc(len - size);
-	if (!paddc)
-		return -ENOMEM;
-
-	if (copy_from_user(paddc, user + size, len - size) != 0) {
-		ret = -EFAULT;
-		goto free;
-	}
-
-	t = xt_find_table_lock(net, AF_INET6, name);
+	paddc = xt_copy_counters_from_user(user, len, &tmp, compat);
+	if (IS_ERR(paddc))
+		return PTR_ERR(paddc);
+	t = xt_find_table_lock(net, AF_INET6, tmp.name);
 	if (IS_ERR_OR_NULL(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
@@ -1367,7 +1319,7 @@ do_add_counters(struct net *net, const void __user *user, unsigned int len,
 
 	local_bh_disable();
 	private = t->private;
-	if (private->number != num_counters) {
+	if (private->number != tmp.num_counters) {
 		ret = -EINVAL;
 		goto unlock_up_free;
 	}
@@ -1447,7 +1399,6 @@ compat_copy_entry_to_user(struct ip6t_entry *e, void __user **dstptr,
 
 static int
 compat_find_calc_match(struct xt_entry_match *m,
-		       const char *name,
 		       const struct ip6t_ip6 *ipv6,
 		       unsigned int hookmask,
 		       int *size)
@@ -1483,21 +1434,19 @@ check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,
 				  struct xt_table_info *newinfo,
 				  unsigned int *size,
 				  const unsigned char *base,
-				  const unsigned char *limit,
-				  const unsigned int *hook_entries,
-				  const unsigned int *underflows,
-				  const char *name)
+				  const unsigned char *limit)
 {
 	struct xt_entry_match *ematch;
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	unsigned int entry_offset;
 	unsigned int j;
-	int ret, off, h;
+	int ret, off;
 
 	duprintf("check_compat_entry_size_and_hooks %p\n", e);
 	if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||
-	    (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit) {
+	    (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit ||
+	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf("Bad offset %p, limit = %p\n", e, limit);
 		return -EINVAL;
 	}
@@ -1509,8 +1458,11 @@ check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,
 		return -EINVAL;
 	}
 
-	/* For purposes of check_entry casting the compat entry is fine */
-	ret = check_entry((struct ip6t_entry *)e, name);
+	if (!ip6_checkentry(&e->ipv6))
+		return -EINVAL;
+
+	ret = xt_compat_check_entry_offsets(e, e->elems,
+					    e->target_offset, e->next_offset);
 	if (ret)
 		return ret;
 
@@ -1518,8 +1470,8 @@ check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,
 	entry_offset = (void *)e - (void *)base;
 	j = 0;
 	xt_ematch_foreach(ematch, e) {
-		ret = compat_find_calc_match(ematch, name,
-					     &e->ipv6, e->comefrom, &off);
+		ret = compat_find_calc_match(ematch, &e->ipv6, e->comefrom,
+					     &off);
 		if (ret != 0)
 			goto release_matches;
 		++j;
@@ -1542,17 +1494,6 @@ check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,
 	if (ret)
 		goto out;
 
-	/* Check hooks & underflows */
-	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
-		if ((unsigned char *)e - base == hook_entries[h])
-			newinfo->hook_entry[h] = hook_entries[h];
-		if ((unsigned char *)e - base == underflows[h])
-			newinfo->underflow[h] = underflows[h];
-	}
-
-	/* Clear counters and comefrom */
-	memset(&e->counters, 0, sizeof(e->counters));
-	e->comefrom = 0;
 	return 0;
 
 out:
@@ -1566,18 +1507,17 @@ release_matches:
 	return ret;
 }
 
-static int
+static void
 compat_copy_entry_from_user(struct compat_ip6t_entry *e, void **dstptr,
-			    unsigned int *size, const char *name,
+			    unsigned int *size,
 			    struct xt_table_info *newinfo, unsigned char *base)
 {
 	struct xt_entry_target *t;
 	struct ip6t_entry *de;
 	unsigned int origsize;
-	int ret, h;
+	int h;
 	struct xt_entry_match *ematch;
 
-	ret = 0;
 	origsize = *size;
 	de = (struct ip6t_entry *)*dstptr;
 	memcpy(de, e, sizeof(struct ip6t_entry));
@@ -1586,11 +1526,9 @@ compat_copy_entry_from_user(struct compat_ip6t_entry *e, void **dstptr,
 	*dstptr += sizeof(struct ip6t_entry);
 	*size += sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
 
-	xt_ematch_foreach(ematch, e) {
-		ret = xt_compat_match_from_user(ematch, dstptr, size);
-		if (ret != 0)
-			return ret;
-	}
+	xt_ematch_foreach(ematch, e)
+		xt_compat_match_from_user(ematch, dstptr, size);
+
 	de->target_offset = e->target_offset - (origsize - *size);
 	t = compat_ip6t_get_target(e);
 	xt_compat_target_from_user(t, dstptr, size);
@@ -1602,181 +1540,82 @@ compat_copy_entry_from_user(struct compat_ip6t_entry *e, void **dstptr,
 		if ((unsigned char *)de - base < newinfo->underflow[h])
 			newinfo->underflow[h] -= origsize - *size;
 	}
-	return ret;
-}
-
-static int compat_check_entry(struct ip6t_entry *e, struct net *net,
-			      const char *name)
-{
-	unsigned int j;
-	int ret = 0;
-	struct xt_mtchk_param mtpar;
-	struct xt_entry_match *ematch;
-
-	j = 0;
-	mtpar.net	= net;
-	mtpar.table     = name;
-	mtpar.entryinfo = &e->ipv6;
-	mtpar.hook_mask = e->comefrom;
-	mtpar.family    = NFPROTO_IPV6;
-	xt_ematch_foreach(ematch, e) {
-		ret = check_match(ematch, &mtpar);
-		if (ret != 0)
-			goto cleanup_matches;
-		++j;
-	}
-
-	ret = check_target(e, net, name);
-	if (ret)
-		goto cleanup_matches;
-	return 0;
-
- cleanup_matches:
-	xt_ematch_foreach(ematch, e) {
-		if (j-- == 0)
-			break;
-		cleanup_match(ematch, net);
-	}
-	return ret;
 }
 
 static int
 translate_compat_table(struct net *net,
-		       const char *name,
-		       unsigned int valid_hooks,
 		       struct xt_table_info **pinfo,
 		       void **pentry0,
-		       unsigned int total_size,
-		       unsigned int number,
-		       unsigned int *hook_entries,
-		       unsigned int *underflows)
+		       const struct compat_ip6t_replace *compatr)
 {
 	unsigned int i, j;
 	struct xt_table_info *newinfo, *info;
 	void *pos, *entry0, *entry1;
 	struct compat_ip6t_entry *iter0;
-	struct ip6t_entry *iter1;
+	struct ip6t_replace repl;
 	unsigned int size;
 	int ret = 0;
 
 	info = *pinfo;
 	entry0 = *pentry0;
-	size = total_size;
-	info->number = number;
-
-	/* Init all hooks to impossible value. */
-	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
-		info->hook_entry[i] = 0xFFFFFFFF;
-		info->underflow[i] = 0xFFFFFFFF;
-	}
+	size = compatr->size;
+	info->number = compatr->num_entries;
 
 	duprintf("translate_compat_table: size %u\n", info->size);
 	j = 0;
 	xt_compat_lock(AF_INET6);
-	xt_compat_init_offsets(AF_INET6, number);
+	xt_compat_init_offsets(AF_INET6, compatr->num_entries);
 	/* Walk through entries, checking offsets. */
-	xt_entry_foreach(iter0, entry0, total_size) {
+	xt_entry_foreach(iter0, entry0, compatr->size) {
 		ret = check_compat_entry_size_and_hooks(iter0, info, &size,
 							entry0,
-							entry0 + total_size,
-							hook_entries,
-							underflows,
-							name);
+							entry0 + compatr->size);
 		if (ret != 0)
 			goto out_unlock;
 		++j;
 	}
 
 	ret = -EINVAL;
-	if (j != number) {
+	if (j != compatr->num_entries) {
 		duprintf("translate_compat_table: %u not %u entries\n",
-			 j, number);
+			 j, compatr->num_entries);
 		goto out_unlock;
 	}
 
-	/* Check hooks all assigned */
-	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
-		/* Only hooks which are valid */
-		if (!(valid_hooks & (1 << i)))
-			continue;
-		if (info->hook_entry[i] == 0xFFFFFFFF) {
-			duprintf("Invalid hook entry %u %u\n",
-				 i, hook_entries[i]);
-			goto out_unlock;
-		}
-		if (info->underflow[i] == 0xFFFFFFFF) {
-			duprintf("Invalid underflow %u %u\n",
-				 i, underflows[i]);
-			goto out_unlock;
-		}
-	}
-
 	ret = -ENOMEM;
 	newinfo = xt_alloc_table_info(size);
 	if (!newinfo)
 		goto out_unlock;
 
-	newinfo->number = number;
+	newinfo->number = compatr->num_entries;
 	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
-		newinfo->hook_entry[i] = info->hook_entry[i];
-		newinfo->underflow[i] = info->underflow[i];
+		newinfo->hook_entry[i] = compatr->hook_entry[i];
+		newinfo->underflow[i] = compatr->underflow[i];
 	}
 	entry1 = newinfo->entries[raw_smp_processor_id()];
 	pos = entry1;
-	size = total_size;
-	xt_entry_foreach(iter0, entry0, total_size) {
-		ret = compat_copy_entry_from_user(iter0, &pos, &size,
-						  name, newinfo, entry1);
-		if (ret != 0)
-			break;
-	}
+	size = compatr->size;
+	xt_entry_foreach(iter0, entry0, compatr->size)
+		compat_copy_entry_from_user(iter0, &pos, &size,
+					    newinfo, entry1);
+
+	/* all module references in entry0 are now gone. */
 	xt_compat_flush_offsets(AF_INET6);
 	xt_compat_unlock(AF_INET6);
-	if (ret)
-		goto free_newinfo;
 
-	ret = -ELOOP;
-	if (!mark_source_chains(newinfo, valid_hooks, entry1))
-		goto free_newinfo;
+	memcpy(&repl, compatr, sizeof(*compatr));
 
-	i = 0;
-	xt_entry_foreach(iter1, entry1, newinfo->size) {
-		ret = compat_check_entry(iter1, net, name);
-		if (ret != 0)
-			break;
-		++i;
-		if (strcmp(ip6t_get_target(iter1)->u.user.name,
-		    XT_ERROR_TARGET) == 0)
-			++newinfo->stacksize;
-	}
-	if (ret) {
-		/*
-		 * The first i matches need cleanup_entry (calls ->destroy)
-		 * because they had called ->check already. The other j-i
-		 * entries need only release.
-		 */
-		int skip = i;
-		j -= i;
-		xt_entry_foreach(iter0, entry0, newinfo->size) {
-			if (skip-- > 0)
-				continue;
-			if (j-- == 0)
-				break;
-			compat_release_entry(iter0);
-		}
-		xt_entry_foreach(iter1, entry1, newinfo->size) {
-			if (i-- == 0)
-				break;
-			cleanup_entry(iter1, net);
-		}
-		xt_free_table_info(newinfo);
-		return ret;
+	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
+		repl.hook_entry[i] = newinfo->hook_entry[i];
+		repl.underflow[i] = newinfo->underflow[i];
 	}
 
-	/* And one copy for every other CPU */
-	for_each_possible_cpu(i)
-		if (newinfo->entries[i] && newinfo->entries[i] != entry1)
-			memcpy(newinfo->entries[i], entry1, newinfo->size);
+	repl.num_counters = 0;
+	repl.counters = NULL;
+	repl.size = newinfo->size;
+	ret = translate_table(net, newinfo, entry1, &repl);
+	if (ret)
+		goto free_newinfo;
 
 	*pinfo = newinfo;
 	*pentry0 = entry1;
@@ -1785,17 +1624,16 @@ translate_compat_table(struct net *net,
 
 free_newinfo:
 	xt_free_table_info(newinfo);
-out:
-	xt_entry_foreach(iter0, entry0, total_size) {
+	return ret;
+out_unlock:
+	xt_compat_flush_offsets(AF_INET6);
+	xt_compat_unlock(AF_INET6);
+	xt_entry_foreach(iter0, entry0, compatr->size) {
 		if (j-- == 0)
 			break;
 		compat_release_entry(iter0);
 	}
 	return ret;
-out_unlock:
-	xt_compat_flush_offsets(AF_INET6);
-	xt_compat_unlock(AF_INET6);
-	goto out;
 }
 
 static int
@@ -1815,6 +1653,9 @@ compat_do_replace(struct net *net, void __user *user, unsigned int len)
 		return -ENOMEM;
 	if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
 		return -ENOMEM;
+	if (tmp.num_counters == 0)
+		return -EINVAL;
+
 	tmp.name[sizeof(tmp.name)-1] = 0;
 
 	newinfo = xt_alloc_table_info(tmp.size);
@@ -1829,10 +1670,7 @@ compat_do_replace(struct net *net, void __user *user, unsigned int len)
 		goto free_newinfo;
 	}
 
-	ret = translate_compat_table(net, tmp.name, tmp.valid_hooks,
-				     &newinfo, &loc_cpu_entry, tmp.size,
-				     tmp.num_entries, tmp.hook_entry,
-				     tmp.underflow);
+	ret = translate_compat_table(net, &newinfo, &loc_cpu_entry, &tmp);
 	if (ret != 0)
 		goto free_newinfo;
 
diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
index 253566a..7cd6235 100644
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
@@ -172,7 +172,7 @@ static void nf_ct_frag6_expire(unsigned long data)
 /* Creation primitives. */
 static inline struct frag_queue *fq_find(struct net *net, __be32 id,
 					 u32 user, struct in6_addr *src,
-					 struct in6_addr *dst, u8 ecn)
+					 struct in6_addr *dst, int iif, u8 ecn)
 {
 	struct inet_frag_queue *q;
 	struct ip6_create_arg arg;
@@ -182,6 +182,7 @@ static inline struct frag_queue *fq_find(struct net *net, __be32 id,
 	arg.user = user;
 	arg.src = src;
 	arg.dst = dst;
+	arg.iif = iif;
 	arg.ecn = ecn;
 
 	read_lock_bh(&nf_frags.lock);
@@ -590,7 +591,7 @@ struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)
 	local_bh_enable();
 
 	fq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,
-		     ip6_frag_ecn(hdr));
+		     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));
 	if (fq == NULL) {
 		pr_debug("Can't find and can't create new queue\n");
 		goto ret_orig;
diff --git a/net/ipv6/reassembly.c b/net/ipv6/reassembly.c
index 1aeb473..a1fb511 100644
--- a/net/ipv6/reassembly.c
+++ b/net/ipv6/reassembly.c
@@ -111,7 +111,10 @@ bool ip6_frag_match(struct inet_frag_queue *q, void *a)
 	return	fq->id == arg->id &&
 		fq->user == arg->user &&
 		ipv6_addr_equal(&fq->saddr, arg->src) &&
-		ipv6_addr_equal(&fq->daddr, arg->dst);
+		ipv6_addr_equal(&fq->daddr, arg->dst) &&
+		(arg->iif == fq->iif ||
+		 !(ipv6_addr_type(arg->dst) & (IPV6_ADDR_MULTICAST |
+					       IPV6_ADDR_LINKLOCAL)));
 }
 EXPORT_SYMBOL(ip6_frag_match);
 
@@ -180,7 +183,7 @@ static void ip6_frag_expire(unsigned long data)
 
 static __inline__ struct frag_queue *
 fq_find(struct net *net, __be32 id, const struct in6_addr *src,
-	const struct in6_addr *dst, u8 ecn)
+	const struct in6_addr *dst, int iif, u8 ecn)
 {
 	struct inet_frag_queue *q;
 	struct ip6_create_arg arg;
@@ -190,6 +193,7 @@ fq_find(struct net *net, __be32 id, const struct in6_addr *src,
 	arg.user = IP6_DEFRAG_LOCAL_DELIVER;
 	arg.src = src;
 	arg.dst = dst;
+	arg.iif = iif;
 	arg.ecn = ecn;
 
 	read_lock(&ip6_frags.lock);
@@ -558,7 +562,7 @@ static int ipv6_frag_rcv(struct sk_buff *skb)
 				 IPSTATS_MIB_REASMFAILS, evicted);
 
 	fq = fq_find(net, fhdr->identification, &hdr->saddr, &hdr->daddr,
-		     ip6_frag_ecn(hdr));
+		     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));
 	if (fq != NULL) {
 		int ret;
 
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index d94d224..6ebefd4 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -1334,7 +1334,6 @@ static void icmp6_clean_all(int (*func)(struct rt6_info *rt, void *arg),
 
 static int ip6_dst_gc(struct dst_ops *ops)
 {
-	unsigned long now = jiffies;
 	struct net *net = container_of(ops, struct net, ipv6.ip6_dst_ops);
 	int rt_min_interval = net->ipv6.sysctl.ip6_rt_gc_min_interval;
 	int rt_max_size = net->ipv6.sysctl.ip6_rt_max_size;
@@ -1344,13 +1343,12 @@ static int ip6_dst_gc(struct dst_ops *ops)
 	int entries;
 
 	entries = dst_entries_get_fast(ops);
-	if (time_after(rt_last_gc + rt_min_interval, now) &&
+	if (time_after(rt_last_gc + rt_min_interval, jiffies) &&
 	    entries <= rt_max_size)
 		goto out;
 
 	net->ipv6.ip6_rt_gc_expire++;
-	fib6_run_gc(net->ipv6.ip6_rt_gc_expire, net);
-	net->ipv6.ip6_rt_last_gc = now;
+	fib6_run_gc(net->ipv6.ip6_rt_gc_expire, net, entries > rt_max_size);
 	entries = dst_entries_get_slow(ops);
 	if (entries < ops->gc_thresh)
 		net->ipv6.ip6_rt_gc_expire = rt_gc_timeout>>1;
@@ -2849,7 +2847,7 @@ int ipv6_sysctl_rtcache_flush(ctl_table *ctl, int write,
 	net = (struct net *)ctl->extra1;
 	delay = net->ipv6.sysctl.flush_delay;
 	proc_dointvec(ctl, write, buffer, lenp, ppos);
-	fib6_run_gc(delay <= 0 ? ~0UL : (unsigned long)delay, net);
+	fib6_run_gc(delay <= 0 ? 0 : (unsigned long)delay, net, delay > 0);
 	return 0;
 }
 
diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c
index 4ddf67c..d9535bb 100644
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@ -530,13 +530,13 @@ static int ipip6_err(struct sk_buff *skb, u32 info)
 
 	if (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {
 		ipv4_update_pmtu(skb, dev_net(skb->dev), info,
-				 t->parms.link, 0, IPPROTO_IPV6, 0);
+				 t->parms.link, 0, iph->protocol, 0);
 		err = 0;
 		goto out;
 	}
 	if (type == ICMP_REDIRECT) {
 		ipv4_redirect(skb, dev_net(skb->dev), t->parms.link, 0,
-			      IPPROTO_IPV6, 0);
+			      iph->protocol, 0);
 		err = 0;
 		goto out;
 	}
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index 1a87659..41c026f 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -1616,7 +1616,7 @@ static void tcp_v6_early_demux(struct sk_buff *skb)
 		skb->sk = sk;
 		skb->destructor = sock_edemux;
 		if (sk->sk_state != TCP_TIME_WAIT) {
-			struct dst_entry *dst = sk->sk_rx_dst;
+			struct dst_entry *dst = ACCESS_ONCE(sk->sk_rx_dst);
 
 			if (dst)
 				dst = dst_check(dst, inet6_sk(sk)->rx_dst_cookie);
@@ -1767,7 +1767,9 @@ static void get_tcp6_sock(struct seq_file *seq, struct sock *sp, int i)
 	destp = ntohs(inet->inet_dport);
 	srcp  = ntohs(inet->inet_sport);
 
-	if (icsk->icsk_pending == ICSK_TIME_RETRANS) {
+	if (icsk->icsk_pending == ICSK_TIME_RETRANS ||
+	    icsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||
+	    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {
 		timer_active	= 1;
 		timer_expires	= icsk->icsk_timeout;
 	} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {
diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c
index 6b298dc..d234e6f 100644
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -370,6 +370,7 @@ int udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
+	bool checksum_valid = false;
 	int is_udp4;
 	bool slow;
 
@@ -401,11 +402,12 @@ try_again:
 	 */
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
-		if (udp_lib_checksum_complete(skb))
+		checksum_valid = !udp_lib_checksum_complete(skb);
+		if (!checksum_valid)
 			goto csum_copy_err;
 	}
 
-	if (skb_csum_unnecessary(skb))
+	if (checksum_valid || skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),
 					      msg->msg_iov, copied);
 	else {
@@ -494,10 +496,8 @@ csum_copy_err:
 	}
 	unlock_sock_fast(sk, slow);
 
-	if (noblock)
-		return -EAGAIN;
-
-	/* starting over for a new packet */
+	/* starting over for a new packet, but check if we need to yield */
+	cond_resched();
 	msg->msg_flags &= ~MSG_TRUNC;
 	goto try_again;
 }
@@ -841,11 +841,9 @@ int __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,
 		int ret = udpv6_queue_rcv_skb(sk, skb);
 		sock_put(sk);
 
-		/* a return value > 0 means to resubmit the input, but
-		 * it wants the return to be -protocol, or 0
-		 */
+		/* a return value > 0 means to resubmit the input */
 		if (ret > 0)
-			return -ret;
+			return ret;
 
 		return 0;
 	}
diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c
index 23ed03d..1c2e0c9 100644
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -284,7 +284,7 @@ static struct dst_ops xfrm6_dst_ops = {
 	.destroy =		xfrm6_dst_destroy,
 	.ifdown =		xfrm6_dst_ifdown,
 	.local_out =		__ip6_local_out,
-	.gc_thresh =		1024,
+	.gc_thresh =		32768,
 };
 
 static struct xfrm_policy_afinfo xfrm6_policy_afinfo = {
diff --git a/net/irda/af_irda.c b/net/irda/af_irda.c
index a5e62ef5..c95bafa 100644
--- a/net/irda/af_irda.c
+++ b/net/irda/af_irda.c
@@ -1039,8 +1039,11 @@ static int irda_connect(struct socket *sock, struct sockaddr *uaddr,
 	}
 
 	/* Check if we have opened a local TSAP */
-	if (!self->tsap)
-		irda_open_tsap(self, LSAP_ANY, addr->sir_name);
+	if (!self->tsap) {
+		err = irda_open_tsap(self, LSAP_ANY, addr->sir_name);
+		if (err)
+			goto out;
+	}
 
 	/* Move to connecting socket, start sending Connect Requests */
 	sock->state = SS_CONNECTING;
@@ -1105,6 +1108,9 @@ static int irda_create(struct net *net, struct socket *sock, int protocol,
 
 	IRDA_DEBUG(2, "%s()\n", __func__);
 
+	if (protocol < 0 || protocol > SK_PROTOCOL_MAX)
+		return -EINVAL;
+
 	if (net != &init_net)
 		return -EAFNOSUPPORT;
 
diff --git a/net/irda/irlmp.c b/net/irda/irlmp.c
index 98ad6ec..8ad1494 100644
--- a/net/irda/irlmp.c
+++ b/net/irda/irlmp.c
@@ -1876,7 +1876,7 @@ static void *irlmp_seq_hb_idx(struct irlmp_iter_state *iter, loff_t *off)
 	for (element = hashbin_get_first(iter->hashbin);
 	     element != NULL;
 	     element = hashbin_get_next(iter->hashbin)) {
-		if (!off || *off-- == 0) {
+		if (!off || (*off)-- == 0) {
 			/* NB: hashbin left locked */
 			return element;
 		}
diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c
index 8c27de2..797ff37 100644
--- a/net/l2tp/l2tp_core.c
+++ b/net/l2tp/l2tp_core.c
@@ -1381,7 +1381,7 @@ static void l2tp_tunnel_del_work(struct work_struct *work)
 	tunnel = container_of(work, struct l2tp_tunnel, del_work);
 	sk = l2tp_tunnel_sock_lookup(tunnel);
 	if (!sk)
-		return;
+		goto out;
 
 	sock = sk->sk_socket;
 
@@ -1402,6 +1402,8 @@ static void l2tp_tunnel_del_work(struct work_struct *work)
 	}
 
 	l2tp_tunnel_sock_put(sk);
+out:
+	l2tp_tunnel_dec_refcount(tunnel);
 }
 
 /* Create a socket for the tunnel, if one isn't set up by
@@ -1731,8 +1733,13 @@ EXPORT_SYMBOL_GPL(l2tp_tunnel_create);
  */
 int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel)
 {
+	l2tp_tunnel_inc_refcount(tunnel);
 	l2tp_tunnel_closeall(tunnel);
-	return (false == queue_work(l2tp_wq, &tunnel->del_work));
+	if (false == queue_work(l2tp_wq, &tunnel->del_work)) {
+		l2tp_tunnel_dec_refcount(tunnel);
+		return 1;
+	}
+	return 0;
 }
 EXPORT_SYMBOL_GPL(l2tp_tunnel_delete);
 
diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c
index da1a1ce..07f8b97 100644
--- a/net/l2tp/l2tp_ip.c
+++ b/net/l2tp/l2tp_ip.c
@@ -123,12 +123,11 @@ static int l2tp_ip_recv(struct sk_buff *skb)
 	struct l2tp_tunnel *tunnel = NULL;
 	int length;
 
-	/* Point to L2TP header */
-	optr = ptr = skb->data;
-
 	if (!pskb_may_pull(skb, 4))
 		goto discard;
 
+	/* Point to L2TP header */
+	optr = ptr = skb->data;
 	session_id = ntohl(*((__be32 *) ptr));
 	ptr += 4;
 
@@ -156,6 +155,9 @@ static int l2tp_ip_recv(struct sk_buff *skb)
 		if (!pskb_may_pull(skb, length))
 			goto discard;
 
+		/* Point to L2TP header */
+		optr = ptr = skb->data;
+		ptr += 4;
 		pr_debug("%s: ip recv\n", tunnel->name);
 		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, ptr, length);
 	}
diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c
index e6e8408..db96af9 100644
--- a/net/l2tp/l2tp_ip6.c
+++ b/net/l2tp/l2tp_ip6.c
@@ -135,12 +135,11 @@ static int l2tp_ip6_recv(struct sk_buff *skb)
 	struct l2tp_tunnel *tunnel = NULL;
 	int length;
 
-	/* Point to L2TP header */
-	optr = ptr = skb->data;
-
 	if (!pskb_may_pull(skb, 4))
 		goto discard;
 
+	/* Point to L2TP header */
+	optr = ptr = skb->data;
 	session_id = ntohl(*((__be32 *) ptr));
 	ptr += 4;
 
@@ -168,6 +167,9 @@ static int l2tp_ip6_recv(struct sk_buff *skb)
 		if (!pskb_may_pull(skb, length))
 			goto discard;
 
+		/* Point to L2TP header */
+		optr = ptr = skb->data;
+		ptr += 4;
 		pr_debug("%s: ip recv\n", tunnel->name);
 		print_hex_dump_bytes("", DUMP_PREFIX_OFFSET, ptr, length);
 	}
diff --git a/net/llc/af_llc.c b/net/llc/af_llc.c
index c3ee805..9d14059 100644
--- a/net/llc/af_llc.c
+++ b/net/llc/af_llc.c
@@ -626,6 +626,7 @@ static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)
 	if (llc->cmsg_flags & LLC_CMSG_PKTINFO) {
 		struct llc_pktinfo info;
 
+		memset(&info, 0, sizeof(info));
 		info.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;
 		llc_pdu_decode_dsap(skb, &info.lpi_sap);
 		llc_pdu_decode_da(skb, info.lpi_mac);
diff --git a/net/llc/sysctl_net_llc.c b/net/llc/sysctl_net_llc.c
index 612a5dd..799bafc 100644
--- a/net/llc/sysctl_net_llc.c
+++ b/net/llc/sysctl_net_llc.c
@@ -18,28 +18,28 @@ static struct ctl_table llc2_timeout_table[] = {
 	{
 		.procname	= "ack",
 		.data		= &sysctl_llc2_ack_timeout,
-		.maxlen		= sizeof(long),
+		.maxlen		= sizeof(sysctl_llc2_ack_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= "busy",
 		.data		= &sysctl_llc2_busy_timeout,
-		.maxlen		= sizeof(long),
+		.maxlen		= sizeof(sysctl_llc2_busy_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= "p",
 		.data		= &sysctl_llc2_p_timeout,
-		.maxlen		= sizeof(long),
+		.maxlen		= sizeof(sysctl_llc2_p_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= "rej",
 		.data		= &sysctl_llc2_rej_timeout,
-		.maxlen		= sizeof(long),
+		.maxlen		= sizeof(sysctl_llc2_rej_timeout),
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
diff --git a/net/mac80211/agg-rx.c b/net/mac80211/agg-rx.c
index 31bf258..8644080 100644
--- a/net/mac80211/agg-rx.c
+++ b/net/mac80211/agg-rx.c
@@ -290,7 +290,7 @@ void ieee80211_process_addba_request(struct ieee80211_local *local,
 	}
 
 	/* prepare A-MPDU MLME for Rx aggregation */
-	tid_agg_rx = kmalloc(sizeof(struct tid_ampdu_rx), GFP_KERNEL);
+	tid_agg_rx = kzalloc(sizeof(*tid_agg_rx), GFP_KERNEL);
 	if (!tid_agg_rx)
 		goto end;
 
diff --git a/net/mac80211/debugfs_netdev.c b/net/mac80211/debugfs_netdev.c
index 2d5b4f6..32bafdb 100644
--- a/net/mac80211/debugfs_netdev.c
+++ b/net/mac80211/debugfs_netdev.c
@@ -697,6 +697,7 @@ void ieee80211_debugfs_remove_netdev(struct ieee80211_sub_if_data *sdata)
 
 	debugfs_remove_recursive(sdata->vif.debugfs_dir);
 	sdata->vif.debugfs_dir = NULL;
+	sdata->debugfs.subdir_stations = NULL;
 }
 
 void ieee80211_debugfs_rename_netdev(struct ieee80211_sub_if_data *sdata)
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 845563b..9f0ea9d 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -60,13 +60,24 @@ struct ieee80211_local;
 #define IEEE80211_UNSET_POWER_LEVEL	INT_MIN
 
 /*
- * Some APs experience problems when working with U-APSD. Decrease the
- * probability of that happening by using legacy mode for all ACs but VO.
- * The AP that caused us trouble was a Cisco 4410N. It ignores our
- * setting, and always treats non-VO ACs as legacy.
+ * Some APs experience problems when working with U-APSD. Decreasing the
+ * probability of that happening by using legacy mode for all ACs but VO isn't
+ * enough.
+ *
+ * Cisco 4410N originally forced us to enable VO by default only because it
+ * treated non-VO ACs as legacy.
+ *
+ * However some APs (notably Netgear R7000) silently reclassify packets to
+ * different ACs. Since u-APSD ACs require trigger frames for frame retrieval
+ * clients would never see some frames (e.g. ARP responses) or would fetch them
+ * accidentally after a long time.
+ *
+ * It makes little sense to enable u-APSD queues by default because it needs
+ * userspace applications to be aware of it to actually take advantage of the
+ * possible additional powersavings. Implicitly depending on driver autotrigger
+ * frame support doesn't make much sense.
  */
-#define IEEE80211_DEFAULT_UAPSD_QUEUES \
-	IEEE80211_WMM_IE_STA_QOSINFO_AC_VO
+#define IEEE80211_DEFAULT_UAPSD_QUEUES 0
 
 #define IEEE80211_DEFAULT_MAX_SP_LEN		\
 	IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL
diff --git a/net/mac80211/main.c b/net/mac80211/main.c
index 6658c58..dd6ca36 100644
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -257,6 +257,7 @@ static void ieee80211_restart_work(struct work_struct *work)
 {
 	struct ieee80211_local *local =
 		container_of(work, struct ieee80211_local, restart_work);
+	struct ieee80211_sub_if_data *sdata;
 
 	/* wait for scan work complete */
 	flush_workqueue(local->workqueue);
@@ -269,6 +270,8 @@ static void ieee80211_restart_work(struct work_struct *work)
 	mutex_unlock(&local->mtx);
 
 	rtnl_lock();
+	list_for_each_entry(sdata, &local->interfaces, list)
+		flush_delayed_work(&sdata->dec_tailroom_needed_wk);
 	ieee80211_scan_cancel(local);
 	ieee80211_reconfig(local);
 	rtnl_unlock();
diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c
index 6952760..f8765cc 100644
--- a/net/mac80211/mesh.c
+++ b/net/mac80211/mesh.c
@@ -161,6 +161,10 @@ void mesh_sta_cleanup(struct sta_info *sta)
 		del_timer_sync(&sta->plink_timer);
 	}
 
+	/* make sure no readers can access nexthop sta from here on */
+	mesh_path_flush_by_nexthop(sta);
+	synchronize_net();
+
 	if (changed)
 		ieee80211_mbss_info_change_notify(sdata, changed);
 }
diff --git a/net/mac80211/mesh_pathtbl.c b/net/mac80211/mesh_pathtbl.c
index 89aacfd..9ba6d8c 100644
--- a/net/mac80211/mesh_pathtbl.c
+++ b/net/mac80211/mesh_pathtbl.c
@@ -747,10 +747,8 @@ void mesh_plink_broken(struct sta_info *sta)
 static void mesh_path_node_reclaim(struct rcu_head *rp)
 {
 	struct mpath_node *node = container_of(rp, struct mpath_node, rcu);
-	struct ieee80211_sub_if_data *sdata = node->mpath->sdata;
 
 	del_timer_sync(&node->mpath->timer);
-	atomic_dec(&sdata->u.mesh.mpaths);
 	kfree(node->mpath);
 	kfree(node);
 }
@@ -758,8 +756,9 @@ static void mesh_path_node_reclaim(struct rcu_head *rp)
 /* needs to be called with the corresponding hashwlock taken */
 static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)
 {
-	struct mesh_path *mpath;
-	mpath = node->mpath;
+	struct mesh_path *mpath = node->mpath;
+	struct ieee80211_sub_if_data *sdata = node->mpath->sdata;
+
 	spin_lock(&mpath->state_lock);
 	mpath->flags |= MESH_PATH_RESOLVING;
 	if (mpath->is_gate)
@@ -767,6 +766,7 @@ static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)
 	hlist_del_rcu(&node->list);
 	call_rcu(&node->rcu, mesh_path_node_reclaim);
 	spin_unlock(&mpath->state_lock);
+	atomic_dec(&sdata->u.mesh.mpaths);
 	atomic_dec(&tbl->entries);
 }
 
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index e606e4a..952cb33 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -3074,7 +3074,7 @@ ieee80211_rx_mgmt_beacon(struct ieee80211_sub_if_data *sdata,
 
 	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
 	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
-		int sig = ifmgd->ave_beacon_signal;
+		int sig = ifmgd->ave_beacon_signal / 16;
 		int last_sig = ifmgd->last_ave_beacon_signal;
 
 		/*
diff --git a/net/mac80211/rc80211_minstrel_ht.c b/net/mac80211/rc80211_minstrel_ht.c
index f3bbea1..13f10aa 100644
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -454,7 +454,7 @@ minstrel_aggr_check(struct ieee80211_sta *pubsta, struct sk_buff *skb)
 	if (skb_get_queue_mapping(skb) == IEEE80211_AC_VO)
 		return;
 
-	ieee80211_start_tx_ba_session(pubsta, tid, 5000);
+	ieee80211_start_tx_ba_session(pubsta, tid, 0);
 }
 
 static void
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index 9299a38..cd60be8 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -2023,6 +2023,9 @@ ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)
 	hdr = (struct ieee80211_hdr *) skb->data;
 	mesh_hdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);
 
+	if (ieee80211_drop_unencrypted(rx, hdr->frame_control))
+		return RX_DROP_MONITOR;
+
 	/* frame is in RMC, don't forward */
 	if (ieee80211_is_data(hdr->frame_control) &&
 	    is_multicast_ether_addr(hdr->addr1) &&
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 10eea23..e960fbe 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -281,9 +281,6 @@ ieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)
 	if (tx->sdata->vif.type == NL80211_IFTYPE_WDS)
 		return TX_CONTINUE;
 
-	if (tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT)
-		return TX_CONTINUE;
-
 	if (tx->flags & IEEE80211_TX_PS_BUFFERED)
 		return TX_CONTINUE;
 
diff --git a/net/netfilter/ipvs/ip_vs_pe_sip.c b/net/netfilter/ipvs/ip_vs_pe_sip.c
index bed5f70..bb318e4 100644
--- a/net/netfilter/ipvs/ip_vs_pe_sip.c
+++ b/net/netfilter/ipvs/ip_vs_pe_sip.c
@@ -88,7 +88,7 @@ ip_vs_sip_fill_param(struct ip_vs_conn_param *p, struct sk_buff *skb)
 	dptr = skb->data + dataoff;
 	datalen = skb->len - dataoff;
 
-	if (get_callid(dptr, dataoff, datalen, &matchoff, &matchlen))
+	if (get_callid(dptr, 0, datalen, &matchoff, &matchlen))
 		return -EINVAL;
 
 	/* N.B: pe_data is only set on success,
diff --git a/net/netfilter/ipvs/ip_vs_sync.c b/net/netfilter/ipvs/ip_vs_sync.c
index e476cc7..19f9aa4 100644
--- a/net/netfilter/ipvs/ip_vs_sync.c
+++ b/net/netfilter/ipvs/ip_vs_sync.c
@@ -599,7 +599,7 @@ static void ip_vs_sync_conn_v0(struct net *net, struct ip_vs_conn *cp,
 			pkts = atomic_add_return(1, &cp->in_pkts);
 		else
 			pkts = sysctl_sync_threshold(ipvs);
-		ip_vs_sync_conn(net, cp->control, pkts);
+		ip_vs_sync_conn(net, cp, pkts);
 	}
 }
 
diff --git a/net/netfilter/ipvs/ip_vs_xmit.c b/net/netfilter/ipvs/ip_vs_xmit.c
index 1692e75..c3d2049 100644
--- a/net/netfilter/ipvs/ip_vs_xmit.c
+++ b/net/netfilter/ipvs/ip_vs_xmit.c
@@ -129,7 +129,6 @@ static struct rtable *do_output_route4(struct net *net, __be32 daddr,
 
 	memset(&fl4, 0, sizeof(fl4));
 	fl4.daddr = daddr;
-	fl4.saddr = (rt_mode & IP_VS_RT_MODE_CONNECT) ? *saddr : 0;
 	fl4.flowi4_flags = (rt_mode & IP_VS_RT_MODE_KNOWN_NH) ?
 			   FLOWI_FLAG_KNOWN_NH : 0;
 
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 0283bae..9dc979a 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -311,6 +311,21 @@ static void death_by_timeout(unsigned long ul_conntrack)
 	nf_ct_put(ct);
 }
 
+static inline bool
+nf_ct_key_equal(struct nf_conntrack_tuple_hash *h,
+			const struct nf_conntrack_tuple *tuple,
+			u16 zone)
+{
+	struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);
+
+	/* A conntrack can be recreated with the equal tuple,
+	 * so we need to check that the conntrack is confirmed
+	 */
+	return nf_ct_tuple_equal(tuple, &h->tuple) &&
+		nf_ct_zone(ct) == zone &&
+		nf_ct_is_confirmed(ct);
+}
+
 /*
  * Warning :
  * - Caller must take a reference on returned object
@@ -332,8 +347,7 @@ ____nf_conntrack_find(struct net *net, u16 zone,
 	local_bh_disable();
 begin:
 	hlist_nulls_for_each_entry_rcu(h, n, &net->ct.hash[bucket], hnnode) {
-		if (nf_ct_tuple_equal(tuple, &h->tuple) &&
-		    nf_ct_zone(nf_ct_tuplehash_to_ctrack(h)) == zone) {
+		if (nf_ct_key_equal(h, tuple, zone)) {
 			NF_CT_STAT_INC(net, found);
 			local_bh_enable();
 			return h;
@@ -380,8 +394,7 @@ begin:
 			     !atomic_inc_not_zero(&ct->ct_general.use)))
 			h = NULL;
 		else {
-			if (unlikely(!nf_ct_tuple_equal(tuple, &h->tuple) ||
-				     nf_ct_zone(ct) != zone)) {
+			if (unlikely(!nf_ct_key_equal(h, tuple, zone))) {
 				nf_ct_put(ct);
 				goto begin;
 			}
diff --git a/net/netfilter/nf_conntrack_expect.c b/net/netfilter/nf_conntrack_expect.c
index c63b618..95578da 100644
--- a/net/netfilter/nf_conntrack_expect.c
+++ b/net/netfilter/nf_conntrack_expect.c
@@ -202,7 +202,8 @@ static inline int expect_clash(const struct nf_conntrack_expect *a,
 			a->mask.src.u3.all[count] & b->mask.src.u3.all[count];
 	}
 
-	return nf_ct_tuple_mask_cmp(&a->tuple, &b->tuple, &intersect_mask);
+	return nf_ct_tuple_mask_cmp(&a->tuple, &b->tuple, &intersect_mask) &&
+	       nf_ct_zone(a->master) == nf_ct_zone(b->master);
 }
 
 static inline int expect_matches(const struct nf_conntrack_expect *a,
diff --git a/net/netfilter/nf_conntrack_proto_generic.c b/net/netfilter/nf_conntrack_proto_generic.c
index d25f293..957c1db 100644
--- a/net/netfilter/nf_conntrack_proto_generic.c
+++ b/net/netfilter/nf_conntrack_proto_generic.c
@@ -14,6 +14,30 @@
 
 static unsigned int nf_ct_generic_timeout __read_mostly = 600*HZ;
 
+static bool nf_generic_should_process(u8 proto)
+{
+	switch (proto) {
+#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE
+	case IPPROTO_SCTP:
+		return false;
+#endif
+#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE
+	case IPPROTO_DCCP:
+		return false;
+#endif
+#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE
+	case IPPROTO_GRE:
+		return false;
+#endif
+#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE
+	case IPPROTO_UDPLITE:
+		return false;
+#endif
+	default:
+		return true;
+	}
+}
+
 static inline struct nf_generic_net *generic_pernet(struct net *net)
 {
 	return &net->ct.nf_ct_proto.generic;
@@ -67,7 +91,7 @@ static int generic_packet(struct nf_conn *ct,
 static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 			unsigned int dataoff, unsigned int *timeouts)
 {
-	return true;
+	return nf_generic_should_process(nf_ct_protonum(ct));
 }
 
 #if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)
diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c
index a191b6d..3b283ed 100644
--- a/net/netfilter/nfnetlink_cthelper.c
+++ b/net/netfilter/nfnetlink_cthelper.c
@@ -74,6 +74,9 @@ nfnl_cthelper_parse_tuple(struct nf_conntrack_tuple *tuple,
 	if (!tb[NFCTH_TUPLE_L3PROTONUM] || !tb[NFCTH_TUPLE_L4PROTONUM])
 		return -EINVAL;
 
+	/* Not all fields are initialized so first zero the tuple */
+	memset(tuple, 0, sizeof(struct nf_conntrack_tuple));
+
 	tuple->src.l3num = ntohs(nla_get_be16(tb[NFCTH_TUPLE_L3PROTONUM]));
 	tuple->dst.protonum = nla_get_u8(tb[NFCTH_TUPLE_L4PROTONUM]);
 
@@ -83,7 +86,7 @@ nfnl_cthelper_parse_tuple(struct nf_conntrack_tuple *tuple,
 static int
 nfnl_cthelper_from_nlattr(struct nlattr *attr, struct nf_conn *ct)
 {
-	const struct nf_conn_help *help = nfct_help(ct);
+	struct nf_conn_help *help = nfct_help(ct);
 
 	if (attr == NULL)
 		return -EINVAL;
@@ -91,7 +94,7 @@ nfnl_cthelper_from_nlattr(struct nlattr *attr, struct nf_conn *ct)
 	if (help->helper->data_len == 0)
 		return -EINVAL;
 
-	memcpy(&help->data, nla_data(attr), help->helper->data_len);
+	memcpy(help->data, nla_data(attr), help->helper->data_len);
 	return 0;
 }
 
diff --git a/net/netfilter/nfnetlink_queue_core.c b/net/netfilter/nfnetlink_queue_core.c
index 2b8199f..5497f50 100644
--- a/net/netfilter/nfnetlink_queue_core.c
+++ b/net/netfilter/nfnetlink_queue_core.c
@@ -228,7 +228,7 @@ nfqnl_flush(struct nfqnl_instance *queue, nfqnl_cmpfn cmpfn, unsigned long data)
 }
 
 static int
-nfqnl_zcopy(struct sk_buff *to, const struct sk_buff *from, int len, int hlen)
+nfqnl_zcopy(struct sk_buff *to, struct sk_buff *from, int len, int hlen)
 {
 	int i, j = 0;
 	int plen = 0; /* length of skb->head fragment */
diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c
index 8b03028..51c141b 100644
--- a/net/netfilter/x_tables.c
+++ b/net/netfilter/x_tables.c
@@ -435,6 +435,47 @@ int xt_check_match(struct xt_mtchk_param *par,
 }
 EXPORT_SYMBOL_GPL(xt_check_match);
 
+/** xt_check_entry_match - check that matches end before start of target
+ *
+ * @match: beginning of xt_entry_match
+ * @target: beginning of this rules target (alleged end of matches)
+ * @alignment: alignment requirement of match structures
+ *
+ * Validates that all matches add up to the beginning of the target,
+ * and that each match covers at least the base structure size.
+ *
+ * Return: 0 on success, negative errno on failure.
+ */
+static int xt_check_entry_match(const char *match, const char *target,
+				const size_t alignment)
+{
+	const struct xt_entry_match *pos;
+	int length = target - match;
+
+	if (length == 0) /* no matches */
+		return 0;
+
+	pos = (struct xt_entry_match *)match;
+	do {
+		if ((unsigned long)pos % alignment)
+			return -EINVAL;
+
+		if (length < (int)sizeof(struct xt_entry_match))
+			return -EINVAL;
+
+		if (pos->u.match_size < sizeof(struct xt_entry_match))
+			return -EINVAL;
+
+		if (pos->u.match_size > length)
+			return -EINVAL;
+
+		length -= pos->u.match_size;
+		pos = ((void *)((char *)(pos) + (pos)->u.match_size));
+	} while (length > 0);
+
+	return 0;
+}
+
 #ifdef CONFIG_COMPAT
 int xt_compat_add_offset(u_int8_t af, unsigned int offset, int delta)
 {
@@ -504,13 +545,14 @@ int xt_compat_match_offset(const struct xt_match *match)
 }
 EXPORT_SYMBOL_GPL(xt_compat_match_offset);
 
-int xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
-			      unsigned int *size)
+void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
+			       unsigned int *size)
 {
 	const struct xt_match *match = m->u.kernel.match;
 	struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
 	int pad, off = xt_compat_match_offset(match);
 	u_int16_t msize = cm->u.user.match_size;
+	char name[sizeof(m->u.user.name)];
 
 	m = *dstptr;
 	memcpy(m, cm, sizeof(*cm));
@@ -524,10 +566,12 @@ int xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,
 
 	msize += off;
 	m->u.user.match_size = msize;
+	strlcpy(name, match->name, sizeof(name));
+	module_put(match->me);
+	strncpy(m->u.user.name, name, sizeof(m->u.user.name));
 
 	*size += off;
 	*dstptr += msize;
-	return 0;
 }
 EXPORT_SYMBOL_GPL(xt_compat_match_from_user);
 
@@ -558,8 +602,125 @@ int xt_compat_match_to_user(const struct xt_entry_match *m,
 	return 0;
 }
 EXPORT_SYMBOL_GPL(xt_compat_match_to_user);
+
+/* non-compat version may have padding after verdict */
+struct compat_xt_standard_target {
+	struct compat_xt_entry_target t;
+	compat_uint_t verdict;
+};
+
+int xt_compat_check_entry_offsets(const void *base, const char *elems,
+				  unsigned int target_offset,
+				  unsigned int next_offset)
+{
+	long size_of_base_struct = elems - (const char *)base;
+	const struct compat_xt_entry_target *t;
+	const char *e = base;
+
+	if (target_offset < size_of_base_struct)
+		return -EINVAL;
+
+	if (target_offset + sizeof(*t) > next_offset)
+		return -EINVAL;
+
+	t = (void *)(e + target_offset);
+	if (t->u.target_size < sizeof(*t))
+		return -EINVAL;
+
+	if (target_offset + t->u.target_size > next_offset)
+		return -EINVAL;
+
+	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
+	    COMPAT_XT_ALIGN(target_offset + sizeof(struct compat_xt_standard_target)) != next_offset)
+		return -EINVAL;
+
+	/* compat_xt_entry match has less strict aligment requirements,
+	 * otherwise they are identical.  In case of padding differences
+	 * we need to add compat version of xt_check_entry_match.
+	 */
+	BUILD_BUG_ON(sizeof(struct compat_xt_entry_match) != sizeof(struct xt_entry_match));
+
+	return xt_check_entry_match(elems, base + target_offset,
+				    __alignof__(struct compat_xt_entry_match));
+}
+EXPORT_SYMBOL(xt_compat_check_entry_offsets);
 #endif /* CONFIG_COMPAT */
 
+/**
+ * xt_check_entry_offsets - validate arp/ip/ip6t_entry
+ *
+ * @base: pointer to arp/ip/ip6t_entry
+ * @elems: pointer to first xt_entry_match, i.e. ip(6)t_entry->elems
+ * @target_offset: the arp/ip/ip6_t->target_offset
+ * @next_offset: the arp/ip/ip6_t->next_offset
+ *
+ * validates that target_offset and next_offset are sane and that all
+ * match sizes (if any) align with the target offset.
+ *
+ * This function does not validate the targets or matches themselves, it
+ * only tests that all the offsets and sizes are correct, that all
+ * match structures are aligned, and that the last structure ends where
+ * the target structure begins.
+ *
+ * Also see xt_compat_check_entry_offsets for CONFIG_COMPAT version.
+ *
+ * The arp/ip/ip6t_entry structure @base must have passed following tests:
+ * - it must point to a valid memory location
+ * - base to base + next_offset must be accessible, i.e. not exceed allocated
+ *   length.
+ *
+ * A well-formed entry looks like this:
+ *
+ * ip(6)t_entry   match [mtdata]  match [mtdata] target [tgdata] ip(6)t_entry
+ * e->elems[]-----'                              |               |
+ *                matchsize                      |               |
+ *                                matchsize      |               |
+ *                                               |               |
+ * target_offset---------------------------------'               |
+ * next_offset---------------------------------------------------'
+ *
+ * elems[]: flexible array member at end of ip(6)/arpt_entry struct.
+ *          This is where matches (if any) and the target reside.
+ * target_offset: beginning of target.
+ * next_offset: start of the next rule; also: size of this rule.
+ * Since targets have a minimum size, target_offset + minlen <= next_offset.
+ *
+ * Every match stores its size, sum of sizes must not exceed target_offset.
+ *
+ * Return: 0 on success, negative errno on failure.
+ */
+int xt_check_entry_offsets(const void *base,
+			   const char *elems,
+			   unsigned int target_offset,
+			   unsigned int next_offset)
+{
+	long size_of_base_struct = elems - (const char *)base;
+	const struct xt_entry_target *t;
+	const char *e = base;
+
+	/* target start is within the ip/ip6/arpt_entry struct */
+	if (target_offset < size_of_base_struct)
+		return -EINVAL;
+
+	if (target_offset + sizeof(*t) > next_offset)
+		return -EINVAL;
+
+	t = (void *)(e + target_offset);
+	if (t->u.target_size < sizeof(*t))
+		return -EINVAL;
+
+	if (target_offset + t->u.target_size > next_offset)
+		return -EINVAL;
+
+	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
+	    XT_ALIGN(target_offset + sizeof(struct xt_standard_target)) != next_offset)
+		return -EINVAL;
+
+	return xt_check_entry_match(elems, base + target_offset,
+				    __alignof__(struct xt_entry_match));
+}
+EXPORT_SYMBOL(xt_check_entry_offsets);
+
 int xt_check_target(struct xt_tgchk_param *par,
 		    unsigned int size, u_int8_t proto, bool inv_proto)
 {
@@ -610,6 +771,80 @@ int xt_check_target(struct xt_tgchk_param *par,
 }
 EXPORT_SYMBOL_GPL(xt_check_target);
 
+/**
+ * xt_copy_counters_from_user - copy counters and metadata from userspace
+ *
+ * @user: src pointer to userspace memory
+ * @len: alleged size of userspace memory
+ * @info: where to store the xt_counters_info metadata
+ * @compat: true if we setsockopt call is done by 32bit task on 64bit kernel
+ *
+ * Copies counter meta data from @user and stores it in @info.
+ *
+ * vmallocs memory to hold the counters, then copies the counter data
+ * from @user to the new memory and returns a pointer to it.
+ *
+ * If @compat is true, @info gets converted automatically to the 64bit
+ * representation.
+ *
+ * The metadata associated with the counters is stored in @info.
+ *
+ * Return: returns pointer that caller has to test via IS_ERR().
+ * If IS_ERR is false, caller has to vfree the pointer.
+ */
+void *xt_copy_counters_from_user(const void __user *user, unsigned int len,
+				 struct xt_counters_info *info, bool compat)
+{
+	void *mem;
+	u64 size;
+
+#ifdef CONFIG_COMPAT
+	if (compat) {
+		/* structures only differ in size due to alignment */
+		struct compat_xt_counters_info compat_tmp;
+
+		if (len <= sizeof(compat_tmp))
+			return ERR_PTR(-EINVAL);
+
+		len -= sizeof(compat_tmp);
+		if (copy_from_user(&compat_tmp, user, sizeof(compat_tmp)) != 0)
+			return ERR_PTR(-EFAULT);
+
+		strlcpy(info->name, compat_tmp.name, sizeof(info->name));
+		info->num_counters = compat_tmp.num_counters;
+		user += sizeof(compat_tmp);
+	} else
+#endif
+	{
+		if (len <= sizeof(*info))
+			return ERR_PTR(-EINVAL);
+
+		len -= sizeof(*info);
+		if (copy_from_user(info, user, sizeof(*info)) != 0)
+			return ERR_PTR(-EFAULT);
+
+		info->name[sizeof(info->name) - 1] = '\0';
+		user += sizeof(*info);
+	}
+
+	size = sizeof(struct xt_counters);
+	size *= info->num_counters;
+
+	if (size != (u64)len)
+		return ERR_PTR(-EINVAL);
+
+	mem = vmalloc(len);
+	if (!mem)
+		return ERR_PTR(-ENOMEM);
+
+	if (copy_from_user(mem, user, len) == 0)
+		return mem;
+
+	vfree(mem);
+	return ERR_PTR(-EFAULT);
+}
+EXPORT_SYMBOL_GPL(xt_copy_counters_from_user);
+
 #ifdef CONFIG_COMPAT
 int xt_compat_target_offset(const struct xt_target *target)
 {
@@ -625,6 +860,7 @@ void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
 	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
 	int pad, off = xt_compat_target_offset(target);
 	u_int16_t tsize = ct->u.user.target_size;
+	char name[sizeof(t->u.user.name)];
 
 	t = *dstptr;
 	memcpy(t, ct, sizeof(*ct));
@@ -638,6 +874,9 @@ void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,
 
 	tsize += off;
 	t->u.user.target_size = tsize;
+	strlcpy(name, target->name, sizeof(name));
+	module_put(target->me);
+	strncpy(t->u.user.name, name, sizeof(t->u.user.name));
 
 	*size += off;
 	*dstptr += tsize;
diff --git a/net/netlabel/netlabel_kapi.c b/net/netlabel/netlabel_kapi.c
index 7c94aed..5b1fbe4 100644
--- a/net/netlabel/netlabel_kapi.c
+++ b/net/netlabel/netlabel_kapi.c
@@ -700,7 +700,11 @@ socket_setattr_return:
  */
 void netlbl_sock_delattr(struct sock *sk)
 {
-	cipso_v4_sock_delattr(sk);
+	switch (sk->sk_family) {
+	case AF_INET:
+		cipso_v4_sock_delattr(sk);
+		break;
+	}
 }
 
 /**
@@ -879,7 +883,11 @@ req_setattr_return:
 */
 void netlbl_req_delattr(struct request_sock *req)
 {
-	cipso_v4_req_delattr(req);
+	switch (req->rsk_ops->family) {
+	case AF_INET:
+		cipso_v4_req_delattr(req);
+		break;
+	}
 }
 
 /**
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index f7ad5c6..56ff3b4 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -214,25 +214,52 @@ err1:
 	return NULL;
 }
 
+
+static void
+__netlink_set_ring(struct sock *sk, struct nl_mmap_req *req, bool tx_ring, void **pg_vec,
+		   unsigned int order)
+{
+	struct netlink_sock *nlk = nlk_sk(sk);
+	struct sk_buff_head *queue;
+	struct netlink_ring *ring;
+
+	queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;
+	ring  = tx_ring ? &nlk->tx_ring : &nlk->rx_ring;
+
+	spin_lock_bh(&queue->lock);
+
+	ring->frame_max		= req->nm_frame_nr - 1;
+	ring->head		= 0;
+	ring->frame_size	= req->nm_frame_size;
+	ring->pg_vec_pages	= req->nm_block_size / PAGE_SIZE;
+
+	swap(ring->pg_vec_len, req->nm_block_nr);
+	swap(ring->pg_vec_order, order);
+	swap(ring->pg_vec, pg_vec);
+
+	__skb_queue_purge(queue);
+	spin_unlock_bh(&queue->lock);
+
+	WARN_ON(atomic_read(&nlk->mapped));
+
+	if (pg_vec)
+		free_pg_vec(pg_vec, order, req->nm_block_nr);
+}
+
 static int netlink_set_ring(struct sock *sk, struct nl_mmap_req *req,
-			    bool closing, bool tx_ring)
+			    bool tx_ring)
 {
 	struct netlink_sock *nlk = nlk_sk(sk);
 	struct netlink_ring *ring;
-	struct sk_buff_head *queue;
 	void **pg_vec = NULL;
 	unsigned int order = 0;
-	int err;
 
 	ring  = tx_ring ? &nlk->tx_ring : &nlk->rx_ring;
-	queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;
 
-	if (!closing) {
-		if (atomic_read(&nlk->mapped))
-			return -EBUSY;
-		if (atomic_read(&ring->pending))
-			return -EBUSY;
-	}
+	if (atomic_read(&nlk->mapped))
+		return -EBUSY;
+	if (atomic_read(&ring->pending))
+		return -EBUSY;
 
 	if (req->nm_block_nr) {
 		if (ring->pg_vec != NULL)
@@ -264,31 +291,19 @@ static int netlink_set_ring(struct sock *sk, struct nl_mmap_req *req,
 			return -EINVAL;
 	}
 
-	err = -EBUSY;
 	mutex_lock(&nlk->pg_vec_lock);
-	if (closing || atomic_read(&nlk->mapped) == 0) {
-		err = 0;
-		spin_lock_bh(&queue->lock);
-
-		ring->frame_max		= req->nm_frame_nr - 1;
-		ring->head		= 0;
-		ring->frame_size	= req->nm_frame_size;
-		ring->pg_vec_pages	= req->nm_block_size / PAGE_SIZE;
-
-		swap(ring->pg_vec_len, req->nm_block_nr);
-		swap(ring->pg_vec_order, order);
-		swap(ring->pg_vec, pg_vec);
-
-		__skb_queue_purge(queue);
-		spin_unlock_bh(&queue->lock);
-
-		WARN_ON(atomic_read(&nlk->mapped));
+	if (atomic_read(&nlk->mapped) == 0) {
+		__netlink_set_ring(sk, req, tx_ring, pg_vec, order);
+		mutex_unlock(&nlk->pg_vec_lock);
+		return 0;
 	}
+
 	mutex_unlock(&nlk->pg_vec_lock);
 
 	if (pg_vec)
 		free_pg_vec(pg_vec, order, req->nm_block_nr);
-	return err;
+
+	return -EBUSY;
 }
 
 static void netlink_mm_open(struct vm_area_struct *vma)
@@ -762,10 +777,10 @@ static void netlink_sock_destruct(struct sock *sk)
 
 		memset(&req, 0, sizeof(req));
 		if (nlk->rx_ring.pg_vec)
-			netlink_set_ring(sk, &req, true, false);
+			__netlink_set_ring(sk, &req, false, NULL, 0);
 		memset(&req, 0, sizeof(req));
 		if (nlk->tx_ring.pg_vec)
-			netlink_set_ring(sk, &req, true, true);
+			__netlink_set_ring(sk, &req, true, NULL, 0);
 	}
 #endif /* CONFIG_NETLINK_MMAP */
 
@@ -2017,7 +2032,7 @@ static int netlink_setsockopt(struct socket *sock, int level, int optname,
 			return -EINVAL;
 		if (copy_from_user(&req, optval, sizeof(req)))
 			return -EFAULT;
-		err = netlink_set_ring(sk, &req, false,
+		err = netlink_set_ring(sk, &req,
 				       optname == NETLINK_TX_RING);
 		break;
 	}
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 81b4b81..2d454a2 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -1150,16 +1150,6 @@ static void packet_sock_destruct(struct sock *sk)
 	sk_refcnt_debug_dec(sk);
 }
 
-static int fanout_rr_next(struct packet_fanout *f, unsigned int num)
-{
-	int x = atomic_read(&f->rr_cur) + 1;
-
-	if (x >= num)
-		x = 0;
-
-	return x;
-}
-
 static unsigned int fanout_demux_hash(struct packet_fanout *f,
 				      struct sk_buff *skb,
 				      unsigned int num)
@@ -1171,13 +1161,9 @@ static unsigned int fanout_demux_lb(struct packet_fanout *f,
 				    struct sk_buff *skb,
 				    unsigned int num)
 {
-	int cur, old;
+	unsigned int val = atomic_inc_return(&f->rr_cur);
 
-	cur = atomic_read(&f->rr_cur);
-	while ((old = atomic_cmpxchg(&f->rr_cur, cur,
-				     fanout_rr_next(f, num))) != cur)
-		cur = old;
-	return cur;
+	return val % num;
 }
 
 static unsigned int fanout_demux_cpu(struct packet_fanout *f,
@@ -1217,7 +1203,7 @@ static int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,
 			     struct packet_type *pt, struct net_device *orig_dev)
 {
 	struct packet_fanout *f = pt->af_packet_priv;
-	unsigned int num = f->num_members;
+	unsigned int num = ACCESS_ONCE(f->num_members);
 	struct packet_sock *po;
 	unsigned int idx;
 
@@ -3011,6 +2997,7 @@ static int packet_mc_add(struct sock *sk, struct packet_mreq_max *mreq)
 	i->ifindex = mreq->mr_ifindex;
 	i->alen = mreq->mr_alen;
 	memcpy(i->addr, mreq->mr_address, i->alen);
+	memset(i->addr + i->alen, 0, sizeof(i->addr) - i->alen);
 	i->count = 1;
 	i->next = po->mclist;
 	po->mclist = i;
diff --git a/net/phonet/af_phonet.c b/net/phonet/af_phonet.c
index 5a940db..f022922 100644
--- a/net/phonet/af_phonet.c
+++ b/net/phonet/af_phonet.c
@@ -377,6 +377,10 @@ static int phonet_rcv(struct sk_buff *skb, struct net_device *dev,
 	struct sockaddr_pn sa;
 	u16 len;
 
+	skb = skb_share_check(skb, GFP_ATOMIC);
+	if (!skb)
+		return NET_RX_DROP;
+
 	/* check we have at least a full Phonet header */
 	if (!pskb_pull(skb, sizeof(struct phonethdr)))
 		goto out;
diff --git a/net/rds/ib_rdma.c b/net/rds/ib_rdma.c
index e8fdb17..a985158 100644
--- a/net/rds/ib_rdma.c
+++ b/net/rds/ib_rdma.c
@@ -759,8 +759,10 @@ void *rds_ib_get_mr(struct scatterlist *sg, unsigned long nents,
 	}
 
 	ibmr = rds_ib_alloc_fmr(rds_ibdev);
-	if (IS_ERR(ibmr))
+	if (IS_ERR(ibmr)) {
+		rds_ib_dev_put(rds_ibdev);
 		return ibmr;
+	}
 
 	ret = rds_ib_map_fmr(rds_ibdev, ibmr, sg, nents);
 	if (ret == 0)
diff --git a/net/rds/info.c b/net/rds/info.c
index 9a6b4f6..140a44a 100644
--- a/net/rds/info.c
+++ b/net/rds/info.c
@@ -176,7 +176,7 @@ int rds_info_getsockopt(struct socket *sock, int optname, char __user *optval,
 
 	/* check for all kinds of wrapping and the like */
 	start = (unsigned long)optval;
-	if (len < 0 || len + PAGE_SIZE - 1 < len || start + len < start) {
+	if (len < 0 || len > INT_MAX - PAGE_SIZE + 1 || start + len < start) {
 		ret = -EINVAL;
 		goto out;
 	}
diff --git a/net/rds/send.c b/net/rds/send.c
index 88eace5..31c9fa4 100644
--- a/net/rds/send.c
+++ b/net/rds/send.c
@@ -955,11 +955,13 @@ int rds_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
 		release_sock(sk);
 	}
 
-	/* racing with another thread binding seems ok here */
+	lock_sock(sk);
 	if (daddr == 0 || rs->rs_bound_addr == 0) {
+		release_sock(sk);
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}
+	release_sock(sk);
 
 	/* size of rm including all sgs */
 	ret = rds_rm_size(msg, payload_len);
diff --git a/net/rds/sysctl.c b/net/rds/sysctl.c
index 907214b..fc6cbe8 100644
--- a/net/rds/sysctl.c
+++ b/net/rds/sysctl.c
@@ -71,14 +71,14 @@ static ctl_table rds_sysctl_rds_table[] = {
 	{
 		.procname	= "max_unacked_packets",
 		.data		= &rds_sysctl_max_unacked_packets,
-		.maxlen         = sizeof(unsigned long),
+		.maxlen         = sizeof(int),
 		.mode           = 0644,
 		.proc_handler   = proc_dointvec,
 	},
 	{
 		.procname	= "max_unacked_bytes",
 		.data		= &rds_sysctl_max_unacked_bytes,
-		.maxlen         = sizeof(unsigned long),
+		.maxlen         = sizeof(int),
 		.mode           = 0644,
 		.proc_handler   = proc_dointvec,
 	},
diff --git a/net/rds/tcp_recv.c b/net/rds/tcp_recv.c
index 4fac4f2..8b33d99 100644
--- a/net/rds/tcp_recv.c
+++ b/net/rds/tcp_recv.c
@@ -234,8 +234,15 @@ static int rds_tcp_data_recv(read_descriptor_t *desc, struct sk_buff *skb,
 			}
 
 			to_copy = min(tc->t_tinc_data_rem, left);
-			pskb_pull(clone, offset);
-			pskb_trim(clone, to_copy);
+			if (!pskb_pull(clone, offset) ||
+			    pskb_trim(clone, to_copy)) {
+				pr_warn("rds_tcp_data_recv: pull/trim failed "
+					"left %zu data_rem %zu skb_len %d\n",
+					left, tc->t_tinc_data_rem, skb->len);
+				kfree_skb(clone);
+				desc->error = -ENOMEM;
+				goto out;
+			}
 			skb_queue_tail(&tinc->ti_skb_list, clone);
 
 			rdsdebug("skb %p data %p len %d off %u to_copy %zu -> "
diff --git a/net/rfkill/core.c b/net/rfkill/core.c
index 1cec5e4..6563cc0 100644
--- a/net/rfkill/core.c
+++ b/net/rfkill/core.c
@@ -51,7 +51,6 @@
 struct rfkill {
 	spinlock_t		lock;
 
-	const char		*name;
 	enum rfkill_type	type;
 
 	unsigned long		state;
@@ -75,6 +74,7 @@ struct rfkill {
 	struct delayed_work	poll_work;
 	struct work_struct	uevent_work;
 	struct work_struct	sync_work;
+	char			name[];
 };
 #define to_rfkill(d)	container_of(d, struct rfkill, dev)
 
@@ -871,14 +871,14 @@ struct rfkill * __must_check rfkill_alloc(const char *name,
 	if (WARN_ON(type == RFKILL_TYPE_ALL || type >= NUM_RFKILL_TYPES))
 		return NULL;
 
-	rfkill = kzalloc(sizeof(*rfkill), GFP_KERNEL);
+	rfkill = kzalloc(sizeof(*rfkill) + strlen(name) + 1, GFP_KERNEL);
 	if (!rfkill)
 		return NULL;
 
 	spin_lock_init(&rfkill->lock);
 	INIT_LIST_HEAD(&rfkill->node);
 	rfkill->type = type;
-	rfkill->name = name;
+	strcpy(rfkill->name, name);
 	rfkill->ops = ops;
 	rfkill->data = ops_data;
 
@@ -1088,17 +1088,6 @@ static unsigned int rfkill_fop_poll(struct file *file, poll_table *wait)
 	return res;
 }
 
-static bool rfkill_readable(struct rfkill_data *data)
-{
-	bool r;
-
-	mutex_lock(&data->mtx);
-	r = !list_empty(&data->events);
-	mutex_unlock(&data->mtx);
-
-	return r;
-}
-
 static ssize_t rfkill_fop_read(struct file *file, char __user *buf,
 			       size_t count, loff_t *pos)
 {
@@ -1115,8 +1104,11 @@ static ssize_t rfkill_fop_read(struct file *file, char __user *buf,
 			goto out;
 		}
 		mutex_unlock(&data->mtx);
+		/* since we re-check and it just compares pointers,
+		 * using !list_empty() without locking isn't a problem
+		 */
 		ret = wait_event_interruptible(data->read_wait,
-					       rfkill_readable(data));
+					       !list_empty(&data->events));
 		mutex_lock(&data->mtx);
 
 		if (ret)
diff --git a/net/rfkill/rfkill-regulator.c b/net/rfkill/rfkill-regulator.c
index d11ac79..cf5b145 100644
--- a/net/rfkill/rfkill-regulator.c
+++ b/net/rfkill/rfkill-regulator.c
@@ -30,6 +30,7 @@ struct rfkill_regulator_data {
 static int rfkill_regulator_set_block(void *data, bool blocked)
 {
 	struct rfkill_regulator_data *rfkill_data = data;
+	int ret = 0;
 
 	pr_debug("%s: blocked: %d\n", __func__, blocked);
 
@@ -40,15 +41,16 @@ static int rfkill_regulator_set_block(void *data, bool blocked)
 		}
 	} else {
 		if (!rfkill_data->reg_enabled) {
-			regulator_enable(rfkill_data->vcc);
-			rfkill_data->reg_enabled = true;
+			ret = regulator_enable(rfkill_data->vcc);
+			if (!ret)
+				rfkill_data->reg_enabled = true;
 		}
 	}
 
 	pr_debug("%s: regulator_is_enabled after set_block: %d\n", __func__,
 		regulator_is_enabled(rfkill_data->vcc));
 
-	return 0;
+	return ret;
 }
 
 static struct rfkill_ops rfkill_regulator_ops = {
diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c
index 2d2f079..e87b27c7 100644
--- a/net/sched/sch_api.c
+++ b/net/sched/sch_api.c
@@ -752,10 +752,8 @@ static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,
 		if (dev->flags & IFF_UP)
 			dev_deactivate(dev);
 
-		if (new && new->ops->attach) {
-			new->ops->attach(new);
-			num_q = 0;
-		}
+		if (new && new->ops->attach)
+			goto skip;
 
 		for (i = 0; i < num_q; i++) {
 			struct netdev_queue *dev_queue = dev_ingress_queue(dev);
@@ -771,12 +769,16 @@ static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,
 				qdisc_destroy(old);
 		}
 
+skip:
 		if (!ingress) {
 			notify_and_destroy(net, skb, n, classid,
 					   dev->qdisc, new);
 			if (new && !new->ops->attach)
 				atomic_inc(&new->refcnt);
 			dev->qdisc = new ? : &noop_qdisc;
+
+			if (new && new->ops->attach)
+				new->ops->attach(new);
 		} else {
 			notify_and_destroy(net, skb, n, classid, old, new);
 		}
diff --git a/net/sctp/auth.c b/net/sctp/auth.c
index bc2fae7..62433f7 100644
--- a/net/sctp/auth.c
+++ b/net/sctp/auth.c
@@ -812,8 +812,8 @@ int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,
 	if (!has_sha1)
 		return -EINVAL;
 
-	memcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],
-		hmacs->shmac_num_idents * sizeof(__u16));
+	for (i = 0; i < hmacs->shmac_num_idents; i++)
+		ep->auth_hmacs_list->hmac_ids[i] = htons(hmacs->shmac_idents[i]);
 	ep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +
 				hmacs->shmac_num_idents * sizeof(__u16));
 	return 0;
diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c
index 422d8bd..10d3e28 100644
--- a/net/sctp/ipv6.c
+++ b/net/sctp/ipv6.c
@@ -520,6 +520,8 @@ static int sctp_v6_cmp_addr(const union sctp_addr *addr1,
 		}
 		return 0;
 	}
+	if (addr1->v6.sin6_port != addr2->v6.sin6_port)
+		return 0;
 	if (!ipv6_addr_equal(&addr1->v6.sin6_addr, &addr2->v6.sin6_addr))
 		return 0;
 	/* If this is a linklocal address, compare the scope_id. */
@@ -639,6 +641,7 @@ static struct sock *sctp_v6_create_accept_sk(struct sock *sk,
 	struct sock *newsk;
 	struct ipv6_pinfo *newnp, *np = inet6_sk(sk);
 	struct sctp6_sock *newsctp6sk;
+	struct ipv6_txoptions *opt;
 
 	newsk = sk_alloc(sock_net(sk), PF_INET6, GFP_KERNEL, sk->sk_prot);
 	if (!newsk)
@@ -658,6 +661,13 @@ static struct sock *sctp_v6_create_accept_sk(struct sock *sk,
 
 	memcpy(newnp, np, sizeof(struct ipv6_pinfo));
 
+	rcu_read_lock();
+	opt = rcu_dereference(np->opt);
+	if (opt)
+		opt = ipv6_dup_options(newsk, opt);
+	RCU_INIT_POINTER(newnp->opt, opt);
+	rcu_read_unlock();
+
 	/* Initialize sk's sport, dport, rcv_saddr and daddr for getsockname()
 	 * and getpeername().
 	 */
diff --git a/net/sctp/output.c b/net/sctp/output.c
index 73b8ca5..2d96893 100644
--- a/net/sctp/output.c
+++ b/net/sctp/output.c
@@ -618,7 +618,9 @@ out:
 	return err;
 no_route:
 	kfree_skb(nskb);
-	IP_INC_STATS(sock_net(asoc->base.sk), IPSTATS_MIB_OUTNOROUTES);
+
+	if (asoc)
+		IP_INC_STATS(sock_net(asoc->base.sk), IPSTATS_MIB_OUTNOROUTES);
 
 	/* FIXME: Returning the 'err' will effect all the associations
 	 * associated with a socket, although only one of the paths of the
diff --git a/net/sctp/protocol.c b/net/sctp/protocol.c
index 5a3c1c0..57c2c4c 100644
--- a/net/sctp/protocol.c
+++ b/net/sctp/protocol.c
@@ -1170,7 +1170,7 @@ static void sctp_v4_del_protocol(void)
 	unregister_inetaddr_notifier(&sctp_inetaddr_notifier);
 }
 
-static int __net_init sctp_net_init(struct net *net)
+static int __net_init sctp_defaults_init(struct net *net)
 {
 	int status;
 
@@ -1263,12 +1263,6 @@ static int __net_init sctp_net_init(struct net *net)
 
 	sctp_dbg_objcnt_init(net);
 
-	/* Initialize the control inode/socket for handling OOTB packets.  */
-	if ((status = sctp_ctl_sock_init(net))) {
-		pr_err("Failed to initialize the SCTP control sock\n");
-		goto err_ctl_sock_init;
-	}
-
 	/* Initialize the local address list. */
 	INIT_LIST_HEAD(&net->sctp.local_addr_list);
 	spin_lock_init(&net->sctp.local_addr_lock);
@@ -1284,9 +1278,6 @@ static int __net_init sctp_net_init(struct net *net)
 
 	return 0;
 
-err_ctl_sock_init:
-	sctp_dbg_objcnt_exit(net);
-	sctp_proc_exit(net);
 err_init_proc:
 	cleanup_sctp_mibs(net);
 err_init_mibs:
@@ -1295,15 +1286,12 @@ err_sysctl_register:
 	return status;
 }
 
-static void __net_exit sctp_net_exit(struct net *net)
+static void __net_exit sctp_defaults_exit(struct net *net)
 {
 	/* Free the local address list */
 	sctp_free_addr_wq(net);
 	sctp_free_local_addr_list(net);
 
-	/* Free the control endpoint.  */
-	inet_ctl_sock_destroy(net->sctp.ctl_sock);
-
 	sctp_dbg_objcnt_exit(net);
 
 	sctp_proc_exit(net);
@@ -1311,9 +1299,32 @@ static void __net_exit sctp_net_exit(struct net *net)
 	sctp_sysctl_net_unregister(net);
 }
 
-static struct pernet_operations sctp_net_ops = {
-	.init = sctp_net_init,
-	.exit = sctp_net_exit,
+static struct pernet_operations sctp_defaults_ops = {
+	.init = sctp_defaults_init,
+	.exit = sctp_defaults_exit,
+};
+
+static int __net_init sctp_ctrlsock_init(struct net *net)
+{
+	int status;
+
+	/* Initialize the control inode/socket for handling OOTB packets.  */
+	status = sctp_ctl_sock_init(net);
+	if (status)
+		pr_err("Failed to initialize the SCTP control sock\n");
+
+	return status;
+}
+
+static void __net_init sctp_ctrlsock_exit(struct net *net)
+{
+	/* Free the control endpoint.  */
+	inet_ctl_sock_destroy(net->sctp.ctl_sock);
+}
+
+static struct pernet_operations sctp_ctrlsock_ops = {
+	.init = sctp_ctrlsock_init,
+	.exit = sctp_ctrlsock_exit,
 };
 
 /* Initialize the universe into something sensible.  */
@@ -1448,8 +1459,11 @@ SCTP_STATIC __init int sctp_init(void)
 	sctp_v4_pf_init();
 	sctp_v6_pf_init();
 
-	status = sctp_v4_protosw_init();
+	status = register_pernet_subsys(&sctp_defaults_ops);
+	if (status)
+		goto err_register_defaults;
 
+	status = sctp_v4_protosw_init();
 	if (status)
 		goto err_protosw_init;
 
@@ -1457,9 +1471,9 @@ SCTP_STATIC __init int sctp_init(void)
 	if (status)
 		goto err_v6_protosw_init;
 
-	status = register_pernet_subsys(&sctp_net_ops);
+	status = register_pernet_subsys(&sctp_ctrlsock_ops);
 	if (status)
-		goto err_register_pernet_subsys;
+		goto err_register_ctrlsock;
 
 	status = sctp_v4_add_protocol();
 	if (status)
@@ -1476,12 +1490,14 @@ out:
 err_v6_add_protocol:
 	sctp_v4_del_protocol();
 err_add_protocol:
-	unregister_pernet_subsys(&sctp_net_ops);
-err_register_pernet_subsys:
+	unregister_pernet_subsys(&sctp_ctrlsock_ops);
+err_register_ctrlsock:
 	sctp_v6_protosw_exit();
 err_v6_protosw_init:
 	sctp_v4_protosw_exit();
 err_protosw_init:
+	unregister_pernet_subsys(&sctp_defaults_ops);
+err_register_defaults:
 	sctp_v4_pf_exit();
 	sctp_v6_pf_exit();
 	sctp_sysctl_unregister();
@@ -1514,12 +1530,14 @@ SCTP_STATIC __exit void sctp_exit(void)
 	sctp_v6_del_protocol();
 	sctp_v4_del_protocol();
 
-	unregister_pernet_subsys(&sctp_net_ops);
+	unregister_pernet_subsys(&sctp_ctrlsock_ops);
 
 	/* Free protosw registrations */
 	sctp_v6_protosw_exit();
 	sctp_v4_protosw_exit();
 
+	unregister_pernet_subsys(&sctp_defaults_ops);
+
 	/* Unregister with socket layer. */
 	sctp_v6_pf_exit();
 	sctp_v4_pf_exit();
diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c
index 8aab894..730914c 100644
--- a/net/sctp/sm_sideeffect.c
+++ b/net/sctp/sm_sideeffect.c
@@ -251,12 +251,13 @@ void sctp_generate_t3_rtx_event(unsigned long peer)
 	int error;
 	struct sctp_transport *transport = (struct sctp_transport *) peer;
 	struct sctp_association *asoc = transport->asoc;
-	struct net *net = sock_net(asoc->base.sk);
+	struct sock *sk = asoc->base.sk;
+	struct net *net = sock_net(sk);
 
 	/* Check whether a task is in the sock.  */
 
-	sctp_bh_lock_sock(asoc->base.sk);
-	if (sock_owned_by_user(asoc->base.sk)) {
+	sctp_bh_lock_sock(sk);
+	if (sock_owned_by_user(sk)) {
 		SCTP_DEBUG_PRINTK("%s:Sock is busy.\n", __func__);
 
 		/* Try again later.  */
@@ -279,10 +280,10 @@ void sctp_generate_t3_rtx_event(unsigned long peer)
 			   transport, GFP_ATOMIC);
 
 	if (error)
-		asoc->base.sk->sk_err = -error;
+		sk->sk_err = -error;
 
 out_unlock:
-	sctp_bh_unlock_sock(asoc->base.sk);
+	sctp_bh_unlock_sock(sk);
 	sctp_transport_put(transport);
 }
 
@@ -292,11 +293,12 @@ out_unlock:
 static void sctp_generate_timeout_event(struct sctp_association *asoc,
 					sctp_event_timeout_t timeout_type)
 {
-	struct net *net = sock_net(asoc->base.sk);
+	struct sock *sk = asoc->base.sk;
+	struct net *net = sock_net(sk);
 	int error = 0;
 
-	sctp_bh_lock_sock(asoc->base.sk);
-	if (sock_owned_by_user(asoc->base.sk)) {
+	sctp_bh_lock_sock(sk);
+	if (sock_owned_by_user(sk)) {
 		SCTP_DEBUG_PRINTK("%s:Sock is busy: timer %d\n",
 				  __func__,
 				  timeout_type);
@@ -320,10 +322,10 @@ static void sctp_generate_timeout_event(struct sctp_association *asoc,
 			   (void *)timeout_type, GFP_ATOMIC);
 
 	if (error)
-		asoc->base.sk->sk_err = -error;
+		sk->sk_err = -error;
 
 out_unlock:
-	sctp_bh_unlock_sock(asoc->base.sk);
+	sctp_bh_unlock_sock(sk);
 	sctp_association_put(asoc);
 }
 
@@ -373,10 +375,11 @@ void sctp_generate_heartbeat_event(unsigned long data)
 	int error = 0;
 	struct sctp_transport *transport = (struct sctp_transport *) data;
 	struct sctp_association *asoc = transport->asoc;
-	struct net *net = sock_net(asoc->base.sk);
+	struct sock *sk = asoc->base.sk;
+	struct net *net = sock_net(sk);
 
-	sctp_bh_lock_sock(asoc->base.sk);
-	if (sock_owned_by_user(asoc->base.sk)) {
+	sctp_bh_lock_sock(sk);
+	if (sock_owned_by_user(sk)) {
 		SCTP_DEBUG_PRINTK("%s:Sock is busy.\n", __func__);
 
 		/* Try again later.  */
@@ -397,10 +400,10 @@ void sctp_generate_heartbeat_event(unsigned long data)
 			   transport, GFP_ATOMIC);
 
 	 if (error)
-		 asoc->base.sk->sk_err = -error;
+		 sk->sk_err = -error;
 
 out_unlock:
-	sctp_bh_unlock_sock(asoc->base.sk);
+	sctp_bh_unlock_sock(sk);
 	sctp_transport_put(transport);
 }
 
@@ -411,10 +414,11 @@ void sctp_generate_proto_unreach_event(unsigned long data)
 {
 	struct sctp_transport *transport = (struct sctp_transport *) data;
 	struct sctp_association *asoc = transport->asoc;
-	struct net *net = sock_net(asoc->base.sk);
+	struct sock *sk = asoc->base.sk;
+	struct net *net = sock_net(sk);
 	
-	sctp_bh_lock_sock(asoc->base.sk);
-	if (sock_owned_by_user(asoc->base.sk)) {
+	sctp_bh_lock_sock(sk);
+	if (sock_owned_by_user(sk)) {
 		SCTP_DEBUG_PRINTK("%s:Sock is busy.\n", __func__);
 
 		/* Try again later.  */
@@ -435,7 +439,7 @@ void sctp_generate_proto_unreach_event(unsigned long data)
 		   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);
 
 out_unlock:
-	sctp_bh_unlock_sock(asoc->base.sk);
+	sctp_bh_unlock_sock(sk);
 	sctp_association_put(asoc);
 }
 
diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c
index c52763a..d9cbecb 100644
--- a/net/sctp/sm_statefuns.c
+++ b/net/sctp/sm_statefuns.c
@@ -4835,7 +4835,8 @@ sctp_disposition_t sctp_sf_do_9_1_prm_abort(
 
 	retval = SCTP_DISPOSITION_CONSUME;
 
-	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));
+	if (abort)
+		sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));
 
 	/* Even if we can't send the ABORT due to low memory delete the
 	 * TCB.  This is a departure from our typical NOMEM handling.
@@ -4972,7 +4973,8 @@ sctp_disposition_t sctp_sf_cookie_wait_prm_abort(
 			SCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));
 	retval = SCTP_DISPOSITION_CONSUME;
 
-	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));
+	if (abort)
+		sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));
 
 	sctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,
 			SCTP_STATE(SCTP_STATE_CLOSED));
diff --git a/net/sctp/socket.c b/net/sctp/socket.c
index dfb9b13..bdc3fb6 100644
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@ -1533,8 +1533,7 @@ SCTP_STATIC void sctp_close(struct sock *sk, long timeout)
 			struct sctp_chunk *chunk;
 
 			chunk = sctp_make_abort_user(asoc, NULL, 0);
-			if (chunk)
-				sctp_primitive_ABORT(net, asoc, chunk);
+			sctp_primitive_ABORT(net, asoc, chunk);
 		} else
 			sctp_primitive_SHUTDOWN(net, asoc, NULL);
 	}
@@ -1548,8 +1547,10 @@ SCTP_STATIC void sctp_close(struct sock *sk, long timeout)
 
 	/* Supposedly, no process has access to the socket, but
 	 * the net layers still may.
+	 * Also, sctp_destroy_sock() needs to be called with addr_wq_lock
+	 * held and that should be grabbed before socket lock.
 	 */
-	sctp_local_bh_disable();
+	spin_lock_bh(&net->sctp.addr_wq_lock);
 	sctp_bh_lock_sock(sk);
 
 	/* Hold the sock, since sk_common_release() will put sock_put()
@@ -1559,7 +1560,7 @@ SCTP_STATIC void sctp_close(struct sock *sk, long timeout)
 	sk_common_release(sk);
 
 	sctp_bh_unlock_sock(sk);
-	sctp_local_bh_enable();
+	spin_unlock_bh(&net->sctp.addr_wq_lock);
 
 	sock_put(sk);
 
@@ -3508,6 +3509,7 @@ static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,
 	if ((val && sp->do_auto_asconf) || (!val && !sp->do_auto_asconf))
 		return 0;
 
+	spin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);
 	if (val == 0 && sp->do_auto_asconf) {
 		list_del(&sp->auto_asconf_list);
 		sp->do_auto_asconf = 0;
@@ -3516,6 +3518,7 @@ static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,
 		    &sock_net(sk)->sctp.auto_asconf_splist);
 		sp->do_auto_asconf = 1;
 	}
+	spin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);
 	return 0;
 }
 
@@ -4007,18 +4010,28 @@ SCTP_STATIC int sctp_init_sock(struct sock *sk)
 	local_bh_disable();
 	percpu_counter_inc(&sctp_sockets_allocated);
 	sock_prot_inuse_add(net, sk->sk_prot, 1);
+
+	/* Nothing can fail after this block, otherwise
+	 * sctp_destroy_sock() will be called without addr_wq_lock held
+	 */
 	if (net->sctp.default_auto_asconf) {
+		spin_lock(&sock_net(sk)->sctp.addr_wq_lock);
 		list_add_tail(&sp->auto_asconf_list,
 		    &net->sctp.auto_asconf_splist);
 		sp->do_auto_asconf = 1;
-	} else
+		spin_unlock(&sock_net(sk)->sctp.addr_wq_lock);
+	} else {
 		sp->do_auto_asconf = 0;
+	}
+
 	local_bh_enable();
 
 	return 0;
 }
 
-/* Cleanup any SCTP per socket resources.  */
+/* Cleanup any SCTP per socket resources. Must be called with
+ * sock_net(sk)->sctp.addr_wq_lock held if sp->do_auto_asconf is true
+ */
 SCTP_STATIC void sctp_destroy_sock(struct sock *sk)
 {
 	struct sctp_sock *sp;
@@ -6955,6 +6968,22 @@ void sctp_copy_sock(struct sock *newsk, struct sock *sk,
 	newinet->mc_ttl = 1;
 	newinet->mc_index = 0;
 	newinet->mc_list = NULL;
+
+	if (newsk->sk_flags & SK_FLAGS_TIMESTAMP)
+		net_enable_timestamp();
+}
+
+static inline void sctp_copy_descendant(struct sock *sk_to,
+					const struct sock *sk_from)
+{
+	int ancestor_size = sizeof(struct inet_sock) +
+			    sizeof(struct sctp_sock) -
+			    offsetof(struct sctp_sock, auto_asconf_list);
+
+	if (sk_from->sk_family == PF_INET6)
+		ancestor_size += sizeof(struct ipv6_pinfo);
+
+	__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);
 }
 
 /* Populate the fields of the newsk from the oldsk and migrate the assoc
@@ -6971,7 +7000,6 @@ static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,
 	struct sk_buff *skb, *tmp;
 	struct sctp_ulpevent *event;
 	struct sctp_bind_hashbucket *head;
-	struct list_head tmplist;
 
 	/* Migrate socket buffer sizes and all the socket level options to the
 	 * new socket.
@@ -6979,12 +7007,7 @@ static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,
 	newsk->sk_sndbuf = oldsk->sk_sndbuf;
 	newsk->sk_rcvbuf = oldsk->sk_rcvbuf;
 	/* Brute force copy old sctp opt. */
-	if (oldsp->do_auto_asconf) {
-		memcpy(&tmplist, &newsp->auto_asconf_list, sizeof(tmplist));
-		inet_sk_copy_descendant(newsk, oldsk);
-		memcpy(&newsp->auto_asconf_list, &tmplist, sizeof(tmplist));
-	} else
-		inet_sk_copy_descendant(newsk, oldsk);
+	sctp_copy_descendant(newsk, oldsk);
 
 	/* Restore the ep value that was overwritten with the above structure
 	 * copy.
@@ -7128,6 +7151,13 @@ struct proto sctp_prot = {
 
 #if IS_ENABLED(CONFIG_IPV6)
 
+#include <net/transp_v6.h>
+static void sctp_v6_destroy_sock(struct sock *sk)
+{
+	sctp_destroy_sock(sk);
+	inet6_destroy_sock(sk);
+}
+
 struct proto sctpv6_prot = {
 	.name		= "SCTPv6",
 	.owner		= THIS_MODULE,
@@ -7137,7 +7167,7 @@ struct proto sctpv6_prot = {
 	.accept		= sctp_accept,
 	.ioctl		= sctp_ioctl,
 	.init		= sctp_init_sock,
-	.destroy	= sctp_destroy_sock,
+	.destroy	= sctp_v6_destroy_sock,
 	.shutdown	= sctp_shutdown,
 	.setsockopt	= sctp_setsockopt,
 	.getsockopt	= sctp_getsockopt,
diff --git a/net/socket.c b/net/socket.c
index fc90b4f..e91e8ed 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -1988,14 +1988,12 @@ static int ___sys_sendmsg(struct socket *sock, struct msghdr __user *msg,
 	int err, ctl_len, total_len;
 
 	err = -EFAULT;
-	if (MSG_CMSG_COMPAT & flags) {
-		if (get_compat_msghdr(msg_sys, msg_compat))
-			return -EFAULT;
-	} else {
+	if (MSG_CMSG_COMPAT & flags)
+		err = get_compat_msghdr(msg_sys, msg_compat);
+	else
 		err = copy_msghdr_from_user(msg_sys, msg);
-		if (err)
-			return err;
-	}
+	if (err)
+		return err;
 
 	if (msg_sys->msg_iovlen > UIO_FASTIOV) {
 		err = -EMSGSIZE;
@@ -2200,14 +2198,12 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,
 	struct sockaddr __user *uaddr;
 	int __user *uaddr_len;
 
-	if (MSG_CMSG_COMPAT & flags) {
-		if (get_compat_msghdr(msg_sys, msg_compat))
-			return -EFAULT;
-	} else {
+	if (MSG_CMSG_COMPAT & flags)
+		err = get_compat_msghdr(msg_sys, msg_compat);
+	else
 		err = copy_msghdr_from_user(msg_sys, msg);
-		if (err)
-			return err;
-	}
+	if (err)
+		return err;
 
 	if (msg_sys->msg_iovlen > UIO_FASTIOV) {
 		err = -EMSGSIZE;
@@ -2385,31 +2381,31 @@ int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
 			break;
 	}
 
-out_put:
-	fput_light(sock->file, fput_needed);
-
 	if (err == 0)
-		return datagrams;
+		goto out_put;
 
-	if (datagrams != 0) {
+	if (datagrams == 0) {
+		datagrams = err;
+		goto out_put;
+	}
+
+	/*
+	 * We may return less entries than requested (vlen) if the
+	 * sock is non block and there aren't enough datagrams...
+	 */
+	if (err != -EAGAIN) {
 		/*
-		 * We may return less entries than requested (vlen) if the
-		 * sock is non block and there aren't enough datagrams...
+		 * ... or  if recvmsg returns an error after we
+		 * received some datagrams, where we record the
+		 * error to return on the next call or if the
+		 * app asks about it using getsockopt(SO_ERROR).
 		 */
-		if (err != -EAGAIN) {
-			/*
-			 * ... or  if recvmsg returns an error after we
-			 * received some datagrams, where we record the
-			 * error to return on the next call or if the
-			 * app asks about it using getsockopt(SO_ERROR).
-			 */
-			sock->sk->sk_err = -err;
-		}
-
-		return datagrams;
+		sock->sk->sk_err = -err;
 	}
+out_put:
+	fput_light(sock->file, fput_needed);
 
-	return err;
+	return datagrams;
 }
 
 SYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,
diff --git a/net/sunrpc/auth_gss/gss_rpc_xdr.c b/net/sunrpc/auth_gss/gss_rpc_xdr.c
index f0f78c5..e0062c5 100644
--- a/net/sunrpc/auth_gss/gss_rpc_xdr.c
+++ b/net/sunrpc/auth_gss/gss_rpc_xdr.c
@@ -794,20 +794,26 @@ int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,
 {
 	u32 value_follows;
 	int err;
+	struct page *scratch;
+
+	scratch = alloc_page(GFP_KERNEL);
+	if (!scratch)
+		return -ENOMEM;
+	xdr_set_scratch_buffer(xdr, page_address(scratch), PAGE_SIZE);
 
 	/* res->status */
 	err = gssx_dec_status(xdr, &res->status);
 	if (err)
-		return err;
+		goto out_free;
 
 	/* res->context_handle */
 	err = gssx_dec_bool(xdr, &value_follows);
 	if (err)
-		return err;
+		goto out_free;
 	if (value_follows) {
 		err = gssx_dec_ctx(xdr, res->context_handle);
 		if (err)
-			return err;
+			goto out_free;
 	} else {
 		res->context_handle = NULL;
 	}
@@ -815,11 +821,11 @@ int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,
 	/* res->output_token */
 	err = gssx_dec_bool(xdr, &value_follows);
 	if (err)
-		return err;
+		goto out_free;
 	if (value_follows) {
 		err = gssx_dec_buffer(xdr, res->output_token);
 		if (err)
-			return err;
+			goto out_free;
 	} else {
 		res->output_token = NULL;
 	}
@@ -827,14 +833,17 @@ int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,
 	/* res->delegated_cred_handle */
 	err = gssx_dec_bool(xdr, &value_follows);
 	if (err)
-		return err;
+		goto out_free;
 	if (value_follows) {
 		/* we do not support upcall servers sending this data. */
-		return -EINVAL;
+		err = -EINVAL;
+		goto out_free;
 	}
 
 	/* res->options */
 	err = gssx_dec_option_array(xdr, &res->options);
 
+out_free:
+	__free_page(scratch);
 	return err;
 }
diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index 29b4ba9..62663a0 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -859,8 +859,8 @@ unwrap_integ_data(struct svc_rqst *rqstp, struct xdr_buf *buf, u32 seq, struct g
 		goto out;
 	if (svc_getnl(&buf->head[0]) != seq)
 		goto out;
-	/* trim off the mic at the end before returning */
-	xdr_buf_trim(buf, mic.len + 4);
+	/* trim off the mic and padding at the end before returning */
+	xdr_buf_trim(buf, round_up_to_quad(mic.len) + 4);
 	stat = 0;
 out:
 	kfree(mic.data);
diff --git a/net/sunrpc/backchannel_rqst.c b/net/sunrpc/backchannel_rqst.c
index 890a299..d29c119e 100644
--- a/net/sunrpc/backchannel_rqst.c
+++ b/net/sunrpc/backchannel_rqst.c
@@ -60,7 +60,7 @@ static void xprt_free_allocation(struct rpc_rqst *req)
 
 	dprintk("RPC:        free allocations for req= %p\n", req);
 	WARN_ON_ONCE(test_bit(RPC_BC_PA_IN_USE, &req->rq_bc_pa_state));
-	xbufp = &req->rq_private_buf;
+	xbufp = &req->rq_rcv_buf;
 	free_page((unsigned long)xbufp->head[0].iov_base);
 	xbufp = &req->rq_snd_buf;
 	free_page((unsigned long)xbufp->head[0].iov_base);
diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index 231b719..a4266b9 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -1221,7 +1221,7 @@ int qword_get(char **bpp, char *dest, int bufsize)
 	if (bp[0] == '\\' && bp[1] == 'x') {
 		/* HEX STRING */
 		bp += 2;
-		while (len < bufsize) {
+		while (len < bufsize - 1) {
 			int h, l;
 
 			h = hex_to_bin(bp[0]);
diff --git a/net/tipc/socket.c b/net/tipc/socket.c
index 2b1d7c2..e0cb5ed 100644
--- a/net/tipc/socket.c
+++ b/net/tipc/socket.c
@@ -1528,6 +1528,7 @@ static int accept(struct socket *sock, struct socket *new_sock, int flags)
 	res = tipc_create(sock_net(sock->sk), new_sock, 0, 0);
 	if (res)
 		goto exit;
+	security_sk_clone(sock->sk, new_sock->sk);
 
 	new_sk = new_sock->sk;
 	new_tsock = tipc_sk(new_sk);
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index 75e198d..8f118c7 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -313,6 +313,118 @@ found:
 	return s;
 }
 
+/* Support code for asymmetrically connected dgram sockets
+ *
+ * If a datagram socket is connected to a socket not itself connected
+ * to the first socket (eg, /dev/log), clients may only enqueue more
+ * messages if the present receive queue of the server socket is not
+ * "too large". This means there's a second writeability condition
+ * poll and sendmsg need to test. The dgram recv code will do a wake
+ * up on the peer_wait wait queue of a socket upon reception of a
+ * datagram which needs to be propagated to sleeping would-be writers
+ * since these might not have sent anything so far. This can't be
+ * accomplished via poll_wait because the lifetime of the server
+ * socket might be less than that of its clients if these break their
+ * association with it or if the server socket is closed while clients
+ * are still connected to it and there's no way to inform "a polling
+ * implementation" that it should let go of a certain wait queue
+ *
+ * In order to propagate a wake up, a wait_queue_t of the client
+ * socket is enqueued on the peer_wait queue of the server socket
+ * whose wake function does a wake_up on the ordinary client socket
+ * wait queue. This connection is established whenever a write (or
+ * poll for write) hit the flow control condition and broken when the
+ * association to the server socket is dissolved or after a wake up
+ * was relayed.
+ */
+
+static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,
+				      void *key)
+{
+	struct unix_sock *u;
+	wait_queue_head_t *u_sleep;
+
+	u = container_of(q, struct unix_sock, peer_wake);
+
+	__remove_wait_queue(&unix_sk(u->peer_wake.private)->peer_wait,
+			    q);
+	u->peer_wake.private = NULL;
+
+	/* relaying can only happen while the wq still exists */
+	u_sleep = sk_sleep(&u->sk);
+	if (u_sleep)
+		wake_up_interruptible_poll(u_sleep, key);
+
+	return 0;
+}
+
+static int unix_dgram_peer_wake_connect(struct sock *sk, struct sock *other)
+{
+	struct unix_sock *u, *u_other;
+	int rc;
+
+	u = unix_sk(sk);
+	u_other = unix_sk(other);
+	rc = 0;
+	spin_lock(&u_other->peer_wait.lock);
+
+	if (!u->peer_wake.private) {
+		u->peer_wake.private = other;
+		__add_wait_queue(&u_other->peer_wait, &u->peer_wake);
+
+		rc = 1;
+	}
+
+	spin_unlock(&u_other->peer_wait.lock);
+	return rc;
+}
+
+static void unix_dgram_peer_wake_disconnect(struct sock *sk,
+					    struct sock *other)
+{
+	struct unix_sock *u, *u_other;
+
+	u = unix_sk(sk);
+	u_other = unix_sk(other);
+	spin_lock(&u_other->peer_wait.lock);
+
+	if (u->peer_wake.private == other) {
+		__remove_wait_queue(&u_other->peer_wait, &u->peer_wake);
+		u->peer_wake.private = NULL;
+	}
+
+	spin_unlock(&u_other->peer_wait.lock);
+}
+
+static void unix_dgram_peer_wake_disconnect_wakeup(struct sock *sk,
+						   struct sock *other)
+{
+	unix_dgram_peer_wake_disconnect(sk, other);
+	wake_up_interruptible_poll(sk_sleep(sk),
+				   POLLOUT |
+				   POLLWRNORM |
+				   POLLWRBAND);
+}
+
+/* preconditions:
+ *	- unix_peer(sk) == other
+ *	- association is stable
+ */
+static int unix_dgram_peer_wake_me(struct sock *sk, struct sock *other)
+{
+	int connected;
+
+	connected = unix_dgram_peer_wake_connect(sk, other);
+
+	if (unix_recvq_full(other))
+		return 1;
+
+	if (connected)
+		unix_dgram_peer_wake_disconnect(sk, other);
+
+	return 0;
+}
+
 static inline int unix_writable(struct sock *sk)
 {
 	return (atomic_read(&sk->sk_wmem_alloc) << 2) <= sk->sk_sndbuf;
@@ -417,6 +529,8 @@ static void unix_release_sock(struct sock *sk, int embrion)
 			skpair->sk_state_change(skpair);
 			sk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);
 		}
+
+		unix_dgram_peer_wake_disconnect(sk, skpair);
 		sock_put(skpair); /* It may now die */
 		unix_peer(sk) = NULL;
 	}
@@ -650,6 +764,7 @@ static struct sock *unix_create1(struct net *net, struct socket *sock)
 	INIT_LIST_HEAD(&u->link);
 	mutex_init(&u->readlock); /* single task reading lock */
 	init_waitqueue_head(&u->peer_wait);
+	init_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);
 	unix_insert_socket(unix_sockets_unbound(sk), sk);
 out:
 	if (sk == NULL)
@@ -1017,6 +1132,8 @@ restart:
 	if (unix_peer(sk)) {
 		struct sock *old_peer = unix_peer(sk);
 		unix_peer(sk) = other;
+		unix_dgram_peer_wake_disconnect_wakeup(sk, old_peer);
+
 		unix_state_double_unlock(sk, other);
 
 		if (other != old_peer)
@@ -1349,7 +1466,7 @@ static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
 	UNIXCB(skb).fp = NULL;
 
 	for (i = scm->fp->count-1; i >= 0; i--)
-		unix_notinflight(scm->fp->fp[i]);
+		unix_notinflight(scm->fp->user, scm->fp->fp[i]);
 }
 
 static void unix_destruct_scm(struct sk_buff *skb)
@@ -1366,6 +1483,21 @@ static void unix_destruct_scm(struct sk_buff *skb)
 	sock_wfree(skb);
 }
 
+/*
+ * The "user->unix_inflight" variable is protected by the garbage
+ * collection lock, and we just read it locklessly here. If you go
+ * over the limit, there might be a tiny race in actually noticing
+ * it across threads. Tough.
+ */
+static inline bool too_many_unix_fds(struct task_struct *p)
+{
+	struct user_struct *user = current_user();
+
+	if (unlikely(user->unix_inflight > task_rlimit(p, RLIMIT_NOFILE)))
+		return !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);
+	return false;
+}
+
 #define MAX_RECURSION_LEVEL 4
 
 static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
@@ -1374,6 +1506,9 @@ static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
 	unsigned char max_level = 0;
 	int unix_sock_count = 0;
 
+	if (too_many_unix_fds(current))
+		return -ETOOMANYREFS;
+
 	for (i = scm->fp->count - 1; i >= 0; i--) {
 		struct sock *sk = unix_get_socket(scm->fp->fp[i]);
 
@@ -1395,10 +1530,8 @@ static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
 	if (!UNIXCB(skb).fp)
 		return -ENOMEM;
 
-	if (unix_sock_count) {
-		for (i = scm->fp->count - 1; i >= 0; i--)
-			unix_inflight(scm->fp->fp[i]);
-	}
+	for (i = scm->fp->count - 1; i >= 0; i--)
+		unix_inflight(scm->fp->user, scm->fp->fp[i]);
 	return max_level;
 }
 
@@ -1456,6 +1589,7 @@ static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
 	struct scm_cookie tmp_scm;
 	int max_level;
 	int data_len = 0;
+	int sk_locked;
 
 	if (NULL == siocb->scm)
 		siocb->scm = &tmp_scm;
@@ -1532,12 +1666,14 @@ restart:
 		goto out_free;
 	}
 
+	sk_locked = 0;
 	unix_state_lock(other);
+restart_locked:
 	err = -EPERM;
 	if (!unix_may_send(sk, other))
 		goto out_unlock;
 
-	if (sock_flag(other, SOCK_DEAD)) {
+	if (unlikely(sock_flag(other, SOCK_DEAD))) {
 		/*
 		 *	Check with 1003.1g - what should
 		 *	datagram error
@@ -1545,10 +1681,14 @@ restart:
 		unix_state_unlock(other);
 		sock_put(other);
 
+		if (!sk_locked)
+			unix_state_lock(sk);
+
 		err = 0;
-		unix_state_lock(sk);
 		if (unix_peer(sk) == other) {
 			unix_peer(sk) = NULL;
+			unix_dgram_peer_wake_disconnect_wakeup(sk, other);
+
 			unix_state_unlock(sk);
 
 			unix_dgram_disconnected(sk, other);
@@ -1574,21 +1714,38 @@ restart:
 			goto out_unlock;
 	}
 
-	if (unix_peer(other) != sk && unix_recvq_full(other)) {
-		if (!timeo) {
-			err = -EAGAIN;
-			goto out_unlock;
+	if (unlikely(unix_peer(other) != sk && unix_recvq_full(other))) {
+		if (timeo) {
+			timeo = unix_wait_for_peer(other, timeo);
+
+			err = sock_intr_errno(timeo);
+			if (signal_pending(current))
+				goto out_free;
+
+			goto restart;
 		}
 
-		timeo = unix_wait_for_peer(other, timeo);
+		if (!sk_locked) {
+			unix_state_unlock(other);
+			unix_state_double_lock(sk, other);
+		}
 
-		err = sock_intr_errno(timeo);
-		if (signal_pending(current))
-			goto out_free;
+		if (unix_peer(sk) != other ||
+		    unix_dgram_peer_wake_me(sk, other)) {
+			err = -EAGAIN;
+			sk_locked = 1;
+			goto out_unlock;
+		}
 
-		goto restart;
+		if (!sk_locked) {
+			sk_locked = 1;
+			goto restart_locked;
+		}
 	}
 
+	if (unlikely(sk_locked))
+		unix_state_unlock(sk);
+
 	if (sock_flag(other, SOCK_RCVTSTAMP))
 		__net_timestamp(skb);
 	maybe_add_creds(skb, sock, other);
@@ -1602,6 +1759,8 @@ restart:
 	return len;
 
 out_unlock:
+	if (sk_locked)
+		unix_state_unlock(sk);
 	unix_state_unlock(other);
 out_free:
 	kfree_skb(skb);
@@ -1898,6 +2057,10 @@ static long unix_stream_data_wait(struct sock *sk, long timeo,
 		unix_state_unlock(sk);
 		timeo = schedule_timeout(timeo);
 		unix_state_lock(sk);
+
+		if (sock_flag(sk, SOCK_DEAD))
+			break;
+
 		clear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);
 	}
 
@@ -1943,20 +2106,17 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 		memset(&tmp_scm, 0, sizeof(tmp_scm));
 	}
 
-	err = mutex_lock_interruptible(&u->readlock);
-	if (unlikely(err)) {
-		/* recvmsg() in non blocking mode is supposed to return -EAGAIN
-		 * sk_rcvtimeo is not honored by mutex_lock_interruptible()
-		 */
-		err = noblock ? -EAGAIN : -ERESTARTSYS;
-		goto out;
-	}
+	mutex_lock(&u->readlock);
 
 	do {
 		int chunk;
 		struct sk_buff *skb, *last;
 
 		unix_state_lock(sk);
+		if (sock_flag(sk, SOCK_DEAD)) {
+			err = -ECONNRESET;
+			goto unlock;
+		}
 		last = skb = skb_peek(&sk->sk_receive_queue);
 again:
 		if (skb == NULL) {
@@ -1982,12 +2142,12 @@ again:
 
 			timeo = unix_stream_data_wait(sk, timeo, last);
 
-			if (signal_pending(current)
-			    ||  mutex_lock_interruptible(&u->readlock)) {
+			if (signal_pending(current)) {
 				err = sock_intr_errno(timeo);
 				goto out;
 			}
 
+			mutex_lock(&u->readlock);
 			continue;
  unlock:
 			unix_state_unlock(sk);
@@ -2055,8 +2215,20 @@ again:
 			if (UNIXCB(skb).fp)
 				siocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);
 
-			sk_peek_offset_fwd(sk, chunk);
+			if (skip) {
+				sk_peek_offset_fwd(sk, chunk);
+				skip -= chunk;
+			}
 
+			if (UNIXCB(skb).fp)
+				break;
+
+			last = skb;
+			unix_state_lock(sk);
+			skb = skb_peek_next(skb, &sk->sk_receive_queue);
+			if (skb)
+				goto again;
+			unix_state_unlock(sk);
 			break;
 		}
 	} while (size);
@@ -2240,14 +2412,16 @@ static unsigned int unix_dgram_poll(struct file *file, struct socket *sock,
 		return mask;
 
 	writable = unix_writable(sk);
-	other = unix_peer_get(sk);
-	if (other) {
-		if (unix_peer(other) != sk) {
-			sock_poll_wait(file, &unix_sk(other)->peer_wait, wait);
-			if (unix_recvq_full(other))
-				writable = 0;
-		}
-		sock_put(other);
+	if (writable) {
+		unix_state_lock(sk);
+
+		other = unix_peer(sk);
+		if (other && unix_peer(other) != sk &&
+		    unix_recvq_full(other) &&
+		    unix_dgram_peer_wake_me(sk, other))
+			writable = 0;
+
+		unix_state_unlock(sk);
 	}
 
 	if (writable)
diff --git a/net/unix/garbage.c b/net/unix/garbage.c
index 9bc73f8..a72182d 100644
--- a/net/unix/garbage.c
+++ b/net/unix/garbage.c
@@ -122,12 +122,15 @@ struct sock *unix_get_socket(struct file *filp)
  *	descriptor if it is for an AF_UNIX socket.
  */
 
-void unix_inflight(struct file *fp)
+void unix_inflight(struct user_struct *user, struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
+
+	spin_lock(&unix_gc_lock);
+
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
-		spin_lock(&unix_gc_lock);
+
 		if (atomic_long_inc_return(&u->inflight) == 1) {
 			BUG_ON(!list_empty(&u->link));
 			list_add_tail(&u->link, &gc_inflight_list);
@@ -135,22 +138,27 @@ void unix_inflight(struct file *fp)
 			BUG_ON(list_empty(&u->link));
 		}
 		unix_tot_inflight++;
-		spin_unlock(&unix_gc_lock);
 	}
+	user->unix_inflight++;
+	spin_unlock(&unix_gc_lock);
 }
 
-void unix_notinflight(struct file *fp)
+void unix_notinflight(struct user_struct *user, struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
+
+	spin_lock(&unix_gc_lock);
+
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
-		spin_lock(&unix_gc_lock);
+
 		BUG_ON(list_empty(&u->link));
 		if (atomic_long_dec_and_test(&u->inflight))
 			list_del_init(&u->link);
 		unix_tot_inflight--;
-		spin_unlock(&unix_gc_lock);
 	}
+	user->unix_inflight--;
+	spin_unlock(&unix_gc_lock);
 }
 
 static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),
diff --git a/net/vmw_vsock/af_vsock.c b/net/vmw_vsock/af_vsock.c
index 9b88693..66a9bf5 100644
--- a/net/vmw_vsock/af_vsock.c
+++ b/net/vmw_vsock/af_vsock.c
@@ -1804,27 +1804,8 @@ vsock_stream_recvmsg(struct kiocb *kiocb,
 	else if (sk->sk_shutdown & RCV_SHUTDOWN)
 		err = 0;
 
-	if (copied > 0) {
-		/* We only do these additional bookkeeping/notification steps
-		 * if we actually copied something out of the queue pair
-		 * instead of just peeking ahead.
-		 */
-
-		if (!(flags & MSG_PEEK)) {
-			/* If the other side has shutdown for sending and there
-			 * is nothing more to read, then modify the socket
-			 * state.
-			 */
-			if (vsk->peer_shutdown & SEND_SHUTDOWN) {
-				if (vsock_stream_has_data(vsk) <= 0) {
-					sk->sk_state = SS_UNCONNECTED;
-					sock_set_flag(sk, SOCK_DONE);
-					sk->sk_state_change(sk);
-				}
-			}
-		}
+	if (copied > 0)
 		err = copied;
-	}
 
 out_wait:
 	finish_wait(sk_sleep(sk), &wait);
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index dc200bf..dd3dbed 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -4032,6 +4032,16 @@ static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)
 	if (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))
 		return -EINVAL;
 
+	/* HT/VHT requires QoS, but if we don't have that just ignore HT/VHT
+	 * as userspace might just pass through the capabilities from the IEs
+	 * directly, rather than enforcing this restriction and returning an
+	 * error in this case.
+	 */
+	if (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME))) {
+		params.ht_capa = NULL;
+		params.vht_capa = NULL;
+	}
+
 	/* When you run into this, adjust the code below for the new flag */
 	BUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);
 
@@ -10675,7 +10685,7 @@ static int nl80211_netlink_notify(struct notifier_block * nb,
 	struct wireless_dev *wdev;
 	struct cfg80211_beacon_registration *reg, *tmp;
 
-	if (state != NETLINK_URELEASE)
+	if (state != NETLINK_URELEASE || notify->protocol != NETLINK_GENERIC)
 		return NOTIFY_DONE;
 
 	rcu_read_lock();
diff --git a/net/wireless/wext-compat.c b/net/wireless/wext-compat.c
index d997d0f..18a7a7b 100644
--- a/net/wireless/wext-compat.c
+++ b/net/wireless/wext-compat.c
@@ -1345,6 +1345,8 @@ static struct iw_statistics *cfg80211_wireless_stats(struct net_device *dev)
 	memcpy(bssid, wdev->current_bss->pub.bssid, ETH_ALEN);
 	wdev_unlock(wdev);
 
+	memset(&sinfo, 0, sizeof(sinfo));
+
 	if (rdev_get_station(rdev, dev, bssid, &sinfo))
 		return NULL;
 
diff --git a/net/wireless/wext-core.c b/net/wireless/wext-core.c
index c8717c1..87dd619 100644
--- a/net/wireless/wext-core.c
+++ b/net/wireless/wext-core.c
@@ -342,6 +342,39 @@ static const int compat_event_type_size[] = {
 
 /* IW event code */
 
+static void wireless_nlevent_flush(void)
+{
+	struct sk_buff *skb;
+	struct net *net;
+
+	ASSERT_RTNL();
+
+	for_each_net(net) {
+		while ((skb = skb_dequeue(&net->wext_nlevents)))
+			rtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL,
+				    GFP_KERNEL);
+	}
+}
+
+static int wext_netdev_notifier_call(struct notifier_block *nb,
+				     unsigned long state, void *ptr)
+{
+	/*
+	 * When a netdev changes state in any way, flush all pending messages
+	 * to avoid them going out in a strange order, e.g. RTM_NEWLINK after
+	 * RTM_DELLINK, or with IFF_UP after without IFF_UP during dev_close()
+	 * or similar - all of which could otherwise happen due to delays from
+	 * schedule_work().
+	 */
+	wireless_nlevent_flush();
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block wext_netdev_notifier = {
+	.notifier_call = wext_netdev_notifier_call,
+};
+
 static int __net_init wext_pernet_init(struct net *net)
 {
 	skb_queue_head_init(&net->wext_nlevents);
@@ -360,7 +393,12 @@ static struct pernet_operations wext_pernet_ops = {
 
 static int __init wireless_nlevent_init(void)
 {
-	return register_pernet_subsys(&wext_pernet_ops);
+	int err = register_pernet_subsys(&wext_pernet_ops);
+
+	if (err)
+		return err;
+
+	return register_netdevice_notifier(&wext_netdev_notifier);
 }
 
 subsys_initcall(wireless_nlevent_init);
@@ -368,17 +406,8 @@ subsys_initcall(wireless_nlevent_init);
 /* Process events generated by the wireless layer or the driver. */
 static void wireless_nlevent_process(struct work_struct *work)
 {
-	struct sk_buff *skb;
-	struct net *net;
-
 	rtnl_lock();
-
-	for_each_net(net) {
-		while ((skb = skb_dequeue(&net->wext_nlevents)))
-			rtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL,
-				    GFP_KERNEL);
-	}
-
+	wireless_nlevent_flush();
 	rtnl_unlock();
 }
 
diff --git a/net/x25/x25_facilities.c b/net/x25/x25_facilities.c
index 66c63873..de7552d 100644
--- a/net/x25/x25_facilities.c
+++ b/net/x25/x25_facilities.c
@@ -271,6 +271,7 @@ int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,
 
 	memset(&theirs, 0, sizeof(theirs));
 	memcpy(new, ours, sizeof(*new));
+	memset(dte, 0, sizeof(*dte));
 
 	len = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);
 	if (len < 0)
diff --git a/scripts/asn1_compiler.c b/scripts/asn1_compiler.c
index db0e5cd..91c4117 100644
--- a/scripts/asn1_compiler.c
+++ b/scripts/asn1_compiler.c
@@ -1353,6 +1353,8 @@ static void render_out_of_line_list(FILE *out)
 			render_opcode(out, "ASN1_OP_END_SET_OF%s,\n", act);
 			render_opcode(out, "_jump_target(%u),\n", entry);
 			break;
+		default:
+			break;
 		}
 		if (e->action)
 			render_opcode(out, "_action(ACT_%s),\n",
diff --git a/scripts/bloat-o-meter b/scripts/bloat-o-meter
index 6129020..81228a4 100755
--- a/scripts/bloat-o-meter
+++ b/scripts/bloat-o-meter
@@ -55,8 +55,8 @@ for name in common:
 delta.sort()
 delta.reverse()
 
-print "add/remove: %s/%s grow/shrink: %s/%s up/down: %s/%s (%s)" % \
-      (add, remove, grow, shrink, up, -down, up-down)
-print "%-40s %7s %7s %+7s" % ("function", "old", "new", "delta")
+print("add/remove: %s/%s grow/shrink: %s/%s up/down: %s/%s (%s)" % \
+      (add, remove, grow, shrink, up, -down, up-down))
+print("%-40s %7s %7s %+7s" % ("function", "old", "new", "delta"))
 for d, n in delta:
-    if d: print "%-40s %7s %7s %+7d" % (n, old.get(n,"-"), new.get(n,"-"), d)
+    if d: print("%-40s %7s %7s %+7d" % (n, old.get(n,"-"), new.get(n,"-"), d))
diff --git a/scripts/coccinelle/iterators/use_after_iter.cocci b/scripts/coccinelle/iterators/use_after_iter.cocci
index 06284c5..93e37ff 100644
--- a/scripts/coccinelle/iterators/use_after_iter.cocci
+++ b/scripts/coccinelle/iterators/use_after_iter.cocci
@@ -123,7 +123,7 @@ list_remove_head(x,c,...)
 |
 sizeof(<+...c...+>)
 |
-&c->member
+ &c->member
 |
 c = E
 |
diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index fd3f018..6af1c42 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -525,7 +525,7 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 {
 	int i, j;
 	struct menu *submenu[8], *menu, *location = NULL;
-	struct jump_key *jump;
+	struct jump_key *jump = NULL;
 
 	str_printf(r, _("Prompt: %s\n"), _(prop->text));
 	menu = prop->menu->parent;
@@ -563,7 +563,7 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 		str_printf(r, _("  Location:\n"));
 		for (j = 4; --i >= 0; j += 2) {
 			menu = submenu[i];
-			if (head && location && menu == location)
+			if (jump && menu == location)
 				jump->offset = r->len - 1;
 			str_printf(r, "%*c-> %s", j, ' ',
 				   _(menu_get_prompt(menu)));
diff --git a/scripts/kconfig/streamline_config.pl b/scripts/kconfig/streamline_config.pl
index 4606cdf..7dd7c39 100644
--- a/scripts/kconfig/streamline_config.pl
+++ b/scripts/kconfig/streamline_config.pl
@@ -137,7 +137,7 @@ my $ksource = ($ARGV[0] ? $ARGV[0] : '.');
 my $kconfig = $ARGV[1];
 my $lsmod_file = $ENV{'LSMOD'};
 
-my @makefiles = `find $ksource -name Makefile 2>/dev/null`;
+my @makefiles = `find $ksource -name Makefile -or -name Kbuild 2>/dev/null`;
 chomp @makefiles;
 
 my %depends;
diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c
index 9c22317..4f7d13d 100644
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -33,10 +33,17 @@
 #include <string.h>
 #include <unistd.h>
 
+/*
+ * glibc synced up and added the metag number but didn't add the relocations.
+ * Work around this in a crude manner for now.
+ */
 #ifndef EM_METAG
-/* Remove this when these make it to the standard system elf.h. */
 #define EM_METAG      174
+#endif
+#ifndef R_METAG_ADDR32
 #define R_METAG_ADDR32                   2
+#endif
+#ifndef R_METAG_NONE
 #define R_METAG_NONE                     3
 #endif
 
@@ -189,6 +196,20 @@ static void *mmap_file(char const *fname)
 		addr = umalloc(sb.st_size);
 		uread(fd_map, addr, sb.st_size);
 	}
+	if (sb.st_nlink != 1) {
+		/* file is hard-linked, break the hard link */
+		close(fd_map);
+		if (unlink(fname) < 0) {
+			perror(fname);
+			fail_file();
+		}
+		fd_map = open(fname, O_RDWR | O_CREAT, sb.st_mode);
+		if (fd_map < 0) {
+			perror(fname);
+			fail_file();
+		}
+		uwrite(fd_map, addr, sb.st_size);
+	}
 	return addr;
 }
 
diff --git a/scripts/recordmcount.h b/scripts/recordmcount.h
index 49b582a..b9897e2 100644
--- a/scripts/recordmcount.h
+++ b/scripts/recordmcount.h
@@ -377,7 +377,7 @@ static void nop_mcount(Elf_Shdr const *const relhdr,
 
 		if (mcountsym == Elf_r_sym(relp) && !is_fake_mcount(relp)) {
 			if (make_nop)
-				ret = make_nop((void *)ehdr, shdr->sh_offset + relp->r_offset);
+				ret = make_nop((void *)ehdr, _w(shdr->sh_offset) + _w(relp->r_offset));
 			if (warn_on_notrace_sect && !once) {
 				printf("Section %s has mcount callers being ignored\n",
 				       txtname);
diff --git a/scripts/recordmcount.pl b/scripts/recordmcount.pl
index 679218b..f94f6a2 100755
--- a/scripts/recordmcount.pl
+++ b/scripts/recordmcount.pl
@@ -265,7 +265,8 @@ if ($arch eq "x86_64") {
 
 } elsif ($arch eq "powerpc") {
     $local_regex = "^[0-9a-fA-F]+\\s+t\\s+(\\.?\\S+)";
-    $function_regex = "^([0-9a-fA-F]+)\\s+<(\\.?.*?)>:";
+    # See comment in the sparc64 section for why we use '\w'.
+    $function_regex = "^([0-9a-fA-F]+)\\s+<(\\.?\\w*?)>:";
     $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s\\.?_mcount\$";
 
     if ($bits == 64) {
diff --git a/security/commoncap.c b/security/commoncap.c
index c9219a6..4fd7bf2 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -142,12 +142,17 @@ int cap_ptrace_access_check(struct task_struct *child, unsigned int mode)
 {
 	int ret = 0;
 	const struct cred *cred, *child_cred;
+	const kernel_cap_t *caller_caps;
 
 	rcu_read_lock();
 	cred = current_cred();
 	child_cred = __task_cred(child);
+	if (mode & PTRACE_MODE_FSCREDS)
+		caller_caps = &cred->cap_effective;
+	else
+		caller_caps = &cred->cap_permitted;
 	if (cred->user_ns == child_cred->user_ns &&
-	    cap_issubset(child_cred->cap_permitted, cred->cap_permitted))
+	    cap_issubset(child_cred->cap_permitted, *caller_caps))
 		goto out;
 	if (ns_capable(child_cred->user_ns, CAP_SYS_PTRACE))
 		goto out;
diff --git a/security/keys/gc.c b/security/keys/gc.c
index 7978186..de34c29 100644
--- a/security/keys/gc.c
+++ b/security/keys/gc.c
@@ -187,6 +187,12 @@ static noinline void key_gc_unused_keys(struct list_head *keys)
 		kdebug("- %u", key->serial);
 		key_check(key);
 
+		/* Throw away the key data if the key is instantiated */
+		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&
+		    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&
+		    key->type->destroy)
+			key->type->destroy(key);
+
 		security_key_free(key);
 
 		/* deal with the user's key tracking and quota */
@@ -201,10 +207,6 @@ static noinline void key_gc_unused_keys(struct list_head *keys)
 		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
 			atomic_dec(&key->user->nikeys);
 
-		/* now throw away the key memory */
-		if (key->type->destroy)
-			key->type->destroy(key);
-
 		key_user_put(key->user);
 
 		kfree(key->description);
diff --git a/security/keys/key.c b/security/keys/key.c
index 8fb7c7b..6595b2d 100644
--- a/security/keys/key.c
+++ b/security/keys/key.c
@@ -580,7 +580,7 @@ int key_reject_and_link(struct key *key,
 
 	mutex_unlock(&key_construction_mutex);
 
-	if (keyring)
+	if (keyring && link_ret == 0)
 		__key_link_end(keyring, key->type, prealloc);
 
 	/* wake up anyone waiting for a key to be constructed */
diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c
index 33cfd27..3242195 100644
--- a/security/keys/keyctl.c
+++ b/security/keys/keyctl.c
@@ -744,16 +744,16 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
 
 	/* the key is probably readable - now try to read it */
 can_read_key:
-	ret = key_validate(key);
-	if (ret == 0) {
-		ret = -EOPNOTSUPP;
-		if (key->type->read) {
-			/* read the data with the semaphore held (since we
-			 * might sleep) */
-			down_read(&key->sem);
+	ret = -EOPNOTSUPP;
+	if (key->type->read) {
+		/* Read the data with the semaphore held (since we might sleep)
+		 * to protect against the key being updated or revoked.
+		 */
+		down_read(&key->sem);
+		ret = key_validate(key);
+		if (ret == 0)
 			ret = key->type->read(key, buffer, buflen);
-			up_read(&key->sem);
-		}
+		up_read(&key->sem);
 	}
 
 error2:
diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c
index 42defae..cd871dc 100644
--- a/security/keys/process_keys.c
+++ b/security/keys/process_keys.c
@@ -792,6 +792,7 @@ long join_session_keyring(const char *name)
 		ret = PTR_ERR(keyring);
 		goto error2;
 	} else if (keyring == new->session_keyring) {
+		key_put(keyring);
 		ret = 0;
 		goto error2;
 	}
diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c
index ff42773..a96bed4 100644
--- a/security/selinux/selinuxfs.c
+++ b/security/selinux/selinuxfs.c
@@ -150,7 +150,7 @@ static ssize_t sel_write_enforce(struct file *file, const char __user *buf,
 		goto out;
 
 	/* No partial writes. */
-	length = EINVAL;
+	length = -EINVAL;
 	if (*ppos != 0)
 		goto out;
 
@@ -1190,7 +1190,7 @@ static void sel_remove_entries(struct dentry *de)
 	spin_lock(&de->d_lock);
 	node = de->d_subdirs.next;
 	while (node != &de->d_subdirs) {
-		struct dentry *d = list_entry(node, struct dentry, d_u.d_child);
+		struct dentry *d = list_entry(node, struct dentry, d_child);
 
 		spin_lock_nested(&d->d_lock, DENTRY_D_LOCK_NESTED);
 		list_del_init(node);
@@ -1664,12 +1664,12 @@ static void sel_remove_classes(void)
 
 	list_for_each(class_node, &class_dir->d_subdirs) {
 		struct dentry *class_subdir = list_entry(class_node,
-					struct dentry, d_u.d_child);
+					struct dentry, d_child);
 		struct list_head *class_subdir_node;
 
 		list_for_each(class_subdir_node, &class_subdir->d_subdirs) {
 			struct dentry *d = list_entry(class_subdir_node,
-						struct dentry, d_u.d_child);
+						struct dentry, d_child);
 
 			if (d->d_inode)
 				if (d->d_inode->i_mode & S_IFDIR)
diff --git a/security/yama/yama_lsm.c b/security/yama/yama_lsm.c
index 13c88fbc..0038834 100644
--- a/security/yama/yama_lsm.c
+++ b/security/yama/yama_lsm.c
@@ -292,7 +292,7 @@ int yama_ptrace_access_check(struct task_struct *child,
 		return rc;
 
 	/* require ptrace target be a child of ptracer on attach */
-	if (mode == PTRACE_MODE_ATTACH) {
+	if (mode & PTRACE_MODE_ATTACH) {
 		switch (ptrace_scope) {
 		case YAMA_SCOPE_DISABLED:
 			/* No additional restrictions. */
@@ -318,7 +318,7 @@ int yama_ptrace_access_check(struct task_struct *child,
 		}
 	}
 
-	if (rc) {
+	if (rc && (mode & PTRACE_MODE_NOAUDIT) == 0) {
 		printk_ratelimited(KERN_NOTICE
 			"ptrace of pid %d was attempted by: %s (pid %d)\n",
 			child->pid, current->comm, current->pid);
diff --git a/sound/arm/Kconfig b/sound/arm/Kconfig
index 885683a..e040621 100644
--- a/sound/arm/Kconfig
+++ b/sound/arm/Kconfig
@@ -9,6 +9,14 @@ menuconfig SND_ARM
 	  Drivers that are implemented on ASoC can be found in
 	  "ALSA for SoC audio support" section.
 
+config SND_PXA2XX_LIB
+	tristate
+	select SND_AC97_CODEC if SND_PXA2XX_LIB_AC97
+	select SND_DMAENGINE_PCM
+
+config SND_PXA2XX_LIB_AC97
+	bool
+
 if SND_ARM
 
 config SND_ARMAACI
@@ -21,13 +29,6 @@ config SND_PXA2XX_PCM
 	tristate
 	select SND_PCM
 
-config SND_PXA2XX_LIB
-	tristate
-	select SND_AC97_CODEC if SND_PXA2XX_LIB_AC97
-
-config SND_PXA2XX_LIB_AC97
-	bool
-
 config SND_PXA2XX_AC97
 	tristate "AC97 driver for the Intel PXA2xx chip"
 	depends on ARCH_PXA
diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c
index 3fdf998..572f951 100644
--- a/sound/core/compress_offload.c
+++ b/sound/core/compress_offload.c
@@ -44,6 +44,13 @@
 #include <sound/compress_offload.h>
 #include <sound/compress_driver.h>
 
+/* struct snd_compr_codec_caps overflows the ioctl bit size for some
+ * architectures, so we need to disable the relevant ioctls.
+ */
+#if _IOC_SIZEBITS < 14
+#define COMPR_CODEC_CAPS_OVERFLOW
+#endif
+
 /* TODO:
  * - add substream support for multiple devices in case of
  *	SND_DYNAMIC_MINORS is not used
@@ -427,6 +434,7 @@ out:
 	return retval;
 }
 
+#ifndef COMPR_CODEC_CAPS_OVERFLOW
 static int
 snd_compr_get_codec_caps(struct snd_compr_stream *stream, unsigned long arg)
 {
@@ -450,6 +458,7 @@ out:
 	kfree(caps);
 	return retval;
 }
+#endif /* !COMPR_CODEC_CAPS_OVERFLOW */
 
 /* revisit this with snd_pcm_preallocate_xxx */
 static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,
@@ -791,9 +800,11 @@ static long snd_compr_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
 	case _IOC_NR(SNDRV_COMPRESS_GET_CAPS):
 		retval = snd_compr_get_caps(stream, arg);
 		break;
+#ifndef COMPR_CODEC_CAPS_OVERFLOW
 	case _IOC_NR(SNDRV_COMPRESS_GET_CODEC_CAPS):
 		retval = snd_compr_get_codec_caps(stream, arg);
 		break;
+#endif
 	case _IOC_NR(SNDRV_COMPRESS_SET_PARAMS):
 		retval = snd_compr_set_params(stream, arg);
 		break;
diff --git a/sound/core/control.c b/sound/core/control.c
index f2082a3..251bc57 100644
--- a/sound/core/control.c
+++ b/sound/core/control.c
@@ -150,6 +150,8 @@ void snd_ctl_notify(struct snd_card *card, unsigned int mask,
 	
 	if (snd_BUG_ON(!card || !id))
 		return;
+	if (card->shutdown)
+		return;
 	read_lock(&card->ctl_files_rwlock);
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	card->mixer_oss_change_count++;
@@ -1325,6 +1327,8 @@ static int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,
 		return -EFAULT;
 	if (tlv.length < sizeof(unsigned int) * 2)
 		return -EINVAL;
+	if (!tlv.numid)
+		return -EINVAL;
 	down_read(&card->controls_rwsem);
 	kctl = snd_ctl_find_numid(card, tlv.numid);
 	if (kctl == NULL) {
diff --git a/sound/core/control_compat.c b/sound/core/control_compat.c
index 2bb95a7..c14565b 100644
--- a/sound/core/control_compat.c
+++ b/sound/core/control_compat.c
@@ -170,6 +170,19 @@ struct snd_ctl_elem_value32 {
         unsigned char reserved[128];
 };
 
+#ifdef CONFIG_X86_X32
+/* x32 has a different alignment for 64bit values from ia32 */
+struct snd_ctl_elem_value_x32 {
+	struct snd_ctl_elem_id id;
+	unsigned int indirect;	/* bit-field causes misalignment */
+	union {
+		s32 integer[128];
+		unsigned char data[512];
+		s64 integer64[64];
+	} value;
+	unsigned char reserved[128];
+};
+#endif /* CONFIG_X86_X32 */
 
 /* get the value type and count of the control */
 static int get_ctl_type(struct snd_card *card, struct snd_ctl_elem_id *id,
@@ -219,9 +232,11 @@ static int get_elem_size(int type, int count)
 
 static int copy_ctl_value_from_user(struct snd_card *card,
 				    struct snd_ctl_elem_value *data,
-				    struct snd_ctl_elem_value32 __user *data32,
+				    void __user *userdata,
+				    void __user *valuep,
 				    int *typep, int *countp)
 {
+	struct snd_ctl_elem_value32 __user *data32 = userdata;
 	int i, type, size;
 	int uninitialized_var(count);
 	unsigned int indirect;
@@ -239,8 +254,9 @@ static int copy_ctl_value_from_user(struct snd_card *card,
 	if (type == SNDRV_CTL_ELEM_TYPE_BOOLEAN ||
 	    type == SNDRV_CTL_ELEM_TYPE_INTEGER) {
 		for (i = 0; i < count; i++) {
+			s32 __user *intp = valuep;
 			int val;
-			if (get_user(val, &data32->value.integer[i]))
+			if (get_user(val, &intp[i]))
 				return -EFAULT;
 			data->value.integer.value[i] = val;
 		}
@@ -250,8 +266,7 @@ static int copy_ctl_value_from_user(struct snd_card *card,
 			printk(KERN_ERR "snd_ioctl32_ctl_elem_value: unknown type %d\n", type);
 			return -EINVAL;
 		}
-		if (copy_from_user(data->value.bytes.data,
-				   data32->value.data, size))
+		if (copy_from_user(data->value.bytes.data, valuep, size))
 			return -EFAULT;
 	}
 
@@ -261,7 +276,8 @@ static int copy_ctl_value_from_user(struct snd_card *card,
 }
 
 /* restore the value to 32bit */
-static int copy_ctl_value_to_user(struct snd_ctl_elem_value32 __user *data32,
+static int copy_ctl_value_to_user(void __user *userdata,
+				  void __user *valuep,
 				  struct snd_ctl_elem_value *data,
 				  int type, int count)
 {
@@ -270,22 +286,22 @@ static int copy_ctl_value_to_user(struct snd_ctl_elem_value32 __user *data32,
 	if (type == SNDRV_CTL_ELEM_TYPE_BOOLEAN ||
 	    type == SNDRV_CTL_ELEM_TYPE_INTEGER) {
 		for (i = 0; i < count; i++) {
+			s32 __user *intp = valuep;
 			int val;
 			val = data->value.integer.value[i];
-			if (put_user(val, &data32->value.integer[i]))
+			if (put_user(val, &intp[i]))
 				return -EFAULT;
 		}
 	} else {
 		size = get_elem_size(type, count);
-		if (copy_to_user(data32->value.data,
-				 data->value.bytes.data, size))
+		if (copy_to_user(valuep, data->value.bytes.data, size))
 			return -EFAULT;
 	}
 	return 0;
 }
 
-static int snd_ctl_elem_read_user_compat(struct snd_card *card, 
-					 struct snd_ctl_elem_value32 __user *data32)
+static int ctl_elem_read_user(struct snd_card *card,
+			      void __user *userdata, void __user *valuep)
 {
 	struct snd_ctl_elem_value *data;
 	int err, type, count;
@@ -294,7 +310,9 @@ static int snd_ctl_elem_read_user_compat(struct snd_card *card,
 	if (data == NULL)
 		return -ENOMEM;
 
-	if ((err = copy_ctl_value_from_user(card, data, data32, &type, &count)) < 0)
+	err = copy_ctl_value_from_user(card, data, userdata, valuep,
+				       &type, &count);
+	if (err < 0)
 		goto error;
 
 	snd_power_lock(card);
@@ -303,14 +321,15 @@ static int snd_ctl_elem_read_user_compat(struct snd_card *card,
 		err = snd_ctl_elem_read(card, data);
 	snd_power_unlock(card);
 	if (err >= 0)
-		err = copy_ctl_value_to_user(data32, data, type, count);
+		err = copy_ctl_value_to_user(userdata, valuep, data,
+					     type, count);
  error:
 	kfree(data);
 	return err;
 }
 
-static int snd_ctl_elem_write_user_compat(struct snd_ctl_file *file,
-					  struct snd_ctl_elem_value32 __user *data32)
+static int ctl_elem_write_user(struct snd_ctl_file *file,
+			       void __user *userdata, void __user *valuep)
 {
 	struct snd_ctl_elem_value *data;
 	struct snd_card *card = file->card;
@@ -320,7 +339,9 @@ static int snd_ctl_elem_write_user_compat(struct snd_ctl_file *file,
 	if (data == NULL)
 		return -ENOMEM;
 
-	if ((err = copy_ctl_value_from_user(card, data, data32, &type, &count)) < 0)
+	err = copy_ctl_value_from_user(card, data, userdata, valuep,
+				       &type, &count);
+	if (err < 0)
 		goto error;
 
 	snd_power_lock(card);
@@ -329,12 +350,39 @@ static int snd_ctl_elem_write_user_compat(struct snd_ctl_file *file,
 		err = snd_ctl_elem_write(card, file, data);
 	snd_power_unlock(card);
 	if (err >= 0)
-		err = copy_ctl_value_to_user(data32, data, type, count);
+		err = copy_ctl_value_to_user(userdata, valuep, data,
+					     type, count);
  error:
 	kfree(data);
 	return err;
 }
 
+static int snd_ctl_elem_read_user_compat(struct snd_card *card,
+					 struct snd_ctl_elem_value32 __user *data32)
+{
+	return ctl_elem_read_user(card, data32, &data32->value);
+}
+
+static int snd_ctl_elem_write_user_compat(struct snd_ctl_file *file,
+					  struct snd_ctl_elem_value32 __user *data32)
+{
+	return ctl_elem_write_user(file, data32, &data32->value);
+}
+
+#ifdef CONFIG_X86_X32
+static int snd_ctl_elem_read_user_x32(struct snd_card *card,
+				      struct snd_ctl_elem_value_x32 __user *data32)
+{
+	return ctl_elem_read_user(card, data32, &data32->value);
+}
+
+static int snd_ctl_elem_write_user_x32(struct snd_ctl_file *file,
+				       struct snd_ctl_elem_value_x32 __user *data32)
+{
+	return ctl_elem_write_user(file, data32, &data32->value);
+}
+#endif /* CONFIG_X86_X32 */
+
 /* add or replace a user control */
 static int snd_ctl_elem_add_compat(struct snd_ctl_file *file,
 				   struct snd_ctl_elem_info32 __user *data32,
@@ -393,6 +441,10 @@ enum {
 	SNDRV_CTL_IOCTL_ELEM_WRITE32 = _IOWR('U', 0x13, struct snd_ctl_elem_value32),
 	SNDRV_CTL_IOCTL_ELEM_ADD32 = _IOWR('U', 0x17, struct snd_ctl_elem_info32),
 	SNDRV_CTL_IOCTL_ELEM_REPLACE32 = _IOWR('U', 0x18, struct snd_ctl_elem_info32),
+#ifdef CONFIG_X86_X32
+	SNDRV_CTL_IOCTL_ELEM_READ_X32 = _IOWR('U', 0x12, struct snd_ctl_elem_value_x32),
+	SNDRV_CTL_IOCTL_ELEM_WRITE_X32 = _IOWR('U', 0x13, struct snd_ctl_elem_value_x32),
+#endif /* CONFIG_X86_X32 */
 };
 
 static inline long snd_ctl_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)
@@ -431,6 +483,12 @@ static inline long snd_ctl_ioctl_compat(struct file *file, unsigned int cmd, uns
 		return snd_ctl_elem_add_compat(ctl, argp, 0);
 	case SNDRV_CTL_IOCTL_ELEM_REPLACE32:
 		return snd_ctl_elem_add_compat(ctl, argp, 1);
+#ifdef CONFIG_X86_X32
+	case SNDRV_CTL_IOCTL_ELEM_READ_X32:
+		return snd_ctl_elem_read_user_x32(ctl->card, argp);
+	case SNDRV_CTL_IOCTL_ELEM_WRITE_X32:
+		return snd_ctl_elem_write_user_x32(ctl, argp);
+#endif /* CONFIG_X86_X32 */
 	}
 
 	down_read(&snd_ioctl_rwsem);
diff --git a/sound/core/hrtimer.c b/sound/core/hrtimer.c
index b8b31c4..14d483d 100644
--- a/sound/core/hrtimer.c
+++ b/sound/core/hrtimer.c
@@ -90,7 +90,7 @@ static int snd_hrtimer_start(struct snd_timer *t)
 	struct snd_hrtimer *stime = t->private_data;
 
 	atomic_set(&stime->running, 0);
-	hrtimer_cancel(&stime->hrt);
+	hrtimer_try_to_cancel(&stime->hrt);
 	hrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),
 		      HRTIMER_MODE_REL);
 	atomic_set(&stime->running, 1);
@@ -101,6 +101,7 @@ static int snd_hrtimer_stop(struct snd_timer *t)
 {
 	struct snd_hrtimer *stime = t->private_data;
 	atomic_set(&stime->running, 0);
+	hrtimer_try_to_cancel(&stime->hrt);
 	return 0;
 }
 
diff --git a/sound/core/oss/pcm_oss.c b/sound/core/oss/pcm_oss.c
index 4c1cc51..7417f96 100644
--- a/sound/core/oss/pcm_oss.c
+++ b/sound/core/oss/pcm_oss.c
@@ -834,7 +834,8 @@ static int choose_rate(struct snd_pcm_substream *substream,
 	return snd_pcm_hw_param_near(substream, params, SNDRV_PCM_HW_PARAM_RATE, best_rate, NULL);
 }
 
-static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream)
+static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream,
+				     bool trylock)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_pcm_hw_params *params, *sparams;
@@ -848,7 +849,10 @@ static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream)
 	struct snd_mask sformat_mask;
 	struct snd_mask mask;
 
-	if (mutex_lock_interruptible(&runtime->oss.params_lock))
+	if (trylock) {
+		if (!(mutex_trylock(&runtime->oss.params_lock)))
+			return -EAGAIN;
+	} else if (mutex_lock_interruptible(&runtime->oss.params_lock))
 		return -EINTR;
 	sw_params = kmalloc(sizeof(*sw_params), GFP_KERNEL);
 	params = kmalloc(sizeof(*params), GFP_KERNEL);
@@ -1091,7 +1095,7 @@ static int snd_pcm_oss_get_active_substream(struct snd_pcm_oss_file *pcm_oss_fil
 		if (asubstream == NULL)
 			asubstream = substream;
 		if (substream->runtime->oss.params) {
-			err = snd_pcm_oss_change_params(substream);
+			err = snd_pcm_oss_change_params(substream, false);
 			if (err < 0)
 				return err;
 		}
@@ -1130,7 +1134,7 @@ static int snd_pcm_oss_make_ready(struct snd_pcm_substream *substream)
 		return 0;
 	runtime = substream->runtime;
 	if (runtime->oss.params) {
-		err = snd_pcm_oss_change_params(substream);
+		err = snd_pcm_oss_change_params(substream, false);
 		if (err < 0)
 			return err;
 	}
@@ -2168,7 +2172,7 @@ static int snd_pcm_oss_get_space(struct snd_pcm_oss_file *pcm_oss_file, int stre
 	runtime = substream->runtime;
 
 	if (runtime->oss.params &&
-	    (err = snd_pcm_oss_change_params(substream)) < 0)
+	    (err = snd_pcm_oss_change_params(substream, false)) < 0)
 		return err;
 
 	info.fragsize = runtime->oss.period_bytes;
@@ -2804,7 +2808,12 @@ static int snd_pcm_oss_mmap(struct file *file, struct vm_area_struct *area)
 		return -EIO;
 	
 	if (runtime->oss.params) {
-		if ((err = snd_pcm_oss_change_params(substream)) < 0)
+		/* use mutex_trylock() for params_lock for avoiding a deadlock
+		 * between mmap_sem and params_lock taken by
+		 * copy_from/to_user() in snd_pcm_oss_write/read()
+		 */
+		err = snd_pcm_oss_change_params(substream, true);
+		if (err < 0)
 			return err;
 	}
 #ifdef CONFIG_SND_PCM_OSS_PLUGINS
diff --git a/sound/core/pcm_compat.c b/sound/core/pcm_compat.c
index c4ac3c1..1bb1a43 100644
--- a/sound/core/pcm_compat.c
+++ b/sound/core/pcm_compat.c
@@ -236,10 +236,15 @@ static int snd_pcm_ioctl_hw_params_compat(struct snd_pcm_substream *substream,
 	if (! (runtime = substream->runtime))
 		return -ENOTTY;
 
-	/* only fifo_size is different, so just copy all */
-	data = memdup_user(data32, sizeof(*data32));
-	if (IS_ERR(data))
-		return PTR_ERR(data);
+	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	/* only fifo_size (RO from userspace) is different, so just copy all */
+	if (copy_from_user(data, data32, sizeof(*data32))) {
+		err = -EFAULT;
+		goto error;
+	}
 
 	if (refine)
 		err = snd_pcm_hw_refine(substream, data);
diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c
index 7b596b5..500765f 100644
--- a/sound/core/rawmidi.c
+++ b/sound/core/rawmidi.c
@@ -934,31 +934,36 @@ static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,
 	unsigned long flags;
 	long result = 0, count1;
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
+	unsigned long appl_ptr;
 
+	spin_lock_irqsave(&runtime->lock, flags);
 	while (count > 0 && runtime->avail) {
 		count1 = runtime->buffer_size - runtime->appl_ptr;
 		if (count1 > count)
 			count1 = count;
-		spin_lock_irqsave(&runtime->lock, flags);
 		if (count1 > (int)runtime->avail)
 			count1 = runtime->avail;
+
+		/* update runtime->appl_ptr before unlocking for userbuf */
+		appl_ptr = runtime->appl_ptr;
+		runtime->appl_ptr += count1;
+		runtime->appl_ptr %= runtime->buffer_size;
+		runtime->avail -= count1;
+
 		if (kernelbuf)
-			memcpy(kernelbuf + result, runtime->buffer + runtime->appl_ptr, count1);
+			memcpy(kernelbuf + result, runtime->buffer + appl_ptr, count1);
 		if (userbuf) {
 			spin_unlock_irqrestore(&runtime->lock, flags);
 			if (copy_to_user(userbuf + result,
-					 runtime->buffer + runtime->appl_ptr, count1)) {
+					 runtime->buffer + appl_ptr, count1)) {
 				return result > 0 ? result : -EFAULT;
 			}
 			spin_lock_irqsave(&runtime->lock, flags);
 		}
-		runtime->appl_ptr += count1;
-		runtime->appl_ptr %= runtime->buffer_size;
-		runtime->avail -= count1;
-		spin_unlock_irqrestore(&runtime->lock, flags);
 		result += count1;
 		count -= count1;
 	}
+	spin_unlock_irqrestore(&runtime->lock, flags);
 	return result;
 }
 
@@ -1161,8 +1166,9 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,
 	unsigned long flags;
 	long count1, result;
 	struct snd_rawmidi_runtime *runtime = substream->runtime;
+	unsigned long appl_ptr;
 
-	if (snd_BUG_ON(!kernelbuf && !userbuf))
+	if (!kernelbuf && !userbuf)
 		return -EINVAL;
 	if (snd_BUG_ON(!runtime->buffer))
 		return -EINVAL;
@@ -1181,12 +1187,19 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,
 			count1 = count;
 		if (count1 > (long)runtime->avail)
 			count1 = runtime->avail;
+
+		/* update runtime->appl_ptr before unlocking for userbuf */
+		appl_ptr = runtime->appl_ptr;
+		runtime->appl_ptr += count1;
+		runtime->appl_ptr %= runtime->buffer_size;
+		runtime->avail -= count1;
+
 		if (kernelbuf)
-			memcpy(runtime->buffer + runtime->appl_ptr,
+			memcpy(runtime->buffer + appl_ptr,
 			       kernelbuf + result, count1);
 		else if (userbuf) {
 			spin_unlock_irqrestore(&runtime->lock, flags);
-			if (copy_from_user(runtime->buffer + runtime->appl_ptr,
+			if (copy_from_user(runtime->buffer + appl_ptr,
 					   userbuf + result, count1)) {
 				spin_lock_irqsave(&runtime->lock, flags);
 				result = result > 0 ? result : -EFAULT;
@@ -1194,9 +1207,6 @@ static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,
 			}
 			spin_lock_irqsave(&runtime->lock, flags);
 		}
-		runtime->appl_ptr += count1;
-		runtime->appl_ptr %= runtime->buffer_size;
-		runtime->avail -= count1;
 		result += count1;
 		count -= count1;
 	}
diff --git a/sound/core/rawmidi_compat.c b/sound/core/rawmidi_compat.c
index 5268c1f..09a8909 100644
--- a/sound/core/rawmidi_compat.c
+++ b/sound/core/rawmidi_compat.c
@@ -94,9 +94,58 @@ static int snd_rawmidi_ioctl_status_compat(struct snd_rawmidi_file *rfile,
 	return 0;
 }
 
+#ifdef CONFIG_X86_X32
+/* X32 ABI has 64bit timespec and 64bit alignment */
+struct snd_rawmidi_status_x32 {
+	s32 stream;
+	u32 rsvd; /* alignment */
+	struct timespec tstamp;
+	u32 avail;
+	u32 xruns;
+	unsigned char reserved[16];
+} __attribute__((packed));
+
+#define put_timespec(src, dst) copy_to_user(dst, src, sizeof(*dst))
+
+static int snd_rawmidi_ioctl_status_x32(struct snd_rawmidi_file *rfile,
+					struct snd_rawmidi_status_x32 __user *src)
+{
+	int err;
+	struct snd_rawmidi_status status;
+
+	if (rfile->output == NULL)
+		return -EINVAL;
+	if (get_user(status.stream, &src->stream))
+		return -EFAULT;
+
+	switch (status.stream) {
+	case SNDRV_RAWMIDI_STREAM_OUTPUT:
+		err = snd_rawmidi_output_status(rfile->output, &status);
+		break;
+	case SNDRV_RAWMIDI_STREAM_INPUT:
+		err = snd_rawmidi_input_status(rfile->input, &status);
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (err < 0)
+		return err;
+
+	if (put_timespec(&status.tstamp, &src->tstamp) ||
+	    put_user(status.avail, &src->avail) ||
+	    put_user(status.xruns, &src->xruns))
+		return -EFAULT;
+
+	return 0;
+}
+#endif /* CONFIG_X86_X32 */
+
 enum {
 	SNDRV_RAWMIDI_IOCTL_PARAMS32 = _IOWR('W', 0x10, struct snd_rawmidi_params32),
 	SNDRV_RAWMIDI_IOCTL_STATUS32 = _IOWR('W', 0x20, struct snd_rawmidi_status32),
+#ifdef CONFIG_X86_X32
+	SNDRV_RAWMIDI_IOCTL_STATUS_X32 = _IOWR('W', 0x20, struct snd_rawmidi_status_x32),
+#endif /* CONFIG_X86_X32 */
 };
 
 static long snd_rawmidi_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)
@@ -115,6 +164,10 @@ static long snd_rawmidi_ioctl_compat(struct file *file, unsigned int cmd, unsign
 		return snd_rawmidi_ioctl_params_compat(rfile, argp);
 	case SNDRV_RAWMIDI_IOCTL_STATUS32:
 		return snd_rawmidi_ioctl_status_compat(rfile, argp);
+#ifdef CONFIG_X86_X32
+	case SNDRV_RAWMIDI_IOCTL_STATUS_X32:
+		return snd_rawmidi_ioctl_status_x32(rfile, argp);
+#endif /* CONFIG_X86_X32 */
 	}
 	return -ENOIOCTLCMD;
 }
diff --git a/sound/core/seq/oss/seq_oss.c b/sound/core/seq/oss/seq_oss.c
index 8d4d5e8..ab77495 100644
--- a/sound/core/seq/oss/seq_oss.c
+++ b/sound/core/seq/oss/seq_oss.c
@@ -150,8 +150,6 @@ odev_release(struct inode *inode, struct file *file)
 	if ((dp = file->private_data) == NULL)
 		return 0;
 
-	snd_seq_oss_drain_write(dp);
-
 	mutex_lock(&register_mutex);
 	snd_seq_oss_release(dp);
 	mutex_unlock(&register_mutex);
diff --git a/sound/core/seq/oss/seq_oss_device.h b/sound/core/seq/oss/seq_oss_device.h
index c0154a9..2464112 100644
--- a/sound/core/seq/oss/seq_oss_device.h
+++ b/sound/core/seq/oss/seq_oss_device.h
@@ -131,7 +131,6 @@ int snd_seq_oss_write(struct seq_oss_devinfo *dp, const char __user *buf, int co
 unsigned int snd_seq_oss_poll(struct seq_oss_devinfo *dp, struct file *file, poll_table * wait);
 
 void snd_seq_oss_reset(struct seq_oss_devinfo *dp);
-void snd_seq_oss_drain_write(struct seq_oss_devinfo *dp);
 
 /* */
 void snd_seq_oss_process_queue(struct seq_oss_devinfo *dp, abstime_t time);
diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c
index b3f39b5..f9e09e4 100644
--- a/sound/core/seq/oss/seq_oss_init.c
+++ b/sound/core/seq/oss/seq_oss_init.c
@@ -457,23 +457,6 @@ snd_seq_oss_release(struct seq_oss_devinfo *dp)
 
 
 /*
- * Wait until the queue is empty (if we don't have nonblock)
- */
-void
-snd_seq_oss_drain_write(struct seq_oss_devinfo *dp)
-{
-	if (! dp->timer->running)
-		return;
-	if (is_write_mode(dp->file_mode) && !is_nonblock_mode(dp->file_mode) &&
-	    dp->writeq) {
-		debug_printk(("syncing..\n"));
-		while (snd_seq_oss_writeq_sync(dp->writeq))
-			;
-	}
-}
-
-
-/*
  * reset sequencer devices
  */
 void
diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c
index c5b773a..4a09c30 100644
--- a/sound/core/seq/oss/seq_oss_synth.c
+++ b/sound/core/seq/oss/seq_oss_synth.c
@@ -310,7 +310,7 @@ snd_seq_oss_synth_cleanup(struct seq_oss_devinfo *dp)
 	struct seq_oss_synth *rec;
 	struct seq_oss_synthinfo *info;
 
-	if (snd_BUG_ON(dp->max_synthdev >= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))
+	if (snd_BUG_ON(dp->max_synthdev > SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))
 		return;
 	for (i = 0; i < dp->max_synthdev; i++) {
 		info = &dp->synths[i];
diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c
index 4dc6bae..08865dc 100644
--- a/sound/core/seq/seq_clientmgr.c
+++ b/sound/core/seq/seq_clientmgr.c
@@ -678,6 +678,9 @@ static int deliver_to_subscribers(struct snd_seq_client *client,
 	else
 		down_read(&grp->list_mutex);
 	list_for_each_entry(subs, &grp->list_head, src_list) {
+		/* both ports ready? */
+		if (atomic_read(&subs->ref_count) != 2)
+			continue;
 		event->dest = subs->info.dest;
 		if (subs->info.flags & SNDRV_SEQ_PORT_SUBS_TIMESTAMP)
 			/* convert time according to flag with subscription */
@@ -1950,7 +1953,7 @@ static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,
 		 * No restrictions so for a user client we can clear
 		 * the whole fifo
 		 */
-		if (client->type == USER_CLIENT)
+		if (client->type == USER_CLIENT && client->data.user.fifo)
 			snd_seq_fifo_clear(client->data.user.fifo);
 	}
 
diff --git a/sound/core/seq/seq_compat.c b/sound/core/seq/seq_compat.c
index 81f7c10..6517590 100644
--- a/sound/core/seq/seq_compat.c
+++ b/sound/core/seq/seq_compat.c
@@ -49,11 +49,12 @@ static int snd_seq_call_port_info_ioctl(struct snd_seq_client *client, unsigned
 	struct snd_seq_port_info *data;
 	mm_segment_t fs;
 
-	data = memdup_user(data32, sizeof(*data32));
-	if (IS_ERR(data))
-		return PTR_ERR(data);
+	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
 
-	if (get_user(data->flags, &data32->flags) ||
+	if (copy_from_user(data, data32, sizeof(*data32)) ||
+	    get_user(data->flags, &data32->flags) ||
 	    get_user(data->time_queue, &data32->time_queue))
 		goto error;
 	data->kernel = NULL;
diff --git a/sound/core/seq/seq_ports.c b/sound/core/seq/seq_ports.c
index 9516e5c..ee0522a 100644
--- a/sound/core/seq/seq_ports.c
+++ b/sound/core/seq/seq_ports.c
@@ -175,10 +175,6 @@ struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 }
 
 /* */
-enum group_type {
-	SRC_LIST, DEST_LIST
-};
-
 static int subscribe_port(struct snd_seq_client *client,
 			  struct snd_seq_client_port *port,
 			  struct snd_seq_port_subs_info *grp,
@@ -205,6 +201,20 @@ static struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,
 	return NULL;
 }
 
+static void delete_and_unsubscribe_port(struct snd_seq_client *client,
+					struct snd_seq_client_port *port,
+					struct snd_seq_subscribers *subs,
+					bool is_src, bool ack);
+
+static inline struct snd_seq_subscribers *
+get_subscriber(struct list_head *p, bool is_src)
+{
+	if (is_src)
+		return list_entry(p, struct snd_seq_subscribers, src_list);
+	else
+		return list_entry(p, struct snd_seq_subscribers, dest_list);
+}
+
 /*
  * remove all subscribers on the list
  * this is called from port_delete, for each src and dest list.
@@ -212,7 +222,7 @@ static struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,
 static void clear_subscriber_list(struct snd_seq_client *client,
 				  struct snd_seq_client_port *port,
 				  struct snd_seq_port_subs_info *grp,
-				  int grptype)
+				  int is_src)
 {
 	struct list_head *p, *n;
 
@@ -221,15 +231,13 @@ static void clear_subscriber_list(struct snd_seq_client *client,
 		struct snd_seq_client *c;
 		struct snd_seq_client_port *aport;
 
-		if (grptype == SRC_LIST) {
-			subs = list_entry(p, struct snd_seq_subscribers, src_list);
+		subs = get_subscriber(p, is_src);
+		if (is_src)
 			aport = get_client_port(&subs->info.dest, &c);
-		} else {
-			subs = list_entry(p, struct snd_seq_subscribers, dest_list);
+		else
 			aport = get_client_port(&subs->info.sender, &c);
-		}
-		list_del(p);
-		unsubscribe_port(client, port, grp, &subs->info, 0);
+		delete_and_unsubscribe_port(client, port, subs, is_src, false);
+
 		if (!aport) {
 			/* looks like the connected port is being deleted.
 			 * we decrease the counter, and when both ports are deleted
@@ -237,21 +245,14 @@ static void clear_subscriber_list(struct snd_seq_client *client,
 			 */
 			if (atomic_dec_and_test(&subs->ref_count))
 				kfree(subs);
-		} else {
-			/* ok we got the connected port */
-			struct snd_seq_port_subs_info *agrp;
-			agrp = (grptype == SRC_LIST) ? &aport->c_dest : &aport->c_src;
-			down_write(&agrp->list_mutex);
-			if (grptype == SRC_LIST)
-				list_del(&subs->dest_list);
-			else
-				list_del(&subs->src_list);
-			up_write(&agrp->list_mutex);
-			unsubscribe_port(c, aport, agrp, &subs->info, 1);
-			kfree(subs);
-			snd_seq_port_unlock(aport);
-			snd_seq_client_unlock(c);
+			continue;
 		}
+
+		/* ok we got the connected port */
+		delete_and_unsubscribe_port(c, aport, subs, !is_src, true);
+		kfree(subs);
+		snd_seq_port_unlock(aport);
+		snd_seq_client_unlock(c);
 	}
 }
 
@@ -264,8 +265,8 @@ static int port_delete(struct snd_seq_client *client,
 	snd_use_lock_sync(&port->use_lock); 
 
 	/* clear subscribers info */
-	clear_subscriber_list(client, port, &port->c_src, SRC_LIST);
-	clear_subscriber_list(client, port, &port->c_dest, DEST_LIST);
+	clear_subscriber_list(client, port, &port->c_src, true);
+	clear_subscriber_list(client, port, &port->c_dest, false);
 
 	if (port->private_free)
 		port->private_free(port->private_data);
@@ -484,85 +485,123 @@ static int match_subs_info(struct snd_seq_port_subscribe *r,
 	return 0;
 }
 
-
-/* connect two ports */
-int snd_seq_port_connect(struct snd_seq_client *connector,
-			 struct snd_seq_client *src_client,
-			 struct snd_seq_client_port *src_port,
-			 struct snd_seq_client *dest_client,
-			 struct snd_seq_client_port *dest_port,
-			 struct snd_seq_port_subscribe *info)
+static int check_and_subscribe_port(struct snd_seq_client *client,
+				    struct snd_seq_client_port *port,
+				    struct snd_seq_subscribers *subs,
+				    bool is_src, bool exclusive, bool ack)
 {
-	struct snd_seq_port_subs_info *src = &src_port->c_src;
-	struct snd_seq_port_subs_info *dest = &dest_port->c_dest;
-	struct snd_seq_subscribers *subs, *s;
-	int err, src_called = 0;
-	unsigned long flags;
-	int exclusive;
-
-	subs = kzalloc(sizeof(*subs), GFP_KERNEL);
-	if (! subs)
-		return -ENOMEM;
-
-	subs->info = *info;
-	atomic_set(&subs->ref_count, 2);
+	struct snd_seq_port_subs_info *grp;
+	struct list_head *p;
+	struct snd_seq_subscribers *s;
+	int err;
 
-	down_write(&src->list_mutex);
-	down_write_nested(&dest->list_mutex, SINGLE_DEPTH_NESTING);
-
-	exclusive = info->flags & SNDRV_SEQ_PORT_SUBS_EXCLUSIVE ? 1 : 0;
+	grp = is_src ? &port->c_src : &port->c_dest;
 	err = -EBUSY;
+	down_write(&grp->list_mutex);
 	if (exclusive) {
-		if (! list_empty(&src->list_head) || ! list_empty(&dest->list_head))
+		if (!list_empty(&grp->list_head))
 			goto __error;
 	} else {
-		if (src->exclusive || dest->exclusive)
+		if (grp->exclusive)
 			goto __error;
 		/* check whether already exists */
-		list_for_each_entry(s, &src->list_head, src_list) {
-			if (match_subs_info(info, &s->info))
-				goto __error;
-		}
-		list_for_each_entry(s, &dest->list_head, dest_list) {
-			if (match_subs_info(info, &s->info))
+		list_for_each(p, &grp->list_head) {
+			s = get_subscriber(p, is_src);
+			if (match_subs_info(&subs->info, &s->info))
 				goto __error;
 		}
 	}
 
-	if ((err = subscribe_port(src_client, src_port, src, info,
-				  connector->number != src_client->number)) < 0)
-		goto __error;
-	src_called = 1;
-
-	if ((err = subscribe_port(dest_client, dest_port, dest, info,
-				  connector->number != dest_client->number)) < 0)
+	err = subscribe_port(client, port, grp, &subs->info, ack);
+	if (err < 0) {
+		grp->exclusive = 0;
 		goto __error;
+	}
 
 	/* add to list */
-	write_lock_irqsave(&src->list_lock, flags);
-	// write_lock(&dest->list_lock); // no other lock yet
-	list_add_tail(&subs->src_list, &src->list_head);
-	list_add_tail(&subs->dest_list, &dest->list_head);
-	// write_unlock(&dest->list_lock); // no other lock yet
-	write_unlock_irqrestore(&src->list_lock, flags);
+	write_lock_irq(&grp->list_lock);
+	if (is_src)
+		list_add_tail(&subs->src_list, &grp->list_head);
+	else
+		list_add_tail(&subs->dest_list, &grp->list_head);
+	grp->exclusive = exclusive;
+	atomic_inc(&subs->ref_count);
+	write_unlock_irq(&grp->list_lock);
+	err = 0;
 
-	src->exclusive = dest->exclusive = exclusive;
+ __error:
+	up_write(&grp->list_mutex);
+	return err;
+}
+
+static void delete_and_unsubscribe_port(struct snd_seq_client *client,
+					struct snd_seq_client_port *port,
+					struct snd_seq_subscribers *subs,
+					bool is_src, bool ack)
+{
+	struct snd_seq_port_subs_info *grp;
+	struct list_head *list;
+	bool empty;
+
+	grp = is_src ? &port->c_src : &port->c_dest;
+	list = is_src ? &subs->src_list : &subs->dest_list;
+	down_write(&grp->list_mutex);
+	write_lock_irq(&grp->list_lock);
+	empty = list_empty(list);
+	if (!empty)
+		list_del_init(list);
+	grp->exclusive = 0;
+	write_unlock_irq(&grp->list_lock);
+	up_write(&grp->list_mutex);
+
+	if (!empty)
+		unsubscribe_port(client, port, grp, &subs->info, ack);
+}
+
+/* connect two ports */
+int snd_seq_port_connect(struct snd_seq_client *connector,
+			 struct snd_seq_client *src_client,
+			 struct snd_seq_client_port *src_port,
+			 struct snd_seq_client *dest_client,
+			 struct snd_seq_client_port *dest_port,
+			 struct snd_seq_port_subscribe *info)
+{
+	struct snd_seq_subscribers *subs;
+	bool exclusive;
+	int err;
+
+	subs = kzalloc(sizeof(*subs), GFP_KERNEL);
+	if (!subs)
+		return -ENOMEM;
+
+	subs->info = *info;
+	atomic_set(&subs->ref_count, 0);
+	INIT_LIST_HEAD(&subs->src_list);
+	INIT_LIST_HEAD(&subs->dest_list);
+
+	exclusive = !!(info->flags & SNDRV_SEQ_PORT_SUBS_EXCLUSIVE);
+
+	err = check_and_subscribe_port(src_client, src_port, subs, true,
+				       exclusive,
+				       connector->number != src_client->number);
+	if (err < 0)
+		goto error;
+	err = check_and_subscribe_port(dest_client, dest_port, subs, false,
+				       exclusive,
+				       connector->number != dest_client->number);
+	if (err < 0)
+		goto error_dest;
 
-	up_write(&dest->list_mutex);
-	up_write(&src->list_mutex);
 	return 0;
 
- __error:
-	if (src_called)
-		unsubscribe_port(src_client, src_port, src, info,
-				 connector->number != src_client->number);
+ error_dest:
+	delete_and_unsubscribe_port(src_client, src_port, subs, true,
+				    connector->number != src_client->number);
+ error:
 	kfree(subs);
-	up_write(&dest->list_mutex);
-	up_write(&src->list_mutex);
 	return err;
 }
 
-
 /* remove the connection */
 int snd_seq_port_disconnect(struct snd_seq_client *connector,
 			    struct snd_seq_client *src_client,
@@ -572,37 +611,28 @@ int snd_seq_port_disconnect(struct snd_seq_client *connector,
 			    struct snd_seq_port_subscribe *info)
 {
 	struct snd_seq_port_subs_info *src = &src_port->c_src;
-	struct snd_seq_port_subs_info *dest = &dest_port->c_dest;
 	struct snd_seq_subscribers *subs;
 	int err = -ENOENT;
-	unsigned long flags;
 
 	down_write(&src->list_mutex);
-	down_write_nested(&dest->list_mutex, SINGLE_DEPTH_NESTING);
-
 	/* look for the connection */
 	list_for_each_entry(subs, &src->list_head, src_list) {
 		if (match_subs_info(info, &subs->info)) {
-			write_lock_irqsave(&src->list_lock, flags);
-			// write_lock(&dest->list_lock);  // no lock yet
-			list_del(&subs->src_list);
-			list_del(&subs->dest_list);
-			// write_unlock(&dest->list_lock);
-			write_unlock_irqrestore(&src->list_lock, flags);
-			src->exclusive = dest->exclusive = 0;
-			unsubscribe_port(src_client, src_port, src, info,
-					 connector->number != src_client->number);
-			unsubscribe_port(dest_client, dest_port, dest, info,
-					 connector->number != dest_client->number);
-			kfree(subs);
+			atomic_dec(&subs->ref_count); /* mark as not ready */
 			err = 0;
 			break;
 		}
 	}
-
-	up_write(&dest->list_mutex);
 	up_write(&src->list_mutex);
-	return err;
+	if (err < 0)
+		return err;
+
+	delete_and_unsubscribe_port(src_client, src_port, subs, true,
+				    connector->number != src_client->number);
+	delete_and_unsubscribe_port(dest_client, dest_port, subs, false,
+				    connector->number != dest_client->number);
+	kfree(subs);
+	return 0;
 }
 
 
diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c
index f907736..4c9aa46 100644
--- a/sound/core/seq/seq_queue.c
+++ b/sound/core/seq/seq_queue.c
@@ -144,8 +144,10 @@ static struct snd_seq_queue *queue_new(int owner, int locked)
 static void queue_delete(struct snd_seq_queue *q)
 {
 	/* stop and release the timer */
+	mutex_lock(&q->timer_mutex);
 	snd_seq_timer_stop(q->timer);
 	snd_seq_timer_close(q);
+	mutex_unlock(&q->timer_mutex);
 	/* wait until access free */
 	snd_use_lock_sync(&q->use_lock);
 	/* release resources... */
diff --git a/sound/core/seq/seq_timer.c b/sound/core/seq/seq_timer.c
index 24d44b2..6ec30a9 100644
--- a/sound/core/seq/seq_timer.c
+++ b/sound/core/seq/seq_timer.c
@@ -92,6 +92,9 @@ void snd_seq_timer_delete(struct snd_seq_timer **tmr)
 
 void snd_seq_timer_defaults(struct snd_seq_timer * tmr)
 {
+	unsigned long flags;
+
+	spin_lock_irqsave(&tmr->lock, flags);
 	/* setup defaults */
 	tmr->ppq = 96;		/* 96 PPQ */
 	tmr->tempo = 500000;	/* 120 BPM */
@@ -107,21 +110,25 @@ void snd_seq_timer_defaults(struct snd_seq_timer * tmr)
 	tmr->preferred_resolution = seq_default_timer_resolution;
 
 	tmr->skew = tmr->skew_base = SKEW_BASE;
+	spin_unlock_irqrestore(&tmr->lock, flags);
 }
 
-void snd_seq_timer_reset(struct snd_seq_timer * tmr)
+static void seq_timer_reset(struct snd_seq_timer *tmr)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&tmr->lock, flags);
-
 	/* reset time & songposition */
 	tmr->cur_time.tv_sec = 0;
 	tmr->cur_time.tv_nsec = 0;
 
 	tmr->tick.cur_tick = 0;
 	tmr->tick.fraction = 0;
+}
+
+void snd_seq_timer_reset(struct snd_seq_timer *tmr)
+{
+	unsigned long flags;
 
+	spin_lock_irqsave(&tmr->lock, flags);
+	seq_timer_reset(tmr);
 	spin_unlock_irqrestore(&tmr->lock, flags);
 }
 
@@ -140,8 +147,11 @@ static void snd_seq_timer_interrupt(struct snd_timer_instance *timeri,
 	tmr = q->timer;
 	if (tmr == NULL)
 		return;
-	if (!tmr->running)
+	spin_lock_irqsave(&tmr->lock, flags);
+	if (!tmr->running) {
+		spin_unlock_irqrestore(&tmr->lock, flags);
 		return;
+	}
 
 	resolution *= ticks;
 	if (tmr->skew != tmr->skew_base) {
@@ -150,8 +160,6 @@ static void snd_seq_timer_interrupt(struct snd_timer_instance *timeri,
 			(((resolution & 0xffff) * tmr->skew) >> 16);
 	}
 
-	spin_lock_irqsave(&tmr->lock, flags);
-
 	/* update timer */
 	snd_seq_inc_time_nsec(&tmr->cur_time, resolution);
 
@@ -298,26 +306,30 @@ int snd_seq_timer_open(struct snd_seq_queue *q)
 	t->callback = snd_seq_timer_interrupt;
 	t->callback_data = q;
 	t->flags |= SNDRV_TIMER_IFLG_AUTO;
+	spin_lock_irq(&tmr->lock);
 	tmr->timeri = t;
+	spin_unlock_irq(&tmr->lock);
 	return 0;
 }
 
 int snd_seq_timer_close(struct snd_seq_queue *q)
 {
 	struct snd_seq_timer *tmr;
+	struct snd_timer_instance *t;
 	
 	tmr = q->timer;
 	if (snd_BUG_ON(!tmr))
 		return -EINVAL;
-	if (tmr->timeri) {
-		snd_timer_stop(tmr->timeri);
-		snd_timer_close(tmr->timeri);
-		tmr->timeri = NULL;
-	}
+	spin_lock_irq(&tmr->lock);
+	t = tmr->timeri;
+	tmr->timeri = NULL;
+	spin_unlock_irq(&tmr->lock);
+	if (t)
+		snd_timer_close(t);
 	return 0;
 }
 
-int snd_seq_timer_stop(struct snd_seq_timer * tmr)
+static int seq_timer_stop(struct snd_seq_timer *tmr)
 {
 	if (! tmr->timeri)
 		return -EINVAL;
@@ -328,6 +340,17 @@ int snd_seq_timer_stop(struct snd_seq_timer * tmr)
 	return 0;
 }
 
+int snd_seq_timer_stop(struct snd_seq_timer *tmr)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&tmr->lock, flags);
+	err = seq_timer_stop(tmr);
+	spin_unlock_irqrestore(&tmr->lock, flags);
+	return err;
+}
+
 static int initialize_timer(struct snd_seq_timer *tmr)
 {
 	struct snd_timer *t;
@@ -360,13 +383,13 @@ static int initialize_timer(struct snd_seq_timer *tmr)
 	return 0;
 }
 
-int snd_seq_timer_start(struct snd_seq_timer * tmr)
+static int seq_timer_start(struct snd_seq_timer *tmr)
 {
 	if (! tmr->timeri)
 		return -EINVAL;
 	if (tmr->running)
-		snd_seq_timer_stop(tmr);
-	snd_seq_timer_reset(tmr);
+		seq_timer_stop(tmr);
+	seq_timer_reset(tmr);
 	if (initialize_timer(tmr) < 0)
 		return -EINVAL;
 	snd_timer_start(tmr->timeri, tmr->ticks);
@@ -375,14 +398,25 @@ int snd_seq_timer_start(struct snd_seq_timer * tmr)
 	return 0;
 }
 
-int snd_seq_timer_continue(struct snd_seq_timer * tmr)
+int snd_seq_timer_start(struct snd_seq_timer *tmr)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&tmr->lock, flags);
+	err = seq_timer_start(tmr);
+	spin_unlock_irqrestore(&tmr->lock, flags);
+	return err;
+}
+
+static int seq_timer_continue(struct snd_seq_timer *tmr)
 {
 	if (! tmr->timeri)
 		return -EINVAL;
 	if (tmr->running)
 		return -EBUSY;
 	if (! tmr->initialized) {
-		snd_seq_timer_reset(tmr);
+		seq_timer_reset(tmr);
 		if (initialize_timer(tmr) < 0)
 			return -EINVAL;
 	}
@@ -392,11 +426,24 @@ int snd_seq_timer_continue(struct snd_seq_timer * tmr)
 	return 0;
 }
 
+int snd_seq_timer_continue(struct snd_seq_timer *tmr)
+{
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&tmr->lock, flags);
+	err = seq_timer_continue(tmr);
+	spin_unlock_irqrestore(&tmr->lock, flags);
+	return err;
+}
+
 /* return current 'real' time. use timeofday() to get better granularity. */
 snd_seq_real_time_t snd_seq_timer_get_cur_time(struct snd_seq_timer *tmr)
 {
 	snd_seq_real_time_t cur_time;
+	unsigned long flags;
 
+	spin_lock_irqsave(&tmr->lock, flags);
 	cur_time = tmr->cur_time;
 	if (tmr->running) { 
 		struct timeval tm;
@@ -412,7 +459,7 @@ snd_seq_real_time_t snd_seq_timer_get_cur_time(struct snd_seq_timer *tmr)
 		}
 		snd_seq_sanity_real_time(&cur_time);
 	}
-                
+	spin_unlock_irqrestore(&tmr->lock, flags);
 	return cur_time;	
 }
 
diff --git a/sound/core/seq/seq_virmidi.c b/sound/core/seq/seq_virmidi.c
index 4b50e60..0fa691e 100644
--- a/sound/core/seq/seq_virmidi.c
+++ b/sound/core/seq/seq_virmidi.c
@@ -254,9 +254,13 @@ static int snd_virmidi_output_open(struct snd_rawmidi_substream *substream)
  */
 static int snd_virmidi_input_close(struct snd_rawmidi_substream *substream)
 {
+	struct snd_virmidi_dev *rdev = substream->rmidi->private_data;
 	struct snd_virmidi *vmidi = substream->runtime->private_data;
-	snd_midi_event_free(vmidi->parser);
+
+	write_lock_irq(&rdev->filelist_lock);
 	list_del(&vmidi->list);
+	write_unlock_irq(&rdev->filelist_lock);
+	snd_midi_event_free(vmidi->parser);
 	substream->runtime->private_data = NULL;
 	kfree(vmidi);
 	return 0;
diff --git a/sound/core/timer.c b/sound/core/timer.c
index 6ddcf06..3476895 100644
--- a/sound/core/timer.c
+++ b/sound/core/timer.c
@@ -73,7 +73,7 @@ struct snd_timer_user {
 	struct timespec tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
-	struct mutex tread_sem;
+	struct mutex ioctl_lock;
 };
 
 /* list of timers */
@@ -215,11 +215,13 @@ static void snd_timer_check_master(struct snd_timer_instance *master)
 		    slave->slave_id == master->slave_id) {
 			list_move_tail(&slave->open_list, &master->slave_list_head);
 			spin_lock_irq(&slave_active_lock);
+			spin_lock(&master->timer->lock);
 			slave->master = master;
 			slave->timer = master->timer;
 			if (slave->flags & SNDRV_TIMER_IFLG_RUNNING)
 				list_add_tail(&slave->active_list,
 					      &master->slave_active_head);
+			spin_unlock(&master->timer->lock);
 			spin_unlock_irq(&slave_active_lock);
 		}
 	}
@@ -298,8 +300,7 @@ int snd_timer_open(struct snd_timer_instance **ti,
 	return 0;
 }
 
-static int _snd_timer_stop(struct snd_timer_instance *timeri,
-			   int keep_flag, int event);
+static int _snd_timer_stop(struct snd_timer_instance *timeri, int event);
 
 /*
  * close a timer instance
@@ -341,19 +342,22 @@ int snd_timer_close(struct snd_timer_instance *timeri)
 		spin_unlock_irq(&timer->lock);
 		mutex_lock(&register_mutex);
 		list_del(&timeri->open_list);
-		if (timer && list_empty(&timer->open_list_head) &&
+		if (list_empty(&timer->open_list_head) &&
 		    timer->hw.close)
 			timer->hw.close(timer);
 		/* remove slave links */
+		spin_lock_irq(&slave_active_lock);
+		spin_lock(&timer->lock);
 		list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,
 					 open_list) {
-			spin_lock_irq(&slave_active_lock);
-			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
 			list_move_tail(&slave->open_list, &snd_timer_slave_list);
 			slave->master = NULL;
 			slave->timer = NULL;
-			spin_unlock_irq(&slave_active_lock);
+			list_del_init(&slave->ack_list);
+			list_del_init(&slave->active_list);
 		}
+		spin_unlock(&timer->lock);
+		spin_unlock_irq(&slave_active_lock);
 		mutex_unlock(&register_mutex);
 	}
  out:
@@ -410,7 +414,7 @@ static void snd_timer_notify1(struct snd_timer_instance *ti, int event)
 	spin_lock_irqsave(&timer->lock, flags);
 	list_for_each_entry(ts, &ti->slave_active_head, active_list)
 		if (ts->ccallback)
-			ts->ccallback(ti, event + 100, &tstamp, resolution);
+			ts->ccallback(ts, event + 100, &tstamp, resolution);
 	spin_unlock_irqrestore(&timer->lock, flags);
 }
 
@@ -439,10 +443,17 @@ static int snd_timer_start_slave(struct snd_timer_instance *timeri)
 	unsigned long flags;
 
 	spin_lock_irqsave(&slave_active_lock, flags);
+	if (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {
+		spin_unlock_irqrestore(&slave_active_lock, flags);
+		return -EBUSY;
+	}
 	timeri->flags |= SNDRV_TIMER_IFLG_RUNNING;
-	if (timeri->master)
+	if (timeri->master && timeri->timer) {
+		spin_lock(&timeri->timer->lock);
 		list_add_tail(&timeri->active_list,
 			      &timeri->master->slave_active_head);
+		spin_unlock(&timeri->timer->lock);
+	}
 	spin_unlock_irqrestore(&slave_active_lock, flags);
 	return 1; /* delayed start */
 }
@@ -460,23 +471,30 @@ int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)
 		return -EINVAL;
 	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
 		result = snd_timer_start_slave(timeri);
-		snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
+		if (result >= 0)
+			snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
 		return result;
 	}
 	timer = timeri->timer;
 	if (timer == NULL)
 		return -EINVAL;
 	spin_lock_irqsave(&timer->lock, flags);
+	if (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |
+			     SNDRV_TIMER_IFLG_START)) {
+		result = -EBUSY;
+		goto unlock;
+	}
 	timeri->ticks = timeri->cticks = ticks;
 	timeri->pticks = 0;
 	result = snd_timer_start1(timer, timeri, ticks);
+ unlock:
 	spin_unlock_irqrestore(&timer->lock, flags);
-	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
+	if (result >= 0)
+		snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);
 	return result;
 }
 
-static int _snd_timer_stop(struct snd_timer_instance * timeri,
-			   int keep_flag, int event)
+static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)
 {
 	struct snd_timer *timer;
 	unsigned long flags;
@@ -485,17 +503,30 @@ static int _snd_timer_stop(struct snd_timer_instance * timeri,
 		return -ENXIO;
 
 	if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
-		if (!keep_flag) {
-			spin_lock_irqsave(&slave_active_lock, flags);
-			timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
+		spin_lock_irqsave(&slave_active_lock, flags);
+		if (!(timeri->flags & SNDRV_TIMER_IFLG_RUNNING)) {
 			spin_unlock_irqrestore(&slave_active_lock, flags);
+			return -EBUSY;
 		}
+		if (timeri->timer)
+			spin_lock(&timeri->timer->lock);
+		timeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
+		list_del_init(&timeri->ack_list);
+		list_del_init(&timeri->active_list);
+		if (timeri->timer)
+			spin_unlock(&timeri->timer->lock);
+		spin_unlock_irqrestore(&slave_active_lock, flags);
 		goto __end;
 	}
 	timer = timeri->timer;
 	if (!timer)
 		return -EINVAL;
 	spin_lock_irqsave(&timer->lock, flags);
+	if (!(timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |
+			       SNDRV_TIMER_IFLG_START))) {
+		spin_unlock_irqrestore(&timer->lock, flags);
+		return -EBUSY;
+	}
 	list_del_init(&timeri->ack_list);
 	list_del_init(&timeri->active_list);
 	if ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&
@@ -510,9 +541,7 @@ static int _snd_timer_stop(struct snd_timer_instance * timeri,
 			}
 		}
 	}
-	if (!keep_flag)
-		timeri->flags &=
-			~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);
+	timeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);
 	spin_unlock_irqrestore(&timer->lock, flags);
       __end:
 	if (event != SNDRV_TIMER_EVENT_RESOLUTION)
@@ -531,7 +560,7 @@ int snd_timer_stop(struct snd_timer_instance *timeri)
 	unsigned long flags;
 	int err;
 
-	err = _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_STOP);
+	err = _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_STOP);
 	if (err < 0)
 		return err;
 	timer = timeri->timer;
@@ -561,10 +590,15 @@ int snd_timer_continue(struct snd_timer_instance *timeri)
 	if (! timer)
 		return -EINVAL;
 	spin_lock_irqsave(&timer->lock, flags);
+	if (timeri->flags & SNDRV_TIMER_IFLG_RUNNING) {
+		result = -EBUSY;
+		goto unlock;
+	}
 	if (!timeri->cticks)
 		timeri->cticks = 1;
 	timeri->pticks = 0;
 	result = snd_timer_start1(timer, timeri, timer->sticks);
+ unlock:
 	spin_unlock_irqrestore(&timer->lock, flags);
 	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_CONTINUE);
 	return result;
@@ -575,7 +609,7 @@ int snd_timer_continue(struct snd_timer_instance *timeri)
  */
 int snd_timer_pause(struct snd_timer_instance * timeri)
 {
-	return _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_PAUSE);
+	return _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_PAUSE);
 }
 
 /*
@@ -692,8 +726,8 @@ void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 			ti->cticks = ti->ticks;
 		} else {
 			ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
-			if (--timer->running)
-				list_del(&ti->active_list);
+			--timer->running;
+			list_del_init(&ti->active_list);
 		}
 		if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
 		    (ti->flags & SNDRV_TIMER_IFLG_FAST))
@@ -978,8 +1012,8 @@ static int snd_timer_s_start(struct snd_timer * timer)
 		njiff += timer->sticks - priv->correction;
 		priv->correction = 0;
 	}
-	priv->last_expires = priv->tlist.expires = njiff;
-	add_timer(&priv->tlist);
+	priv->last_expires = njiff;
+	mod_timer(&priv->tlist, njiff);
 	return 0;
 }
 
@@ -1174,6 +1208,7 @@ static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
 		tu->tstamp = *tstamp;
 	if ((tu->filter & (1 << event)) == 0 || !tu->tread)
 		return;
+	memset(&r1, 0, sizeof(r1));
 	r1.event = event;
 	r1.tstamp = *tstamp;
 	r1.val = resolution;
@@ -1208,6 +1243,7 @@ static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,
 	}
 	if ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&
 	    tu->last_resolution != resolution) {
+		memset(&r1, 0, sizeof(r1));
 		r1.event = SNDRV_TIMER_EVENT_RESOLUTION;
 		r1.tstamp = tstamp;
 		r1.val = resolution;
@@ -1256,7 +1292,7 @@ static int snd_timer_user_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 	spin_lock_init(&tu->qlock);
 	init_waitqueue_head(&tu->qchange_sleep);
-	mutex_init(&tu->tread_sem);
+	mutex_init(&tu->ioctl_lock);
 	tu->ticks = 1;
 	tu->queue_size = 128;
 	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
@@ -1276,8 +1312,10 @@ static int snd_timer_user_release(struct inode *inode, struct file *file)
 	if (file->private_data) {
 		tu = file->private_data;
 		file->private_data = NULL;
+		mutex_lock(&tu->ioctl_lock);
 		if (tu->timeri)
 			snd_timer_close(tu->timeri);
+		mutex_unlock(&tu->ioctl_lock);
 		kfree(tu->queue);
 		kfree(tu->tqueue);
 		kfree(tu);
@@ -1515,7 +1553,6 @@ static int snd_timer_user_tselect(struct file *file,
 	int err = 0;
 
 	tu = file->private_data;
-	mutex_lock(&tu->tread_sem);
 	if (tu->timeri) {
 		snd_timer_close(tu->timeri);
 		tu->timeri = NULL;
@@ -1559,7 +1596,6 @@ static int snd_timer_user_tselect(struct file *file,
 	}
 
       __err:
-      	mutex_unlock(&tu->tread_sem);
 	return err;
 }
 
@@ -1673,6 +1709,7 @@ static int snd_timer_user_params(struct file *file,
 	if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {
 		if (tu->tread) {
 			struct snd_timer_tread tread;
+			memset(&tread, 0, sizeof(tread));
 			tread.event = SNDRV_TIMER_EVENT_EARLY;
 			tread.tstamp.tv_sec = 0;
 			tread.tstamp.tv_nsec = 0;
@@ -1772,7 +1809,7 @@ enum {
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO('T', 0x23),
 };
 
-static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
+static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 				 unsigned long arg)
 {
 	struct snd_timer_user *tu;
@@ -1789,17 +1826,11 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 	{
 		int xarg;
 
-		mutex_lock(&tu->tread_sem);
-		if (tu->timeri)	{	/* too late */
-			mutex_unlock(&tu->tread_sem);
+		if (tu->timeri)	/* too late */
 			return -EBUSY;
-		}
-		if (get_user(xarg, p)) {
-			mutex_unlock(&tu->tread_sem);
+		if (get_user(xarg, p))
 			return -EFAULT;
-		}
 		tu->tread = xarg ? 1 : 0;
-		mutex_unlock(&tu->tread_sem);
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:
@@ -1832,6 +1863,18 @@ static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
 	return -ENOTTY;
 }
 
+static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,
+				 unsigned long arg)
+{
+	struct snd_timer_user *tu = file->private_data;
+	long ret;
+
+	mutex_lock(&tu->ioctl_lock);
+	ret = __snd_timer_user_ioctl(file, cmd, arg);
+	mutex_unlock(&tu->ioctl_lock);
+	return ret;
+}
+
 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	struct snd_timer_user *tu;
diff --git a/sound/core/timer_compat.c b/sound/core/timer_compat.c
index e05802a..2e90822 100644
--- a/sound/core/timer_compat.c
+++ b/sound/core/timer_compat.c
@@ -70,13 +70,14 @@ static int snd_timer_user_status_compat(struct file *file,
 					struct snd_timer_status32 __user *_status)
 {
 	struct snd_timer_user *tu;
-	struct snd_timer_status status;
+	struct snd_timer_status32 status;
 	
 	tu = file->private_data;
 	if (snd_BUG_ON(!tu->timeri))
 		return -ENXIO;
 	memset(&status, 0, sizeof(status));
-	status.tstamp = tu->tstamp;
+	status.tstamp.tv_sec = tu->tstamp.tv_sec;
+	status.tstamp.tv_nsec = tu->tstamp.tv_nsec;
 	status.resolution = snd_timer_resolution(tu->timeri);
 	status.lost = tu->timeri->lost;
 	status.overrun = tu->overrun;
@@ -88,12 +89,21 @@ static int snd_timer_user_status_compat(struct file *file,
 	return 0;
 }
 
+#ifdef CONFIG_X86_X32
+/* X32 ABI has the same struct as x86-64 */
+#define snd_timer_user_status_x32(file, s) \
+	snd_timer_user_status(file, s)
+#endif /* CONFIG_X86_X32 */
+
 /*
  */
 
 enum {
 	SNDRV_TIMER_IOCTL_INFO32 = _IOR('T', 0x11, struct snd_timer_info32),
 	SNDRV_TIMER_IOCTL_STATUS32 = _IOW('T', 0x14, struct snd_timer_status32),
+#ifdef CONFIG_X86_X32
+	SNDRV_TIMER_IOCTL_STATUS_X32 = _IOW('T', 0x14, struct snd_timer_status),
+#endif /* CONFIG_X86_X32 */
 };
 
 static long snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)
@@ -122,6 +132,10 @@ static long snd_timer_user_ioctl_compat(struct file *file, unsigned int cmd, uns
 		return snd_timer_user_info_compat(file, argp);
 	case SNDRV_TIMER_IOCTL_STATUS32:
 		return snd_timer_user_status_compat(file, argp);
+#ifdef CONFIG_X86_X32
+	case SNDRV_TIMER_IOCTL_STATUS_X32:
+		return snd_timer_user_status_x32(file, argp);
+#endif /* CONFIG_X86_X32 */
 	}
 	return -ENOIOCTLCMD;
 }
diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c
index fd798f7..7f400a1 100644
--- a/sound/drivers/dummy.c
+++ b/sound/drivers/dummy.c
@@ -109,6 +109,9 @@ struct dummy_timer_ops {
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);
 };
 
+#define get_dummy_ops(substream) \
+	(*(const struct dummy_timer_ops **)(substream)->runtime->private_data)
+
 struct dummy_model {
 	const char *name;
 	int (*playback_constraints)(struct snd_pcm_runtime *runtime);
@@ -137,7 +140,6 @@ struct snd_dummy {
 	int iobox;
 	struct snd_kcontrol *cd_volume_ctl;
 	struct snd_kcontrol *cd_switch_ctl;
-	const struct dummy_timer_ops *timer_ops;
 };
 
 /*
@@ -231,6 +233,8 @@ struct dummy_model *dummy_models[] = {
  */
 
 struct dummy_systimer_pcm {
+	/* ops must be the first item */
+	const struct dummy_timer_ops *timer_ops;
 	spinlock_t lock;
 	struct timer_list timer;
 	unsigned long base_time;
@@ -368,6 +372,8 @@ static struct dummy_timer_ops dummy_systimer_ops = {
  */
 
 struct dummy_hrtimer_pcm {
+	/* ops must be the first item */
+	const struct dummy_timer_ops *timer_ops;
 	ktime_t base_time;
 	ktime_t period_time;
 	atomic_t running;
@@ -416,6 +422,7 @@ static int dummy_hrtimer_stop(struct snd_pcm_substream *substream)
 
 static inline void dummy_hrtimer_sync(struct dummy_hrtimer_pcm *dpcm)
 {
+	hrtimer_cancel(&dpcm->timer);
 	tasklet_kill(&dpcm->tasklet);
 }
 
@@ -494,31 +501,25 @@ static struct dummy_timer_ops dummy_hrtimer_ops = {
 
 static int dummy_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
-
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
-		return dummy->timer_ops->start(substream);
+		return get_dummy_ops(substream)->start(substream);
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
-		return dummy->timer_ops->stop(substream);
+		return get_dummy_ops(substream)->stop(substream);
 	}
 	return -EINVAL;
 }
 
 static int dummy_pcm_prepare(struct snd_pcm_substream *substream)
 {
-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
-
-	return dummy->timer_ops->prepare(substream);
+	return get_dummy_ops(substream)->prepare(substream);
 }
 
 static snd_pcm_uframes_t dummy_pcm_pointer(struct snd_pcm_substream *substream)
 {
-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
-
-	return dummy->timer_ops->pointer(substream);
+	return get_dummy_ops(substream)->pointer(substream);
 }
 
 static struct snd_pcm_hardware dummy_pcm_hardware = {
@@ -564,17 +565,19 @@ static int dummy_pcm_open(struct snd_pcm_substream *substream)
 	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
 	struct dummy_model *model = dummy->model;
 	struct snd_pcm_runtime *runtime = substream->runtime;
+	const struct dummy_timer_ops *ops;
 	int err;
 
-	dummy->timer_ops = &dummy_systimer_ops;
+	ops = &dummy_systimer_ops;
 #ifdef CONFIG_HIGH_RES_TIMERS
 	if (hrtimer)
-		dummy->timer_ops = &dummy_hrtimer_ops;
+		ops = &dummy_hrtimer_ops;
 #endif
 
-	err = dummy->timer_ops->create(substream);
+	err = ops->create(substream);
 	if (err < 0)
 		return err;
+	get_dummy_ops(substream) = ops;
 
 	runtime->hw = dummy->pcm_hw;
 	if (substream->pcm->device & 1) {
@@ -596,7 +599,7 @@ static int dummy_pcm_open(struct snd_pcm_substream *substream)
 			err = model->capture_constraints(substream->runtime);
 	}
 	if (err < 0) {
-		dummy->timer_ops->free(substream);
+		get_dummy_ops(substream)->free(substream);
 		return err;
 	}
 	return 0;
@@ -604,8 +607,7 @@ static int dummy_pcm_open(struct snd_pcm_substream *substream)
 
 static int dummy_pcm_close(struct snd_pcm_substream *substream)
 {
-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
-	dummy->timer_ops->free(substream);
+	get_dummy_ops(substream)->free(substream);
 	return 0;
 }
 
diff --git a/sound/oss/sequencer.c b/sound/oss/sequencer.c
index 4ff60a6..2e67dd5 100644
--- a/sound/oss/sequencer.c
+++ b/sound/oss/sequencer.c
@@ -683,13 +683,8 @@ static int seq_timing_event(unsigned char *event_rec)
 			break;
 
 		case TMR_ECHO:
-			if (seq_mode == SEQ_2)
-				seq_copy_to_input(event_rec, 8);
-			else
-			{
-				parm = (parm << 8 | SEQ_ECHO);
-				seq_copy_to_input((unsigned char *) &parm, 4);
-			}
+			parm = (parm << 8 | SEQ_ECHO);
+			seq_copy_to_input((unsigned char *) &parm, 4);
 			break;
 
 		default:;
@@ -1332,7 +1327,6 @@ int sequencer_ioctl(int dev, struct file *file, unsigned int cmd, void __user *a
 	int mode = translate_mode(file);
 	struct synth_info inf;
 	struct seq_event_rec event_rec;
-	unsigned long flags;
 	int __user *p = arg;
 
 	orig_dev = dev = dev >> 4;
@@ -1487,9 +1481,7 @@ int sequencer_ioctl(int dev, struct file *file, unsigned int cmd, void __user *a
 		case SNDCTL_SEQ_OUTOFBAND:
 			if (copy_from_user(&event_rec, arg, sizeof(event_rec)))
 				return -EFAULT;
-			spin_lock_irqsave(&lock,flags);
 			play_event(event_rec.arr);
-			spin_unlock_irqrestore(&lock,flags);
 			return 0;
 
 		case SNDCTL_MIDI_INFO:
diff --git a/sound/pci/au88x0/au88x0_core.c b/sound/pci/au88x0/au88x0_core.c
index ae59dba..42d4b13 100644
--- a/sound/pci/au88x0/au88x0_core.c
+++ b/sound/pci/au88x0/au88x0_core.c
@@ -1442,9 +1442,8 @@ static int vortex_wtdma_bufshift(vortex_t * vortex, int wtdma)
 	int page, p, pp, delta, i;
 
 	page =
-	    (hwread(vortex->mmio, VORTEX_WTDMA_STAT + (wtdma << 2)) &
-	     WT_SUBBUF_MASK)
-	    >> WT_SUBBUF_SHIFT;
+	    (hwread(vortex->mmio, VORTEX_WTDMA_STAT + (wtdma << 2))
+	     >> WT_SUBBUF_SHIFT) & WT_SUBBUF_MASK;
 	if (dma->nr_periods >= 4)
 		delta = (page - dma->period_real) & 3;
 	else {
diff --git a/sound/pci/emu10k1/emu10k1.c b/sound/pci/emu10k1/emu10k1.c
index 8c5010f..70e6fe1 100644
--- a/sound/pci/emu10k1/emu10k1.c
+++ b/sound/pci/emu10k1/emu10k1.c
@@ -181,8 +181,10 @@ static int snd_card_emu10k1_probe(struct pci_dev *pci,
 	}
 #endif
  
-	strcpy(card->driver, emu->card_capabilities->driver);
-	strcpy(card->shortname, emu->card_capabilities->name);
+	strlcpy(card->driver, emu->card_capabilities->driver,
+		sizeof(card->driver));
+	strlcpy(card->shortname, emu->card_capabilities->name,
+		sizeof(card->shortname));
 	snprintf(card->longname, sizeof(card->longname),
 		 "%s (rev.%d, serial:0x%x) at 0x%lx, irq %i",
 		 card->shortname, emu->revision, emu->serial, emu->port, emu->irq);
diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c
index 0a34b5f..f8a6549 100644
--- a/sound/pci/emu10k1/emu10k1_callback.c
+++ b/sound/pci/emu10k1/emu10k1_callback.c
@@ -415,7 +415,7 @@ start_voice(struct snd_emux_voice *vp)
 	snd_emu10k1_ptr_write(hw, Z2, ch, 0);
 
 	/* invalidate maps */
-	temp = (hw->silent_page.addr << 1) | MAP_PTI_MASK;
+	temp = (hw->silent_page.addr << hw->address_mode) | (hw->address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);
 	snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 	snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 #if 0
@@ -436,7 +436,7 @@ start_voice(struct snd_emux_voice *vp)
 		snd_emu10k1_ptr_write(hw, CDF, ch, sample);
 
 		/* invalidate maps */
-		temp = ((unsigned int)hw->silent_page.addr << 1) | MAP_PTI_MASK;
+		temp = ((unsigned int)hw->silent_page.addr << hw_address_mode) | (hw->address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);
 		snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 		snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 		
diff --git a/sound/pci/emu10k1/emu10k1_main.c b/sound/pci/emu10k1/emu10k1_main.c
index bdd888e..a131092 100644
--- a/sound/pci/emu10k1/emu10k1_main.c
+++ b/sound/pci/emu10k1/emu10k1_main.c
@@ -282,7 +282,7 @@ static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)
 	snd_emu10k1_ptr_write(emu, TCB, 0, 0);	/* taken from original driver */
 	snd_emu10k1_ptr_write(emu, TCBS, 0, 4);	/* taken from original driver */
 
-	silent_page = (emu->silent_page.addr << 1) | MAP_PTI_MASK;
+	silent_page = (emu->silent_page.addr << emu->address_mode) | (emu->address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);
 	for (ch = 0; ch < NUM_G; ch++) {
 		snd_emu10k1_ptr_write(emu, MAPA, ch, silent_page);
 		snd_emu10k1_ptr_write(emu, MAPB, ch, silent_page);
@@ -348,6 +348,11 @@ static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)
 		outl(reg | A_IOCFG_GPOUT0, emu->port + A_IOCFG);
 	}
 
+	if (emu->address_mode == 0) {
+		/* use 16M in 4G */
+		outl(inl(emu->port + HCFG) | HCFG_EXPANDED_MEM, emu->port + HCFG);
+	}
+
 	return 0;
 }
 
@@ -1411,7 +1416,7 @@ static struct snd_emu_chip_details emu_chip_details[] = {
 	 *
 	 */
 	{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x20011102,
-	 .driver = "Audigy2", .name = "SB Audigy 2 ZS Notebook [SB0530]",
+	 .driver = "Audigy2", .name = "Audigy 2 ZS Notebook [SB0530]",
 	 .id = "Audigy2",
 	 .emu10k2_chip = 1,
 	 .ca0108_chip = 1,
@@ -1561,7 +1566,7 @@ static struct snd_emu_chip_details emu_chip_details[] = {
 	 .adc_1361t = 1,  /* 24 bit capture instead of 16bit */
 	 .ac97_chip = 1} ,
 	{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10051102,
-	 .driver = "Audigy2", .name = "SB Audigy 2 Platinum EX [SB0280]",
+	 .driver = "Audigy2", .name = "Audigy 2 Platinum EX [SB0280]",
 	 .id = "Audigy2",
 	 .emu10k2_chip = 1,
 	 .ca0102_chip = 1,
@@ -1865,8 +1870,10 @@ int snd_emu10k1_create(struct snd_card *card,
 
 	is_audigy = emu->audigy = c->emu10k2_chip;
 
+	/* set addressing mode */
+	emu->address_mode = is_audigy ? 0 : 1;
 	/* set the DMA transfer mask */
-	emu->dma_mask = is_audigy ? AUDIGY_DMA_MASK : EMU10K1_DMA_MASK;
+	emu->dma_mask = emu->address_mode ? EMU10K1_DMA_MASK : AUDIGY_DMA_MASK;
 	if (pci_set_dma_mask(pci, emu->dma_mask) < 0 ||
 	    pci_set_consistent_dma_mask(pci, emu->dma_mask) < 0) {
 		snd_printk(KERN_ERR "architecture does not support PCI busmaster DMA with mask 0x%lx\n", emu->dma_mask);
@@ -1889,7 +1896,7 @@ int snd_emu10k1_create(struct snd_card *card,
 
 	emu->max_cache_pages = max_cache_bytes >> PAGE_SHIFT;
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
-				32 * 1024, &emu->ptb_pages) < 0) {
+				(emu->address_mode ? 32 : 16) * 1024, &emu->ptb_pages) < 0) {
 		err = -ENOMEM;
 		goto error;
 	}
@@ -1988,8 +1995,8 @@ int snd_emu10k1_create(struct snd_card *card,
 
 	/* Clear silent pages and set up pointers */
 	memset(emu->silent_page.area, 0, PAGE_SIZE);
-	silent_page = emu->silent_page.addr << 1;
-	for (idx = 0; idx < MAXPAGES; idx++)
+	silent_page = emu->silent_page.addr << emu->address_mode;
+	for (idx = 0; idx < (emu->address_mode ? MAXPAGES1 : MAXPAGES0); idx++)
 		((u32 *)emu->ptb_pages.area)[idx] = cpu_to_le32(silent_page | idx);
 
 	/* set up voice indices */
diff --git a/sound/pci/emu10k1/emupcm.c b/sound/pci/emu10k1/emupcm.c
index 5ae1d04..7581019 100644
--- a/sound/pci/emu10k1/emupcm.c
+++ b/sound/pci/emu10k1/emupcm.c
@@ -379,7 +379,7 @@ static void snd_emu10k1_pcm_init_voice(struct snd_emu10k1 *emu,
 	snd_emu10k1_ptr_write(emu, Z1, voice, 0);
 	snd_emu10k1_ptr_write(emu, Z2, voice, 0);
 	/* invalidate maps */
-	silent_page = ((unsigned int)emu->silent_page.addr << 1) | MAP_PTI_MASK;
+	silent_page = ((unsigned int)emu->silent_page.addr << emu->address_mode) | (emu->address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);
 	snd_emu10k1_ptr_write(emu, MAPA, voice, silent_page);
 	snd_emu10k1_ptr_write(emu, MAPB, voice, silent_page);
 	/* modulation envelope */
diff --git a/sound/pci/emu10k1/emuproc.c b/sound/pci/emu10k1/emuproc.c
index 2ca9f2e..53745f4 100644
--- a/sound/pci/emu10k1/emuproc.c
+++ b/sound/pci/emu10k1/emuproc.c
@@ -241,31 +241,22 @@ static void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry,
 	struct snd_emu10k1 *emu = entry->private_data;
 	u32 value;
 	u32 value2;
-	unsigned long flags;
 	u32 rate;
 
 	if (emu->card_capabilities->emu_model) {
-		spin_lock_irqsave(&emu->emu_lock, flags);
 		snd_emu1010_fpga_read(emu, 0x38, &value);
-		spin_unlock_irqrestore(&emu->emu_lock, flags);
 		if ((value & 0x1) == 0) {
-			spin_lock_irqsave(&emu->emu_lock, flags);
 			snd_emu1010_fpga_read(emu, 0x2a, &value);
 			snd_emu1010_fpga_read(emu, 0x2b, &value2);
-			spin_unlock_irqrestore(&emu->emu_lock, flags);
 			rate = 0x1770000 / (((value << 5) | value2)+1);	
 			snd_iprintf(buffer, "ADAT Locked : %u\n", rate);
 		} else {
 			snd_iprintf(buffer, "ADAT Unlocked\n");
 		}
-		spin_lock_irqsave(&emu->emu_lock, flags);
 		snd_emu1010_fpga_read(emu, 0x20, &value);
-		spin_unlock_irqrestore(&emu->emu_lock, flags);
 		if ((value & 0x4) == 0) {
-			spin_lock_irqsave(&emu->emu_lock, flags);
 			snd_emu1010_fpga_read(emu, 0x28, &value);
 			snd_emu1010_fpga_read(emu, 0x29, &value2);
-			spin_unlock_irqrestore(&emu->emu_lock, flags);
 			rate = 0x1770000 / (((value << 5) | value2)+1);	
 			snd_iprintf(buffer, "SPDIF Locked : %d\n", rate);
 		} else {
@@ -410,14 +401,11 @@ static void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,
 {
 	struct snd_emu10k1 *emu = entry->private_data;
 	u32 value;
-	unsigned long flags;
 	int i;
 	snd_iprintf(buffer, "EMU1010 Registers:\n\n");
 
 	for(i = 0; i < 0x40; i+=1) {
-		spin_lock_irqsave(&emu->emu_lock, flags);
 		snd_emu1010_fpga_read(emu, i, &value);
-		spin_unlock_irqrestore(&emu->emu_lock, flags);
 		snd_iprintf(buffer, "%02X: %08X, %02X\n", i, value, (value >> 8) & 0x7f);
 	}
 }
diff --git a/sound/pci/emu10k1/memory.c b/sound/pci/emu10k1/memory.c
index ae709c1..d514458 100644
--- a/sound/pci/emu10k1/memory.c
+++ b/sound/pci/emu10k1/memory.c
@@ -34,10 +34,11 @@
  * aligned pages in others
  */
 #define __set_ptb_entry(emu,page,addr) \
-	(((u32 *)(emu)->ptb_pages.area)[page] = cpu_to_le32(((addr) << 1) | (page)))
+	(((u32 *)(emu)->ptb_pages.area)[page] = cpu_to_le32(((addr) << (emu->address_mode)) | (page)))
 
 #define UNIT_PAGES		(PAGE_SIZE / EMUPAGESIZE)
-#define MAX_ALIGN_PAGES		(MAXPAGES / UNIT_PAGES)
+#define MAX_ALIGN_PAGES0		(MAXPAGES0 / UNIT_PAGES)
+#define MAX_ALIGN_PAGES1		(MAXPAGES1 / UNIT_PAGES)
 /* get aligned page from offset address */
 #define get_aligned_page(offset)	((offset) >> PAGE_SHIFT)
 /* get offset address from aligned page */
@@ -124,7 +125,7 @@ static int search_empty_map_area(struct snd_emu10k1 *emu, int npages, struct lis
 		}
 		page = blk->mapped_page + blk->pages;
 	}
-	size = MAX_ALIGN_PAGES - page;
+	size = (emu->address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0) - page;
 	if (size >= max_size) {
 		*nextp = pos;
 		return page;
@@ -181,7 +182,7 @@ static int unmap_memblk(struct snd_emu10k1 *emu, struct snd_emu10k1_memblk *blk)
 		q = get_emu10k1_memblk(p, mapped_link);
 		end_page = q->mapped_page;
 	} else
-		end_page = MAX_ALIGN_PAGES;
+		end_page = (emu->address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0);
 
 	/* remove links */
 	list_del(&blk->mapped_link);
@@ -305,7 +306,7 @@ snd_emu10k1_alloc_pages(struct snd_emu10k1 *emu, struct snd_pcm_substream *subst
 	if (snd_BUG_ON(!emu))
 		return NULL;
 	if (snd_BUG_ON(runtime->dma_bytes <= 0 ||
-		       runtime->dma_bytes >= MAXPAGES * EMUPAGESIZE))
+		       runtime->dma_bytes >= (emu->address_mode ? MAXPAGES1 : MAXPAGES0) * EMUPAGESIZE))
 		return NULL;
 	hdr = emu->memhdr;
 	if (snd_BUG_ON(!hdr))
diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index 83a0f9b4..68261a7 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -2078,6 +2078,16 @@ int snd_hda_codec_amp_init_stereo(struct hda_codec *codec, hda_nid_t nid,
 }
 EXPORT_SYMBOL_HDA(snd_hda_codec_amp_init_stereo);
 
+/* meta hook to call each driver's vmaster hook */
+static void vmaster_hook(void *private_data, int enabled)
+{
+	struct hda_vmaster_mute_hook *hook = private_data;
+
+	if (hook->mute_mode != HDA_VMUTE_FOLLOW_MASTER)
+		enabled = hook->mute_mode;
+	hook->hook(hook->codec, enabled);
+}
+
 /**
  * snd_hda_codec_resume_amp - Resume all AMP commands from the cache
  * @codec: HD-audio codec
@@ -2772,9 +2782,9 @@ int snd_hda_add_vmaster_hook(struct hda_codec *codec,
 
 	if (!hook->hook || !hook->sw_kctl)
 		return 0;
-	snd_ctl_add_vmaster_hook(hook->sw_kctl, hook->hook, codec);
 	hook->codec = codec;
 	hook->mute_mode = HDA_VMUTE_FOLLOW_MASTER;
+	snd_ctl_add_vmaster_hook(hook->sw_kctl, vmaster_hook, hook);
 	if (!expose_enum_ctl)
 		return 0;
 	kctl = snd_ctl_new1(&vmaster_mute_mode, hook);
@@ -2797,14 +2807,7 @@ void snd_hda_sync_vmaster_hook(struct hda_vmaster_mute_hook *hook)
 	 */
 	if (hook->codec->bus->shutdown)
 		return;
-	switch (hook->mute_mode) {
-	case HDA_VMUTE_FOLLOW_MASTER:
-		snd_ctl_sync_vmaster_hook(hook->sw_kctl);
-		break;
-	default:
-		hook->hook(hook->codec, hook->mute_mode);
-		break;
-	}
+	snd_ctl_sync_vmaster_hook(hook->sw_kctl);
 }
 EXPORT_SYMBOL_HDA(snd_hda_sync_vmaster_hook);
 
diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index 1800db6..57d01f1 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -1104,6 +1104,36 @@ static unsigned int azx_get_response(struct hda_bus *bus,
 		return azx_rirb_get_response(bus, addr);
 }
 
+#ifdef CONFIG_PM_SLEEP
+/* put codec down to D3 at hibernation for Intel SKL+;
+ * otherwise BIOS may still access the codec and screw up the driver
+ */
+#define IS_SKL(pci) ((pci)->vendor == 0x8086 && (pci)->device == 0xa170)
+#define IS_SKL_LP(pci) ((pci)->vendor == 0x8086 && (pci)->device == 0x9d70)
+#define IS_BXT(pci) ((pci)->vendor == 0x8086 && (pci)->device == 0x5a98)
+#define IS_SKL_PLUS(pci) (IS_SKL(pci) || IS_SKL_LP(pci) || IS_BXT(pci))
+
+static int azx_freeze_noirq(struct device *dev)
+{
+	struct pci_dev *pci = to_pci_dev(dev);
+
+	if (IS_SKL_PLUS(pci))
+		pci_set_power_state(pci, PCI_D3hot);
+
+	return 0;
+}
+
+static int azx_thaw_noirq(struct device *dev)
+{
+	struct pci_dev *pci = to_pci_dev(dev);
+
+	if (IS_SKL_PLUS(pci))
+		pci_set_power_state(pci, PCI_D0);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
 #ifdef CONFIG_PM
 static void azx_power_notify(struct hda_bus *bus, bool power_up);
 #endif
@@ -2974,6 +3004,10 @@ static int azx_runtime_idle(struct device *dev)
 #ifdef CONFIG_PM
 static const struct dev_pm_ops azx_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(azx_suspend, azx_resume)
+#ifdef CONFIG_PM_SLEEP
+	.freeze_noirq = azx_freeze_noirq,
+	.thaw_noirq = azx_thaw_noirq,
+#endif
 	SET_RUNTIME_PM_OPS(azx_runtime_suspend, azx_runtime_resume, azx_runtime_idle)
 };
 
@@ -3864,6 +3898,11 @@ static DEFINE_PCI_DEVICE_TABLE(azx_ids) = {
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },
 	{ PCI_DEVICE(0x8086, 0x8d21),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },
+	/* Lewisburg */
+	{ PCI_DEVICE(0x8086, 0xa1f0),
+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },
+	{ PCI_DEVICE(0x8086, 0xa270),
+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },
 	/* Lynx Point-LP */
 	{ PCI_DEVICE(0x8086, 0x9c20),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },
diff --git a/sound/pci/hda/patch_cirrus.c b/sound/pci/hda/patch_cirrus.c
index e2642ba..2ba07ae 100644
--- a/sound/pci/hda/patch_cirrus.c
+++ b/sound/pci/hda/patch_cirrus.c
@@ -787,9 +787,7 @@ static void cs4210_spdif_automute(struct hda_codec *codec,
 
 	spec->spdif_present = spdif_present;
 	/* SPDIF TX on/off */
-	if (spdif_present)
-		snd_hda_set_pin_ctl(codec, spdif_pin,
-				    spdif_present ? PIN_OUT : 0);
+	snd_hda_set_pin_ctl(codec, spdif_pin, spdif_present ? PIN_OUT : 0);
 
 	cs_automute(codec);
 }
diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c
index fab9099..3cda292 100644
--- a/sound/pci/hda/patch_conexant.c
+++ b/sound/pci/hda/patch_conexant.c
@@ -3490,6 +3490,14 @@ static const struct hda_codec_preset snd_hda_preset_conexant[] = {
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f150b9, .name = "CX20665",
 	  .patch = patch_conexant_auto },
+	{ .id = 0x14f150f1, .name = "CX20721",
+	  .patch = patch_conexant_auto },
+	{ .id = 0x14f150f2, .name = "CX20722",
+	  .patch = patch_conexant_auto },
+	{ .id = 0x14f150f3, .name = "CX20723",
+	  .patch = patch_conexant_auto },
+	{ .id = 0x14f150f4, .name = "CX20724",
+	  .patch = patch_conexant_auto },
 	{ .id = 0x14f1510f, .name = "CX20751/2",
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f15110, .name = "CX20751/2",
@@ -3524,6 +3532,10 @@ MODULE_ALIAS("snd-hda-codec-id:14f150ab");
 MODULE_ALIAS("snd-hda-codec-id:14f150ac");
 MODULE_ALIAS("snd-hda-codec-id:14f150b8");
 MODULE_ALIAS("snd-hda-codec-id:14f150b9");
+MODULE_ALIAS("snd-hda-codec-id:14f150f1");
+MODULE_ALIAS("snd-hda-codec-id:14f150f2");
+MODULE_ALIAS("snd-hda-codec-id:14f150f3");
+MODULE_ALIAS("snd-hda-codec-id:14f150f4");
 MODULE_ALIAS("snd-hda-codec-id:14f1510f");
 MODULE_ALIAS("snd-hda-codec-id:14f15110");
 MODULE_ALIAS("snd-hda-codec-id:14f15111");
diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index 4008034..babbf23 100644
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@ -266,7 +266,7 @@ static void alc_auto_setup_eapd(struct hda_codec *codec, bool on)
 {
 	/* We currently only handle front, HP */
 	static hda_nid_t pins[] = {
-		0x0f, 0x10, 0x14, 0x15, 0
+		0x0f, 0x10, 0x14, 0x15, 0x17, 0
 	};
 	hda_nid_t *p;
 	for (p = pins; *p; p++)
@@ -1137,7 +1137,7 @@ static const struct hda_fixup alc880_fixups[] = {
 		/* override all pins as BIOS on old Amilo is broken */
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
-			{ 0x14, 0x0121411f }, /* HP */
+			{ 0x14, 0x0121401f }, /* HP */
 			{ 0x15, 0x99030120 }, /* speaker */
 			{ 0x16, 0x99030130 }, /* bass speaker */
 			{ 0x17, 0x411111f0 }, /* N/A */
@@ -1157,7 +1157,7 @@ static const struct hda_fixup alc880_fixups[] = {
 		/* almost compatible with FUJITSU, but no bass and SPDIF */
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
-			{ 0x14, 0x0121411f }, /* HP */
+			{ 0x14, 0x0121401f }, /* HP */
 			{ 0x15, 0x99030120 }, /* speaker */
 			{ 0x16, 0x411111f0 }, /* N/A */
 			{ 0x17, 0x411111f0 }, /* N/A */
@@ -1365,7 +1365,7 @@ static const struct snd_pci_quirk alc880_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x161f, 0x203d, "W810", ALC880_FIXUP_W810),
 	SND_PCI_QUIRK(0x161f, 0x205d, "Medion Rim 2150", ALC880_FIXUP_MEDION_RIM),
 	SND_PCI_QUIRK(0x1631, 0xe011, "PB 13201056", ALC880_FIXUP_6ST_AUTOMUTE),
-	SND_PCI_QUIRK(0x1734, 0x107c, "FSC F1734", ALC880_FIXUP_F1734),
+	SND_PCI_QUIRK(0x1734, 0x107c, "FSC Amilo M1437", ALC880_FIXUP_FUJITSU),
 	SND_PCI_QUIRK(0x1734, 0x1094, "FSC Amilo M1451G", ALC880_FIXUP_FUJITSU),
 	SND_PCI_QUIRK(0x1734, 0x10ac, "FSC AMILO Xi 1526", ALC880_FIXUP_F1734),
 	SND_PCI_QUIRK(0x1734, 0x10b0, "FSC Amilo Pi1556", ALC880_FIXUP_FUJITSU),
@@ -1768,6 +1768,7 @@ enum {
 	ALC889_FIXUP_MBA11_VREF,
 	ALC889_FIXUP_MBA21_VREF,
 	ALC889_FIXUP_MP11_VREF,
+	ALC889_FIXUP_MP41_VREF,
 	ALC882_FIXUP_INV_DMIC,
 	ALC882_FIXUP_NO_PRIMARY_HP,
 	ALC887_FIXUP_ASUS_BASS,
@@ -1854,7 +1855,7 @@ static void alc889_fixup_mbp_vref(struct hda_codec *codec,
 				  const struct hda_fixup *fix, int action)
 {
 	struct alc_spec *spec = codec->spec;
-	static hda_nid_t nids[2] = { 0x14, 0x15 };
+	static hda_nid_t nids[3] = { 0x14, 0x15, 0x19 };
 	int i;
 
 	if (action != HDA_FIXUP_ACT_INIT)
@@ -2128,6 +2129,12 @@ static const struct hda_fixup alc882_fixups[] = {
 		.chained = true,
 		.chain_id = ALC885_FIXUP_MACPRO_GPIO,
 	},
+	[ALC889_FIXUP_MP41_VREF] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc889_fixup_mbp_vref,
+		.chained = true,
+		.chain_id = ALC885_FIXUP_MACPRO_GPIO,
+	},
 	[ALC882_FIXUP_INV_DMIC] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_inv_dmic_0x12,
@@ -2148,6 +2155,7 @@ static const struct hda_fixup alc882_fixups[] = {
 static const struct snd_pci_quirk alc882_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x1025, 0x006c, "Acer Aspire 9810", ALC883_FIXUP_ACER_EAPD),
 	SND_PCI_QUIRK(0x1025, 0x0090, "Acer Aspire", ALC883_FIXUP_ACER_EAPD),
+	SND_PCI_QUIRK(0x1025, 0x0107, "Acer Aspire", ALC883_FIXUP_ACER_EAPD),
 	SND_PCI_QUIRK(0x1025, 0x010a, "Acer Ferrari 5000", ALC883_FIXUP_ACER_EAPD),
 	SND_PCI_QUIRK(0x1025, 0x0110, "Acer Aspire", ALC883_FIXUP_ACER_EAPD),
 	SND_PCI_QUIRK(0x1025, 0x0112, "Acer Aspire 9303", ALC883_FIXUP_ACER_EAPD),
@@ -2180,6 +2188,7 @@ static const struct snd_pci_quirk alc882_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x104d, 0x9047, "Sony Vaio TT", ALC889_FIXUP_VAIO_TT),
 	SND_PCI_QUIRK(0x104d, 0x905a, "Sony Vaio Z", ALC882_FIXUP_NO_PRIMARY_HP),
 	SND_PCI_QUIRK(0x104d, 0x9043, "Sony Vaio VGC-LN51JGB", ALC882_FIXUP_NO_PRIMARY_HP),
+	SND_PCI_QUIRK(0x104d, 0x9044, "Sony VAIO AiO", ALC882_FIXUP_NO_PRIMARY_HP),
 
 	/* All Apple entries are in codec SSIDs */
 	SND_PCI_QUIRK(0x106b, 0x00a0, "MacBookPro 3,1", ALC889_FIXUP_MBP_VREF),
@@ -2199,11 +2208,11 @@ static const struct snd_pci_quirk alc882_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x106b, 0x3f00, "Macbook 5,1", ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4000, "MacbookPro 5,1", ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4100, "Macmini 3,1", ALC889_FIXUP_IMAC91_VREF),
-	SND_PCI_QUIRK(0x106b, 0x4200, "Mac Pro 5,1", ALC885_FIXUP_MACPRO_GPIO),
+	SND_PCI_QUIRK(0x106b, 0x4200, "Mac Pro 4,1/5,1", ALC889_FIXUP_MP41_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4300, "iMac 9,1", ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4600, "MacbookPro 5,2", ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4900, "iMac 9,1 Aluminum", ALC889_FIXUP_IMAC91_VREF),
-	SND_PCI_QUIRK(0x106b, 0x4a00, "Macbook 5,2", ALC889_FIXUP_IMAC91_VREF),
+	SND_PCI_QUIRK(0x106b, 0x4a00, "Macbook 5,2", ALC889_FIXUP_MBA11_VREF),
 
 	SND_PCI_QUIRK(0x1071, 0x8258, "Evesham Voyaeger", ALC882_FIXUP_EAPD),
 	SND_PCI_QUIRK(0x1462, 0x7350, "MSI-7350", ALC889_FIXUP_CD),
@@ -3363,6 +3372,8 @@ enum {
 	ALC269_FIXUP_QUANTA_MUTE,
 	ALC269_FIXUP_LIFEBOOK,
 	ALC269_FIXUP_LIFEBOOK_EXTMIC,
+	ALC269_FIXUP_LIFEBOOK_HP_PIN,
+	ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT,
 	ALC269_FIXUP_AMIC,
 	ALC269_FIXUP_DMIC,
 	ALC269VB_FIXUP_AMIC,
@@ -3381,6 +3392,7 @@ enum {
 	ALC290_FIXUP_MONO_SPEAKERS,
 	ALC269_FIXUP_HEADSET_MODE,
 	ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC,
+	ALC269_FIXUP_ASPIRE_HEADSET_MIC,
 	ALC269_FIXUP_ASUS_X101_FUNC,
 	ALC269_FIXUP_ASUS_X101_VERB,
 	ALC269_FIXUP_ASUS_X101,
@@ -3477,6 +3489,17 @@ static const struct hda_fixup alc269_fixups[] = {
 			{ }
 		},
 	},
+	[ALC269_FIXUP_LIFEBOOK_HP_PIN] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = (const struct hda_pintbl[]) {
+			{ 0x21, 0x0221102f }, /* HP out */
+			{ }
+		},
+	},
+	[ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc269_fixup_pincfg_no_hp_to_lineout,
+	},
 	[ALC269_FIXUP_AMIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
@@ -3589,6 +3612,15 @@ static const struct hda_fixup alc269_fixups[] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_headset_mode_no_hp_mic,
 	},
+	[ALC269_FIXUP_ASPIRE_HEADSET_MIC] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = (const struct hda_pintbl[]) {
+			{ 0x19, 0x01a1913c }, /* headset mic w/o jack detect */
+			{ }
+		},
+		.chained = true,
+		.chain_id = ALC269_FIXUP_HEADSET_MODE,
+	},
 	[ALC286_FIXUP_SONY_MIC_NO_PRESENCE] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
@@ -3723,10 +3755,15 @@ static const struct snd_pci_quirk alc269_fixup_tbl[] = {
 	SND_PCI_QUIRK_VENDOR(0x104d, "Sony VAIO", ALC269_FIXUP_SONY_VAIO),
 	SND_PCI_QUIRK(0x1028, 0x0470, "Dell M101z", ALC269_FIXUP_DELL_M101Z),
 	SND_PCI_QUIRK(0x1025, 0x047c, "Acer AC700", ALC269_FIXUP_ACER_AC700),
+	SND_PCI_QUIRK(0x1025, 0x072d, "Acer Aspire V5-571G", ALC269_FIXUP_ASPIRE_HEADSET_MIC),
+	SND_PCI_QUIRK(0x1025, 0x080d, "Acer Aspire V5-122P", ALC269_FIXUP_ASPIRE_HEADSET_MIC),
 	SND_PCI_QUIRK(0x1025, 0x0740, "Acer AO725", ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK(0x1025, 0x0742, "Acer AO756", ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK_VENDOR(0x1025, "Acer Aspire", ALC271_FIXUP_DMIC),
 	SND_PCI_QUIRK(0x10cf, 0x1475, "Lifebook", ALC269_FIXUP_LIFEBOOK),
+	SND_PCI_QUIRK(0x10cf, 0x159f, "Lifebook E780", ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT),
+	SND_PCI_QUIRK(0x10cf, 0x15dc, "Lifebook T731", ALC269_FIXUP_LIFEBOOK_HP_PIN),
+	SND_PCI_QUIRK(0x10cf, 0x1757, "Lifebook E752", ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1845, "Lifebook U904", ALC269_FIXUP_LIFEBOOK_EXTMIC),
 	SND_PCI_QUIRK(0x17aa, 0x20f2, "Thinkpad SL410/510", ALC269_FIXUP_SKU_IGNORE),
 	SND_PCI_QUIRK(0x17aa, 0x215e, "Thinkpad L512", ALC269_FIXUP_SKU_IGNORE),
@@ -4417,6 +4454,7 @@ static const struct hda_fixup alc662_fixups[] = {
 static const struct snd_pci_quirk alc662_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x1019, 0x9087, "ECS", ALC662_FIXUP_ASUS_MODE2),
 	SND_PCI_QUIRK(0x1025, 0x022f, "Acer Aspire One", ALC662_FIXUP_INV_DMIC),
+	SND_PCI_QUIRK(0x1025, 0x0241, "Packard Bell DOTS", ALC662_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x0308, "Acer Aspire 8942G", ALC662_FIXUP_ASPIRE),
 	SND_PCI_QUIRK(0x1025, 0x031c, "Gateway NV79", ALC662_FIXUP_SKU_IGNORE),
 	SND_PCI_QUIRK(0x1025, 0x0349, "eMachines eM250", ALC662_FIXUP_INV_DMIC),
diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c
index 44d3fb9..5ffe799 100644
--- a/sound/pci/hda/patch_sigmatel.c
+++ b/sound/pci/hda/patch_sigmatel.c
@@ -703,6 +703,7 @@ static bool hp_bnb2011_with_dock(struct hda_codec *codec)
 static bool hp_blike_system(u32 subsystem_id)
 {
 	switch (subsystem_id) {
+	case 0x103c1473: /* HP ProBook 6550b */
 	case 0x103c1520:
 	case 0x103c1521:
 	case 0x103c1523:
diff --git a/sound/pci/intel8x0.c b/sound/pci/intel8x0.c
index b8fe405..7022450 100644
--- a/sound/pci/intel8x0.c
+++ b/sound/pci/intel8x0.c
@@ -2885,6 +2885,7 @@ static void intel8x0_measure_ac97_clock(struct intel8x0 *chip)
 
 static struct snd_pci_quirk intel8x0_clock_list[] = {
 	SND_PCI_QUIRK(0x0e11, 0x008a, "AD1885", 41000),
+	SND_PCI_QUIRK(0x1014, 0x0581, "AD1981B", 48000),
 	SND_PCI_QUIRK(0x1028, 0x00be, "AD1885", 44100),
 	SND_PCI_QUIRK(0x1028, 0x0177, "AD1980", 48000),
 	SND_PCI_QUIRK(0x1028, 0x01ad, "AD1981B", 48000),
diff --git a/sound/pci/oxygen/oxygen_mixer.c b/sound/pci/oxygen/oxygen_mixer.c
index c0dbb52..1e4bcb9 100644
--- a/sound/pci/oxygen/oxygen_mixer.c
+++ b/sound/pci/oxygen/oxygen_mixer.c
@@ -88,7 +88,7 @@ static int dac_mute_put(struct snd_kcontrol *ctl,
 	int changed;
 
 	mutex_lock(&chip->mutex);
-	changed = !value->value.integer.value[0] != chip->dac_mute;
+	changed = (!value->value.integer.value[0]) != chip->dac_mute;
 	if (changed) {
 		chip->dac_mute = !value->value.integer.value[0];
 		chip->model.update_dac_mute(chip);
diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c
index 5fb88ac..4fdb234 100644
--- a/sound/pci/rme96.c
+++ b/sound/pci/rme96.c
@@ -703,10 +703,11 @@ snd_rme96_playback_setrate(struct rme96 *rme96,
 	{
 		/* change to/from double-speed: reset the DAC (if available) */
 		snd_rme96_reset_dac(rme96);
+		return 1; /* need to restore volume */
 	} else {
 		writel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);
+		return 0;
 	}
-	return 0;
 }
 
 static int
@@ -944,6 +945,7 @@ snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	int err, rate, dummy;
+	bool apply_dac_volume = false;
 
 	runtime->dma_area = (void __force *)(rme96->iobase +
 					     RME96_IO_PLAY_BUFFER);
@@ -957,24 +959,26 @@ snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,
 	{
                 /* slave clock */
                 if ((int)params_rate(params) != rate) {
-			spin_unlock_irq(&rme96->lock);
-			return -EIO;                    
-                }
-	} else if ((err = snd_rme96_playback_setrate(rme96, params_rate(params))) < 0) {
-		spin_unlock_irq(&rme96->lock);
-		return err;
-	}
-	if ((err = snd_rme96_playback_setformat(rme96, params_format(params))) < 0) {
-		spin_unlock_irq(&rme96->lock);
-		return err;
+			err = -EIO;
+			goto error;
+		}
+	} else {
+		err = snd_rme96_playback_setrate(rme96, params_rate(params));
+		if (err < 0)
+			goto error;
+		apply_dac_volume = err > 0; /* need to restore volume later? */
 	}
+
+	err = snd_rme96_playback_setformat(rme96, params_format(params));
+	if (err < 0)
+		goto error;
 	snd_rme96_setframelog(rme96, params_channels(params), 1);
 	if (rme96->capture_periodsize != 0) {
 		if (params_period_size(params) << rme96->playback_frlog !=
 		    rme96->capture_periodsize)
 		{
-			spin_unlock_irq(&rme96->lock);
-			return -EBUSY;
+			err = -EBUSY;
+			goto error;
 		}
 	}
 	rme96->playback_periodsize =
@@ -985,9 +989,16 @@ snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,
 		rme96->wcreg &= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);
 		writel(rme96->wcreg |= rme96->wcreg_spdif_stream, rme96->iobase + RME96_IO_CONTROL_REGISTER);
 	}
+
+	err = 0;
+ error:
 	spin_unlock_irq(&rme96->lock);
-		
-	return 0;
+	if (apply_dac_volume) {
+		usleep_range(3000, 10000);
+		snd_rme96_apply_dac_volume(rme96);
+	}
+
+	return err;
 }
 
 static int
diff --git a/sound/pci/rme9652/hdsp.c b/sound/pci/rme9652/hdsp.c
index 94084cd..9a281f4 100644
--- a/sound/pci/rme9652/hdsp.c
+++ b/sound/pci/rme9652/hdsp.c
@@ -2923,7 +2923,7 @@ static int snd_hdsp_get_dds_offset(struct snd_kcontrol *kcontrol, struct snd_ctl
 {
 	struct hdsp *hdsp = snd_kcontrol_chip(kcontrol);
 
-	ucontrol->value.enumerated.item[0] = hdsp_dds_offset(hdsp);
+	ucontrol->value.integer.value[0] = hdsp_dds_offset(hdsp);
 	return 0;
 }
 
@@ -2935,7 +2935,7 @@ static int snd_hdsp_put_dds_offset(struct snd_kcontrol *kcontrol, struct snd_ctl
 
 	if (!snd_hdsp_use_is_exclusive(hdsp))
 		return -EBUSY;
-	val = ucontrol->value.enumerated.item[0];
+	val = ucontrol->value.integer.value[0];
 	spin_lock_irq(&hdsp->lock);
 	if (val != hdsp_dds_offset(hdsp))
 		change = (hdsp_set_dds_offset(hdsp, val) == 0) ? 1 : 0;
diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c
index dd910d2..8444098 100644
--- a/sound/pci/rme9652/hdspm.c
+++ b/sound/pci/rme9652/hdspm.c
@@ -1423,6 +1423,9 @@ static void hdspm_set_dds_value(struct hdspm *hdspm, int rate)
 {
 	u64 n;
 
+	if (snd_BUG_ON(rate <= 0))
+		return;
+
 	if (rate >= 112000)
 		rate /= 4;
 	else if (rate >= 56000)
@@ -2045,6 +2048,8 @@ static int hdspm_get_system_sample_rate(struct hdspm *hdspm)
 		} else {
 			/* slave mode, return external sample rate */
 			rate = hdspm_external_sample_rate(hdspm);
+			if (!rate)
+				rate = hdspm->system_sample_rate;
 		}
 	}
 
@@ -2090,8 +2095,11 @@ static int snd_hdspm_put_system_sample_rate(struct snd_kcontrol *kcontrol,
 					    ucontrol)
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
+	int rate = ucontrol->value.integer.value[0];
 
-	hdspm_set_dds_value(hdspm, ucontrol->value.enumerated.item[0]);
+	if (rate < 27000 || rate > 207000)
+		return -EINVAL;
+	hdspm_set_dds_value(hdspm, ucontrol->value.integer.value[0]);
 	return 0;
 }
 
@@ -4199,7 +4207,7 @@ static int snd_hdspm_get_tco_word_term(struct snd_kcontrol *kcontrol,
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	ucontrol->value.enumerated.item[0] = hdspm->tco->term;
+	ucontrol->value.integer.value[0] = hdspm->tco->term;
 
 	return 0;
 }
@@ -4210,8 +4218,8 @@ static int snd_hdspm_put_tco_word_term(struct snd_kcontrol *kcontrol,
 {
 	struct hdspm *hdspm = snd_kcontrol_chip(kcontrol);
 
-	if (hdspm->tco->term != ucontrol->value.enumerated.item[0]) {
-		hdspm->tco->term = ucontrol->value.enumerated.item[0];
+	if (hdspm->tco->term != ucontrol->value.integer.value[0]) {
+		hdspm->tco->term = ucontrol->value.integer.value[0];
 
 		hdspm_tco_write(hdspm);
 
diff --git a/sound/soc/ambarella/Kconfig b/sound/soc/ambarella/Kconfig
index 5a3c9fe..85fc1a6 100644
--- a/sound/soc/ambarella/Kconfig
+++ b/sound/soc/ambarella/Kconfig
@@ -37,47 +37,72 @@ menuconfig SND_AMBARELLA_CODEC
 if SND_AMBARELLA_CODEC
 
 config SND_SOC_AK4642_AMB
-	tristate "AK4642 for Ambarella"
+	tristate "AK4642 for Ambarella Platform"
 	help
-		Support AK4642 for A5S/S2_EVK/S2E_GINKGO/Hawthorn/s2lsmallbin.
+		Support AK4642 for Ambarella Platform.
 
 config SND_SOC_AK4951_AMB
-	tristate "AK4951 for Ambarella"
+	tristate "AK4951 for Ambarella Platform"
 	help
-		Support AK4951 for Ambarella S2E_EVK/S2lm_kiwi/s2lm_ironman.
+		Support AK4951 for Ambarella Platform.
 
 config SND_SOC_AK4954_AMB
-	tristate "AK4954 for Ambarella"
+	tristate "AK4954 for Ambarella Platform"
 	help
-		Support AK4951 for Ambarella s2lm_kiwi/s2lm_ironman.
+		Support AK4951 for Ambarella Platform.
 
 config SND_SOC_AK7719_DSP
-	tristate "AK7719_DSP for Ambarella"
+	tristate "AK7719_DSP for Ambarella Platform"
 	depends on SND_AMBARELLA_SOC && (SND_SOC_AK4954_AMB || SND_SOC_AK4951_AMB)
 	help
 	  Say Y if you want to add AK7719 DSP support for
 	  SoC audio on Ambarella Board.
 	  and the AK7719_DSP should be modprobed before AK4954/AK4951.
 
+config SND_SOC_AK7755
+	tristate "AK7755 for Ambarella Platform"
+	help
+		Support AK7755 for Ambarella Platform.
+
+config SND_SOC_TLV320ADC3xxx
+	tristate "TLV320ADC3xxx for Ambarella Platform"
+	help
+		Support TLV320ADC3xxx for Ambarella Platform.
+
 config SND_SOC_ES8388
-	tristate "ES8388 for Ambarella"
+	tristate "ES8388 for Ambarella Platform"
+	help
+		Support ES8388 Audio Codec for Ambarella Platform.
+
+config SND_SOC_ES8374
+	tristate "ES8374 for Ambarella Platform"
 	help
-		Support ES8388 for s2lm_iceman.
+		ES8374 Audio Codec for Ambarella Platform.
 
 config SND_SOC_WM8974_AMB
-	tristate "WM8974 for Ambarella"
+	tristate "WM8974 for Ambarella Platform"
 	help
-		Support WM8974 for s2lm_elektra.
+		Support WM8974 Audio Codec for Ambarella Platform.
 
 config SND_SOC_WM8940_AMB
-	tristate "WM8940 for Ambarella"
+	tristate "WM8940 for Ambarella Platform"
+	help
+		Support WM8940 Audio Codec for Ambarella Platform
+
+config SND_SOC_ZL380TW
+	tristate "ZL380XX for Ambarella Platform"
+	help
+		Support ZL380XX Audio Codec for Ambarella Platform
+
+config SND_SOC_RT5670
+	tristate "RT5670 for Ambarella Platform"
 	help
-		Support WM8940 for strawnerry
+		Support RT5670 Audio Codec for Ambarella Platform
 
 config SND_SOC_AMBARELLA_DUMMY
-	tristate "Dummy Codec for Ambarella"
+	tristate "Dummy Codec for Ambarella Platform"
 	help
-		Support Dummy Codec for Ambarella
+		Support Dummy Codec for Ambarella Platform
 
 endif
 
diff --git a/sound/soc/ambarella/ambarella_board.c b/sound/soc/ambarella/ambarella_board.c
index 59c004e..e493e8b 100644
--- a/sound/soc/ambarella/ambarella_board.c
+++ b/sound/soc/ambarella/ambarella_board.c
@@ -31,6 +31,10 @@
 #include <sound/soc.h>
 #include <plat/audio.h>
 #include <linux/slab.h>
+#include <sound/pcm_params.h>
+
+static int fast_boot = 0;
+module_param(fast_boot, uint, 0664);
 
 static unsigned int dai_fmt;
 module_param(dai_fmt, uint, 0644);
@@ -68,66 +72,34 @@ module_param(clk_fmt, uint, 0664);
 
 struct amb_clk {
 	int mclk;
-	int oversample;
+	int i2s_div;
 	int bclk;
 };
 
 static int amba_clk_config(struct snd_pcm_hw_params *params, struct amb_clk *clk)
 {
-	int ret= 0;
+	u32 channels, sample_bits, rate;
 
-	switch (params_rate(params)) {
-	case 8000:
-		clk->mclk = 12288000;
-		clk->oversample = AudioCodec_1536xfs;
-		clk->bclk = 8000;
-		break;
-	case 11025:
-		clk->mclk = 12288000;
-		clk->oversample = AudioCodec_1152xfs;
-		clk->bclk = 11025;
-		break;
-	case 12000:
-		clk->mclk = 12288000;
-		clk->oversample = AudioCodec_1024xfs;
-		clk->bclk = 12000;
-		break;
-	case 16000:
-		clk->mclk = 12288000;
-		clk->oversample = AudioCodec_768xfs;
-		clk->bclk = 16000;
-		break;
-	case 22050:
-		clk->mclk = 12288000;
-		clk->oversample = AudioCodec_512xfs;
-		clk->bclk = 22050;
-		break;
-	case 24000:
-		clk->mclk = 12288000;
-		clk->oversample = AudioCodec_512xfs;
-		clk->bclk = 24000;
-		break;
-	case 32000:
-		clk->mclk = 12288000;
-		clk->oversample = AudioCodec_384xfs;
-		clk->bclk = 32000;
-		break;
-	case 44100:
-		clk->mclk = 12288000;
-		clk->oversample = AudioCodec_256xfs;
-		clk->bclk = 44100;
-		break;
-	case 48000:
-		clk->mclk = 12288000;
-		clk->oversample = AudioCodec_256xfs;
-		clk->bclk = 48000;
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+		sample_bits = 32;
 		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
 	default:
-		ret = -EINVAL;
+		sample_bits = 16;
 		break;
 	}
 
-	return ret;
+	channels = params_channels(params);
+	rate = params_rate(params);
+
+	clk->mclk = 12288000;
+	clk->bclk = channels * rate * sample_bits;
+
+	clk->i2s_div = (clk->mclk / ( 2 * clk->bclk)) - 1;
+
+	return 0;
 }
 
 static int amba_general_board_hw_params(struct snd_pcm_substream *substream,
@@ -211,7 +183,7 @@ static int amba_general_board_hw_params(struct snd_pcm_substream *substream,
 		goto hw_params_exit;
 	}
 
-	rval = snd_soc_dai_set_clkdiv(cpu_dai, AMBARELLA_CLKDIV_LRCLK, clk.oversample);
+	rval = snd_soc_dai_set_clkdiv(cpu_dai, AMBARELLA_CLKDIV_LRCLK, clk.i2s_div);
 	if (rval < 0) {
 		pr_err("can't set cpu MCLK/SF ratio\n");
 		goto hw_params_exit;
@@ -229,6 +201,8 @@ static int amba_dummy_board_hw_params(struct snd_pcm_substream *substream,
 	int i2s_mode, rval = 0;
 	struct amb_clk clk={0};
 
+	if (fast_boot)
+		return 0;
 	rval = amba_clk_config(params, &clk);
 	if (rval < 0) {
 		pr_err("amba can not support the sample rate\n");
@@ -241,8 +215,14 @@ static int amba_dummy_board_hw_params(struct snd_pcm_substream *substream,
 		i2s_mode = SND_SOC_DAIFMT_DSP_A;
 
 	/* set the I2S system data format*/
-	rval = snd_soc_dai_set_fmt(cpu_dai,
-		i2s_mode | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if(clk_fmt == 2) {
+		rval = snd_soc_dai_set_fmt(cpu_dai,
+			i2s_mode | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	} else {
+		rval = snd_soc_dai_set_fmt(cpu_dai,
+			i2s_mode | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	}
+
 	if (rval < 0) {
 		printk(KERN_ERR "can't set cpu DAI configuration\n");
 		goto hw_params_exit;
@@ -255,7 +235,7 @@ static int amba_dummy_board_hw_params(struct snd_pcm_substream *substream,
 		goto hw_params_exit;
 	}
 
-	rval = snd_soc_dai_set_clkdiv(cpu_dai, AMBARELLA_CLKDIV_LRCLK, clk.oversample);
+	rval = snd_soc_dai_set_clkdiv(cpu_dai, AMBARELLA_CLKDIV_LRCLK, clk.i2s_div);
 	if (rval < 0) {
 		printk(KERN_ERR "can't set cpu MCLK/SF ratio\n");
 		goto hw_params_exit;
@@ -310,15 +290,11 @@ static int amba_soc_snd_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	rval = snd_soc_of_parse_audio_routing(card,
-			"amb,audio-routing");
-	if(rval) {
-		dev_err(&pdev->dev, "amb,audio-routing is invalid\n");
-		return -EINVAL;
-	}
-
 	cpup_np = of_parse_phandle(np, "amb,i2s-controllers", 0);
-	codec_np = of_parse_phandle(np, "amb,audio-codec", 0);
+	if (fast_boot)
+		codec_np = NULL;
+	else
+		codec_np = of_parse_phandle(np, "amb,audio-codec", 0);
 	dummy_codec_np = of_parse_phandle(np, "amb,dummy-codec", 0);
 	if (!cpup_np || !dummy_codec_np) {
 		dev_err(&pdev->dev, "phandle missing or invalid\n");
@@ -326,6 +302,12 @@ static int amba_soc_snd_probe(struct platform_device *pdev)
 	}
 
 	if(codec_np) {
+		rval = snd_soc_of_parse_audio_routing(card,
+		"amb,audio-routing");
+		if(rval) {
+			dev_err(&pdev->dev, "amb,audio-routing is not specified, please doube check\n");
+		}
+
 		/*alloc two amba_dai_link for audio codec and dummy codec*/
 		amba_dai_link = devm_kzalloc(&pdev->dev, 2 * sizeof(*amba_dai_link), GFP_KERNEL);
 		if (amba_dai_link == NULL) {
diff --git a/sound/soc/ambarella/ambarella_i2s.c b/sound/soc/ambarella/ambarella_i2s.c
index 3f2b892..83becfc 100644
--- a/sound/soc/ambarella/ambarella_i2s.c
+++ b/sound/soc/ambarella/ambarella_i2s.c
@@ -43,43 +43,35 @@
 #include "ambarella_pcm.h"
 #include "ambarella_i2s.h"
 
+static unsigned int capture_enabled = 1;
+module_param(capture_enabled, uint, 0644);
+MODULE_PARM_DESC(capture_enabled, "capture_enabled.");
+
 static unsigned int bclk_reverse = 0;
 module_param(bclk_reverse, uint, 0644);
 MODULE_PARM_DESC(bclk_reverse, "bclk_reverse.");
 
 static DEFINE_MUTEX(clock_reg_mutex);
-static int enable_ext_i2s = 1;
-
-static u32 DAI_Clock_Divide_Table[MAX_OVERSAMPLE_IDX_NUM][2] = {
-	{ 1, 0 }, // 128xfs
-	{ 3, 1 }, // 256xfs
-	{ 5, 2 }, // 384xfs
-	{ 7, 3 }, // 512xfs
-	{ 11, 5 }, // 768xfs
-	{ 15, 7 }, // 1024xfs
-	{ 17, 8 }, // 1152xfs
-	{ 23, 11 }, // 1536xfs
-	{ 35, 17 } // 2304xfs
-};
 
 static inline void dai_tx_enable(void)
 {
-	amba_setbitsl(I2S_INIT_REG, DAI_TX_EN);
+	amba_setbitsl(I2S_INIT_REG, I2S_TX_ENABLE_BIT);
 }
 
 static inline void dai_rx_enable(void)
 {
-	amba_setbitsl(I2S_INIT_REG, DAI_RX_EN);
+	amba_setbitsl(I2S_INIT_REG, I2S_RX_ENABLE_BIT);
 }
 
 static inline void dai_tx_disable(void)
 {
-	amba_clrbitsl(I2S_INIT_REG, DAI_TX_EN);
+	amba_clrbitsl(I2S_INIT_REG, I2S_TX_ENABLE_BIT);
 }
 
 static inline void dai_rx_disable(void)
 {
-	amba_clrbitsl(I2S_INIT_REG, DAI_RX_EN);
+	if(capture_enabled)
+		amba_clrbitsl(I2S_INIT_REG, I2S_RX_ENABLE_BIT);
 }
 
 static inline void dai_tx_fifo_rst(void)
@@ -89,12 +81,14 @@ static inline void dai_tx_fifo_rst(void)
 
 static inline void dai_rx_fifo_rst(void)
 {
-	amba_setbitsl(I2S_INIT_REG, I2S_RX_FIFO_RESET_BIT);
+	if(capture_enabled)
+		amba_setbitsl(I2S_INIT_REG, I2S_RX_FIFO_RESET_BIT);
 }
 
 static inline void dai_fifo_rst(void)
 {
-	amba_setbitsl(I2S_INIT_REG, DAI_FIFO_RST);
+	if(capture_enabled)
+		amba_setbitsl(I2S_INIT_REG, I2S_FIFO_RESET_BIT);
 }
 
 static int ambarella_i2s_prepare(struct snd_pcm_substream *substream,
@@ -142,145 +136,116 @@ static int ambarella_i2s_hw_params(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *cpu_dai)
 {
 	struct amb_i2s_priv *priv_data = snd_soc_dai_get_drvdata(cpu_dai);
-	u8 slots, word_len, word_pos, oversample, double_rate;
-	u32 clock_divider, clock_reg, channels, tx_ctrl = 0, multi24 = 0;
+	struct ambarella_i2s_interface *i2s_intf = &priv_data->amb_i2s_intf;
+	u32 clock_reg;
+
+	if( capture_enabled == 0)
+		return 0;
 
 	/* Disable tx/rx before initializing */
 	dai_tx_disable();
 	dai_rx_disable();
 
-	channels = params_channels(params);
-	/* Set channels */
-	switch (channels) {
-	case 2:
-		amba_writel(I2S_REG(I2S_CHANNEL_SELECT_OFFSET), I2S_2CHANNELS_ENB);
-		break;
-	case 4:
-		amba_writel(I2S_REG(I2S_CHANNEL_SELECT_OFFSET), I2S_4CHANNELS_ENB);
-		break;
-	case 6:
-		amba_writel(I2S_REG(I2S_CHANNEL_SELECT_OFFSET), I2S_6CHANNELS_ENB);
-		break;
-	}
-	priv_data->amb_i2s_intf.ch = channels;
+	i2s_intf->sfreq = params_rate(params);
+	i2s_intf->channels = params_channels(params);
+	amba_writel(I2S_REG(I2S_CHANNEL_SELECT_OFFSET), i2s_intf->channels / 2 - 1);
 
 	/* Set format */
-	double_rate = 0;
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
-		priv_data->amb_i2s_intf.word_len = DAI_16bits;
-		word_len = 0x0f;
-		tx_ctrl |= 0x08; /* set unison bit (LR both in TX_LEFT_DATA) */
-		if (priv_data->amb_i2s_intf.mode == DAI_DSP_Mode) {
-			slots = channels - 1;
-			word_pos = 0x0f;
-			priv_data->amb_i2s_intf.slots = slots;
+		i2s_intf->multi24 = 0;
+		i2s_intf->tx_ctrl = I2S_TX_UNISON_BIT;
+		i2s_intf->word_len = 15;
+		i2s_intf->shift = 0;
+		if (i2s_intf->mode == I2S_DSP_MODE) {
+			i2s_intf->slots = i2s_intf->channels - 1;
+			i2s_intf->word_pos = 15;
 		} else {
-			slots = 0;
-			word_pos = 0;
-			priv_data->amb_i2s_intf.slots = DAI_32slots;
+			i2s_intf->slots = 0;
+			i2s_intf->word_pos = 0;
 		}
 		priv_data->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 		break;
+
 	case SNDRV_PCM_FORMAT_S24_LE:
-		double_rate = 1;
-		priv_data->amb_i2s_intf.word_len = DAI_24bits;
-		word_len = 0x17;
-		multi24 = 0x1; /* multi_24_en bit */
-		if (priv_data->amb_i2s_intf.mode == DAI_DSP_Mode) {
-			slots = channels - 1;
-			word_pos = 0x00; /* ignored, but set it to something */
-			priv_data->amb_i2s_intf.slots = slots;
+		i2s_intf->multi24 = I2S_24BITMUX_MODE_ENABLE;
+		i2s_intf->tx_ctrl = 0;
+		i2s_intf->word_len = 23;
+		i2s_intf->shift = 1;
+		if (i2s_intf->mode == I2S_DSP_MODE) {
+			i2s_intf->slots = i2s_intf->channels - 1;
+			i2s_intf->word_pos = 0; /* ignored */
 		} else {
-			slots = 0;
-			word_pos = 0; /* ignored, but set it to something */
-			priv_data->amb_i2s_intf.slots = DAI_32slots;
+			i2s_intf->slots = 0;
+			i2s_intf->word_pos = 0; /* ignored */
 		}
 		priv_data->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		i2s_intf->multi24 = I2S_24BITMUX_MODE_ENABLE;
+		i2s_intf->tx_ctrl = 0;
+		i2s_intf->word_len = 31;
+		i2s_intf->shift = 0;
+		if (i2s_intf->mode == I2S_DSP_MODE) {
+			i2s_intf->slots = i2s_intf->channels - 1;
+			i2s_intf->word_pos = 0; /* ignored */
+		} else {
+			i2s_intf->slots = 0;
+			i2s_intf->word_pos = 0; /* ignored */
+		}
+		priv_data->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+
 	default:
 		goto hw_params_exit;
 	}
 
-	priv_data->amb_i2s_intf.word_pos = word_pos;
-	priv_data->amb_i2s_intf.word_order = DAI_MSB_FIRST;
+	if (priv_data->dai_master == true) {
+		i2s_intf->tx_ctrl |= I2S_TX_WS_MST_BIT;
+		i2s_intf->rx_ctrl |= I2S_RX_WS_MST_BIT;
+	} else {
+		i2s_intf->tx_ctrl &= ~I2S_TX_WS_MST_BIT;
+		i2s_intf->rx_ctrl &= ~I2S_RX_WS_MST_BIT;
+	}
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (priv_data->amb_i2s_intf.ms_mode != DAI_SLAVE)
-			tx_ctrl |= 0x20;
-		amba_writel(I2S_TX_CTRL_REG, tx_ctrl);
+		amba_writel(I2S_TX_CTRL_REG, i2s_intf->tx_ctrl);
 		amba_writel(I2S_TX_FIFO_LTH_REG, 0x10);
+		amba_writel(I2S_GATEOFF_REG, (i2s_intf->shift << 0));
 	} else {
-		if (priv_data->amb_i2s_intf.ms_mode == DAI_SLAVE)
-			amba_writel(I2S_RX_CTRL_REG, 0x00);
-		else
-			amba_writel(I2S_RX_CTRL_REG, 0x02);
+		amba_writel(I2S_RX_CTRL_REG, i2s_intf->rx_ctrl);
 		amba_writel(I2S_RX_FIFO_GTH_REG, 0x20);
+		amba_writel(I2S_GATEOFF_REG, (i2s_intf->shift << 1));
 	}
 
-	amba_writel(I2S_MODE_REG, priv_data->amb_i2s_intf.mode);
-	amba_writel(I2S_WLEN_REG, word_len);
-	amba_writel(I2S_WPOS_REG, word_pos);
-	amba_writel(I2S_SLOT_REG, slots);
-	amba_writel(I2S_24BITMUX_MODE_REG, multi24);
-
-	switch (params_rate(params)) {
-	case 8000:
-		priv_data->amb_i2s_intf.sfreq = AUDIO_SF_8000;
-		break;
-	case 11025:
-		priv_data->amb_i2s_intf.sfreq = AUDIO_SF_11025;
-		break;
-	case 16000:
-		priv_data->amb_i2s_intf.sfreq = AUDIO_SF_16000;
-		break;
-	case 22050:
-		priv_data->amb_i2s_intf.sfreq = AUDIO_SF_22050;
-		break;
-	case 32000:
-		priv_data->amb_i2s_intf.sfreq = AUDIO_SF_32000;
-		break;
-	case 44100:
-		priv_data->amb_i2s_intf.sfreq = AUDIO_SF_44100;
-		break;
-	case 48000:
-		priv_data->amb_i2s_intf.sfreq = AUDIO_SF_48000;
-		break;
-	default:
-		goto hw_params_exit;
-	}
+	amba_writel(I2S_MODE_REG, i2s_intf->mode);
+	amba_writel(I2S_WLEN_REG, i2s_intf->word_len);
+	amba_writel(I2S_WPOS_REG, i2s_intf->word_pos);
+	amba_writel(I2S_SLOT_REG, i2s_intf->slots);
+	amba_writel(I2S_24BITMUX_MODE_REG, i2s_intf->multi24);
 
 	/* Set clock */
-	clk_set_rate(priv_data->mclk, priv_data->amb_i2s_intf.mclk);
+	clk_set_rate(priv_data->mclk, i2s_intf->mclk);
 
 	mutex_lock(&clock_reg_mutex);
-	clock_reg = amba_readl(I2S_CLOCK_REG);
-	oversample = priv_data->amb_i2s_intf.oversample;
-
-	/* In 16 bit mode, the channel width is 16 bits, and in 24 bit
-	 * mode then channel width is 32 bits (see Ambarella S2L Hardware
-         * Programming Manual, Table 9-1); consequently we need to adjust
-	 * the clock divider accordingly, by referencing 'double_rate' here.
-	 */
-
-	clock_divider = DAI_Clock_Divide_Table[oversample][double_rate];
 
+	clock_reg = amba_readl(I2S_CLOCK_REG);
 	clock_reg &= ~DAI_CLOCK_MASK;
-	clock_reg |= clock_divider;
-	if (priv_data->amb_i2s_intf.ms_mode == DAI_MASTER)
+	clock_reg |= i2s_intf->div;
+
+	if (priv_data->dai_master == true)
 		clock_reg |= I2S_CLK_MASTER_MODE;
 	else
-		clock_reg &= (~I2S_CLK_MASTER_MODE);
-	/* Disable output BCLK and LRCLK to disable external codec */
-	if (enable_ext_i2s == 0)
-		clock_reg &= ~(I2S_CLK_WS_OUT_EN | I2S_CLK_BCLK_OUT_EN);
+		clock_reg &= ~I2S_CLK_MASTER_MODE;
 
 	if (bclk_reverse)
-		clock_reg &= ~(1<< 6);
+		clock_reg &= ~I2S_CLK_TX_PO_FALL;
 	else
-		clock_reg |= (1<< 6);
+		clock_reg |= I2S_CLK_TX_PO_FALL;
 
 	amba_writel(I2S_CLOCK_REG, clock_reg);
+
 	mutex_unlock(&clock_reg_mutex);
 
 	dai_rx_enable();
@@ -311,7 +276,6 @@ static int ambarella_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
 		else
 			dai_rx_enable();
 		break;
-	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
 			dai_tx_disable();
@@ -338,16 +302,16 @@ static int ambarella_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
 
 	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 	case SND_SOC_DAIFMT_LEFT_J:
-		priv_data->amb_i2s_intf.mode = DAI_leftJustified_Mode;
+		priv_data->amb_i2s_intf.mode = I2S_LEFT_JUSTIFIED_MODE;
 		break;
 	case SND_SOC_DAIFMT_RIGHT_J:
-		priv_data->amb_i2s_intf.mode = DAI_rightJustified_Mode;
+		priv_data->amb_i2s_intf.mode = I2S_RIGHT_JUSTIFIED_MODE;
 		break;
 	case SND_SOC_DAIFMT_I2S:
-		priv_data->amb_i2s_intf.mode = DAI_I2S_Mode;
+		priv_data->amb_i2s_intf.mode = I2S_I2S_MODE;
 		break;
 	case SND_SOC_DAIFMT_DSP_A:
-		priv_data->amb_i2s_intf.mode = DAI_DSP_Mode;
+		priv_data->amb_i2s_intf.mode = I2S_DSP_MODE;
 		break;
 	default:
 		return -EINVAL;
@@ -355,14 +319,14 @@ static int ambarella_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
 
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBS_CFS:
-		priv_data->amb_i2s_intf.ms_mode = DAI_MASTER;
+		priv_data->dai_master = true;
 		break;
 	case SND_SOC_DAIFMT_CBM_CFM:
-		if (priv_data->amb_i2s_intf.mode != DAI_I2S_Mode) {
+		if (priv_data->amb_i2s_intf.mode != I2S_I2S_MODE) {
 			printk("DAI can't work in slave mode without standard I2S format!\n");
 			return -EINVAL;
 		}
-		priv_data->amb_i2s_intf.ms_mode = DAI_SLAVE;
+		priv_data->dai_master = false;
 		break;
 	default:
 		return -EINVAL;
@@ -398,7 +362,7 @@ static int ambarella_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai,
 
 	switch (div_id) {
 	case AMBARELLA_CLKDIV_LRCLK:
-		priv_data->amb_i2s_intf.oversample = div;
+		priv_data->amb_i2s_intf.div = div;
 		break;
 	default:
 		return -EINVAL;
@@ -407,71 +371,42 @@ static int ambarella_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai,
 	return 0;
 }
 
-static int external_i2s_get_status(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	mutex_lock(&clock_reg_mutex);
-	ucontrol->value.integer.value[0] = enable_ext_i2s;
-	mutex_unlock(&clock_reg_mutex);
-
-	return 0;
-}
-
-static int external_i2s_set_status(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
-{
-	u32 clock_reg;
-
-	mutex_lock(&clock_reg_mutex);
-	clock_reg = amba_readl(I2S_CLOCK_REG);
-
-	enable_ext_i2s = ucontrol->value.integer.value[0];
-	if (enable_ext_i2s)
-		clock_reg |= (I2S_CLK_WS_OUT_EN | I2S_CLK_BCLK_OUT_EN);
-	else
-		clock_reg &= ~(I2S_CLK_WS_OUT_EN | I2S_CLK_BCLK_OUT_EN);
-
-	amba_writel(I2S_CLOCK_REG, clock_reg);
-	mutex_unlock(&clock_reg_mutex);
-
-	return 1;
-}
-
-static const char *i2s_status_str[] = {"Off", "On"};
-
-static const struct soc_enum external_i2s_enum[] = {
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(i2s_status_str), i2s_status_str),
-};
-
-static const struct snd_kcontrol_new external_i2s_controls[] = {
-	SOC_ENUM_EXT("External I2S Switch", external_i2s_enum[0],
-			external_i2s_get_status, external_i2s_set_status),
-};
-
-int ambarella_i2s_add_controls(struct snd_soc_codec *codec)
-{
-	return snd_soc_add_codec_controls(codec, external_i2s_controls,
-			ARRAY_SIZE(external_i2s_controls));
-}
-EXPORT_SYMBOL_GPL(ambarella_i2s_add_controls);
-
-
 #ifdef CONFIG_PM
 static int ambarella_i2s_dai_suspend(struct snd_soc_dai *dai)
 {
 	struct amb_i2s_priv *priv_data = snd_soc_dai_get_drvdata(dai);
+	struct ambarella_i2s_interface *i2s_intf = &priv_data->amb_i2s_intf;
 
 	priv_data->clock_reg = amba_readl(I2S_CLOCK_REG);
+	i2s_intf->mode = amba_readl(I2S_MODE_REG);
+	i2s_intf->word_len = amba_readl(I2S_WLEN_REG);
+	i2s_intf->word_pos = amba_readl(I2S_WPOS_REG);
+	i2s_intf->slots = amba_readl(I2S_SLOT_REG);
+	i2s_intf->channels = amba_readl(I2S_REG(I2S_CHANNEL_SELECT_OFFSET));
+	i2s_intf->rx_ctrl = amba_readl(I2S_RX_CTRL_REG);
+	i2s_intf->tx_ctrl = amba_readl(I2S_TX_CTRL_REG);
+	i2s_intf->rx_fifo_len = amba_readl(I2S_RX_FIFO_GTH_REG);
+	i2s_intf->tx_fifo_len = amba_readl(I2S_TX_FIFO_LTH_REG);
+	i2s_intf->multi24 = amba_readl(I2S_24BITMUX_MODE_REG);
 
 	return 0;
 }
 
-
-
 static int ambarella_i2s_dai_resume(struct snd_soc_dai *dai)
 {
 	struct amb_i2s_priv *priv_data = snd_soc_dai_get_drvdata(dai);
-
+	struct ambarella_i2s_interface *i2s_intf = &priv_data->amb_i2s_intf;
+
+	amba_writel(I2S_MODE_REG, i2s_intf->mode);
+	amba_writel(I2S_WLEN_REG, i2s_intf->word_len);
+	amba_writel(I2S_WPOS_REG, i2s_intf->word_pos);
+	amba_writel(I2S_SLOT_REG, i2s_intf->slots);
+	amba_writel(I2S_REG(I2S_CHANNEL_SELECT_OFFSET), i2s_intf->channels);
+	amba_writel(I2S_RX_CTRL_REG, i2s_intf->rx_ctrl);
+	amba_writel(I2S_TX_CTRL_REG, i2s_intf->tx_ctrl);
+	amba_writel(I2S_RX_FIFO_GTH_REG, i2s_intf->rx_fifo_len);
+	amba_writel(I2S_TX_FIFO_LTH_REG, i2s_intf->tx_fifo_len);
+	amba_writel(I2S_24BITMUX_MODE_REG,i2s_intf->multi24);
 	amba_writel(I2S_CLOCK_REG, priv_data->clock_reg);
 
 	return 0;
@@ -481,45 +416,44 @@ static int ambarella_i2s_dai_resume(struct snd_soc_dai *dai)
 #define ambarella_i2s_dai_resume	NULL
 #endif /* CONFIG_PM */
 
-
-
 static int ambarella_i2s_dai_probe(struct snd_soc_dai *dai)
 {
-	u32 sfreq, clock_divider;
+	u32 sfreq, clk_div = 3;
 	struct amb_i2s_priv *priv_data = snd_soc_dai_get_drvdata(dai);
+	struct ambarella_i2s_interface *i2s_intf = &priv_data->amb_i2s_intf;
 
 	dai->capture_dma_data = &priv_data->capture_dma_data;
 	dai->playback_dma_data = &priv_data->playback_dma_data;
 
 	if (priv_data->default_mclk == 12288000) {
-		sfreq = AUDIO_SF_48000;
+		sfreq = 48000;
 	} else if (priv_data->default_mclk == 11289600){
-		sfreq = AUDIO_SF_44100;
+		sfreq = 44100;
 	} else {
-		dev_warn(dai->dev, "Please sepcify the default mclk\n");
 		priv_data->default_mclk = 12288000;
-		sfreq = AUDIO_SF_48000;
+		sfreq = 48000;
 	}
 
 	clk_set_rate(priv_data->mclk, priv_data->default_mclk);
 
-	/* Dai default smapling rate, polarity configuration.
+	/*
+	 * Dai default smapling rate, polarity configuration.
 	 * Note: Just be configured, actually BCLK and LRCLK will not
-	 * output to outside at this time. */
-	clock_divider = DAI_Clock_Divide_Table[AudioCodec_256xfs][DAI_32slots >> 6];
-	amba_writel(I2S_CLOCK_REG, clock_divider | I2S_CLK_TX_PO_FALL);
-
-	priv_data->amb_i2s_intf.mode = DAI_I2S_Mode;
-	priv_data->amb_i2s_intf.clksrc = AMBARELLA_CLKSRC_ONCHIP;
-	priv_data->amb_i2s_intf.ms_mode = DAI_MASTER;
-	priv_data->amb_i2s_intf.mclk = priv_data->default_mclk;
-	priv_data->amb_i2s_intf.oversample = AudioCodec_256xfs;
-	priv_data->amb_i2s_intf.word_order = DAI_MSB_FIRST;
-	priv_data->amb_i2s_intf.sfreq = sfreq;
-	priv_data->amb_i2s_intf.word_len = DAI_16bits;
-	priv_data->amb_i2s_intf.word_pos = 0;
-	priv_data->amb_i2s_intf.slots = DAI_32slots;
-	priv_data->amb_i2s_intf.ch = 2;
+	 * output to outside at this time.
+	 */
+	if(capture_enabled)
+		amba_writel(I2S_CLOCK_REG, clk_div | I2S_CLK_TX_PO_FALL);
+
+	priv_data->dai_master = true;
+	i2s_intf->mode = I2S_I2S_MODE;
+	i2s_intf->clksrc = AMBARELLA_CLKSRC_ONCHIP;
+	i2s_intf->mclk = priv_data->default_mclk;
+	i2s_intf->div = clk_div;
+	i2s_intf->sfreq = sfreq;
+	i2s_intf->word_len = 15;
+	i2s_intf->word_pos = 0;
+	i2s_intf->slots = 0;
+	i2s_intf->channels = 2;
 
 	/* reset fifo */
 	dai_tx_enable();
@@ -565,13 +499,13 @@ static struct snd_soc_dai_driver ambarella_i2s_dai = {
 		.channels_min = 2,
 		.channels_max = 0, // initialized in ambarella_i2s_probe function
 		.rates = SNDRV_PCM_RATE_8000_48000,
-		.formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE),
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE),
 	},
 	.capture = {
 		.channels_min = 2,
 		.channels_max = 0, // initialized in ambarella_i2s_probe function
 		.rates = SNDRV_PCM_RATE_8000_48000,
-		.formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE),
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE),
 	},
 	.ops = &ambarella_i2s_dai_ops,
 	.symmetric_rates = 1,
@@ -595,12 +529,10 @@ static int ambarella_i2s_probe(struct platform_device *pdev)
 	priv_data->playback_dma_data.addr = I2S_TX_LEFT_DATA_DMA_REG;
 	priv_data->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	priv_data->playback_dma_data.maxburst = 32;
-	priv_data->playback_dma_data.filter_data = (void *)I2S_TX_DMA_CHAN;
 
 	priv_data->capture_dma_data.addr = I2S_RX_DATA_DMA_REG;
 	priv_data->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
 	priv_data->capture_dma_data.maxburst = 32;
-	priv_data->capture_dma_data.filter_data = (void *)I2S_RX_DMA_CHAN;
 	priv_data->mclk = clk_get(&pdev->dev, "gclk_audio");
 	if (IS_ERR(priv_data->mclk)) {
 		dev_err(&pdev->dev, "Get audio clk failed!\n");
@@ -624,8 +556,6 @@ static int ambarella_i2s_probe(struct platform_device *pdev)
 	if (IS_ERR(pinctrl))
 		return PTR_ERR(pinctrl);
 
-
-
 	rval = snd_soc_register_component(&pdev->dev,
 			&ambarella_i2s_component,  &ambarella_i2s_dai, 1);
 	if (rval < 0){
diff --git a/sound/soc/ambarella/ambarella_i2s.h b/sound/soc/ambarella/ambarella_i2s.h
index cd22934..9fa8e3b 100644
--- a/sound/soc/ambarella/ambarella_i2s.h
+++ b/sound/soc/ambarella/ambarella_i2s.h
@@ -29,6 +29,7 @@
 
 struct amb_i2s_priv {
 	struct clk *mclk;
+	bool dai_master;
 	u32 default_mclk;
 	u32 clock_reg;
 	u32 bclk_reverse;
diff --git a/sound/soc/ambarella/ambarella_pcm.c b/sound/soc/ambarella/ambarella_pcm.c
index 154f39c..8ffcd0a 100644
--- a/sound/soc/ambarella/ambarella_pcm.c
+++ b/sound/soc/ambarella/ambarella_pcm.c
@@ -39,9 +39,6 @@
 #include <sound/dmaengine_pcm.h>
 #include <plat/dma.h>
 
-unsigned int force_stop = 0;
-module_param(force_stop, uint, 0644);
-MODULE_PARM_DESC(force_stop, "Stop DMA immediately, only used by cyclic DMA");
 
 #define AMBA_MAX_DESC_NUM		128
 #define AMBA_MIN_DESC_NUM		2
@@ -63,7 +60,7 @@ static const struct snd_pcm_hardware ambarella_pcm_hardware = {
 				  SNDRV_PCM_INFO_RESUME |
 				  SNDRV_PCM_INFO_BATCH |
 				  SNDRV_PCM_INFO_JOINT_DUPLEX,
-	.formats		= SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
 	.rates			= SNDRV_PCM_RATE_8000_48000,
 	.rate_min		= 8000,
 	.rate_max		= 48000,
@@ -74,23 +71,10 @@ static const struct snd_pcm_hardware ambarella_pcm_hardware = {
 	.buffer_bytes_max	= AMBA_BUFFER_BYTES_MAX,
 };
 
-static bool ambarella_pcm_dma_filter(struct dma_chan *chan, void *param)
-{
-	struct snd_dmaengine_dai_dma_data *dma_params = param;
-	bool ret = false;
-
-	if (ambarella_dma_channel_id(chan) == (int)dma_params->filter_data) {
-		ret = true;
-		chan->private = &force_stop;
-	}
-
-	return ret;
-}
 
 static const struct snd_dmaengine_pcm_config ambarella_dmaengine_pcm_config = {
 	.pcm_hardware = &ambarella_pcm_hardware,
 	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
-	.compat_filter_fn = ambarella_pcm_dma_filter,
 	.prealloc_buffer_size = AMBA_BUFFER_BYTES_MAX,
 };
 
@@ -98,7 +82,6 @@ int ambarella_pcm_platform_register(struct device *dev)
 {
 	return snd_dmaengine_pcm_register(dev, &ambarella_dmaengine_pcm_config,
 			SND_DMAENGINE_PCM_FLAG_NO_RESIDUE |
-			SND_DMAENGINE_PCM_FLAG_NO_DT |
 			SND_DMAENGINE_PCM_FLAG_COMPAT);
 }
 EXPORT_SYMBOL_GPL(ambarella_pcm_platform_register);
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 62d982a..f318c6b 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -33,6 +33,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_AK4954_AMB if I2C
 	select SND_SOC_WM8940_AMB if I2C
 	select SND_SOC_WM8974_AMB if I2C
+	select SND_SOC_AK7755 if SND_SOC_I2C_AND_SPI
 	select SND_SOC_ALC5623 if I2C
 	select SND_SOC_ALC5632 if I2C
 	select SND_SOC_CQ0093VC if MFD_DAVINCI_VOICECODEC
@@ -48,6 +49,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_DA9055 if I2C
 	select SND_SOC_DFBMCS320
 	select SND_SOC_ES8328 if I2C
+	select SND_SOC_ES8374 if I2C
 	select SND_SOC_ES8388 if I2C
 	select SND_SOC_ISABELLE if I2C
 	select SND_SOC_JZ4740_CODEC
@@ -73,6 +75,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_STA529 if I2C
 	select SND_SOC_STAC9766 if SND_SOC_AC97_BUS
 	select SND_SOC_TAS5086 if I2C
+	select SND_SOC_TLV320ADC3xxx if I2C
 	select SND_SOC_TLV320AIC23 if I2C
 	select SND_SOC_TLV320AIC26 if SPI_MASTER
 	select SND_SOC_TLV320AIC32X4 if I2C
@@ -133,6 +136,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_WM9705 if SND_SOC_AC97_BUS
 	select SND_SOC_WM9712 if SND_SOC_AC97_BUS
 	select SND_SOC_WM9713 if SND_SOC_AC97_BUS
+	select SND_SOC_ZL380TW if SND_SOC_I2C_AND_SPI
         help
           Normally ASoC codec drivers are only built if a machine driver which
           uses them is also built since they are only usable with a machine
@@ -234,6 +238,9 @@ config SND_SOC_WM8940_AMB
 config SND_SOC_WM8974_AMB
 	tristate
 
+config SND_SOC_AK7755
+	tristate
+
 config SND_SOC_ALC5623
        tristate
 config SND_SOC_ALC5632
@@ -298,6 +305,9 @@ config SND_SOC_DMIC
 config SND_SOC_ES8328
 	tristate
 
+config SND_SOC_ES8374
+	tristate
+
 config SND_SOC_ES8388
 	tristate
 
@@ -557,3 +567,12 @@ config SND_SOC_ML26124
 
 config SND_SOC_TPA6130A2
 	tristate
+
+config SND_SOC_TLV320ADC3xxx
+	tristate
+
+config SND_SOC_ZL380TW
+	tristate
+
+config SND_SOC_RT5670
+	tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 31222b4..36c172e 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -19,8 +19,10 @@ snd-soc-ak5386-objs := ak5386.o
 snd-soc-ak4951-amb-objs := ak4951_amb.o
 snd-soc-ak4954-amb-objs := ak4954_amb.o
 snd-soc-ak7719-objs := ak7719_amb.o
+snd-soc-ak7755-objs := ak7755.o
 snd-soc-wm8940-amb-objs := wm8940_amb.o
 snd-soc-wm8974-amb-objs := wm8974_amb.o
+snd-soc-rt5670-objs := rt5670.o rt5670-dsp.o
 snd-soc-ambdummy-objs := ambarella_dummy.o
 snd-soc-arizona-objs := arizona.o
 snd-soc-cq93vc-objs := cq93vc.o
@@ -37,6 +39,7 @@ snd-soc-da9055-objs := da9055.o
 snd-soc-dfbmcs320-objs := dfbmcs320.o
 snd-soc-dmic-objs := dmic.o
 snd-soc-es8328-objs := es8328.o
+snd-soc-es8374-objs := es8374.o
 snd-soc-es8388-objs := es8388.o
 snd-soc-isabelle-objs := isabelle.o
 snd-soc-jz4740-codec-objs := jz4740.o
@@ -66,6 +69,7 @@ snd-soc-sta32x-objs := sta32x.o
 snd-soc-sta529-objs := sta529.o
 snd-soc-stac9766-objs := stac9766.o
 snd-soc-tas5086-objs := tas5086.o
+snd-soc-tlv320adc3xxx-amb-objs := tlv320adc3xxx_amb.o
 snd-soc-tlv320aic23-objs := tlv320aic23.o
 snd-soc-tlv320aic26-objs := tlv320aic26.o
 snd-soc-tlv320aic3x-objs := tlv320aic3x.o
@@ -131,6 +135,7 @@ snd-soc-wm-hubs-objs := wm_hubs.o
 # Amp
 snd-soc-max9877-objs := max9877.o
 snd-soc-tpa6130a2-objs := tpa6130a2.o
+snd-soc-zl380tw-objs := zl380tw.o
 
 obj-$(CONFIG_SND_SOC_88PM860X)	+= snd-soc-88pm860x.o
 obj-$(CONFIG_SND_SOC_AB8500_CODEC)	+= snd-soc-ab8500-codec.o
@@ -153,8 +158,10 @@ obj-$(CONFIG_SND_SOC_AK5386)	+= snd-soc-ak5386.o
 obj-$(CONFIG_SND_SOC_AK4951_AMB)    += snd-soc-ak4951-amb.o
 obj-$(CONFIG_SND_SOC_AK4954_AMB)    += snd-soc-ak4954-amb.o
 obj-$(CONFIG_SND_SOC_AK7719_DSP)    += snd-soc-ak7719.o
+obj-$(CONFIG_SND_SOC_AK7755)    += snd-soc-ak7755.o
 obj-$(CONFIG_SND_SOC_WM8940_AMB)    += snd-soc-wm8940-amb.o
 obj-$(CONFIG_SND_SOC_WM8974_AMB)    += snd-soc-wm8974-amb.o
+obj-$(CONFIG_SND_SOC_RT5670)    += snd-soc-rt5670.o
 obj-$(CONFIG_SND_SOC_ALC5623)    += snd-soc-alc5623.o
 obj-$(CONFIG_SND_SOC_ALC5632)	+= snd-soc-alc5632.o
 obj-$(CONFIG_SND_SOC_AMBARELLA_DUMMY)	+= snd-soc-ambdummy.o
@@ -173,6 +180,7 @@ obj-$(CONFIG_SND_SOC_DA9055)	+= snd-soc-da9055.o
 obj-$(CONFIG_SND_SOC_DFBMCS320)	+= snd-soc-dfbmcs320.o
 obj-$(CONFIG_SND_SOC_DMIC)	+= snd-soc-dmic.o
 obj-$(CONFIG_SND_SOC_ES8328)	+= snd-soc-es8328.o
+obj-$(CONFIG_SND_SOC_ES8374)	+= snd-soc-es8374.o
 obj-$(CONFIG_SND_SOC_ES8388)	+= snd-soc-es8388.o
 obj-$(CONFIG_SND_SOC_ISABELLE)	+= snd-soc-isabelle.o
 obj-$(CONFIG_SND_SOC_JZ4740_CODEC)	+= snd-soc-jz4740-codec.o
@@ -204,6 +212,7 @@ obj-$(CONFIG_SND_SOC_TLV320AIC26)	+= snd-soc-tlv320aic26.o
 obj-$(CONFIG_SND_SOC_TLV320AIC3X)	+= snd-soc-tlv320aic3x.o
 obj-$(CONFIG_SND_SOC_TLV320AIC32X4)     += snd-soc-tlv320aic32x4.o
 obj-$(CONFIG_SND_SOC_TLV320DAC33)	+= snd-soc-tlv320dac33.o
+obj-$(CONFIG_SND_SOC_TLV320ADC3xxx)	+= snd-soc-tlv320adc3xxx-amb.o
 obj-$(CONFIG_SND_SOC_TWL4030)	+= snd-soc-twl4030.o
 obj-$(CONFIG_SND_SOC_TWL6040)	+= snd-soc-twl6040.o
 obj-$(CONFIG_SND_SOC_UDA134X)	+= snd-soc-uda134x.o
@@ -264,3 +273,4 @@ obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
+obj-$(CONFIG_SND_SOC_ZL380TW)	+= snd-soc-zl380tw.o
diff --git a/sound/soc/codecs/adav80x.c b/sound/soc/codecs/adav80x.c
index 3c839cc..0ef2b2a 100644
--- a/sound/soc/codecs/adav80x.c
+++ b/sound/soc/codecs/adav80x.c
@@ -307,7 +307,7 @@ static int adav80x_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);
-	unsigned int deemph = ucontrol->value.enumerated.item[0];
+	unsigned int deemph = ucontrol->value.integer.value[0];
 
 	if (deemph > 1)
 		return -EINVAL;
@@ -323,7 +323,7 @@ static int adav80x_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.enumerated.item[0] = adav80x->deemph;
+	ucontrol->value.integer.value[0] = adav80x->deemph;
 	return 0;
 };
 
diff --git a/sound/soc/codecs/ak4641.c b/sound/soc/codecs/ak4641.c
index 5f9af1f..68379c1 100644
--- a/sound/soc/codecs/ak4641.c
+++ b/sound/soc/codecs/ak4641.c
@@ -74,7 +74,7 @@ static int ak4641_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.enumerated.item[0];
+	int deemph = ucontrol->value.integer.value[0];
 
 	if (deemph > 1)
 		return -EINVAL;
@@ -90,7 +90,7 @@ static int ak4641_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.enumerated.item[0] = ak4641->deemph;
+	ucontrol->value.integer.value[0] = ak4641->deemph;
 	return 0;
 };
 
diff --git a/sound/soc/codecs/ak4642_amb.c b/sound/soc/codecs/ak4642_amb.c
index 40093b9..6df1c70 100644
--- a/sound/soc/codecs/ak4642_amb.c
+++ b/sound/soc/codecs/ak4642_amb.c
@@ -43,6 +43,7 @@ struct ak4642_priv {
 	unsigned int rst_pin;
 	unsigned int rst_active;
 	unsigned int sysclk;
+	unsigned int clk_id;
 };
 
 /*
@@ -402,6 +403,7 @@ static int ak4642_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 	struct ak4642_priv *ak4642 = snd_soc_codec_get_drvdata(codec);
 
 	ak4642->sysclk = freq;
+	ak4642->clk_id = clk_id;
 	return 0;
 }
 
@@ -412,27 +414,147 @@ static int ak4642_hw_params(struct snd_pcm_substream *substream,
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_codec *codec = rtd->codec;
 	struct ak4642_priv *ak4642 = snd_soc_codec_get_drvdata(codec);
-	int rate = params_rate(params), fs = 256;
-	u8 mode = snd_soc_read(codec, AK4642_MODE2) & 0xc0;
-
-	if (rate)
-		fs = ak4642->sysclk / rate;
+	int rate = params_rate(params);
+	u8 mode0, mode1;
+
+	mode0 = snd_soc_read(codec, AK4642_MODE1) & 0x0F;
+	mode1 = snd_soc_read(codec, AK4642_MODE2) & 0xD8;
+
+	if(ak4642->clk_id == AK4642_MCLK_IN) {
+		switch(ak4642->sysclk) {
+		case 11289600:
+			mode0 |= (4 << 4);
+			break;
+		case 12288000:
+			mode0 |= (5 << 4);
+			break;
+		case 12000000:
+			mode0 |= (6 << 4);
+			break;
+		case 24000000:
+			mode0 |= (7 << 4);
+			break;
+		case 13500000:
+			mode0 |= (0xC << 4);
+			break;
+		case 27000000:
+			mode0 |= (0xD << 4);
+			break;
+		default:
+			mode0 |= (5 << 4);
+			break;
+		}
+
+		snd_soc_write(codec, AK4642_MODE1, mode0);
+		snd_soc_update_bits(codec,AK4642_PM2,0x09,0x01);
+	} else if(ak4642->clk_id == AK4642_BCLK_IN) {
+		u32 oversampe = ak4642->sysclk / rate;
+
+		switch(oversampe) {
+		case 32:
+			mode0 |= (2 << 4);
+			break;
+		case 64:
+			mode0 |= (3 << 4);
+			break;
+		default:
+			mode0 |= (2 << 4);
+			break;
+		}
+
+		snd_soc_write(codec, AK4642_MODE1, mode0);
+		snd_soc_update_bits(codec,AK4642_PM2,0x09,0x01);
+
+	} else if(ak4642->clk_id == AK4642_MCLK_IN_BCLK_OUT) {
+		switch(ak4642->sysclk) {
+		case 11289600:
+			mode0 |= (4 << 4);
+			break;
+		case 12288000:
+			mode0 |= (5 << 4);
+			break;
+		case 12000000:
+			mode0 |= (6 << 4);
+			break;
+		case 24000000:
+			mode0 |= (7 << 4);
+			break;
+		case 13500000:
+			mode0 |= (0xC << 4);
+			break;
+		case 27000000:
+			mode0 |= (0xD << 4);
+			break;
+		default:
+			mode0 |= (5 << 4);
+			break;
+		}
+
+		snd_soc_write(codec, AK4642_MODE1, mode0);
+		snd_soc_update_bits(codec,AK4642_PM2,0x09,0x09);
+	}
 
-	/* set fs */
-	switch (fs) {
-	case 1024:
-		mode |= 0x1;
-		break;
-	case 512:
-		mode |= 0x3;
-		break;
-	case 256:
-		mode |= 0x0;
-		break;
+	if(ak4642->clk_id == AK4642_BCLK_IN) {
+		if(rate >= 7350 && rate <= 8000)
+			mode1 |= 0;
+		else if(rate > 8000 && rate <= 12000)
+			mode1 |= 1;
+		else if(rate > 12000 && rate <= 16000)
+			mode1 |= 2;
+		else if(rate > 16000 && rate <= 24000)
+			mode1 |= 3;
+		else if(rate > 24000 && rate <= 32000)
+			mode1 |= 0x22;
+		else if(rate > 32 && rate <= 48000)
+			mode1 |= 0x23;
+
+		snd_soc_write(codec, AK4642_MODE2, mode1);
+	} else {
+		switch(rate) {
+		case 7350:
+			mode1 |= 4;
+			break;
+		case 8000:
+			mode1 |= 0;
+			break;
+		case 11025:
+			mode1 |= 5;
+			break;
+		case 12000:
+			mode1 |= 1;
+			break;
+		case 14700:
+			mode1 |= 6;
+			break;
+		case 16000:
+			mode1 |= 2;
+			break;
+		case 22050:
+			mode1 |= 7;
+			break;
+		case 24000:
+			mode1 |= 3;
+			break;
+		case 29400:
+			mode1 |= 0x26;
+			break;
+		case 32000:
+			mode1 |= 0x22;
+			break;
+		case 44100:
+			mode1 |= 0x27;
+			break;
+		case 48000:
+			mode1 |= 0x23;
+			break;
+		default:
+			mode1 |= 0x23;
+			break;
+		}
+
+		snd_soc_write(codec, AK4642_MODE2, mode1);
 	}
 
-	/* set rate */
-	snd_soc_write(codec, AK4642_MODE2, mode);
 	return 0;
 }
 
@@ -447,6 +569,9 @@ static int ak4642_set_dai_fmt(struct snd_soc_dai *codec_dai,
 	case SND_SOC_DAIFMT_CBS_CFS:
 		snd_soc_update_bits(codec, AK4642_PM2, 0x08, 0);
 		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		snd_soc_update_bits(codec, AK4642_PM2, 0x08, 0x08);
+		break;
 	default:
 		return -EINVAL;
 	}
diff --git a/sound/soc/codecs/ak4642_amb.h b/sound/soc/codecs/ak4642_amb.h
index cb51a18..75377e3 100644
--- a/sound/soc/codecs/ak4642_amb.h
+++ b/sound/soc/codecs/ak4642_amb.h
@@ -56,4 +56,10 @@
 #define AK4642_BOTH_MIC_ON	1
 #define AK4642_INPUT_UNKNOWN	2
 
+#define AK4642_MCLK_IN	0
+#define AK4642_BCLK_IN	1
+#define AK4642_MCLK_IN_BCLK_OUT	2
+
+
+
 #endif
diff --git a/sound/soc/codecs/ak4951_amb.c b/sound/soc/codecs/ak4951_amb.c
index ca041e3..873b9c4 100644
--- a/sound/soc/codecs/ak4951_amb.c
+++ b/sound/soc/codecs/ak4951_amb.c
@@ -55,13 +55,15 @@ struct ak4951_priv {
 	unsigned int sysclk;
 	unsigned int clkid;
 	struct regmap *regmap;
-	struct snd_soc_codec codec;
 	struct i2c_client* i2c_clt;
 	u8 reg_cache[AK4951_MAX_REGISTERS];
 	int onStereo;
 	int mic;
+	u8 fmt;
 };
 
+struct ak4951_priv *ak4951_data;
+
 /*
  * ak4951 register
  */
@@ -448,7 +450,7 @@ struct snd_ctl_elem_value  *ucontrol)
 
 static const struct snd_kcontrol_new ak4951_snd_controls[] = {
 	SOC_SINGLE_TLV("Mic Gain Control",
-			AK4951_02_SIGNAL_SELECT1, 0, 0x47, 0, mgain_tlv),
+			AK4951_02_SIGNAL_SELECT1, 0, 0x07, 0, mgain_tlv),
 	SOC_SINGLE_TLV("Input Digital Volume",
 			AK4951_0D_LCH_INPUT_VOLUME_CONTROL, 0, 0xF1, 0, ivol_tlv),
 	SOC_SINGLE_TLV("Speaker Output Volume",
@@ -785,37 +787,89 @@ static int ak4951_hw_params(struct snd_pcm_substream *substream,
 	default:
 		break;
 	}
-	switch (rate) {
-	case 8000:
-		fs |= AK4951_FS_8KHZ;
-		break;
-	case 11025:
-		fs |= AK4951_FS_11_025KHZ;
-		break;
-	case 12000:
-		fs |= AK4951_FS_12KHZ;
-		break;
-	case 16000:
-		fs |= AK4951_FS_16KHZ;
-		break;
-	case 22050:
-		fs |= AK4951_FS_22_05KHZ;
-		break;
-	case 24000:
-		fs |= AK4951_FS_24KHZ;
-		break;
-	case 32000:
-		fs |= AK4951_FS_32KHZ;
-		break;
-	case 44100:
-		fs |= AK4951_FS_44_1KHZ;
-		break;
-	case 48000:
-		fs |= AK4951_FS_48KHZ;
-		break;
 
-	default:
-		return -EINVAL;
+	if(ak4951->clkid == AK4951_BCLK_IN) {
+		switch (rate) {
+			case 8000:
+				fs |= AK4951_BICK_FS_8KHZ;
+				break;
+			case 11025:
+				fs |= AK4951_BICK_FS_11_025KHZ;
+				break;
+			case 12000:
+				fs |= AK4951_BICK_FS_12KHZ;
+				break;
+			case 16000:
+				fs |= AK4951_BICK_FS_16KHZ;
+				break;
+			case 22050:
+				fs |= AK4951_BICK_FS_22_05KHZ;
+				break;
+			case 24000:
+				fs |= AK4951_BICK_FS_24KHZ;
+				break;
+			case 32000:
+				fs |= AK4951_BICK_FS_32KHZ;
+				break;
+			case 44100:
+				fs |= AK4951_BICK_FS_44_1KHZ;
+				break;
+			case 48000:
+				fs |= AK4951_BICK_FS_48KHZ;
+				break;
+
+			default:
+				return -EINVAL;
+		}
+
+	} else {
+		switch (rate) {
+			case 8000:
+				fs |= AK4951_MCKI_FS_8KHZ;
+				break;
+			case 11025:
+				fs |= AK4951_MCKI_FS_11_025KHZ;
+				break;
+			case 12000:
+				fs |= AK4951_MCKI_FS_12KHZ;
+				break;
+			case 16000:
+				fs |= AK4951_MCKI_FS_16KHZ;
+				break;
+			case 22050:
+				fs |= AK4951_MCKI_FS_22_05KHZ;
+				break;
+			case 24000:
+				fs |= AK4951_MCKI_FS_24KHZ;
+				break;
+			case 32000:
+				fs |= AK4951_MCKI_FS_32KHZ;
+				break;
+			case 44100:
+				fs |= AK4951_MCKI_FS_44_1KHZ;
+				break;
+			case 48000:
+				fs |= AK4951_MCKI_FS_48KHZ;
+				break;
+
+			default:
+				return -EINVAL;
+		}
+	}
+
+	switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			ak4951->fmt = 2 << 4;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			ak4951->fmt = 3 << 4;
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			ak4951->fmt = 3 << 4;
+			break;
+		default:
+			dev_err(codec->dev, "Can not support the format");
+			return -EINVAL;
 	}
 	snd_soc_write(codec, AK4951_06_MODE_CONTROL2, fs);
 
@@ -827,29 +881,28 @@ static int ak4951_set_pll(u8 *pll, int clk_id,int freq)
 	if (clk_id == AK4951_MCLK_IN_BCLK_OUT){
 		switch (freq) {
 		case 11289600:
-			*pll |= (2 << 4);
+			*pll |= (4 << 4);
 			break;
 		case 12288000:
-			*pll |= (3 << 4);
+			*pll |= (5 << 4);
 			break;
 		case 12000000:
-			*pll |= (4 << 4);
+			*pll |= (6 << 4);
 			break;
 		case 24000000:
-			*pll |= (5 << 4);
+			*pll |= (7 << 4);
 			break;
 		case 13500000:
-			*pll |= (6 << 4);
+			*pll |= (0xC << 4);
 			break;
 		case 27000000:
-			*pll |= (7 << 4);
+			*pll |= (0xD << 4);
 			break;
 		default:
 			break;
 		}
-	}else if  (clk_id == AK4951_BCLK_IN) {
-		*pll |= (0 << 4);
 	}
+
 	return 0;
 }
 
@@ -876,7 +929,7 @@ static int ak4951_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
 	}else if (clk_id == AK4951_BCLK_IN) {
 		pllpwr |= AK4951_PMPLL;
 		pllpwr &= (~AK4951_M_S);
-		ak4951_set_pll(&pll, clk_id, freq);
+		pll |= ak4951->fmt;
 	}else if (clk_id == AK4951_MCLK_IN_BCLK_OUT) {
 		pllpwr |= AK4951_PMPLL;
 		pllpwr |= AK4951_M_S;
@@ -913,7 +966,7 @@ static int ak4951_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
             break;
         case SND_SOC_DAIFMT_CBM_CFM:
 			akdbgprt("\t[AK4951] %s(Master)\n",__FUNCTION__);
-            mode |= (AK4951_M_S);
+            mode |= AK4951_M_S;
             //format |= (AK4951_BCKO);
             break;
         case SND_SOC_DAIFMT_CBS_CFM:
@@ -1011,7 +1064,7 @@ static int ak4951_set_bias_level(struct snd_soc_codec *codec,
 				SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\
 				SNDRV_PCM_RATE_96000)
 
-#define AK4951_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
+#define AK4951_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 static struct snd_soc_dai_ops ak4951_dai_ops = {
 	.hw_params	= ak4951_hw_params,
@@ -1043,11 +1096,12 @@ struct snd_soc_dai_driver ak4951_dai[] = {
 
 static int ak4951_probe(struct snd_soc_codec *codec)
 {
-	struct ak4951_priv *ak4951 = snd_soc_codec_get_drvdata(codec);
+	struct ak4951_priv *ak4951 = ak4951_data;
 	int ret = 0;
 
 	akdbgprt("\t[AK4951] %s(%d)\n",__FUNCTION__,__LINE__);
 	codec->control_data = ak4951->regmap;
+	snd_soc_codec_set_drvdata(codec, ak4951);
 	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);
 	if (ret != 0) {
 		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
@@ -1087,11 +1141,12 @@ static int ak4951_probe(struct snd_soc_codec *codec)
 	snd_soc_update_bits(codec,AK4951_08_DIGITL_MIC,0x01,0x00);//AMIC
 	snd_soc_update_bits(codec,AK4951_1D_DIGITAL_FILTER_MODE,0x02,0x02);//ADC output
 	snd_soc_update_bits(codec,AK4951_1D_DIGITAL_FILTER_MODE,0x01,0x01);//ALC output
-	snd_soc_update_bits(codec,AK4951_02_SIGNAL_SELECT1,0x47,0x42);//Mic Gain 0x10100110
+	snd_soc_update_bits(codec,AK4951_02_SIGNAL_SELECT1,0x47,0x00);//Mic Gain 0x10100110
 	snd_soc_update_bits(codec,AK4951_0D_LCH_INPUT_VOLUME_CONTROL,0xff,0xb0);//Lch gain
 	snd_soc_update_bits(codec,AK4951_0E_RCH_INPUT_VOLUME_CONTROL,0xff,0xb0);//Lch gain
 	snd_soc_write(codec, AK4951_0B_ALC_MODE_CONTROL1, 0x20);	//enable ALC
-
+	snd_soc_write(codec, AK4951_1B_DIGITAL_FILTER_SELECT1, 0x07); //enable HPF1
+	snd_soc_write(codec, AK4951_0C_ALC_MODE_CONTROL2, 0xF1);
 	/*Enable LIN3*/
 	//snd_soc_update_bits(codec,AK4951_03_SIGNAL_SELECT2,0x0f,0x0a);// LIN3 RIN3
     return ret;
@@ -1111,6 +1166,13 @@ static int ak4951_remove(struct snd_soc_codec *codec)
 
 static int ak4951_suspend(struct snd_soc_codec *codec)
 {
+	struct ak4951_priv *ak4951 = snd_soc_codec_get_drvdata(codec);
+	int i;
+
+	for(i = 0; i < 7; i++) {
+		ak4951->reg_cache[i] = snd_soc_read(codec, i);
+	}
+
 	ak4951_set_bias_level(codec, SND_SOC_BIAS_OFF);
 
 	return 0;
@@ -1118,8 +1180,14 @@ static int ak4951_suspend(struct snd_soc_codec *codec)
 
 static int ak4951_resume(struct snd_soc_codec *codec)
 {
+	struct ak4951_priv *ak4951 = snd_soc_codec_get_drvdata(codec);
+	int i;
 
-	ak4951_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	for(i = 0; i < 7; i++) {
+		snd_soc_write(codec, i, ak4951->reg_cache[i]);
+	}
+
+	ak4951_set_bias_level(codec, codec->dapm.bias_level);
 
 	return 0;
 }
@@ -1160,7 +1228,6 @@ static int ak4951_i2c_probe(struct i2c_client *i2c,
 	struct ak4951_priv *ak4951;
 	enum of_gpio_flags flags;
 	int rst_pin;
-	struct snd_soc_codec *codec;
 	int ret = 0;
 
 	akdbgprt("\t[AK4951] %s(%d)\n",__FUNCTION__,__LINE__);
@@ -1176,7 +1243,6 @@ static int ak4951_i2c_probe(struct i2c_client *i2c,
 	ak4951->i2c_clt = i2c;
 	ak4951->rst_pin = rst_pin;
 	ak4951->rst_active = !!(flags & OF_GPIO_ACTIVE_LOW);
-	codec = &ak4951->codec;
 	i2c_set_clientdata(i2c, ak4951);
 	ak4951->regmap = devm_regmap_init_i2c(i2c, &ak4951_regmap);
 	if (IS_ERR(ak4951->regmap)) {
@@ -1185,6 +1251,8 @@ static int ak4951_i2c_probe(struct i2c_client *i2c,
 		return ret;
 	}
 
+	ak4951_data = ak4951;
+
 	ret = snd_soc_register_codec(&i2c->dev,
 			&soc_codec_dev_ak4951, &ak4951_dai[0], ARRAY_SIZE(ak4951_dai));
 	if (ret < 0){
diff --git a/sound/soc/codecs/ak4951_amb.h b/sound/soc/codecs/ak4951_amb.h
index 8202753..919ce5e 100644
--- a/sound/soc/codecs/ak4951_amb.h
+++ b/sound/soc/codecs/ak4951_amb.h
@@ -141,15 +141,25 @@
 
 /* AK4954_06_MODE_CONTROL2 (0x06) Fields */
 #define AK4951_FS				0x0F
-#define AK4951_FS_8KHZ			(0 << 0)
-#define AK4951_FS_12KHZ			(1 << 0)
-#define AK4951_FS_16KHZ			(2 << 0)
-#define AK4951_FS_11_025KHZ		(5 << 0)
-#define AK4951_FS_22_05KHZ		(7 << 0)
-#define AK4951_FS_24KHZ			(9 << 0)
-#define AK4951_FS_32KHZ			(10 << 0)
-#define AK4951_FS_48KHZ			(11 << 0)
-#define AK4951_FS_44_1KHZ		(15 << 0)
+#define AK4951_MCKI_FS_8KHZ			(0 << 0)
+#define AK4951_MCKI_FS_12KHZ			(1 << 0)
+#define AK4951_MCKI_FS_16KHZ			(2 << 0)
+#define AK4951_MCKI_FS_11_025KHZ		(5 << 0)
+#define AK4951_MCKI_FS_22_05KHZ			(7 << 0)
+#define AK4951_MCKI_FS_24KHZ			(9 << 0)
+#define AK4951_MCKI_FS_32KHZ			(10 << 0)
+#define AK4951_MCKI_FS_44_1KHZ			(15 << 0)
+#define AK4951_MCKI_FS_48KHZ			(11 << 0)
+
+#define AK4951_BICK_FS_8KHZ			(0 << 0)
+#define AK4951_BICK_FS_12KHZ			(1 << 0)
+#define AK4951_BICK_FS_16KHZ			(5 << 0)
+#define AK4951_BICK_FS_11_025KHZ		(2 << 0)
+#define AK4951_BICK_FS_22_05KHZ			(7 << 0)
+#define AK4951_BICK_FS_24KHZ			(6 << 0)
+#define AK4951_BICK_FS_32KHZ			(10 << 0)
+#define AK4951_BICK_FS_44_1KHZ			(8 << 0)
+#define AK4951_BICK_FS_48KHZ			(11 << 0)
 
 #define AK4951_FS_CM0			(1 << 6)
 #define AK4951_FS_CM1			(1 << 7)
diff --git a/sound/soc/codecs/ak7755.c b/sound/soc/codecs/ak7755.c
new file mode 100644
index 0000000..867c44f
--- /dev/null
+++ b/sound/soc/codecs/ak7755.c
@@ -0,0 +1,2693 @@
+/*
+ * ak7755.c  --  audio driver for AK7755
+ *
+ * Copyright (C) 2014 Asahi Kasei Microdevices Corporation
+ *  Author                Date        Revision
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *                      14/04/22	    1.0
+ *                      15/06/15	    1.1
+ *                      16/01/13	    2.01  kernel 3.10.94
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <sound/pcm_params.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/spi/spi.h>
+#include <plat/spi.h>
+
+
+#include <linux/of_gpio.h> // '16/01/13
+
+#include <linux/mutex.h>
+#include <linux/firmware.h>
+#include <linux/vmalloc.h>
+
+#include <sound/ak7755_pdata.h>    // '15/06/15
+#include "ak7755.h"
+#include "ak7755_dsp_code.h"
+#include <linux/types.h>
+
+//#define AK7755_PD_SUSPEND     // '15/06/15
+
+//#define AK7755_DEBUG			//used at debug mode
+#define AK7755_CONTIF_DEBUG	//used at debug mode
+
+#ifdef AK7755_DEBUG
+#define akdbgprt printk
+#else
+#define akdbgprt(format, arg...) do {} while (0)
+#endif
+static int fast_boot = 0;
+module_param(fast_boot, uint, 0664);
+static int aec = 1;
+module_param(aec, uint, 0664);
+static int RAM_FLAG = 1;
+
+
+/* AK7755 Codec Private Data */
+struct ak7755_priv {
+	enum snd_soc_control_type control_type;
+	struct snd_soc_codec *codec;
+	struct spi_device *spi;
+	struct i2c_client *i2c;
+	int fs;
+	int rclk;			//Master Clock
+	int lign;			//LIGN3-0(LineIn Volume)
+	int selmix;			//SELMIX2-0
+	int status;
+	int MIRNo;
+	int bickfs;         // '15/06/15  0:64fs, 1:48fs, 2:32fs, 3:256fs
+	int pdn_gpio;       // '15/06/15
+	unsigned int pdn_active;
+	int power_gpio;
+	unsigned int power_active;
+	int amp_gpio;
+	unsigned int amp_active;
+	unsigned int fmt;
+
+
+	u16  DSPPramMode;
+	u16  DSPCramMode;
+	u16  DSPOfregMode;
+	u16  DSPAcramMode;
+	int  EQLevel[5];
+	int  HPFfc[2];
+	int  LimRel;
+	int  LimVol;
+};
+
+struct _ak7755_pd_handler {
+	int ref_count;
+	struct mutex lock;
+	struct ak7755_priv *data;
+} ak7755_pd_handler = {
+	.ref_count = -1,
+	.data = NULL,
+};
+
+
+static int ak7755_reads(u8 *, size_t, u8 *, size_t);
+static int ak7755_writes(const u8 *tx, size_t wlen);
+static unsigned int ak7755_i2c_read(u8 *reg,int reglen,u8 *data,int datalen);
+
+
+static struct ak7755_priv *ak7755_data;
+/* ak7755 register cache & default register settings */
+static u8 ak7755_reg[AK7755_MAX_REGISTERS];
+
+static const u8 ak7755_reg2[] = {
+	0x00,	/*	0xC0	AK7755_C0_CLOCK_SETTING1			*/
+	0x00,	/*	0xC1	AK7755_C1_CLOCK_SETTING2			*/
+	0x00,	/*	0xC2	AK7755_C2_SERIAL_DATA_FORMAT		*/
+	0x00,	/*	0xC3	AK7755_C3_DELAY_RAM_DSP_IO			*/
+	0x00,	/*	0xC4	AK7755_C4_DATARAM_CRAM_SETTING		*/
+	0x00,	/*	0xC5	AK7755_C5_ACCELARETOR_SETTING		*/
+	0x00,	/*	0xC6	AK7755_C6_DAC_DEM_SETTING			*/
+	0x00,	/*	0xC7	AK7755_C7_DSP_OUT_SETTING			*/
+	0x00,	/*	0xC8	AK7755_C8_DAC_IN_SETTING			*/
+	0x00,	/*	0xC9	AK7755_C9_ANALOG_IO_SETTING			*/
+	0x00,	/*	0xCA	AK7755_CA_CLK_SDOUT_SETTING			*/
+	0x00,	/*	0xCB	AK7755_CB_TEST_SETTING				*/
+	0x00,	/*	0xCC	AK7755_CC_VOLUME_TRANSITION			*/
+	0x80,	/*	0xCD	AK7755_CD_STO_DLS_SETTING			*/
+	0x00,	/*	0xCE	AK7755_CE_POWER_MANAGEMENT			*/
+	0x00,	/*	0xCF	AK7755_CF_RESET_POWER_SETTING		*/
+	0x00,	/*	0xD0	AK7755_D0_FUNCTION_SETTING			*/
+	0x00,	/*	0xD1	AK7755_D1_DSPMCLK_SETTING			*/
+	0x00,	/*	0xD2	AK7755_D2_MIC_GAIN_SETTING			*/
+	0x00,	/*	0xD3	AK7755_D3_LIN_LO3_VOLUME_SETTING	*/
+	0x00,	/*	0xD4	AK7755_D4_LO1_LO2_VOLUME_SETTING	*/
+	0x30,	/*	0xD5	AK7755_D5_ADC_DVOLUME_SETTING1		*/
+	0x30,	/*	0xD6	AK7755_D6_ADC_DVOLUME_SETTING2		*/
+	0x30,	/*	0xD7	AK7755_D7_ADC2_DVOLUME_SETTING1		*/
+	0x18,	/*	0xD8	AK7755_D8_DAC_DVOLUME_SETTING1		*/
+	0x18,	/*	0xD9	AK7755_D9_DAC_DVOLUME_SETTING2		*/
+	0x00,	/*	0xDA	AK7755_DA_MUTE_ADRC_ZEROCROSS_SET	*/
+	0x00,	/*	0xDB	AK7755_DB_ADRC_MIC_GAIN_READ		*/
+	0x00,	/*	0xDC	AK7755_DC_TEST_SETTING				*/
+	0x30,	/*	0xDD	AK7755_DD_ADC2_DVOLUME_SETTING2		*/
+	0x00,	/*	0xDE	AK7755_DE_DMIC_IF_SETTING			*/
+};
+
+static struct {
+	int readable;   /* Mask of readable bits */
+	int writable;   /* Mask of writable bits */
+} ak7755_access_masks[AK7755_MAX_REGISTERS];
+
+static const struct {
+	int readable;   /* Mask of readable bits */
+	int writable;   /* Mask of writable bits */
+} ak7755_access_masks2[] = {
+    { 0xFF, 0x7F },	//0xC0
+    { 0xFF, 0xFF },	//0xC1
+    { 0xFF, 0xFF },	//0xC2
+    { 0xFF, 0xFF },	//0xC3
+    { 0xFF, 0xFB },	//0xC4
+    { 0xFF, 0xFF },	//0xC5
+    { 0xFF, 0xF7 },	//0xC6
+    { 0xFF, 0xF7 },	//0xC7
+    { 0xFF, 0xFF },	//0xC8
+    { 0xFF, 0xFF },	//0xC9
+    { 0xFF, 0xE7 },	//0xCA
+    { 0xFF, 0x00 },	//0xCB
+    { 0xFF, 0xB7 },	//0xCC
+    { 0xFF, 0x81 },	//0xCD
+    { 0xFF, 0xFF },	//0xCE
+    { 0xFF, 0x37 },	//0xCF
+    { 0xFF, 0xF9 },	//0xD0
+    { 0xFF, 0xFF },	//0xD1
+    { 0xFF, 0xFF },	//0xD2
+    { 0xFF, 0xFF },	//0xD3
+    { 0xFF, 0xFF },	//0xD4
+    { 0xFF, 0xFF },	//0xD5
+    { 0xFF, 0xFF },	//0xD6
+    { 0xFF, 0xFF },	//0xD7
+    { 0xFF, 0xFF },	//0xD8
+    { 0xFF, 0xFF },	//0xD9
+    { 0xFF, 0xFF },	//0xDA
+    { 0xFF, 0x00 },	//0xDB
+    { 0xFF, 0x00 },	//0xDC
+    { 0xFF, 0xFF },	//0xDD
+    { 0xFF, 0xFC },	//0xDE
+};
+
+/* MIC Input Volume control:
+ * from 0 to 36 dB (quantity of each step is various) */
+static DECLARE_TLV_DB_MINMAX(mgnl_tlv, 0, 3600);
+static DECLARE_TLV_DB_MINMAX(mgnr_tlv, 0, 3600);
+
+/* Line-out Volume control:
+ * from -30 to 0 dB in 2 dB steps (mute instead of -30 dB) */
+static DECLARE_TLV_DB_SCALE(lovol1_tlv, -3000, 200, 0);
+static DECLARE_TLV_DB_SCALE(lovol2_tlv, -3000, 200, 0);
+static DECLARE_TLV_DB_SCALE(lovol3_tlv, -3000, 200, 0);
+
+static const char *line_in_texts[]  =
+{
+	"-21dB","-18dB","-15dB","-12dB","-9dB","-6dB","-3dB",
+	"0dB","+3dB","+6dB","+9dB","+12dB","+15dB","+18dB","+21dB",
+};
+
+static const struct soc_enum ak7755_linein_enum[] = {
+    SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(line_in_texts), line_in_texts),
+};
+
+/* ADC, ADC2 Digital Volume control:
+ * from -103.5 to 24 dB in 0.5 dB steps (mute instead of -103.5 dB) */
+static DECLARE_TLV_DB_SCALE(voladl_tlv, -10350, 50, 0);
+static DECLARE_TLV_DB_SCALE(voladr_tlv, -10350, 50, 0);
+static DECLARE_TLV_DB_SCALE(volad2l_tlv, -10350, 50, 0);
+static DECLARE_TLV_DB_SCALE(volad2r_tlv, -10350, 50, 0);
+
+/* DAC Digital Volume control:
+ * from -115.5 to 12 dB in 0.5 dB steps (mute instead of -115.5 dB) */
+static DECLARE_TLV_DB_SCALE(voldal_tlv, -11550, 50, 0);
+static DECLARE_TLV_DB_SCALE(voldar_tlv, -11550, 50, 0);
+
+
+static const char *ak7755_bank_select_texts[] =
+		{"0:8192", "1024:7168","2048:6144","3072:5120","4096:4096",
+			"5120:3072","6144:2048","7168:1024","8192:0"};
+static const char *ak7755_drms_select_texts[] =
+		{"512:1536", "1024:1024", "1536:512"};
+static const char *ak7755_dram_select_texts[] =
+		{"Ring:Ring", "Ring:Linear", "Linear:Ring", "Linear:Linear"};
+static const char *ak7755_pomode_select_texts[] = {"DBUS Immediate", "OFREG"};
+static const char *ak7755_wavp_select_texts[] =
+		{"33 word", "65 word", "129 word", "257 word"};
+static const char *ak7755_filmode1_select_texts[] = {"Adaptive Filter", "FIR Filter"};
+static const char *ak7755_filmode2_select_texts[] = {"Adaptive Filter", "FIR Filter"};
+static const char *ak7755_submode1_select_texts[] = {"Fullband", "Subband"};
+static const char *ak7755_submode2_select_texts[] = {"Fullband", "Subband"};
+static const char *ak7755_memdiv_select_texts[] =
+		{"2048:-", "1792:256", "1536:512", "1024:1024"};
+static const char *ak7755_dem_select_texts[] = {"Off", "48kHz", "44.1kHz", "32kHz"};
+static const char *ak7755_clkoe_select_texts[] = {"CLKO=L", "CLKO Out Enable"};
+static const char *ak7755_clks_select_texts[] =
+		{"12.288MHz", "6.144MHz", "3.072MHz", "8.192MHz",
+			"4.096MHz", "2.048MHz", "256fs", "XTI or BICK"};
+
+static const struct soc_enum ak7755_set_enum[] = {
+	SOC_ENUM_SINGLE(AK7755_C3_DELAY_RAM_DSP_IO, 0,
+			ARRAY_SIZE(ak7755_bank_select_texts), ak7755_bank_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C4_DATARAM_CRAM_SETTING, 6,
+			ARRAY_SIZE(ak7755_drms_select_texts), ak7755_drms_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C4_DATARAM_CRAM_SETTING, 4,
+			ARRAY_SIZE(ak7755_dram_select_texts), ak7755_dram_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C4_DATARAM_CRAM_SETTING, 3,
+			ARRAY_SIZE(ak7755_pomode_select_texts), ak7755_pomode_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C4_DATARAM_CRAM_SETTING, 0,
+			ARRAY_SIZE(ak7755_wavp_select_texts), ak7755_wavp_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C5_ACCELARETOR_SETTING, 5,
+			ARRAY_SIZE(ak7755_filmode1_select_texts), ak7755_filmode1_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C5_ACCELARETOR_SETTING, 4,
+			ARRAY_SIZE(ak7755_filmode2_select_texts), ak7755_filmode2_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C5_ACCELARETOR_SETTING, 3,
+			ARRAY_SIZE(ak7755_submode1_select_texts), ak7755_submode1_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C5_ACCELARETOR_SETTING, 2,
+			ARRAY_SIZE(ak7755_submode2_select_texts), ak7755_submode2_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C5_ACCELARETOR_SETTING, 0,
+			ARRAY_SIZE(ak7755_memdiv_select_texts), ak7755_memdiv_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C6_DAC_DEM_SETTING, 6,
+			ARRAY_SIZE(ak7755_dem_select_texts), ak7755_dem_select_texts),
+	SOC_ENUM_SINGLE(AK7755_CA_CLK_SDOUT_SETTING, 7,
+			ARRAY_SIZE(ak7755_clkoe_select_texts), ak7755_clkoe_select_texts),
+	SOC_ENUM_SINGLE(AK7755_C1_CLOCK_SETTING2, 1,
+			ARRAY_SIZE(ak7755_clks_select_texts), ak7755_clks_select_texts),
+};
+
+// '15/06/15
+static const char *ak7755_bick_select_texts[] =
+		{"64fs", "48fs", "32fs", "TDM" };
+
+static const struct soc_enum ak7755_bick_enum[] = {
+    SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(ak7755_bick_select_texts), ak7755_bick_select_texts)
+};
+
+static int get_bickfs(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+
+    ucontrol->value.enumerated.item[0] = ak7755->bickfs;
+
+    return 0;
+}
+
+static int set_bickfs(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+
+	ak7755->bickfs = ucontrol->value.enumerated.item[0];
+    return 0;
+}
+// '15/06/15
+
+static const char *selmix_set_texts[]  =
+{
+	"SDOUTAD", "ADL_AD2L/ADR", "ADL/ADR_AD2R", "SDOUTAD2",
+	"DSPL/AD2R", "AD2L/DSPR", "DSPL/ADR", "ADL/DSPR",
+};
+
+static const struct soc_enum ak7755_selmix_enum[] = {
+    SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(selmix_set_texts), selmix_set_texts),
+};
+
+// Added for AK7755
+static const struct soc_enum ak7755_firmware_enum[] =
+{
+    SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(ak7755_firmware_pram), ak7755_firmware_pram),
+    SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(ak7755_firmware_cram), ak7755_firmware_cram),
+    SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(ak7755_firmware_ofreg), ak7755_firmware_ofreg),
+    SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(ak7755_firmware_acram), ak7755_firmware_acram),
+};
+
+static inline u32 ak7755_read_reg_cache(struct snd_soc_codec *, u16);
+static int ak7755_firmware_write_ram(u16 mode, u16 cmd);
+static int ak7755_set_status(enum ak7755_status status);
+static int ak7755_write_cram(int addr, int len, unsigned char *cram_data);
+
+static int get_linein(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+
+    ucontrol->value.enumerated.item[0] = ak7755->lign;
+
+    return 0;
+}
+
+static int set_linein(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+
+	ak7755->lign = ucontrol->value.enumerated.item[0];
+
+	if ( ak7755->lign <= 7) {
+		snd_soc_update_bits(codec, AK7755_D3_LIN_LO3_VOLUME_SETTING, 0xF0, ((7 - ak7755->lign) << 4) );
+	}
+	else {
+		snd_soc_update_bits(codec, AK7755_D3_LIN_LO3_VOLUME_SETTING, 0xF0, ((ak7755->lign + 1) << 4) );
+	}
+
+    return 0;
+}
+
+static int get_selmix(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+
+    ucontrol->value.enumerated.item[0] = ak7755->selmix;
+
+    return 0;
+}
+
+static int set_selmix(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+
+	ak7755->selmix = ucontrol->value.enumerated.item[0];
+
+	if ( ak7755->selmix < 4) {	//SELMIX2=0, SELMIX1-0=selmix
+		snd_soc_update_bits(codec, AK7755_C9_ANALOG_IO_SETTING, 0x01, 0x00);
+		snd_soc_update_bits(codec, AK7755_C8_DAC_IN_SETTING, 0x03, ak7755->selmix);
+	}
+	else {						//SELMIX2=1, SELMIX1-0=(selmix & 0x03)
+		snd_soc_update_bits(codec, AK7755_C9_ANALOG_IO_SETTING, 0x01, 0x01);
+		snd_soc_update_bits(codec, AK7755_C8_DAC_IN_SETTING, 0x03, (ak7755->selmix & 0x03));
+	}
+
+    return 0;
+}
+
+static int get_DSP_write_pram(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    /* Get the current output routing */
+    ucontrol->value.enumerated.item[0] = ak7755_data->DSPPramMode;
+
+    return 0;
+
+}
+
+static int set_DSP_write_pram(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    u32    currMode = ucontrol->value.enumerated.item[0];
+	int    ret;
+	akdbgprt("set_DSP_write_pram start ...\n");
+
+/*
+	if ( currMode == ak7755_data->DSPPramMode ) {
+		akdbgprt("\t%s Same PRAM mode =%d\n",__FUNCTION__, currMode);
+		return(0);
+	}
+*/
+	if (RAM_FLAG ==1 ){
+		akdbgprt("\t%s PRAM mode =%d\n",__FUNCTION__, currMode);
+
+		ret = ak7755_firmware_write_ram(RAMTYPE_PRAM, currMode);
+		if ( ret != 0 ) return(-1);
+
+		ak7755_data->DSPPramMode = currMode;
+	}
+	akdbgprt("set_DSP_write_pram done ...\n");
+	return(0);
+}
+
+static int get_DSP_write_cram(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    /* Get the current output routing */
+    ucontrol->value.enumerated.item[0] = ak7755_data->DSPCramMode;
+
+    return 0;
+
+}
+
+static int set_DSP_write_cram(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    u32    currMode = ucontrol->value.enumerated.item[0];
+	int    ret;
+	akdbgprt("set_DSP_write_cram start ...\n");
+
+/*
+	if ( currMode == ak7755_data->DSPCramMode ) {
+		akdbgprt("\t%s Same CRAM mode =%d\n",__FUNCTION__, currMode);
+		return(0);
+	}
+*/
+	if (RAM_FLAG ==1){
+		RAM_FLAG = 0 ;
+		akdbgprt("\t%s CRAM mode =%d\n",__FUNCTION__, currMode);
+
+		ret = ak7755_firmware_write_ram(RAMTYPE_CRAM, currMode);
+		if ( ret != 0 ) return(-1);
+
+		ak7755_data->DSPCramMode =currMode;
+	}
+	akdbgprt("set_DSP_write_cram done ...\n");
+	return(0);
+}
+
+static int get_DSP_write_ofreg(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    /* Get the current output routing */
+    ucontrol->value.enumerated.item[0] = ak7755_data->DSPOfregMode;
+
+    return 0;
+
+}
+
+static int set_DSP_write_ofreg(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    u32    currMode = ucontrol->value.enumerated.item[0];
+	int    ret;
+
+/*
+	if ( currMode == ak7755_data->DSPOfregMode ) {
+		akdbgprt("\t%s Same CRAM mode =%d\n",__FUNCTION__, currMode);
+		return(0);
+	}
+	akdbgprt("\t%s OFREG mode =%d\n",__FUNCTION__, currMode);
+*/
+	ret = ak7755_firmware_write_ram(RAMTYPE_OFREG, currMode);
+	if ( ret != 0 ) return(-1);
+
+	ak7755_data->DSPOfregMode =currMode;
+
+	return(0);
+}
+
+static int get_DSP_write_acram(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    /* Get the current output routing */
+    ucontrol->value.enumerated.item[0] = ak7755_data->DSPAcramMode;
+
+    return 0;
+
+}
+
+static int set_DSP_write_acram(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    u32    currMode = ucontrol->value.enumerated.item[0];
+	int    ret;
+
+/*
+	if ( currMode == ak7755_data->DSPAcramMode ) {
+		akdbgprt("\t%s Same CRAM mode =%d\n",__FUNCTION__, currMode);
+		return(0);
+	}
+*/
+	akdbgprt("\t%s ACRAM mode =%d\n",__FUNCTION__, currMode);
+
+	ret = ak7755_firmware_write_ram(RAMTYPE_ACRAM, currMode);
+	if ( ret != 0 ) return(-1);
+
+	ak7755_data->DSPAcramMode =currMode;
+
+	return(0);
+}
+
+#ifdef AK7755_DEBUG
+
+static int test_read_ram(int mode)
+{
+	u8	tx[3], rx[512];
+	int i, n, plen, clen;
+
+	akdbgprt("*****[AK7755] %s(%d)\n",__FUNCTION__,__LINE__);
+
+	snd_soc_update_bits(ak7755_data->codec, AK7755_CF_RESET_POWER_SETTING, 0x1, 0x1);  // DLRDY bit = 1
+	mdelay(1);
+	if ( mode == 1 ) {
+		plen = 10;
+		for ( n = 0 ; n < (5 * plen) ; n++ ) rx[n] = 0;
+		tx[0] = 0x38;
+		tx[1] = 0x0;
+		tx[2] = 0x0;
+		ak7755_reads(tx, 3, rx, 5 * plen);
+		printk("*****%s PRAM LEN = %d *******\n", __func__, plen);
+		n = 0;
+		for ( i = 0 ; i < plen ; i ++ ) {
+			printk("PAddr=%x %x %x %x %x %x\n", i,(int)rx[n], (int)rx[n+1], (int)rx[n+2], (int)rx[n+3], (int)rx[n+4]);
+			n += 5;
+		}
+	}
+	else if ( mode < 5 ) {
+		clen = 80;
+		for ( n = 0 ; n < (3 * clen) ; n++ ) rx[n] = 0;
+		if ( mode == 2 ) tx[0] = 0x34;
+		else if ( mode == 3 ) {
+			tx[0] = 0x32;
+			clen = 16;
+		}
+		else  tx[0] = 0x3B;
+		tx[1] = 0x0;
+		tx[2] = 0x0;
+		ak7755_reads(tx, 3, rx, 3 * clen);
+		printk("*****%s RAM CMD=%d,  LEN = %d*******\n", __func__, (int)tx[0], clen);
+		n = 0;
+		for ( i = 0 ; i < clen ; i ++ ) {
+			printk("CAddr=%x %x %x %x\n", i,(int)rx[n], (int)rx[n+1], (int)rx[n+2]);
+			n += 3;
+		}
+	}
+	mdelay(1);
+	snd_soc_update_bits(ak7755_data->codec, AK7755_CF_RESET_POWER_SETTING, 0x1, 0x0);  // DLRDY bit = 0
+
+	return(0);
+
+}
+
+static const char *test_reg_select[]   =
+{
+    "read AK7755 Reg 00:24",
+	"read PRAM",
+	"read CRAM",
+	"read OFREG",
+	"read ACRAM",
+};
+
+static const struct soc_enum ak7755_enum[] =
+{
+    SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(test_reg_select), test_reg_select),
+};
+
+static int nTestRegNo = 0;
+
+
+static int get_test_reg(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    /* Get the current output routing */
+    ucontrol->value.enumerated.item[0] = nTestRegNo;
+
+    return 0;
+}
+
+static int set_test_reg(
+struct snd_kcontrol       *kcontrol,
+struct snd_ctl_elem_value  *ucontrol)
+{
+    struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+    u32    currMode = ucontrol->value.enumerated.item[0];
+	int    i, value;
+	int	   regs, rege;
+
+	nTestRegNo = currMode;
+
+	if ( currMode == 0 ) {
+		regs = 0xC0;
+		rege = 0xDE;
+
+		for ( i = regs ; i <= rege ; i++ ){
+			value = snd_soc_read(codec, i);
+			printk("***AK7755 Addr,Reg=(%x, %x)\n", i, value);
+		}
+	}
+	else if ( currMode < 5 ) {
+		test_read_ram(currMode);
+	}
+
+	return 0;
+
+}
+#endif
+
+static const struct snd_kcontrol_new ak7755_snd_controls[] = {
+	SOC_SINGLE_TLV("MIC Input Volume L",
+			AK7755_D2_MIC_GAIN_SETTING, 0, 0x0F, 0, mgnl_tlv),
+	SOC_SINGLE_TLV("MIC Input Volume R",
+			AK7755_D2_MIC_GAIN_SETTING, 4, 0x0F, 0, mgnr_tlv),
+	SOC_SINGLE_TLV("Line Out Volume 1",
+			AK7755_D4_LO1_LO2_VOLUME_SETTING, 0, 0x0F, 0, lovol1_tlv),
+	SOC_SINGLE_TLV("Line Out Volume 2",
+			AK7755_D4_LO1_LO2_VOLUME_SETTING, 4, 0x0F, 0, lovol2_tlv),
+	SOC_SINGLE_TLV("Line Out Volume 3",
+			AK7755_D3_LIN_LO3_VOLUME_SETTING, 0, 0x0F, 0, lovol3_tlv),
+	SOC_ENUM_EXT("Line Input Volume", ak7755_linein_enum[0], get_linein, set_linein),
+	SOC_SINGLE_TLV("ADC Digital Volume L",
+			AK7755_D5_ADC_DVOLUME_SETTING1, 0, 0xFF, 1, voladl_tlv),
+	SOC_SINGLE_TLV("ADC Digital Volume R",
+			AK7755_D6_ADC_DVOLUME_SETTING2, 0, 0xFF, 1, voladr_tlv),
+	SOC_SINGLE_TLV("ADC2 Digital Volume L",
+			AK7755_D7_ADC2_DVOLUME_SETTING1, 0, 0xFF, 1, volad2l_tlv),
+	SOC_SINGLE_TLV("ADC2 Digital Volume R",
+			AK7755_DD_ADC2_DVOLUME_SETTING2, 0, 0xFF, 1, volad2r_tlv),
+	SOC_SINGLE_TLV("DAC Digital Volume L",
+			AK7755_D8_DAC_DVOLUME_SETTING1, 0, 0xFF, 1, voldal_tlv),
+	SOC_SINGLE_TLV("DAC Digital Volume R",
+			AK7755_D9_DAC_DVOLUME_SETTING2, 0, 0xFF, 1, voldar_tlv),
+
+	SOC_SINGLE("ADC Mute", AK7755_DA_MUTE_ADRC_ZEROCROSS_SET, 7, 1, 0),
+	SOC_SINGLE("ADC2 Mute", AK7755_DA_MUTE_ADRC_ZEROCROSS_SET, 6, 1, 0),
+	SOC_SINGLE("DAC Mute", AK7755_DA_MUTE_ADRC_ZEROCROSS_SET, 5, 1, 0),
+	SOC_SINGLE("Analog DRC Lch", AK7755_DA_MUTE_ADRC_ZEROCROSS_SET, 2, 1, 0),
+	SOC_SINGLE("Analog DRC Rch", AK7755_DA_MUTE_ADRC_ZEROCROSS_SET, 3, 1, 0),
+	SOC_SINGLE("MICGAIN Lch Zero-cross", AK7755_DA_MUTE_ADRC_ZEROCROSS_SET, 0, 1, 0),
+	SOC_SINGLE("MICGAIN Rch Zero-cross", AK7755_DA_MUTE_ADRC_ZEROCROSS_SET, 1, 1, 0),
+
+	SOC_ENUM("DAC De-emphasis", ak7755_set_enum[10]),
+
+	SOC_SINGLE("JX0 Enable", AK7755_C2_SERIAL_DATA_FORMAT, 0, 1, 0),
+	SOC_SINGLE("JX1 Enable", AK7755_C2_SERIAL_DATA_FORMAT, 1, 1, 0),
+	SOC_SINGLE("JX2 Enable", AK7755_C1_CLOCK_SETTING2, 7, 1, 0),
+	SOC_SINGLE("JX3 Enable", AK7755_C5_ACCELARETOR_SETTING, 6, 1, 0),
+
+	SOC_ENUM("DLRAM Mode(Bank1:Bank0)", ak7755_set_enum[0]),
+	SOC_ENUM("DRAM Size(Bank1:Bank0)", ak7755_set_enum[1]),
+	SOC_ENUM("DRAM Addressing Mode(Bank1:Bank0)", ak7755_set_enum[2]),
+	SOC_ENUM("POMODE DLRAM Pointer 0", ak7755_set_enum[3]),
+	SOC_ENUM("CRAM Memory Assignment", ak7755_set_enum[4]),
+	SOC_ENUM("FIRMODE1 Accelerator Ch1", ak7755_set_enum[5]),
+	SOC_ENUM("FIRMODE2 Accelerator Ch2", ak7755_set_enum[6]),
+	SOC_ENUM("SUBMODE1 Accelerator Ch1", ak7755_set_enum[7]),
+	SOC_ENUM("SUBMODE2 Accelerator Ch2", ak7755_set_enum[8]),
+	SOC_ENUM("Accelerator Memory(ch1:ch2)", ak7755_set_enum[9]),
+	SOC_ENUM("CLKO pin", ak7755_set_enum[11]),
+	SOC_ENUM("CLKO Output Clock", ak7755_set_enum[12]),
+
+	SOC_ENUM_EXT("BICK fs", ak7755_bick_enum[0], get_bickfs, set_bickfs),     // '15/06/15
+
+// Added for AK7755
+	SOC_ENUM_EXT("DSP Firmware PRAM", ak7755_firmware_enum[0], get_DSP_write_pram, set_DSP_write_pram),
+	SOC_ENUM_EXT("DSP Firmware CRAM", ak7755_firmware_enum[1], get_DSP_write_cram, set_DSP_write_cram),
+	SOC_ENUM_EXT("DSP Firmware OFREG", ak7755_firmware_enum[2], get_DSP_write_ofreg, set_DSP_write_ofreg),
+	SOC_ENUM_EXT("DSP Firmware ACRAM", ak7755_firmware_enum[3], get_DSP_write_acram, set_DSP_write_acram),
+#if 0
+#ifdef AK7755_CRAM_BASIC_COTROL
+	SOC_ENUM_EXT("CRAM EQ1 Level", ak7755_cram_write_enum[0], get_cram_write_eq1, set_cram_write_eq1),
+	SOC_ENUM_EXT("CRAM EQ2 Level", ak7755_cram_write_enum[0], get_cram_write_eq2, set_cram_write_eq2),
+	SOC_ENUM_EXT("CRAM EQ3 Level", ak7755_cram_write_enum[0], get_cram_write_eq3, set_cram_write_eq3),
+	SOC_ENUM_EXT("CRAM EQ4 Level", ak7755_cram_write_enum[0], get_cram_write_eq4, set_cram_write_eq4),
+	SOC_ENUM_EXT("CRAM EQ5 Level", ak7755_cram_write_enum[0], get_cram_write_eq5, set_cram_write_eq5),
+	SOC_ENUM_EXT("CRAM HPF1 fc", ak7755_cram_write_enum[1], get_cram_write_hpf1fc, set_cram_write_hpf1fc),
+	SOC_ENUM_EXT("CRAM HPF2 fc", ak7755_cram_write_enum[1], get_cram_write_hpf2fc, set_cram_write_hpf2fc),
+	SOC_ENUM_EXT("CRAM Limiter Release Time", ak7755_cram_write_enum[2], get_cram_write_limrel, set_cram_write_limrel),
+	SOC_ENUM_EXT("CRAM Limiter Volume", ak7755_cram_write_enum[3], get_cram_write_limvol, set_cram_write_limvol),
+#endif
+#endif
+#ifdef AK7755_DEBUG
+	SOC_ENUM_EXT("Reg Read", ak7755_enum[0], get_test_reg, set_test_reg),
+#endif
+
+	SOC_ENUM_EXT("SELMIX2-0", ak7755_selmix_enum[0], get_selmix, set_selmix),	//SELMIX2-0 bit setting
+
+};
+
+
+/* Clock Event for DAC, ADC */
+static int ak7755_clkset_event(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	akdbgprt("\t[AK7755] %s(%d)\n",__FUNCTION__,__LINE__);
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:	/* after widget power up */
+		snd_soc_update_bits(codec, AK7755_CF_RESET_POWER_SETTING, 0x08,0x08);	//CRESETN(CODEC ResetN)=1
+		break;
+	}
+
+	return 0;
+}
+
+/* Clock Event */
+static int ak7755_clock_event(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event) //CONFIG_LINF
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	akdbgprt("\t[AK7755] %s(%d)\n",__FUNCTION__,__LINE__);
+
+	switch (event) {
+		case SND_SOC_DAPM_POST_PMU:	/* after widget power up */
+			akdbgprt("\t[AK7755] %s wait=10msec\n",__FUNCTION__);
+			mdelay(10);
+			break;
+		case SND_SOC_DAPM_PRE_PMD:	/* before widget power down */
+			snd_soc_update_bits(codec, AK7755_CF_RESET_POWER_SETTING, 0x08,0x00);	//CODEC Reset
+			break;
+	}
+
+	return 0;
+}
+
+/* SDOUT 1 switch */
+static const struct snd_kcontrol_new ak7755_out1e_control =
+	SOC_DAPM_SINGLE("Switch", AK7755_CA_CLK_SDOUT_SETTING, 0, 1, 0);
+
+/* SDOUT 2 switch */
+static const struct snd_kcontrol_new ak7755_out2e_control =
+	SOC_DAPM_SINGLE("Switch", AK7755_CA_CLK_SDOUT_SETTING, 1, 1, 0);
+
+/* SDOUT 3 switch */
+static const struct snd_kcontrol_new ak7755_out3e_control =
+	SOC_DAPM_SINGLE("Switch", AK7755_CA_CLK_SDOUT_SETTING, 2, 1, 0);
+
+/* LineOut1 Switch */
+static const char *ak7755_pmlo1_select_texts[] =
+		{"Off", "On"};
+
+static const struct soc_enum ak7755_pmlo1_mux_enum =
+	SOC_ENUM_SINGLE(AK7755_CE_POWER_MANAGEMENT, 2,
+			ARRAY_SIZE(ak7755_pmlo1_select_texts), ak7755_pmlo1_select_texts);
+//	SOC_ENUM_SINGLE(0, 0,
+//			ARRAY_SIZE(ak7755_pmlo1_select_texts), ak7755_pmlo1_select_texts);
+
+static const struct snd_kcontrol_new ak7755_pmlo1_mux_control =
+	SOC_DAPM_ENUM("OUT1 SW", ak7755_pmlo1_mux_enum);
+	//SOC_DAPM_ENUM_VIRT("OUT1 SW", ak7755_pmlo1_mux_enum);
+
+/* LineOut2 Switch */
+static const char *ak7755_pmlo2_select_texts[] =
+		{"Off", "On"};
+
+static const struct soc_enum ak7755_pmlo2_mux_enum =
+	SOC_ENUM_SINGLE(AK7755_CE_POWER_MANAGEMENT, 3,
+			ARRAY_SIZE(ak7755_pmlo2_select_texts), ak7755_pmlo2_select_texts);
+//	SOC_ENUM_SINGLE(0, 0,
+//			ARRAY_SIZE(ak7755_pmlo2_select_texts), ak7755_pmlo2_select_texts);
+
+static const struct snd_kcontrol_new ak7755_pmlo2_mux_control =
+	SOC_DAPM_ENUM("OUT2 SW", ak7755_pmlo2_mux_enum);
+//	SOC_DAPM_ENUM_VIRT("OUT2 SW", ak7755_pmlo2_mux_enum);
+
+/* LineOut3 Mixer */
+static const struct snd_kcontrol_new ak7755_lo3sw_mixer_controls[] = {
+	SOC_DAPM_SINGLE("LOSW1", AK7755_C9_ANALOG_IO_SETTING, 1, 1, 0),
+	SOC_DAPM_SINGLE("LOSW2", AK7755_C9_ANALOG_IO_SETTING, 2, 1, 0),
+#ifndef DIGITAL_MIC		//LOSW3 used only Analog MIC
+	SOC_DAPM_SINGLE("LOSW3", AK7755_C9_ANALOG_IO_SETTING, 3, 1, 0),
+#endif
+};
+
+/* DSPIn Virt SWITCH */
+static const char *ak7755_dspinad_texts[] =
+		{"Off", "On"};
+
+static const struct soc_enum ak7755_dspinad_enum =
+	SOC_ENUM_SINGLE(0, 0,
+			ARRAY_SIZE(ak7755_dspinad_texts), ak7755_dspinad_texts);
+
+static const struct soc_enum ak7755_dspinad2_enum =
+	SOC_ENUM_SINGLE(0, 0,
+			ARRAY_SIZE(ak7755_dspinad_texts), ak7755_dspinad_texts);
+
+static const struct snd_kcontrol_new ak7755_dspinad_control =
+	SOC_DAPM_ENUM_VIRT("DSPINAD Switch", ak7755_dspinad_enum);
+
+static const struct snd_kcontrol_new ak7755_dspinad2_control =
+	SOC_DAPM_ENUM_VIRT("DSPINAD2 Switch", ak7755_dspinad2_enum);
+
+/* LIN MUX */
+static const char *ak7755_lin_select_texts[] =
+		{"IN1", "IN2", "INPN1"};
+
+static const struct soc_enum ak7755_lin_mux_enum =
+	SOC_ENUM_SINGLE(AK7755_C9_ANALOG_IO_SETTING, 4,
+			ARRAY_SIZE(ak7755_lin_select_texts), ak7755_lin_select_texts);
+
+static const struct snd_kcontrol_new ak7755_lin_mux_control =
+	SOC_DAPM_ENUM("LIN Select", ak7755_lin_mux_enum);
+
+/* RIN MUX */
+static const char *ak7755_rin_select_texts[] =
+		{"IN3", "IN4", "INPN2"};
+
+static const struct soc_enum ak7755_rin_mux_enum =
+	SOC_ENUM_SINGLE(AK7755_C9_ANALOG_IO_SETTING, 6,
+			ARRAY_SIZE(ak7755_rin_select_texts), ak7755_rin_select_texts);
+
+static const struct snd_kcontrol_new ak7755_rin_mux_control =
+	SOC_DAPM_ENUM("RIN Select", ak7755_rin_mux_enum);
+
+/* DAC MUX */
+static const char *ak7755_seldai_select_texts[] =
+		{"DSP", "MIXOUT", "SDIN2", "SDIN1"};
+
+static const struct soc_enum ak7755_seldai_mux_enum =
+	SOC_ENUM_SINGLE(AK7755_C8_DAC_IN_SETTING, 6,
+			ARRAY_SIZE(ak7755_seldai_select_texts), ak7755_seldai_select_texts);
+
+static const struct snd_kcontrol_new ak7755_seldai_mux_control =
+	SOC_DAPM_ENUM("SELDAI Select", ak7755_seldai_mux_enum);
+
+/* SDOUT1 MUX */
+static const char *ak7755_seldo1_select_texts[] =
+		{"DSP", "DSP GP0", "SDIN1", "SDOUTAD", "EEST", "SDOUTAD2"};
+
+static const struct soc_enum ak7755_seldo1_mux_enum =
+	SOC_ENUM_SINGLE(AK7755_CC_VOLUME_TRANSITION, 0,
+			ARRAY_SIZE(ak7755_seldo1_select_texts), ak7755_seldo1_select_texts);
+
+static const struct snd_kcontrol_new ak7755_seldo1_mux_control =
+	SOC_DAPM_ENUM("SELDO1 Select", ak7755_seldo1_mux_enum);
+
+/* SDOUT2 MUX */
+static const char *ak7755_seldo2_select_texts[] =
+		{"DSP", "DSP GP1", "SDIN2", "SDOUTAD2"};
+
+static const struct soc_enum ak7755_seldo2_mux_enum =
+	SOC_ENUM_SINGLE(AK7755_C8_DAC_IN_SETTING, 2,
+			ARRAY_SIZE(ak7755_seldo2_select_texts), ak7755_seldo2_select_texts);
+
+static const struct snd_kcontrol_new ak7755_seldo2_mux_control =
+	SOC_DAPM_ENUM("SELDO2 Select", ak7755_seldo2_mux_enum);
+
+/* SDOUT3 MUX */
+static const char *ak7755_seldo3_select_texts[] =
+		{"DSP DOUT3", "MIXOUT", "DSP DOUT4", "SDOUTAD2"};
+
+static const struct soc_enum ak7755_seldo3_mux_enum =
+	SOC_ENUM_SINGLE(AK7755_C8_DAC_IN_SETTING, 4,
+			ARRAY_SIZE(ak7755_seldo3_select_texts), ak7755_seldo3_select_texts);
+
+static const struct snd_kcontrol_new ak7755_seldo3_mux_control =
+	SOC_DAPM_ENUM("SELDO3 Select", ak7755_seldo3_mux_enum);
+
+/* SELMIX Virt SWITCH */
+static const char *ak7755_selmix_select_texts[] =
+		{"Off", "On"};
+
+static const struct soc_enum ak7755_sdoutad_selmix_enum =
+	SOC_ENUM_SINGLE(0, 0,
+			ARRAY_SIZE(ak7755_selmix_select_texts), ak7755_selmix_select_texts);
+
+static const struct soc_enum ak7755_sdoutad2_selmix_enum =
+	SOC_ENUM_SINGLE(0, 0,
+			ARRAY_SIZE(ak7755_selmix_select_texts), ak7755_selmix_select_texts);
+
+static const struct soc_enum ak7755_dsp_selmix_enum =
+	SOC_ENUM_SINGLE(0, 0,
+			ARRAY_SIZE(ak7755_selmix_select_texts), ak7755_selmix_select_texts);
+
+static const struct snd_kcontrol_new ak7755_sdoutad_selmix_control =
+	SOC_DAPM_ENUM_VIRT("SELMIX Switch", ak7755_sdoutad_selmix_enum);
+
+static const struct snd_kcontrol_new ak7755_sdoutad2_selmix_control =
+	SOC_DAPM_ENUM_VIRT("SELMIX Switch", ak7755_sdoutad2_selmix_enum);
+
+static const struct snd_kcontrol_new ak7755_dsp_selmix_control =
+	SOC_DAPM_ENUM_VIRT("SELMIX Switch", ak7755_dsp_selmix_enum);
+
+
+
+/* ak7755 dapm widgets */
+static const struct snd_soc_dapm_widget ak7755_dapm_widgets[] = {
+
+// ADC, DAC
+#ifdef DIGITAL_MIC
+	SND_SOC_DAPM_INPUT("DMICIN1"),
+	SND_SOC_DAPM_INPUT("DMICIN2"),
+	SND_SOC_DAPM_ADC_E("DMIC1 Left",  "NULL", AK7755_CE_POWER_MANAGEMENT, 6, 0,
+		ak7755_clkset_event, SND_SOC_DAPM_POST_PMU ),
+	SND_SOC_DAPM_ADC_E("DMIC1 Right", "NULL", AK7755_CE_POWER_MANAGEMENT, 7, 0,
+		ak7755_clkset_event, SND_SOC_DAPM_POST_PMU ),
+	SND_SOC_DAPM_ADC_E("DMIC2 Left",  "NULL", AK7755_CE_POWER_MANAGEMENT, 5, 0,
+		ak7755_clkset_event, SND_SOC_DAPM_POST_PMU ),
+	SND_SOC_DAPM_ADC_E("DMIC2 Right", "NULL", AK7755_CF_RESET_POWER_SETTING, 1, 0,
+		ak7755_clkset_event, SND_SOC_DAPM_POST_PMU ),
+	SND_SOC_DAPM_SUPPLY("DMIC1 CLK", AK7755_DE_DMIC_IF_SETTING, 5, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("DMIC2 CLK", AK7755_DE_DMIC_IF_SETTING, 2, 0, NULL, 0),
+#else
+	SND_SOC_DAPM_ADC_E("ADC Left", "NULL", AK7755_CE_POWER_MANAGEMENT, 6, 0,
+		ak7755_clkset_event, SND_SOC_DAPM_POST_PMU ),
+	SND_SOC_DAPM_ADC_E("ADC Right", "NULL", AK7755_CE_POWER_MANAGEMENT, 7, 0,
+		ak7755_clkset_event, SND_SOC_DAPM_POST_PMU ),
+	SND_SOC_DAPM_ADC_E("ADC2 Left", "NULL", AK7755_CE_POWER_MANAGEMENT, 5, 0,
+		ak7755_clkset_event, SND_SOC_DAPM_POST_PMU ),
+#endif
+	SND_SOC_DAPM_DAC_E("DAC Left", "NULL", AK7755_CE_POWER_MANAGEMENT, 0, 0,
+		ak7755_clkset_event, SND_SOC_DAPM_POST_PMU ),
+	SND_SOC_DAPM_DAC_E("DAC Right", "NULL", AK7755_CE_POWER_MANAGEMENT, 1, 0,
+		ak7755_clkset_event, SND_SOC_DAPM_POST_PMU ),
+	SND_SOC_DAPM_SUPPLY("CLOCK", AK7755_C1_CLOCK_SETTING2, 0, 0,
+		ak7755_clock_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+
+// Analog Output
+	SND_SOC_DAPM_OUTPUT("Line Out1"),
+	SND_SOC_DAPM_OUTPUT("Line Out2"),
+	SND_SOC_DAPM_OUTPUT("Line Out3"),
+
+	SND_SOC_DAPM_MIXER("LineOut Amp3 Mixer", AK7755_CE_POWER_MANAGEMENT, 4, 0,
+			&ak7755_lo3sw_mixer_controls[0], ARRAY_SIZE(ak7755_lo3sw_mixer_controls)),
+//	SND_SOC_DAPM_MUX("LineOut Amp2", AK7755_CE_POWER_MANAGEMENT, 3, 0, &ak7755_pmlo2_mux_control),
+//	SND_SOC_DAPM_MUX("LineOut Amp1", AK7755_CE_POWER_MANAGEMENT, 2, 0, &ak7755_pmlo1_mux_control),
+
+	SND_SOC_DAPM_MUX("LineOut Amp1", SND_SOC_NOPM, 0, 0,	&ak7755_pmlo1_mux_control),
+	SND_SOC_DAPM_MUX("LineOut Amp2", SND_SOC_NOPM, 0, 0,	&ak7755_pmlo2_mux_control),
+
+// Analog Input
+	SND_SOC_DAPM_INPUT("LIN"),
+	SND_SOC_DAPM_INPUT("IN1"),
+	SND_SOC_DAPM_INPUT("IN2"),
+	SND_SOC_DAPM_INPUT("IN3"),
+	SND_SOC_DAPM_INPUT("IN4"),
+	SND_SOC_DAPM_INPUT("INPN1"),
+	SND_SOC_DAPM_INPUT("INPN2"),
+
+	SND_SOC_DAPM_PGA("LineIn Amp", AK7755_CF_RESET_POWER_SETTING, 5, 0, NULL, 0),
+	SND_SOC_DAPM_MUX("RIN MUX", SND_SOC_NOPM, 0, 0,	&ak7755_rin_mux_control),
+	SND_SOC_DAPM_MUX("LIN MUX", SND_SOC_NOPM, 0, 0,	&ak7755_lin_mux_control),
+	SND_SOC_DAPM_VIRT_MUX("DSPIN SDOUTAD2", SND_SOC_NOPM, 0, 0, &ak7755_dspinad2_control),
+	SND_SOC_DAPM_VIRT_MUX("DSPIN SDOUTAD", SND_SOC_NOPM, 0, 0, &ak7755_dspinad_control),
+
+// Digital Input/Output
+	SND_SOC_DAPM_AIF_IN("SDIN1", "Playback", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("SDIN2", "Playback", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("SDOUT1", "Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("SDOUT2", "Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("SDOUT3", "Capture", 0, SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_SWITCH("SDOUT3 Enable", SND_SOC_NOPM, 0, 0,
+		&ak7755_out3e_control),
+	SND_SOC_DAPM_SWITCH("SDOUT2 Enable", SND_SOC_NOPM, 0, 0,
+		&ak7755_out2e_control),
+	SND_SOC_DAPM_SWITCH("SDOUT1 Enable", SND_SOC_NOPM, 0, 0,
+		&ak7755_out1e_control),
+
+	SND_SOC_DAPM_PGA("SDOUTAD", SND_SOC_NOPM, 0, 0, NULL, 0),		//ADC's Output
+	SND_SOC_DAPM_PGA("SDOUTAD2", SND_SOC_NOPM, 0, 0, NULL, 0),		//ADC2's Output
+	SND_SOC_DAPM_PGA("DSP", AK7755_CF_RESET_POWER_SETTING, 2, 0, NULL, 0),
+
+	SND_SOC_DAPM_AIF_IN("DSP GP0", NULL, 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("DSP GP1", NULL, 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("EEST", NULL, 0, SND_SOC_NOPM, 0, 0),
+
+// Multiplexer (selects 1 analog signal from many inputs) & Mixer
+	SND_SOC_DAPM_MUX("SDOUT3 MUX", SND_SOC_NOPM, 0, 0, &ak7755_seldo3_mux_control),
+	SND_SOC_DAPM_MUX("SDOUT2 MUX", SND_SOC_NOPM, 0, 0, &ak7755_seldo2_mux_control),
+	SND_SOC_DAPM_MUX("SDOUT1 MUX", SND_SOC_NOPM, 0, 0, &ak7755_seldo1_mux_control),
+	SND_SOC_DAPM_MUX("DAC MUX", SND_SOC_NOPM, 0, 0, &ak7755_seldai_mux_control),
+	SND_SOC_DAPM_VIRT_MUX("SELMIX DSP", SND_SOC_NOPM, 0, 0, &ak7755_dsp_selmix_control),
+	SND_SOC_DAPM_VIRT_MUX("SELMIX AD2", SND_SOC_NOPM, 0, 0, &ak7755_sdoutad2_selmix_control),
+	SND_SOC_DAPM_VIRT_MUX("SELMIX AD", SND_SOC_NOPM, 0, 0, &ak7755_sdoutad_selmix_control),
+	SND_SOC_DAPM_PGA("SELMIX Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+};
+
+static const struct snd_soc_dapm_route ak7755_intercon[] =
+{
+
+#ifdef DIGITAL_MIC
+	{"DMIC1 Left", "NULL", "CLOCK"},
+	{"DMIC1 Right", "NULL", "CLOCK"},
+	{"DMIC2 Left", "NULL", "CLOCK"},
+	{"DMIC2 Right", "NULL", "CLOCK"},
+
+	{"DMICIN1", "NULL", "DMIC1 CLK"},
+	{"DMICIN2", "NULL", "DMIC2 CLK"},
+	{"DMIC1 Left", "NULL", "DMICIN1"},
+	{"DMIC1 Right", "NULL", "DMICIN1"},
+	{"DMIC2 Left", "NULL", "DMICIN2"},
+	{"DMIC2 Right", "NULL", "DMICIN2"},
+	{"SDOUTAD", "NULL", "DMIC1 Left"},
+	{"SDOUTAD", "NULL", "DMIC1 Right"},
+	{"SDOUTAD2", "NULL", "DMIC2 Left"},
+	{"SDOUTAD2", "NULL", "DMIC2 Right"},
+#else
+	{"ADC Left", "NULL", "CLOCK"},
+	{"ADC Right", "NULL", "CLOCK"},
+	{"ADC2 Left", "NULL", "CLOCK"},
+
+	{"LineIn Amp", "NULL", "LIN"},
+	{"ADC2 Left", "NULL", "LineIn Amp"},
+	{"SDOUTAD2", "NULL", "ADC2 Left"},
+
+	{"LIN MUX", "IN1", "IN1"},
+	{"LIN MUX", "IN2", "IN2"},
+	{"LIN MUX", "INPN1", "INPN1"},
+	{"RIN MUX", "IN3", "IN3"},
+	{"RIN MUX", "IN4", "IN4"},
+	{"RIN MUX", "INPN2", "INPN2"},
+	{"ADC Left", "NULL", "LIN MUX"},
+	{"ADC Right", "NULL", "RIN MUX"},
+	{"SDOUTAD", "NULL", "ADC Left"},
+	{"SDOUTAD", "NULL", "ADC Right"},
+#endif
+
+	{"DAC Left", "NULL", "CLOCK"},
+	{"DAC Right", "NULL", "CLOCK"},
+	{"DSP", "NULL", "CLOCK"},
+
+	{"DSP", "NULL", "SDIN1"},
+	{"DSP", "NULL", "SDIN2"},
+
+	{"DSPIN SDOUTAD", "On", "SDOUTAD"},
+	{"DSPIN SDOUTAD2", "On", "SDOUTAD2"},
+	{"DSP", "NULL", "DSPIN SDOUTAD"},
+	{"DSP", "NULL", "DSPIN SDOUTAD2"},
+
+	{"SELMIX AD", "On", "SDOUTAD"},
+	{"SELMIX AD2", "On", "SDOUTAD2"},
+	{"SELMIX DSP", "On", "DSP"},
+	{"SELMIX Mixer", "NULL", "SELMIX AD"},
+	{"SELMIX Mixer", "NULL", "SELMIX AD2"},
+	{"SELMIX Mixer", "NULL", "SELMIX DSP"},
+	{"DAC MUX", "MIXOUT", "SELMIX Mixer"},
+	{"DAC MUX", "DSP", "DSP"},
+	{"DAC MUX", "SDIN2", "SDIN2"},
+	{"DAC MUX", "SDIN1", "SDIN1"},
+
+	{"DAC Left", "NULL", "DAC MUX"},
+	{"DAC Right", "NULL", "DAC MUX"},
+
+	{"LineOut Amp1", "On", "DAC Left"},
+	{"LineOut Amp2", "On", "DAC Right"},
+	{"Line Out1", "NULL", "LineOut Amp1"},
+	{"Line Out2", "NULL", "LineOut Amp2"},
+	{"LineOut Amp3 Mixer", "LOSW1", "DAC Left"},
+	{"LineOut Amp3 Mixer", "LOSW2", "DAC Right"},
+#ifndef DIGITAL_MIC		//LOSW3 used only Analog MIC
+	{"LineOut Amp3 Mixer", "LOSW3", "LineIn Amp"},
+#endif
+	{"Line Out3", "NULL", "LineOut Amp3 Mixer"},
+
+	{"SDOUT1 MUX", "DSP", "DSP"},
+	{"SDOUT1 MUX", "DSP GP0", "DSP GP0"},
+	{"SDOUT1 MUX", "SDIN1", "SDIN1"},
+	{"SDOUT1 MUX", "SDOUTAD", "SDOUTAD"},
+	{"SDOUT1 MUX", "EEST", "EEST"},
+	{"SDOUT1 MUX", "SDOUTAD2", "SDOUTAD2"},
+
+	{"SDOUT2 MUX", "DSP", "DSP"},
+	{"SDOUT2 MUX", "DSP GP1", "DSP GP1"},
+	{"SDOUT2 MUX", "SDIN2", "SDIN2"},
+	{"SDOUT2 MUX", "SDOUTAD2", "SDOUTAD2"},
+
+	{"SDOUT3 MUX", "DSP DOUT3", "DSP"},
+	{"SDOUT3 MUX", "MIXOUT", "DAC MUX"},
+	{"SDOUT3 MUX", "DSP DOUT4", "DSP"},
+	{"SDOUT3 MUX", "SDOUTAD2", "SDOUTAD2"},
+
+	{"SDOUT1 Enable", "Switch", "SDOUT1 MUX"},
+	{"SDOUT2 Enable", "Switch", "SDOUT2 MUX"},
+	{"SDOUT3 Enable", "Switch", "SDOUT3 MUX"},
+
+	{"SDOUT1", "NULL", "SDOUT1 Enable"},
+	{"SDOUT2", "NULL", "SDOUT2 Enable"},
+	{"SDOUT3", "NULL", "SDOUT3 Enable"},
+
+};
+
+static int ak7755_hw_params_set(struct snd_soc_codec *codec, int nfs)
+{
+	u8 	fs;
+
+	akdbgprt("\t[AK7755] %s(%d)\n",__FUNCTION__,__LINE__);
+
+	fs = snd_soc_read(codec, AK7755_C0_CLOCK_SETTING1);
+	fs &= ~AK7755_FS;
+
+	switch (nfs) {
+	case 8000:
+		fs |= AK7755_FS_8KHZ;
+		break;
+	case 11025:
+		fs |= AK7755_FS_12KHZ;
+		break;
+	case 16000:
+		fs |= AK7755_FS_16KHZ;
+		break;
+	case 22050:
+		fs |= AK7755_FS_24KHZ;
+		break;
+	case 32000:
+		fs |= AK7755_FS_32KHZ;
+		break;
+	case 44100:
+	case 48000:
+		fs |= AK7755_FS_48KHZ;
+		break;
+	case 88200:
+	case 96000:
+		fs |= AK7755_FS_96KHZ;
+		break;
+	default:
+		return -EINVAL;
+	}
+	snd_soc_write(codec, AK7755_C0_CLOCK_SETTING1, fs);
+	ak7755_set_status(RUN);
+	if (aec == 1){
+		snd_soc_update_bits(codec, AK7755_CE_POWER_MANAGEMENT, 0x80, 0x0);		//If aec is enable, only CH-L enable by DSP
+	}
+
+	return 0;
+}
+
+static int ak7755_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params,
+		struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+	u8 format;
+
+	format = snd_soc_read(codec, AK7755_C2_SERIAL_DATA_FORMAT);
+	format &= ~AK7755_LRIF;
+	if (aec ==0){
+		switch (params_format(params)) {
+			case SNDRV_PCM_FORMAT_S16_LE:
+				ak7755->bickfs = (AK7755_AIF_BICK32 >> 4);
+				break;
+			case SNDRV_PCM_FORMAT_S24_LE:
+				ak7755->bickfs = (AK7755_AIF_BICK48 >> 4);
+				break;
+			case SNDRV_PCM_FORMAT_S32_LE:
+				ak7755->bickfs = (AK7755_AIF_BICK64 >> 4);
+				break;
+			default:
+				dev_err(codec->dev, "Can not support the format");
+				return -EINVAL;
+		}
+	}else{
+		ak7755->bickfs = (AK7755_AIF_BICK64 >> 4);
+	}
+	ak7755->fs = params_rate(params);
+	ak7755_hw_params_set(codec, ak7755->fs);
+
+	snd_soc_update_bits(codec, AK7755_C1_CLOCK_SETTING2, 0x30, (ak7755->bickfs << 4));
+	if ( ak7755->bickfs < 3 ) {
+		format &= 0x7F;
+	} else {
+		format |= 0x80;
+		format &= 0xF3;
+		format |=  AK7755_TDM_INPUT_SOURCE;
+	}
+
+	switch (ak7755->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		format |= AK7755_LRIF_I2S_MODE;
+		if ( ak7755->bickfs == 2 ) {   // 32fs
+			snd_soc_update_bits(codec, AK7755_C3_DELAY_RAM_DSP_IO, 0xF0, 0xf0); 	// DIF2, DOF2
+			snd_soc_update_bits(codec, AK7755_C6_DAC_DEM_SETTING, 0x37, 0x33);		//DIF, DIFDA
+			snd_soc_update_bits(codec, AK7755_C7_DSP_OUT_SETTING, 0xFF, 0xf3); 		//DOF
+		}else {
+			snd_soc_update_bits(codec, AK7755_C3_DELAY_RAM_DSP_IO, 0xF0, 0x0); 	// DIF2, DOF2
+			snd_soc_update_bits(codec, AK7755_C6_DAC_DEM_SETTING, 0x37, 0x0);	//DIF, DIFDA
+			snd_soc_update_bits(codec, AK7755_C7_DSP_OUT_SETTING, 0xFF, 0x0); 	//DOF
+		}
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		format |= AK7755_LRIF_MSB_MODE;
+		if ( ak7755->bickfs == 2 ) {   // 32fs
+			snd_soc_update_bits(codec, AK7755_C3_DELAY_RAM_DSP_IO, 0xF0, 0xF0); 	// DIF2, DOF2
+			snd_soc_update_bits(codec, AK7755_C6_DAC_DEM_SETTING, 0x37, 0x33);	//DIF, DIFDA
+			snd_soc_update_bits(codec, AK7755_C7_DSP_OUT_SETTING, 0xFF, 0xF3); 	//DOF
+		}
+		else {
+			snd_soc_update_bits(codec, AK7755_C3_DELAY_RAM_DSP_IO, 0xF0, 0x0); 	// DIF2, DOF2
+			snd_soc_update_bits(codec, AK7755_C6_DAC_DEM_SETTING, 0x37, 0x0);	//DIF, DIFDA
+			snd_soc_update_bits(codec, AK7755_C7_DSP_OUT_SETTING, 0xFF, 0x0); 	//DOF
+		}
+		break;
+/*
+	case SND_SOC_DAIFMT_PCM_SHORT:
+		format &= 0xBF;							//BCKP Clear
+		format |= (AK7755_BCKP_BIT << 6);		//BCKP set
+		format |= AK7755_LRIF_PCM_SHORT_MODE;
+		break;
+	case SND_SOC_DAIFMT_PCM_LONG:
+		format &= 0xBF;							//BCKP lear
+		format |= (AK7755_BCKP_BIT << 6);		//BCKP set
+		format |= AK7755_LRIF_PCM_LONG_MODE;
+		break;
+*/
+	default:
+		return -EINVAL;
+	}
+
+	snd_soc_write(codec, AK7755_C2_SERIAL_DATA_FORMAT, format);
+	return 0;
+}
+
+static int ak7755_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
+		unsigned int freq, int dir)
+{
+	akdbgprt("\t[AK7755] %s(%d)\n",__FUNCTION__,__LINE__);
+
+	ak7755_data->rclk = freq;
+
+	return 0;
+}
+
+static int ak7755_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+
+	struct snd_soc_codec *codec = dai->codec;
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);  // '15/06/15
+	u8 mode, mode2;
+
+	akdbgprt("\t[AK7755] %s(%d)\n",__FUNCTION__,__LINE__);
+
+	/* set master/slave audio interface */
+	mode = snd_soc_read(codec, AK7755_C0_CLOCK_SETTING1);//CKM2-0(M/S)
+	mode &= ~AK7755_M_S;
+	mode2 = snd_soc_read(codec, AK7755_CA_CLK_SDOUT_SETTING);//BICKOE,LRCKOE
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+        case SND_SOC_DAIFMT_CBS_CFS:
+	#ifdef CLOCK_MODE_BICK
+	    	mode |= AK7755_M_S_3;//CKM mode = 3(Slave, BICK)
+	#else
+	    	mode |= AK7755_M_S_2;//CKM mode = 2(Slave, XTI=12.288MHz)
+	#endif
+          	mode2 &= ~AK7755_BICK_LRCK;//BICK = LRCK = 0
+            break;
+        case SND_SOC_DAIFMT_CBM_CFM:
+	#ifdef CLOCK_MODE_18_432
+	    	mode |= AK7755_M_S_1;//CKM mode = 1(Master, XTI=18.432MHz)
+	#else
+	    	mode |= AK7755_M_S_0;//CKM mode = 0(Master, XTI=12.288MHz)
+	#endif
+		mode2 |= AK7755_BICK_LRCK;//BICK = LRCK = 1
+            break;
+        case SND_SOC_DAIFMT_CBS_CFM:
+        case SND_SOC_DAIFMT_CBM_CFS:
+        default:
+            dev_err(codec->dev, "Clock mode unsupported");
+           return -EINVAL;
+	}
+
+	ak7755->fmt = fmt;
+	/* set mode */
+	snd_soc_write(codec, AK7755_C0_CLOCK_SETTING1, mode);
+	snd_soc_write(codec, AK7755_CA_CLK_SDOUT_SETTING, mode2);
+	return 0;
+}
+
+static int ak7755_volatile(struct snd_soc_codec *codec, unsigned int reg)
+{
+	int	ret;
+
+	switch (reg) {
+//		case :
+//			ret = 1;
+		default:
+			ret = 0;
+			break;
+	}
+	return ret;
+}
+
+static int ak7755_readable(struct snd_soc_codec *codec, unsigned int reg)
+{
+	return ak7755_access_masks[reg].readable != 0;
+
+}
+
+static int ak7755_reads(u8 *tx, size_t wlen, u8 *rx, size_t rlen)
+{
+	int ret;
+
+	//akdbgprt("*****[AK7755] %s tx[0]=%x, %d, %d\n",__FUNCTION__, tx[0],wlen,rlen);
+	if (ak7755_data->control_type == SND_SOC_SPI) {
+		ret = spi_write_then_read(ak7755_data->spi, tx, wlen, rx, rlen);
+	}
+	else {
+		ret = ak7755_i2c_read( tx, wlen, rx, rlen);
+	}
+
+	return ret;
+
+}
+
+static int ak7755_writes(const u8 *tx, size_t wlen)
+{
+	int rc;
+
+	akdbgprt("![AK7755W] %s tx[0]=%x tx[1]=%x, len=%d\n",__FUNCTION__, (int)tx[0], (int)tx[1], wlen);
+
+	if (ak7755_data->control_type == SND_SOC_SPI)
+		rc = spi_write_then_read(ak7755_data->spi, tx, wlen, NULL, 0);
+	else
+		rc = i2c_master_send(ak7755_data->i2c, tx, wlen);
+
+	if (rc < 0) {
+		akdbgprt("\t[AK7755] %s error rc = %d\n",__FUNCTION__, rc);
+	}
+
+	return rc;
+}
+
+#ifdef AK7755_CONTIF_DEBUG
+static inline void ak7755_write_reg_cache(struct snd_soc_codec *codec,u16 reg,u16 value)
+{
+    u8 *cache = codec->reg_cache;
+    //BUG_ON(reg_index > ARRAY_SIZE(ak7755_reg));
+
+    if (reg < ARRAY_SIZE(ak7755_reg))
+    	cache[reg] = (u8)value;
+}
+
+/*
+* Read ak7755 register cache
+ */
+static inline u32 ak7755_read_reg_cache(struct snd_soc_codec *codec, u16 reg)
+{
+    u8 *cache = codec->reg_cache;
+    BUG_ON(reg > ARRAY_SIZE(ak7755_reg));
+    return (u32)cache[reg];
+}
+
+
+static unsigned int ak7755_i2c_read(
+u8 *reg,
+int reglen,
+u8 *data,
+int datalen)
+{
+	struct i2c_msg xfer[2];
+	int ret;
+	struct i2c_client *client = ak7755_data->i2c;
+
+	/* Write register */
+	xfer[0].addr = client->addr;
+	xfer[0].flags = 0;
+	xfer[0].len = reglen;
+	xfer[0].buf = reg;
+
+	/* Read data */
+	xfer[1].addr = client->addr;
+	xfer[1].flags = I2C_M_RD;
+	xfer[1].len = datalen;
+	xfer[1].buf = data;
+
+	ret = i2c_transfer(client->adapter, xfer, 2);
+
+//	akdbgprt("*****[AK7755] %s (%x,%x)\n",__FUNCTION__, (int)reg[0], (int)data[0]);
+
+	if (ret == 2)
+		return 0;
+	else if (ret < 0)
+		return -ret;
+	else
+		return -EIO;
+}
+
+unsigned int ak7755_reg_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	unsigned char tx[1], rx[1];
+	int	wlen, rlen;
+	int ret;
+	unsigned int rdata;
+
+	wlen = 1;
+	rlen = 1;
+	tx[0] = (unsigned char)(0x7F & reg);
+
+	//akdbgprt("*****[AK7755] %s reg = %0x, tx[0]=%0x, %d, %d\n",__FUNCTION__, reg,  tx[0],wlen,rlen);
+
+	if (ak7755_data->control_type == SND_SOC_SPI) {
+		ret = spi_write_then_read(ak7755_data->spi, tx, wlen, rx, rlen);
+	}
+	else {
+		ret = ak7755_i2c_read(tx, wlen, rx, rlen);
+	}
+
+	if (ret < 0) {
+		akdbgprt("\t[AK7755] %s error ret = %d\n",__FUNCTION__, ret);
+		rdata = -EIO;
+		return rdata;
+	}
+	else {
+		rdata = (unsigned int)rx[0];
+		if (ak7755_read_reg_cache(codec, reg) != rdata)
+			ak7755_write_reg_cache(codec, reg, rdata);
+	}
+	akdbgprt("\t[AK7755] %s addr, read data =(%x, %x)\n",__FUNCTION__, reg, (int)rdata);
+
+	return rdata;
+}
+
+
+int ak7755_reg_write(struct snd_soc_codec *codec, unsigned int reg, unsigned int value)
+{
+	unsigned char tx[3];
+	int	wlen;
+	int ret;
+
+	wlen = 2;
+	tx[0] = reg;
+	tx[1] = value;
+
+	ret = ak7755_writes(tx, wlen);
+
+	if (ret >=0) {
+		ak7755_write_reg_cache(codec, reg, value);
+	}
+
+	return ret;
+}
+
+
+/*
+ * Write with Mask to  AK7755 register space
+ */
+// ak7755_writeMask() => snd_soc_update_bits()  // '16/01/13
+
+#endif
+
+
+static int crc_read(void)
+{
+	int rc;
+	u8	tx[1], rx[2];
+
+	tx[0] = CRC_COMMAND_READ_RESULT;
+
+	rc =  ak7755_reads(tx, 1, rx, 2);
+
+	return (rc < 0) ? rc : ((rx[0] << 8) + rx[1]);
+}
+
+static int ak7755_set_status(enum ak7755_status status)
+{
+
+	switch (status) {
+	case RUN:
+		snd_soc_update_bits(ak7755_data->codec, AK7755_C1_CLOCK_SETTING2, 0x1, 0x1);  // CKRESETN bit = 1
+		mdelay(10);
+		snd_soc_update_bits(ak7755_data->codec, AK7755_CF_RESET_POWER_SETTING, 0xd, 0xc);  // CRESETN bit = DSPRESETN = 1;
+		mdelay(10);
+		break;
+	case DOWNLOAD:
+		snd_soc_update_bits(ak7755_data->codec, AK7755_CF_RESET_POWER_SETTING, 0x1, 0x1);  // DLRDY bit = 1
+		mdelay(10);
+		break;
+	case STANDBY:
+		snd_soc_update_bits(ak7755_data->codec, AK7755_C1_CLOCK_SETTING2, 0x1, 0x1);  // CKRESETN bit = 1
+		mdelay(10);
+		snd_soc_update_bits(ak7755_data->codec, AK7755_CF_RESET_POWER_SETTING, 0xc, 0x0);  // CRESETN bit = DSPRESETN = 0;
+		mdelay(10);
+		break;
+	case SUSPEND:
+	case POWERDOWN:
+		snd_soc_update_bits(ak7755_data->codec, AK7755_CF_RESET_POWER_SETTING, 0x3f, 0x0);
+		snd_soc_update_bits(ak7755_data->codec, AK7755_CE_POWER_MANAGEMENT, 0xFF, 0x0);
+		snd_soc_update_bits(ak7755_data->codec, AK7755_C1_CLOCK_SETTING2, 0x0, 0x0);
+		mdelay(10);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ak7755_data->status = status;
+
+	return 0;
+}
+
+static int ak7755_ram_download(const u8 *tx_ram, u64 num, u16 crc)
+{
+	int rc;
+	u16	read_crc;
+	u8 tx[2];
+
+	akdbgprt("\t[AK7755] %s num=%ld\n",__FUNCTION__, (long int)num);
+	if (fast_boot == 0)
+		ak7755_set_status(DOWNLOAD);
+
+	rc = ak7755_writes(tx_ram, num);
+	if (rc < 0) {
+		printk("%s: RAM Write Error! RAM size = %lld \n", __func__, num);
+		if ( fast_boot == 1 ) {
+			tx[0] = AK7755_CF_RESET_POWER_SETTING;
+			tx[1] = 0x0c;
+			ak7755_writes(tx, 2);
+		} else {
+			snd_soc_update_bits(ak7755_data->codec, AK7755_CF_RESET_POWER_SETTING, 0x0d,0x0c);  // system rest release
+		}
+		return rc;
+	}
+
+	if ( ( crc != 0 ) && (rc >= 0) )  {
+		read_crc = crc_read();
+		akdbgprt("\t[AK7755] %s CRC Cal=%x Read=%x\n",__FUNCTION__, (int)crc,(int)read_crc);
+
+		if ( read_crc == crc ) rc = 0;
+		else rc = 1;
+	}
+	if ( fast_boot == 0 )
+		ak7755_set_status(STANDBY);
+
+	return rc;
+
+}
+
+static int calc_CRC(int length, u8 *data )
+{
+
+#define CRC16_CCITT (0x1021)
+
+	unsigned short crc = 0x0000;
+	int i, j;
+
+	for ( i = 0; i < length; i++ ) {
+		crc ^= *data++ << 8;
+		for ( j = 0; j < 8; j++) {
+			if ( crc & 0x8000) {
+				crc <<= 1;
+				crc ^= CRC16_CCITT;
+			}
+			else {
+				crc <<= 1;
+			}
+		}
+	}
+
+	akdbgprt("[AK7755] %s CRC=%x\n",__FUNCTION__, crc);
+
+	return crc;
+}
+
+static int ak7755_write_ram(
+int	 nPCRam,  // 0 : PRAM, 1 : CRAM, 2:  OFREG. 3: ACRAM
+u8 	*upRam,
+int	 nWSize)
+{
+	int n, ret;
+	int	wCRC;
+
+	switch(nPCRam) {
+		case RAMTYPE_PRAM:
+			if (  nWSize > TOTAL_NUM_OF_PRAM_MAX ) {
+				printk("%s: PRAM Write size is over! \n", __func__);
+				return(-1);
+			}
+			break;
+		case RAMTYPE_CRAM:
+			if (  nWSize > TOTAL_NUM_OF_CRAM_MAX ) {
+				printk("%s: CRAM Write size is over! \n", __func__);
+				return(-1);
+			}
+			break;
+		case RAMTYPE_OFREG:
+			if (  nWSize > TOTAL_NUM_OF_OFREG_MAX ) {
+				printk("%s: OFREG Write size is over! \n", __func__);
+				return(-1);
+			}
+			break;
+		case RAMTYPE_ACRAM:
+			if (  nWSize > TOTAL_NUM_OF_ACRAM_MAX ) {
+				printk("%s: ACRAM Write size is over! \n", __func__);
+				return(-1);
+			}
+			break;
+		default:
+			break;
+	}
+
+	wCRC = calc_CRC(nWSize, upRam);
+
+	n = MAX_LOOP_TIMES;
+	do {
+		ret = ak7755_ram_download(upRam, nWSize, wCRC);
+		if ( ret >= 0 ) break;
+		printk("%s: RAM Write Error! RAM No = %d \n", __func__, nPCRam);
+		n--;
+	} while ( n > 0 );
+
+	if ( ret < 0 ) {
+		printk("%s: RAM Write Error! RAM No = %d \n", __func__, nPCRam);
+		return(-1);
+	}
+
+	return(0);
+
+}
+
+static int ak7755_firmware_write_ram(u16 mode, u16 cmd)
+{
+	int ret = 0;
+	int nNumMode, nMaxLen;
+	int nRamSize;
+	u8  *ram_basic;
+	const struct firmware *fw;
+	u8  *fwdn;
+	char szFileName[32];
+
+	akdbgprt("[AK7755] %s mode=%d, cmd=%d\n",__FUNCTION__, mode, cmd);
+
+	switch(mode) {
+		case RAMTYPE_PRAM:
+			nNumMode = sizeof(ak7755_firmware_pram) / sizeof(ak7755_firmware_pram[0]);
+			break;
+		case RAMTYPE_CRAM:
+			nNumMode = sizeof(ak7755_firmware_cram) / sizeof(ak7755_firmware_cram[0]);
+			break;
+		case RAMTYPE_OFREG:
+			nNumMode = sizeof(ak7755_firmware_ofreg) / sizeof(ak7755_firmware_ofreg[0]);
+			break;
+		case RAMTYPE_ACRAM:
+			nNumMode = sizeof(ak7755_firmware_acram) / sizeof(ak7755_firmware_acram[0]);
+			break;
+		default:
+			akdbgprt("[AK7755] %s mode Error=%d\n",__FUNCTION__, mode);
+			return( -EINVAL);
+	}
+
+	if ( cmd == 0 ) return(0);
+
+	if ( cmd >= nNumMode ) {
+		pr_err("%s: invalid command %d\n", __func__, cmd);
+		return( -EINVAL);
+	}
+
+	if ( cmd == 1 ) {
+		switch(mode) {
+			case RAMTYPE_PRAM:
+				if (aec == 0){
+					ram_basic = ak7755_pram_basic;
+					nRamSize = sizeof(ak7755_pram_basic);
+				}else{
+					ram_basic = ak7755_pram_aec;
+					nRamSize = sizeof(ak7755_pram_aec);
+				}
+				break;
+			case RAMTYPE_CRAM:
+				if (aec == 0){
+					ram_basic = ak7755_cram_basic;
+					nRamSize = sizeof(ak7755_cram_basic);
+				}else{
+					ram_basic = ak7755_cram_aec;
+					nRamSize = sizeof(ak7755_cram_aec);
+				}
+				break;
+			case RAMTYPE_OFREG:
+				ram_basic = ak7755_ofreg_basic;
+				nRamSize = sizeof(ak7755_ofreg_basic);
+				break;
+			case RAMTYPE_ACRAM:
+				ram_basic = ak7755_acram_basic;
+				nRamSize = sizeof(ak7755_acram_basic);
+				break;
+			default:
+				return( -EINVAL);
+		}
+		ret = ak7755_write_ram((int)mode, ram_basic, nRamSize);
+	} else {
+		switch(mode) {
+			case RAMTYPE_PRAM:
+				sprintf(szFileName, "ak7755_pram_%s.bin", ak7755_firmware_pram[cmd]);
+				nMaxLen = TOTAL_NUM_OF_PRAM_MAX;
+				break;
+			case RAMTYPE_CRAM:
+				sprintf(szFileName, "ak7755_cram_%s.bin", ak7755_firmware_cram[cmd]);
+				nMaxLen = TOTAL_NUM_OF_CRAM_MAX;
+				break;
+			case RAMTYPE_OFREG:
+				sprintf(szFileName, "ak7755_ofreg_%s.bin", ak7755_firmware_cram[cmd]);
+				nMaxLen = TOTAL_NUM_OF_OFREG_MAX;
+				break;
+			case RAMTYPE_ACRAM:
+				sprintf(szFileName, "ak7755_acram_%s.bin", ak7755_firmware_cram[cmd]);
+				nMaxLen = TOTAL_NUM_OF_ACRAM_MAX;
+				break;
+			default:
+				return( -EINVAL);
+		}
+
+		if (ak7755_data->control_type == SND_SOC_SPI) {
+			ret = request_firmware(&fw, szFileName, &(ak7755_data->spi->dev));
+		}
+		else {
+			ret = request_firmware(&fw, szFileName, &(ak7755_data->i2c->dev));
+		}
+		if (ret) {
+			akdbgprt("[AK7755] %s could not load firmware=%d\n", szFileName, ret);
+			return -EINVAL;
+		}
+
+		//printk("[AK7755] %s name=%s size=%d\n",__FUNCTION__, szFileName, fw->size);
+		if ( fw->size > nMaxLen ) {
+			akdbgprt("[AK7755] %s RAM Size Error : %d\n",__FUNCTION__, fw->size);
+			return -ENOMEM;
+		}
+
+		fwdn = kmalloc((unsigned long)fw->size, GFP_KERNEL);
+		if (fwdn == NULL) {
+			printk(KERN_ERR "failed to buffer vmalloc: %d\n", fw->size);
+			return -ENOMEM;
+		}
+
+		memcpy((void *)fwdn, fw->data, fw->size);
+
+		ret = ak7755_write_ram((int)mode, (u8 *)fwdn, (fw->size));
+		//printk("ak7755 download ram is ok, ret = %d\n", ret);
+
+		kfree(fwdn);
+	}
+
+
+	return ret;
+}
+
+static int ak7755_write_cram(
+int addr,
+int len,
+unsigned char *cram_data)
+{
+	int i, n, ret;
+	int nDSPRun;
+	unsigned char tx[51];
+
+	akdbgprt("[AK7755] %s addr=%d, len=%d\n",__FUNCTION__, addr, len);
+
+	if ( len > 48 ) {
+		akdbgprt("[AK7755] %s Length over!\n",__FUNCTION__);
+		return(-1);
+	}
+
+	nDSPRun = snd_soc_read(ak7755_data->codec, AK7755_CF_RESET_POWER_SETTING);
+
+	if ( nDSPRun & 0x4 ) {
+		tx[0] = 0x80 + (unsigned char)((len / 3) - 1);
+		tx[1] = (unsigned char)(0xFF & (addr >> 8));
+		tx[2] = (unsigned char)(0xFF & addr);
+	}
+	else {
+		ak7755_set_status(DOWNLOAD);
+		tx[0] = 0xB4;
+		tx[1] = (unsigned char)(0xFF & (addr >> 8));
+		tx[2] = (unsigned char)(0xFF & addr);
+	}
+
+	n = 3;
+	for ( i = 0 ; i < len; i ++ ) {
+		tx[n++] = cram_data[i];
+	}
+
+	ret = ak7755_writes(tx, n);
+
+	if ( nDSPRun & 0x4 ) {
+		tx[0] = 0xA4;
+		tx[1] = 0;
+		tx[2] = 0;
+		ret = ak7755_writes(tx, 3);
+	}
+	else {
+		snd_soc_write(ak7755_data->codec, AK7755_CF_RESET_POWER_SETTING, nDSPRun);
+	}
+
+
+	return ret;
+
+}
+
+static unsigned long ak7755_readMIR(
+int nMIRNo)
+{
+	unsigned char tx[1];
+	unsigned char rx[4];
+	unsigned long dwMIRData;
+
+	if ( ( nMIRNo < 1 )  ||  ( nMIRNo > 4 ) ) return(-1);
+
+	tx[0] = (unsigned char)(0x74 + (2 * nMIRNo));
+
+	ak7755_reads(tx, 1, rx, 4);
+
+	dwMIRData = ((0xFF & (unsigned long)rx[0]) << 20) + ((0xFF & (unsigned long)rx[1]) << 12) +
+                       ((0xFF & (unsigned long)rx[2]) << 4) + ((0xFF & (unsigned long)rx[3]) >> 4);
+
+
+	return(dwMIRData);
+
+}
+
+static int ak7755_reg_cmd(REG_CMD *reg_param, int len)
+{
+	int i;
+	int rc;
+	int  addr, value;
+
+	akdbgprt("*****[AK7755] %s len = %d\n",__FUNCTION__, len);
+
+	rc = 0;
+	for (i = 0; i < len; i++) {
+		addr = (int)(reg_param[i].addr);
+		value = (int)(reg_param[i].data);
+
+		if ( addr != 0xFF ) {
+			rc = snd_soc_write(ak7755_data->codec, addr, value);
+			if (rc < 0) {
+				break;
+			}
+		}
+		else {
+			mdelay(value);
+		}
+	}
+
+	if (rc != 0 ) rc = 0;
+
+	return(rc);
+
+}
+
+#ifdef AK7755_IO_CONTROL
+static long ak7755_ioctl(struct file *file, unsigned int cmd, unsigned long args)
+{
+	struct ak7755_priv *ak7755 = (struct ak7755_priv*)file->private_data;
+	struct ak7755_wreg_handle ak7755_wreg;
+	struct ak7755_wcram_handle  ak7755_wcram;
+	struct ak7755_loadram_handle  ak7755_ram;
+	void __user *data = (void __user *)args;
+	int *val = (int *)args;
+	int i;
+	unsigned long dwMIRData;
+	int ret = 0;
+	REG_CMD      regcmd[MAX_WREG];
+	unsigned char cram_data[MAX_WCRAM];
+
+	akdbgprt("*****[AK7755] %s cmd, val=%x, %x\n",__FUNCTION__, cmd, val[0]);
+
+	switch(cmd) {
+	case AK7755_IOCTL_WRITECRAM:
+		if (copy_from_user(&ak7755_wcram, data, sizeof(struct ak7755_wcram_handle)))
+			return -EFAULT;
+		if ( (  ak7755_wcram.len % 3 ) != 0 ) {
+			printk(KERN_ERR "[AK7755] %s CRAM len error\n",__FUNCTION__);
+			return -EFAULT;
+		}
+		if ( ( ak7755_wcram.len < 3 ) || ( ak7755_wcram.len > MAX_WCRAM ) ) {
+			printk(KERN_ERR "[AK7755] %s CRAM len error2\n",__FUNCTION__);
+			return -EFAULT;
+		}
+		for ( i = 0 ; i < ak7755_wcram.len ; i ++ ) {
+			cram_data[i] = ak7755_wcram.cram[i];
+		}
+		ret = ak7755_write_cram(ak7755_wcram.addr, ak7755_wcram.len, cram_data);
+		break;
+	case AK7755_IOCTL_WRITEREG:
+		if (copy_from_user(&ak7755_wreg, data, sizeof(struct ak7755_wreg_handle)))
+			return -EFAULT;
+		if ( ( ak7755_wreg.len < 1 ) || ( ak7755_wreg.len > MAX_WREG ) ) {
+			printk(KERN_ERR "MAXREG ERROR %d\n", ak7755_wreg.len );
+			return -EFAULT;
+		}
+		for ( i = 0 ; i < ak7755_wreg.len; i ++ ) {
+			regcmd[i].addr = ak7755_wreg.regcmd[i].addr;
+			regcmd[i].data = ak7755_wreg.regcmd[i].data;
+		}
+		ak7755_reg_cmd(regcmd, ak7755_wreg.len);
+		break;
+	case AK7755_IOCTL_LOADRAM:
+		if (copy_from_user(&ak7755_ram, data, sizeof(struct ak7755_loadram_handle)))
+			return -EFAULT;
+		ak7755_firmware_write_ram(ak7755_ram.ramtype, ak7755_ram.mode);
+		break;
+	case AK7755_IOCTL_SETSTATUS:
+		ret = ak7755_set_status(val[0]);
+		if (ret < 0) {
+			printk(KERN_ERR "ak7755: set_status error: \n");
+			return ret;
+		}
+		break;
+	case AK7755_IOCTL_GETSTATUS:
+		ret = copy_to_user(data, (const void*)&ak7755->status,
+							(unsigned long)sizeof(unsigned int));
+		if (ret < 0) {
+			printk(KERN_ERR "ak7755: get status error\n");
+			return -EFAULT;
+		}
+		break;
+	case AK7755_IOCTL_SETMIR:
+		ak7755->MIRNo = val[0];
+		if (ret < 0) {
+			printk(KERN_ERR "ak7755: set MIR error\n");
+			return -EFAULT;
+		}
+		break;
+	case AK7755_IOCTL_GETMIR:
+		dwMIRData = ak7755_readMIR(ak7755->MIRNo);
+		ret = copy_to_user(data, (const void*)&dwMIRData,
+							(unsigned long)sizeof(unsigned int));
+		if (ret < 0) {
+			printk(KERN_ERR "ak7755: get status error\n");
+			return -EFAULT;
+		}
+		break;
+
+	default:
+		printk(KERN_ERR "Unknown command required: %d\n", cmd);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int init_ak7755_pd(struct ak7755_priv *data)
+{
+	struct _ak7755_pd_handler *ak7755 = &ak7755_pd_handler;
+
+	if (data == NULL)
+		return -EFAULT;
+
+	mutex_init(&ak7755->lock);
+
+	mutex_lock(&ak7755->lock);
+	ak7755->data = data;
+	mutex_unlock(&ak7755->lock);
+
+	printk("data:%p, ak7755->data:%p\n", data, ak7755->data);
+
+	return 0;
+}
+
+static struct ak7755_priv* get_ak7755_pd(void)
+{
+	struct _ak7755_pd_handler *ak7755 = &ak7755_pd_handler;
+
+	if (ak7755->data == NULL)
+		return NULL;
+
+	mutex_lock(&ak7755->lock);
+	ak7755->ref_count++;
+	mutex_unlock(&ak7755->lock);
+
+	return ak7755->data;
+}
+
+static int rel_ak7755_pd(struct ak7755_priv *data)
+{
+	struct _ak7755_pd_handler *ak7755 = &ak7755_pd_handler;
+
+	if (ak7755->data == NULL)
+		return -EFAULT;
+
+	mutex_lock(&ak7755->lock);
+	ak7755->ref_count--;
+	mutex_unlock(&ak7755->lock);
+
+	data = NULL;
+
+	return 0;
+}
+
+/* AK7755 Misc driver interfaces */
+static int ak7755_open(struct inode *inode, struct file *file)
+{
+	struct ak7755_priv *ak7755;
+
+	ak7755 = get_ak7755_pd();
+	file->private_data = ak7755;
+
+	return 0;
+}
+
+static int ak7755_close(struct inode *inode, struct file *file)
+{
+	struct ak7755_priv *ak7755 = (struct ak7755_priv*)file->private_data;
+
+	rel_ak7755_pd(ak7755);
+
+	return 0;
+}
+
+static const struct file_operations ak7755_fops = {
+	.owner = THIS_MODULE,
+	.open = ak7755_open,
+	.release = ak7755_close,
+	.unlocked_ioctl = ak7755_ioctl,
+};
+
+static struct miscdevice ak7755_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "ak7755-dsp",
+	.fops = &ak7755_fops,
+};
+
+#endif
+
+/*********************************/
+
+// * for AK7755
+static int ak7755_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *codec_dai)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+	int 	ret = 0;
+
+	if(ak7755->amp_gpio > 0) {
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				gpio_direction_output(ak7755->amp_gpio, ak7755->amp_active);
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
+				gpio_direction_output(ak7755->amp_gpio, !ak7755->amp_active);
+			}
+			break;
+		default:
+			break;
+		}
+
+	}
+
+	akdbgprt("\t[AK7755] %s(%d)\n",__FUNCTION__,__LINE__);
+
+	return ret;
+}
+
+static int ak7755_set_bias_level(struct snd_soc_codec *codec,
+		enum snd_soc_bias_level level)
+{
+	akdbgprt("\t[AK7755] %s(%d) level : %d\n",__FUNCTION__,__LINE__, level);
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+		ak7755_set_status(RUN);
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		ak7755_set_status(STANDBY);
+		break;
+	case SND_SOC_BIAS_OFF:
+		ak7755_set_status(POWERDOWN);
+		break;
+	}
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+static int ak7755_set_dai_mute2(struct snd_soc_codec *codec, int mute)
+{
+	int ret = 0;
+	//int ndt;
+
+	//akdbgprt("\t[AK7755] %s mute[%s]\n",__FUNCTION__, mute ? "ON":"OFF");
+
+#if 0
+	if (mute) {	//SMUTE: 1 , MUTE
+		ret = snd_soc_update_bits(codec, AK7755_DA_MUTE_ADRC_ZEROCROSS_SET, 0xE0, 0xE0);
+	}
+	else {
+		ak7755_set_status(RUN);
+		// SMUTE: 0 ,NORMAL operation
+		ret = snd_soc_update_bits(codec, AK7755_DA_MUTE_ADRC_ZEROCROSS_SET, 0xE0, 0x00);
+	}
+
+	ndt = 1021000 / ak7755_data->fs;
+	mdelay(ndt);
+#endif
+	return ret;
+}
+
+static int ak7755_set_dai_mute(struct snd_soc_dai *dai, int mute)
+{
+    struct snd_soc_codec *codec = dai->codec;
+
+	ak7755_set_dai_mute2(codec, mute);
+
+	return 0;
+}
+
+#define AK7755_RATES		(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
+				SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
+				SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\
+				SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\
+			    SNDRV_PCM_RATE_96000)
+
+#define AK7755_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_ops ak7755_dai_ops = {
+	.hw_params	= ak7755_hw_params,
+	.set_sysclk	= ak7755_set_dai_sysclk,
+	.set_fmt	= ak7755_set_dai_fmt,
+	.trigger = ak7755_trigger,
+	.digital_mute = ak7755_set_dai_mute,
+};
+
+struct snd_soc_dai_driver ak7755_dai[] = {
+	{
+		.name = "ak7755-AIF1",
+		.playback = {
+		       .stream_name = "Playback",
+		       .channels_min = 1,
+		       .channels_max = 2,
+		       .rates = AK7755_RATES,
+		       .formats = AK7755_FORMATS,
+		},
+		.capture = {
+		       .stream_name = "Capture",
+		       .channels_min = 1,
+		       .channels_max = 4,
+		       .rates = AK7755_RATES,
+		       .formats = AK7755_FORMATS,
+		},
+		.ops = &ak7755_dai_ops,
+	},
+};
+
+static int ak7755_init_reg(struct snd_soc_codec *codec)
+{
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);   // '15/06/15
+
+	akdbgprt("\t[AK7755 bias] %s(%d)\n",__FUNCTION__,__LINE__);
+
+
+	if ( ak7755->power_gpio > 0 ) {
+		gpio_direction_output(ak7755->power_gpio, ak7755->power_active);
+	}
+
+	if ( ak7755->pdn_gpio > 0 ) {
+		gpio_direction_output(ak7755->pdn_gpio, ak7755->pdn_active);
+		msleep(10);
+		gpio_direction_output(ak7755->pdn_gpio, !ak7755->pdn_active);
+	}
+
+
+	ak7755_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	snd_soc_update_bits(codec, AK7755_D4_LO1_LO2_VOLUME_SETTING, 0xFF, 0xFF);			//LOVOL1,2=F(0dB)
+	snd_soc_update_bits(codec, AK7755_D3_LIN_LO3_VOLUME_SETTING, 0x0F, 0x0F);			//LOVOL3=F(0dB)
+	snd_soc_update_bits(codec, AK7755_D2_MIC_GAIN_SETTING, 0xFF, 0xCC);
+	snd_soc_update_bits(codec, AK7755_D0_FUNCTION_SETTING, 0x40, 0x40);				//CRCE=1(CRC Enable)
+	snd_soc_update_bits(codec, AK7755_C2_SERIAL_DATA_FORMAT, 0x40, AK7755_BCKP_BIT);	//BCKP bit
+	snd_soc_update_bits(codec, AK7755_D0_FUNCTION_SETTING, 0x10, AK7755_SOCFG_BIT);	//SOFG bit
+#ifdef DIGITAL_MIC		//Analog MIC Use
+	snd_soc_update_bits(codec, AK7755_DE_DMIC_IF_SETTING, 0x90, 0x90);					//DMIC1=DMIC2=1(Digital MIC Use)
+	snd_soc_update_bits(codec, AK7755_DE_DMIC_IF_SETTING, 0x40, AK7755_DMCLKP1_BIT);	//DMCLKP1 bit
+	snd_soc_update_bits(codec, AK7755_DE_DMIC_IF_SETTING, 0x08, AK7755_DMCLKP2_BIT);	//DMCLKP2 bit
+	snd_soc_update_bits(codec, AK7755_C0_CLOCK_SETTING1, 0x08, 0x00);
+#else
+	snd_soc_update_bits(codec, AK7755_C0_CLOCK_SETTING1, 0x08, 0x08);		//AINE=1(Analog MIC Use)
+#endif
+	snd_soc_write(codec, 0xCA, 0x01);
+	snd_soc_write(codec, 0xDA, 0x10);
+	snd_soc_write(codec, 0xCD, 0xC0);
+	snd_soc_write(codec, 0xE6, 0x01);
+	snd_soc_write(codec, 0xEA, 0x80);
+
+	if(aec == 1) {
+		/*Select DAC MUX as DSP DOUT4*/
+		snd_soc_update_bits(codec, AK7755_C8_DAC_IN_SETTING, 0xC0, 0x00);
+		/*Lineout1 power on*/
+		snd_soc_update_bits(codec, AK7755_CE_POWER_MANAGEMENT, 0xC7, 0xC7);
+
+		/*Select SDOUT1 MUX as DOUT1 Of DSP*/
+		snd_soc_update_bits(codec, AK7755_CC_VOLUME_TRANSITION, 0x07, 0x00);
+	} else {
+		/*Select DAC MUX as SDIN1*/
+		snd_soc_update_bits(codec, AK7755_C8_DAC_IN_SETTING, 0xC0, 0xC0);
+		/*Lineout1 power on*/
+		snd_soc_update_bits(codec, AK7755_CE_POWER_MANAGEMENT, 0xC7, 0xC7);
+
+		/*Select SDOUT1 MUX as SDOUTAD*/
+		snd_soc_update_bits(codec, AK7755_CC_VOLUME_TRANSITION, 0x07, 0x03);
+	}
+
+	return 0;
+}
+
+static int ak7755_parse_dt(struct ak7755_priv *ak7755)
+{
+	struct device *dev;
+	struct device_node *np;
+	enum of_gpio_flags flags;
+	int ret = 0;
+
+	if (ak7755->control_type == SND_SOC_SPI) {
+		dev = &(ak7755->spi->dev);
+	}
+	else {
+		dev = &(ak7755->i2c->dev);
+	}
+
+	np = dev->of_node;
+
+	if (!np)
+		return -1;
+
+	ak7755->pdn_gpio = of_get_named_gpio_flags(np, "ak7755,pdn-gpio", 0, &flags);
+	ak7755->pdn_active = !!(flags & OF_GPIO_ACTIVE_LOW);
+	if(ak7755->pdn_gpio < 0 || !gpio_is_valid(ak7755->pdn_gpio)) {
+		dev_err(dev, "ak7755 pdn pin(%u) is invalid\n", ret);
+		ak7755->pdn_gpio = -1;
+		return ret;
+	}
+	ret = devm_gpio_request(dev, ak7755->pdn_gpio, "ak7755 pdn_gpio");
+	if ( ret < 0 )
+		dev_err(dev, "Failed to request pdn_pin: %d\n", ret);
+
+
+	ak7755->power_gpio = of_get_named_gpio_flags(np, "ak7755,pwr-gpio", 0, &flags);
+	ak7755->power_active = !!(flags & OF_GPIO_ACTIVE_LOW);
+	if (ak7755->power_gpio < 0 || !gpio_is_valid(ak7755->power_gpio)) {
+		ak7755->power_gpio = -1;
+		dev_err(dev, "ak7755 power pin(%u) is invalid\n", ret);
+		return ret;
+	}
+	ret = devm_gpio_request(dev, ak7755->power_gpio, "ak7755 power_gpio");
+	if ( ret < 0 )
+		dev_err(dev, "Failed to request power_pin: %d\n", ret);
+
+
+	ak7755->amp_gpio = of_get_named_gpio_flags(np, "ak7755,amp-gpio", 0, &flags);
+	ak7755->amp_active = !!(flags & OF_GPIO_ACTIVE_LOW);
+	if (ak7755->amp_gpio < 0 || !gpio_is_valid(ak7755->amp_gpio)) {
+		ak7755->amp_gpio = -1;
+		dev_err(dev, "ak7755 amplifier pin(%u) is invalid\n", ret);
+		return ret;
+	}
+	ret = devm_gpio_request(dev, ak7755->amp_gpio, "ak7755 amp_gpio");
+	if ( ret < 0 )
+		dev_err(dev, "Failed to request amp_pin: %d\n", ret);
+
+	return 0;
+}
+
+static int ak7755_set_reg_table(void)
+{
+	int i;
+	int n;
+
+	n = 0;
+	do {
+		ak7755_reg[n] = 0;
+		ak7755_access_masks[n].readable = 0;
+		ak7755_access_masks[n].writable = 0;
+		n ++;
+	} while ( n < AK7755_C0_CLOCK_SETTING1 );
+
+	i = 0;
+	do {
+		ak7755_reg[n] = ak7755_reg2[i] ;
+		ak7755_access_masks[n].readable = ak7755_access_masks2[i].readable;
+		ak7755_access_masks[n].writable = ak7755_access_masks2[i].writable;
+		i++;
+		n++;
+	} while ( n < AK7755_MAX_REGISTERS);
+
+	return(0);
+
+}
+
+static int ak7755_probe(struct snd_soc_codec *codec)
+{
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+	int i;
+
+	akdbgprt("\t[AK7755] %s(%d)\n",__FUNCTION__,__LINE__);
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, ak7755->control_type);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+
+#ifdef AK7755_CONTIF_DEBUG
+	codec->read = ak7755_reg_read;
+	codec->write = ak7755_reg_write;
+
+#endif
+
+	akdbgprt("\t[AK7755] %s(%d) ak7755=%x\n",__FUNCTION__,__LINE__, (int)ak7755);
+	ak7755->codec = codec;
+	ret = ak7755_parse_dt(ak7755);
+	if ( ret != 0 ) {
+		dev_err(codec->dev, "Failed to parse devict tree: %d\n", ret);
+		return ret;
+	}
+
+	ak7755_set_reg_table();
+	ak7755_init_reg(codec);
+	akdbgprt("\t[AK7755 Effect] %s(%d)\n",__FUNCTION__,__LINE__);
+
+	ak7755->fs = 48000;
+	ak7755->rclk = 0;
+	ak7755->lign = 7;	//lign:7 = LIGN:0(0dB)
+	ak7755->selmix = 0;	//SDOUTAD(L,R)
+	ak7755->MIRNo = 1;
+	ak7755->status = POWERDOWN;
+
+
+	ak7755->DSPPramMode = 0;
+	ak7755->DSPCramMode = 0;
+	ak7755->DSPOfregMode = 0;
+	ak7755->DSPAcramMode = 0;
+
+	for ( i = 0 ; i < 5 ; i ++ ) ak7755->EQLevel[i] = 24;
+	ak7755->HPFfc[0] = 0;
+	ak7755->HPFfc[1] = 0;
+ 	ak7755->LimRel = 2;
+	ak7755->LimVol = 0;
+
+	ak7755->bickfs = (AK7755_AUDIO_IF_MODE >> 4);
+
+	akdbgprt("\t[AK7755 init_ak7755_pd] %s(%d)\n",__FUNCTION__,__LINE__);
+
+#ifdef AK7755_IO_CONTROL
+	init_ak7755_pd(ak7755);
+#endif
+	return ret;
+}
+
+static int ak7755_remove(struct snd_soc_codec *codec)
+{
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+
+	akdbgprt("\t[AK7755] %s(%d)\n",__FUNCTION__,__LINE__);
+
+	ak7755_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	if ( ak7755->pdn_gpio > 0 ) {
+		gpio_set_value(ak7755->pdn_gpio, 0);
+		gpio_free(ak7755->pdn_gpio);
+	}
+
+	return 0;
+}
+
+static int ak7755_suspend(struct snd_soc_codec *codec)
+{
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+
+	ak7755_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	if ( ak7755->pdn_gpio > 0 ) {
+		gpio_set_value(ak7755->pdn_gpio, 0);
+	}
+	else {
+#ifdef AK7755_PD_SUSPEND
+		//snd_soc_cache_init(codec);
+#endif
+	}
+
+	return 0;
+}
+
+static int ak7755_resume(struct snd_soc_codec *codec)
+{
+	struct ak7755_priv *ak7755 = snd_soc_codec_get_drvdata(codec);
+
+	if ( ak7755->pdn_gpio > 0 ) {
+		gpio_set_value(ak7755->pdn_gpio, 0);
+		msleep(2);
+		gpio_set_value(ak7755->pdn_gpio, 1);
+	}
+	mdelay(2);
+
+	ak7755_firmware_write_ram(RAMTYPE_PRAM, ak7755_data->DSPPramMode);
+	ak7755_firmware_write_ram(RAMTYPE_CRAM, ak7755_data->DSPCramMode);
+
+	snd_soc_cache_sync(codec);
+	snd_soc_write(codec, 0xE6, 0x01);
+	snd_soc_write(codec, 0xEA, 0x80);
+
+	ak7755_set_bias_level(codec, SND_SOC_BIAS_ON);
+
+	return 0;
+}
+
+
+struct snd_soc_codec_driver soc_codec_dev_ak7755 = {
+	.probe = ak7755_probe,
+	.remove = ak7755_remove,
+	.suspend =	ak7755_suspend,
+	.resume =	ak7755_resume,
+
+	//.idle_bias_off = false,
+	.set_bias_level = ak7755_set_bias_level,
+	.reg_cache_size = ARRAY_SIZE(ak7755_reg),
+	.reg_word_size = sizeof(u8),
+	.reg_cache_default = ak7755_reg,
+	.readable_register = ak7755_readable,
+	.volatile_register = ak7755_volatile,
+
+	.controls = ak7755_snd_controls,
+	.num_controls = ARRAY_SIZE(ak7755_snd_controls),
+	.dapm_widgets = ak7755_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(ak7755_dapm_widgets),
+	.dapm_routes = ak7755_intercon,
+	.num_dapm_routes = ARRAY_SIZE(ak7755_intercon),
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_ak7755);
+
+#ifdef CONFIG_OF
+static struct of_device_id ak7755_if_dt_ids[] = {
+	{ .compatible = "akm,ak7755"},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ak7755_if_dt_ids);
+#endif
+
+#ifdef AK7755_I2C_IF
+static int ak7755_i2c_probe(struct i2c_client *i2c,
+                            const struct i2c_device_id *id)
+{
+	struct ak7755_priv *ak7755;
+	int ret=0;
+
+	akdbgprt("\t[AK7755] %s(%d)\n",__FUNCTION__,__LINE__);
+
+	ak7755 = kzalloc(sizeof(struct ak7755_priv), GFP_KERNEL);
+	if (ak7755 == NULL) return -ENOMEM;
+
+	i2c_set_clientdata(i2c, ak7755);
+
+	ak7755->control_type = SND_SOC_I2C;
+	ak7755->i2c = i2c;
+
+	ak7755_data = ak7755;
+
+	ret = snd_soc_register_codec(&i2c->dev,
+			&soc_codec_dev_ak7755, &ak7755_dai[0], ARRAY_SIZE(ak7755_dai));
+	if (ret < 0){
+		kfree(ak7755);
+		akdbgprt("\t[AK7755 Error!] %s(%d)\n",__FUNCTION__,__LINE__);
+	}
+	return ret;
+}
+
+static int ak7755_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	kfree(i2c_get_clientdata(client));
+	return 0;
+}
+
+static const struct i2c_device_id ak7755_i2c_id[] = {
+	{ "ak7755", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ak7755_i2c_id);
+
+static struct i2c_driver ak7755_i2c_driver = {
+	.driver = {
+		.name = "ak7755",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(ak7755_if_dt_ids),
+#endif
+	},
+	.probe = ak7755_i2c_probe,
+	.remove = ak7755_i2c_remove,
+	.id_table = ak7755_i2c_id,
+};
+
+#else
+
+static int ak7755_spi_probe(struct spi_device *spi)
+{
+	struct ak7755_priv *ak7755;
+	int	ret;
+
+	akdbgprt("\t[AK7755] %s spi=%x\n",__FUNCTION__, (int)spi);
+
+	ak7755 = kzalloc(sizeof(struct ak7755_priv), GFP_KERNEL);
+	if (!ak7755)
+		return -ENOMEM;
+
+	ak7755->control_type = SND_SOC_SPI;
+	spi->bits_per_word = 8; // bits
+	spi->max_speed_hz = 7000000;
+	spi->mode = SPI_MODE_3;
+
+	akdbgprt("\t[AK7755] %s spi=%x, spi->chip_select = %d\n, cs_gpio = %d",__FUNCTION__, \
+		(int)spi, spi->chip_select, spi->cs_gpio);
+
+	ak7755->spi = spi;
+	ak7755_data = ak7755;
+
+	if ( 1 == fast_boot ) {
+		u8 reg[2],rx[1];
+		akdbgprt("Start loading AEC Firmware....\n");
+		reg[0] = AK7755_C1_CLOCK_SETTING2 & 0x7F;
+		ak7755_reads(reg,1,rx,1);
+		if (1 != (rx[0] & 0x1)) {
+			printk( "Fast audio setup error for ak7755: 0x%02X\n", rx[0]);
+			return -1;
+		}
+		reg[0] = AK7755_CF_RESET_POWER_SETTING;
+		reg[1] = 0x01;
+		ak7755_writes(reg,2);
+
+		msleep(1);
+		ret = ak7755_firmware_write_ram(RAMTYPE_PRAM, 1);
+		if ( ret < 0 ) {
+			printk( "Failed to RAMTYPE_PRAM %d\n", ret);
+			return ret;
+		}
+		ret = ak7755_firmware_write_ram(RAMTYPE_CRAM,1);
+		if ( ret < 0 ) {
+			printk( "Failed to RAMTYPE_CRAM: %d\n", ret);
+			return ret;
+		}
+		reg[0] = AK7755_CF_RESET_POWER_SETTING;
+		reg[1] = 0x0c;
+		ak7755_writes(reg,2);
+		akdbgprt("Loading AEC Firmware done\n");
+		reg[0] = AK7755_CC_VOLUME_TRANSITION;	   //change to DSP output
+		reg[1] = 0x00;
+		ak7755_writes(reg,2);
+		reg[0] = AK7755_D2_MIC_GAIN_SETTING;	   //change Mic Gain to 6dB
+		reg[1] = 0x03;
+		ak7755_writes(reg,2);
+		reg[0] = AK7755_C8_DAC_IN_SETTING;		 //change DAC out to DSP
+		reg[1] = 0x00;
+
+#ifdef AK7755_DEBUG
+		u32 i;
+		for(i = 0x40; i <= 0x5e; i++) {
+			reg[0] = i ;
+			ak7755_reads(reg,1,rx,1);
+			printk("0x%x: 0x%02x\n", i|0xc0, rx[0]);
+  }
+#endif
+		return 0;
+	} else {
+		spi_set_drvdata(spi, ak7755);
+	}
+
+	ret = snd_soc_register_codec(&spi->dev,
+			&soc_codec_dev_ak7755,  &ak7755_dai[0], ARRAY_SIZE(ak7755_dai));
+	if (ret < 0)
+		kfree(ak7755);
+
+	ak7755_data = ak7755;
+
+	return 0;
+}
+
+static int ak7755_spi_remove(struct spi_device *spi)
+{
+	if ( ak7755_data->amp_active > 0 ) {
+		gpio_direction_output(ak7755_data->amp_gpio, !ak7755_data->amp_active);
+		devm_gpio_free(&spi->dev,ak7755_data->amp_active);
+	}
+	if ( ak7755_data->pdn_gpio > 0 ) {
+		gpio_direction_output(ak7755_data->pdn_gpio, ak7755_data->pdn_active);
+		devm_gpio_free(&spi->dev,ak7755_data->pdn_gpio);
+	}
+	if ( ak7755_data->power_gpio > 0 ) {
+		gpio_direction_output(ak7755_data->power_gpio, !ak7755_data->power_active);
+		devm_gpio_free(&spi->dev,ak7755_data->power_gpio);
+		akdbgprt("\t[AK7755] %s(%d) Release power_gpio ->>> %d\n",__FUNCTION__,__LINE__,ak7755_data->power_gpio);
+	}
+	snd_soc_unregister_codec(&spi->dev);
+	kfree(spi_get_drvdata(spi));
+	return 0;
+}
+
+static struct spi_driver ak7755_spi_driver = {
+	.driver = {
+		.name = "ak7755",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(ak7755_if_dt_ids),
+#endif
+	},
+	.probe = ak7755_spi_probe,
+	.remove = ak7755_spi_remove,
+};
+#endif
+
+static int __init ak7755_modinit(void)
+{
+	int ret = 0;
+
+	akdbgprt("\t[AK7755] %s(%d)\n", __FUNCTION__,__LINE__);
+
+#ifdef AK7755_I2C_IF
+	ret = i2c_add_driver(&ak7755_i2c_driver);
+	if ( ret != 0 ) {
+		printk(KERN_ERR "Failed to register AK7755 I2C driver: %d\n", ret);
+
+	}
+#else
+	ret = spi_register_driver(&ak7755_spi_driver);
+	if ( ret != 0 ) {
+		printk(KERN_ERR "Failed to register AK7755 SPI driver: %d\n",  ret);
+
+	}
+#endif
+
+#ifdef AK7755_IO_CONTROL
+	ret = misc_register(&ak7755_misc);
+	if (ret < 0) {
+		printk(KERN_ERR "Failed to register AK7755 MISC driver: %d\n",  ret);
+	}
+#endif
+
+	return ret;
+}
+
+module_init(ak7755_modinit);
+
+static void __exit ak7755_exit(void)
+{
+#ifdef AK7755_I2C_IF
+	i2c_del_driver(&ak7755_i2c_driver);
+#else
+	spi_unregister_driver(&ak7755_spi_driver);
+#endif
+
+#ifdef AK7755_IO_CONTROL
+	misc_deregister(&ak7755_misc);
+#endif
+
+}
+module_exit(ak7755_exit);
+
+MODULE_AUTHOR("Junichi Wakasugi <wakasugi.jb@om.asahi-kasei.co.jp>");
+MODULE_DESCRIPTION("ASoC ak7755 codec driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/ak7755.h b/sound/soc/codecs/ak7755.h
new file mode 100644
index 0000000..c49996b
--- /dev/null
+++ b/sound/soc/codecs/ak7755.h
@@ -0,0 +1,171 @@
+/*
+ * ak7755.h  --  audio driver for ak7755
+ *
+ * Copyright (C) 2014 Asahi Kasei Microdevices Corporation
+ *  Author                Date        Revision
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *                      14/04/22	    1.0
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef _AK7755_H
+#define _AK7755_H
+
+//#define AK7755_I2C_IF
+#define AK7755_IO_CONTROL
+
+
+/* AK7755_C1_CLOCK_SETTING2 (0xC1)  Fields */
+#define AK7755_AIF_BICK32		(2 << 4)
+#define AK7755_AIF_BICK48		(1 << 4)
+#define AK7755_AIF_BICK64		(0 << 4)
+#define AK7755_AIF_TDM			(3 << 4)	//TDM256 bit is set "1" at initialization.
+
+/* TDMMODE Input Source */
+#define AK7755_TDM_DSP				(0 << 2)
+#define AK7755_TDM_DSP_AD1			(1 << 2)
+#define AK7755_TDM_DSP_AD1_AD2		(2 << 2)
+
+/* User Setting */
+//#define DIGITAL_MIC
+//#define CLOCK_MODE_BICK
+//#define CLOCK_MODE_18_432
+#define AK7755_AUDIO_IF_MODE		AK7755_AIF_BICK32	//32fs, 48fs, 64fs, 256fs(TDM)
+#define AK7755_TDM_INPUT_SOURCE		AK7755_TDM_DSP		//Effective only in TDM mode
+#define AK7755_BCKP_BIT				(0 << 6)	//BICK Edge Setting
+#define AK7755_SOCFG_BIT  			(0 << 4)	//SO pin Hi-z Setting
+#define AK7755_DMCLKP1_BIT			(0 << 6)	//DigitalMIC 1 Channnel Setting
+#define AK7755_DMCLKP2_BIT			(0 << 3)	//DigitalMIC 1 Channnel Setting
+/* User Setting */
+
+#define AK7755_C0_CLOCK_SETTING1			0xC0
+#define AK7755_C1_CLOCK_SETTING2			0xC1
+#define AK7755_C2_SERIAL_DATA_FORMAT		0xC2
+#define AK7755_C3_DELAY_RAM_DSP_IO			0xC3
+#define AK7755_C4_DATARAM_CRAM_SETTING		0xC4
+#define AK7755_C5_ACCELARETOR_SETTING		0xC5
+#define AK7755_C6_DAC_DEM_SETTING			0xC6
+#define AK7755_C7_DSP_OUT_SETTING			0xC7
+#define AK7755_C8_DAC_IN_SETTING			0xC8
+#define AK7755_C9_ANALOG_IO_SETTING			0xC9
+#define AK7755_CA_CLK_SDOUT_SETTING			0xCA
+#define AK7755_CB_TEST_SETTING				0xCB
+#define AK7755_CC_VOLUME_TRANSITION			0xCC
+#define AK7755_CD_STO_DLS_SETTING			0xCD
+#define AK7755_CE_POWER_MANAGEMENT			0xCE
+#define AK7755_CF_RESET_POWER_SETTING		0xCF
+#define AK7755_D0_FUNCTION_SETTING			0xD0
+#define AK7755_D1_DSPMCLK_SETTING			0xD1
+#define AK7755_D2_MIC_GAIN_SETTING			0xD2
+#define AK7755_D3_LIN_LO3_VOLUME_SETTING	0xD3
+#define AK7755_D4_LO1_LO2_VOLUME_SETTING	0xD4
+#define AK7755_D5_ADC_DVOLUME_SETTING1		0xD5
+#define AK7755_D6_ADC_DVOLUME_SETTING2		0xD6
+#define AK7755_D7_ADC2_DVOLUME_SETTING1		0xD7
+#define AK7755_D8_DAC_DVOLUME_SETTING1		0xD8
+#define AK7755_D9_DAC_DVOLUME_SETTING2		0xD9
+#define AK7755_DA_MUTE_ADRC_ZEROCROSS_SET	0xDA
+#define AK7755_DB_ADRC_MIC_GAIN_READ		0xDB
+#define AK7755_DC_TEST_SETTING				0xDC
+#define AK7755_DD_ADC2_DVOLUME_SETTING2		0xDD
+#define AK7755_DE_DMIC_IF_SETTING			0xDE
+
+#define AK7755_MAX_REGISTERS	(AK7755_DE_DMIC_IF_SETTING + 1)
+
+/* Bitfield Definitions */
+
+/* AK7755_C0_CLOCK_SETTING1 (0xC0) Fields */
+#define AK7755_FS				0x07
+#define AK7755_FS_8KHZ			(0x00 << 0)
+#define AK7755_FS_12KHZ			(0x01 << 0)
+#define AK7755_FS_16KHZ			(0x02 << 0)
+#define AK7755_FS_24KHZ			(0x03 << 0)
+#define AK7755_FS_32KHZ			(0x04 << 0)
+#define AK7755_FS_48KHZ			(0x05 << 0)
+#define AK7755_FS_96KHZ			(0x06 << 0)
+
+#define AK7755_M_S				0x30		//CKM1-0 (CKM2 bit is not use)
+#define AK7755_M_S_0			(0 << 4)	//Master, XTI=12.288MHz
+#define AK7755_M_S_1			(1 << 4)	//Master, XTI=18.432MHz
+#define AK7755_M_S_2			(2 << 4)	//Slave, XTI=12.288MHz
+#define AK7755_M_S_3			(3 << 4)	//Slave, BICK
+
+/* AK7755_C2_SERIAL_DATA_FORMAT (0xC2) Fields */
+/* LRCK I/F Format */
+#define AK7755_LRIF					0x30
+#define AK7755_LRIF_MSB_MODE		(0 << 4)
+#define AK7755_LRIF_I2S_MODE		(1 << 4)
+#define AK7755_LRIF_PCM_SHORT_MODE	(2 << 4)
+#define AK7755_LRIF_PCM_LONG_MODE	(3 << 4)
+/* Input Format is set as "MSB(24- bit)" by following register.
+   CONT03(DIF2,DOF2), CONT06(DIFDA, DIF1), CONT07(DOF4,DOF3,DOF1) */
+
+/* AK7755_CA_CLK_SDOUT_SETTING (0xCA) Fields */
+#define AK7755_BICK_LRCK			(3 << 5)	//BICKOE, LRCKOE
+
+
+
+#define MAX_LOOP_TIMES		3
+
+#define CRC_COMMAND_READ_RESULT			0x72
+#define	TOTAL_NUM_OF_PRAM_MAX		20483
+#define	TOTAL_NUM_OF_CRAM_MAX		6147
+#define	TOTAL_NUM_OF_OFREG_MAX		99
+#define	TOTAL_NUM_OF_ACRAM_MAX		6147
+
+static const char *ak7755_firmware_pram[] =
+{
+    "Off",
+    "basic",
+    "data2",
+    "data3",
+    "data4",
+    "data5",
+    "data6",
+    "data7",
+    "data8",
+    "data9",
+};
+
+static const char *ak7755_firmware_cram[] =
+{
+    "Off",
+    "basic",
+    "data2",
+    "data3",
+    "data4",
+    "data5",
+    "data6",
+    "data7",
+    "data8",
+    "data9",
+};
+
+static const char *ak7755_firmware_ofreg[] =
+{
+    "Off",
+    "basic",
+    "data2",
+    "data3",
+    "data4",
+};
+
+static const char *ak7755_firmware_acram[] =
+{
+    "Off",
+    "basic",
+    "data2",
+    "data3",
+    "data4",
+};
+
+#include "ak7755ctl.h"
+
+#endif
+
diff --git a/sound/soc/codecs/ak7755_dsp_code.h b/sound/soc/codecs/ak7755_dsp_code.h
new file mode 100644
index 0000000..43a4cc5
--- /dev/null
+++ b/sound/soc/codecs/ak7755_dsp_code.h
@@ -0,0 +1,6220 @@
+static u8 ak7755_pram_basic[]= {
+    0xB8, 0x00, 0x00,             // PRAM Write Command
+    0x0C, 0x94, 0xED, 0x1E, 0x74,
+    0x04, 0xA8, 0x9C, 0x6D, 0x55,
+    0x00, 0x44, 0x02, 0x11, 0x99,
+    0x09, 0x58, 0x6F, 0x4D, 0xD0,
+    0x01, 0x5A, 0x7C, 0xC9, 0x27,
+    0x09, 0x35, 0x31, 0x01, 0x86,
+    0x03, 0x4B, 0xFA, 0x2C, 0x60,
+    0x0E, 0xF8, 0x5B, 0xA8, 0xD6,
+    0x04, 0x02, 0x37, 0xDD, 0x00,
+    0x05, 0x79, 0x77, 0x03, 0x9D,
+    0x07, 0xAE, 0xA3, 0x43, 0x38,
+    0x0E, 0xD9, 0xA6, 0x5E, 0x1F,
+    0x00, 0x7B, 0xE3, 0xE6, 0x41,
+    0x09, 0x8A, 0xB8, 0x79, 0xB1,
+    0x03, 0x68, 0x1B, 0xB8, 0x98,
+    0x08, 0x55, 0xA7, 0x8B, 0x7A,
+    0x01, 0x8F, 0x58, 0x91, 0x42,
+    0x04, 0xAC, 0x14, 0xDB, 0xF2,
+    0x0B, 0x37, 0xC2, 0x1F, 0x0C,
+    0x06, 0xA5, 0x9C, 0xED, 0xE6,
+    0x01, 0xA6, 0xC0, 0xAD, 0xBB,
+    0x05, 0xFE, 0x2A, 0x81, 0x4A,
+    0x03, 0xBF, 0xC7, 0x3A, 0x4F,
+    0x0D, 0x44, 0x86, 0x74, 0x8C,
+    0x03, 0x43, 0xBC, 0x3B, 0x53,
+    0x07, 0xC5, 0xCD, 0x84, 0x59,
+    0x04, 0x79, 0xF3, 0xE4, 0x2E,
+    0x01, 0xB5, 0x71, 0x37, 0x20,
+    0x08, 0x46, 0x13, 0x93, 0xD3,
+    0x05, 0xB7, 0x82, 0x8D, 0x69,
+    0x02, 0xA4, 0x57, 0xEC, 0x94,
+    0x0C, 0x06, 0x32, 0x8D, 0x2F,
+    0x08, 0xB1, 0xD7, 0x59, 0xE3,
+    0x0E, 0x83, 0x5C, 0xF6, 0x0B,
+    0x0F, 0x55, 0x03, 0x95, 0xE5,
+    0x0C, 0x5E, 0xF0, 0x1E, 0xBA,
+    0x08, 0x5C, 0x20, 0x7B, 0x66,
+    0x07, 0x29, 0xFB, 0x43, 0x5F,
+    0x0A, 0xC8, 0xC7, 0xA7, 0x68,
+    0x03, 0xB7, 0x43, 0xC8, 0xE3,
+    0x0B, 0xB3, 0xA3, 0x26, 0x5A,
+    0x0D, 0x76, 0xEE, 0xC5, 0xB0,
+    0x0E, 0x14, 0x8B, 0xD3, 0xF6,
+    0x09, 0x3E, 0x49, 0xA9, 0x98,
+    0x0D, 0x34, 0xDA, 0x5F, 0xD1,
+    0x03, 0xAC, 0xB3, 0xC3, 0xEC,
+    0x06, 0xB6, 0xEC, 0x12, 0x0D,
+    0x0A, 0x05, 0x2A, 0xCD, 0xB2,
+    0x0C, 0xE9, 0x3D, 0xF3, 0x98,
+    0x09, 0xC2, 0xF6, 0xCB, 0x3E,
+    0x00, 0xFF, 0x83, 0xD9, 0xA5,
+    0x0A, 0x89, 0xEE, 0xD9, 0xE7,
+    0x04, 0x0A, 0x71, 0xCE, 0x95,
+    0x04, 0xC4, 0x40, 0x21, 0x18,
+    0x0E, 0x55, 0x87, 0xF4, 0xDC,
+    0x0A, 0x15, 0xA0, 0x6C, 0x92,
+    0x0F, 0x93, 0x52, 0x30, 0x18,
+    0x0A, 0x64, 0x3B, 0x22, 0xC7,
+    0x08, 0x37, 0x4E, 0xBA, 0x0D,
+    0x0D, 0x89, 0xA9, 0xFF, 0xE4,
+    0x0B, 0x06, 0x54, 0x70, 0x39,
+    0x02, 0x2B, 0x6C, 0xA4, 0x33,
+    0x04, 0xBC, 0x5B, 0x1B, 0xAB,
+    0x0E, 0x56, 0x7A, 0x28, 0xAE,
+    0x02, 0xCC, 0x22, 0xCF, 0x9B,
+    0x05, 0x72, 0x0D, 0xAB, 0x89,
+    0x09, 0xD1, 0x82, 0x30, 0x9C,
+    0x0B, 0x0D, 0xE9, 0xBD, 0x25,
+    0x0B, 0x4F, 0xD9, 0x21, 0x0C,
+    0x06, 0xA6, 0x61, 0x37, 0x9E,
+    0x09, 0x7F, 0x45, 0x08, 0x38,
+    0x0F, 0x1F, 0x74, 0x1C, 0xEB,
+    0x00, 0x5A, 0xFA, 0xAE, 0xA6,
+    0x07, 0xAE, 0x40, 0x7B, 0xA4,
+    0x0C, 0x54, 0xA8, 0x6F, 0x4B,
+    0x0B, 0x34, 0x3B, 0xC3, 0xFE,
+    0x0F, 0x7C, 0x5D, 0xC8, 0x25,
+    0x0B, 0x47, 0x98, 0xB6, 0x2A,
+    0x07, 0x1B, 0x56, 0x13, 0x11,
+    0x00, 0xD4, 0xE5, 0xB9, 0x56,
+    0x0A, 0x83, 0xB3, 0x28, 0x56,
+    0x0F, 0xE3, 0xCF, 0xFC, 0xFD,
+    0x0D, 0x91, 0xA0, 0x28, 0xD2,
+    0x0E, 0xDA, 0x9B, 0xE5, 0x9E,
+    0x0F, 0xB9, 0xF4, 0xB1, 0x2A,
+    0x04, 0xA4, 0x94, 0x2F, 0x94,
+    0x0D, 0x91, 0x66, 0x49, 0xEB,
+    0x08, 0xC1, 0x4E, 0x17, 0xB6,
+    0x09, 0x26, 0x47, 0xFC, 0x1E,
+    0x08, 0xB9, 0x90, 0x4E, 0x47,
+    0x0F, 0x3E, 0x6C, 0x50, 0x3D,
+    0x06, 0xAE, 0x27, 0x24, 0x0B,
+    0x08, 0xC2, 0x72, 0x2A, 0xBD,
+    0x06, 0xE4, 0x50, 0xAB, 0x0F,
+    0x04, 0x96, 0xFC, 0x9C, 0x2B,
+    0x08, 0x46, 0xF1, 0xAD, 0xFD,
+    0x0F, 0xBA, 0x2B, 0x34, 0x3D,
+    0x00, 0x6B, 0x6E, 0xC1, 0x6B,
+    0x0A, 0xA0, 0x53, 0xBC, 0xBB,
+    0x01, 0xCE, 0x94, 0x57, 0x51,
+    0x01, 0x9C, 0x2E, 0x6C, 0xD0,
+    0x0F, 0x5F, 0x7C, 0xBD, 0xF1,
+    0x02, 0x70, 0x55, 0xED, 0x1E,
+    0x0C, 0x89, 0x2D, 0x9E, 0xDD,
+    0x0D, 0x1D, 0x87, 0x02, 0x11,
+    0x04, 0xB4, 0xDE, 0xEF, 0x4D,
+    0x09, 0xF0, 0x9B, 0x78, 0x83,
+    0x0C, 0xA8, 0xF1, 0x35, 0xCB,
+    0x0C, 0xF2, 0xCA, 0xFA, 0x2C,
+    0x05, 0xC7, 0xF8, 0xFB, 0xA0,
+    0x07, 0x8C, 0x42, 0xD7, 0xD5,
+    0x00, 0xA5, 0x79, 0x73, 0x32,
+    0x0D, 0x27, 0xAE, 0xA6, 0xF0,
+    0x08, 0x5E, 0xD8, 0xA7, 0xD4,
+    0x0F, 0xF0, 0x7B, 0x64, 0x6C,
+    0x01, 0x29, 0xDA, 0x3A, 0xC9,
+    0x01, 0x52, 0x38, 0xDC, 0x0A,
+    0x04, 0x88, 0x04, 0x23, 0x01,
+    0x06, 0xB0, 0xDC, 0xDB, 0x99,
+    0x00, 0xB4, 0xF9, 0x9A, 0x1B,
+    0x0E, 0x6A, 0x62, 0x83, 0x11,
+    0x06, 0xC7, 0x70, 0x58, 0xEB,
+    0x00, 0xF1, 0xF1, 0x81, 0xA5,
+    0x0B, 0x54, 0x2B, 0xAA, 0x81,
+    0x06, 0xF2, 0xE7, 0x07, 0x32,
+    0x0F, 0x0C, 0xC0, 0x86, 0x70,
+    0x01, 0xB3, 0x48, 0xFC, 0x37,
+    0x00, 0xA6, 0x41, 0xCC, 0x82,
+    0x03, 0xB4, 0x79, 0xF3, 0x62,
+    0x04, 0x20, 0x31, 0x71, 0x31,
+    0x00, 0x08, 0x46, 0x13, 0x95,
+    0x01, 0xEC, 0xB7, 0x22, 0x85,
+    0x05, 0xFB, 0x2F, 0x37, 0xEC,
+    0x04, 0xCC, 0x06, 0x36, 0xBC,
+    0x0F, 0xE8, 0xB1, 0xD0, 0x53,
+    0x03, 0xEE, 0x83, 0xDD, 0x46,
+    0x0B, 0x5F, 0x55, 0x06, 0xB2,
+    0x09, 0xDC, 0x0E, 0x74, 0x96,
+    0x06, 0x89, 0x0D, 0x21, 0x73,
+    0x04, 0x87, 0x7C, 0x77, 0xC1,
+    0x03, 0x8B, 0x9D, 0x04, 0xAF,
+    0x08, 0xA3, 0x62, 0xC5, 0x48,
+    0x0F, 0x6A, 0xE4, 0x22, 0x28,
+    0x00, 0xDD, 0xA3, 0x2A, 0xC3,
+    0x06, 0x6E, 0x4D, 0x8A, 0xDB,
+    0x06, 0x18, 0xEB, 0xC9, 0xA9,
+    0x04, 0x0C, 0x6F, 0xDA, 0x57,
+    0x01, 0x32, 0x28, 0xB3, 0xC7,
+    0x0D, 0x06, 0xB6, 0xEC, 0x16,
+    0x0E, 0xFB, 0x81, 0x2B, 0xCB,
+    0x08, 0x1C, 0xE9, 0x3D, 0x75,
+    0x02, 0x48, 0x42, 0xF6, 0xCD,
+    0x02, 0xF0, 0xF4, 0x43, 0xD7,
+    0x07, 0x32, 0x09, 0x4A, 0xE0,
+    0x07, 0xCD, 0x8A, 0x97, 0xCC,
+    0x05, 0xC4, 0xC4, 0xC6, 0x11,
+    0x08, 0x4E, 0x55, 0x82, 0xD2,
+    0x04, 0x0A, 0xB5, 0xAE, 0x6C,
+    0x0B, 0x5F, 0x73, 0x5A, 0xF0,
+    0x08, 0xCA, 0x34, 0xBF, 0xA2,
+    0x07, 0x59, 0x66, 0x8F, 0xBA,
+    0x0D, 0x6D, 0xDF, 0xAD, 0x7D,
+    0x04, 0x0A, 0x56, 0x97, 0x70,
+    0x09, 0x82, 0xFE, 0x6A, 0x24,
+    0x02, 0xD5, 0x2C, 0x9A, 0x1D,
+    0x01, 0xAE, 0x83, 0x3C, 0x9E,
+    0x05, 0x43, 0x5E, 0xA3, 0xCF,
+    0x0B, 0x44, 0xA5, 0x0D, 0xAB,
+    0x08, 0xD9, 0x41, 0x44, 0x7A,
+    0x0D, 0xFA, 0xC9, 0xEF, 0x73,
+    0x04, 0x7A, 0xCE, 0xD9, 0x25,
+    0x0F, 0x77, 0x26, 0x60, 0x31,
+    0x05, 0x38, 0xBF, 0x45, 0x8E,
+    0x02, 0xCF, 0x1F, 0x70, 0x2B,
+    0x0B, 0xB0, 0x5A, 0xFE, 0x1B,
+    0x04, 0xAF, 0x2F, 0xE6, 0x79,
+    0x04, 0xF5, 0xD4, 0xCE, 0xED,
+    0x0B, 0xDB, 0x34, 0x3D, 0xF3,
+    0x0E, 0x0F, 0x7C, 0x5A, 0x7A,
+    0x09, 0x3B, 0x4A, 0x1F, 0x3E,
+    0x0A, 0x47, 0x1B, 0x57, 0x13,
+    0x01, 0x00, 0x84, 0x63, 0x89,
+    0x0A, 0x1B, 0xDD, 0x72, 0x20,
+    0x06, 0x9F, 0xB2, 0x4B, 0x7E,
+    0x0D, 0x4C, 0xC0, 0x61, 0x99,
+    0x0E, 0xFE, 0x85, 0x5D, 0x6D,
+    0x0E, 0x3E, 0xE8, 0x35, 0xB7,
+    0x08, 0xB6, 0x75, 0xDC, 0x23,
+    0x06, 0xDE, 0x60, 0x6B, 0x03,
+    0x02, 0xAA, 0xB0, 0xCA, 0x17,
+    0x0C, 0x68, 0x17, 0x87, 0xF8,
+    0x06, 0xF8, 0x39, 0x94, 0x0A,
+    0x0E, 0x0F, 0x9E, 0x6E, 0xD4,
+    0x06, 0xB4, 0x8E, 0x22, 0x22,
+    0x0B, 0x08, 0xA0, 0x72, 0xA4,
+    0x07, 0x25, 0xC4, 0x50, 0xAD,
+    0x0F, 0x64, 0x92, 0xFC, 0x9A,
+    0x0B, 0x80, 0xC2, 0x55, 0xE5,
+    0x0F, 0x16, 0x3E, 0xCF, 0x7C,
+    0x0D, 0xD1, 0xEF, 0x6E, 0xC1,
+    0x0B, 0xD3, 0x24, 0x52, 0xBC,
+    0x07, 0x9E, 0x31, 0x6F, 0xE7,
+    0x08, 0x22, 0x58, 0x2B, 0x67,
+    0x08, 0x6A, 0xAF, 0xF9, 0xEA,
+    0x08, 0x5B, 0xE0, 0x90, 0x6D,
+    0x07, 0x72, 0x18, 0xA5, 0x1C,
+    0x05, 0xDD, 0xE8, 0x44, 0xC2,
+    0x08, 0x9D, 0x45, 0x5C, 0xEF,
+    0x01, 0xC8, 0xAA, 0x5A, 0x60,
+    0x01, 0xAF, 0xBD, 0xB5, 0xF3,
+    0x0B, 0x8C, 0xC9, 0xCB, 0xF2,
+    0x04, 0xF5, 0x36, 0x78, 0xFB,
+    0x0C, 0xD6, 0xD6, 0x02, 0xC9,
+    0x04, 0xC5, 0x05, 0x7F, 0x7D,
+    0x0B, 0x9C, 0xC7, 0xAE, 0x62,
+    0x0B, 0x9E, 0xDA, 0xD5, 0xA1,
+    0x06, 0x1F, 0x70, 0x7F, 0xE2,
+    0x0E, 0x40, 0xAD, 0xDA, 0xFC,
+    0x01, 0x37, 0x72, 0x38, 0x1A,
+    0x08, 0x98, 0x88, 0x80, 0x34,
+    0x01, 0x62, 0x10, 0xDA, 0xDB,
+    0x09, 0x42, 0x3C, 0xFF, 0x12,
+    0x03, 0xF0, 0x6A, 0x62, 0x43,
+    0x03, 0x46, 0xE7, 0x74, 0x50,
+    0x0B, 0x2F, 0xF1, 0xF7, 0x41,
+    0x0D, 0xBB, 0x01, 0xAF, 0xAA,
+    0x03, 0x4A, 0xFA, 0xEA, 0x07,
+    0x08, 0x4F, 0x51, 0x40, 0x86,
+    0x00, 0x3C, 0x13, 0x43, 0xBC,
+    0x0F, 0x59, 0x57, 0xC5, 0xCC,
+    0x02, 0x53, 0xB4, 0xF9, 0xF3,
+    0x02, 0xA4, 0x73, 0x31, 0x3B,
+    0x01, 0x10, 0x0B, 0x46, 0x13,
+    0x05, 0x61, 0xBD, 0xB7, 0x22,
+    0x01, 0x69, 0xFA, 0xA0, 0xF7,
+    0x00, 0xD4, 0xCD, 0x02, 0x72,
+    0x0D, 0x2F, 0x68, 0xB1, 0xD6,
+    0x09, 0x63, 0x4E, 0x83, 0x5B,
+    0x0A, 0x2F, 0x5F, 0x55, 0x15,
+    0x05, 0xE5, 0xDC, 0x0A, 0x45,
+    0x0E, 0xBA, 0x89, 0x08, 0x92,
+    0x0B, 0x66, 0x87, 0xFE, 0x75,
+    0x01, 0xEF, 0x8B, 0x9F, 0x4E,
+    0x07, 0x68, 0xF3, 0x60, 0xF5,
+    0x08, 0xE3, 0x6A, 0xE4, 0x10,
+    0x0C, 0x10, 0x9C, 0x27, 0x22,
+    0x0F, 0x7A, 0x60, 0x45, 0x02,
+    0x03, 0xF6, 0x4D, 0x6F, 0xC9,
+    0x09, 0x98, 0x0C, 0x65, 0x1A,
+    0x0F, 0xB1, 0xE7, 0xAC, 0xB3,
+    0x07, 0xDD, 0x06, 0xB6, 0xEC,
+    0x06, 0xDF, 0x2A, 0x05, 0x2B,
+    0x07, 0xB8, 0x0C, 0xA9, 0x35,
+    0x05, 0x12, 0x19, 0xC6, 0xC7,
+    0x0D, 0x0E, 0xF0, 0xF9, 0x89,
+    0x0F, 0x17, 0x32, 0x8F, 0x7E,
+    0x01, 0xE7, 0xCD, 0x8E, 0xB0,
+    0x0E, 0x55, 0x60, 0x4D, 0x40,
+    0x01, 0x18, 0x4A, 0xD5, 0x86,
+    0x04, 0xDC, 0x8E, 0x95, 0xA7,
+    0x0C, 0xC2, 0x58, 0x11, 0xE2,
+    0x00, 0x49, 0x4E, 0x36, 0x0F,
+    0x00, 0x96, 0xDD, 0x61, 0xC5,
+    0x0A, 0x5C, 0xE0, 0xD8, 0x2D,
+    0x0D, 0x05, 0x8A, 0x57, 0x97,
+    0x00, 0x39, 0xD2, 0x7A, 0xEA,
+    0x04, 0x33, 0x85, 0xE9, 0xAB,
+    0x0D, 0xE1, 0xFF, 0x01, 0xB4,
+    0x0E, 0x64, 0x12, 0x1B, 0x93,
+    0x0F, 0x9B, 0x15, 0x27, 0xA9,
+    0x0B, 0x89, 0x88, 0x88, 0xE0,
+    0x00, 0x9C, 0xAB, 0x05, 0x0A,
+    0x05, 0x14, 0x26, 0xCF, 0xD1,
+    0x09, 0xBF, 0x29, 0x66, 0x68,
+    0x01, 0x94, 0x6D, 0x7F, 0x45,
+    0x0E, 0xB2, 0xCF, 0x1F, 0x74,
+    0x0A, 0xBB, 0x34, 0x5A, 0xFA,
+    0x08, 0x14, 0xAF, 0x2E, 0xE0,
+    0x03, 0xC5, 0x75, 0xD4, 0x48,
+    0x0B, 0x0B, 0xCA, 0xF4, 0x33,
+    0x03, 0xFE, 0x0F, 0x78, 0x6D,
+    0x08, 0x25, 0x3B, 0x41, 0x95,
+    0x06, 0x2A, 0x47, 0x9D, 0x67,
+    0x03, 0x11, 0x00, 0x80, 0x41,
+    0x05, 0x56, 0x0A, 0x53, 0x7A,
+    0x04, 0x56, 0x8D, 0xB2, 0x43,
+    0x06, 0x4D, 0xCC, 0xC2, 0xE3,
+    0x08, 0xD2, 0xFE, 0x8B, 0x1D,
+    0x05, 0x9E, 0x3E, 0xEC, 0x10,
+    0x08, 0x60, 0xB5, 0xF5, 0x50,
+};
+
+static u8 ak7755_cram_basic[]= {
+	0xB4, 0x00, 0x00,    // CRAM Write Command
+    0x00, 0x00, 0x00,  // EQ1 LPF fc = 125Hz
+    0x00, 0x42, 0x7A,
+    0x00, 0x00, 0x00,
+    0x1F, 0x7B, 0x0B,
+    0x00, 0x42, 0x7A,
+    0xFF, 0x50, 0x67,  // EQ2 BPF fo = 250Hz
+    0x00, 0x00, 0x00,
+    0xE2, 0x1C, 0x4C,
+    0x3D, 0xDB, 0x38,
+    0x00, 0xAF, 0x99,
+    0xFD, 0x7D, 0x8E,  // EQ3 BPF fo = 1000Hz
+    0x00, 0x00, 0x00,
+    0xE7, 0xB8, 0xC0,
+    0x37, 0xCB, 0xFE,
+    0x02, 0x82, 0x72,
+    0xF8, 0x9F, 0x19,  // EQ4 BPF fo = 4000Hz
+    0x00, 0x00, 0x00,
+    0xF6, 0xB4, 0x01,
+    0x23, 0xC3, 0x9E,
+    0x07, 0x60, 0xE7,
+    0x00, 0x00, 0x00,  // EQ5 HPF fc = 7500Hz
+    0xEB, 0x25, 0x7E,
+    0x00, 0x00, 0x00,
+    0x09, 0xB5, 0x04,
+    0x14, 0xDA, 0x82,
+    0x20, 0x00, 0x00, 
+    0x00, 0x00, 0x00, // EQ1 Gain
+    0x00, 0x00, 0x00, // EQ2 Gain
+    0x00, 0x00, 0x00, // EQ3 Gain
+    0x00, 0x00, 0x00, // EQ4 Gain
+    0x00, 0x00, 0x00, // EQ5 Gain
+    0x20, 0x00, 0x00,
+    0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, // HPF1
+    0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00,
+    0x20, 0x00, 0x00,
+    0x7D, 0x63, 0x00,
+    0x21, 0xF6, 0x00,
+    0x7D, 0x63, 0x00,
+    0x21, 0xF6, 0x00,
+    0x7F, 0xFA, 0x00,
+    0x55, 0x72, 0x00,
+    0xF8, 0x6E, 0x00,
+    0xE6, 0xDA, 0xB0,
+    0x17, 0x92, 0x00,
+    0x08, 0x00, 0x00,
+    0x00, 0x00, 0x00, // MIX_VOL_L
+    0x08, 0x00, 0x00,
+    0x00, 0x00, 0x00, // HPF2
+    0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00,
+    0x20, 0x00, 0x00,
+    0x08, 0x00, 0x00,
+    0x00, 0x00, 0x00,  // MIX_VOL_R
+};
+
+static u8 ak7755_pram_aec[]= {
+	0xB8,0x00,0x00,               // PRAM Write Command
+	0x0C, 0xB4, 0xED, 0x1E, 0x42,
+	0x04, 0xA9, 0x1C, 0x6D, 0x49,
+	0x04, 0x44, 0x82, 0x1A, 0x44,
+	0x0F, 0x58, 0x76, 0xCD, 0x88,
+	0x0D, 0x5A, 0x7E, 0x89, 0x1D,
+	0x03, 0x35, 0x29, 0x03, 0x8C,
+	0x0F, 0x4A, 0x05, 0x6C, 0x68,
+	0x0A, 0x70, 0xFE, 0x20, 0xE7,
+	0x01, 0x86, 0xD2, 0x15, 0x72,
+	0x09, 0x79, 0x37, 0xC3, 0xAE,
+	0x07, 0xAE, 0xA2, 0x4F, 0x79,
+	0x0E, 0xD9, 0xA1, 0xD2, 0xA2,
+	0x00, 0x7B, 0xE2, 0xEA, 0xAB,
+	0x09, 0xDA, 0x38, 0xF5, 0xEE,
+	0x02, 0x38, 0xDE, 0xB4, 0x07,
+	0x08, 0x04, 0x23, 0x05, 0x15,
+	0x0C, 0xDE, 0x9B, 0xD1, 0x73,
+	0x04, 0xFD, 0x92, 0x57, 0x99,
+	0x06, 0x67, 0xD8, 0x99, 0x75,
+	0x0B, 0xF4, 0x58, 0xEB, 0x2A,
+	0x0D, 0xF6, 0xA0, 0x2D, 0x8E,
+	0x09, 0xAF, 0xC4, 0x01, 0x43,
+	0x0E, 0xEC, 0x54, 0x3A, 0x4B,
+	0x06, 0xC1, 0x84, 0xF0, 0xBD,
+	0x0F, 0x42, 0x33, 0x3F, 0xFD,
+	0x0B, 0xC5, 0x8C, 0x02, 0x5A,
+	0x0F, 0xFB, 0x3C, 0x62, 0xA4,
+	0x0D, 0xB4, 0xE6, 0xF1, 0x0D,
+	0x04, 0x46, 0x63, 0x95, 0x68,
+	0x06, 0xB5, 0xD0, 0x85, 0x69,
+	0x07, 0x25, 0x38, 0xE4, 0xC9,
+	0x00, 0x06, 0x63, 0xCD, 0x26,
+	0x03, 0x33, 0x19, 0x59, 0xE3,
+	0x02, 0x82, 0xC8, 0xB6, 0x16,
+	0x03, 0x55, 0x73, 0x15, 0xEC,
+	0x07, 0x8C, 0x86, 0x9E, 0xBA,
+	0x05, 0x1C, 0xE1, 0x7B, 0x60,
+	0x0B, 0x68, 0x7F, 0xC1, 0xE8,
+	0x07, 0x98, 0xB3, 0xE7, 0x75,
+	0x0F, 0xE6, 0xA1, 0xC8, 0xEA,
+	0x01, 0x61, 0xAF, 0x20, 0x10,
+	0x00, 0x26, 0xEA, 0x03, 0x67,
+	0x02, 0x45, 0x68, 0xD3, 0xFF,
+	0x02, 0xEC, 0x04, 0xA9, 0x98,
+	0x07, 0xE1, 0x8D, 0x5F, 0xD1,
+	0x0F, 0xAC, 0xB3, 0xC7, 0xE3,
+	0x0A, 0xB7, 0x76, 0xD6, 0xA3,
+	0x06, 0x05, 0x58, 0x0B, 0xB1,
+	0x0C, 0xE9, 0x3F, 0x75, 0x12,
+	0x09, 0xC2, 0xF6, 0x4D, 0xC4,
+	0x00, 0xFF, 0x81, 0xDF, 0xDD,
+	0x0D, 0x89, 0x4E, 0xD1, 0xE7,
+	0x01, 0x8A, 0x91, 0xC6, 0xD3,
+	0x08, 0xC4, 0x40, 0x21, 0x1F,
+	0x05, 0xD2, 0xD0, 0xF4, 0xDC,
+	0x06, 0x14, 0x27, 0xAC, 0x8F,
+	0x03, 0x93, 0x53, 0x70, 0x29,
+	0x03, 0xB4, 0x5F, 0xAE, 0x87,
+	0x03, 0x67, 0x91, 0xBA, 0x4D,
+	0x0D, 0xD8, 0x2D, 0x7D, 0x4B,
+	0x0A, 0x57, 0x97, 0x70, 0x39,
+	0x0E, 0x7A, 0x15, 0xE4, 0x3B,
+	0x09, 0xEF, 0x65, 0xDD, 0xE5,
+	0x0F, 0x07, 0xBE, 0x2E, 0x6E,
+	0x02, 0x9D, 0xA3, 0xCF, 0x99,
+	0x09, 0x23, 0x4A, 0xAB, 0x80,
+	0x08, 0x80, 0x40, 0x30, 0x9C,
+	0x07, 0x0D, 0xE9, 0xB9, 0x2B,
+	0x02, 0xCF, 0x3B, 0x27, 0x3F,
+	0x0C, 0xA6, 0x43, 0xB1, 0xB4,
+	0x05, 0x5F, 0x45, 0x8E, 0x8D,
+	0x07, 0x1F, 0x74, 0x1A, 0xDB,
+	0x0C, 0x5B, 0x66, 0xA8, 0x09,
+	0x04, 0xA8, 0xA0, 0x7B, 0x96,
+	0x09, 0xD4, 0x37, 0xA7, 0x02,
+	0x07, 0x35, 0xBA, 0x03, 0xE3,
+	0x0F, 0x7C, 0x5E, 0xC8, 0x25,
+	0x03, 0x47, 0x1F, 0x3A, 0xA0,
+	0x0F, 0x9B, 0xF5, 0x13, 0xD1,
+	0x0A, 0x84, 0x4E, 0xB9, 0x76,
+	0x07, 0xD3, 0xFE, 0x68, 0x5E,
+	0x03, 0xB2, 0x71, 0xFE, 0x50,
+	0x07, 0x46, 0x56, 0xA8, 0xD2,
+	0x02, 0x8B, 0x60, 0xA5, 0x97,
+	0x0E, 0xE8, 0x37, 0xB7, 0x60,
+	0x0C, 0x75, 0xB0, 0x25, 0x5E,
+	0x04, 0x41, 0x07, 0x4B, 0x6B,
+	0x00, 0x96, 0x2E, 0x1B, 0xB6,
+	0x08, 0x77, 0x87, 0x79, 0xD4,
+	0x02, 0xB9, 0xBE, 0xCA, 0x36,
+	0x07, 0x3E, 0xEC, 0x50, 0xCE,
+	0x06, 0xAE, 0x26, 0x26, 0x8B,
+	0x02, 0xC2, 0x5D, 0xAC, 0x36,
+	0x0E, 0xE4, 0xD0, 0xAF, 0xBF,
+	0x04, 0x96, 0xFE, 0x9A, 0x99,
+	0x0C, 0xC7, 0xD3, 0xA5, 0xE0,
+	0x0E, 0x3A, 0x4B, 0x38, 0x7D,
+	0x08, 0xEB, 0xCE, 0xC1, 0xAB,
+	0x00, 0xA0, 0x13, 0xBC, 0x9B,
+	0x0D, 0xCE, 0xEF, 0xD7, 0x58,
+	0x01, 0x9C, 0x2D, 0x60, 0xC1,
+	0x0F, 0x0F, 0xF8, 0x3D, 0xF1,
+	0x0B, 0xA3, 0xB4, 0xEF, 0x9E,
+	0x05, 0xDE, 0x09, 0x10, 0x6D,
+	0x0C, 0x4C, 0x44, 0x02, 0x11,
+	0x04, 0xE5, 0x5A, 0x6A, 0x07,
+	0x02, 0xA1, 0x60, 0x7E, 0xE9,
+	0x01, 0xF8, 0x55, 0x33, 0x39,
+	0x00, 0xA3, 0x54, 0xBA, 0x15,
+	0x09, 0x96, 0x04, 0x7B, 0x9A,
+	0x0A, 0xDF, 0xD1, 0x97, 0xEE,
+	0x0B, 0x20, 0x77, 0x77, 0x03,
+	0x01, 0x27, 0xD2, 0xE2, 0x4A,
+	0x00, 0x5E, 0x5B, 0xA7, 0x9E,
+	0x0F, 0xF0, 0x79, 0xE4, 0x6C,
+	0x0B, 0x29, 0x9B, 0x3C, 0xF8,
+	0x0D, 0x52, 0x1B, 0x9A, 0xB0,
+	0x02, 0x48, 0x0C, 0xA3, 0x7E,
+	0x0A, 0xB0, 0xDE, 0x1B, 0x91,
+	0x02, 0xB4, 0xFE, 0x90, 0xD1,
+	0x0E, 0x68, 0x33, 0x03, 0x1D,
+	0x0C, 0x57, 0xF0, 0x58, 0x96,
+	0x0C, 0xF1, 0xF7, 0x41, 0xAD,
+	0x0B, 0x05, 0xAF, 0xBA, 0x81,
+	0x0A, 0xF2, 0xEE, 0x37, 0xB8,
+	0x0F, 0x5D, 0x44, 0xB6, 0x70,
+	0x01, 0xB3, 0x3F, 0xFC, 0x36,
+	0x00, 0xF7, 0xC7, 0xCC, 0x82,
+	0x03, 0xB4, 0x79, 0xF3, 0x62,
+	0x0C, 0x71, 0x37, 0x73, 0xB1,
+	0x0C, 0x09, 0xC4, 0xD3, 0x88,
+	0x09, 0xBD, 0x37, 0x22, 0x85,
+	0x0B, 0xFB, 0x24, 0xB1, 0xE4,
+	0x0C, 0xCC, 0x06, 0x32, 0x8D,
+	0x0F, 0x98, 0x31, 0xD6, 0x59,
+	0x0F, 0xEE, 0xDB, 0x5B, 0x7F,
+	0x0B, 0x5F, 0x57, 0x02, 0x95,
+	0x05, 0xDC, 0x0C, 0x70, 0x94,
+	0x06, 0x88, 0x91, 0x61, 0x66,
+	0x0D, 0x05, 0xF9, 0xFF, 0xC1,
+	0x04, 0x09, 0x18, 0x84, 0xA7,
+	0x04, 0xF3, 0xA6, 0x85, 0x41,
+	0x0F, 0x6B, 0x62, 0xA2, 0x3D,
+	0x09, 0x0C, 0xC7, 0x26, 0xC3,
+	0x03, 0xC8, 0xA7, 0x0A, 0x13,
+	0x0E, 0x49, 0x6D, 0xCD, 0xA3,
+	0x04, 0x0D, 0xEA, 0x1A, 0x42,
+	0x0A, 0xE1, 0x1D, 0xB7, 0x3C,
+	0x0D, 0x06, 0xB4, 0xEC, 0x16,
+	0x02, 0xAA, 0x76, 0xEB, 0xC2,
+	0x04, 0x1D, 0x73, 0xFD, 0x68,
+	0x02, 0x19, 0xC0, 0xF4, 0x52,
+	0x02, 0xF1, 0x7E, 0xC3, 0xC2,
+	0x0E, 0xB2, 0xE9, 0x42, 0xD1,
+	0x0E, 0x6B, 0x6A, 0x91, 0x06,
+	0x0F, 0xC4, 0x94, 0x40, 0x01,
+	0x08, 0x4E, 0x57, 0x86, 0xF4,
+	0x00, 0x8A, 0x61, 0xA7, 0xE5,
+	0x0E, 0xDE, 0x09, 0x93, 0x2D,
+	0x08, 0xCA, 0x36, 0xBD, 0x3D,
+	0x0B, 0x59, 0x26, 0x4F, 0xB3,
+	0x01, 0x6C, 0x4F, 0xED, 0x60,
+	0x08, 0x0A, 0x27, 0xD7, 0x79,
+	0x05, 0xD3, 0xAE, 0xEA, 0x20,
+	0x08, 0x07, 0x3C, 0x1A, 0x1D,
+	0x0D, 0xFF, 0x44, 0xFE, 0x27,
+	0x04, 0x12, 0x9F, 0xA3, 0xCF,
+	0x0B, 0x15, 0x23, 0x89, 0xA1,
+	0x05, 0x88, 0xCC, 0x42, 0x39,
+	0x00, 0xAB, 0x64, 0x29, 0xB0,
+	0x04, 0x2B, 0x4F, 0xDB, 0x97,
+	0x0F, 0x26, 0xA4, 0x62, 0x85,
+	0x08, 0x69, 0x3C, 0xC5, 0x87,
+	0x0E, 0xCE, 0x9F, 0x74, 0x07,
+	0x07, 0xB1, 0xD4, 0xFA, 0xB5,
+	0x0F, 0x2D, 0xDB, 0x60, 0x82,
+	0x08, 0xF4, 0x56, 0x08, 0x7A,
+	0x07, 0xDA, 0xD1, 0xFB, 0xC0,
+	0x07, 0x8F, 0x9C, 0x5C, 0x08,
+	0x0C, 0xBA, 0xA7, 0x9F, 0x76,
+	0x06, 0x47, 0x5F, 0x57, 0x1A,
+	0x01, 0x00, 0x8E, 0x65, 0xE7,
+	0x06, 0x1B, 0xD1, 0x76, 0x22,
+	0x04, 0x9F, 0xBA, 0x47, 0xBE,
+	0x0F, 0x4C, 0xC0, 0x65, 0x1B,
+	0x02, 0x7E, 0x2B, 0x1D, 0x65,
+	0x0E, 0x5E, 0x6A, 0x35, 0xB7,
+	0x00, 0xB5, 0xF5, 0x50, 0x29,
+	0x0E, 0x5D, 0xC0, 0xE3, 0x43,
+	0x07, 0xA8, 0xCB, 0x0E, 0x1E,
+	0x06, 0x68, 0x77, 0x81, 0xB6,
+	0x02, 0xF8, 0xF4, 0x90, 0x43,
+	0x06, 0x8F, 0x3C, 0x6A, 0x1E,
+	0x0E, 0x36, 0xAE, 0x20, 0x11,
+	0x0D, 0x09, 0x41, 0x72, 0xB1,
+	0x07, 0xA6, 0xE4, 0x50, 0xAD,
+	0x0D, 0x64, 0x96, 0xFA, 0x9A,
+	0x05, 0x81, 0x64, 0xD1, 0xB8,
+	0x0D, 0x66, 0xB8, 0xCB, 0x3C,
+	0x01, 0xD0, 0x2F, 0xAE, 0xC8,
+	0x0B, 0xEA, 0xA2, 0x56, 0xB6,
+	0x00, 0x03, 0x4F, 0x13, 0xD7,
+	0x0A, 0xA3, 0x1D, 0xAF, 0x6C,
+	0x0C, 0xEF, 0x9D, 0xB8, 0x20,
+	0x0D, 0x73, 0x33, 0x54, 0xE5,
+	0x05, 0xFE, 0xA4, 0x29, 0x1C,
+	0x01, 0x5D, 0xC9, 0xC4, 0x1F,
+	0x0D, 0x84, 0xA1, 0xD8, 0x66,
+	0x0D, 0xC8, 0xA1, 0x5A, 0xB6,
+	0x09, 0x2D, 0xFB, 0x31, 0x39,
+	0x01, 0x8C, 0xA1, 0x4F, 0xF0,
+	0x04, 0x75, 0x16, 0x74, 0x3B,
+	0x0C, 0xD6, 0x9A, 0x82, 0xDE,
+	0x09, 0x41, 0x05, 0x79, 0x6A,
+	0x08, 0x1F, 0xA6, 0x2E, 0xA2,
+	0x08, 0xBA, 0xDF, 0x59, 0xA1,
+	0x02, 0x1E, 0x73, 0x3B, 0xFF,
+	0x0E, 0x41, 0x29, 0xDA, 0x3C,
+	0x0B, 0xB1, 0x52, 0x3E, 0xDA,
+	0x00, 0x98, 0x88, 0x04, 0x23,
+	0x09, 0xBA, 0x30, 0xDE, 0x9B,
+	0x0D, 0x43, 0x28, 0xBD, 0x8F,
+	0x00, 0x74, 0x0E, 0x66, 0x03,
+	0x09, 0x46, 0x95, 0xF4, 0x58,
+	0x03, 0xAC, 0x53, 0xF3, 0x4B,
+	0x01, 0xBB, 0x6A, 0x6F, 0xA3,
+	0x0D, 0x4B, 0x6E, 0x6E, 0x1A,
+	0x01, 0xC9, 0x1D, 0x4D, 0x34,
+	0x08, 0xBD, 0xB1, 0x43, 0xBC,
+	0x07, 0xE0, 0x71, 0xC9, 0x46,
+	0x09, 0xD5, 0xF4, 0x70, 0x01,
+	0x0A, 0xA4, 0x73, 0xB5, 0x71,
+	0x09, 0x90, 0xAA, 0x4A, 0x99,
+	0x09, 0x61, 0x36, 0x37, 0x2B,
+	0x0D, 0x69, 0xF9, 0x24, 0xB7,
+	0x0C, 0xD4, 0xCE, 0x0F, 0x38,
+	0x01, 0x2F, 0x71, 0x31, 0xDF,
+	0x01, 0xE3, 0xEC, 0x83, 0x5B,
+	0x0E, 0x0B, 0x5D, 0x5C, 0x48,
+	0x09, 0xE4, 0x5D, 0x0E, 0x69,
+	0x02, 0xBB, 0x52, 0x8C, 0xD2,
+	0x07, 0x67, 0x5A, 0xF8, 0x4B,
+	0x0D, 0xEE, 0x6A, 0x19, 0x31,
+	0x0B, 0x68, 0x9D, 0x66, 0xCC,
+	0x04, 0xE1, 0x39, 0xE2, 0x66,
+	0x0C, 0x12, 0xDC, 0x27, 0x2F,
+	0x08, 0xFE, 0xA0, 0x45, 0xFB,
+	0x0F, 0xF7, 0xCA, 0xEF, 0xD4,
+	0x05, 0x99, 0xA9, 0x65, 0x07,
+	0x0D, 0xD1, 0x63, 0xAA, 0xB3,
+	0x0B, 0xD7, 0x06, 0xB6, 0xF0,
+	0x06, 0xCE, 0x28, 0x05, 0x2B,
+	0x07, 0xB8, 0x55, 0xA9, 0x34,
+	0x05, 0x12, 0x1B, 0xC6, 0xFC,
+	0x06, 0x8C, 0x71, 0x7F, 0x83,
+	0x04, 0x95, 0xB3, 0x89, 0x4E,
+	0x0D, 0xE7, 0x40, 0x0A, 0x98,
+	0x06, 0xD5, 0xC6, 0xC4, 0x40,
+	0x01, 0x18, 0x4C, 0x51, 0x8C,
+	0x08, 0xDC, 0xC1, 0x95, 0xAE,
+	0x00, 0x92, 0x4D, 0xD3, 0x4E,
+	0x0C, 0x18, 0xCA, 0x34, 0xB7,
+	0x09, 0x45, 0x25, 0xE7, 0x8F,
+	0x06, 0x0D, 0x41, 0x98, 0x25,
+	0x0D, 0x54, 0x0A, 0x53, 0xAC,
+	0x00, 0x39, 0xD0, 0x78, 0x50,
+	0x04, 0x33, 0x85, 0x63, 0x10,
+	0x0D, 0xE1, 0xFF, 0x89, 0x74,
+	0x02, 0x65, 0x92, 0x9D, 0xBE,
+	0x03, 0x9B, 0x63, 0x63, 0x84,
+	0x0B, 0x89, 0x88, 0x80, 0xB3,
+	0x08, 0x9C, 0x2B, 0x0F, 0x69,
+	0x03, 0x14, 0xA2, 0x4F, 0xF9,
+	0x05, 0xBF, 0x26, 0xA6, 0x51,
+	0x0D, 0x94, 0x25, 0x7F, 0x4C,
+	0x02, 0xB3, 0x49, 0x9F, 0x69,
+	0x0A, 0xDB, 0xB0, 0xDA, 0xFA,
+	0x08, 0x14, 0xAD, 0x2C, 0x52,
+	0x03, 0xA4, 0xF5, 0xD6, 0xFB,
+	0x0C, 0x88, 0xDC, 0x34, 0x3B,
+	0x03, 0xFE, 0x0D, 0x7C, 0x5C,
+	0x00, 0x25, 0x3B, 0xC9, 0xD5,
+	0x0E, 0x2A, 0xC5, 0x15, 0x5D,
+	0x03, 0x11, 0x02, 0x84, 0x61,
+	0x05, 0x57, 0x9B, 0xD3, 0x6F,
+	0x04, 0x56, 0xE9, 0xF2, 0x42,
+	0x0E, 0x4D, 0x4C, 0xC0, 0x92,
+	0x00, 0xD2, 0x7C, 0x89, 0x9D,
+	0x0F, 0x9E, 0xAF, 0xE8, 0x15,
+	0x07, 0x60, 0xB5, 0xF5, 0x61,
+	0x05, 0x5E, 0x12, 0x40, 0xEE,
+	0x05, 0xEA, 0x2F, 0x50, 0xD3,
+	0x0C, 0x35, 0x44, 0x77, 0x87,
+	0x0C, 0x1E, 0xFA, 0xB9, 0x90,
+	0x06, 0x76, 0xF9, 0x7E, 0x65,
+	0x0C, 0x8E, 0x36, 0xAE, 0x26,
+	0x0A, 0x01, 0x88, 0xC0, 0xF2,
+	0x06, 0x37, 0x30, 0xE4, 0x70,
+	0x01, 0x3F, 0x0C, 0xD6, 0xF5,
+	0x0A, 0x99, 0x80, 0xC6, 0x5B,
+	0x09, 0xFD, 0x59, 0xFA, 0xC2,
+	0x04, 0x85, 0x70, 0xE7, 0x6E,
+	0x01, 0x6B, 0xEA, 0xA2, 0xE6,
+	0x0C, 0xBB, 0x81, 0xCC, 0x26,
+	0x0B, 0x51, 0x54, 0x5C, 0x26,
+	0x00, 0xD1, 0x5E, 0xCF, 0xE5,
+	0x05, 0xF1, 0xF3, 0x2D, 0xD4,
+	0x05, 0x1C, 0x7C, 0xD5, 0xA9,
+	0x04, 0x6F, 0x5C, 0x4C, 0x84,
+	0x02, 0x11, 0x84, 0x61, 0x52,
+	0x0F, 0x4D, 0xC8, 0x25, 0x50,
+	0x0E, 0xC9, 0x2D, 0xF9, 0x3F,
+	0x09, 0x01, 0x11, 0xA3, 0x4F,
+	0x0A, 0x2C, 0x75, 0x9A, 0x72,
+	0x0B, 0xA0, 0xD4, 0xDD, 0x82,
+	0x0B, 0xD5, 0x0C, 0xA5, 0x70,
+	0x07, 0x03, 0x9F, 0x27, 0xAE,
+	0x02, 0x43, 0x38, 0xD2, 0x53,
+	0x01, 0xDE, 0x1D, 0xFC, 0xB1,
+	0x0E, 0xE6, 0x31, 0x29, 0xD3,
+	0x00, 0xF8, 0x35, 0x12, 0x25,
+	0x0A, 0xB8, 0x9A, 0x88, 0x04,
+	0x0F, 0x08, 0x6D, 0x30, 0xC3,
+	0x09, 0x91, 0x42, 0xB6, 0x7D,
+	0x02, 0x5B, 0xF2, 0x6A, 0x66,
+	0x03, 0x69, 0xC6, 0x97, 0xF4,
+	0x04, 0xEB, 0x79, 0x71, 0xFE,
+	0x01, 0xAD, 0xB9, 0x01, 0xA5,
+	0x01, 0x03, 0xCB, 0x72, 0xEE,
+	0x0C, 0xB8, 0xCE, 0xDD, 0x44,
+	0x0A, 0x70, 0x30, 0x73, 0x4A,
+	0x0C, 0x3F, 0xE2, 0xF7, 0xC5,
+	0x0C, 0x82, 0x51, 0xB0, 0x73,
+	0x0F, 0x62, 0xF3, 0xB1, 0xBC,
+	0x0D, 0x31, 0x82, 0x48, 0x5B,
+	0x0F, 0x95, 0x61, 0x3D, 0x3F,
+	0x09, 0x07, 0x15, 0x7B, 0x24,
+	0x07, 0xE4, 0xD6, 0xC8, 0x3D,
+	0x02, 0x8D, 0x2F, 0x66, 0x7B,
+	0x06, 0x59, 0xE1, 0xEE, 0x83,
+	0x07, 0x76, 0x40, 0xDF, 0x5C,
+	0x02, 0x95, 0xE7, 0xDC, 0x0E,
+	0x04, 0x9E, 0xBA, 0x89, 0x0C,
+	0x01, 0x7B, 0x64, 0x85, 0xC2,
+	0x0F, 0xC1, 0xED, 0x8B, 0x99,
+	0x08, 0xA7, 0x32, 0x33, 0xEF,
+	0x09, 0x49, 0x63, 0x6A, 0xFF,
+	0x0E, 0x21, 0x9A, 0xCC, 0x3A,
+	0x0A, 0xC3, 0x7A, 0xEE, 0xB4,
+	0x0A, 0xD3, 0xF4, 0x4B, 0xDD,
+	0x02, 0x2A, 0x8D, 0x8E, 0xD6,
+	0x0A, 0x5F, 0xD3, 0x63, 0xAC,
+	0x03, 0xC7, 0xDD, 0x88, 0xFC,
+	0x0C, 0x16, 0xBE, 0x24, 0x0F,
+	0x0B, 0xCB, 0xB8, 0x1C, 0xE9,
+	0x0D, 0x75, 0x10, 0x1B, 0x70,
+	0x06, 0xCD, 0x0C, 0xF0, 0xFF,
+	0x0F, 0xDE, 0x97, 0x32, 0x14,
+	0x02, 0xD1, 0x90, 0xCD, 0x83,
+	0x01, 0xC6, 0xD5, 0xC4, 0x35,
+	0x08, 0x21, 0x9A, 0x4C, 0xD5,
+	0x0C, 0xF4, 0x69, 0x0A, 0x35,
+	0x07, 0xEC, 0x92, 0xDF, 0xA2,
+	0x0F, 0x30, 0x46, 0x8A, 0x3D,
+	0x03, 0xA3, 0x4C, 0xD9, 0x7A,
+	0x04, 0x39, 0x21, 0x6D, 0xD8,
+	0x0D, 0x7D, 0x56, 0x0A, 0x57,
+	0x0B, 0x70, 0x4E, 0xD2, 0x73,
+	0x02, 0x24, 0x33, 0x85, 0xED,
+	0x02, 0x1D, 0x61, 0xFD, 0x87,
+	0x04, 0x2E, 0xDE, 0x92, 0xBD,
+	0x0F, 0xCF, 0xF0, 0xD5, 0x2A,
+	0x0D, 0xAB, 0x89, 0x88, 0x8A,
+	0x0E, 0x30, 0xC2, 0x2B, 0x04,
+	0x01, 0x41, 0xB4, 0xA7, 0x4F,
+	0x09, 0x25, 0xBF, 0x24, 0x12,
+	0x00, 0x31, 0x94, 0x6B, 0xCA,
+	0x09, 0x8E, 0xC4, 0x4F, 0x16,
+	0x08, 0x1B, 0x69, 0xB0, 0x47,
+	0x02, 0xA8, 0x94, 0xA2, 0x6E,
+	0x08, 0x71, 0xA4, 0xF8, 0xD4,
+	0x00, 0x65, 0x0B, 0xDB, 0xF4,
+	0x0B, 0xC3, 0xFE, 0x8B, 0x76,
+	0x0C, 0xC8, 0x25, 0xBF, 0x4D,
+	0x0F, 0x36, 0x2A, 0x47, 0x11,
+	0x0D, 0x13, 0xD0, 0x80, 0x80,
+	0x01, 0x39, 0x56, 0x17, 0xD9,
+	0x02, 0x28, 0x54, 0x9F, 0xB2,
+	0x07, 0x7E, 0x17, 0x8C, 0xC9,
+	0x03, 0x28, 0xD0, 0xFE, 0x8B,
+	0x0D, 0x65, 0x9E, 0xB2, 0x62,
+	0x05, 0xB7, 0x62, 0xB9, 0x3F,
+	0x0C, 0x28, 0xDF, 0xDD, 0xDD,
+	0x07, 0x49, 0xE9, 0xA8, 0x90,
+	0x02, 0x17, 0xFA, 0xE8, 0x7E,
+	0x0B, 0xFC, 0x45, 0xB8, 0xB0,
+	0x08, 0x4A, 0xF6, 0x8D, 0xBE,
+	0x04, 0xD4, 0x2C, 0x34, 0x2E,
+	0x0A, 0x22, 0x55, 0xC8, 0xFB,
+	0x0E, 0xAD, 0x7A, 0x26, 0xDC,
+	0x0B, 0x28, 0x1B, 0x64, 0x6D,
+	0x00, 0x9A, 0xE6, 0xC0, 0xCF,
+	0x01, 0xA5, 0xFF, 0x16, 0x3A,
+	0x0B, 0x3C, 0x7D, 0x54, 0x61,
+	0x0E, 0xC1, 0x69, 0xEE, 0xEA,
+	0x0E, 0xBD, 0x3D, 0x81, 0xD3,
+	0x0F, 0xD7, 0x1D, 0xA1, 0x95,
+	0x0F, 0x6C, 0xD2, 0xEF, 0xCB,
+	0x08, 0x3D, 0xF1, 0xF3, 0x20,
+	0x0C, 0x6D, 0xBE, 0xF8, 0xD8,
+	0x01, 0x1C, 0xED, 0x5E, 0xCC,
+	0x04, 0x02, 0x11, 0x86, 0x57,
+	0x04, 0x6F, 0x18, 0xC8, 0xA8,
+	0x0A, 0x7E, 0xCA, 0xA9, 0xB3,
+	0x05, 0x33, 0x03, 0x8A, 0xE1,
+	0x07, 0xFB, 0x0C, 0x75, 0x92,
+	0x08, 0xFB, 0xA0, 0xD6, 0xDD,
+	0x02, 0xD7, 0xD5, 0x40, 0xA5,
+	0x05, 0x77, 0x3C, 0x5D, 0x23,
+	0x0E, 0xA2, 0x43, 0x38, 0xE4,
+	0x09, 0xA1, 0xDE, 0x11, 0x72,
+	0x07, 0xE3, 0x79, 0x81, 0x2D,
+	0x06, 0x3C, 0x74, 0x31, 0x5B,
+	0x08, 0xDA, 0xBA, 0x98, 0x88,
+	0x04, 0x23, 0x09, 0xCA, 0xB0,
+	0x0E, 0x9B, 0x91, 0x40, 0x36,
+	0x01, 0x90, 0x14, 0x32, 0x6E,
+	0x0A, 0x03, 0x94, 0x86, 0x9E,
+	0x04, 0x58, 0xEB, 0x2C, 0xF1,
+	0x07, 0x41, 0xAD, 0xBB, 0x05,
+	0x0F, 0xAA, 0x83, 0x48, 0x70,
+	0x02, 0x07, 0x77, 0x0F, 0x54,
+	0x08, 0x87, 0xDC, 0x3D, 0xAE,
+	0x08, 0x3E, 0xBE, 0x60, 0xF7,
+	0x0E, 0x4E, 0x03, 0xD3, 0xB4,
+	0x05, 0xF3, 0xFD, 0x64, 0x75,
+	0x09, 0x70, 0xB1, 0x10, 0x15,
+	0x06, 0x13, 0x97, 0x67, 0xBF,
+	0x07, 0x22, 0x87, 0x6D, 0xF1,
+	0x08, 0xB7, 0x6F, 0xD4, 0xC5,
+	0x0A, 0x33, 0x08, 0x2F, 0xF5,
+	0x01, 0xD6, 0x5B, 0xE3, 0xEE,
+	0x0F, 0x5A, 0xD3, 0x0B, 0x42,
+	0x07, 0x02, 0x95, 0x67, 0x5C,
+	0x0E, 0x74, 0x9E, 0xBA, 0x89,
+	0x0C, 0x91, 0xFB, 0x66, 0x87,
+	0x08, 0x7F, 0xC1, 0xEF, 0x8B,
+	0x09, 0x04, 0xA5, 0x6C, 0xF9,
+	0x0D, 0x47, 0xC9, 0x63, 0x6A,
+	0x09, 0xE0, 0xA1, 0x90, 0x8C,
+	0x0B, 0x28, 0x56, 0x7A, 0x6A,
+	0x05, 0x0A, 0xD1, 0xF6, 0x49,
+	0x0F, 0xC9, 0xA8, 0x98, 0x0C,
+	0x05, 0x1A, 0x5D, 0xD5, 0x69,
+	0x0C, 0xB3, 0xC7, 0xD9, 0x04,
+	0x0A, 0xEC, 0x8F, 0x3E, 0xA3,
+	0x09, 0x2A, 0x4E, 0xB8, 0x01,
+	0x09, 0x3D, 0x77, 0x12, 0x19,
+	0x0E, 0xF7, 0x68, 0x0E, 0xED,
+	0x0D, 0x83, 0xDF, 0x95, 0xB2,
+	0x09, 0x4E, 0xD1, 0xE7, 0xCD,
+	0x0A, 0xE1, 0x46, 0xD5, 0xC4,
+	0x04, 0x40, 0x21, 0x18, 0x4E,
+	0x05, 0x86, 0xF6, 0xD8, 0x80,
+	0x0E, 0x25, 0x6D, 0x12, 0xDF,
+	0x08, 0xD1, 0xB1, 0x98, 0xCA,
+	0x08, 0xBF, 0x2C, 0x87, 0x50,
+	0x0B, 0x8F, 0x45, 0xCD, 0x69,
+	0x08, 0x2D, 0x7F, 0x54, 0x0A,
+	0x07, 0x97, 0x72, 0x3D, 0xD8,
+	0x0A, 0xEA, 0x24, 0x37, 0x87,
+	0x01, 0x9A, 0x5D, 0xE1, 0xFB,
+	0x0B, 0xBE, 0x8E, 0x64, 0x16,
+	0x01, 0xA2, 0x4B, 0x5B, 0x08,
+	0x0F, 0x8D, 0xFA, 0x89, 0x81,
+	0x08, 0x42, 0xB0, 0x9C, 0x2B,
+	0x0F, 0xE9, 0xB9, 0x14, 0xAB,
+	0x03, 0xD9, 0xB7, 0xFF, 0x3B,
+	0x06, 0x11, 0xB1, 0x94, 0x69,
+	0x03, 0x45, 0x9D, 0xF2, 0xC7,
+	0x04, 0xF6, 0x64, 0x5B, 0xB0,
+	0x06, 0xFB, 0x28, 0xD4, 0xB2,
+	0x07, 0x60, 0x93, 0xA8, 0xF5,
+	0x0D, 0xCE, 0x87, 0x0B, 0x1B,
+	0x08, 0x3A, 0x43, 0xBE, 0x12,
+	0x0C, 0x5C, 0xC8, 0x25, 0x3B,
+	0x0E, 0x1E, 0xD4, 0x2A, 0x87,
+	0x0B, 0x57, 0x11, 0x15, 0x0A,
+	0x08, 0x60, 0xB6, 0x56, 0x06,
+	0x0F, 0x72, 0x79, 0x56, 0x96,
+	0x02, 0x4B, 0x7C, 0x4D, 0x4C,
+	0x00, 0x63, 0x28, 0xD2, 0xFE,
+	0x03, 0x1D, 0xE7, 0x9C, 0xBE,
+	0x04, 0x35, 0xE4, 0xE0, 0xBC,
+	0x0D, 0x50, 0x2B, 0x5E, 0x5D,
+	0x0C, 0xE6, 0x89, 0xEB, 0x91,
+	0x09, 0xCE, 0xD7, 0xB4, 0xE8,
+	0x0F, 0x05, 0xBC, 0x10, 0xB8,
+	0x03, 0x90, 0xB1, 0x76, 0x87,
+	0x07, 0x6D, 0x94, 0x82, 0x36,
+	0x07, 0xA6, 0xC2, 0x01, 0x08,
+	0x02, 0x72, 0xAC, 0x33, 0x2C,
+	0x0C, 0x50, 0xAF, 0x3F, 0x64,
+	0x0A, 0xFC, 0xCB, 0xD9, 0x89,
+	0x0D, 0xD3, 0x14, 0xF9, 0xED,
+	0x0A, 0xCB, 0x3E, 0x7D, 0xD0,
+	0x07, 0x6E, 0x92, 0xAB, 0xE3,
+	0x00, 0x52, 0xBE, 0xB7, 0x0B,
+	0x02, 0x92, 0x57, 0x91, 0x3C,
+	0x05, 0xAF, 0x8C, 0xDC, 0xEF,
+	0x06, 0x7E, 0xDD, 0xF1, 0xB3,
+	0x00, 0x94, 0xED, 0x1E, 0x7C,
+	0x08, 0xA9, 0x1C, 0x69, 0xA7,
+	0x00, 0x45, 0x91, 0xD1, 0x99,
+	0x09, 0x58, 0x1E, 0x8D, 0xC1,
+	0x0D, 0x5B, 0xBE, 0xC9, 0x29,
+	0x02, 0xB7, 0xE2, 0x81, 0x8C,
+	0x0F, 0x4B, 0xAE, 0x2C, 0x7C,
+	0x06, 0x78, 0xF9, 0xA0, 0xD6,
+	0x0D, 0x82, 0xD5, 0xD1, 0x4A,
+	0x09, 0x79, 0x28, 0xC3, 0x94,
+	0x0B, 0xAF, 0x08, 0x43, 0x25,
+	0x05, 0x5B, 0x20, 0x5E, 0x1F,
+	0x0B, 0xF9, 0x63, 0x66, 0x41,
+	0x05, 0xDB, 0xB8, 0x79, 0xAC,
+	0x02, 0x38, 0xDA, 0xB8, 0x98,
+	0x0A, 0x04, 0x23, 0x0F, 0xCA,
+	0x00, 0xDE, 0x9B, 0x91, 0x42,
+	0x04, 0x8D, 0x12, 0x5B, 0xF2,
+	0x06, 0x67, 0x82, 0xD9, 0x5B,
+	0x07, 0xF4, 0x58, 0xEB, 0x2C,
+	0x09, 0x77, 0xE1, 0xAD, 0x7B,
+	0x0F, 0xAE, 0xA1, 0x01, 0x0A,
+	0x02, 0xEE, 0x07, 0x3E, 0x7D,
+	0x07, 0x45, 0x95, 0xF0, 0xBC,
+	0x0F, 0x43, 0xC2, 0x7F, 0xE9,
+	0x07, 0xC5, 0xCE, 0x82, 0x53,
+	0x0D, 0xF9, 0x13, 0x6E, 0xA4,
+	0x08, 0x34, 0x91, 0x33, 0x90,
+	0x00, 0xC0, 0xF3, 0x99, 0x61,
+	0x0D, 0x37, 0x22, 0x00, 0xA3,
+	0x01, 0x25, 0xA5, 0x64, 0xF4,
+	0x04, 0x86, 0x90, 0x8F, 0xAF,
+	0x01, 0xB1, 0x16, 0x5D, 0xE3,
+	0x02, 0x81, 0xC7, 0x76, 0x0F,
+	0x03, 0x55, 0x51, 0x55, 0xF8,
+	0x07, 0x88, 0x4E, 0x1E, 0xBA,
+	0x09, 0x0C, 0xE1, 0x7F, 0x54,
+	0x0D, 0x79, 0x6C, 0xC1, 0xEE,
+	0x0B, 0x99, 0x06, 0xA3, 0x62,
+	0x03, 0xE6, 0xC5, 0x48, 0xE3,
+	0x0A, 0xE2, 0x62, 0x20, 0x10,
+	0x00, 0x26, 0xB7, 0xC3, 0x67,
+	0x02, 0x45, 0x6B, 0x13, 0xFF,
+	0x02, 0xE9, 0xB7, 0x29, 0x98,
+	0x0C, 0x65, 0x18, 0x5F, 0xD1,
+	0x0B, 0x2C, 0x11, 0xC3, 0xD7,
+	0x06, 0xB6, 0xEC, 0x10, 0x84,
+	0x06, 0x07, 0x2B, 0xCB, 0x8A,
+	0x00, 0xE8, 0x40, 0x75, 0x0F,
+	0x05, 0xC2, 0x82, 0x8D, 0x07,
+	0x0B, 0x7B, 0x45, 0x5F, 0x17,
+	0x02, 0x09, 0x4E, 0xDF, 0xE7,
+	0x0D, 0x8A, 0x91, 0xC8, 0xD5,
+	0x08, 0xC4, 0x40, 0x21, 0x1E,
+	0x02, 0x45, 0x86, 0xF4, 0xDB,
+	0x06, 0x14, 0xDB, 0xEC, 0x8F,
+	0x03, 0x93, 0xAB, 0x30, 0x11,
+	0x01, 0xB3, 0xF0, 0xA2, 0xC7,
+	0x05, 0x66, 0x14, 0x7A, 0x10,
+	0x0D, 0xD8, 0x2D, 0x7D, 0x54,
+	0x0A, 0x57, 0x97, 0x70, 0xCE,
+	0x0E, 0x7B, 0x03, 0xE4, 0x2E,
+	0x0E, 0x6F, 0x15, 0x1D, 0xE1,
+	0x03, 0x07, 0xBB, 0x2E, 0x6D,
+	0x02, 0x9D, 0xA1, 0xC3, 0x8A,
+	0x09, 0x23, 0xCD, 0xAB, 0xBE,
+	0x00, 0x03, 0x62, 0x32, 0x1C,
+	0x03, 0x07, 0xC9, 0xB4, 0xD4,
+	0x01, 0x4E, 0xE2, 0xA5, 0x9F,
+	0x06, 0xA6, 0x61, 0x35, 0xDE,
+	0x01, 0x7E, 0xC5, 0x82, 0xB2,
+	0x05, 0x1E, 0x9B, 0x9A, 0xFB,
+	0x0C, 0x5A, 0xFA, 0xA8, 0x1D,
+	0x0F, 0x2E, 0xE0, 0xF3, 0xA4,
+	0x0D, 0xD4, 0xC8, 0xE5, 0x8B,
+	0x03, 0xB4, 0x9B, 0x41, 0x7E,
+	0x06, 0x7C, 0x9C, 0x4A, 0xA5,
+	0x02, 0xC7, 0x7F, 0xB4, 0xAA,
+	0x07, 0x1B, 0x57, 0x91, 0xAA,
+	0x00, 0x84, 0x61, 0xBB, 0xEC,
+	0x0B, 0xD3, 0x72, 0xAA, 0xEF,
+	0x0F, 0xB2, 0x4B, 0xFC, 0xF5,
+	0x0C, 0xC0, 0x63, 0xAA, 0x65,
+	0x0E, 0x8B, 0x1D, 0xE7, 0x28,
+	0x0E, 0xE8, 0x35, 0x35, 0xD5,
+	0x05, 0xF5, 0x50, 0xAB, 0xEA,
+	0x0D, 0xC0, 0xE7, 0xCB, 0x58,
+	0x08, 0x90, 0xCE, 0x95, 0x04,
+	0x08, 0x77, 0x87, 0x7E, 0xAF,
+	0x08, 0xB9, 0x90, 0xC8, 0xC6,
+	0x0F, 0x3E, 0x6C, 0xD6, 0x08,
+	0x06, 0xAE, 0x26, 0xA0, 0x86,
+	0x08, 0xC2, 0x70, 0xAE, 0xB3,
+	0x06, 0xE4, 0x50, 0xAF, 0xBA,
+	0x08, 0x96, 0xFC, 0x9A, 0xA7,
+	0x0E, 0xC6, 0x51, 0xA5, 0xFD,
+	0x09, 0xBA, 0xCB, 0x3C, 0x7D,
+	0x0C, 0x6B, 0x6E, 0xC1, 0x62,
+	0x0A, 0xA0, 0x50, 0xBC, 0xBB,
+	0x01, 0xCE, 0x93, 0x51, 0x5B,
+	0x01, 0x9C, 0x2F, 0xEA, 0x9A,
+	0x0F, 0x0F, 0xF8, 0xBB, 0x7B,
+	0x03, 0x20, 0x94, 0x6B, 0xD4,
+	0x0C, 0xD8, 0xA9, 0x92, 0xA7,
+	0x0C, 0x4C, 0x44, 0x8C, 0x9B,
+	0x04, 0xE5, 0x58, 0xE1, 0x07,
+	0x08, 0xA1, 0x5A, 0xF0, 0xC3,
+	0x0D, 0xF9, 0x35, 0xBE, 0xCB,
+	0x0C, 0xA3, 0x4B, 0x77, 0xA6,
+	0x05, 0x96, 0x78, 0x76, 0xEA,
+	0x06, 0xDD, 0x82, 0x5A, 0xDF,
+	0x00, 0xA5, 0x79, 0xFB, 0xC9,
+	0x0D, 0x27, 0xAE, 0x2E, 0xC9,
+	0x08, 0x5E, 0xD9, 0x2D, 0x94,
+	0x0F, 0xF0, 0x7B, 0x6E, 0xEC,
+	0x01, 0x29, 0xDA, 0xBF, 0x73,
+	0x01, 0x52, 0x38, 0x59, 0x72,
+	0x08, 0x88, 0x04, 0xA0, 0x03,
+	0x0A, 0xB0, 0xDC, 0x98, 0xDB,
+	0x0D, 0x34, 0xFD, 0x92, 0x5B,
+	0x02, 0x6A, 0x67, 0x03, 0x13,
+	0x06, 0x97, 0xF6, 0x54, 0xE1,
+	0x00, 0xF1, 0xF7, 0x41, 0xAB,
+	0x07, 0x15, 0xAF, 0xAA, 0x86,
+	0x06, 0xF2, 0xE6, 0x07, 0x00,
+	0x03, 0x5D, 0x44, 0x86, 0x42,
+	0x01, 0xB0, 0x43, 0xBC, 0x0C,
+	0x0B, 0x76, 0x3D, 0xCC, 0x82,
+	0x0F, 0xB5, 0x19, 0xF3, 0x50,
+	0x08, 0x73, 0x35, 0x71, 0x02,
+	0x0B, 0x89, 0xBE, 0x13, 0x95,
+	0x0D, 0xBD, 0x57, 0x22, 0xB7,
+	0x05, 0xF8, 0xE4, 0xB7, 0xD7,
+	0x0F, 0x4D, 0xFE, 0x32, 0x8D,
+	0x03, 0xEA, 0xA1, 0xD6, 0x6B,
+	0x0F, 0xEC, 0x43, 0x5B, 0x45,
+	0x00, 0xDE, 0xAD, 0x02, 0x95,
+	0x09, 0xDE, 0x5B, 0x34, 0xAC,
+	0x06, 0x8B, 0x4C, 0xE1, 0x48,
+	0x0D, 0x06, 0x80, 0x7F, 0xC1,
+	0x03, 0x8B, 0x59, 0x04, 0x95,
+	0x04, 0xF2, 0xE6, 0xC5, 0x7B,
+	0x08, 0xEB, 0x1A, 0x62, 0x20,
+	0x0C, 0x8C, 0x27, 0x2A, 0xFD,
+	0x06, 0x7E, 0x45, 0x0A, 0xD5,
+	0x0A, 0x49, 0x2F, 0xC9, 0x9E,
+	0x04, 0x3E, 0x65, 0x1A, 0x6D,
+	0x0D, 0x61, 0x2C, 0xB3, 0xC3,
+	0x01, 0x04, 0x16, 0xEC, 0x13,
+	0x05, 0x28, 0x14, 0x2B, 0xCB,
+	0x04, 0x1C, 0xA9, 0x3D, 0x42,
+	0x0E, 0x2B, 0xC2, 0xF6, 0xFF,
+	0x02, 0xF2, 0x3F, 0x83, 0xDB,
+	0x0B, 0x30, 0xE9, 0x4E, 0xD4,
+	0x0C, 0x4F, 0x9B, 0x91, 0xC6,
+	0x09, 0xC4, 0x84, 0x40, 0x16,
+	0x04, 0x7C, 0x55, 0x86, 0xC6,
+	0x00, 0x88, 0x55, 0xA7, 0xE8,
+	0x0E, 0xDD, 0xF3, 0x53, 0x35,
+	0x03, 0x48, 0x25, 0xBF, 0xA2,
+	0x0B, 0x59, 0x27, 0x8F, 0x8D,
+	0x01, 0x5F, 0xD8, 0x2D, 0x4F,
+	0x08, 0x0B, 0x57, 0x97, 0x74,
+	0x05, 0xD3, 0x5A, 0xEA, 0x21,
+	0x08, 0x07, 0xFC, 0x9A, 0x1D,
+	0x0D, 0xFF, 0x47, 0xBE, 0x19,
+	0x08, 0x20, 0x9D, 0xA3, 0xFD,
+	0x07, 0x16, 0x23, 0x8D, 0xAF,
+	0x05, 0x8B, 0xA0, 0x42, 0x35,
+	0x07, 0x29, 0x1C, 0xE9, 0xB9,
+	0x08, 0x2B, 0x4F, 0x99, 0x2B,
+	0x03, 0x26, 0xA6, 0x20, 0x09,
+	0x08, 0x6A, 0x7F, 0x45, 0xB7,
+	0x0E, 0xCF, 0x1C, 0xF4, 0x20,
+	0x07, 0xB0, 0x5A, 0xFA, 0x93,
+	0x0C, 0xAF, 0xAE, 0xE0, 0x73,
+	0x0F, 0x77, 0xCF, 0xC8, 0x67,
+	0x0B, 0xDB, 0x34, 0x35, 0x87,
+	0x05, 0x8D, 0x0D, 0x5F, 0xCD,
+	0x09, 0x3B, 0x47, 0xDF, 0x38,
+	0x06, 0x47, 0x1B, 0x17, 0x2B,
+	0x0D, 0x02, 0x04, 0x61, 0x00,
+	0x0A, 0x1B, 0xD0, 0xF2, 0x12,
+	0x0A, 0x9F, 0xB2, 0x4B, 0x45,
+	0x05, 0x4C, 0x40, 0x63, 0x28,
+	0x09, 0x7C, 0x90, 0x9D, 0x65,
+	0x0E, 0x3E, 0xE8, 0x3B, 0xF3,
+	0x0B, 0x37, 0x84, 0x53, 0x2C,
+	0x02, 0x5D, 0xC0, 0xA7, 0x47,
+	0x07, 0xA8, 0x90, 0x8E, 0x2F,
+	0x0A, 0x6A, 0xB7, 0x87, 0xC5,
+	0x02, 0xF8, 0xBA, 0x10, 0x70,
+	0x0A, 0x8F, 0x3E, 0x6C, 0x6F,
+	0x06, 0x36, 0x2E, 0x26, 0x22,
+	0x0A, 0x8A, 0xD9, 0xF2, 0xAC,
+	0x07, 0xA6, 0xE4, 0x5E, 0xE9,
+	0x04, 0xE6, 0xE7, 0xFF, 0x9F,
+	0x05, 0x80, 0xC6, 0x11, 0xAB,
+	0x01, 0x16, 0x3A, 0x8B, 0x04,
+	0x01, 0xD2, 0x2B, 0x6E, 0xF8,
+	0x07, 0xEA, 0xA3, 0xD2, 0x86,
+	0x07, 0x81, 0xCE, 0x93, 0xEC,
+	0x09, 0x21, 0x1C, 0x2F, 0x6C,
+	0x0B, 0x6D, 0x14, 0x78, 0x3D,
+	0x01, 0x73, 0x20, 0x9A, 0xA9,
+	0x05, 0xFE, 0xA9, 0xAA, 0x19,
+	0x01, 0x5C, 0x4C, 0x04, 0x0C,
+	0x0D, 0x84, 0xE5, 0x18, 0x57,
+	0x01, 0xC9, 0xA1, 0x5A, 0x47,
+	0x05, 0x2D, 0xFA, 0xB5, 0x09,
+	0x0D, 0x8C, 0xA3, 0x4B, 0xC1,
+	0x04, 0x75, 0x16, 0x78, 0xFB,
+	0x0B, 0x54, 0xC6, 0x02, 0xD7,
+	0x05, 0x40, 0xA5, 0x77, 0x33,
+	0x08, 0x1F, 0x56, 0xAD, 0xA7,
+	0x0F, 0x3B, 0x5E, 0xD9, 0x95,
+	0x02, 0x1F, 0xC7, 0xFB, 0xDA,
+	0x0D, 0xC7, 0x2E, 0xD4, 0x21,
+	0x05, 0xB0, 0xD2, 0x78, 0xC7,
+	0x08, 0x98, 0x88, 0x04, 0x23,
+	0x01, 0xCA, 0x30, 0xDE, 0x5B,
+	0x0B, 0x43, 0x74, 0xFD, 0xB2,
+	0x07, 0xC0, 0x6A, 0x66, 0x35,
+	0x05, 0x46, 0xD7, 0xF4, 0x6F,
+	0x07, 0x2E, 0x71, 0xF7, 0x79,
+	0x01, 0xBB, 0xC5, 0xAF, 0x93,
+	0x0A, 0xCC, 0x6B, 0xEE, 0x07,
+	0x06, 0x4F, 0x72, 0x44, 0x9B,
+	0x0C, 0xBC, 0x13, 0x43, 0x8A,
+	0x03, 0xE0, 0xD7, 0x85, 0xF4,
+	0x0E, 0x52, 0x00, 0x39, 0xC9,
+	0x0E, 0xA4, 0xF1, 0xB5, 0x4A,
+	0x0A, 0x96, 0x96, 0xC6, 0x13,
+	0x09, 0x61, 0x35, 0x77, 0x14,
+	0x0E, 0xEE, 0xB0, 0x29, 0x3E,
+	0x08, 0xD4, 0x9F, 0xC6, 0x06,
+	0x01, 0x2F, 0x6E, 0x31, 0xE3,
+	0x05, 0xE3, 0x2A, 0x83, 0x63,
+	0x0A, 0x0B, 0x70, 0x95, 0x1F,
+	0x09, 0xE5, 0xDC, 0xCE, 0x77,
+	0x07, 0x3A, 0x69, 0x0C, 0xA1,
+	0x02, 0xE4, 0xE7, 0x78, 0xBF,
+	0x0B, 0xEE, 0xF0, 0x99, 0x00,
+	0x0B, 0x68, 0xDC, 0x66, 0xD8,
+	0x04, 0xE3, 0xEC, 0x62, 0x6B,
+	0x0B, 0x96, 0x25, 0xA7, 0x2A,
+	0x09, 0x7B, 0x12, 0xC5, 0x0B,
+	0x0F, 0xF6, 0xFD, 0x6F, 0xFF,
+	0x05, 0x98, 0x23, 0xA5, 0x07,
+	0x04, 0x57, 0xD5, 0xAC, 0xB3,
+	0x0F, 0xDD, 0x06, 0xB6, 0xEC,
+	0x0A, 0x8C, 0xAA, 0x05, 0x1D,
+	0x07, 0xB8, 0x5C, 0xE9, 0x0A,
+	0x09, 0x10, 0x59, 0xC2, 0xCE,
+	0x01, 0x0E, 0x30, 0xFF, 0xBA,
+	0x04, 0x91, 0xAB, 0x09, 0x4E,
+	0x0D, 0xE7, 0xE2, 0x8A, 0x8C,
+	0x0A, 0xD4, 0x04, 0xC4, 0x76,
+	0x0D, 0x18, 0x25, 0x15, 0xBE,
+	0x08, 0xDD, 0x5E, 0x55, 0x9D,
+	0x00, 0x92, 0x4F, 0x93, 0x68,
+	0x0B, 0x9E, 0x54, 0xB4, 0xBF,
+	0x0E, 0xC7, 0xCE, 0xE7, 0xB9,
+	0x01, 0x8A, 0x26, 0xD5, 0xA4,
+	0x01, 0x54, 0x59, 0x97, 0xA3,
+	0x0C, 0x39, 0x44, 0xFA, 0xDF,
+	0x08, 0x33, 0x41, 0xAD, 0xA2,
+	0x01, 0xE1, 0xD0, 0xC7, 0xA3,
+	0x02, 0x64, 0x12, 0x5D, 0xA0,
+	0x06, 0x1B, 0xF5, 0x23, 0xCD,
+	0x02, 0x0B, 0xE8, 0x80, 0x82,
+	0x0A, 0x9D, 0x22, 0x8D, 0xED,
+	0x05, 0x14, 0x04, 0xCF, 0xC4,
+	0x09, 0xBF, 0xB0, 0x26, 0x69,
+	0x0A, 0x12, 0xC0, 0xFF, 0x45,
+	0x04, 0xB3, 0x44, 0x1F, 0x75,
+	0x06, 0xDB, 0x08, 0x5A, 0xCC,
+	0x04, 0x14, 0x80, 0xEE, 0xFD,
+	0x08, 0x22, 0x43, 0xD4, 0x48,
+	0x0F, 0x0B, 0xDB, 0x34, 0x3B,
+	0x0F, 0xFE, 0x07, 0x7C, 0x66,
+	0x04, 0x27, 0xFB, 0x47, 0xAD,
+	0x0A, 0x28, 0x47, 0x1B, 0x64,
+	0x08, 0x90, 0xF8, 0x84, 0x61,
+	0x05, 0x64, 0x1B, 0xD3, 0x44,
+	0x04, 0x56, 0xDF, 0xB2, 0x7C,
+	0x02, 0x4F, 0x4C, 0xC0, 0x5B,
+	0x04, 0xD2, 0x3E, 0x8B, 0x24,
+	0x0E, 0x18, 0xA7, 0xE8, 0x35,
+	0x0B, 0x60, 0x9A, 0xF5, 0x4D,
+	0x05, 0x5F, 0xBD, 0xC0, 0xD1,
+	0x05, 0xEB, 0x3C, 0x90, 0xF6,
+	0x0B, 0xB7, 0x9C, 0x37, 0xBD,
+	0x00, 0x1E, 0x50, 0xB9, 0xAB,
+	0x01, 0xF0, 0x11, 0xBE, 0x6C,
+	0x08, 0x8E, 0x99, 0x2E, 0x10,
+	0x09, 0x86, 0x43, 0xCF, 0xFB,
+	0x00, 0x37, 0xF5, 0x24, 0x64,
+	0x01, 0x3F, 0xCA, 0x16, 0xC9,
+	0x06, 0x99, 0x44, 0x06, 0x69,
+	0x09, 0xFD, 0x39, 0xFA, 0xD6,
+	0x00, 0x7D, 0xD0, 0xAB, 0x6D,
+	0x08, 0xEB, 0x0A, 0xA0, 0x12,
+	0x05, 0x39, 0xE1, 0xCE, 0x53,
+	0x0D, 0x50, 0xBB, 0x9C, 0x2B,
+	0x00, 0xD0, 0xC0, 0x8F, 0xE5,
+	0x01, 0xF1, 0xDD, 0xA0, 0x9D,
+	0x06, 0x98, 0xD5, 0x58, 0xA9,
+	0x06, 0x6C, 0xC7, 0xCC, 0x45,
+	0x0E, 0x11, 0x44, 0xE5, 0x6E,
+	0x03, 0x4D, 0xE7, 0x61, 0x47,
+	0x05, 0x4F, 0x9B, 0xF9, 0x35,
+	0x0B, 0x01, 0x8C, 0xA3, 0x4B,
+	0x0A, 0x2C, 0x77, 0x96, 0x78,
+	0x07, 0xA0, 0x12, 0xDD, 0x8B,
+	0x0B, 0xD5, 0x70, 0xE5, 0x64,
+	0x0F, 0x03, 0x1D, 0xA5, 0x2E,
+	0x0B, 0xC3, 0xD8, 0x5E, 0x19,
+	0x0B, 0xDF, 0xBE, 0xF0, 0x3B,
+	0x0E, 0xE6, 0x42, 0x69, 0xD9,
+	0x04, 0x79, 0x11, 0x52, 0x78,
+	0x03, 0xB8, 0x58, 0x84, 0x04,
+	0x09, 0x08, 0x68, 0x30, 0xDF,
+	0x07, 0x91, 0x86, 0x74, 0xF4,
+	0x0A, 0xDB, 0x52, 0x68, 0xE6,
+	0x0A, 0x19, 0x86, 0x95, 0x74,
+	0x01, 0x25, 0xCE, 0xFD, 0xF7,
+	0x0B, 0xAC, 0x1F, 0x85, 0xEF,
+	0x01, 0x07, 0xA9, 0x72, 0xEE,
+	0x0D, 0x3B, 0xEA, 0x5D, 0x45,
+	0x0D, 0xF7, 0xBD, 0x33, 0x43,
+	0x0C, 0x3F, 0xE0, 0xF7, 0xC5,
+	0x00, 0x82, 0x94, 0x74, 0x70,
+	0x03, 0x62, 0xA6, 0x71, 0xB5,
+	0x01, 0x31, 0x12, 0x06, 0x8C,
+	0x03, 0x95, 0x63, 0xBD, 0x37,
+	0x0E, 0x85, 0xAD, 0xFB, 0x2D,
+	0x0B, 0xE4, 0x10, 0x8C, 0x0F,
+	0x0B, 0x0D, 0xCF, 0xEA, 0x31,
+	0x0A, 0x59, 0x27, 0x2E, 0x8A,
+	0x02, 0x97, 0xEB, 0x5D, 0xD5,
+	0x0B, 0x64, 0x05, 0xDE, 0x8E,
+	0x08, 0x9E, 0x7D, 0xC9, 0x05,
+	0x09, 0x7B, 0x66, 0x83, 0xB8,
+	0x07, 0xC1, 0xED, 0x8F, 0x53,
+	0x04, 0xA7, 0x6A, 0xF3, 0xE6,
+	0x09, 0x48, 0x24, 0x6A, 0xEB,
+	0x02, 0x20, 0x10, 0x8C, 0x2D,
+	0x06, 0xC3, 0x29, 0xAE, 0x4C,
+	0x0A, 0xD3, 0xF6, 0x49, 0x6F,
+	0x00, 0x29, 0x78, 0x0E, 0xE5,
+	0x00, 0x5E, 0x61, 0xE3, 0xEC,
+	0x03, 0xC7, 0xDD, 0x06, 0xB7,
+	0x06, 0x17, 0x01, 0x2A, 0x04,
+	0x07, 0xCB, 0x97, 0xDC, 0xF4,
+	0x01, 0x75, 0x12, 0xD9, 0xC1,
+	0x0F, 0x4D, 0xEE, 0xF0, 0xBF,
+	0x0A, 0x5D, 0x77, 0x32, 0xC9,
+	0x04, 0xD0, 0x5B, 0xCD, 0x82,
+	0x0D, 0xC6, 0xD6, 0x04, 0xFD,
+	0x09, 0x21, 0xD8, 0x40, 0x15,
+	0x0A, 0xF4, 0x68, 0x8A, 0x1C,
+	0x07, 0xEC, 0x92, 0xDF, 0x93,
+	0x0A, 0xB2, 0x58, 0xC8, 0xB4,
+	0x05, 0xA3, 0x78, 0xD9, 0x27,
+	0x03, 0xBA, 0xB5, 0x6D, 0xD1,
+	0x0D, 0x7D, 0x54, 0x0A, 0x57,
+	0x0E, 0xF2, 0x79, 0xD0, 0xFA,
+	0x00, 0x25, 0x8C, 0x05, 0xAD,
+	0x06, 0x1D, 0xD1, 0xBF, 0x1A,
+	0x07, 0xAE, 0x84, 0x1E, 0x9D,
+	0x0A, 0x41, 0x7B, 0x15, 0xE3,
+	0x07, 0xAA, 0x35, 0x88, 0xA0,
+	0x0E, 0x30, 0x5C, 0xAB, 0x04,
+	0x09, 0xB9, 0x14, 0x2B, 0x4F,
+	0x00, 0xA7, 0xFF, 0x24, 0x26,
+	0x0A, 0x30, 0x2B, 0xE9, 0x3F,
+	0x05, 0x8E, 0xB2, 0xC3, 0x1E,
+	0x08, 0x1A, 0x1C, 0xB0, 0x53,
+	0x0A, 0xA8, 0x14, 0xA3, 0x24,
+	0x0C, 0x73, 0x63, 0xB5, 0xDD,
+	0x04, 0x67, 0xCC, 0x1B, 0x3D,
+	0x0B, 0xC3, 0xFE, 0x0D, 0xFC,
+	0x0C, 0xC8, 0x25, 0x39, 0xEC,
+	0x07, 0x36, 0x28, 0x47, 0x1B,
+	0x0B, 0x12, 0x91, 0x80, 0x99,
+	0x09, 0x39, 0xD6, 0x17, 0xD3,
+	0x0A, 0x26, 0xD6, 0x9F, 0x72,
+	0x07, 0x7D, 0x4D, 0x4C, 0xF4,
+	0x0F, 0x28, 0xC2, 0xFE, 0xBE,
+	0x01, 0x66, 0xFE, 0x3E, 0xDE,
+	0x09, 0xB7, 0x20, 0xB5, 0xC2,
+	0x0C, 0x28, 0xED, 0x9D, 0xF8,
+	0x0B, 0x49, 0x8F, 0x28, 0xA9,
+	0x05, 0x94, 0xFC, 0xEC, 0x4C,
+	0x0B, 0xFD, 0x60, 0xF8, 0xA4,
+	0x08, 0xCA, 0xD6, 0x81, 0xBE,
+	0x07, 0xD0, 0x32, 0xB6, 0xAE,
+	0x0A, 0x22, 0x75, 0x08, 0xCB,
+	0x00, 0xAC, 0x31, 0xA2, 0x64,
+	0x00, 0xAD, 0x3F, 0x64, 0x96,
+	0x0D, 0x9A, 0x59, 0x80, 0xC6,
+	0x01, 0xA5, 0xFD, 0x16, 0x3A,
+	0x0A, 0x3D, 0xBD, 0xD0, 0x6B,
+	0x0E, 0xC1, 0x6B, 0xEA, 0xA0,
+	0x02, 0xBC, 0xB9, 0x85, 0x44,
+	0x0F, 0xD7, 0x11, 0x21, 0xAB,
+	0x03, 0x5E, 0xD0, 0xEF, 0x3D,
+	0x04, 0x3E, 0x31, 0x73, 0x24,
+	0x08, 0xEE, 0xFE, 0x7C, 0xDD,
+	0x02, 0x9E, 0x7C, 0x5C, 0x4C,
+	0x08, 0x02, 0x11, 0xC4, 0xEB,
+	0x04, 0x6F, 0x4D, 0x88, 0x99,
+	0x06, 0x7D, 0x09, 0x2D, 0xC0,
+	0x09, 0x33, 0x02, 0x0C, 0x99,
+	0x07, 0xFA, 0x2C, 0x75, 0xAD,
+	0x00, 0xFB, 0x20, 0xD6, 0xDD,
+	0x09, 0x55, 0xCE, 0xC0, 0xA5,
+	0x05, 0x76, 0x83, 0x9D, 0x3A,
+	0x02, 0xA1, 0x43, 0x38, 0x6A,
+	0x05, 0xA2, 0x1E, 0x1F, 0xC5,
+	0x07, 0xE2, 0xF6, 0x41, 0x1F,
+	0x06, 0x3C, 0xB9, 0xB1, 0x65,
+	0x04, 0xDB, 0xF8, 0x98, 0xB0,
+	0x08, 0x23, 0x6E, 0xCA, 0x89,
+	0x05, 0x18, 0x6A, 0xC2, 0x4F,
+	0x01, 0x91, 0x5B, 0xF2, 0x6E,
+	0x0D, 0x81, 0x68, 0x45, 0x92,
+	0x08, 0x58, 0xEB, 0x6C, 0xFF,
+	0x0B, 0x41, 0xED, 0xBB, 0x32,
+	0x03, 0xAA, 0x81, 0x0A, 0xCA,
+	0x02, 0x04, 0x3A, 0x4F, 0x64,
+	0x08, 0x86, 0x73, 0x3D, 0x89,
+	0x0F, 0xBC, 0x3F, 0xE0, 0xCC,
+	0x0D, 0xCC, 0x02, 0x5F, 0xB4,
+	0x02, 0x71, 0x79, 0x24, 0x71,
+	0x09, 0x72, 0xF1, 0x10, 0x31,
+	0x0E, 0x13, 0x15, 0x6D, 0xBD,
+	0x0C, 0xA0, 0x9E, 0xE9, 0xFB,
+	0x08, 0xB7, 0xA4, 0xD4, 0xFB,
+	0x0A, 0x31, 0x8D, 0x2F, 0xEC,
+	0x0D, 0xD5, 0x79, 0xE3, 0xEB,
+	0x08, 0xD9, 0x67, 0x0B, 0x6D,
+	0x09, 0x01, 0x55, 0xE5, 0xD8,
+	0x02, 0x77, 0x7E, 0xBA, 0x8C,
+	0x07, 0x63, 0x6A, 0x66, 0xB5,
+	0x04, 0x7F, 0xC4, 0x6F, 0x82,
+	0x09, 0x04, 0xA5, 0x68, 0xF3,
+	0x06, 0xC5, 0x4A, 0xE3, 0x60,
+	0x0E, 0x62, 0x5D, 0x90, 0x85,
+	0x07, 0x2A, 0xC1, 0x7A, 0x6E,
+	0x05, 0x0A, 0xD1, 0xFA, 0x43,
+	0x03, 0xC9, 0xA9, 0x98, 0x11,
+	0x09, 0x1A, 0x5F, 0xD1, 0x6B,
+	0x06, 0x73, 0xC5, 0x5E, 0xC0,
+	0x06, 0x6D, 0xB2, 0x3E, 0xAA,
+	0x0B, 0xAA, 0xFB, 0xB8, 0x1C,
+	0x05, 0x3D, 0x08, 0x92, 0x10,
+	0x02, 0xF6, 0xCF, 0x0E, 0xF0,
+	0x0F, 0x83, 0xDF, 0x17, 0x32,
+	0x01, 0x4E, 0x53, 0xE5, 0x4D,
+	0x00, 0x90, 0x27, 0x55, 0x84,
+	0x08, 0x40, 0x5C, 0x98, 0x47,
+	0x05, 0x86, 0xF6, 0xDC, 0x8A,
+	0x05, 0xA7, 0xEE, 0x9E, 0xD5,
+	0x0F, 0x53, 0x30, 0x18, 0xD7,
+	0x08, 0xBF, 0xA2, 0xC7, 0x51,
+	0x0D, 0x4F, 0xB8, 0x8E, 0xBE,
+	0x08, 0xAC, 0xD9, 0xD4, 0x0A,
+	0x09, 0x16, 0x9D, 0xB9, 0xD2,
+	0x06, 0xEA, 0x59, 0xB3, 0x8C,
+	0x0D, 0x9A, 0x1F, 0xE1, 0xFF,
+	0x07, 0xBE, 0x2E, 0x64, 0x12,
+	0x05, 0xA3, 0x4D, 0x99, 0x95,
+	0x09, 0x8C, 0x43, 0x89, 0xC8,
+	0x0F, 0xC2, 0x30, 0x9C, 0xAB,
+	0x01, 0xE9, 0xC4, 0x94, 0x22,
+	0x0F, 0xD9, 0x27, 0xBF, 0x26,
+	0x06, 0x60, 0x33, 0x94, 0x63,
+	0x05, 0x44, 0xAD, 0x32, 0xCE,
+	0x03, 0x64, 0x1A, 0xDB, 0xB6,
+	0x06, 0xFA, 0xA8, 0x14, 0xA8,
+	0x06, 0xE0, 0xF3, 0x26, 0x75,
+	0x0E, 0x49, 0x94, 0x8B, 0xFB,
+	0x0C, 0x38, 0xC3, 0xFC, 0x8F,
+	0x0C, 0x5C, 0xC8, 0x25, 0x3B,
+	0x07, 0x9F, 0x36, 0x2E, 0x4D,
+	0x0B, 0x57, 0x13, 0x15, 0x00,
+	0x04, 0x61, 0x3B, 0x56, 0x1B,
+	0x0F, 0x71, 0x68, 0x56, 0x9B,
+	0x0E, 0x4B, 0x3E, 0x0D, 0x49,
+	0x0B, 0xE1, 0x2B, 0x52, 0xFE,
+	0x07, 0x19, 0x65, 0x9E, 0x3A,
+	0x04, 0x35, 0x17, 0x20, 0xB0,
+	0x0E, 0xD2, 0x2A, 0xDE, 0x5D,
+	0x0C, 0xE7, 0x49, 0xEB, 0x96,
+	0x0A, 0xCF, 0xFA, 0x36, 0x69,
+	0x07, 0x87, 0xFC, 0x12, 0x7C,
+	0x09, 0x90, 0x4A, 0x7A, 0x4A,
+	0x04, 0x8C, 0x49, 0x8A, 0x32,
+	0x0E, 0x26, 0x22, 0x11, 0x08,
+	0x02, 0x72, 0xAC, 0x27, 0xA6,
+	0x04, 0x50, 0xAD, 0x2F, 0xD5,
+	0x06, 0xFC, 0x9A, 0x89, 0x32,
+	0x06, 0x51, 0xA5, 0xED, 0xA5,
+	0x0A, 0xCB, 0x3C, 0x6D, 0x64,
+	0x0B, 0x6E, 0xC1, 0x7B, 0x5F,
+	0x00, 0x52, 0xBC, 0x9B, 0x37,
+	0x0E, 0x93, 0xD7, 0x51, 0x96,
+	0x0C, 0x2F, 0x6C, 0xD0, 0x57,
+	0x0F, 0xF8, 0x3D, 0xED, 0x31,
+	0x00, 0x94, 0xED, 0x02, 0xFE,
+	0x08, 0xA9, 0x1C, 0x71, 0x9E,
+	0x0C, 0x44, 0x02, 0x0C, 0x86,
+	0x05, 0x58, 0x6F, 0x50, 0x8A,
+	0x01, 0x5A, 0x7E, 0xD4, 0xAF,
+	0x09, 0x35, 0x33, 0x1C, 0x4E,
+	0x03, 0x4B, 0xFA, 0x02, 0x77,
+	0x08, 0xF9, 0xCB, 0xA0, 0xD6,
+	0x06, 0x82, 0xD7, 0xD5, 0x40,
+	0x09, 0x46, 0xB7, 0x03, 0x8E,
+	0x0B, 0xAE, 0x82, 0x43, 0x2C,
+	0x04, 0x19, 0xB1, 0xDA, 0x3F,
+	0x00, 0x7B, 0xE2, 0xF6, 0x41,
+	0x09, 0xDA, 0x3C, 0xE9, 0xB1,
+	0x0A, 0x38, 0x5A, 0xA8, 0x18,
+	0x00, 0x84, 0x83, 0x49, 0x4A,
+	0x09, 0xDE, 0x5B, 0xA1, 0xC2,
+	0x0D, 0x7D, 0x72, 0x6B, 0x72,
+	0x03, 0xE7, 0xE3, 0x29, 0xC6,
+	0x0E, 0xF5, 0x98, 0xBB, 0xAC,
+	0x09, 0x76, 0xE1, 0xBD, 0x3B,
+	0x0D, 0xAE, 0x2A, 0x91, 0xCA,
+	0x02, 0xEE, 0x07, 0x2A, 0xFE,
+	0x0D, 0x44, 0x86, 0x20, 0x0F,
+	0x03, 0x43, 0xBC, 0x0F, 0x53,
+	0x07, 0xC5, 0xCC, 0xB2, 0xE7,
+	0x04, 0x79, 0xF3, 0x52, 0xA4,
+	0x01, 0xB5, 0x71, 0x2D, 0x52,
+	0x08, 0x46, 0x13, 0x89, 0xE3,
+	0x0D, 0x37, 0x22, 0x99, 0xAB,
+	0x0B, 0x24, 0xB7, 0xC9, 0xD6,
+	0x0C, 0x06, 0x32, 0x99, 0x2D,
+	0x08, 0xB1, 0xD6, 0x4D, 0xA1,
+	0x0E, 0x83, 0x5B, 0x62, 0x89,
+	0x0F, 0x55, 0x02, 0xB1, 0x27,
+	0x07, 0x0E, 0x74, 0x9E, 0xBA,
+	0x05, 0x0D, 0xFE, 0xBB, 0x65,
+	0x0B, 0x79, 0x7F, 0xC1, 0xEC,
+	0x03, 0x99, 0x84, 0xA7, 0x28,
+	0x0B, 0x66, 0x65, 0x48, 0xA3,
+	0x03, 0x62, 0x82, 0x20, 0x10,
+	0x00, 0x27, 0x2A, 0x83, 0x6B,
+	0x02, 0x7A, 0xF5, 0x13, 0xE6,
+	0x09, 0x6F, 0xC9, 0xA5, 0x0E,
+	0x04, 0x66, 0x1A, 0x7B, 0xCC,
+	0x0B, 0x2E, 0x1B, 0xF3, 0x83,
+	0x04, 0xB6, 0xE4, 0x36, 0x3E,
+	0x08, 0x05, 0x2B, 0xFB, 0x38,
+	0x0D, 0xA9, 0xFD, 0x75, 0x12,
+	0x08, 0x82, 0x36, 0xCD, 0x0E,
+	0x09, 0x7E, 0x63, 0xD3, 0x17,
+	0x02, 0x09, 0x4E, 0xF7, 0x65,
+	0x0D, 0x8A, 0x91, 0xE0, 0x57,
+	0x0A, 0x45, 0x70, 0x21, 0x18,
+	0x07, 0x5F, 0xE6, 0xF9, 0x1C,
+	0x00, 0x17, 0xB4, 0x6C, 0x96,
+	0x04, 0x93, 0x53, 0x30, 0x18,
+	0x06, 0x34, 0xBF, 0x22, 0xD7,
+	0x05, 0x77, 0x8F, 0xBA, 0x01,
+	0x01, 0xD9, 0xD3, 0xBD, 0x49,
+	0x02, 0x57, 0x17, 0x74, 0x26,
+	0x08, 0x78, 0xF5, 0x24, 0x73,
+	0x09, 0xED, 0x9A, 0x1D, 0xED,
+	0x04, 0x85, 0x86, 0xAE, 0x64,
+	0x02, 0x9D, 0xA3, 0xC1, 0x96,
+	0x0C, 0xA1, 0x6D, 0xAB, 0x89,
+	0x00, 0x8A, 0x22, 0x3D, 0x5C,
+	0x01, 0x0F, 0xDC, 0x39, 0x1C,
+	0x03, 0xCF, 0x79, 0x28, 0x7F,
+	0x0E, 0x24, 0x40, 0x34, 0x66,
+	0x00, 0xFE, 0xA5, 0x80, 0xF2,
+	0x07, 0x9E, 0xD4, 0x14, 0x9B,
+	0x00, 0x5A, 0xFA, 0xAD, 0xD0,
+	0x03, 0x2F, 0x1E, 0xB3, 0xB9,
+	0x05, 0xD4, 0x48, 0x62, 0x4E,
+	0x0B, 0x34, 0x3B, 0xE3, 0xF7,
+	0x07, 0x74, 0xDC, 0xC8, 0xA5,
+	0x02, 0xCA, 0x7F, 0x16, 0xAA,
+	0x0F, 0x12, 0xD7, 0x13, 0x91,
+	0x09, 0x0D, 0x81, 0x19, 0xD6,
+	0x03, 0x5B, 0xD2, 0x28, 0xD6,
+	0x06, 0xBA, 0x8B, 0x4E, 0xCD,
+	0x04, 0x4A, 0x43, 0x18, 0x52,
+	0x07, 0x82, 0xDF, 0x45, 0x1E,
+	0x0E, 0xE8, 0x35, 0x81, 0x6A,
+	0x0D, 0xF5, 0xC0, 0x19, 0x9E,
+	0x07, 0xC2, 0xCC, 0xC9, 0xCB,
+	0x09, 0x95, 0x0E, 0x17, 0xB6,
+	0x09, 0xF2, 0x67, 0xFC, 0x1E,
+	0x00, 0xB9, 0x18, 0x48, 0xF6,
+	0x0D, 0x3E, 0x6C, 0x52, 0x0E,
+	0x04, 0xAE, 0x26, 0xA4, 0xC1,
+	0x0B, 0xC3, 0xF2, 0x2A, 0xBD,
+	0x05, 0x65, 0xF8, 0xAB, 0xF5,
+	0x05, 0x17, 0x1F, 0x1A, 0x99,
+	0x01, 0xC4, 0x19, 0x25, 0xFD,
+	0x06, 0x3A, 0xCB, 0x3C, 0x7D,
+	0x00, 0xEE, 0xC5, 0x41, 0x6B,
+	0x0A, 0xA2, 0x50, 0xBC, 0xBB,
+	0x01, 0x4F, 0x33, 0xD7, 0x51,
+	0x01, 0x9D, 0xAF, 0x7A, 0x52,
+	0x0F, 0x8E, 0x58, 0x3B, 0x33,
+	0x0A, 0xA2, 0x60, 0xC1, 0x9E,
+	0x0C, 0xD8, 0xB9, 0x0A, 0x6F,
+	0x0C, 0x4C, 0x44, 0x24, 0x53,
+	0x0A, 0x64, 0x68, 0x6F, 0x4D,
+	0x04, 0xA1, 0x5A, 0xFE, 0xD9,
+	0x01, 0xF9, 0x35, 0x73, 0x0F,
+	0x06, 0xA1, 0x6B, 0xFA, 0x2D,
+	0x09, 0x97, 0x86, 0x3B, 0xBD,
+	0x06, 0xDD, 0x82, 0xD7, 0xD5,
+	0x08, 0xA5, 0xF9, 0x77, 0xC3,
+	0x07, 0x25, 0x96, 0xA2, 0x63,
+	0x03, 0xDC, 0xE1, 0x21, 0xDE,
+	0x04, 0xF0, 0x7B, 0xE2, 0xE6,
+	0x0D, 0x29, 0xDA, 0xBC, 0xCC,
+	0x08, 0x52, 0xF8, 0xDA, 0xB8,
+	0x00, 0x08, 0xA4, 0x23, 0x09,
+	0x00, 0xB2, 0xE5, 0x9B, 0x90,
+	0x0A, 0x35, 0x5D, 0x9F, 0x1B,
+	0x0A, 0x78, 0x46, 0x0E, 0xD9,
+	0x0C, 0x95, 0xBF, 0xD8, 0xE3,
+	0x04, 0xF3, 0xD7, 0x44, 0x2D,
+	0x01, 0x07, 0xEC, 0xAA, 0x89,
+	0x02, 0xF2, 0x6E, 0x09, 0x7A,
+	0x06, 0x94, 0xC4, 0x83, 0x30,
+	0x05, 0xFA, 0xC3, 0xB9, 0xBF,
+	0x00, 0xF7, 0xC5, 0xC9, 0x46,
+	0x08, 0x36, 0x12, 0x76, 0x67,
+	0x0C, 0x79, 0x35, 0x7C, 0xF1,
+	0x08, 0x09, 0xC6, 0x1E, 0xD5,
+	0x09, 0xBC, 0xB7, 0x2C, 0xC5,
+	0x00, 0x32, 0xA4, 0xB2, 0xA4,
+	0x0C, 0x85, 0x86, 0x37, 0x0D,
+	0x0F, 0xE8, 0xB1, 0xD3, 0x9D,
+	0x08, 0x6C, 0xE8, 0xDE, 0x73,
+	0x03, 0x5F, 0xD5, 0x0C, 0xD5,
+	0x0C, 0x55, 0x8E, 0x79, 0x5E,
+	0x02, 0x88, 0x8C, 0xEC, 0x3B,
+	0x0F, 0x4E, 0x98, 0x7A, 0x81,
+	0x07, 0xC2, 0x19, 0x01, 0x27,
+	0x08, 0xF3, 0xE6, 0xC0, 0x8C,
+	0x08, 0xE8, 0x89, 0xE7, 0x25,
+	0x09, 0x14, 0xC7, 0x27, 0x03,
+	0x03, 0x69, 0x25, 0x0F, 0x53,
+	0x0E, 0x4B, 0x2F, 0xCC, 0x69,
+	0x02, 0x0E, 0x2C, 0x9A, 0x57,
+	0x08, 0xEB, 0x4C, 0xB6, 0x07,
+	0x07, 0x04, 0xF1, 0xEC, 0x17,
+	0x00, 0x2B, 0x35, 0x2B, 0xCB,
+	0x04, 0x1C, 0xE9, 0xBD, 0x65,
+	0x0E, 0x19, 0xC2, 0xB6, 0xC3,
+	0x04, 0xF2, 0xC5, 0x03, 0xDE,
+	0x07, 0x32, 0x09, 0x40, 0x95,
+	0x0B, 0xCD, 0x8A, 0x11, 0xF3,
+	0x0C, 0xD4, 0x04, 0x4D, 0xE1,
+	0x00, 0xCE, 0xF5, 0x86, 0xF4,
+	0x0C, 0x8A, 0x15, 0xA3, 0x5A,
+	0x0A, 0xDD, 0xB3, 0x5D, 0xB0,
+	0x02, 0xC8, 0x5F, 0xBF, 0xAA,
+	0x0E, 0x59, 0xA7, 0x8F, 0xBA,
+	0x05, 0x6F, 0x98, 0x20, 0x3D,
+	0x0E, 0x08, 0x3F, 0x17, 0x78,
+	0x05, 0xD3, 0x85, 0xEA, 0x39,
+	0x03, 0x85, 0xED, 0x97, 0x82,
+	0x03, 0xFF, 0x07, 0xBB, 0xAE,
+	0x0D, 0x92, 0x7D, 0xA3, 0xCF,
+	0x0B, 0x6D, 0xA3, 0x83, 0x7C,
+	0x09, 0x88, 0x80, 0x42, 0x30,
+	0x04, 0x83, 0x8D, 0xEC, 0xB9,
+	0x04, 0x2B, 0x4F, 0xD9, 0x25,
+	0x0F, 0x26, 0xA6, 0x65, 0x3C,
+	0x0C, 0x23, 0x1F, 0x48, 0x0E,
+	0x08, 0xCD, 0x78, 0xF4, 0x12,
+	0x07, 0xB1, 0xA5, 0xFA, 0xB5,
+	0x04, 0xAF, 0x2E, 0xE5, 0xAC,
+	0x06, 0xF5, 0xD4, 0x45, 0x27,
+	0x0B, 0xDB, 0x34, 0x3E, 0x70,
+	0x0E, 0x76, 0xBC, 0x59, 0xBA,
+	0x0D, 0xBA, 0xC7, 0x92, 0x76,
+	0x02, 0x46, 0x9B, 0x59, 0x53,
+	0x09, 0x81, 0x24, 0x6F, 0x79,
+	0x06, 0x1B, 0xD3, 0x77, 0x2C,
+	0x06, 0x9F, 0xB2, 0x4E, 0x3B,
+	0x0D, 0x4C, 0xCC, 0x46, 0xF7,
+	0x02, 0xFE, 0x9B, 0x0D, 0x6C,
+	0x07, 0x3E, 0x22, 0x05, 0x37,
+	0x02, 0xB5, 0xF5, 0xE0, 0xA3,
+	0x0C, 0x5D, 0xC3, 0x47, 0xC3,
+	0x09, 0xA8, 0x18, 0xCC, 0x97,
+	0x04, 0xE8, 0xC7, 0x85, 0x7C,
+	0x0E, 0xFA, 0xB9, 0xA0, 0x4A,
+	0x06, 0x0E, 0x9E, 0x5C, 0x54,
+	0x07, 0xB6, 0x4E, 0x26, 0xA2,
+	0x09, 0x0A, 0x82, 0xF4, 0xA6,
+	0x0F, 0x24, 0x87, 0xD6, 0xE7,
+	0x06, 0xE5, 0x74, 0xFE, 0x1A,
+	0x00, 0x81, 0x06, 0x73, 0x25,
+	0x0D, 0x16, 0x3A, 0xDD, 0x3E,
+	0x0D, 0xD0, 0x6B, 0x48, 0x83,
+	0x0B, 0xEA, 0xA0, 0x44, 0x3E,
+	0x0B, 0x81, 0xCE, 0x95, 0x15,
+	0x09, 0xA1, 0x3C, 0x23, 0xEC,
+	0x09, 0xEF, 0xCF, 0xF4, 0xFD,
+	0x08, 0xF1, 0xC0, 0x94, 0x2D,
+	0x00, 0xFD, 0xE8, 0xA9, 0x1C,
+	0x01, 0x5C, 0x4C, 0xC4, 0x12,
+	0x0D, 0x84, 0xE5, 0x18, 0x61,
+	0x07, 0xCA, 0xF4, 0x5A, 0x7F,
+	0x08, 0x2F, 0x39, 0x35, 0x33,
+	0x0B, 0x8E, 0xEC, 0xCB, 0xFB,
+	0x04, 0x3D, 0x16, 0x75, 0xBB,
+	0x09, 0xDE, 0x1D, 0x8F, 0x57,
+	0x05, 0x40, 0xA5, 0x7C, 0x42,
+	0x03, 0x1F, 0x87, 0xAB, 0x14,
+	0x09, 0x3A, 0x10, 0xD9, 0xA0,
+	0x05, 0x1F, 0xF0, 0x7B, 0xE2,
+	0x06, 0x41, 0x29, 0xCA, 0x3C,
+	0x09, 0xB1, 0x52, 0x18, 0xDA,
+	0x08, 0x98, 0x88, 0x14, 0x92,
+	0x09, 0xCA, 0xB0, 0xDE, 0x29,
+	0x01, 0x42, 0xB4, 0xFD, 0x21,
+	0x0B, 0xF2, 0x6A, 0x66, 0xB7,
+	0x09, 0x46, 0x97, 0xC1, 0x9C,
+	0x0B, 0x2C, 0xF1, 0xEB, 0x03,
+	0x0D, 0xBB, 0x05, 0x83, 0x28,
+	0x01, 0x4A, 0xF2, 0xF2, 0xC5,
+	0x01, 0x4F, 0x5D, 0x49, 0x84,
+	0x0C, 0xBD, 0xB3, 0xC3, 0xAF,
+	0x0F, 0xE0, 0xF7, 0xD5, 0xCC,
+	0x08, 0x93, 0xA4, 0x7D, 0x1D,
+	0x02, 0xA4, 0x71, 0xF5, 0x71,
+	0x01, 0x10, 0x08, 0x06, 0x13,
+	0x0D, 0x64, 0x3D, 0x77, 0xA2,
+	0x0D, 0xEC, 0x5B, 0x34, 0x37,
+	0x0D, 0xD1, 0x0C, 0x26, 0xB2,
+	0x04, 0xAA, 0x08, 0xA1, 0x56,
+	0x09, 0xE3, 0xEE, 0xC5, 0x59,
+	0x06, 0x0B, 0x5F, 0x13, 0x40,
+	0x05, 0xE5, 0xDC, 0x48, 0xF6,
+	0x0E, 0xBA, 0x89, 0x2A, 0x23,
+	0x00, 0x66, 0x87, 0x78, 0x7F,
+	0x01, 0xEF, 0x8B, 0x9F, 0x07,
+	0x0F, 0x68, 0x73, 0xE6, 0xC5,
+	0x02, 0x23, 0x72, 0xE6, 0x91,
+	0x00, 0x59, 0x08, 0xA7, 0x2A,
+	0x03, 0x33, 0xEA, 0x45, 0x0A,
+	0x01, 0xBF, 0xC9, 0xEF, 0x83,
+	0x09, 0xD1, 0x8C, 0x65, 0x1A,
+	0x0F, 0x98, 0xE3, 0xAC, 0xB3,
+	0x0C, 0xDD, 0x06, 0xB6, 0xEC,
+	0x06, 0xBE, 0xAA, 0x85, 0x2B,
+	0x03, 0xB8, 0x9C, 0x6F, 0x37,
+	0x05, 0x10, 0x19, 0xC2, 0xF6,
+	0x06, 0x0E, 0xF0, 0xFF, 0x83,
+	0x0F, 0x17, 0x32, 0x89, 0x4E,
+	0x01, 0xE7, 0xCD, 0x8A, 0x91,
+	0x06, 0xD4, 0x44, 0xC4, 0x40,
+	0x01, 0x18, 0x4E, 0x55, 0x86,
+	0x04, 0xDC, 0x8A, 0x15, 0xA7,
+	0x07, 0x92, 0xDF, 0x95, 0x59,
+	0x00, 0x18, 0xC8, 0x34, 0xBF,
+	0x0B, 0xE7, 0x9D, 0xE1, 0x8F,
+	0x0A, 0x0D, 0x69, 0x58, 0x2D,
+	0x0D, 0x54, 0x0E, 0xD5, 0x14,
+	0x00, 0x71, 0x56, 0x7A, 0xEA,
+	0x04, 0x7A, 0x01, 0xEF, 0x19,
+	0x0F, 0xA8, 0x7C, 0x81, 0x3E,
+	0x0E, 0x2D, 0x91, 0x1D, 0xE9,
+	0x0F, 0xD2, 0x96, 0xA5, 0x07,
+	0x0B, 0x89, 0x89, 0x00, 0x08,
+	0x00, 0x9C, 0xAB, 0x0D, 0xE9,
+	0x01, 0x74, 0xA9, 0x49, 0xD3,
+	0x0E, 0xBF, 0x26, 0xA6, 0x60,
+	0x0D, 0x95, 0x96, 0xBF, 0x74,
+	0x02, 0xBE, 0xCF, 0x1F, 0x46,
+	0x06, 0xF3, 0xB0, 0x5A, 0xE6,
+	0x04, 0x02, 0xAF, 0x2E, 0xF7,
+	0x03, 0xA4, 0xF1, 0xD4, 0x48,
+	0x0F, 0xA3, 0x7F, 0x34, 0xFB,
+	0x0B, 0xFE, 0x8F, 0x7C, 0x9C,
+	0x03, 0xA7, 0x9C, 0xC3, 0xC8,
+	0x0A, 0x3C, 0x47, 0x1B, 0x40,
+	0x03, 0x11, 0x04, 0x80, 0x45,
+	0x01, 0xFE, 0xBF, 0xD3, 0xB2,
+	0x00, 0x56, 0x1F, 0xB2, 0x8B,
+	0x05, 0xCF, 0xEB, 0x44, 0x34,
+	0x03, 0xD2, 0xFE, 0x8F, 0x38,
+	0x09, 0x9F, 0xC1, 0x28, 0x04,
+	0x0B, 0x6C, 0xB5, 0xF5, 0x62,
+	0x05, 0x76, 0x5D, 0xC0, 0xFB,
+	0x05, 0xFD, 0xA8, 0x90, 0xD9,
+	0x07, 0xB6, 0x6C, 0x77, 0x87,
+	0x04, 0xB6, 0x5C, 0xB9, 0x50,
+	0x02, 0x76, 0x0F, 0x3E, 0xAC,
+	0x0F, 0x0C, 0x91, 0x2A, 0x71,
+	0x0A, 0x81, 0xA8, 0xCF, 0xB2,
+	0x06, 0x35, 0x33, 0xE4, 0x10,
+	0x0D, 0x3F, 0x64, 0x92, 0xD8,
+	0x00, 0x9B, 0x1B, 0x46, 0x50,
+	0x0D, 0x7F, 0x36, 0x36, 0xCB,
+	0x06, 0x7F, 0x47, 0x6B, 0x2E,
+	0x01, 0x6B, 0xEA, 0xA4, 0x72,
+	0x06, 0xB9, 0x1A, 0x4E, 0x92,
+	0x0F, 0xD3, 0x01, 0x90, 0x2F,
+	0x06, 0xD2, 0x76, 0x0F, 0xB8,
+	0x0D, 0xF1, 0x73, 0x24, 0xB6,
+	0x07, 0x1C, 0xE7, 0x58, 0xA8,
+	0x04, 0xEF, 0x7C, 0x40, 0x44,
+	0x08, 0x13, 0x1F, 0xE5, 0x18,
+	0x0F, 0x4D, 0xC8, 0xA5, 0x7E,
+	0x04, 0xCB, 0xB6, 0x79, 0x34,
+	0x03, 0x01, 0x8C, 0xA7, 0x6D,
+	0x06, 0x3A, 0x75, 0x96, 0x6F,
+	0x0B, 0xA0, 0xD2, 0xDD, 0x82,
+	0x0F, 0x7D, 0xE4, 0xA5, 0xB9,
+	0x0F, 0x03, 0x1D, 0x27, 0x6E,
+	0x09, 0xC1, 0x9F, 0xDA, 0x8E,
+	0x09, 0x5E, 0xBF, 0xFD, 0xBB,
+	0x08, 0xE4, 0xE1, 0x29, 0x9A,
+	0x0C, 0xF9, 0xB1, 0x56, 0x1D,
+	0x00, 0xBA, 0x3E, 0x08, 0x05,
+	0x0B, 0x8B, 0xEA, 0xBC, 0xDE,
+	0x01, 0x93, 0xE0, 0xB4, 0xBD,
+	0x02, 0x5B, 0xF2, 0x6E, 0x47,
+	0x09, 0x1B, 0xE0, 0x17, 0xF5,
+	0x00, 0x69, 0x0C, 0xFD, 0xF7,
+	0x0B, 0xAF, 0x1F, 0x05, 0xEF,
+	0x0A, 0x81, 0x4A, 0xF6, 0xCD,
+	0x0D, 0x38, 0xE9, 0xDD, 0x45,
+	0x0E, 0xF2, 0x9D, 0xBF, 0x43,
+	0x06, 0x3D, 0x46, 0xF7, 0x85,
+	0x0C, 0x82, 0x53, 0xB0, 0x5C,
+	0x09, 0x60, 0x02, 0xF1, 0xB4,
+	0x01, 0x31, 0x10, 0x0C, 0x61,
+	0x03, 0x95, 0x61, 0xBD, 0x37,
+	0x09, 0x85, 0x69, 0xFB, 0x24,
+	0x0E, 0xE2, 0x54, 0xC0, 0x86,
+	0x0A, 0x0B, 0xAF, 0xE4, 0xF1,
+	0x0F, 0x19, 0x23, 0xEA, 0x03,
+	0x01, 0x74, 0xA7, 0x5F, 0x15,
+	0x08, 0x97, 0x4B, 0xDC, 0x4E,
+	0x04, 0x9E, 0xB2, 0x8D, 0x52,
+	0x01, 0x7B, 0x6E, 0x87, 0x78,
+	0x07, 0xC1, 0x63, 0x8B, 0x59,
+	0x0E, 0xA5, 0xD8, 0xF3, 0xE7,
+	0x0C, 0x4A, 0xA3, 0x66, 0xE2,
+	0x08, 0x22, 0xBE, 0x8C, 0x37,
+	0x0A, 0xC3, 0x7A, 0x6A, 0x0D,
+	0x00, 0xD1, 0x59, 0x49, 0x6E,
+	0x09, 0xA9, 0x9A, 0x08, 0x2C,
+	0x0A, 0x5F, 0xD3, 0x63, 0xAC,
+	0x0B, 0xC7, 0x5D, 0x04, 0x36,
+	0x0C, 0x16, 0xBE, 0xAA, 0x05,
+	0x03, 0xE3, 0x38, 0x18, 0xE9,
+	0x06, 0x75, 0x12, 0x19, 0xC2,
+	0x0F, 0x4D, 0xEE, 0xFE, 0x3F,
+	0x09, 0xDD, 0xD8, 0x32, 0x29,
+	0x0E, 0xD1, 0xE1, 0xCD, 0x8A,
+	0x01, 0xC6, 0xD1, 0x44, 0xC4,
+	0x00, 0x21, 0x1C, 0xCE, 0x55,
+	0x06, 0xF4, 0xD8, 0x08, 0x96,
+	0x07, 0x24, 0x36, 0xDF, 0x93,
+	0x03, 0xF9, 0xBC, 0xC8, 0xB7,
+	0x0D, 0x6B, 0x64, 0xDF, 0x67,
+	0x0F, 0x73, 0xAE, 0xED, 0x92,
+	0x0D, 0xB4, 0xF7, 0x8C, 0x5D,
+	0x07, 0x70, 0x38, 0x52, 0x30,
+	0x06, 0x24, 0x33, 0x81, 0xFC,
+	0x02, 0x9E, 0x41, 0x79, 0x4D,
+	0x0E, 0x2E, 0x60, 0x12, 0x9D,
+	0x03, 0xCF, 0x9F, 0x95, 0x23,
+	0x0F, 0xAB, 0x8D, 0x8E, 0xC0,
+	0x03, 0x30, 0x5B, 0x2B, 0x0D,
+	0x0A, 0xB8, 0xD4, 0x2D, 0x0F,
+	0x08, 0xA5, 0x5F, 0x26, 0xA6,
+	0x01, 0xB0, 0x74, 0x69, 0x7F,
+	0x0C, 0x8C, 0xD2, 0x49, 0x95,
+	0x05, 0x19, 0x1B, 0xB0, 0x5A,
+	0x03, 0xA9, 0xD4, 0x29, 0xE4,
+	0x00, 0x73, 0xA1, 0xF5, 0xD4,
+	0x08, 0x67, 0x0F, 0xDB, 0x34,
+	0x09, 0xC3, 0xFA, 0x09, 0xFC,
+	0x0D, 0xC8, 0xE1, 0x3B, 0xB4,
+	0x0E, 0x37, 0xEA, 0x47, 0xEF,
+	0x0E, 0x91, 0x51, 0x06, 0x71,
+	0x09, 0xB9, 0xF5, 0x19, 0x53,
+	0x02, 0x28, 0x56, 0x19, 0x38,
+	0x02, 0x7C, 0x6D, 0x41, 0x80,
+	0x01, 0x28, 0xD6, 0xF8, 0x4B,
+	0x04, 0xE6, 0xFE, 0xBC, 0x68,
+	0x04, 0xB5, 0x20, 0xB5, 0xC7,
+	0x0A, 0x2B, 0x98, 0xDD, 0xC2,
+	0x0E, 0xC9, 0x0C, 0xA8, 0x90,
+	0x0E, 0x17, 0xB3, 0x68, 0x77,
+	0x07, 0xFC, 0x1E, 0xF8, 0xB9,
+	0x00, 0xCA, 0xD6, 0x8F, 0x3E,
+	0x0C, 0xD5, 0x2E, 0x36, 0xAE,
+	0x0C, 0x20, 0xCB, 0x08, 0xC3,
+	0x0B, 0xAE, 0x53, 0xAA, 0x24,
+	0x0A, 0xAF, 0xF6, 0x64, 0x92,
+	0x08, 0x9A, 0x99, 0x8D, 0xC6,
+	0x01, 0xA5, 0xFD, 0x16, 0x3A,
+	0x0B, 0xF4, 0xDD, 0xD0, 0x6B,
+	0x0E, 0xC1, 0x6F, 0xEA, 0xA0,
+	0x02, 0xBC, 0xBB, 0x81, 0xCE,
+	0x01, 0xD7, 0x56, 0xA7, 0xD6,
+	0x03, 0x60, 0xD0, 0xEF, 0x16,
+	0x08, 0x95, 0x51, 0xF7, 0xEA,
+	0x0D, 0xEF, 0x3C, 0x7C, 0x18,
+	0x03, 0x1E, 0xA0, 0x5C, 0x44,
+	0x0C, 0x82, 0xB1, 0x84, 0x25,
+	0x01, 0x6D, 0x69, 0xC5, 0xE1,
+	0x00, 0x7C, 0x07, 0xAD, 0xF1,
+	0x05, 0x33, 0x01, 0x80, 0x91,
+	0x00, 0xFA, 0x2C, 0x75, 0x96,
+	0x00, 0x7B, 0x02, 0xD6, 0xEF,
+	0x08, 0x17, 0xD1, 0x45, 0x05,
+	0x09, 0x77, 0x03, 0x1D, 0x2D,
+	0x0E, 0xA2, 0x41, 0x38, 0x94,
+	0x02, 0xA1, 0xDE, 0x1F, 0xF0,
+	0x02, 0xE7, 0x26, 0x41, 0xFA,
+	0x03, 0xBC, 0x19, 0xFF, 0x92,
+	0x02, 0xD8, 0x4A, 0x98, 0xA8,
+	0x0C, 0x20, 0x8F, 0xCC, 0xB2,
+	0x0E, 0x9B, 0x94, 0xC6, 0x27,
+	0x01, 0x92, 0x5B, 0x72, 0x65,
+	0x0F, 0x01, 0x1A, 0x44, 0x17,
+	0x0E, 0x5A, 0x3D, 0x2C, 0xF5,
+	0x07, 0x41, 0xB5, 0xBB, 0x0A,
+	0x05, 0x6A, 0x80, 0xCF, 0x43,
+	0x0E, 0x07, 0x3E, 0x4F, 0x5D,
+	0x04, 0x86, 0x7F, 0x3D, 0xB3,
+	0x01, 0xBC, 0x3E, 0xE6, 0xFD,
+	0x05, 0xCC, 0x02, 0x53, 0xB4,
+	0x09, 0xF2, 0xE2, 0xA4, 0x71,
+	0x05, 0x71, 0x29, 0x10, 0x08,
+	0x0F, 0x93, 0x72, 0xA3, 0x3D,
+	0x0B, 0x2A, 0x85, 0x69, 0xE2,
+	0x04, 0xB7, 0xE0, 0x52, 0xC6,
+	0x02, 0x32, 0x8D, 0x29, 0x28,
+	0x09, 0x46, 0xF9, 0xE3, 0x1A,
+	0x03, 0x73, 0xF6, 0x0B, 0x5F,
+	0x0E, 0x81, 0x67, 0x65, 0xDC,
+	0x06, 0xF4, 0x32, 0xBC, 0x89,
+	0x07, 0x62, 0x89, 0xE0, 0xC4,
+	0x00, 0xFD, 0xE5, 0xEF, 0xCB,
+	0x01, 0x86, 0x83, 0x68, 0x33,
+	0x06, 0xC5, 0x4C, 0xE3, 0x99,
+	0x08, 0x60, 0xC2, 0x90, 0x9C,
+	0x0F, 0xBA, 0x6F, 0x77, 0x6E,
+	0x0D, 0x88, 0xF3, 0xF0, 0x49,
+	0x0F, 0xC9, 0xAD, 0x98, 0xFF,
+	0x0F, 0x18, 0xBD, 0x51, 0x61,
+	0x0C, 0xB3, 0xC7, 0xDD, 0xF5,
+	0x0F, 0xEC, 0xD6, 0xB2, 0x2A,
+	0x0F, 0x29, 0x2F, 0xB8, 0x5C,
+	0x05, 0x2D, 0x75, 0x12, 0x2A,
+	0x06, 0xF6, 0xC9, 0x02, 0x30,
+	0x0F, 0x83, 0xDF, 0x17, 0x32,
+	0x08, 0x86, 0x31, 0xE7, 0xCD,
+	0x03, 0x93, 0xA2, 0xD5, 0x37,
+	0x0E, 0x42, 0xC6, 0x18, 0x46,
+	0x0C, 0x06, 0x14, 0xD0, 0x4A,
+	0x0C, 0xA5, 0x88, 0x92, 0x2C,
+	0x09, 0x51, 0xD9, 0x18, 0xC8,
+	0x0D, 0x3F, 0x42, 0xCB, 0x99,
+	0x07, 0x8F, 0xBA, 0x0D, 0x6D,
+	0x08, 0x2D, 0x7D, 0x54, 0x80,
+	0x03, 0x97, 0x70, 0xBF, 0x18,
+	0x06, 0xE6, 0x24, 0x33, 0x9C,
+	0x0D, 0xB2, 0x9D, 0xE1, 0xFF,
+	0x0E, 0xBE, 0xEE, 0x68, 0x92,
+	0x07, 0xA1, 0x22, 0x9B, 0x35,
+	0x03, 0x8D, 0xAF, 0x89, 0x88,
+	0x00, 0x42, 0x3C, 0x9C, 0xAB,
+	0x0D, 0xE9, 0xBD, 0x14, 0x2B,
+	0x0F, 0xD9, 0x21, 0xBF, 0x26,
+	0x07, 0xA8, 0xD1, 0x94, 0x69,
+	0x06, 0x47, 0xEE, 0xB2, 0x05,
+	0x05, 0x76, 0xEA, 0xDB, 0xB4,
+	0x0A, 0xFA, 0xA8, 0x12, 0x65,
+	0x0A, 0xE0, 0x73, 0xA2, 0xF5,
+	0x04, 0x48, 0x67, 0x0B, 0xDB,
+	0x04, 0x3B, 0x41, 0xFE, 0x0F,
+	0x07, 0x5C, 0xC8, 0x25, 0x3B,
+	0x0B, 0x80, 0xC9, 0xD6, 0x44,
+	0x0B, 0x57, 0x15, 0x11, 0x00,
+	0x0E, 0xA1, 0x3B, 0x53, 0xFC,
+	0x03, 0x72, 0x28, 0xD6, 0x95,
+	0x02, 0x4B, 0x7E, 0xCD, 0x86,
+	0x00, 0x63, 0x2A, 0xD2, 0xB4,
+	0x00, 0x1D, 0x65, 0x9E, 0x3E,
+	0x08, 0x35, 0xB1, 0x60, 0x46,
+	0x0C, 0xD0, 0xC9, 0x5E, 0x5D,
+	0x08, 0x67, 0xE9, 0xE7, 0xB9,
+	0x08, 0x48, 0xB7, 0xBA, 0x28,
+	0x0D, 0x85, 0x02, 0x1E, 0xD8,
+	0x01, 0x40, 0xEA, 0x7A, 0x8F,
+	0x06, 0xEA, 0xF4, 0x82, 0x76,
+	0x04, 0x24, 0xDC, 0x01, 0x48,
+	0x0A, 0xF2, 0x0C, 0x3A, 0xA6,
+	0x0E, 0x52, 0x56, 0xBF, 0x24,
+	0x0E, 0x7C, 0x3A, 0x95, 0x00,
+	0x0C, 0x53, 0x5B, 0xFD, 0x56,
+	0x0A, 0xCB, 0x38, 0x7D, 0x23,
+	0x02, 0xED, 0xAD, 0x69, 0x6A,
+	0x09, 0x50, 0xDC, 0xBB, 0x41,
+	0x04, 0x91, 0x29, 0x51, 0x31,
+	0x00, 0x3F, 0x6C, 0xD0, 0xDC,
+	0x0F, 0xF8, 0x3D, 0x75, 0xB9,
+	0x00, 0x94, 0xED, 0x1E, 0x7C,
+	0x0C, 0xA9, 0x18, 0x61, 0x9C,
+	0x0C, 0x44, 0x06, 0x11, 0x84,
+	0x05, 0x90, 0xCF, 0x4D, 0xC8,
+	0x08, 0x58, 0x5E, 0xC9, 0xDE,
+	0x03, 0x36, 0x31, 0x01, 0x84,
+	0x0B, 0xCB, 0x5A, 0x20, 0xB5,
+	0x06, 0x78, 0xFB, 0xA6, 0xDC,
+	0x09, 0x82, 0xD7, 0xD1, 0x0A,
+	0x05, 0x79, 0x77, 0x03, 0x9D,
+	0x07, 0xAE, 0x20, 0x43, 0x38,
+	0x05, 0xD9, 0xA1, 0xDA, 0x6C,
+	0x0C, 0x7B, 0xE2, 0x26, 0x4E,
+	0x09, 0xDA, 0x26, 0xF9, 0xB1,
+	0x02, 0x38, 0xDA, 0x38, 0x92,
+	0x08, 0x04, 0x21, 0x09, 0x00,
+	0x0B, 0xDE, 0x9B, 0x91, 0xB1,
+	0x0C, 0xFD, 0x12, 0x57, 0xF2,
+	0x02, 0x60, 0x83, 0x15, 0x06,
+	0x0D, 0xF7, 0x48, 0x6B, 0x0C,
+	0x01, 0xF7, 0x45, 0xAD, 0x73,
+	0x05, 0xAF, 0xAA, 0x8F, 0xE4,
+	0x0A, 0xEE, 0x87, 0x34, 0xA1,
+	0x0D, 0x44, 0x82, 0x70, 0x53,
+	0x09, 0xC0, 0x98, 0x39, 0xAF,
+	0x0D, 0xC6, 0xC2, 0x02, 0x13,
+	0x04, 0x79, 0xF3, 0x68, 0x1D,
+	0x01, 0xB5, 0x71, 0x3B, 0xA8,
+	0x02, 0xC5, 0x3B, 0x93, 0x36,
+	0x07, 0x34, 0x2C, 0x05, 0x29,
+	0x03, 0x24, 0x37, 0xE8, 0x54,
+	0x06, 0x05, 0x3D, 0x0D, 0x6F,
+	0x01, 0x31, 0x36, 0x59, 0xE3,
+	0x0E, 0x83, 0x5B, 0x7B, 0x01,
+	0x0F, 0x55, 0x02, 0x91, 0x0B,
+	0x07, 0x0E, 0x74, 0x9E, 0x94,
+	0x09, 0x0C, 0xE5, 0x7B, 0xAE,
+	0x07, 0x78, 0x7F, 0xC1, 0xC1,
+	0x0B, 0x99, 0x04, 0xA7, 0x46,
+	0x03, 0xE6, 0xC5, 0x48, 0x0D,
+	0x02, 0x9A, 0xE2, 0x2C, 0x3E,
+	0x06, 0xE7, 0x28, 0x45, 0x5D,
+	0x0E, 0x45, 0x0A, 0x53, 0xFC,
+	0x09, 0x6F, 0xC9, 0xAC, 0xB6,
+	0x0C, 0x65, 0x1A, 0x51, 0x28,
+	0x08, 0xAC, 0xB3, 0xC7, 0xE5,
+	0x0E, 0xB6, 0x6C, 0x1A, 0xBE,
+	0x02, 0x03, 0xAB, 0xC7, 0xF8,
+	0x06, 0xEA, 0x22, 0x75, 0x32,
+	0x09, 0xC2, 0xF2, 0xCD, 0xC6,
+	0x00, 0xFF, 0x83, 0xD1, 0xB8,
+	0x0A, 0x09, 0xCE, 0xDF, 0x08,
+	0x0D, 0x8A, 0x95, 0xC6, 0x3A,
+	0x0E, 0x47, 0x64, 0x27, 0x57,
+	0x04, 0x56, 0x9B, 0xF4, 0x9C,
+	0x0A, 0x15, 0xA7, 0xE6, 0x6B,
+	0x0F, 0x93, 0x53, 0x3A, 0xE0,
+	0x00, 0xB7, 0x97, 0xA4, 0x90,
+	0x03, 0x64, 0x92, 0xBA, 0x4D,
+	0x05, 0xD8, 0xAD, 0x71, 0xD4,
+	0x00, 0x54, 0x89, 0x70, 0x79,
+	0x0B, 0xFA, 0x0A, 0x24, 0x33,
+	0x05, 0xED, 0x9A, 0x10, 0xEB,
+	0x0F, 0x07, 0xBE, 0x2A, 0x8B,
+	0x09, 0x9D, 0xA3, 0xCF, 0xB4,
+	0x05, 0x23, 0x89, 0xAB, 0x41,
+	0x08, 0x80, 0x42, 0x30, 0xB3,
+	0x0B, 0x0D, 0xE9, 0xB9, 0x3B,
+	0x0B, 0x4F, 0xD9, 0x25, 0x50,
+	0x0E, 0xDE, 0xE0, 0x3D, 0xBB,
+	0x03, 0xBF, 0x47, 0x08, 0xF6,
+	0x0F, 0x1F, 0x74, 0x9A, 0xD1,
+	0x00, 0x5A, 0xFA, 0xAD, 0x3B,
+	0x0F, 0x2E, 0xE0, 0x7D, 0x5D,
+	0x0E, 0xD4, 0x48, 0x67, 0x33,
+	0x0B, 0x34, 0x3A, 0xC1, 0x47,
+	0x0F, 0x7C, 0x58, 0x4C, 0x2F,
+	0x02, 0xC7, 0x7F, 0x36, 0xEA,
+	0x0F, 0x98, 0x77, 0x91, 0xA5,
+	0x00, 0x84, 0x61, 0x39, 0x6E,
+	0x0B, 0xD3, 0x72, 0x2C, 0x1C,
+	0x07, 0xE2, 0xCB, 0x72, 0x4D,
+	0x04, 0xC6, 0xE3, 0x24, 0x92,
+	0x0E, 0x8B, 0x19, 0x65, 0x49,
+	0x07, 0xE8, 0xF5, 0xBB, 0xA0,
+	0x0F, 0xF6, 0x7B, 0x29, 0x1E,
+	0x04, 0xC2, 0xC7, 0x49, 0x2B,
+	0x02, 0x93, 0xE5, 0x17, 0xB4,
+	0x01, 0xDF, 0x67, 0xF8, 0xDE,
+	0x00, 0xE1, 0x10, 0x46, 0x76,
+	0x07, 0x38, 0xEC, 0x58, 0xCE,
+	0x0E, 0xAE, 0xA6, 0x2E, 0x01,
+	0x00, 0xC4, 0xF2, 0xA0, 0x77,
+	0x0C, 0xE7, 0x16, 0xAD, 0x1F,
+	0x0C, 0x95, 0x7C, 0x94, 0x19,
+	0x08, 0x45, 0xF3, 0xAB, 0x3D,
+	0x0F, 0x39, 0x0F, 0x32, 0x3D,
+	0x00, 0x6B, 0x62, 0x41, 0x58,
+	0x08, 0xA0, 0x56, 0xBA, 0xBB,
+	0x01, 0xCE, 0x1F, 0x57, 0x51,
+	0x03, 0x9D, 0xAB, 0x6A, 0x90,
+	0x0F, 0x8F, 0x5F, 0x3D, 0xF1,
+	0x01, 0xA1, 0x38, 0xEB, 0x9E,
+	0x0F, 0xD8, 0x69, 0x10, 0xED,
+	0x0D, 0x4D, 0x84, 0x84, 0x1B,
+	0x05, 0x07, 0x58, 0xE9, 0x07,
+	0x02, 0xA2, 0x6F, 0x7E, 0xD9,
+	0x0D, 0xF9, 0x37, 0x35, 0x8B,
+	0x07, 0xA3, 0x4B, 0xFA, 0x1E,
+	0x0E, 0x15, 0x8A, 0x7D, 0x2A,
+	0x0E, 0x5D, 0x21, 0xD5, 0x55,
+	0x0B, 0x26, 0x8B, 0xF1, 0x76,
+	0x04, 0x25, 0x8E, 0xAF, 0x03,
+	0x01, 0x5C, 0x99, 0xA1, 0x1E,
+	0x05, 0xF3, 0x43, 0x62, 0xE2,
+	0x01, 0x29, 0xDA, 0x30, 0xCA,
+	0x09, 0xD2, 0x99, 0x58, 0x38,
+	0x03, 0x0B, 0xF6, 0xA5, 0x7F,
+	0x02, 0x32, 0xFE, 0x96, 0x11,
+	0x0A, 0xB4, 0x79, 0x10, 0xDB,
+	0x0B, 0x68, 0x66, 0x03, 0xD9,
+	0x0F, 0x95, 0xB7, 0xDE, 0xA1,
+	0x06, 0xF2, 0xC9, 0x41, 0xA9,
+	0x09, 0x05, 0xAB, 0xAC, 0x01,
+	0x0A, 0xF2, 0xEA, 0x0B, 0xC8,
+	0x0F, 0xDF, 0x40, 0x86, 0x70,
+	0x07, 0xB0, 0x02, 0xBC, 0x3E,
+	0x00, 0xF7, 0xC1, 0xC0, 0xB0,
+	0x03, 0xB4, 0x7D, 0x73, 0x62,
+	0x04, 0x71, 0xB2, 0xF1, 0x31,
+	0x00, 0x08, 0x46, 0x13, 0x95,
+	0x01, 0x3D, 0x97, 0x22, 0x85,
+	0x09, 0x7A, 0x84, 0xB7, 0xE4,
+	0x0D, 0x4E, 0x22, 0x32, 0x79,
+	0x05, 0xEB, 0xF3, 0x56, 0x5B,
+	0x0B, 0x6E, 0x23, 0x56, 0x76,
+	0x02, 0xDD, 0x71, 0x02, 0x61,
+	0x0F, 0xDF, 0x4A, 0x74, 0x96,
+	0x02, 0x09, 0xAC, 0xEC, 0x7B,
+	0x06, 0x87, 0x79, 0x7F, 0xC1,
+	0x0F, 0x8B, 0x9A, 0x00, 0x2D,
+	0x08, 0xF3, 0xE4, 0xC3, 0x02,
+	0x08, 0x6A, 0xE2, 0x62, 0x20,
+	0x0C, 0x8C, 0x25, 0x6A, 0xCC,
+	0x0A, 0x6E, 0x5F, 0x0A, 0xE1,
+	0x06, 0x49, 0x6F, 0x49, 0xA3,
+	0x08, 0x0C, 0x65, 0x9A, 0x55,
+	0x01, 0x63, 0xAC, 0x33, 0xCD,
+	0x0D, 0x06, 0xB6, 0x6C, 0xDC,
+	0x0E, 0xAA, 0x05, 0xAB, 0xC1,
+	0x08, 0x1C, 0xEB, 0x3D, 0x7F,
+	0x09, 0x19, 0xC2, 0xF6, 0xFE,
+	0x06, 0xF0, 0x7F, 0x8F, 0xDF,
+	0x0F, 0x34, 0x89, 0x40, 0x11,
+	0x0D, 0xCE, 0xC6, 0x11, 0x86,
+	0x0E, 0xC4, 0xC4, 0x40, 0x1B,
+	0x08, 0x4E, 0x55, 0x8B, 0xF0,
+	0x05, 0x0A, 0xF5, 0xA7, 0xDE,
+	0x0C, 0x5E, 0xA3, 0x53, 0x30,
+	0x01, 0x4B, 0xD4, 0xA3, 0xA2,
+	0x07, 0x59, 0x67, 0x91, 0xA7,
+	0x0B, 0x6D, 0xD8, 0x2D, 0xFD,
+	0x02, 0x0A, 0x57, 0x97, 0xF0,
+	0x09, 0xD2, 0xFA, 0xEA, 0xF7,
+	0x03, 0x84, 0x6D, 0x94, 0x54,
+	0x09, 0x7D, 0x07, 0xB2, 0xAE,
+	0x0E, 0x11, 0xCF, 0x23, 0xCB,
+	0x0B, 0x15, 0x23, 0x89, 0x99,
+	0x01, 0x02, 0xE0, 0x4F, 0xF0,
+	0x06, 0xA8, 0x40, 0x69, 0xBD,
+	0x04, 0x2B, 0x4D, 0xD5, 0xAE,
+	0x06, 0x26, 0x66, 0x61, 0xF1,
+	0x0C, 0x6B, 0x3F, 0x47, 0x0E,
+	0x02, 0xCF, 0x1D, 0x70, 0x90,
+	0x0B, 0xB0, 0x5A, 0xFE, 0x9A,
+	0x04, 0xAF, 0x2E, 0xED, 0xF7,
+	0x0C, 0xED, 0x54, 0x05, 0xA7,
+	0x0B, 0xDB, 0x34, 0x38, 0xC6,
+	0x05, 0x8C, 0xAE, 0xD8, 0xF9,
+	0x0E, 0xB8, 0x95, 0x1F, 0x36,
+	0x0A, 0x47, 0x19, 0x5A, 0x17,
+	0x01, 0x00, 0x86, 0x6C, 0x7C,
+	0x0D, 0x98, 0x0A, 0x70, 0x9A,
+	0x06, 0x9F, 0xB6, 0x46, 0x3A,
+	0x05, 0x49, 0x40, 0x6F, 0xA8,
+	0x0B, 0x7E, 0x67, 0x1D, 0xB6,
+	0x0E, 0x3E, 0xE8, 0x71, 0xA0,
+	0x08, 0xB5, 0x75, 0x50, 0x29,
+	0x07, 0xDC, 0x20, 0xEB, 0x49,
+	0x03, 0x81, 0x10, 0xDE, 0x97,
+	0x0F, 0x62, 0x17, 0x8A, 0x3C,
+	0x04, 0xFB, 0xE5, 0x10, 0x4E,
+	0x06, 0x8F, 0x3C, 0x62, 0x1D,
+	0x0E, 0x36, 0xAE, 0xAB, 0xA6,
+	0x08, 0x88, 0x22, 0x7E, 0xBD,
+	0x0F, 0x25, 0xC0, 0x52, 0x3E,
+	0x06, 0x66, 0xB2, 0xBC, 0x68,
+	0x03, 0x83, 0xA4, 0x51, 0xA1,
+	0x05, 0x96, 0x9A, 0xCB, 0x3C,
+	0x0D, 0xD0, 0x6B, 0x63, 0x45,
+	0x09, 0xEA, 0xA0, 0x54, 0xBE,
+	0x0B, 0x81, 0xCE, 0x93, 0xD7,
+	0x01, 0x21, 0x1E, 0x2B, 0x26,
+	0x08, 0x6F, 0xAF, 0xE8, 0xBD,
+	0x0F, 0xF2, 0x10, 0x94, 0xED,
+	0x07, 0xFD, 0x38, 0xA5, 0x1C,
+	0x04, 0x5E, 0x6C, 0x54, 0xB3,
+	0x0B, 0x87, 0x82, 0x58, 0x6D,
+	0x05, 0x48, 0x01, 0x56, 0x3E,
+	0x00, 0x2F, 0x99, 0x39, 0xB3,
+	0x0B, 0x8F, 0xC7, 0xCB, 0xFE,
+	0x0C, 0x75, 0x96, 0x7B, 0xCD,
+	0x00, 0xD6, 0xDD, 0x81, 0xD2,
+	0x05, 0x40, 0xA5, 0x74, 0x33,
+	0x0A, 0x1D, 0xC7, 0xAE, 0xA2,
+	0x0B, 0x3A, 0x5E, 0xDF, 0xE1,
+	0x04, 0x1C, 0x86, 0x7B, 0xE6,
+	0x08, 0xC0, 0x19, 0xDA, 0x3C,
+	0x09, 0xB1, 0x52, 0x26, 0xC7,
+	0x01, 0x19, 0x6C, 0x28, 0x23,
+	0x01, 0xCA, 0x34, 0xCE, 0x1B,
+	0x08, 0x42, 0x70, 0xFD, 0x12,
+	0x03, 0xF0, 0x6A, 0x66, 0x83,
+	0x03, 0x45, 0xF8, 0xF4, 0x5C,
+	0x03, 0x2C, 0x71, 0xF7, 0x41,
+	0x04, 0xB9, 0x45, 0x9F, 0x2A,
+	0x0B, 0x49, 0x82, 0x6E, 0x03,
+	0x03, 0x4F, 0x9D, 0x44, 0x86,
+	0x02, 0xBD, 0xB3, 0x45, 0xBC,
+	0x07, 0xE0, 0x77, 0xD5, 0x4C,
+	0x02, 0x52, 0x36, 0x77, 0xBA,
+	0x00, 0xA4, 0x70, 0x33, 0xF1,
+	0x08, 0x10, 0xC9, 0xF6, 0x93,
+	0x04, 0x60, 0x7D, 0x37, 0x22,
+	0x05, 0x69, 0xFB, 0x32, 0xB5,
+	0x0C, 0xC6, 0xAC, 0x0B, 0xF2,
+	0x0D, 0x2F, 0xEE, 0x97, 0x54,
+	0x03, 0xE0, 0x85, 0x83, 0x5F,
+	0x0C, 0x08, 0xDE, 0xD5, 0x03,
+	0x0B, 0x64, 0xEC, 0x0E, 0x74,
+	0x0E, 0xBA, 0x8B, 0x12, 0xA8,
+	0x02, 0xE7, 0x66, 0xD4, 0x7F,
+	0x09, 0xEF, 0x0A, 0x19, 0x84,
+	0x0E, 0x68, 0x32, 0xE6, 0x45,
+	0x00, 0xE1, 0x6A, 0xE2, 0xE2,
+	0x0A, 0x13, 0xF6, 0xA7, 0x2E,
+	0x03, 0x7A, 0x6E, 0xC5, 0x0A,
+	0x03, 0xF6, 0x4A, 0xEF, 0xC9,
+	0x0D, 0x98, 0x0C, 0x73, 0x1A,
+	0x07, 0xD1, 0xE3, 0xAC, 0x33,
+	0x07, 0xDC, 0x86, 0xB8, 0xF1,
+	0x0F, 0xBC, 0xEA, 0x05, 0xAB,
+	0x01, 0xBB, 0x62, 0xE9, 0x39,
+	0x05, 0x12, 0x19, 0x42, 0xF6,
+	0x0D, 0x0E, 0xF3, 0x7F, 0x83,
+	0x0B, 0x17, 0x32, 0x0F, 0xCE,
+	0x08, 0xE7, 0x0D, 0xBA, 0x11,
+	0x07, 0xD4, 0x00, 0xC4, 0x40,
+	0x01, 0x18, 0x4A, 0x43, 0x84,
+	0x0C, 0xCE, 0xED, 0x18, 0x67,
+	0x0C, 0x92, 0xD9, 0xB5, 0xD1,
+	0x0A, 0x1B, 0xBC, 0x34, 0xBB,
+	0x09, 0x44, 0xBB, 0xE7, 0x8F,
+	0x0A, 0x0D, 0x6D, 0xDC, 0x97,
+	0x04, 0xD6, 0x4E, 0x57, 0x66,
+	0x0A, 0x3A, 0x56, 0x7A, 0xE8,
+	0x0D, 0x33, 0x45, 0xE1, 0xDA,
+	0x04, 0x63, 0xBB, 0x07, 0x4C,
+	0x04, 0x67, 0x97, 0x1D, 0xAB,
+	0x06, 0x9B, 0xD5, 0x2F, 0x0D,
+	0x09, 0x89, 0x88, 0x8C, 0x02,
+	0x02, 0x9C, 0xAB, 0x09, 0x69,
+	0x08, 0x94, 0xCD, 0x4F, 0xD9,
+	0x04, 0x3D, 0x46, 0xA6, 0x60,
+	0x09, 0x14, 0xC9, 0x7D, 0xC5,
+	0x0C, 0xB2, 0xCF, 0x1B, 0xB4,
+	0x0B, 0x59, 0x90, 0x57, 0xFF,
+	0x09, 0x95, 0x4F, 0x2E, 0xD3,
+	0x0B, 0xA4, 0x75, 0xD4, 0x7A,
+	0x07, 0x0B, 0xD9, 0x30, 0xF1,
+	0x0D, 0x7F, 0x3F, 0x7C, 0x5C,
+	0x04, 0x25, 0x39, 0x47, 0x91,
+	0x06, 0x2A, 0x47, 0x15, 0x4A,
+	0x0B, 0x90, 0x94, 0x89, 0x21,
+	0x00, 0x57, 0x9B, 0xDE, 0xF2,
+	0x01, 0xDF, 0x5F, 0xBF, 0x8B,
+	0x0E, 0x4D, 0x4C, 0xC4, 0x27,
+	0x08, 0xD2, 0xFE, 0x8F, 0x99,
+	0x05, 0x9E, 0x3C, 0xE6, 0x7C,
+	0x07, 0x60, 0xB4, 0xF1, 0x94,
+	0x00, 0x5E, 0x9D, 0x40, 0x6D,
+	0x0B, 0xEB, 0xA8, 0x90, 0x4E,
+	0x05, 0xB6, 0x6C, 0x77, 0x07,
+	0x0D, 0xFE, 0x18, 0xB5, 0x81,
+	0x0B, 0x14, 0xCF, 0x3E, 0x6C,
+	0x0E, 0x8D, 0xA5, 0xAE, 0x2E,
+	0x0B, 0x01, 0xC8, 0xC2, 0x72,
+	0x0C, 0x37, 0xA6, 0x62, 0x9A,
+	0x01, 0x1F, 0x64, 0x96, 0xFF,
+	0x03, 0x19, 0x60, 0xC4, 0xD1,
+	0x0C, 0x7C, 0xF6, 0xBA, 0x8B,
+	0x0D, 0xF8, 0x33, 0xED, 0xE4,
+	0x09, 0xEB, 0x4A, 0x2C, 0x92,
+	0x08, 0xBB, 0x82, 0xCE, 0x13,
+	0x03, 0x51, 0x21, 0x9A, 0xEF,
+	0x0D, 0xD0, 0x2B, 0x0F, 0x2F,
+	0x0C, 0xF0, 0xB3, 0x20, 0x94,
+	0x04, 0x9F, 0xBF, 0x5A, 0x29,
+	0x0C, 0x6D, 0x5C, 0x4C, 0x44,
+	0x0E, 0x11, 0x85, 0x65, 0x56,
+	0x0F, 0x4D, 0xC8, 0xA7, 0x81,
+	0x0E, 0xC9, 0x2D, 0xFE, 0xAF,
+	0x09, 0xC1, 0x85, 0x24, 0x7D,
+	0x0A, 0x2C, 0x75, 0x96, 0x78,
+	0x03, 0x09, 0x76, 0x5C, 0x01,
+	0x03, 0xD5, 0x44, 0xA4, 0xF9,
+	0x07, 0x03, 0x99, 0x27, 0xAE,
+	0x03, 0x43, 0xF8, 0x58, 0xAA,
+	0x00, 0x5C, 0x5F, 0xF0, 0x7B,
+	0x08, 0xE5, 0xE0, 0x29, 0xDE,
+	0x04, 0x79, 0x16, 0xD3, 0xB8,
+	0x0A, 0xB8, 0x99, 0x08, 0x04,
+	0x0A, 0x89, 0x2A, 0xB2, 0x5E,
+	0x0A, 0x91, 0x86, 0xB4, 0x24,
+	0x08, 0x58, 0x59, 0xEA, 0x67,
+	0x0A, 0x99, 0xA9, 0x15, 0x74,
+	0x04, 0xEB, 0x23, 0x31, 0xC6,
+	0x0D, 0xAC, 0x55, 0xC5, 0xAC,
+	0x0A, 0x81, 0x4A, 0xF4, 0x35,
+	0x07, 0x3A, 0x4F, 0x5A, 0xDE,
+	0x0C, 0xB0, 0xB4, 0x34, 0x0B,
+	0x0C, 0x3F, 0xE0, 0xF7, 0xC5,
+	0x0E, 0x82, 0x57, 0xB5, 0xF9,
+	0x0A, 0xE2, 0x44, 0xF3, 0x35,
+	0x00, 0x31, 0xD0, 0x08, 0x46,
+	0x0B, 0x17, 0x21, 0xB1, 0x77,
+	0x08, 0x86, 0xCE, 0x7B, 0x26,
+	0x0E, 0xE4, 0x14, 0xC0, 0x46,
+	0x0B, 0x8C, 0xE7, 0xE8, 0xF1,
+	0x06, 0x59, 0xE3, 0xEE, 0x83,
+	0x0B, 0x76, 0x0B, 0x5B, 0xCB,
+	0x02, 0x95, 0xE5, 0xDC, 0x0E,
+	0x04, 0x9E, 0xB3, 0x89, 0x0C,
+	0x01, 0x7B, 0x66, 0x87, 0x78,
+	0x0E, 0xC1, 0x2B, 0x8B, 0x40,
+	0x0C, 0x27, 0xC8, 0xF3, 0xE6,
+	0x05, 0x48, 0xE3, 0x6C, 0x39,
+	0x02, 0x20, 0x10, 0x8B, 0xBD,
+	0x00, 0x03, 0x73, 0xE9, 0x1F,
+	0x0A, 0xD3, 0xF6, 0x49, 0x6F,
+	0x00, 0xA8, 0x38, 0x0D, 0xE5,
+	0x03, 0xDD, 0x91, 0xE3, 0xEC,
+	0x0B, 0x44, 0xE9, 0x0A, 0x39,
+	0x08, 0x16, 0xA6, 0x2E, 0xC5,
+	0x0B, 0xCB, 0xB8, 0x1C, 0xE9,
+	0x0C, 0x77, 0x52, 0x19, 0xC2,
+	0x0F, 0x4D, 0xFA, 0xF0, 0x3F,
+	0x03, 0xDF, 0x03, 0x32, 0x09,
+	0x0E, 0xD1, 0xE4, 0xCD, 0x8A,
+	0x00, 0x6C, 0xB5, 0xC4, 0xC4,
+	0x01, 0x88, 0xF8, 0x4E, 0x55,
+	0x06, 0xF4, 0xDC, 0x8A, 0x15,
+	0x0E, 0x6E, 0xD2, 0xDB, 0x62,
+	0x09, 0x33, 0xAD, 0xCA, 0x3C,
+	0x06, 0xA2, 0x07, 0x55, 0x27,
+	0x06, 0x38, 0x09, 0x4D, 0x18,
+	0x07, 0x7E, 0xE2, 0x8A, 0x17,
+	0x07, 0x70, 0x39, 0xD6, 0x08,
+	0x02, 0x25, 0xB3, 0x99, 0xED,
+	0x0A, 0x1D, 0xE1, 0xC9, 0x8D,
+	0x0A, 0x2E, 0x64, 0x12, 0x1D,
+	0x07, 0xCF, 0x99, 0x15, 0xA3,
+	0x0C, 0xAB, 0x49, 0x86, 0xC9,
+	0x03, 0xB0, 0x7C, 0xAB, 0x0D,
+	0x01, 0x33, 0x14, 0x26, 0x8F,
+	0x09, 0x25, 0xBF, 0x30, 0x24,
+	0x00, 0x31, 0x94, 0x4F, 0xBD,
+	0x0F, 0x8D, 0x38, 0x4F, 0x1B,
+	0x04, 0x1A, 0xD9, 0xBD, 0x5E,
+	0x02, 0xA8, 0x94, 0xA2, 0xAE,
+	0x08, 0x7A, 0x24, 0xF8, 0x14,
+	0x08, 0x67, 0x09, 0xD9, 0x86,
+	0x00, 0x40, 0x27, 0x0B, 0x79,
+	0x00, 0xE8, 0x25, 0x3B, 0x76,
+	0x07, 0xB6, 0x8A, 0x4B, 0xDB,
+	0x0C, 0x90, 0xF3, 0x8D, 0x80,
+	0x0D, 0x39, 0x55, 0x9B, 0xDC,
+	0x0A, 0xE0, 0xEE, 0x99, 0x32,
+	0x03, 0xFF, 0xED, 0x40, 0x80,
+	0x03, 0xAD, 0x70, 0xF0, 0xC2,
+	0x07, 0x66, 0x5C, 0xBE, 0xF8,
+	0x0D, 0x37, 0xC0, 0xB5, 0xF5,
+	0x09, 0x29, 0x9B, 0xDD, 0x00,
+	0x0E, 0xC8, 0x2A, 0xA4, 0xD0,
+	0x0E, 0x17, 0xB6, 0x6E, 0x3D,
+	0x03, 0xFC, 0x1E, 0xFC, 0x79,
+	0x00, 0x4A, 0x72, 0x8F, 0x3E,
+	0x0D, 0x56, 0xCE, 0x26, 0xAC,
+	0x07, 0xA2, 0xE2, 0xB8, 0xC0,
+	0x02, 0xAC, 0x36, 0xA2, 0x6E,
+	0x00, 0xAD, 0x38, 0xE0, 0x5C,
+	0x04, 0x9A, 0x1D, 0x80, 0x06,
+	0x09, 0x27, 0xF9, 0x16, 0xFA,
+	0x02, 0x3C, 0xB9, 0xD0, 0xAB,
+	0x07, 0xC3, 0x2B, 0xEA, 0x63,
+	0x06, 0xBC, 0xBB, 0x85, 0x8E,
+	0x07, 0xD7, 0x51, 0x25, 0x1C,
+	0x0F, 0x6E, 0xD0, 0xEF, 0x0F,
+	0x09, 0x3D, 0x31, 0x73, 0x20,
+	0x0D, 0xEC, 0xDF, 0xFC, 0x98,
+	0x09, 0x1C, 0x6D, 0xD8, 0x46,
+	0x04, 0x02, 0x13, 0x80, 0x6F,
+	0x03, 0x6F, 0x4D, 0xC8, 0xA1,
+	0x06, 0x7E, 0xCA, 0xAD, 0xF7,
+	0x05, 0x33, 0x17, 0x8C, 0xA3,
+	0x01, 0x3A, 0x2E, 0x72, 0x0B,
+	0x08, 0xFB, 0xA0, 0x56, 0xD7,
+	0x02, 0xD7, 0xD1, 0xC0, 0x6F,
+	0x09, 0x77, 0x07, 0x1D, 0x2D,
+	0x0E, 0xA2, 0x47, 0xB8, 0x54,
+	0x09, 0xA1, 0xDA, 0x9F, 0xFA,
+	0x0B, 0xE2, 0xE6, 0xC1, 0xE3,
+	0x0A, 0x3C, 0xFB, 0xB1, 0x98,
+	0x03, 0xDA, 0xB8, 0x98, 0x88,
+	0x0E, 0xC3, 0x11, 0x4D, 0x1F,
+	0x0E, 0x9B, 0x91, 0x5E, 0x23,
+	0x0D, 0x92, 0x5B, 0xE2, 0x6A,
+	0x0E, 0x2B, 0x99, 0x56, 0x17,
+	0x0C, 0xF0, 0x4B, 0x0C, 0x71,
+	0x0E, 0x69, 0x6D, 0xBB, 0x85,
+	0x06, 0x02, 0x61, 0x4A, 0x72,
+	0x0E, 0x07, 0x3A, 0x59, 0x5F,
+	0x04, 0x86, 0x70, 0xAB, 0xF1,
+	0x03, 0xBC, 0x3F, 0xF6, 0x75,
+	0x05, 0xCC, 0x82, 0x75, 0x76,
+	0x07, 0x72, 0x52, 0xA4, 0x71,
+	0x0E, 0x71, 0x31, 0x1E, 0x41,
+	0x0F, 0x93, 0x75, 0x61, 0xBD,
+	0x0E, 0xA3, 0x65, 0x75, 0xFB,
+	0x04, 0xB7, 0xE4, 0xC8, 0x55,
+	0x00, 0x32, 0x8D, 0x3F, 0x68,
+	0x07, 0xD6, 0x59, 0xF3, 0x6E,
+	0x05, 0x73, 0xF6, 0x1B, 0xDF,
+	0x03, 0x2B, 0x15, 0xF5, 0x5C,
+	0x08, 0xDC, 0x3E, 0xAA, 0x09,
+	0x0A, 0x48, 0xDB, 0x46, 0x07,
+	0x0F, 0x57, 0x01, 0xEF, 0x0B,
+	0x0E, 0x2D, 0x67, 0x68, 0x73,
+	0x06, 0xED, 0xC8, 0xF5, 0x68,
+	0x02, 0x4B, 0xA0, 0x06, 0xCE,
+	0x07, 0x2A, 0xC3, 0x6C, 0xEC,
+	0x0C, 0x10, 0xB3, 0xFB, 0x89,
+	0x0F, 0xC9, 0xA9, 0xBE, 0x0E,
+	0x0F, 0x19, 0x86, 0x51, 0x67,
+	0x02, 0x32, 0xF7, 0xDD, 0x06,
+	0x0D, 0xEC, 0x16, 0xB0, 0xB7,
+	0x09, 0x2A, 0x27, 0xB8, 0x02,
+	0x09, 0x3D, 0x79, 0x10, 0x9A,
+	0x0B, 0x74, 0xE5, 0x02, 0xEC,
+	0x05, 0x80, 0x39, 0x17, 0x3A,
+	0x05, 0x52, 0xD1, 0xE7, 0xDA,
+	0x02, 0x39, 0x66, 0xD3, 0x84,
+	0x08, 0x72, 0x21, 0x18, 0x52,
+	0x0D, 0x86, 0xF0, 0xD8, 0xC1,
+	0x0C, 0x27, 0x0C, 0x92, 0x1F,
+	0x0A, 0xDD, 0xD0, 0x19, 0x1D,
+	0x0C, 0x17, 0x06, 0xC1, 0x19,
+	0x0F, 0x0D, 0x9E, 0x0D, 0xAD,
+	0x01, 0x2D, 0xBD, 0x54, 0xCA,
+	0x06, 0x12, 0x90, 0x3D, 0x98,
+	0x00, 0x2A, 0x26, 0xB4, 0x52,
+	0x09, 0x9A, 0x1D, 0xE5, 0xBF,
+	0x05, 0xBE, 0x2A, 0x60, 0x52,
+	0x0D, 0x23, 0x6F, 0x9B, 0x15,
+	0x02, 0x8C, 0x6B, 0x89, 0x88,
+	0x02, 0x42, 0x34, 0x98, 0xEB,
+	0x0D, 0xE9, 0xB9, 0x14, 0x2B,
+	0x0E, 0xD8, 0xE5, 0xBB, 0xF1,
+	0x0F, 0xE0, 0xD1, 0x95, 0xA9,
+	0x06, 0x6D, 0x4E, 0xB6, 0x4F,
+	0x06, 0xF2, 0xFE, 0xDB, 0x70,
+	0x00, 0xF9, 0x59, 0x14, 0x8F,
+	0x0C, 0xE0, 0x73, 0xA0, 0x75,
+	0x04, 0x48, 0x67, 0x0B, 0xDB,
+	0x05, 0x3B, 0x03, 0xFE, 0x0F,
+	0x0C, 0x5C, 0xC8, 0x25, 0x71,
+	0x0E, 0xDF, 0xFE, 0x2E, 0xC7,
+	0x00, 0x57, 0x13, 0x11, 0x00,
+	0x08, 0x60, 0xD3, 0x96, 0x05,
+	0x0B, 0x72, 0x20, 0x52, 0xD4,
+	0x0A, 0x4B, 0x7E, 0x4C, 0x9B,
+	0x08, 0xCB, 0x88, 0xD4, 0xBE,
+	0x07, 0x0D, 0x65, 0x9E, 0x3D,
+	0x0E, 0x35, 0xB3, 0x64, 0xF5,
+	0x0D, 0x50, 0x2D, 0x5E, 0x5D,
+	0x03, 0x67, 0xAD, 0xEF, 0xE8,
+	0x09, 0xDE, 0xD7, 0xB6, 0xA8,
+	0x04, 0x96, 0x3C, 0x1A, 0x38,
+	0x01, 0x12, 0x0A, 0x77, 0x4F,
+	0x0E, 0xFD, 0xF0, 0x8E, 0x36,
+	0x0E, 0x26, 0x22, 0x01, 0x08,
+	0x02, 0x72, 0xAC, 0x37, 0xA6,
+	0x06, 0x50, 0xAD, 0x39, 0x24,
+	0x0E, 0x34, 0x3A, 0x99, 0xC0,
+	0x06, 0xD0, 0x0D, 0xFD, 0x16,
+	0x01, 0xCB, 0x3C, 0x7D, 0xD0,
+	0x03, 0x6E, 0x41, 0x65, 0x2A,
+	0x08, 0xD4, 0x3E, 0xB7, 0x81,
+	0x04, 0x97, 0x74, 0x51, 0x01,
+	0x00, 0x2F, 0x6D, 0x50, 0xEC,
+	0x07, 0x7E, 0xBD, 0xF1, 0x33,
+	0x0A, 0x90, 0x48, 0x1E, 0x3C,
+	0x00, 0x29, 0xBE, 0x60, 0x1C,
+	0x04, 0xC5, 0xA2, 0x1C, 0x44,
+	0x0D, 0xD1, 0xCF, 0x40, 0x08,
+	0x01, 0x5A, 0x7E, 0xC4, 0x29,
+	0x09, 0x35, 0x33, 0x05, 0xC9,
+	0x08, 0xCF, 0x50, 0x28, 0x0E,
+	0x0D, 0xFB, 0x19, 0x2D, 0x92,
+	0x04, 0x30, 0x97, 0xD5, 0x80,
+	0x0F, 0x7D, 0x73, 0x83, 0x8D,
+	0x0E, 0x9E, 0x62, 0x43, 0xF8,
+	0x0E, 0xD9, 0xA1, 0xDE, 0x1F,
+	0x00, 0x7B, 0xE2, 0xE6, 0x41,
+	0x02, 0x5E, 0x96, 0xFF, 0x32,
+	0x09, 0xBB, 0x38, 0x38, 0x98,
+	0x01, 0xB6, 0x63, 0x09, 0x0A,
+	0x0A, 0xDA, 0x9C, 0x91, 0x52,
+	0x0D, 0xCD, 0x52, 0x5B, 0x32,
+	0x0A, 0x66, 0x05, 0x17, 0x0F,
+	0x07, 0xF4, 0x58, 0x6B, 0x66,
+	0x01, 0xF7, 0x41, 0x2B, 0x31,
+	0x09, 0xAF, 0xAA, 0x01, 0x59,
+	0x02, 0xEE, 0x07, 0x39, 0x0B,
+	0x05, 0xC7, 0xA5, 0x32, 0x29,
+	0x0B, 0x41, 0x9C, 0x6F, 0x34,
+	0x0D, 0xC1, 0xC7, 0x02, 0x57,
+	0x0C, 0xF9, 0x53, 0x62, 0xA4,
+	0x01, 0xB5, 0x71, 0x31, 0xE2,
+	0x08, 0x46, 0x13, 0x57, 0xE3,
+	0x0D, 0x37, 0x22, 0xD6, 0x2D,
+	0x0B, 0x24, 0xB7, 0x26, 0x56,
+	0x07, 0x82, 0x81, 0x09, 0x65,
+	0x08, 0xB1, 0xD6, 0x49, 0xE3,
+	0x0E, 0x83, 0x5B, 0x66, 0x0B,
+	0x04, 0xD1, 0xB1, 0x13, 0x94,
+	0x0C, 0x0E, 0x70, 0x9E, 0xBA,
+	0x09, 0x0C, 0xE5, 0x75, 0x2F,
+	0x07, 0x78, 0x7A, 0x42, 0xEA,
+	0x00, 0x1D, 0xBD, 0xA9, 0xAC,
+	0x03, 0xE6, 0xC9, 0xCE, 0x29,
+	0x01, 0x66, 0xDB, 0x26, 0x61,
+	0x0C, 0x27, 0x2D, 0x45, 0xB0,
+	0x0C, 0x45, 0x0F, 0xD5, 0x36,
+	0x09, 0x6F, 0xC9, 0xAA, 0xE2,
+	0x0C, 0x05, 0x9A, 0x5F, 0xD1,
+	0x03, 0x4C, 0x13, 0xC7, 0xDD,
+	0x0F, 0x35, 0x8C, 0x94, 0x3E,
+	0x03, 0x07, 0x2B, 0xCD, 0x38,
+	0x06, 0xED, 0x25, 0xF5, 0x1A,
+	0x09, 0xC2, 0xF1, 0x4D, 0x04,
+	0x00, 0xFF, 0x82, 0x5B, 0xDD,
+	0x02, 0x09, 0x4E, 0xDD, 0xED,
+	0x07, 0x8E, 0x8A, 0xC6, 0xD4,
+	0x0D, 0x47, 0x20, 0x23, 0x98,
+	0x07, 0x57, 0xE2, 0xF4, 0x1C,
+	0x0A, 0x15, 0xA6, 0xE8, 0x58,
+	0x05, 0x97, 0x48, 0x30, 0x1A,
+	0x0A, 0x34, 0xBF, 0xA2, 0xCD,
+	0x00, 0xE7, 0x6F, 0xBA, 0x3C,
+	0x04, 0xD8, 0xEC, 0xFF, 0xD4,
+	0x00, 0x53, 0x88, 0xF0, 0x79,
+	0x0B, 0x7A, 0x2A, 0x26, 0xB3,
+	0x05, 0xED, 0x9A, 0x13, 0xA8,
+	0x05, 0x03, 0xA1, 0xAE, 0x24,
+	0x0B, 0x9F, 0x83, 0xCD, 0x1B,
+	0x0F, 0x27, 0x92, 0x2B, 0x8B,
+	0x08, 0x80, 0x42, 0x3C, 0xAD,
+	0x0B, 0x0D, 0xEB, 0xB9, 0x14,
+	0x05, 0xCE, 0xE9, 0x25, 0xBF,
+	0x06, 0xA6, 0x60, 0x1F, 0x89,
+	0x05, 0x7F, 0x44, 0x4E, 0xBC,
+	0x07, 0x9F, 0xC0, 0x1A, 0x5B,
+	0x08, 0xF8, 0xDA, 0xA8, 0x94,
+	0x05, 0x2A, 0xC5, 0xF3, 0xA0,
+	0x0C, 0xD4, 0x88, 0x6B, 0x4B,
+	0x01, 0x30, 0x1F, 0x43, 0xBE,
+	0x07, 0xFC, 0xFC, 0xC8, 0x25,
+	0x0B, 0x47, 0x9B, 0x36, 0x2A,
+	0x07, 0x1B, 0x5B, 0x13, 0x11,
+	0x02, 0x84, 0x65, 0x3F, 0x16,
+	0x03, 0x53, 0xD6, 0x28, 0xD6,
+	0x0F, 0x53, 0xE9, 0x70, 0x04,
+	0x05, 0x41, 0x82, 0x24, 0xD2,
+	0x07, 0x81, 0x7D, 0x68, 0x5E,
+	0x0E, 0xE8, 0x37, 0x91, 0x22,
+	0x0F, 0xF1, 0x70, 0x29, 0x5A,
+	0x0D, 0xC0, 0xE5, 0x47, 0x2F,
+	0x00, 0x90, 0x4A, 0x17, 0x76,
+	0x00, 0xF7, 0x26, 0xFE, 0x9E,
+	0x03, 0x3D, 0x2C, 0xCA, 0x44,
+	0x06, 0xBC, 0x6D, 0x56, 0x0E,
+	0x0C, 0xAA, 0x0B, 0x22, 0x05,
+	0x01, 0xC2, 0xB2, 0xAC, 0x37,
+	0x06, 0xE4, 0x50, 0xA1, 0x0D,
+	0x04, 0x96, 0xFD, 0x16, 0x13,
+	0x00, 0xC6, 0x53, 0xA3, 0x77,
+	0x0A, 0x3A, 0xCB, 0xFC, 0x4E,
+	0x0C, 0x6B, 0x6A, 0xC1, 0x59,
+	0x02, 0xA0, 0xD2, 0xB2, 0xBB,
+	0x09, 0xCF, 0x13, 0xDB, 0xD1,
+	0x01, 0x9C, 0x2F, 0x62, 0x55,
+	0x0F, 0x0F, 0xF8, 0x39, 0xC3,
+	0x03, 0x20, 0x94, 0xE0, 0x9D,
+	0x00, 0xD8, 0xA8, 0xDC, 0x6E,
+	0x0C, 0x4C, 0x46, 0x0C, 0x58,
+	0x0C, 0xE5, 0xD8, 0xE3, 0xD0,
+	0x00, 0xA0, 0xDB, 0xFE, 0x89,
+	0x05, 0x79, 0x94, 0xB1, 0x81,
+	0x07, 0x27, 0xF7, 0x7E, 0x1E,
+	0x0D, 0x16, 0xD8, 0xF9, 0x20,
+	0x0C, 0xD9, 0xB4, 0xD7, 0xF5,
+	0x09, 0xA5, 0xB9, 0x77, 0xC3,
+	0x0D, 0x27, 0xAA, 0xA2, 0x43,
+	0x08, 0x5E, 0xD9, 0xA1, 0xDE,
+	0x07, 0xF0, 0xF9, 0xE2, 0x26,
+	0x0B, 0x2D, 0x90, 0xBC, 0xFB,
+	0x0F, 0xD3, 0x08, 0xDA, 0xB8,
+	0x00, 0x00, 0xA4, 0x2E, 0xC9,
+	0x0A, 0xB0, 0xDC, 0xBB, 0x98,
+	0x02, 0xB4, 0xFD, 0xB6, 0x08,
+	0x0A, 0xEA, 0xC6, 0x03, 0x93,
+	0x0F, 0x37, 0x14, 0x58, 0x6B,
+	0x0C, 0xF1, 0xF7, 0x72, 0xAE,
+	0x0B, 0x05, 0xAF, 0xEC, 0xDA,
+	0x0A, 0xF2, 0xEE, 0x00, 0xE0,
+	0x03, 0x42, 0xBB, 0x7A, 0x41,
+	0x0D, 0xB3, 0x43, 0xB2, 0x76,
+	0x04, 0xF7, 0xC4, 0x4A, 0x01,
+	0x0A, 0xB4, 0xB8, 0x73, 0xE2,
+	0x05, 0x2B, 0xF4, 0x7C, 0xB5,
+	0x0A, 0x0C, 0x01, 0x93, 0x97,
+	0x08, 0xBD, 0xF7, 0x20, 0x05,
+	0x03, 0xFF, 0x63, 0x37, 0xC4,
+	0x08, 0xCC, 0x05, 0xF2, 0x83,
+	0x0F, 0xE8, 0xB1, 0xD8, 0x44,
+	0x0A, 0xEE, 0x43, 0x57, 0x36,
+	0x03, 0xDD, 0x21, 0x04, 0xD5,
+	0x0F, 0xD8, 0x4A, 0xF4, 0x96,
+	0x00, 0x49, 0x0E, 0xE9, 0xFC,
+	0x0E, 0x07, 0xD8, 0x7E, 0x41,
+	0x04, 0x08, 0x7B, 0x84, 0xA7,
+	0x0A, 0xF3, 0xE7, 0xC3, 0xC8,
+	0x03, 0x6A, 0xE2, 0x62, 0x20,
+	0x01, 0x8C, 0xE7, 0x2A, 0xC3,
+	0x02, 0xEC, 0x05, 0x08, 0x62,
+	0x0C, 0x4D, 0x28, 0x49, 0xAD,
+	0x08, 0x0C, 0x65, 0x1C, 0xEE,
+	0x08, 0x63, 0x6C, 0xB3, 0x87,
+	0x05, 0x04, 0xB6, 0xE0, 0x16,
+	0x0E, 0xAA, 0x05, 0x37, 0x89,
+	0x08, 0x1C, 0xE9, 0x3E, 0x43,
+	0x02, 0x19, 0xC0, 0xF6, 0x89,
+	0x04, 0xF4, 0xC7, 0x83, 0xCF,
+	0x0E, 0xB2, 0xE9, 0x42, 0x11,
+	0x0E, 0x4F, 0xEA, 0x9D, 0xC6,
+	0x05, 0xC4, 0xC4, 0x40, 0x21,
+	0x08, 0x4E, 0x55, 0x82, 0x07,
+	0x06, 0x8E, 0x24, 0x27, 0xFC,
+	0x0E, 0xDF, 0x92, 0xD3, 0x01,
+	0x00, 0xC2, 0xB4, 0xB2, 0x62,
+	0x0F, 0x5B, 0x67, 0x83, 0xFA,
+	0x01, 0x6D, 0xD1, 0x6D, 0x7E,
+	0x0C, 0x8A, 0xF7, 0x99, 0x70,
+	0x01, 0x53, 0xDA, 0xEA, 0x64,
+	0x03, 0x85, 0xED, 0x9A, 0x59,
+	0x01, 0xFF, 0x07, 0xBD, 0x5D,
+	0x0F, 0x96, 0x5E, 0x2E, 0x4A,
+	0x05, 0x94, 0x13, 0x8D, 0xAB,
+	0x09, 0x88, 0x80, 0x76, 0x6D,
+	0x0C, 0xAB, 0x09, 0xD5, 0xEA,
+	0x06, 0x2B, 0x4B, 0xE9, 0xA5,
+	0x0D, 0x26, 0xA2, 0x20, 0xB1,
+	0x07, 0x69, 0xBF, 0x75, 0x0E,
+	0x01, 0xCE, 0xD3, 0x44, 0x9A,
+	0x08, 0xB1, 0x96, 0xCA, 0x28,
+	0x07, 0xAE, 0xE2, 0xC0, 0xF3,
+	0x07, 0xF4, 0x14, 0x48, 0xE7,
+	0x0A, 0xDA, 0xF4, 0x3B, 0xC3,
+	0x0F, 0x0E, 0xBC, 0x5C, 0xC8,
+	0x0C, 0xEA, 0xE7, 0x93, 0x36,
+	0x02, 0x45, 0x1B, 0x5B, 0x13,
+	0x01, 0x00, 0x84, 0x47, 0xBB,
+	0x0C, 0x1F, 0x82, 0xF2, 0x38,
+	0x0D, 0x1B, 0x71, 0xCF, 0xBD,
+	0x0D, 0x4C, 0xC0, 0x60, 0x1A,
+	0x02, 0xFE, 0x8B, 0x10, 0x60,
+	0x06, 0x3E, 0x68, 0x35, 0xB7,
+	0x08, 0x35, 0x55, 0x50, 0x29,
+	0x00, 0xDC, 0xF0, 0xE7, 0x49,
+	0x0B, 0xA8, 0x92, 0xE0, 0x0A,
+	0x0E, 0x69, 0xF7, 0x9B, 0xFC,
+	0x08, 0xF8, 0xB9, 0xB0, 0xCA,
+	0x00, 0x8F, 0x3E, 0x6C, 0xD4,
+	0x09, 0x36, 0x6E, 0x26, 0xA2,
+	0x00, 0x08, 0x02, 0x76, 0xAF,
+	0x06, 0x26, 0x04, 0x50, 0xA4,
+	0x0F, 0x64, 0x96, 0xFA, 0x10,
+	0x01, 0x82, 0xC6, 0x51, 0x65,
+	0x07, 0x12, 0x59, 0x4B, 0x3E,
+	0x09, 0xD0, 0x6B, 0x68, 0x41,
+	0x0F, 0xEA, 0xA0, 0x54, 0x7C,
+	0x0B, 0x00, 0x6E, 0x9D, 0x9E,
+	0x01, 0xA0, 0x3D, 0xAF, 0x6C,
+	0x08, 0xEF, 0x8E, 0x78, 0x7D,
+	0x08, 0x79, 0x22, 0x99, 0x2D,
+	0x04, 0x78, 0x84, 0xA9, 0x18,
+	0x06, 0xDF, 0xAE, 0xC8, 0x86,
+	0x01, 0x84, 0xE7, 0x58, 0x32,
+	0x05, 0xC0, 0x20, 0x57, 0xBE,
+	0x09, 0x2D, 0xF9, 0x35, 0x33,
+	0x08, 0x8E, 0xE3, 0x49, 0x7A,
+	0x06, 0x71, 0xFF, 0x78, 0xEB,
+	0x00, 0xD6, 0xD9, 0x82, 0xD7,
+	0x05, 0x40, 0xA9, 0x79, 0x77,
+	0x01, 0x9D, 0x21, 0x28, 0x22,
+	0x0A, 0x38, 0x98, 0x5B, 0x21,
+	0x0F, 0x1E, 0x35, 0xF7, 0x27,
+	0x06, 0x41, 0x2C, 0x5A, 0x07,
+	0x01, 0x33, 0x12, 0x38, 0x1A,
+	0x08, 0x7A, 0xA8, 0x04, 0xD2,
+	0x09, 0xCA, 0xB1, 0x58, 0x11,
+	0x01, 0x42, 0xB6, 0xF9, 0xD8,
+	0x01, 0xF6, 0x18, 0x66, 0x01,
+	0x09, 0x46, 0x97, 0xF8, 0x63,
+	0x05, 0xAD, 0xC1, 0xF7, 0x41,
+	0x04, 0x3B, 0xE5, 0xAF, 0x2A,
+	0x08, 0x48, 0x92, 0xE2, 0x47,
+	0x00, 0x4B, 0x2D, 0xC4, 0x8E,
+	0x00, 0xBD, 0xB3, 0x4F, 0xFE,
+	0x07, 0xE2, 0xF7, 0xD9, 0xCC,
+	0x08, 0x57, 0xDA, 0x79, 0xE3,
+	0x0A, 0xAC, 0xF1, 0xB8, 0xB1,
+	0x01, 0x10, 0x08, 0x4A, 0x97,
+	0x09, 0x61, 0xB6, 0xB7, 0x21,
+	0x0C, 0x69, 0x3B, 0x2A, 0xB7,
+	0x0D, 0xD5, 0x0C, 0x06, 0x72,
+	0x03, 0xAE, 0xD8, 0xB1, 0xD6,
+	0x09, 0xE3, 0xEC, 0xAD, 0x12,
+	0x06, 0x0B, 0x5E, 0xD1, 0x9F,
+	0x0D, 0x65, 0x7D, 0x8E, 0xF4,
+	0x06, 0x38, 0xA8, 0x0C, 0x61,
+	0x07, 0x66, 0x87, 0xF8, 0x71,
+	0x08, 0x6F, 0x7E, 0x9B, 0x84,
+	0x0D, 0x6C, 0x8E, 0xE6, 0xE5,
+	0x01, 0x63, 0x8E, 0xEC, 0xA2,
+	0x0A, 0x14, 0xF7, 0x27, 0x6A,
+	0x0A, 0xFA, 0x9A, 0x43, 0x4A,
+	0x09, 0xF2, 0x34, 0x6F, 0xD9,
+	0x09, 0x98, 0x08, 0x65, 0x1A,
+	0x05, 0xD5, 0x1E, 0xAC, 0xB2,
+	0x0E, 0x5D, 0xE6, 0xB0, 0xAC,
+	0x0C, 0xBA, 0xD7, 0x05, 0x3B,
+	0x0B, 0xB8, 0x18, 0xE9, 0x3D,
+	0x05, 0x12, 0x15, 0xC2, 0xF6,
+	0x0F, 0x0E, 0xF0, 0xF9, 0xC3,
+	0x07, 0x97, 0x92, 0x09, 0xCE,
+	0x01, 0x66, 0x6D, 0x8E, 0x0C,
+	0x0F, 0x55, 0x24, 0xC4, 0x40,
+	0x09, 0x1A, 0x4E, 0x59, 0x86,
+	0x04, 0xDC, 0x88, 0x33, 0xE5,
+	0x06, 0x96, 0xAB, 0x93, 0x43,
+	0x00, 0x18, 0xCA, 0x38, 0x7B,
+	0x02, 0xC7, 0x5B, 0x6A, 0x8A,
+	0x0A, 0x0D, 0x6B, 0xD6, 0xE7,
+	0x0D, 0x54, 0x0E, 0x57, 0x66,
+	0x00, 0x39, 0xD2, 0x7A, 0x19,
+	0x0C, 0x3B, 0x05, 0xE0, 0x5A,
+	0x03, 0x60, 0xCF, 0x07, 0xBE,
+	0x0E, 0x64, 0x10, 0xBD, 0xAA,
+	0x0F, 0x9B, 0x15, 0x3F, 0xDA,
+	0x02, 0x20, 0x68, 0xB0, 0xC8,
+	0x04, 0x9C, 0xAB, 0x0D, 0x69,
+	0x0D, 0x14, 0x2B, 0x4F, 0x59,
+	0x05, 0x3F, 0x86, 0xA8, 0x29,
+	0x00, 0x94, 0xA8, 0xFF, 0x45,
+	0x06, 0xB0, 0xCE, 0x93, 0x74,
+	0x0A, 0xDB, 0xB1, 0xCC, 0xB8,
+	0x08, 0x14, 0xAD, 0x08, 0x62,
+	0x09, 0xA0, 0x76, 0x54, 0x58,
+	0x07, 0x0B, 0xD9, 0x3A, 0xBF,
+	0x0B, 0x7C, 0x6E, 0xF0, 0x9C,
+	0x08, 0x25, 0x39, 0x41, 0x55,
+	0x0C, 0x2E, 0xEF, 0x1B, 0x5F,
+	0x03, 0x11, 0x00, 0x89, 0x24,
+	0x01, 0x46, 0x9B, 0xDE, 0xB2,
+	0x06, 0xD7, 0xAF, 0xB2, 0x4B,
+	0x06, 0xCD, 0xEC, 0xD0, 0xE3,
+	0x03, 0x51, 0x1C, 0x0B, 0x11,
+	0x0D, 0x1E, 0x9E, 0xC8, 0xB5,
+	0x0C, 0xE3, 0x57, 0x73, 0xE1,
+	0x09, 0x5E, 0x4D, 0xC2, 0x2A,
+	0x05, 0xD1, 0xA8, 0x90, 0xD7,
+	0x07, 0xB6, 0x60, 0x75, 0x4A,
+	0x0C, 0x1E, 0xF0, 0xB9, 0x90,
+	0x08, 0x76, 0x87, 0x32, 0x2C,
+	0x06, 0x8E, 0x3E, 0xA2, 0x66,
+	0x00, 0xA9, 0xB8, 0xC4, 0xF2,
+	0x0F, 0x1F, 0x66, 0xE2, 0xD0,
+	0x0C, 0x97, 0x84, 0x96, 0xFC,
+	0x0A, 0x31, 0x20, 0xD0, 0x13,
+	0x05, 0xFD, 0x16, 0x2C, 0x49,
+	0x0C, 0x7D, 0xD0, 0x7D, 0xAC,
+	0x01, 0x6B, 0xEA, 0x86, 0x10,
+	0x04, 0xB9, 0x81, 0xC2, 0x93,
+	0x0D, 0x55, 0xAD, 0x1C, 0x3F,
+	0x07, 0xD0, 0xEF, 0x0F, 0xF8,
+	0x01, 0xEE, 0x8C, 0xDC, 0xA5,
+	0x01, 0x1A, 0x1C, 0xD8, 0xAD,
+	0x06, 0xAD, 0x9C, 0x45, 0x75,
+	0x02, 0x11, 0x84, 0xF9, 0x1A,
+	0x03, 0x49, 0x28, 0xA1, 0x5E,
+	0x04, 0x09, 0x6D, 0xF0, 0x01,
+	0x03, 0x01, 0x8C, 0xBF, 0x09,
+	0x06, 0x2C, 0x12, 0x96, 0x71,
+	0x03, 0xED, 0x54, 0xD1, 0x82,
+	0x07, 0xD5, 0x40, 0x29, 0x33,
+	0x07, 0x03, 0x9D, 0xAB, 0xE4,
+	0x02, 0x43, 0x3A, 0x5A, 0xD3,
+	0x0D, 0xDC, 0x7F, 0xF0, 0x7F,
+	0x08, 0x26, 0x81, 0x20, 0xE6,
+	0x0C, 0xF9, 0xB1, 0x4E, 0x7A,
+	0x06, 0xBA, 0x78, 0x88, 0x00,
+	0x09, 0xC9, 0x8A, 0xB9, 0xE1,
+	0x0B, 0x91, 0x42, 0xA8, 0xBF,
+	0x0E, 0x5B, 0x98, 0xEA, 0x6F,
+	0x0B, 0x54, 0xC4, 0x9B, 0xF4,
+	0x08, 0xEB, 0x2C, 0x7D, 0xBD,
+	0x01, 0xAD, 0xBB, 0x89, 0xE5,
+	0x0A, 0x81, 0x48, 0xF6, 0xE4,
+	0x0C, 0x3A, 0x4F, 0x5D, 0x44,
+	0x06, 0x70, 0xBD, 0xBD, 0x0A,
+	0x0C, 0x3F, 0xE1, 0x77, 0xC5,
+	0x0C, 0x82, 0x52, 0xB4, 0x79,
+	0x03, 0x62, 0xA4, 0x71, 0xBF,
+	0x01, 0x31, 0x10, 0x06, 0x0F,
+	0x03, 0x95, 0x60, 0x3D, 0x37,
+	0x02, 0x85, 0x68, 0x7B, 0x24,
+	0x07, 0xE4, 0xD5, 0x4C, 0x06,
+	0x02, 0x8D, 0x2E, 0xE8, 0xB1,
+	0x06, 0x59, 0xE1, 0xEE, 0x89,
+	0x0B, 0x76, 0x0B, 0x52, 0x11,
+	0x08, 0x75, 0xFE, 0x55, 0x5C,
+	0x04, 0x9E, 0xBA, 0x99, 0x0E,
+	0x0A, 0x7B, 0x66, 0x87, 0x78,
+	0x07, 0x41, 0x4F, 0x8B, 0x99,
+	0x0D, 0x27, 0x88, 0xF3, 0xE6,
+	0x0B, 0xC9, 0xD3, 0x6A, 0xE2,
+	0x02, 0x20, 0x10, 0x92, 0x3A,
+	0x03, 0x42, 0x9A, 0x42, 0x54,
+	0x0C, 0xD3, 0xF6, 0x49, 0xEF,
+	0x0F, 0xA9, 0x98, 0x0C, 0xE5,
+	0x0A, 0x3F, 0x51, 0x63, 0xAC,
+	0x03, 0xA6, 0x5D, 0x06, 0xB6,
+	0x05, 0x14, 0xDA, 0xAA, 0xC5,
+	0x01, 0xCF, 0x08, 0x1C, 0xEB,
+	0x05, 0xD4, 0xB2, 0x1F, 0xC2,
+	0x0E, 0xC5, 0x8E, 0xF6, 0xFF,
+	0x0B, 0xD6, 0x97, 0x32, 0x89,
+	0x07, 0xDB, 0x87, 0xC0, 0x4A,
+	0x01, 0xC6, 0xD5, 0xC4, 0xC4,
+	0x00, 0x21, 0x18, 0x68, 0x57,
+	0x0C, 0xF0, 0x77, 0x8A, 0x11,
+	0x0C, 0xEC, 0x92, 0xDF, 0x93,
+	0x0A, 0xB0, 0xFA, 0xC6, 0x34,
+	0x07, 0x22, 0x67, 0x49, 0xE7,
+	0x01, 0x3B, 0x3D, 0x6D, 0xD8,
+	0x04, 0xFC, 0xB4, 0x06, 0x57,
+	0x0F, 0x72, 0x19, 0xD2, 0xFA,
+	0x00, 0x20, 0x84, 0x85, 0xEF,
+	0x02, 0x9D, 0x41, 0xFF, 0x87,
+	0x06, 0x2C, 0x04, 0x0E, 0x1D,
+	0x09, 0xCB, 0x2F, 0x95, 0x27,
+	0x0D, 0xAB, 0x8B, 0x88, 0x80,
+	0x09, 0x30, 0x9C, 0xA5, 0x10,
+	0x0B, 0xB9, 0x14, 0x27, 0x0F,
+	0x00, 0xA5, 0x5B, 0x2A, 0xE6,
+	0x00, 0x11, 0x14, 0x69, 0x7F,
+	0x05, 0xAC, 0xB2, 0xCF, 0x1F,
+	0x0E, 0x1E, 0x67, 0xB0, 0x58,
+	0x03, 0x29, 0x94, 0xAD, 0xAE,
+	0x0B, 0x73, 0xA4, 0xF9, 0xC5,
+	0x01, 0x65, 0x2F, 0xDB, 0xC5,
+	0x01, 0xC7, 0x40, 0x0F, 0x74,
+	0x04, 0x48, 0x85, 0x37, 0x07,
+	0x06, 0x34, 0x0E, 0x47, 0xEA,
+	0x0D, 0x17, 0xAE, 0x80, 0x86,
+	0x09, 0xB9, 0xF6, 0x17, 0x93,
+	0x0A, 0xAA, 0x72, 0x93, 0xF2,
+	0x02, 0x7E, 0x89, 0x4C, 0x31,
+	0x01, 0x28, 0xD6, 0xFA, 0xCB,
+	0x0D, 0x65, 0x9E, 0x3E, 0x31,
+	0x04, 0x9E, 0xA0, 0xB5, 0xF5,
+	0x0A, 0x2D, 0x9D, 0x5D, 0xC8,
+	0x0E, 0x49, 0x2B, 0xA8, 0x90,
+	0x05, 0x17, 0xB6, 0x68, 0x77,
+	0x0D, 0x3C, 0x1F, 0x71, 0x32,
+	0x00, 0x4A, 0x76, 0xAF, 0xBD,
+	0x0C, 0x54, 0x8E, 0x16, 0xEC,
+	0x06, 0x22, 0x01, 0x08, 0xC2,
+	0x02, 0xAC, 0x37, 0xA6, 0xE4,
+	0x0B, 0xAD, 0x3F, 0x64, 0x96,
+	0x0C, 0x9A, 0x9B, 0x80, 0xFE,
+	0x09, 0xA6, 0x7D, 0x18, 0xBA,
+	0x0B, 0x3C, 0x79, 0xD0, 0x6B,
+	0x0E, 0xC1, 0x6F, 0xEA, 0xA0,
+	0x00, 0xBC, 0xBB, 0x87, 0xCE,
+	0x03, 0xD7, 0xD1, 0x21, 0x9C,
+	0x0F, 0x6D, 0x50, 0xEF, 0x0F,
+	0x08, 0x3D, 0xF1, 0x73, 0x20,
+	0x06, 0xED, 0x1E, 0x70, 0x58,
+	0x09, 0x1C, 0x6D, 0x5A, 0x46,
+	0x05, 0xE0, 0x13, 0x84, 0xE5,
+	0x02, 0x6B, 0x80, 0xC8, 0xB1,
+	0x01, 0x7E, 0xC9, 0x2D, 0xF9,
+	0x09, 0x13, 0x01, 0x8C, 0x9B,
+	0x00, 0xFA, 0x2C, 0x75, 0x96,
+	0x01, 0x7B, 0x40, 0xDA, 0x9D,
+	0x08, 0xD2, 0xD7, 0xC0, 0x85,
+	0x05, 0x77, 0x03, 0x99, 0x11,
+	0x0E, 0xA2, 0x41, 0x34, 0x83,
+	0x00, 0x21, 0x3C, 0x15, 0xF0,
+	0x02, 0xE0, 0x82, 0x41, 0xE9,
+	0x03, 0x3D, 0x39, 0xBC, 0x12,
+	0x0A, 0xDA, 0xB8, 0x9C, 0xC8,
+	0x04, 0x23, 0x09, 0xCE, 0x2D,
+	0x0E, 0x7B, 0x31, 0x66, 0x36,
+	0x0D, 0x92, 0x5B, 0xF2, 0x6A,
+	0x0E, 0x80, 0xB9, 0x42, 0xD7,
+	0x06, 0x58, 0xEB, 0x28, 0xF1,
+	0x07, 0x41, 0xAD, 0xB6, 0x18,
+	0x0E, 0xAA, 0x4D, 0x4A, 0xF2,
+	0x0E, 0x07, 0x36, 0x4F, 0x5D,
+	0x04, 0x86, 0x70, 0xBD, 0xB3,
+	0x01, 0xBC, 0x3F, 0xE4, 0x77,
+	0x05, 0xCC, 0x82, 0x5F, 0x69,
+	0x08, 0xF3, 0xA6, 0xA4, 0x71,
+	0x05, 0x71, 0x35, 0x10, 0x08,
+	0x0F, 0x10, 0x55, 0x65, 0x3D,
+	0x0E, 0xA0, 0xC7, 0x6D, 0xBB,
+	0x0E, 0xB3, 0x3E, 0x54, 0xDC,
+	0x0F, 0x32, 0x4D, 0x2B, 0xA8,
+	0x08, 0x54, 0x19, 0xE1, 0x6E,
+	0x09, 0x5F, 0xAA, 0x8B, 0x4F,
+	0x0C, 0x02, 0x55, 0xE7, 0x5C,
+	0x0E, 0x74, 0x9E, 0xBA, 0x89,
+	0x0E, 0xE1, 0x7F, 0x62, 0x07,
+	0x08, 0x7F, 0xC1, 0xEF, 0x8B,
+	0x08, 0x64, 0x67, 0x68, 0xF3,
+	0x06, 0xC5, 0x48, 0xE3, 0x6A,
+	0x02, 0x62, 0x22, 0x14, 0x06,
+	0x0B, 0x2A, 0xC0, 0xBA, 0x5F,
+	0x05, 0x0A, 0xD3, 0xF6, 0xBB,
+	0x07, 0x49, 0x09, 0x94, 0x4C,
+	0x0D, 0x9B, 0xFF, 0xDC, 0x63,
+	0x0C, 0xB3, 0xC7, 0xDD, 0x06,
+	0x06, 0xEC, 0x16, 0xBA, 0xF7,
+	0x05, 0x2B, 0xCB, 0xB8, 0x1C,
+	0x0B, 0x3D, 0x79, 0x16, 0x99,
+	0x0A, 0x74, 0xED, 0x02, 0xF0,
+	0x0E, 0x63, 0x3F, 0x17, 0x32,
+	0x00, 0xCC, 0xB1, 0xEB, 0x4D,
+	0x00, 0x95, 0x24, 0x55, 0xD4,
+	0x04, 0x40, 0x21, 0x14, 0x93,
+	0x0D, 0x07, 0x56, 0xD0, 0x8A,
+	0x0D, 0x25, 0xCC, 0x9F, 0xDF,
+	0x09, 0x57, 0xD7, 0x98, 0xDA,
+	0x0C, 0x3F, 0x02, 0xC7, 0x59,
+	0x0E, 0x0D, 0x9A, 0x07, 0x6D,
+	0x02, 0x29, 0x8E, 0x54, 0x1A,
+	0x0E, 0x15, 0x50, 0x39, 0x12,
+	0x00, 0xEE, 0xCE, 0x33, 0x95,
+	0x05, 0x1A, 0xBD, 0xE1, 0x3F,
+	0x07, 0xBE, 0x2A, 0xE4, 0x12,
+	0x0D, 0xA3, 0xCB, 0x9B, 0x15,
+	0x03, 0x8D, 0xAF, 0x89, 0x88,
+	0x00, 0x42, 0x34, 0x9C, 0xAB,
+	0x0D, 0xE9, 0xBD, 0x14, 0x2B,
+	0x06, 0x59, 0xC7, 0xBD, 0xA6,
+	0x0F, 0x62, 0x51, 0x94, 0xA9,
+	0x05, 0x41, 0x7E, 0x32, 0xDF,
+	0x06, 0x75, 0xF8, 0xD6, 0x30,
+	0x0A, 0xFA, 0xAB, 0x94, 0xAF,
+	0x0E, 0xE0, 0x70, 0x20, 0x7F,
+	0x04, 0x48, 0x65, 0x0B, 0xD1,
+	0x0E, 0x3F, 0x3E, 0x7E, 0x0E,
+	0x0C, 0x5C, 0xCA, 0x21, 0x53,
+	0x07, 0x9F, 0x35, 0xAE, 0x2E,
+	0x0B, 0x57, 0x10, 0x91, 0x0A,
+	0x04, 0x61, 0x3B, 0x56, 0x11,
+	0x09, 0x76, 0xD5, 0xD6, 0x9E,
+	0x02, 0x4B, 0x7A, 0x4D, 0x4C,
+	0x00, 0x63, 0x2C, 0xD2, 0xFE,
+	0x02, 0x9D, 0x83, 0x9C, 0xBE,
+	0x08, 0x35, 0xB3, 0x60, 0xB5,
+	0x05, 0x50, 0x29, 0x5E, 0x5D,
+	0x09, 0xE5, 0x29, 0xEB, 0x68,
+	0x0A, 0xCA, 0xEF, 0x36, 0x78,
+	0x0E, 0x86, 0x1E, 0x13, 0x78,
+	0x09, 0x90, 0x49, 0xF6, 0x85,
+	0x0E, 0x6C, 0x56, 0x8A, 0xBC,
+	0x04, 0x22, 0xDF, 0x81, 0x09,
+	0x0B, 0xF2, 0x4E, 0x3D, 0xA6,
+	0x0D, 0xD1, 0x4D, 0x33, 0x64,
+	0x06, 0xFC, 0x99, 0x19, 0x8A,
+	0x06, 0x51, 0xA7, 0xFD, 0x1C,
+	0x03, 0xC9, 0x5C, 0x71, 0x90,
+	0x01, 0x6A, 0x3D, 0xEB, 0xE8,
+	0x09, 0xD2, 0x5C, 0xB7, 0xC1,
+	0x0E, 0x93, 0xD7, 0x51, 0x21,
+	0x0C, 0x2F, 0x6C, 0xD4, 0x07,
+	0x0F, 0xF8, 0x3D, 0xF5, 0x9A,
+	0x00, 0x94, 0xEF, 0x1E, 0x7C,
+	0x08, 0xA9, 0x1C, 0xED, 0x5C,
+	0x05, 0xC4, 0xE2, 0x31, 0x0E,
+	0x05, 0x58, 0x6F, 0x4D, 0xC8,
+	0x01, 0x5A, 0x7E, 0xCD, 0xF0,
+	0x09, 0x35, 0x33, 0x01, 0x8C,
+	0x01, 0x4B, 0xFA, 0x2A, 0x75,
+	0x06, 0x78, 0xF9, 0xA0, 0xD6,
+	0x0D, 0x82, 0x57, 0xD5, 0x40,
+	0x0E, 0x79, 0x77, 0x03, 0x9D,
+	0x07, 0xAE, 0xA0, 0x4E, 0x65,
+	0x0E, 0xD9, 0xA1, 0x5E, 0x15,
+	0x00, 0x7B, 0xE2, 0x66, 0x4B,
+	0x09, 0xDA, 0x3C, 0x79, 0xBB,
+	0x02, 0x38, 0xDA, 0x38, 0x92,
+	0x08, 0x04, 0x21, 0x04, 0x80,
+	0x00, 0xDE, 0x9B, 0xAC, 0x00,
+	0x04, 0xFD, 0x92, 0x66, 0xB0,
+	0x0A, 0x66, 0x03, 0x24, 0x04,
+	0x07, 0xF4, 0x58, 0xD6, 0x6E,
+	0x01, 0xF7, 0x41, 0x90, 0xF9,
+	0x05, 0xAF, 0xAA, 0xBC, 0x08,
+	0x02, 0xEE, 0x07, 0x07, 0x0D,
+	0x0D, 0x44, 0x86, 0x4D, 0xFF,
+	0x03, 0x43, 0xBC, 0x02, 0xA2,
+	0x07, 0xC5, 0xCC, 0xBF, 0x11,
+	0x04, 0x79, 0xF3, 0x5F, 0xE6,
+	0x01, 0xB5, 0x71, 0x0C, 0x52,
+	0x08, 0x46, 0x13, 0xA8, 0x23,
+	0x0D, 0x37, 0x22, 0x89, 0xB4,
+	0x0B, 0x24, 0xB7, 0xE4, 0xD4,
+	0x0C, 0x06, 0x32, 0x8D, 0xC7,
+	0x03, 0xB1, 0xD6, 0x59, 0x0A,
+	0x02, 0x83, 0x5F, 0x36, 0x08,
+	0x06, 0xD5, 0xE2, 0x9B, 0xF8,
+	0x05, 0x8F, 0x94, 0x9E, 0xFA,
+	0x01, 0x8C, 0x41, 0x75, 0x2E,
+	0x0F, 0xF1, 0xDF, 0xC1, 0x2F,
+	0x02, 0x99, 0xC4, 0xA7, 0x62,
+	0x09, 0x06, 0xC4, 0xC2, 0xC0,
+	0x0B, 0xE3, 0xA6, 0xAE, 0xD5,
+	0x0D, 0x26, 0xEE, 0x65, 0x70,
+	0x0F, 0x44, 0xCA, 0xC7, 0xBE,
+	0x08, 0x6E, 0x09, 0x3D, 0x60,
+	0x0D, 0x64, 0xDA, 0x4F, 0xD1,
+	0x0B, 0xAC, 0x33, 0xE5, 0x5D,
+	0x06, 0xB6, 0xEC, 0x18, 0xA3,
+	0x01, 0x80, 0x31, 0xC5, 0x31,
+	0x07, 0x6C, 0x1D, 0xFB, 0xD6,
+	0x01, 0x42, 0x56, 0xCB, 0x0E,
+	0x00, 0xFF, 0x83, 0xF1, 0xD2,
+	0x0A, 0x09, 0xCE, 0xF7, 0x67,
+	0x0D, 0x8A, 0x91, 0xC8, 0xC8,
+	0x0F, 0x41, 0x5A, 0x2F, 0x91,
+	0x05, 0xD0, 0xA6, 0x74, 0xDC,
+	0x03, 0x15, 0x67, 0xEA, 0x92,
+	0x04, 0x93, 0x53, 0x30, 0x18,
+	0x0A, 0x34, 0xBD, 0xA2, 0xC7,
+	0x00, 0xC7, 0x6B, 0x3C, 0x0D,
+	0x0D, 0xD8, 0x29, 0xFD, 0x54,
+	0x0A, 0x57, 0x93, 0xF2, 0xBA,
+	0x02, 0x32, 0x6E, 0x24, 0x33,
+	0x05, 0xA4, 0x1E, 0x1F, 0x62,
+	0x0D, 0x4E, 0x3D, 0xA8, 0xA4,
+	0x02, 0xD4, 0x20, 0x4F, 0xD1,
+	0x05, 0x6A, 0x0E, 0x2D, 0x43,
+	0x08, 0x80, 0x43, 0xB0, 0xD6,
+	0x0B, 0x0D, 0xE9, 0xB9, 0x14,
+	0x03, 0x2F, 0x5B, 0x23, 0xB5,
+	0x0D, 0xA6, 0x60, 0x31, 0x94,
+	0x00, 0xFF, 0xA5, 0x8E, 0xB2,
+	0x05, 0xDF, 0x70, 0x10, 0x98,
+	0x03, 0xDB, 0x1E, 0x88, 0x94,
+	0x0C, 0xAF, 0x00, 0x45, 0xA4,
+	0x04, 0x55, 0xA8, 0x61, 0x09,
+	0x0B, 0x35, 0xDB, 0xC3, 0xFE,
+	0x04, 0x7C, 0x5C, 0xC8, 0x25,
+	0x02, 0x47, 0x5F, 0x38, 0x62,
+	0x0E, 0x9B, 0xB7, 0x1D, 0xD1,
+	0x0A, 0x81, 0x05, 0x39, 0x76,
+	0x07, 0xD3, 0x62, 0x28, 0x55,
+	0x06, 0xB2, 0x8B, 0x70, 0x50,
+	0x05, 0xC1, 0xA7, 0x28, 0x92,
+	0x0C, 0x8B, 0x1D, 0x63, 0x9E,
+	0x0C, 0xE8, 0x31, 0xB1, 0x20,
+	0x07, 0xF5, 0xD4, 0xAF, 0x1E,
+	0x0C, 0xC2, 0xE3, 0xCD, 0x75,
+	0x09, 0x11, 0x4A, 0x97, 0xB6,
+	0x08, 0x6F, 0x00, 0x7E, 0x9D,
+	0x08, 0xA0, 0x14, 0x4A, 0x76,
+	0x0D, 0x77, 0xE8, 0xD2, 0x04,
+	0x04, 0xE7, 0xA2, 0xA2, 0x41,
+	0x08, 0x5B, 0xF6, 0x2A, 0xB4,
+	0x06, 0xFC, 0xD7, 0x2B, 0xFC,
+	0x04, 0x8F, 0x78, 0x9A, 0x99,
+	0x02, 0x8F, 0xD0, 0xA3, 0xB7,
+	0x06, 0x73, 0x4F, 0xBC, 0x7D,
+	0x01, 0x72, 0xEA, 0x41, 0x6B,
+	0x0A, 0xA0, 0x56, 0x3C, 0xBB,
+	0x01, 0x86, 0x14, 0x55, 0xD2,
+	0x01, 0xD5, 0xAB, 0x6C, 0xD0,
+	0x0D, 0x46, 0x7B, 0x3B, 0x3B,
+	0x03, 0x69, 0x11, 0x6B, 0x94,
+	0x0E, 0x11, 0x2D, 0x9C, 0x2D,
+	0x0D, 0x07, 0x80, 0x82, 0x11,
+	0x04, 0xED, 0xDF, 0xEF, 0x4D,
+	0x08, 0xE8, 0xDE, 0x7E, 0xC9,
+	0x0F, 0xB0, 0xB4, 0x35, 0x4B,
+	0x0C, 0xEA, 0xCB, 0xFA, 0x2C,
+	0x04, 0x1F, 0xF8, 0xFB, 0xA0,
+	0x0E, 0xDF, 0xC2, 0xD5, 0x55,
+	0x0A, 0xA0, 0x4E, 0x77, 0x07,
+	0x05, 0x27, 0x2E, 0x20, 0xC3,
+	0x01, 0x6F, 0x59, 0xA7, 0xDE,
+	0x05, 0xF5, 0x43, 0x62, 0xE7,
+	0x03, 0x29, 0xDA, 0x3A, 0xF9,
+	0x09, 0x52, 0xB8, 0x58, 0x38,
+	0x09, 0xB9, 0x84, 0x23, 0x09,
+	0x0B, 0x33, 0x3E, 0x9D, 0x52,
+	0x0A, 0xB6, 0x9D, 0x90, 0xDB,
+	0x08, 0x6F, 0x5D, 0x83, 0x1D,
+	0x0E, 0x97, 0x73, 0xDA, 0x6B,
+	0x05, 0x40, 0x77, 0x47, 0xAD,
+	0x01, 0x00, 0x92, 0xAA, 0x80,
+	0x08, 0xF2, 0xEA, 0x01, 0x3A,
+	0x07, 0x5D, 0xC7, 0x04, 0xF0,
+	0x0C, 0x02, 0xC3, 0xBC, 0x3F,
+	0x00, 0xF7, 0xC1, 0x4C, 0xC8,
+	0x01, 0xB4, 0x7D, 0x75, 0xE8,
+	0x06, 0x71, 0xB5, 0x77, 0xFB,
+	0x01, 0x78, 0x86, 0x13, 0x95,
+	0x00, 0x4D, 0xD7, 0x22, 0x85,
+	0x0F, 0xFB, 0x24, 0xB3, 0x64,
+	0x08, 0xDC, 0x06, 0x32, 0xBF,
+	0x0F, 0xE8, 0x31, 0xD2, 0x86,
+	0x0F, 0xCA, 0x83, 0x5B, 0x6F,
+	0x09, 0x5F, 0x51, 0x06, 0x95,
+	0x05, 0xDC, 0x0E, 0x74, 0x9E,
+	0x0A, 0x0B, 0x08, 0x61, 0x7B,
+	0x0E, 0x02, 0x54, 0x7F, 0x01,
+	0x07, 0x1F, 0x3D, 0x04, 0x67,
+	0x00, 0xF6, 0xE2, 0xC5, 0x88,
+	0x0B, 0x4E, 0x62, 0x62, 0xE0,
+	0x08, 0x1C, 0x87, 0x2E, 0x83,
+	0x03, 0x6E, 0x81, 0x06, 0x53,
+	0x0E, 0x40, 0xAB, 0x4D, 0x9A,
+	0x01, 0x85, 0xA1, 0x1E, 0x2B,
+	0x01, 0x63, 0x28, 0x37, 0xDC,
+	0x0D, 0x3F, 0x3E, 0xE0, 0x8C,
+	0x0E, 0xE3, 0x8D, 0xAB, 0xCB,
+	0x08, 0x35, 0x6D, 0x3F, 0xC0,
+	0x02, 0x18, 0x45, 0x76, 0xCD,
+	0x0E, 0xF1, 0x7B, 0x83, 0xDF,
+	0x05, 0x7B, 0x8D, 0x4E, 0x9B,
+	0x07, 0xE4, 0x0E, 0x91, 0xC6,
+	0x07, 0xC5, 0x40, 0xCD, 0x61,
+	0x0A, 0x77, 0xD1, 0x8B, 0xB4,
+	0x0C, 0x0A, 0xBD, 0x27, 0xEC,
+	0x02, 0x66, 0x3B, 0x53, 0x30,
+	0x0A, 0x03, 0x9C, 0xB9, 0xA2,
+	0x07, 0xF0, 0xCF, 0x0D, 0x0F,
+	0x0D, 0x6D, 0x5C, 0x2D, 0x7D,
+	0x04, 0x8B, 0xF3, 0x97, 0x70,
+	0x09, 0x53, 0xDD, 0x6A, 0x24,
+	0x01, 0x4C, 0x48, 0x9C, 0x17,
+	0x03, 0x56, 0xA3, 0xB8, 0x2E,
+	0x04, 0x93, 0x39, 0x23, 0xCF,
+	0x0B, 0xAC, 0x87, 0x8D, 0xAB,
+	0x08, 0x88, 0x48, 0xC2, 0x30,
+	0x0D, 0x92, 0xC5, 0xE8, 0x08,
+	0x07, 0x62, 0x87, 0xDF, 0x65,
+	0x0E, 0x0F, 0x6E, 0xE2, 0x84,
+	0x04, 0xE9, 0xDB, 0x41, 0x55,
+	0x03, 0xCE, 0xDB, 0x78, 0x80,
+	0x0A, 0xB1, 0x9D, 0x7A, 0xA8,
+	0x07, 0xE6, 0xE9, 0xE0, 0x39,
+	0x05, 0xDC, 0x11, 0x4E, 0x2D,
+	0x08, 0xDA, 0xF0, 0xB6, 0x83,
+	0x0D, 0x36, 0xB8, 0x51, 0x88,
+	0x04, 0xBB, 0xAF, 0x1F, 0x36,
+	0x0B, 0xFE, 0xF3, 0x57, 0x13,
+	0x02, 0xC9, 0x6C, 0x67, 0xB9,
+	0x07, 0xB2, 0x3B, 0xF2, 0x28,
+	0x07, 0x9F, 0x76, 0x4B, 0x7E,
+	0x0C, 0xCD, 0x24, 0x63, 0x28,
+	0x03, 0x7F, 0x6C, 0x9D, 0x65,
+	0x0D, 0xF7, 0x01, 0x33, 0x3D,
+	0x03, 0x1C, 0x15, 0x56, 0xA9,
+	0x0F, 0xDC, 0x20, 0xE7, 0x49,
+	0x0A, 0x11, 0x70, 0xCE, 0x17,
+	0x06, 0x68, 0x77, 0x87, 0xFC,
+	0x0E, 0xF8, 0xB9, 0x90, 0x4A,
+	0x04, 0x8F, 0x3E, 0x6A, 0x94,
+	0x0E, 0x36, 0xA2, 0x2A, 0x7D,
+	0x00, 0x88, 0x22, 0x73, 0x1E,
+	0x07, 0xA6, 0xE8, 0x5C, 0x72,
+	0x0F, 0x64, 0x9A, 0xF0, 0xC5,
+	0x01, 0x81, 0x66, 0xD7, 0x6F,
+	0x05, 0x94, 0x1A, 0xCD, 0xFC,
+	0x0D, 0xD0, 0x67, 0x62, 0x1E,
+	0x0B, 0xEA, 0xAC, 0x5E, 0x23,
+	0x0B, 0x81, 0xC2, 0x9E, 0xC8,
+	0x01, 0x21, 0x90, 0x23, 0xF3,
+	0x00, 0xEF, 0x07, 0xF5, 0x22,
+	0x0A, 0x73, 0x20, 0x94, 0xED,
+	0x02, 0x7C, 0xDE, 0x69, 0x1F,
+	0x04, 0x5D, 0x8C, 0x44, 0x42,
+	0x01, 0x84, 0xE5, 0x58, 0x6F,
+	0x0D, 0xC8, 0xA1, 0x5E, 0xF6,
+	0x09, 0x2D, 0xF9, 0xB5, 0x39,
+	0x0A, 0x8C, 0xA3, 0x4B, 0xFA,
+	0x04, 0x75, 0x1E, 0x7E, 0xFB,
+	0x0A, 0xD3, 0xB4, 0x02, 0xC7,
+	0x0D, 0x40, 0x2D, 0x79, 0x77,
+	0x03, 0x9D, 0x2B, 0xAE, 0xA2,
+	0x08, 0x38, 0x5E, 0xD9, 0xA1,
+	0x02, 0x1F, 0x8B, 0x7B, 0xFC,
+	0x06, 0x41, 0x29, 0xD6, 0x7F,
+	0x09, 0xB1, 0x52, 0x3A, 0x59,
+	0x00, 0x18, 0x2C, 0x04, 0xE3,
+	0x00, 0xC8, 0xB0, 0xD2, 0x9B,
+	0x0B, 0x47, 0xDA, 0xFD, 0x9A,
+	0x07, 0xEE, 0x6A, 0x66, 0x14,
+	0x01, 0x6E, 0x17, 0xF2, 0x58,
+	0x03, 0xAD, 0x51, 0xF7, 0x81,
+	0x01, 0xAD, 0x05, 0xAF, 0xBD,
+	0x0D, 0x42, 0xF2, 0xEE, 0x36,
+	0x03, 0x4D, 0x59, 0x48, 0xC6,
+	0x0A, 0xB8, 0xC1, 0xC3, 0xAC,
+	0x07, 0x4A, 0xD7, 0xC9, 0xCC,
+	0x0A, 0x03, 0x34, 0x7F, 0xF3,
+	0x0B, 0xA6, 0x71, 0xB9, 0x31,
+	0x0B, 0x15, 0x78, 0x46, 0x17,
+	0x0F, 0x64, 0xCB, 0x37, 0x23,
+	0x09, 0x76, 0x04, 0xD8, 0x86,
+	0x0D, 0xD6, 0xCC, 0x0A, 0x72,
+	0x07, 0x2A, 0x9E, 0xB1, 0xD2,
+	0x01, 0x4A, 0x4E, 0x8F, 0x5B,
+	0x0E, 0x1B, 0xDF, 0x53, 0x02,
+	0x0C, 0xE7, 0xDC, 0x02, 0x34,
+	0x04, 0xBF, 0xFD, 0x0C, 0xE9,
+	0x0B, 0x66, 0x87, 0x7E, 0x75,
+	0x09, 0xEF, 0x0F, 0x99, 0xC4,
+	0x0D, 0xA8, 0xF2, 0x6C, 0x37,
+	0x0C, 0xE3, 0x6A, 0xE6, 0x62,
+	0x08, 0x10, 0x08, 0x27, 0xEA,
+	0x03, 0x7B, 0xEE, 0x41, 0x5D,
+	0x03, 0xF6, 0x49, 0x6B, 0x90,
+	0x0D, 0x98, 0x0C, 0x61, 0x1A,
+	0x07, 0xF9, 0xEB, 0xAC, 0x73,
+	0x07, 0xF4, 0x8A, 0xB6, 0xA6,
+	0x0D, 0xBE, 0xAA, 0x05, 0x5A,
+	0x0B, 0xB8, 0x1C, 0xE7, 0x39,
+	0x05, 0x12, 0x19, 0xDC, 0xB3,
+	0x05, 0x0E, 0x70, 0xD2, 0x43,
+	0x07, 0x15, 0x32, 0x05, 0x4E,
+	0x09, 0x62, 0x6D, 0x87, 0x51,
+	0x06, 0xD5, 0xC4, 0xC0, 0x7A,
+	0x01, 0x18, 0x4E, 0x51, 0xFD,
+	0x04, 0xDC, 0x8A, 0x05, 0xA5,
+	0x0C, 0x92, 0xDF, 0xB3, 0x51,
+	0x09, 0x90, 0x2A, 0x39, 0x7F,
+	0x0B, 0x0D, 0x39, 0x6B, 0x8F,
+	0x06, 0x13, 0x6D, 0xD8, 0x1C,
+	0x03, 0xD5, 0x3A, 0x57, 0x97,
+	0x00, 0x39, 0xD2, 0x64, 0x79,
+	0x04, 0x33, 0x85, 0xA3, 0x4E,
+	0x0B, 0xE1, 0xFF, 0x17, 0x3E,
+	0x08, 0x64, 0x12, 0xCD, 0x23,
+	0x09, 0x1B, 0xB5, 0x13, 0x0D,
+	0x0D, 0x08, 0x28, 0x80, 0xC2,
+	0x00, 0x9C, 0x29, 0x0D, 0xE0,
+	0x09, 0x15, 0xAB, 0x4F, 0xD9,
+	0x0C, 0xBD, 0x26, 0xA0, 0x20,
+	0x0B, 0x91, 0xE1, 0x7F, 0x4D,
+	0x06, 0xB2, 0x4F, 0x19, 0x34,
+	0x0A, 0xDB, 0xB0, 0x5A, 0xFA,
+	0x08, 0x14, 0xAF, 0x3A, 0xEB,
+	0x0A, 0xA4, 0x35, 0x95, 0x9E,
+	0x01, 0x0B, 0xDB, 0xA4, 0xB1,
+	0x05, 0xFE, 0x0F, 0xCC, 0xD6,
+	0x0E, 0xE5, 0x9B, 0x47, 0x1F,
+	0x00, 0xEB, 0xE7, 0x1B, 0xD7,
+	0x03, 0x51, 0x80, 0x84, 0x61,
+	0x09, 0x17, 0x9B, 0xD3, 0x72,
+	0x01, 0x54, 0xDF, 0xBE, 0x0B,
+	0x0E, 0x4D, 0x4C, 0xC6, 0x29,
+	0x0C, 0xD2, 0xFD, 0x8D, 0x1D,
+	0x09, 0x9E, 0x3E, 0xEC, 0x36,
+	0x07, 0x60, 0x35, 0xF1, 0xCC,
+	0x02, 0xDB, 0x3A, 0xC0, 0xE7,
+	0x01, 0xAA, 0x28, 0x80, 0x8E,
+	0x07, 0xB6, 0x68, 0xC3, 0x44,
+	0x08, 0x1E, 0xF8, 0xA9, 0x10,
+	0x0E, 0x76, 0x8C, 0xBE, 0xEC,
+	0x01, 0xCE, 0xF6, 0xAE, 0xA6,
+	0x07, 0x40, 0xCA, 0xC2, 0xF2,
+	0x0D, 0xF7, 0x46, 0xEA, 0x84,
+	0x0C, 0xFD, 0x04, 0xC0, 0xE7,
+	0x0A, 0x99, 0x80, 0xE1, 0xCB,
+	0x05, 0xFD, 0x16, 0x37, 0x57,
+	0x06, 0xBD, 0xD9, 0xE0, 0x47,
+	0x09, 0xAB, 0x4A, 0xA1, 0xD2,
+	0x0C, 0xBB, 0x81, 0xC8, 0x88,
+	0x07, 0x51, 0x21, 0x9B, 0xF5,
+	0x0C, 0xD0, 0xEF, 0x19, 0xBA,
+	0x07, 0x31, 0x7A, 0xAB, 0xBA,
+	0x05, 0xDE, 0xDC, 0xD9, 0x29,
+	0x05, 0xED, 0xBC, 0x4C, 0x04,
+	0x0B, 0x93, 0xE4, 0xE9, 0x58,
+	0x0F, 0x4D, 0xC8, 0x87, 0x18,
+	0x04, 0xCC, 0xAC, 0x79, 0x25,
+	0x03, 0x01, 0x8C, 0x83, 0x4B,
+	0x0A, 0x2C, 0x75, 0x86, 0x7A,
+	0x0B, 0xA0, 0xD6, 0xFD, 0x80,
+	0x0C, 0xD5, 0x40, 0xA5, 0x79,
+	0x0F, 0xCB, 0x3D, 0x2B, 0xAE,
+	0x0B, 0x42, 0x98, 0x50, 0xC4,
+	0x01, 0xDE, 0x1F, 0xFD, 0xFE,
+	0x0A, 0x6F, 0xE1, 0x29, 0x1A,
+	0x04, 0xF9, 0x31, 0x5F, 0xF8,
+	0x02, 0xBA, 0x98, 0x8C, 0x44,
+	0x0B, 0x08, 0x4A, 0xBE, 0x9E,
+	0x0B, 0x91, 0x42, 0xB0, 0x45,
+	0x09, 0xDE, 0x43, 0x6E, 0x62,
+	0x08, 0x9C, 0xF7, 0x99, 0xB0,
+	0x01, 0x3B, 0xC8, 0xF1, 0x37,
+	0x08, 0xAD, 0x7B, 0x08, 0x2B,
+	0x0A, 0x81, 0x4A, 0xF2, 0x1D,
+	0x09, 0xBB, 0x7F, 0x5D, 0x44,
+	0x0E, 0xF0, 0x1D, 0xBD, 0x5E,
+	0x0C, 0x3F, 0xE0, 0xFB, 0x1C,
+	0x04, 0x82, 0xD3, 0xB4, 0x79,
+	0x09, 0xA2, 0xAD, 0x7A, 0xFC,
+	0x03, 0x18, 0x94, 0x18, 0xC6,
+	0x03, 0xBC, 0xE1, 0xBD, 0x37,
+	0x02, 0xAC, 0xE9, 0xF7, 0x35,
+	0x0E, 0xE7, 0x94, 0xC8, 0x82,
+	0x0B, 0x0F, 0x4F, 0xE4, 0xB1,
+	0x06, 0x59, 0xE3, 0xF8, 0x81,
+	0x01, 0x73, 0xA9, 0x5F, 0x45,
+	0x0E, 0x95, 0xE1, 0x5C, 0x0D,
+	0x0C, 0x1F, 0x1A, 0x89, 0x4C,
+	0x08, 0xF8, 0x06, 0x84, 0x7D,
+	0x0F, 0xC1, 0xEF, 0x8F, 0xC4,
+	0x04, 0xA7, 0x68, 0xFE, 0x62,
+	0x05, 0x48, 0xE3, 0x6A, 0x31,
+	0x08, 0xE0, 0x16, 0x07, 0x7A,
+	0x0A, 0xC3, 0x7A, 0x2E, 0x45,
+	0x02, 0xD3, 0xF2, 0x59, 0x6F,
+	0x09, 0xA9, 0x9C, 0x21, 0xE1,
+	0x08, 0x5F, 0xD5, 0x63, 0x2C,
+	0x01, 0xC7, 0xDD, 0x06, 0x36,
+	0x0C, 0x76, 0x3E, 0x8C, 0x07,
+	0x0B, 0xAA, 0x38, 0x1C, 0x3A,
+	0x0D, 0x75, 0x12, 0x19, 0xC2,
+	0x06, 0xCD, 0x0E, 0xD4, 0x3B,
+	0x03, 0xDF, 0x17, 0x14, 0x0B,
+	0x05, 0xD1, 0xE7, 0xCD, 0x8A,
+	0x0B, 0x26, 0xDD, 0x4F, 0xAC,
+	0x00, 0x21, 0x18, 0x4E, 0x55,
+	0x06, 0xF4, 0xDC, 0xAA, 0x15,
+	0x07, 0xEC, 0x92, 0xCF, 0x11,
+	0x03, 0x30, 0x18, 0xDA, 0x36,
+	0x0F, 0xA2, 0xC7, 0x49, 0x65,
+	0x0F, 0xBA, 0x0D, 0x4D, 0xDA,
+	0x06, 0x7D, 0x54, 0x0A, 0x57,
+	0x0E, 0x72, 0x19, 0xD0, 0xFA,
+	0x00, 0x21, 0x84, 0x85, 0xE5,
+	0x0A, 0x1D, 0xE5, 0xFF, 0x07,
+	0x0E, 0x2E, 0x68, 0x12, 0x9D,
+	0x01, 0xCF, 0x9B, 0x13, 0xA3,
+	0x04, 0xAB, 0x49, 0x8A, 0x00,
+	0x03, 0x31, 0x5C, 0xAB, 0x0D,
+	0x02, 0xB9, 0x14, 0x2B, 0x4F,
+	0x09, 0x25, 0xBF, 0x06, 0xA6,
+	0x00, 0x31, 0x94, 0x79, 0x7F,
+	0x05, 0x8E, 0xB0, 0xDF, 0x1F,
+	0x04, 0x1A, 0xDA, 0xA0, 0xD0,
+	0x0A, 0xA8, 0x15, 0xBF, 0xA4,
+	0x00, 0x73, 0xA5, 0xE5, 0x5E,
+	0x08, 0x67, 0x0A, 0xCB, 0xBE,
+	0x0B, 0xC3, 0xFF, 0x1F, 0xF6,
+	0x0C, 0xC8, 0x24, 0x2B, 0xCD,
+	0x0F, 0x36, 0x2B, 0x57, 0x91,
+	0x07, 0x13, 0x10, 0x10, 0x0E,
+	0x01, 0x39, 0x57, 0x0B, 0x59,
+	0x02, 0x28, 0x57, 0x8F, 0x38,
+	0x0B, 0x7E, 0x4C, 0x4C, 0x4A,
+	0x03, 0x28, 0xD3, 0xFE, 0x01,
+	0x0D, 0x65, 0x9C, 0x1E, 0x62,
+	0x0E, 0xB7, 0x60, 0xB5, 0xF5,
+	0x0C, 0x09, 0x5E, 0x5D, 0xC3,
+	0x0E, 0x49, 0x29, 0xA8, 0xD0,
+	0x06, 0x97, 0x16, 0x68, 0x77,
+	0x0D, 0x3C, 0x18, 0x73, 0x37,
+	0x08, 0xCB, 0xD6, 0x83, 0x3E,
+	0x04, 0x56, 0xCE, 0x34, 0x2E,
+	0x0C, 0x27, 0xC4, 0x88, 0xC6,
+	0x08, 0xA9, 0xF0, 0xA6, 0xE5,
+	0x09, 0xAD, 0xFF, 0x66, 0x2C,
+	0x0C, 0x9A, 0x99, 0x84, 0xBD,
+	0x01, 0xA5, 0xFD, 0x16, 0x3A,
+	0x0B, 0x3C, 0x7C, 0xD0, 0x6B,
+	0x0E, 0xC1, 0x69, 0xEA, 0xA0,
+	0x09, 0xBC, 0xBB, 0x81, 0xCE,
+	0x0F, 0xF7, 0x51, 0x21, 0x9F,
+	0x06, 0x6C, 0x12, 0xEF, 0x4F,
+	0x00, 0xBD, 0x51, 0x73, 0x20,
+	0x0E, 0x2D, 0x18, 0xF7, 0x46,
+	0x01, 0x9D, 0xCD, 0x50, 0x4C,
+	0x0C, 0x00, 0x51, 0x86, 0x65,
+	0x02, 0x6A, 0x81, 0x48, 0xA5,
+	0x00, 0x7B, 0x06, 0x2D, 0xF8,
+	0x0C, 0x31, 0x21, 0x82, 0x63,
+	0x01, 0xFF, 0xE3, 0x75, 0xB6,
+	0x01, 0xFB, 0x60, 0xD4, 0x5D,
+	0x02, 0xD7, 0xD5, 0x44, 0xDC,
+	0x09, 0x77, 0x03, 0x9D, 0x27,
+	0x0E, 0xA2, 0x42, 0x38, 0x5E,
+	0x09, 0xA1, 0xDC, 0x1F, 0xF0,
+	0x00, 0xE2, 0xE6, 0x41, 0x29,
+	0x06, 0x1C, 0xF9, 0xB1, 0x51,
+	0x01, 0xDA, 0x7A, 0x98, 0xC8,
+	0x0C, 0xA3, 0xA9, 0x4A, 0xB0,
+	0x04, 0x5B, 0x97, 0xC9, 0x18,
+	0x05, 0x13, 0xFB, 0xFE, 0x6A,
+	0x0E, 0x01, 0x59, 0x44, 0x17,
+	0x0E, 0x5D, 0x3F, 0xAC, 0xF5,
+	0x0D, 0x44, 0x7B, 0xBB, 0x04,
+	0x06, 0xAA, 0x41, 0x48, 0x48,
+	0x0E, 0x07, 0x3A, 0x4B, 0x26,
+	0x04, 0x86, 0x70, 0xBD, 0xB3,
+	0x03, 0xBC, 0x3F, 0x60, 0xF7,
+	0x05, 0xCC, 0x80, 0x53, 0xB4,
+	0x02, 0xF3, 0x62, 0xA4, 0x71,
+	0x09, 0x51, 0x31, 0x10, 0x0B,
+	0x0F, 0x13, 0x57, 0x61, 0xFD,
+	0x0F, 0xA2, 0x25, 0x69, 0xFB,
+	0x0E, 0x77, 0xE2, 0x5F, 0x76,
+	0x0E, 0xB3, 0x2D, 0x23, 0xE8,
+	0x09, 0xD4, 0x19, 0xE1, 0x6E,
+	0x09, 0x5E, 0xAD, 0x8B, 0x5B,
+	0x0F, 0x07, 0x48, 0xE5, 0xDD,
+	0x07, 0x74, 0x5E, 0xB8, 0x33,
+	0x0C, 0xE1, 0x7B, 0x62, 0xFC,
+	0x08, 0x7F, 0xC1, 0xEF, 0x8B,
+	0x09, 0x04, 0xA7, 0xE8, 0xF3,
+	0x06, 0xC5, 0x4A, 0xE3, 0x6A,
+	0x09, 0x62, 0x20, 0x10, 0x8C,
+	0x07, 0x2A, 0xC1, 0x7A, 0x6E,
+	0x0F, 0xCA, 0xD5, 0x7D, 0x8B,
+	0x07, 0x49, 0x09, 0x1A, 0x8C,
+	0x0E, 0x9F, 0xEA, 0xD1, 0x63,
+	0x0C, 0xB3, 0xC7, 0x5B, 0x8C,
+	0x06, 0xEC, 0x16, 0xBE, 0xAA,
+	0x05, 0x2B, 0xC9, 0xB8, 0x1C,
+	0x02, 0x3D, 0x75, 0x12, 0x19,
+	0x0E, 0xD4, 0xCD, 0x0E, 0xC1,
+	0x0F, 0x83, 0xDD, 0x17, 0x32,
+	0x09, 0x4E, 0xD1, 0x6B, 0x87,
+	0x0A, 0x91, 0xC6, 0x59, 0x8E,
+	0x04, 0x40, 0x23, 0x18, 0x44,
+	0x0F, 0x66, 0xF5, 0x57, 0x41,
+	0x05, 0xA7, 0xEC, 0x82, 0xDD,
+	0x09, 0xB3, 0x31, 0x93, 0x07,
+	0x04, 0xBF, 0xA2, 0xD7, 0x5B,
+	0x0D, 0x6F, 0xA1, 0x86, 0xA2,
+	0x08, 0x2D, 0x7D, 0x44, 0x08,
+	0x0D, 0x77, 0x6B, 0xB2, 0x03,
+	0x0A, 0xEA, 0x24, 0x23, 0x87,
+	0x06, 0x9A, 0x1D, 0xE1, 0xFF,
+	0x0B, 0xBE, 0x2C, 0x64, 0x1C,
+	0x0D, 0xA3, 0xD9, 0x9B, 0x15,
+	0x09, 0x6D, 0xAA, 0x02, 0x5E,
+	0x00, 0x42, 0x34, 0x9C, 0xB4,
+	0x07, 0x29, 0xBA, 0x1F, 0xF3,
+	0x0F, 0xD9, 0x25, 0x3F, 0x2C,
+	0x06, 0x60, 0x32, 0x14, 0x69,
+	0x0F, 0x45, 0x8C, 0xB2, 0xCF,
+	0x05, 0x94, 0x01, 0x50, 0x6C,
+	0x0A, 0xFA, 0xA8, 0x04, 0xAD,
+	0x05, 0xE0, 0x73, 0xA4, 0xF5,
+	0x08, 0x48, 0x66, 0x4B, 0xD5,
+	0x0C, 0x3B, 0x55, 0xF2, 0x0F,
+	0x00, 0x60, 0xC8, 0x25, 0x0A,
+	0x0B, 0x99, 0x36, 0x2A, 0x75,
+	0x07, 0x55, 0x13, 0x11, 0x33,
+	0x08, 0x43, 0x39, 0x56, 0x18,
+	0x0B, 0x73, 0xA8, 0x56, 0x5F,
+	0x02, 0x4B, 0x7E, 0xCD, 0x06,
+	0x00, 0x63, 0x28, 0x56, 0xF4,
+	0x0B, 0x1D, 0x65, 0x12, 0x74,
+	0x08, 0x35, 0xB7, 0xEC, 0xFF,
+	0x05, 0x50, 0x29, 0xD2, 0x17,
+	0x00, 0xE7, 0x49, 0x67, 0xE2,
+	0x00, 0xCE, 0x17, 0x3A, 0xE2,
+	0x07, 0x87, 0xFC, 0x92, 0x72,
+	0x09, 0x90, 0x4A, 0xFA, 0xC5,
+	0x0E, 0x6C, 0x54, 0x02, 0xFC,
+	0x0E, 0x26, 0x20, 0x01, 0x02,
+	0x08, 0x92, 0xB7, 0xBC, 0x57,
+	0x04, 0x50, 0xAD, 0x2F, 0x66,
+	0x0D, 0xFC, 0x9A, 0x99, 0x80,
+	0x0A, 0x73, 0xA5, 0xFD, 0x27,
+	0x0A, 0xCB, 0x3E, 0x7D, 0xD0,
+	0x0B, 0x6E, 0xC1, 0xEB, 0xE0,
+	0x00, 0x52, 0xBC, 0x37, 0xCB,
+	0x0E, 0x93, 0xD7, 0xDD, 0x6B,
+	0x06, 0xCF, 0x77, 0x5B, 0x16,
+	0x0F, 0xF8, 0x3D, 0x71, 0x79,
+	0x08, 0x94, 0x6F, 0x1E, 0xBC,
+	0x02, 0x49, 0x07, 0xE6, 0xA0,
+	0x0C, 0x44, 0x02, 0x01, 0x86,
+	0x0F, 0xB8, 0x74, 0xC6, 0x36,
+	0x01, 0x5A, 0x7E, 0xDF, 0x2F,
+	0x03, 0xD5, 0x28, 0x8D, 0x8C,
+	0x03, 0x4B, 0xFA, 0x3C, 0x77,
+	0x0D, 0x78, 0xFB, 0xA0, 0xD6,
+	0x01, 0x9D, 0x28, 0x29, 0x43,
+	0x09, 0x5B, 0x77, 0x03, 0x9E,
+	0x07, 0xAE, 0xA0, 0x43, 0x38,
+	0x0E, 0xD9, 0xA1, 0x5E, 0x55,
+	0x00, 0x7B, 0xE2, 0x66, 0x4B,
+	0x09, 0xDA, 0x3C, 0x79, 0xBB,
+	0x02, 0x38, 0xD8, 0xB8, 0xD2,
+	0x02, 0xE4, 0x38, 0x85, 0xC0,
+	0x00, 0xDE, 0x9B, 0x81, 0x40,
+	0x0E, 0x1D, 0x89, 0xD7, 0xFE,
+	0x0A, 0x66, 0x03, 0x09, 0x44,
+	0x0C, 0xF4, 0x58, 0xEB, 0x2C,
+	0x09, 0xF7, 0xC5, 0xAD, 0x7B,
+	0x0F, 0xA9, 0x85, 0x81, 0x6A,
+	0x02, 0xEE, 0x03, 0x17, 0x4A,
+	0x0D, 0x44, 0x8A, 0x70, 0xBD,
+	0x0B, 0x43, 0x38, 0x3F, 0x20,
+	0x0F, 0xC7, 0xC8, 0x82, 0xA7,
+	0x04, 0x79, 0xF3, 0x62, 0xA4,
+	0x01, 0xB5, 0x7D, 0x35, 0x25,
+	0x00, 0x46, 0x97, 0x95, 0xA1,
+	0x05, 0x35, 0x26, 0x85, 0xA9,
+	0x0B, 0x24, 0xB7, 0xE4, 0xD4,
+	0x0C, 0x06, 0x3E, 0x89, 0x19,
+	0x00, 0xB1, 0x52, 0x59, 0x23,
+	0x06, 0x81, 0x5F, 0x76, 0xCB,
+	0x0F, 0x55, 0x02, 0x95, 0xE5,
+	0x0C, 0x0E, 0x78, 0x9A, 0x82,
+	0x01, 0x0C, 0x65, 0x7B, 0xA6,
+	0x0F, 0x7A, 0x7B, 0xC1, 0x2F,
+	0x0B, 0x99, 0x04, 0xA7, 0x68,
+	0x03, 0xE6, 0xC1, 0x5C, 0xDA,
+	0x00, 0x02, 0x78, 0x2C, 0x3B,
+	0x0E, 0x27, 0x2A, 0xC3, 0xFA,
+	0x0C, 0x45, 0x0A, 0xE3, 0x76,
+	0x09, 0x0F, 0x49, 0xA9, 0x98,
+	0x0C, 0x85, 0xBA, 0x5F, 0xD1,
+	0x03, 0xAC, 0xB3, 0xC7, 0xDD,
+	0x06, 0xB6, 0xEC, 0x00, 0xBC,
+	0x0A, 0x05, 0x2B, 0xDD, 0xFA,
+	0x0C, 0xE9, 0x3D, 0x65, 0x12,
+	0x09, 0xC2, 0xF6, 0xCD, 0x0E,
+	0x00, 0xFF, 0x83, 0xEF, 0x17,
+	0x02, 0x09, 0x4A, 0xC1, 0xE7,
+	0x07, 0x6A, 0x8B, 0x4A, 0xE2,
+	0x06, 0xC4, 0x40, 0x21, 0x98,
+	0x0C, 0x55, 0x86, 0xC4, 0x5C,
+	0x0A, 0x75, 0x27, 0xEC, 0x92,
+	0x0F, 0x73, 0xF3, 0x30, 0x18,
+	0x0A, 0x34, 0xBF, 0xA2, 0xC7,
+	0x09, 0x67, 0x8F, 0xAC, 0x0F,
+	0x0D, 0xD8, 0x2D, 0x6B, 0x16,
+	0x0A, 0x57, 0x97, 0x60, 0x39,
+	0x02, 0x7A, 0xEA, 0x24, 0x33,
+	0x05, 0xED, 0x9A, 0x2D, 0xE1,
+	0x0F, 0x07, 0xBA, 0x3E, 0x64,
+	0x08, 0x7D, 0xB8, 0xC3, 0xD8,
+	0x07, 0x23, 0x8D, 0xAB, 0x09,
+	0x0A, 0x80, 0x42, 0x00, 0x1C,
+	0x0B, 0x6D, 0x69, 0xB9, 0x14,
+	0x0B, 0xAF, 0x79, 0x25, 0xBF,
+	0x06, 0xA6, 0x60, 0x31, 0x94,
+	0x09, 0x7F, 0x45, 0x98, 0xB0,
+	0x0F, 0x1F, 0x74, 0x0C, 0x99,
+	0x00, 0x5A, 0xFA, 0xB8, 0x14,
+	0x0F, 0x2E, 0xE0, 0x73, 0xA4,
+	0x05, 0xD4, 0x48, 0x67, 0x0B,
+	0x0B, 0x34, 0x3B, 0xF3, 0xFE,
+	0x0F, 0x7C, 0x58, 0xD8, 0x25,
+	0x01, 0xA7, 0x83, 0x3A, 0x7A,
+	0x05, 0x1B, 0x57, 0x13, 0x91,
+	0x02, 0x84, 0x61, 0x09, 0xD6,
+	0x0B, 0xB3, 0xF2, 0x28, 0x56,
+	0x0F, 0x52, 0xEB, 0x7E, 0x4D,
+	0x0C, 0xC0, 0x63, 0x28, 0xD2,
+	0x0E, 0x8B, 0x1D, 0x73, 0x9C,
+	0x0E, 0xE8, 0x35, 0xA1, 0x22,
+	0x05, 0xF5, 0x50, 0x39, 0x5E,
+	0x0D, 0xC0, 0xE7, 0x49, 0xEB,
+	0x08, 0x90, 0xCE, 0x27, 0xB6,
+	0x08, 0x77, 0x83, 0xEC, 0x1E,
+	0x02, 0x59, 0x8C, 0xC6, 0x2A,
+	0x0D, 0x3E, 0x6C, 0x54, 0x0E,
+	0x04, 0xAE, 0x26, 0x12, 0x81,
+	0x08, 0xA2, 0xF2, 0xAC, 0x37,
+	0x06, 0x04, 0xF0, 0xAD, 0x3F,
+	0x04, 0x96, 0xFC, 0x9A, 0x99,
+	0x00, 0xC6, 0x51, 0xB3, 0xFF,
+	0x06, 0x3A, 0xCB, 0x2A, 0x3F,
+	0x00, 0x6B, 0x6E, 0xD1, 0x6B,
+	0x0A, 0xA0, 0x52, 0xBC, 0xBB,
+	0x01, 0xCE, 0x93, 0xF7, 0x51,
+	0x0A, 0x9C, 0x2F, 0x6C, 0xD0,
+	0x07, 0x0F, 0x7A, 0x30, 0xB1,
+	0x09, 0x26, 0xA0, 0x6D, 0x3E,
+	0x0C, 0xD8, 0xAD, 0x1C, 0x6D,
+	0x0C, 0x4C, 0x44, 0x02, 0x11,
+	0x06, 0xE5, 0x58, 0x61, 0x4D,
+	0x08, 0xA1, 0xDA, 0x7E, 0xC9,
+	0x0D, 0xF8, 0xB5, 0x33, 0x01,
+	0x0C, 0xA3, 0x4B, 0xFA, 0x2C,
+	0x05, 0x96, 0x78, 0xFF, 0xAA,
+	0x06, 0xDD, 0x82, 0xD3, 0xE7,
+	0x00, 0xA5, 0x7B, 0x77, 0x03,
+	0x06, 0x27, 0xAE, 0xA2, 0x43,
+	0x01, 0x5E, 0x19, 0xA1, 0xDE,
+	0x07, 0x70, 0xDB, 0xE2, 0xE6,
+	0x0B, 0xE9, 0xC3, 0x30, 0x96,
+	0x00, 0x53, 0xFD, 0xDA, 0xB8,
+	0x08, 0x09, 0xA0, 0x23, 0x09,
+	0x09, 0xB1, 0x1B, 0x9D, 0x9B,
+	0x00, 0x35, 0x5D, 0x94, 0x5B,
+	0x03, 0x6B, 0xA6, 0x03, 0x19,
+	0x06, 0x16, 0x54, 0x58, 0xEB,
+	0x07, 0xF1, 0xF7, 0x41, 0xAD,
+	0x07, 0x05, 0xA4, 0x2A, 0x92,
+	0x06, 0xCD, 0x1A, 0xC7, 0x2E,
+	0x07, 0x5D, 0xC4, 0x86, 0x70,
+	0x07, 0x73, 0x54, 0xB0, 0x45,
+	0x02, 0xFE, 0x41, 0x8C, 0x02,
+	0x01, 0xBD, 0xFD, 0xA3, 0xE2,
+	0x06, 0x78, 0x31, 0x47, 0x71,
+	0x02, 0x01, 0xC6, 0x15, 0x15,
+	0x01, 0xB4, 0xB7, 0x64, 0xC7,
+	0x09, 0xF2, 0xA4, 0xA1, 0x66,
+	0x0F, 0xCC, 0x06, 0x32, 0x8D,
+	0x03, 0xE8, 0xB2, 0x16, 0x68,
+	0x0A, 0xEE, 0x43, 0x5B, 0xB6,
+	0x02, 0x59, 0x95, 0x0E, 0xD5,
+	0x0F, 0xDA, 0x5C, 0xF4, 0xBE,
+	0x03, 0x8B, 0x4C, 0xED, 0x7B,
+	0x0C, 0x81, 0x3C, 0x7F, 0x81,
+	0x07, 0x8B, 0x99, 0x0C, 0x95,
+	0x02, 0xF5, 0xB4, 0x45, 0x68,
+	0x0A, 0x68, 0xA2, 0x6E, 0x20,
+	0x0A, 0x8A, 0x61, 0x2A, 0x83,
+	0x02, 0x6E, 0x45, 0x02, 0xA1,
+	0x0C, 0x4F, 0x3D, 0x49, 0x89,
+	0x01, 0x0E, 0x25, 0x16, 0x5F,
+	0x0B, 0x65, 0xE4, 0xB3, 0x87,
+	0x05, 0x06, 0xB6, 0xE4, 0xA4,
+	0x04, 0xAC, 0x57, 0xAB, 0xEB,
+	0x01, 0x1E, 0xA9, 0x31, 0x75,
+	0x08, 0x1F, 0x88, 0xF6, 0x8D,
+	0x06, 0xF0, 0xFF, 0x8B, 0x2D,
+	0x0D, 0x34, 0x5B, 0xCE, 0xF1,
+	0x0E, 0xCF, 0xCA, 0x9D, 0xC6,
+	0x0F, 0xC2, 0x88, 0x40, 0x61,
+	0x00, 0x4E, 0x55, 0x8F, 0xC6,
+	0x06, 0x8C, 0x47, 0x27, 0xCC,
+	0x0B, 0xDD, 0xD3, 0x5F, 0x30,
+	0x02, 0xCC, 0x7A, 0xBF, 0xE2,
+	0x0F, 0x59, 0x67, 0x86, 0xC8,
+	0x07, 0x6B, 0x8A, 0xAD, 0x5D,
+	0x0D, 0x08, 0x17, 0x9B, 0x70,
+	0x03, 0xD4, 0x2A, 0xEA, 0x64,
+	0x0B, 0x85, 0xED, 0x93, 0xAF,
+	0x0B, 0xF9, 0x55, 0x3E, 0x0E,
+	0x0D, 0x10, 0xDD, 0xAF, 0xCF,
+	0x01, 0x13, 0x71, 0x8D, 0xEB,
+	0x01, 0x88, 0x80, 0x4B, 0xC2,
+	0x06, 0xAD, 0x5F, 0x69, 0x99,
+	0x0C, 0x2B, 0x4F, 0xD9, 0x17,
+	0x0F, 0x26, 0xA6, 0x60, 0x31,
+	0x0F, 0x69, 0x7F, 0x45, 0x8E,
+	0x0B, 0xCD, 0x5F, 0x78, 0x1A,
+	0x01, 0xB6, 0x0F, 0x7A, 0xE8,
+	0x0C, 0xAF, 0x2E, 0xEC, 0xD3,
+	0x0E, 0xF3, 0xB7, 0x48, 0x47,
+	0x02, 0xD9, 0x74, 0x37, 0xC3,
+	0x04, 0x09, 0x2B, 0xDC, 0x88,
+	0x0D, 0x3B, 0x47, 0x93, 0x97,
+	0x00, 0x41, 0x78, 0x57, 0x33,
+	0x08, 0x02, 0xC4, 0x6D, 0x39,
+	0x0C, 0x1D, 0x8A, 0xF2, 0x68,
+	0x0E, 0x9F, 0xB2, 0x47, 0xDC,
+	0x07, 0x4A, 0xA3, 0x63, 0x08,
+	0x0B, 0xFC, 0xCB, 0x11, 0x65,
+	0x04, 0x38, 0xB3, 0xB5, 0xF7,
+	0x08, 0xB5, 0xF5, 0x5C, 0x8A,
+	0x04, 0x5B, 0xA3, 0xE7, 0x69,
+	0x02, 0xAA, 0xD0, 0xC2, 0x17,
+	0x0C, 0x6E, 0x2A, 0x07, 0xBC,
+	0x06, 0xF8, 0xB9, 0x9C, 0xEE,
+	0x0C, 0x89, 0x5D, 0x6C, 0x74,
+	0x07, 0x34, 0xEE, 0x2A, 0x22,
+	0x0B, 0x0E, 0x9D, 0xF2, 0xEC,
+	0x0F, 0xA6, 0xE4, 0x5C, 0x08,
+	0x05, 0x62, 0xF5, 0xFC, 0xBA,
+	0x00, 0x82, 0x86, 0x5D, 0xA5,
+	0x07, 0x10, 0x5B, 0x4B, 0x7C,
+	0x05, 0xD0, 0x6B, 0x62, 0x67,
+	0x01, 0xEC, 0xC3, 0x52, 0x9C,
+	0x02, 0x83, 0x8E, 0x9F, 0xD7,
+	0x0B, 0x27, 0xFF, 0x2F, 0x2C,
+	0x08, 0xEF, 0x0F, 0xF4, 0x9A,
+	0x01, 0x73, 0x20, 0x94, 0xED,
+	0x05, 0x7C, 0xD8, 0xA9, 0x1C,
+	0x04, 0xDC, 0xAC, 0x44, 0xC2,
+	0x0B, 0x82, 0x83, 0x58, 0x2F,
+	0x05, 0xC8, 0xA1, 0x5E, 0x58,
+	0x03, 0x2B, 0x84, 0xB5, 0x32,
+	0x08, 0x0E, 0xC3, 0x47, 0xFA,
+	0x06, 0x73, 0xFE, 0x78, 0xBB,
+	0x08, 0xD6, 0xDD, 0x86, 0xF7,
+	0x0F, 0x46, 0xD8, 0xF9, 0x76,
+	0x0A, 0x1F, 0x47, 0xA2, 0xA2,
+	0x09, 0x3E, 0x34, 0xD9, 0xE1,
+	0x06, 0x1F, 0xF0, 0x7F, 0xC3,
+	0x0C, 0x47, 0x54, 0x5A, 0x3D,
+	0x00, 0x33, 0x32, 0x34, 0xDA,
+	0x02, 0x9E, 0xE4, 0x04, 0x63,
+	0x01, 0xCA, 0xB0, 0xDA, 0xB9,
+	0x0B, 0x44, 0xC9, 0x7D, 0x93,
+	0x02, 0x70, 0x0A, 0x6A, 0x03,
+	0x03, 0x40, 0xF9, 0xF4, 0x18,
+	0x03, 0x2C, 0xF1, 0xF3, 0x62,
+	0x07, 0xBD, 0x78, 0x2F, 0xAB,
+	0x08, 0xC8, 0x92, 0xE2, 0x07,
+	0x00, 0x49, 0x2D, 0x44, 0xC6,
+	0x08, 0xBD, 0xB3, 0x47, 0x98,
+	0x05, 0xE6, 0x8A, 0x45, 0xCD,
+	0x0B, 0xD1, 0xD4, 0x75, 0xF3,
+	0x08, 0xA2, 0x03, 0xB5, 0x31,
+	0x09, 0x10, 0x08, 0x42, 0x36,
+	0x0F, 0x67, 0xC0, 0xB7, 0x23,
+	0x0C, 0xEB, 0x9B, 0x28, 0xB7,
+	0x0E, 0xD2, 0xB8, 0x06, 0x72,
+	0x05, 0x2F, 0xE8, 0xB5, 0xF0,
+	0x03, 0xE5, 0x93, 0x03, 0x5A,
+	0x0F, 0x89, 0x3F, 0x59, 0x02,
+	0x0F, 0xE3, 0xAA, 0x0E, 0x34,
+	0x06, 0xBA, 0x89, 0x08, 0xC6,
+	0x01, 0x60, 0xFA, 0xF8, 0x7E,
+	0x08, 0x6D, 0xEB, 0x95, 0x04,
+	0x0D, 0x6E, 0x8B, 0x66, 0x85,
+	0x00, 0xE3, 0x6A, 0xE6, 0x44,
+	0x08, 0x10, 0x8C, 0x23, 0x0D,
+	0x09, 0x7C, 0x13, 0xC5, 0x0B,
+	0x0A, 0x74, 0x29, 0x63, 0xC9,
+	0x03, 0x9E, 0x77, 0x65, 0x5A,
+	0x07, 0xD1, 0x63, 0xA8, 0x93,
+	0x0F, 0xDD, 0x06, 0xB2, 0xCA,
+	0x0C, 0xB8, 0xD7, 0x85, 0x2A,
+	0x02, 0x3A, 0x7C, 0xE5, 0x3D,
+	0x0F, 0x14, 0x64, 0x42, 0xB6,
+	0x05, 0x0E, 0xF0, 0xFB, 0xA2,
+	0x07, 0x17, 0x32, 0x0D, 0x69,
+	0x0B, 0xE1, 0xB0, 0x0A, 0x90,
+	0x06, 0xD5, 0xC4, 0xC4, 0x40,
+	0x0A, 0x18, 0x4E, 0x55, 0x86,
+	0x0D, 0x5C, 0x6A, 0x15, 0x67,
+	0x06, 0x94, 0x5F, 0x13, 0x13,
+	0x08, 0x18, 0xCA, 0x30, 0x9F,
+	0x08, 0xC1, 0xC1, 0x67, 0x8E,
+	0x03, 0x8F, 0x0D, 0xD4, 0x2D,
+	0x07, 0x52, 0x88, 0xD7, 0xD7,
+	0x08, 0x39, 0xD2, 0x7E, 0xCA,
+	0x0E, 0x35, 0x1D, 0xED, 0x9B,
+	0x04, 0x63, 0x9F, 0x0B, 0xBE,
+	0x04, 0x62, 0x96, 0x1D, 0xE3,
+	0x07, 0x9B, 0x15, 0x27, 0xAC,
+	0x01, 0x8F, 0x10, 0x80, 0x43,
+	0x09, 0x1E, 0xCB, 0x01, 0xE9,
+	0x03, 0x12, 0xAD, 0xCF, 0x99,
+	0x0D, 0xBF, 0x26, 0xA2, 0x42,
+	0x0B, 0x92, 0xF1, 0x7F, 0x44,
+	0x07, 0x30, 0xAF, 0x13, 0x74,
+	0x00, 0xDD, 0x38, 0xDA, 0xBA,
+	0x00, 0x14, 0xAF, 0x2A, 0xC3,
+	0x09, 0xA2, 0x6D, 0xD4, 0x49,
+	0x0E, 0x89, 0xBB, 0x38, 0x3B,
+	0x09, 0xF8, 0x85, 0xFC, 0x1C,
+	0x00, 0x25, 0x3B, 0x43, 0xBB,
+	0x0C, 0x2C, 0xDF, 0x1B, 0x56,
+	0x0A, 0x93, 0x60, 0x88, 0x61,
+	0x03, 0x50, 0x97, 0x53, 0x32,
+	0x00, 0x56, 0x9F, 0xB6, 0x6E,
+	0x04, 0x4B, 0xD4, 0xC0, 0x62,
+	0x01, 0x50, 0x9E, 0x87, 0x1D,
+	0x0F, 0x98, 0xB0, 0x68, 0x75,
+	0x0F, 0x60, 0xB5, 0xF1, 0x76,
+	0x03, 0x58, 0xC5, 0xC0, 0xE6,
+	0x00, 0x69, 0xC8, 0x9C, 0xCE,
+	0x0D, 0xB0, 0xF8, 0xF7, 0xC7,
+	0x04, 0x1E, 0xF8, 0xBD, 0xB7,
+	0x00, 0x70, 0x17, 0x3E, 0x6D,
+	0x0D, 0x0C, 0x56, 0xA2, 0x26,
+	0x08, 0x07, 0x9B, 0xC2, 0x32,
+	0x04, 0x37, 0xA6, 0xE0, 0x76,
+	0x05, 0x3F, 0x64, 0x92, 0xDB,
+	0x00, 0x9F, 0x18, 0xC6, 0x50,
+	0x0C, 0x7F, 0x76, 0x36, 0xCB,
+	0x06, 0x7B, 0x45, 0xEB, 0x2E,
+	0x09, 0x6B, 0xEA, 0xA4, 0x72,
+	0x04, 0xBB, 0x81, 0xCA, 0xB5,
+	0x0D, 0x57, 0xB9, 0x9C, 0x2E,
+	0x05, 0x52, 0x8F, 0x03, 0xF8,
+	0x07, 0xF7, 0xEB, 0x20, 0xD4,
+	0x05, 0x1E, 0x7C, 0xDC, 0x88,
+	0x04, 0x6D, 0x5C, 0x48, 0x63,
+	0x08, 0x17, 0x1C, 0xE5, 0x59,
+	0x0F, 0x4D, 0xC8, 0xA1, 0x5A,
+	0x05, 0xC9, 0x2D, 0xF9, 0x35,
+	0x03, 0x01, 0x8C, 0xA3, 0x4B,
+	0x01, 0xA9, 0x0E, 0x16, 0x78,
+	0x0B, 0xA0, 0xD6, 0xD3, 0xC6,
+	0x0C, 0x57, 0x31, 0xA6, 0x7C,
+	0x0B, 0x03, 0x9D, 0x67, 0xA0,
+	0x0E, 0x43, 0x38, 0x1E, 0xE1,
+	0x0D, 0xDE, 0x1C, 0x70, 0x41,
+	0x0E, 0xE6, 0x41, 0x29, 0xE1,
+	0x04, 0xF9, 0x31, 0x5E, 0x38,
+	0x01, 0x3A, 0x83, 0x08, 0x04,
+	0x08, 0x09, 0xCA, 0xB0, 0xDE,
+	0x0B, 0x91, 0x42, 0xB4, 0xFD,
+	0x09, 0xDE, 0x69, 0xEA, 0x66,
+	0x03, 0x19, 0x46, 0x99, 0x71,
+	0x08, 0xEB, 0x2C, 0xFF, 0x3E,
+	0x0A, 0x28, 0x02, 0x05, 0xAF,
+	0x0A, 0x81, 0x4A, 0xFC, 0x27,
+	0x0C, 0xBF, 0x91, 0xDD, 0x44,
+	0x0A, 0x70, 0xBB, 0x33, 0x7A,
+	0x05, 0xBF, 0x00, 0xF9, 0x05,
+	0x04, 0x83, 0xB3, 0xB8, 0x79,
+	0x0A, 0xE3, 0x44, 0x7F, 0xF5,
+	0x01, 0x31, 0x10, 0x0C, 0x4F,
+	0x03, 0x95, 0x61, 0xB9, 0x0E,
+	0x09, 0x00, 0xA8, 0x7B, 0x24,
+	0x0F, 0x2C, 0x74, 0xC2, 0xC6,
+	0x0A, 0x0C, 0x8F, 0xE6, 0xF1,
+	0x06, 0x59, 0xE3, 0xEE, 0x83,
+	0x0B, 0x76, 0x09, 0x5B, 0x1C,
+	0x02, 0x95, 0xE6, 0xDC, 0x0E,
+	0x04, 0x9E, 0xB8, 0x89, 0x0C,
+	0x0A, 0xFE, 0xAE, 0x09, 0x31,
+	0x04, 0xC1, 0xEF, 0x8B, 0x99,
+	0x04, 0xA7, 0x68, 0xF3, 0xE6,
+	0x0D, 0x48, 0xE1, 0x6A, 0xE2,
+	0x0A, 0x50, 0x90, 0x82, 0xE7,
+	0x0A, 0xC3, 0x7A, 0xE0, 0xCF,
+	0x0A, 0xD3, 0xF6, 0xCD, 0x65,
+	0x09, 0xA9, 0x9A, 0x0C, 0x6F,
+	0x0A, 0x5F, 0xD3, 0x6E, 0xA5,
+	0x0F, 0xC5, 0xDD, 0x06, 0x8F,
+	0x04, 0x16, 0x3C, 0xA8, 0x85,
+	0x01, 0xCD, 0x0B, 0x9C, 0xC9,
+	0x0D, 0x75, 0x10, 0x14, 0x8B,
+	0x06, 0xCD, 0x0F, 0x70, 0xFF,
+	0x03, 0xDF, 0x17, 0x32, 0x09,
+	0x06, 0xD1, 0x63, 0xCF, 0x0A,
+	0x09, 0xC7, 0x55, 0xC8, 0xC4,
+	0x08, 0xA3, 0x16, 0x4E, 0x95,
+	0x0C, 0xF2, 0x68, 0x8A, 0x55,
+	0x07, 0xEC, 0x90, 0xD1, 0x9A,
+	0x03, 0x30, 0x1A, 0xC4, 0xFE,
+	0x05, 0xA4, 0x73, 0x59, 0x66,
+	0x07, 0xBA, 0x8D, 0x6D, 0xD8,
+	0x0D, 0x7D, 0x56, 0x07, 0x1E,
+	0x07, 0x70, 0x38, 0x52, 0x7A,
+	0x0A, 0x24, 0x31, 0x81, 0xE7,
+	0x01, 0x1D, 0xE1, 0xFF, 0x07,
+	0x06, 0x2E, 0x64, 0x12, 0x9D,
+	0x03, 0xCF, 0x99, 0x18, 0x2A,
+	0x0D, 0xAB, 0x89, 0x88, 0x80,
+	0x0B, 0x30, 0x5E, 0xA9, 0x8D,
+	0x03, 0xBF, 0xCB, 0x2B, 0x6F,
+	0x05, 0x25, 0xBF, 0xA6, 0x92,
+	0x08, 0x31, 0x14, 0x67, 0x3F,
+	0x0D, 0x8C, 0xB2, 0xC1, 0xDF,
+	0x0D, 0x1B, 0x5B, 0xBD, 0x5A,
+	0x03, 0xAA, 0x14, 0xA2, 0x2E,
+	0x00, 0x73, 0xA6, 0xF8, 0x5D,
+	0x04, 0x67, 0x08, 0x1B, 0x00,
+	0x02, 0x43, 0x1E, 0x02, 0x7C,
+	0x05, 0x4A, 0x47, 0x39, 0xC7,
+	0x05, 0x30, 0xC8, 0xC7, 0x3B,
+	0x07, 0x13, 0x11, 0x0D, 0xCD,
+	0x09, 0x49, 0xD4, 0x15, 0x13,
+	0x02, 0x28, 0x56, 0x11, 0x38,
+	0x0B, 0x7E, 0x4D, 0xC8, 0xCA,
+	0x03, 0x28, 0xD2, 0x70, 0xC1,
+	0x0D, 0x65, 0x9E, 0x3E, 0xE8,
+	0x0C, 0xB7, 0xA0, 0xB7, 0x75,
+	0x09, 0x28, 0x9E, 0x51, 0xC0,
+	0x07, 0x49, 0xEB, 0xA8, 0x90,
+	0x0E, 0x17, 0xB6, 0x6C, 0xFD,
+	0x0F, 0xFC, 0x1E, 0xF8, 0xB9,
+	0x09, 0xCA, 0x94, 0x8D, 0xBE,
+	0x06, 0x52, 0x6C, 0xB6, 0xAC,
+	0x0F, 0xA0, 0x61, 0x08, 0x02,
+	0x0A, 0xAC, 0x37, 0xA6, 0xE4,
+	0x08, 0xAD, 0x3F, 0x60, 0x62,
+	0x06, 0x9C, 0x7B, 0x00, 0xD6,
+	0x08, 0xA5, 0x3F, 0x1B, 0xBA,
+	0x02, 0x3D, 0xBD, 0xDE, 0xAB,
+	0x06, 0xC1, 0x6B, 0xEA, 0xA0,
+	0x0A, 0xBC, 0xBB, 0x85, 0x47,
+	0x0A, 0xD7, 0x91, 0x2D, 0x9C,
+	0x06, 0x6D, 0x10, 0xED, 0x8F,
+	0x00, 0x3D, 0xF1, 0x73, 0x20,
+	0x0C, 0xED, 0x1C, 0x78, 0x52,
+	0x02, 0x99, 0xBD, 0xD1, 0xC5,
+	0x0D, 0x82, 0xF1, 0x89, 0xE5,
+	0x02, 0x69, 0xAF, 0x48, 0xE1,
+	0x0A, 0x7E, 0xCB, 0x20, 0xB0,
+	0x05, 0x33, 0x00, 0x0C, 0xA3,
+	0x0B, 0xFA, 0x2C, 0x75, 0x96,
+	0x00, 0xFB, 0xA0, 0xD6, 0xD7,
+	0x0B, 0xD7, 0x15, 0x4D, 0x2C,
+	0x00, 0xF7, 0xE3, 0x91, 0x27,
+	0x07, 0x23, 0xA3, 0x3A, 0xDE,
+	0x01, 0xA1, 0xDE, 0x1F, 0xF0,
+	0x03, 0xE2, 0xE4, 0x45, 0xE3,
+	0x06, 0x3C, 0xFA, 0x71, 0x66,
+	0x01, 0x58, 0xD8, 0x95, 0x88,
+	0x0E, 0x25, 0xEB, 0x4A, 0xB8,
+	0x02, 0x9B, 0x92, 0xC2, 0x80,
+	0x04, 0x93, 0x9B, 0xFF, 0x6A,
+	0x0E, 0x03, 0x19, 0x46, 0x97,
+	0x0C, 0x58, 0xE9, 0x28, 0x78,
+	0x0F, 0x41, 0xAD, 0x3F, 0xB1,
+	0x07, 0xAA, 0x82, 0xC8, 0x78,
+	0x0E, 0x07, 0x38, 0x41, 0x97,
+	0x0C, 0x86, 0x72, 0xB0, 0xBA,
+	0x0B, 0xBC, 0xBF, 0x60, 0xF7,
+	0x0D, 0x4C, 0x22, 0x51, 0x34,
+	0x03, 0xF5, 0xBC, 0xA4, 0x51,
+	0x0C, 0x71, 0xF1, 0x12, 0x88,
+	0x0C, 0x15, 0x4B, 0x61, 0x9D,
+	0x0E, 0x20, 0xA5, 0x6B, 0x7B,
+	0x0E, 0xB1, 0x3F, 0x54, 0xEC,
+	0x0F, 0xB0, 0xCD, 0x23, 0xE8,
+	0x0B, 0xD0, 0x82, 0x63, 0xCE,
+	0x0A, 0xDA, 0xB6, 0x07, 0x5F,
+	0x0F, 0x04, 0x4E, 0x65, 0xFC,
+	0x04, 0x72, 0x40, 0xBA, 0x88,
+	0x04, 0xE1, 0x7B, 0x68, 0x8E,
+	0x00, 0x7F, 0xC1, 0xED, 0x01,
+	0x01, 0x04, 0xA7, 0x65, 0x7A,
+	0x0A, 0xC5, 0x4B, 0x23, 0x5E,
+	0x0A, 0x62, 0x20, 0x1D, 0x86,
+	0x0F, 0x2A, 0xC1, 0x7A, 0x6E,
+	0x0F, 0x0C, 0x31, 0x76, 0x48,
+	0x07, 0xC9, 0xA9, 0x95, 0x85,
+	0x0F, 0xDA, 0x57, 0xDC, 0xA2,
+	0x0C, 0xB3, 0xC5, 0xDD, 0x06,
+	0x06, 0xEC, 0x14, 0xBE, 0xA0,
+	0x05, 0x2B, 0xC9, 0xB5, 0x55,
+	0x09, 0x3D, 0x74, 0x92, 0x19,
+	0x02, 0xF6, 0xCF, 0x0E, 0xFA,
+	0x07, 0x83, 0xDF, 0x17, 0x32,
+	0x02, 0x4E, 0xD1, 0xE7, 0xCD,
+	0x03, 0x11, 0x22, 0xD5, 0x04,
+	0x0E, 0x46, 0xC4, 0x98, 0x0E,
+	0x0C, 0x86, 0x34, 0xD8, 0x8A,
+	0x0F, 0xA1, 0x16, 0x12, 0xDE,
+	0x0F, 0x53, 0x31, 0x58, 0xF3,
+	0x0D, 0x3D, 0x82, 0xC9, 0x19,
+	0x0D, 0x89, 0x53, 0x0D, 0x7D,
+	0x04, 0x2D, 0x7B, 0xD4, 0x33,
+	0x0E, 0x97, 0xB0, 0x37, 0x92,
+	0x03, 0xE8, 0x64, 0x37, 0x85,
+	0x07, 0x9C, 0xE7, 0x61, 0xFE,
+	0x0B, 0xBE, 0x2C, 0x24, 0x2B,
+	0x04, 0x21, 0xEF, 0x95, 0x55,
+	0x09, 0x8B, 0x40, 0x09, 0x8C,
+	0x09, 0x42, 0xF0, 0x98, 0xAB,
+	0x07, 0xEF, 0x43, 0x94, 0x2A,
+	0x03, 0xD9, 0x27, 0xFF, 0x1F,
+	0x0F, 0xE2, 0x31, 0x9A, 0x29,
+	0x05, 0x43, 0x61, 0xB2, 0xCB,
+	0x03, 0x74, 0x1F, 0xDB, 0x89,
+	0x03, 0xFA, 0x68, 0x1A, 0xEF,
+	0x07, 0xE2, 0x33, 0xA0, 0xB5,
+	0x0E, 0x4E, 0x9D, 0x8B, 0xDA,
+	0x08, 0x3B, 0xC2, 0xBE, 0x36,
+	0x05, 0xDE, 0xC8, 0x2B, 0x7B,
+	0x0D, 0x99, 0xC2, 0x2A, 0x57,
+	0x07, 0x57, 0x12, 0xD1, 0x39,
+	0x0D, 0xE3, 0x19, 0x58, 0x5B,
+	0x09, 0x74, 0xDC, 0x56, 0x97,
+	0x0E, 0x4B, 0x7A, 0xCD, 0x75,
+	0x09, 0x63, 0xE8, 0xDC, 0xBE,
+	0x02, 0x1C, 0xA5, 0x9A, 0x7E,
+	0x02, 0x33, 0x4D, 0xE0, 0xB4,
+	0x09, 0x50, 0x28, 0x1E, 0x64,
+	0x09, 0x65, 0x49, 0xE5, 0xE8,
+	0x0A, 0xC8, 0xEE, 0xB6, 0x78,
+	0x0B, 0x87, 0xFD, 0xDE, 0xC1,
+	0x00, 0x12, 0x6A, 0x78, 0xCF,
+	0x04, 0x6A, 0xAD, 0x8E, 0x32,
+	0x02, 0x26, 0x23, 0x81, 0x31,
+	0x0B, 0x72, 0x6C, 0x33, 0xE6,
+	0x0D, 0x52, 0xED, 0x31, 0x24,
+	0x0C, 0xFA, 0x60, 0x19, 0x81,
+	0x0A, 0x52, 0x1E, 0x7D, 0x2F,
+	0x0A, 0xCB, 0x3C, 0x73, 0xAB,
+	0x01, 0x68, 0x3E, 0xEB, 0xEB,
+	0x09, 0xD3, 0x7C, 0xBB, 0x41,
+	0x02, 0xAB, 0xD7, 0x51, 0x36,
+	0x00, 0x10, 0x90, 0xD0, 0xD6,
+	0x0F, 0xF8, 0x3D, 0xF5, 0xAE,
+	0x09, 0x14, 0x0D, 0x10, 0x3C,
+	0x01, 0x2F, 0xFC, 0x6D, 0x9C,
+	0x0C, 0x44, 0x02, 0x11, 0x84,
+	0x0C, 0xF0, 0x8F, 0x49, 0x08,
+	0x01, 0x5A, 0x7E, 0xC9, 0x2D,
+	0x09, 0x35, 0x33, 0x05, 0x77,
+	0x03, 0x4B, 0xFA, 0x2C, 0x75,
+	0x0D, 0x78, 0xFB, 0xA0, 0xD6,
+	0x01, 0x82, 0xD6, 0x95, 0x79,
+	0x0C, 0xFB, 0x77, 0x0D, 0xDD,
+	0x0D, 0xA9, 0xAA, 0x43, 0x3C,
+	0x02, 0xD9, 0xA3, 0x9E, 0x26,
+	0x09, 0xF9, 0xE2, 0xE8, 0x01,
+	0x03, 0xDD, 0x34, 0xF9, 0xA1,
+	0x0E, 0x38, 0xD8, 0xF8, 0xA1,
+	0x01, 0x86, 0x03, 0x07, 0x8A,
+	0x0A, 0xD9, 0x9C, 0x91, 0x4A,
+	0x08, 0xFD, 0x93, 0x1B, 0xCB,
+	0x03, 0xE4, 0x43, 0x17, 0x06,
+	0x0D, 0xF3, 0x5F, 0xEB, 0x2E,
+	0x0B, 0xF0, 0x49, 0xAD, 0xBA,
+	0x0C, 0xAF, 0x6A, 0x85, 0x4A,
+	0x08, 0xE9, 0x34, 0x3A, 0x4E,
+	0x01, 0x44, 0x87, 0x30, 0x84,
+	0x0A, 0xC1, 0xFC, 0x31, 0xA0,
+	0x0D, 0xC2, 0xDC, 0x82, 0x57,
+	0x08, 0x79, 0xF1, 0x22, 0x9D,
+	0x08, 0x37, 0x31, 0x3F, 0x50,
+	0x02, 0x41, 0x03, 0x95, 0x71,
+	0x01, 0x37, 0x20, 0xC5, 0x50,
+	0x02, 0xA6, 0xB7, 0xEA, 0x94,
+	0x06, 0x01, 0x3C, 0x0D, 0x27,
+	0x04, 0xB1, 0xD7, 0x19, 0xDA,
+	0x07, 0x01, 0x7B, 0x78, 0x4B,
+	0x05, 0x52, 0x0C, 0x15, 0xE7,
+	0x06, 0x09, 0x64, 0x9E, 0xBB,
+	0x05, 0x0C, 0xE3, 0xFB, 0x5F,
+	0x0E, 0x79, 0xBF, 0xCF, 0xAF,
+	0x01, 0x9E, 0x37, 0xA7, 0x69,
+	0x0F, 0xE6, 0xC4, 0x08, 0xDA,
+	0x03, 0x60, 0x42, 0x2E, 0x50,
+	0x06, 0x20, 0x32, 0xC3, 0x7E,
+	0x02, 0x45, 0x08, 0x93, 0xCF,
+	0x00, 0xED, 0xE9, 0xA7, 0xD8,
+	0x06, 0x62, 0x02, 0x5F, 0xC1,
+	0x0F, 0xAC, 0xB2, 0x87, 0xE4,
+	0x0F, 0x34, 0xEC, 0x18, 0xFE,
+	0x00, 0x02, 0x3D, 0x4B, 0xBA,
+	0x00, 0xE9, 0x3F, 0x35, 0x2B,
+	0x00, 0x40, 0xB6, 0xC3, 0x4E,
+	0x0A, 0xF8, 0x95, 0x5F, 0x1F,
+	0x08, 0x0E, 0x56, 0xD1, 0xE6,
+	0x01, 0x8A, 0x95, 0x46, 0xEC,
+	0x0D, 0xC5, 0xE0, 0x2F, 0x58,
+	0x04, 0x52, 0xB5, 0xF4, 0xDD,
+	0x06, 0x15, 0xA6, 0xAC, 0xAB,
+	0x06, 0x11, 0x53, 0x3E, 0x58,
+	0x00, 0x33, 0x9F, 0x22, 0xC3,
+	0x05, 0x67, 0x8D, 0xFA, 0x34,
+	0x04, 0x5A, 0x2D, 0x73, 0x14,
+	0x00, 0x50, 0xB7, 0xF0, 0x29,
+	0x0E, 0x7A, 0xEB, 0x64, 0x0A,
+	0x0C, 0x6F, 0xBA, 0x13, 0xA1,
+	0x05, 0x00, 0xA0, 0xAE, 0x66,
+	0x0E, 0x9D, 0xA1, 0x8F, 0xA2,
+	0x0C, 0xA1, 0xCD, 0xA5, 0xC9,
+	0x02, 0x87, 0x5C, 0xB0, 0x94,
+	0x01, 0x0A, 0xC9, 0x39, 0x15,
+	0x07, 0x4F, 0xDF, 0xA5, 0x86,
+	0x0F, 0xA6, 0xA0, 0x3F, 0xD4,
+	0x00, 0x7D, 0x05, 0x8A, 0xB2,
+	0x05, 0x18, 0x47, 0x1A, 0xDA,
+	0x0C, 0x5A, 0xFB, 0xE8, 0x2D,
+	0x06, 0xAC, 0xC0, 0x7D, 0xE4,
+	0x0F, 0xD3, 0x61, 0x67, 0x0F,
+	0x07, 0x34, 0x39, 0x83, 0xC7,
+	0x06, 0xFE, 0x7C, 0xC6, 0x65,
+	0x01, 0x40, 0xB6, 0x36, 0x3A,
+	0x0B, 0x1B, 0x55, 0x53, 0x28,
+	0x09, 0x06, 0x61, 0x37, 0x16,
+	0x01, 0xD4, 0x55, 0x28, 0x5E,
+	0x03, 0xB2, 0x4A, 0x3E, 0x74,
+	0x05, 0x42, 0x23, 0x26, 0x92,
+	0x04, 0x8C, 0x3A, 0x65, 0x9C,
+	0x04, 0xEF, 0x1C, 0xB7, 0x61,
+	0x09, 0xF5, 0x54, 0xA9, 0x67,
+	0x04, 0xC0, 0x27, 0x47, 0xAB,
+	0x01, 0x92, 0x8E, 0x13, 0xF6,
+	0x02, 0x70, 0xB4, 0xFC, 0x1F,
+	0x04, 0xB9, 0x91, 0x0A, 0x4F,
+	0x06, 0xBC, 0x2C, 0x5A, 0xCE,
+	0x0C, 0xA9, 0x17, 0xA2, 0x05,
+	0x04, 0xC2, 0x70, 0xEC, 0x0E,
+	0x0F, 0x66, 0x10, 0xA3, 0x7F,
+	0x0E, 0x91, 0xCD, 0x1A, 0x89,
+	0x0C, 0xC6, 0x50, 0xE5, 0xC4,
+	0x0F, 0xB8, 0xCB, 0x32, 0x3D,
+	0x0A, 0x6C, 0x41, 0x41, 0x69,
+	0x06, 0xA0, 0x50, 0xFC, 0x82,
+	0x08, 0x4C, 0xB3, 0xD9, 0x11,
+	0x0B, 0x9B, 0x00, 0xEC, 0xD8,
+	0x05, 0x08, 0xC9, 0xBD, 0xF0,
+	0x0F, 0x20, 0x96, 0x6D, 0x27,
+	0x05, 0x58, 0x49, 0x12, 0x2D,
+	0x05, 0x4E, 0x24, 0x06, 0x91,
+	0x0E, 0xE2, 0x6B, 0x6F, 0x4C,
+	0x04, 0xA2, 0xE1, 0xFE, 0xF0,
+	0x0D, 0xF9, 0x35, 0x3D, 0x7A,
+	0x06, 0xA4, 0x70, 0xFA, 0x2D,
+	0x09, 0x96, 0x7E, 0x3B, 0x99,
+	0x0F, 0x5F, 0xC6, 0xD9, 0x95,
+	0x0A, 0xA2, 0x4F, 0x77, 0x01,
+	0x01, 0x24, 0x15, 0x22, 0x7A,
+	0x08, 0x5E, 0xD9, 0xAF, 0xA5,
+	0x05, 0xF7, 0x40, 0xE2, 0xE7,
+	0x08, 0xA8, 0x1A, 0x3C, 0x39,
+	0x0D, 0x6A, 0x38, 0xDA, 0xAF,
+	0x04, 0xB7, 0xF8, 0x23, 0x30,
+	0x0A, 0xB0, 0xDE, 0x9F, 0x4C,
+	0x0B, 0x34, 0x1D, 0x9C, 0x1B,
+	0x0B, 0xEC, 0x86, 0x03, 0xD9,
+	0x06, 0x97, 0xF4, 0x58, 0xEB,
+	0x05, 0x59, 0x17, 0x45, 0x6D,
+	0x0B, 0x05, 0xAF, 0xAA, 0x81,
+	0x0A, 0xF2, 0xEE, 0x03, 0xC1,
+	0x0F, 0x5D, 0x44, 0x86, 0x70,
+	0x06, 0xB3, 0x43, 0xBC, 0x3F,
+	0x0C, 0xF7, 0xC7, 0xCC, 0xBB,
+	0x0B, 0xB4, 0x7B, 0xF3, 0x62,
+	0x0C, 0x71, 0xB5, 0x71, 0x31,
+	0x09, 0x08, 0x86, 0x11, 0x15,
+	0x08, 0x3F, 0x77, 0x2C, 0xC5,
+	0x03, 0xFC, 0x60, 0xB7, 0xF4,
+	0x08, 0xF4, 0x06, 0x32, 0x9A,
+	0x06, 0xE9, 0x71, 0xD6, 0x99,
+	0x0F, 0xD1, 0x7F, 0x5B, 0x4F,
+	0x0B, 0x5F, 0x55, 0x06, 0x08,
+	0x0C, 0xDC, 0xCE, 0x7A, 0xDE,
+	0x03, 0x8F, 0xCC, 0xE1, 0xBB,
+	0x06, 0x87, 0x78, 0x7F, 0xC1,
+	0x06, 0xA3, 0x59, 0x00, 0x27,
+	0x08, 0xF3, 0xE6, 0xCB, 0x41,
+	0x03, 0x6A, 0xE2, 0x66, 0xAA,
+	0x00, 0x8C, 0x25, 0x2A, 0xC3,
+	0x01, 0x6E, 0x45, 0x0A, 0xD3,
+	0x0E, 0x49, 0x6D, 0xC9, 0xA9,
+	0x00, 0x0C, 0x64, 0x9A, 0x5F,
+	0x09, 0x63, 0xAC, 0xB3, 0xC7,
+	0x05, 0x86, 0x15, 0x6E, 0x96,
+	0x0E, 0xAA, 0x05, 0xAB, 0xCB,
+	0x08, 0x1C, 0xEA, 0x3F, 0xFF,
+	0x02, 0x19, 0xC2, 0x76, 0xCD,
+	0x0E, 0xF0, 0xFC, 0x81, 0x55,
+	0x07, 0x32, 0x09, 0xCE, 0xD1,
+	0x07, 0xCD, 0x89, 0x13, 0x4C,
+	0x05, 0xC4, 0xC6, 0x44, 0x2B,
+	0x03, 0x4E, 0x55, 0x86, 0xF4,
+	0x04, 0x8A, 0x95, 0xA9, 0x2C,
+	0x09, 0x58, 0xD6, 0x53, 0x30,
+	0x00, 0xCA, 0x36, 0xBF, 0xA2,
+	0x0F, 0x59, 0xE6, 0x81, 0xFA,
+	0x05, 0x6D, 0xDA, 0x2D, 0x7D,
+	0x0F, 0x8D, 0x12, 0x93, 0x0B,
+	0x01, 0xD2, 0x7A, 0xEE, 0x5D,
+	0x08, 0x85, 0xED, 0x9A, 0x1D,
+	0x01, 0xFF, 0x01, 0xBE, 0xEA,
+	0x04, 0x12, 0x9D, 0xA3, 0xCF,
+	0x0B, 0x15, 0x27, 0x8D, 0x6F,
+	0x09, 0x88, 0x80, 0x42, 0x30,
+	0x0C, 0xAB, 0x0D, 0x69, 0x33,
+	0x04, 0x2B, 0x4F, 0xD9, 0x25,
+	0x0F, 0x26, 0xA2, 0xE0, 0xBB,
+	0x04, 0x69, 0x7F, 0x65, 0x4B,
+	0x02, 0xCF, 0x1F, 0x74, 0xDF,
+	0x0B, 0xB0, 0x5A, 0xFA, 0xA8,
+	0x04, 0xAF, 0x2E, 0xE0, 0x73,
+	0x04, 0xF5, 0xD4, 0xC8, 0xED,
+	0x0B, 0xDB, 0x36, 0x1B, 0x49,
+	0x05, 0x0F, 0x7C, 0x5C, 0xC8,
+	0x0D, 0x3B, 0x47, 0x9F, 0x36,
+	0x06, 0x46, 0x5F, 0x57, 0x0E,
+	0x0B, 0xC0, 0x96, 0xEF, 0x96,
+	0x0E, 0x1B, 0xD7, 0x72, 0xE8,
+	0x0A, 0x9E, 0x0A, 0x8B, 0x63,
+	0x07, 0x8C, 0xC9, 0x6D, 0x9A,
+	0x0A, 0xFE, 0x8F, 0x1D, 0xA5,
+	0x02, 0x3F, 0x2A, 0x75, 0xAA,
+	0x0A, 0x75, 0xFC, 0x5E, 0x9C,
+	0x06, 0x5D, 0xC4, 0xE7, 0x89,
+	0x07, 0xA8, 0xB5, 0x8E, 0x0A,
+	0x0C, 0xA8, 0x61, 0x09, 0x44,
+	0x06, 0xF8, 0xBD, 0x90, 0x8A,
+	0x0A, 0x8F, 0x4E, 0x2C, 0x49,
+	0x04, 0xF6, 0xB8, 0xA8, 0x99,
+	0x09, 0x08, 0xC6, 0x72, 0x6C,
+	0x0B, 0xA6, 0x66, 0x50, 0xB0,
+	0x05, 0xA4, 0x80, 0x72, 0x24,
+	0x01, 0x80, 0xC2, 0x51, 0x65,
+	0x01, 0x16, 0xA3, 0xCB, 0x21,
+	0x07, 0x10, 0x7D, 0xE0, 0x00,
+	0x03, 0xEA, 0xA4, 0x52, 0x7C,
+	0x00, 0x81, 0xCE, 0x93, 0xD7,
+};
+
+static u8 ak7755_cram_aec[]= {
+	0xB4, 0x00, 0x00,    // CRAM Write Command  
+	0x7F, 0xFF, 0xF0,
+	0x7F, 0xF6, 0x20,
+	0x7F, 0xD8, 0x80,
+	0x7F, 0xA7, 0x30,
+	0x7F, 0x62, 0x30,
+	0x7F, 0x09, 0x90,
+	0x7E, 0x9D, 0x50,
+	0x7E, 0x1D, 0x90,
+	0x7D, 0x8A, 0x60,
+	0x7C, 0xE3, 0xD0,
+	0x7C, 0x2A, 0x00,
+	0x7B, 0x5D, 0x00,
+	0x7A, 0x7D, 0x00,
+	0x79, 0x8A, 0x20,
+	0x78, 0x84, 0x80,
+	0x77, 0x6C, 0x50,
+	0x76, 0x41, 0xB0,
+	0x75, 0x04, 0xD0,
+	0x73, 0xB5, 0xF0,
+	0x72, 0x55, 0x30,
+	0x70, 0xE2, 0xD0,
+	0x6F, 0x5F, 0x00,
+	0x6D, 0xCA, 0x10,
+	0x6C, 0x24, 0x30,
+	0x6A, 0x6D, 0xA0,
+	0x68, 0xA6, 0xA0,
+	0x66, 0xCF, 0x80,
+	0x64, 0xE8, 0x90,
+	0x62, 0xF2, 0x00,
+	0x60, 0xEC, 0x40,
+	0x5E, 0xD7, 0x80,
+	0x5C, 0xB4, 0x20,
+	0x5A, 0x82, 0x80,
+	0x58, 0x42, 0xE0,
+	0x55, 0xF5, 0xA0,
+	0x53, 0x9B, 0x30,
+	0x51, 0x33, 0xD0,
+	0x4E, 0xBF, 0xF0,
+	0x4C, 0x3F, 0xE0,
+	0x49, 0xB4, 0x10,
+	0x47, 0x1C, 0xF0,
+	0x44, 0x7A, 0xD0,
+	0x41, 0xCE, 0x20,
+	0x3F, 0x17, 0x50,
+	0x3C, 0x56, 0xC0,
+	0x39, 0x8C, 0xE0,
+	0x36, 0xBA, 0x20,
+	0x33, 0xDE, 0xF0,
+	0x30, 0xFB, 0xC0,
+	0x2E, 0x11, 0x10,
+	0x2B, 0x1F, 0x30,
+	0x28, 0x26, 0xC0,
+	0x25, 0x28, 0x10,
+	0x22, 0x23, 0xA0,
+	0x1F, 0x1A, 0x00,
+	0x1C, 0x0B, 0x80,
+	0x18, 0xF8, 0xC0,
+	0x15, 0xE2, 0x10,
+	0x12, 0xC8, 0x10,
+	0x0F, 0xAB, 0x20,
+	0x0C, 0x8B, 0xD0,
+	0x09, 0x6A, 0x90,
+	0x06, 0x47, 0xE0,
+	0x03, 0x24, 0x30,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x14, 0x00,
+	0xF0, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0xFF, 0x87, 0x50,
+	0xFE, 0x8C, 0x50,
+	0xFD, 0xE9, 0x70,
+	0x00, 0x00, 0x00,
+	0x06, 0xD8, 0xD0,
+	0x11, 0x8D, 0x30,
+	0x1B, 0xAE, 0x90,
+	0x1F, 0xDC, 0xD0,
+	0x1B, 0xAE, 0x90,
+	0x11, 0x8D, 0x30,
+	0x06, 0xD8, 0xD0,
+	0x00, 0x00, 0x00,
+	0xFD, 0xE9, 0x70,
+	0xFE, 0x8C, 0x50,
+	0xFF, 0x87, 0x50,
+	0x00, 0x00, 0x00,
+	0x00, 0x18, 0x00,
+	0x07, 0x87, 0x80,
+	0x78, 0x78, 0x80,
+	0x00, 0x19, 0x00,
+	0x45, 0xD9, 0xB0,
+	0x3A, 0x26, 0x50,
+	0x00, 0x1A, 0x00,
+	0x05, 0x4A, 0x20,
+	0x7A, 0xB5, 0xE0,
+	0x00, 0x1D, 0x00,
+	0x52, 0xF8, 0x20,
+	0x2D, 0x07, 0xE0,
+	0x00, 0x20, 0x00,
+	0x43, 0xC3, 0xC0,
+	0x3C, 0x3C, 0x40,
+	0x00, 0x24, 0x00,
+	0x72, 0xE1, 0xA0,
+	0x0D, 0x1E, 0x60,
+	0x00, 0x28, 0x00,
+	0x7F, 0xFF, 0xF0,
+	0x00, 0x00, 0x00,
+	0x00, 0x2B, 0x00,
+	0x0D, 0x1E, 0x60,
+	0x72, 0xE1, 0xA0,
+	0x00, 0x2F, 0x00,
+	0x3C, 0x3C, 0x40,
+	0x43, 0xC3, 0xC0,
+	0x00, 0x32, 0x00,
+	0x2D, 0x07, 0xE0,
+	0x52, 0xF8, 0x20,
+	0x00, 0x35, 0x00,
+	0x7A, 0xB5, 0xE0,
+	0x05, 0x4A, 0x20,
+	0x00, 0x36, 0x00,
+	0x3A, 0x26, 0x50,
+	0x45, 0xD9, 0xB0,
+	0x00, 0x37, 0x00,
+	0x78, 0x78, 0x80,
+	0x07, 0x87, 0x80,
+	0x20, 0x00, 0x00,
+	0x06, 0x66, 0x60,
+	0x00, 0x00, 0x00,
+	0x00, 0x0A, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x01, 0x00,
+	0x00, 0xC2, 0x00,
+	0x00, 0x00, 0x10,
+	0x01, 0x50, 0x20,
+	0x03, 0x00, 0x30,
+	0x04, 0x50, 0x40,
+	0x06, 0x00, 0x50,
+	0x07, 0x50, 0x60,
+	0x09, 0x00, 0x70,
+	0x10, 0x50, 0x80,
+	0x12, 0x00, 0x90,
+	0x13, 0x50, 0xA0,
+	0x15, 0x00, 0xB0,
+	0x16, 0x50, 0xC0,
+	0x18, 0x00, 0xD0,
+	0x19, 0x50, 0xE0,
+	0x21, 0x00, 0xF0,
+	0x22, 0x51, 0x00,
+	0x24, 0x01, 0x10,
+	0x25, 0x51, 0x20,
+	0x27, 0x01, 0x30,
+	0x28, 0x51, 0x40,
+	0x30, 0x01, 0x50,
+	0x31, 0x51, 0x60,
+	0x33, 0x01, 0x70,
+	0x34, 0x51, 0x80,
+	0x36, 0x01, 0x90,
+	0x01, 0x50, 0x20,
+	0x03, 0x00, 0x30,
+	0x00, 0x00, 0x00,
+	0x00, 0x10, 0x00,
+	0x00, 0x20, 0x00,
+	0x00, 0x40, 0x00,
+	0x00, 0x60, 0x00,
+	0x00, 0x7F, 0x00,
+	0x00, 0x00, 0x00,
+	0x02, 0x87, 0xA0,
+	0x00, 0xCC, 0xD0,
+	0x00, 0x40, 0xC0,
+	0x00, 0x14, 0x80,
+	0x00, 0xCC, 0xD0,
+	0x00, 0x00, 0x00,
+	0x00, 0x07, 0x40,
+	0x00, 0x1C, 0x20,
+	0x00, 0x29, 0xE0,
+	0x00, 0x06, 0x20,
+	0xFF, 0xB7, 0x40,
+	0xFF, 0x96, 0x70,
+	0xFF, 0xDC, 0x30,
+	0x00, 0x29, 0x10,
+	0x00, 0x00, 0x80,
+	0xFF, 0xA9, 0xB0,
+	0xFF, 0xD3, 0x90,
+	0x00, 0x4E, 0xA0,
+	0x00, 0x34, 0xB0,
+	0xFF, 0x99, 0x10,
+	0xFF, 0xA4, 0x60,
+	0x00, 0x6C, 0xF0,
+	0x00, 0x7D, 0xA0,
+	0xFF, 0x85, 0xC0,
+	0xFF, 0x50, 0x20,
+	0x00, 0x7E, 0x50,
+	0x00, 0xE7, 0xD0,
+	0xFF, 0x7F, 0xF0,
+	0xFE, 0xD3, 0x60,
+	0x00, 0x78, 0xE0,
+	0x01, 0x7B, 0xF0,
+	0xFF, 0x96, 0xC0,
+	0xFE, 0x27, 0x10,
+	0x00, 0x4D, 0x20,
+	0x02, 0x44, 0x30,
+	0xFF, 0xDD, 0xD0,
+	0xFD, 0x3F, 0x70,
+	0xFF, 0xE3, 0xD0,
+	0x03, 0x51, 0x40,
+	0x00, 0x73, 0x80,
+	0xFC, 0x04, 0x30,
+	0xFF, 0x13, 0xD0,
+	0x04, 0xC9, 0x20,
+	0x01, 0x93, 0x50,
+	0xFA, 0x37, 0x10,
+	0xFD, 0x80, 0x50,
+	0x07, 0x18, 0xF0,
+	0x03, 0xDC, 0xF0,
+	0xF7, 0x08, 0x60,
+	0xF9, 0xF4, 0x10,
+	0x0C, 0x00, 0x30,
+	0x0A, 0x1A, 0x30,
+	0xED, 0xCD, 0x40,
+	0xEB, 0x8C, 0x30,
+	0x28, 0x40, 0xF0,
+	0x70, 0x4E, 0x60,
+	0x70, 0x4E, 0x60,
+	0x28, 0x40, 0xF0,
+	0xEB, 0x8C, 0x30,
+	0xED, 0xCD, 0x40,
+	0x0A, 0x1A, 0x30,
+	0x0C, 0x00, 0x30,
+	0xF9, 0xF4, 0x10,
+	0xF7, 0x08, 0x60,
+	0x03, 0xDC, 0xF0,
+	0x07, 0x18, 0xF0,
+	0xFD, 0x80, 0x50,
+	0xFA, 0x37, 0x10,
+	0x01, 0x93, 0x50,
+	0x04, 0xC9, 0x20,
+	0xFF, 0x13, 0xD0,
+	0xFC, 0x04, 0x30,
+	0x00, 0x73, 0x80,
+	0x03, 0x51, 0x40,
+	0xFF, 0xE3, 0xD0,
+	0xFD, 0x3F, 0x70,
+	0xFF, 0xDD, 0xD0,
+	0x02, 0x44, 0x30,
+	0x00, 0x4D, 0x20,
+	0xFE, 0x27, 0x10,
+	0xFF, 0x96, 0xC0,
+	0x01, 0x7B, 0xF0,
+	0x00, 0x78, 0xE0,
+	0xFE, 0xD3, 0x60,
+	0xFF, 0x7F, 0xF0,
+	0x00, 0xE7, 0xD0,
+	0x00, 0x7E, 0x50,
+	0xFF, 0x50, 0x20,
+	0xFF, 0x85, 0xC0,
+	0x00, 0x7D, 0xA0,
+	0x00, 0x6C, 0xF0,
+	0xFF, 0xA4, 0x60,
+	0xFF, 0x99, 0x10,
+	0x00, 0x34, 0xB0,
+	0x00, 0x4E, 0xA0,
+	0xFF, 0xD3, 0x90,
+	0xFF, 0xA9, 0xB0,
+	0x00, 0x00, 0x80,
+	0x00, 0x29, 0x10,
+	0xFF, 0xDC, 0x30,
+	0xFF, 0x96, 0x70,
+	0xFF, 0xB7, 0x40,
+	0x00, 0x06, 0x20,
+	0x00, 0x29, 0xE0,
+	0x00, 0x1C, 0x20,
+	0x00, 0x07, 0x40,
+	0x00, 0x00, 0x00,
+	0xFF, 0xFD, 0x60,
+	0xFF, 0xF9, 0x60,
+	0xFF, 0xFD, 0x40,
+	0x00, 0x0A, 0x90,
+	0x00, 0x0C, 0x80,
+	0xFF, 0xF8, 0x00,
+	0xFF, 0xEF, 0x60,
+	0x00, 0x0D, 0xB0,
+	0x00, 0x1F, 0xE0,
+	0xFF, 0xF3, 0x50,
+	0xFF, 0xD0, 0xC0,
+	0x00, 0x0E, 0x40,
+	0x00, 0x48, 0x10,
+	0xFF, 0xF5, 0x80,
+	0xFF, 0x9A, 0x50,
+	0x00, 0x05, 0x20,
+	0x00, 0x8D, 0x90,
+	0x00, 0x06, 0xB0,
+	0xFF, 0x41, 0xD0,
+	0xFF, 0xE7, 0xB0,
+	0x00, 0xFB, 0x20,
+	0x00, 0x33, 0x80,
+	0xFE, 0xBB, 0x40,
+	0xFF, 0xA6, 0x60,
+	0x01, 0x9E, 0x30,
+	0x00, 0x8E, 0xD0,
+	0xFD, 0xF6, 0x70,
+	0xFF, 0x29, 0x50,
+	0x02, 0x8B, 0x40,
+	0x01, 0x37, 0x70,
+	0xFC, 0xD7, 0x60,
+	0xFE, 0x46, 0xE0,
+	0x03, 0xEB, 0x30,
+	0x02, 0x69, 0x50,
+	0xFB, 0x1D, 0x40,
+	0xFC, 0xA1, 0x60,
+	0x06, 0x2D, 0x70,
+	0x04, 0xC5, 0x00,
+	0xF7, 0xF6, 0x20,
+	0xF9, 0x02, 0x40,
+	0x0B, 0x14, 0x00,
+	0x0B, 0x17, 0xC0,
+	0xEE, 0xB1, 0x80,
+	0xEA, 0x7B, 0x10,
+	0x27, 0x7C, 0x40,
+	0x71, 0xE1, 0xE0,
+	0x71, 0xE1, 0xE0,
+	0x27, 0x7C, 0x40,
+	0xEA, 0x7B, 0x10,
+	0xEE, 0xB1, 0x80,
+	0x0B, 0x17, 0xC0,
+	0x0B, 0x14, 0x00,
+	0xF9, 0x02, 0x40,
+	0xF7, 0xF6, 0x20,
+	0x04, 0xC5, 0x00,
+	0x06, 0x2D, 0x70,
+	0xFC, 0xA1, 0x60,
+	0xFB, 0x1D, 0x40,
+	0x02, 0x69, 0x50,
+	0x03, 0xEB, 0x30,
+	0xFE, 0x46, 0xE0,
+	0xFC, 0xD7, 0x60,
+	0x01, 0x37, 0x70,
+	0x02, 0x8B, 0x40,
+	0xFF, 0x29, 0x50,
+	0xFD, 0xF6, 0x70,
+	0x00, 0x8E, 0xD0,
+	0x01, 0x9E, 0x30,
+	0xFF, 0xA6, 0x60,
+	0xFE, 0xBB, 0x40,
+	0x00, 0x33, 0x80,
+	0x00, 0xFB, 0x20,
+	0xFF, 0xE7, 0xB0,
+	0xFF, 0x41, 0xD0,
+	0x00, 0x06, 0xB0,
+	0x00, 0x8D, 0x90,
+	0x00, 0x05, 0x20,
+	0xFF, 0x9A, 0x50,
+	0xFF, 0xF5, 0x80,
+	0x00, 0x48, 0x10,
+	0x00, 0x0E, 0x40,
+	0xFF, 0xD0, 0xC0,
+	0xFF, 0xF3, 0x50,
+	0x00, 0x1F, 0xE0,
+	0x00, 0x0D, 0xB0,
+	0xFF, 0xEF, 0x60,
+	0xFF, 0xF8, 0x00,
+	0x00, 0x0C, 0x80,
+	0x00, 0x0A, 0x90,
+	0xFF, 0xFD, 0x40,
+	0xFF, 0xF9, 0x60,
+	0xFF, 0xFD, 0x60,
+	0x00, 0x00, 0x00,
+	0x00, 0x14, 0x00,
+	0xF0, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0xFF, 0x87, 0x50,
+	0xFE, 0x8C, 0x50,
+	0xFD, 0xE9, 0x70,
+	0x00, 0x00, 0x00,
+	0x06, 0xD8, 0xD0,
+	0x11, 0x8D, 0x30,
+	0x1B, 0xAE, 0x90,
+	0x1F, 0xDC, 0xD0,
+	0x1B, 0xAE, 0x90,
+	0x11, 0x8D, 0x30,
+	0x06, 0xD8, 0xD0,
+	0x00, 0x00, 0x00,
+	0xFD, 0xE9, 0x70,
+	0xFE, 0x8C, 0x50,
+	0xFF, 0x87, 0x50,
+	0x00, 0x00, 0x00,
+	0x00, 0x18, 0x00,
+	0x07, 0x87, 0x80,
+	0x78, 0x78, 0x80,
+	0x00, 0x19, 0x00,
+	0x45, 0xD9, 0xB0,
+	0x3A, 0x26, 0x50,
+	0x00, 0x1A, 0x00,
+	0x05, 0x4A, 0x20,
+	0x7A, 0xB5, 0xE0,
+	0x00, 0x1D, 0x00,
+	0x52, 0xF8, 0x20,
+	0x2D, 0x07, 0xE0,
+	0x00, 0x20, 0x00,
+	0x43, 0xC3, 0xC0,
+	0x3C, 0x3C, 0x40,
+	0x00, 0x24, 0x00,
+	0x72, 0xE1, 0xA0,
+	0x0D, 0x1E, 0x60,
+	0x00, 0x28, 0x00,
+	0x7F, 0xFF, 0xF0,
+	0x00, 0x00, 0x00,
+	0x00, 0x2B, 0x00,
+	0x0D, 0x1E, 0x60,
+	0x72, 0xE1, 0xA0,
+	0x00, 0x2F, 0x00,
+	0x3C, 0x3C, 0x40,
+	0x43, 0xC3, 0xC0,
+	0x00, 0x32, 0x00,
+	0x2D, 0x07, 0xE0,
+	0x52, 0xF8, 0x20,
+	0x00, 0x35, 0x00,
+	0x7A, 0xB5, 0xE0,
+	0x05, 0x4A, 0x20,
+	0x00, 0x36, 0x00,
+	0x3A, 0x26, 0x50,
+	0x45, 0xD9, 0xB0,
+	0x00, 0x37, 0x00,
+	0x78, 0x78, 0x80,
+	0x07, 0x87, 0x80,
+	0x20, 0x00, 0x00,
+	0x06, 0x66, 0x60,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x08, 0x00, 0x00,
+	0xC8, 0x00, 0x00,
+	0xEB, 0xD8, 0x60,
+	0x42, 0xCD, 0xA0,
+	0xA2, 0x68, 0x10,
+	0x62, 0xB9, 0xF0,
+	0x0C, 0x35, 0x90,
+	0x00, 0x00, 0x00,
+	0x00, 0x14, 0x00,
+	0xF0, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0xFF, 0x87, 0x50,
+	0xFE, 0x8C, 0x50,
+	0xFD, 0xE9, 0x70,
+	0x00, 0x00, 0x00,
+	0x06, 0xD8, 0xD0,
+	0x11, 0x8D, 0x30,
+	0x1B, 0xAE, 0x90,
+	0x1F, 0xDC, 0xD0,
+	0x1B, 0xAE, 0x90,
+	0x11, 0x8D, 0x30,
+	0x06, 0xD8, 0xD0,
+	0x00, 0x00, 0x00,
+	0xFD, 0xE9, 0x70,
+	0xFE, 0x8C, 0x50,
+	0xFF, 0x87, 0x50,
+	0x00, 0x00, 0x00,
+	0x00, 0x18, 0x00,
+	0x07, 0x87, 0x80,
+	0x78, 0x78, 0x80,
+	0x00, 0x19, 0x00,
+	0x6A, 0x3E, 0xF0,
+	0x15, 0xC1, 0x10,
+	0x00, 0x1F, 0x00,
+	0x51, 0x95, 0xE0,
+	0x2E, 0x6A, 0x20,
+	0x00, 0x22, 0x00,
+	0x13, 0x41, 0x00,
+	0x6C, 0xBF, 0x00,
+	0x00, 0x26, 0x00,
+	0x27, 0xFE, 0xD0,
+	0x58, 0x01, 0x30,
+	0x00, 0x2A, 0x00,
+	0x31, 0x49, 0xC0,
+	0x4E, 0xB6, 0x40,
+	0x00, 0x2E, 0x00,
+	0x51, 0x64, 0x10,
+	0x2E, 0x9B, 0xF0,
+	0x00, 0x31, 0x00,
+	0x29, 0x02, 0x10,
+	0x56, 0xFD, 0xF0,
+	0x00, 0x33, 0x00,
+	0x3B, 0x6D, 0x40,
+	0x44, 0x92, 0xC0,
+	0x00, 0x35, 0x00,
+	0x7A, 0xB5, 0xE0,
+	0x05, 0x4A, 0x20,
+	0x00, 0x36, 0x00,
+	0x6C, 0xB7, 0x00,
+	0x13, 0x49, 0x00,
+	0x00, 0x36, 0x00,
+	0x15, 0xC1, 0x10,
+	0x6A, 0x3E, 0xF0,
+	0x00, 0x37, 0x00,
+	0x78, 0x78, 0x80,
+	0x07, 0x87, 0x80,
+	0x20, 0x00, 0x00,
+	0x06, 0x66, 0x60,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x02, 0x33, 0x00,
+	0x01, 0x50, 0x10,
+	0x00, 0x00, 0x20,
+	0x01, 0x50, 0x30,
+	0x03, 0x00, 0x40,
+	0x04, 0x50, 0x50,
+	0x06, 0x00, 0x60,
+	0x07, 0x50, 0x70,
+	0x09, 0x00, 0x80,
+	0x10, 0x50, 0x90,
+	0x12, 0x00, 0xA0,
+	0x13, 0x50, 0xB0,
+	0x15, 0x00, 0xC0,
+	0x16, 0x50, 0xD0,
+	0x18, 0x00, 0xD0,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x14, 0x00,
+	0xF0, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0xFF, 0x87, 0x50,
+	0xFE, 0x8C, 0x50,
+	0xFD, 0xE9, 0x70,
+	0x00, 0x00, 0x00,
+	0x06, 0xD8, 0xD0,
+	0x11, 0x8D, 0x30,
+	0x1B, 0xAE, 0x90,
+	0x1F, 0xDC, 0xD0,
+	0x1B, 0xAE, 0x90,
+	0x11, 0x8D, 0x30,
+	0x06, 0xD8, 0xD0,
+	0x00, 0x00, 0x00,
+	0xFD, 0xE9, 0x70,
+	0xFE, 0x8C, 0x50,
+	0xFF, 0x87, 0x50,
+	0x00, 0x00, 0x00,
+	0x00, 0x18, 0x00,
+	0x07, 0x87, 0x80,
+	0x78, 0x78, 0x80,
+	0x00, 0x19, 0x00,
+	0x45, 0xD9, 0xB0,
+	0x3A, 0x26, 0x50,
+	0x00, 0x1A, 0x00,
+	0x05, 0x4A, 0x20,
+	0x7A, 0xB5, 0xE0,
+	0x00, 0x1D, 0x00,
+	0x52, 0xF8, 0x20,
+	0x2D, 0x07, 0xE0,
+	0x00, 0x20, 0x00,
+	0x43, 0xC3, 0xC0,
+	0x3C, 0x3C, 0x40,
+	0x00, 0x24, 0x00,
+	0x72, 0xE1, 0xA0,
+	0x0D, 0x1E, 0x60,
+	0x00, 0x28, 0x00,
+	0x7F, 0xFF, 0xF0,
+	0x00, 0x00, 0x00,
+	0x00, 0x2B, 0x00,
+	0x0D, 0x1E, 0x60,
+	0x72, 0xE1, 0xA0,
+	0x00, 0x2F, 0x00,
+	0x3C, 0x3C, 0x40,
+	0x43, 0xC3, 0xC0,
+	0x00, 0x32, 0x00,
+	0x2D, 0x07, 0xE0,
+	0x52, 0xF8, 0x20,
+	0x00, 0x35, 0x00,
+	0x7A, 0xB5, 0xE0,
+	0x05, 0x4A, 0x20,
+	0x00, 0x36, 0x00,
+	0x3A, 0x26, 0x50,
+	0x45, 0xD9, 0xB0,
+	0x00, 0x37, 0x00,
+	0x78, 0x78, 0x80,
+	0x07, 0x87, 0x80,
+	0x20, 0x00, 0x00,
+	0x06, 0x66, 0x60,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0xC9, 0x10,
+	0x02, 0x5B, 0x20,
+	0x03, 0xED, 0x20,
+	0x05, 0x7F, 0x00,
+	0x07, 0x10, 0xA0,
+	0x08, 0xA2, 0x00,
+	0x0A, 0x33, 0x10,
+	0x0B, 0xC3, 0xB0,
+	0x0D, 0x53, 0xE0,
+	0x0E, 0xE3, 0x80,
+	0x10, 0x72, 0xA0,
+	0x12, 0x01, 0x10,
+	0x13, 0x8E, 0xE0,
+	0x15, 0x1B, 0xE0,
+	0x16, 0xA8, 0x10,
+	0x18, 0x33, 0x60,
+	0x19, 0xBD, 0xD0,
+	0x1B, 0x47, 0x30,
+	0x1C, 0xCF, 0x90,
+	0x1E, 0x56, 0xD0,
+	0x1F, 0xDC, 0xE0,
+	0x21, 0x61, 0xB0,
+	0x22, 0xE5, 0x40,
+	0x24, 0x67, 0x70,
+	0x25, 0xE8, 0x40,
+	0x27, 0x67, 0xA0,
+	0x28, 0xE5, 0x70,
+	0x2A, 0x61, 0xB0,
+	0x2B, 0xDC, 0x50,
+	0x2D, 0x55, 0x40,
+	0x2E, 0xCC, 0x70,
+	0x30, 0x41, 0xC0,
+	0x31, 0xB5, 0x50,
+	0x33, 0x26, 0xE0,
+	0x34, 0x96, 0x80,
+	0x36, 0x04, 0x20,
+	0x37, 0x6F, 0xA0,
+	0x38, 0xD9, 0x00,
+	0x3A, 0x40, 0x30,
+	0x3B, 0xA5, 0x20,
+	0x3D, 0x07, 0xC0,
+	0x3E, 0x68, 0x10,
+	0x3F, 0xC5, 0xF0,
+	0x41, 0x21, 0x60,
+	0x42, 0x7A, 0x40,
+	0x43, 0xD0, 0xA0,
+	0x45, 0x24, 0x50,
+	0x46, 0x75, 0x70,
+	0x47, 0xC3, 0xC0,
+	0x49, 0x0F, 0x50,
+	0x4A, 0x58, 0x20,
+	0x4B, 0x9E, 0x00,
+	0x4C, 0xE1, 0x00,
+	0x4E, 0x21, 0x00,
+	0x4F, 0x5E, 0x10,
+	0x50, 0x98, 0x00,
+	0x51, 0xCE, 0xD0,
+	0x53, 0x02, 0x80,
+	0x54, 0x33, 0x00,
+	0x55, 0x60, 0x40,
+	0x56, 0x8A, 0x30,
+	0x57, 0xB0, 0xD0,
+	0x58, 0xD4, 0x10,
+	0x59, 0xF3, 0xE0,
+	0x5B, 0x10, 0x30,
+	0x5C, 0x29, 0x10,
+	0x5D, 0x3E, 0x50,
+	0x5E, 0x50, 0x00,
+	0x5F, 0x5E, 0x10,
+	0x60, 0x68, 0x70,
+	0x61, 0x6F, 0x10,
+	0x62, 0x72, 0x00,
+	0x63, 0x71, 0x10,
+	0x64, 0x6C, 0x60,
+	0x65, 0x63, 0xC0,
+	0x66, 0x57, 0x40,
+	0x67, 0x46, 0xC0,
+	0x68, 0x32, 0x50,
+	0x69, 0x19, 0xE0,
+	0x69, 0xFD, 0x60,
+	0x6A, 0xDC, 0xD0,
+	0x6B, 0xB8, 0x10,
+	0x6C, 0x8F, 0x30,
+	0x6D, 0x62, 0x20,
+	0x6E, 0x30, 0xE0,
+	0x6E, 0xFB, 0x60,
+	0x6F, 0xC1, 0x90,
+	0x70, 0x83, 0x80,
+	0x71, 0x41, 0x10,
+	0x71, 0xFA, 0x40,
+	0x72, 0xAF, 0x00,
+	0x73, 0x5F, 0x60,
+	0x74, 0x0B, 0x50,
+	0x74, 0xB2, 0xD0,
+	0x75, 0x55, 0xC0,
+	0x75, 0xF4, 0x30,
+	0x76, 0x8E, 0x10,
+	0x77, 0x23, 0x60,
+	0x77, 0xB4, 0x10,
+	0x78, 0x40, 0x30,
+	0x78, 0xC7, 0xB0,
+	0x79, 0x4A, 0x80,
+	0x79, 0xC8, 0xA0,
+	0x7A, 0x42, 0x10,
+	0x7A, 0xB6, 0xD0,
+	0x7B, 0x26, 0xD0,
+	0x7B, 0x92, 0x10,
+	0x7B, 0xF8, 0x90,
+	0x7C, 0x5A, 0x40,
+	0x7C, 0xB7, 0x20,
+	0x7D, 0x0F, 0x40,
+	0x7D, 0x62, 0x90,
+	0x7D, 0xB1, 0x00,
+	0x7D, 0xFA, 0xA0,
+	0x7E, 0x3F, 0x50,
+	0x7E, 0x7F, 0x40,
+	0x7E, 0xBA, 0x40,
+	0x7E, 0xF0, 0x60,
+	0x7F, 0x21, 0x90,
+	0x7F, 0x4D, 0xE0,
+	0x7F, 0x75, 0x50,
+	0x7F, 0x97, 0xD0,
+	0x7F, 0xB5, 0x60,
+	0x7F, 0xCE, 0x10,
+	0x7F, 0xE1, 0xC0,
+	0x7F, 0xF0, 0x90,
+	0x7F, 0xFA, 0x70,
+	0x7F, 0xFF, 0x60,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x03, 0x00,
+	0x03, 0x46, 0xE0,
+	0x00, 0xBE, 0x00,
+	0x02, 0x0C, 0x50,
+	0x20, 0x00, 0x00,
+	0x14, 0x00, 0x00,
+	0x00, 0x0C, 0x00,
+	0x0C, 0xCC, 0xD0,
+	0x00, 0x51, 0xF0,
+	0x04, 0x00, 0x00,
+	0x00, 0x41, 0x90,
+	0x01, 0x47, 0xB0,
+	0x7E, 0xB8, 0x50,
+	0x7B, 0xC0, 0x00,
+	0x38, 0x00, 0x00,
+	0x0C, 0xCC, 0xD0,
+	0x01, 0x47, 0xB0,
+	0x06, 0x66, 0x60,
+	0x06, 0x66, 0x60,
+	0xF5, 0xFF, 0xF0,
+	0x20, 0x00, 0x00,
+	0x00, 0x28, 0xF0,
+	0x00, 0x28, 0x00,
+	0x01, 0x47, 0xB0,
+	0x0F, 0x5C, 0x30,
+	0x00, 0x51, 0xF0,
+	0xF7, 0x45, 0xD0,
+	0x00, 0x00, 0x00,
+	0x00, 0x28, 0xF0,
+	0x00, 0x16, 0x00,
+	0x01, 0x47, 0xB0,
+	0x0C, 0xCC, 0xD0,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x28, 0xF0,
+	0x00, 0x42, 0x00,
+	0x2B, 0x85, 0x20,
+	0x14, 0x7A, 0xE0,
+	0x0C, 0xCC, 0xD0,
+	0x08, 0xF5, 0xC0,
+	0x05, 0x1E, 0xC0,
+	0x02, 0x8F, 0x60,
+	0x08, 0x00, 0x00,
+	0x00, 0x90, 0x00,
+	0x00, 0x00, 0x00,
+	0xC8, 0x00, 0x00,
+	0x5A, 0x9D, 0xF0,
+	0x06, 0x66, 0x00,
+	0x13, 0x33, 0x00,
+	0x13, 0x33, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x0D, 0x1B, 0x40,
+	0x1A, 0x36, 0x80,
+	0xC9, 0xD2, 0x70,
+	0x75, 0x5B, 0xE0,
+	0x0D, 0x1B, 0x40,
+	0x0D, 0x1B, 0x40,
+	0x1A, 0x36, 0x80,
+	0xC9, 0xD2, 0x70,
+	0x75, 0x5B, 0xE0,
+	0x0D, 0x1B, 0x40,
+	0x3C, 0x8A, 0xE0,
+	0x86, 0xEA, 0x40,
+	0xC6, 0xBA, 0x60,
+	0x78, 0xE5, 0xF0,
+	0x3C, 0x8A, 0xE0,
+	0x18, 0xFE, 0x60,
+	0x0C, 0x7F, 0x30,
+	0xEA, 0xAA, 0xB0,
+	0x3C, 0x57, 0x00,
+	0x18, 0xFE, 0x60,
+	0x00, 0x80, 0x00,
+	0x02, 0x80, 0x00,
+	0x01, 0x40, 0x00,
+	0x00, 0x00, 0x00,
+	0x12, 0xC8, 0x10,
+	0x11, 0x0F, 0x70,
+	0x7F, 0xFE, 0x00,
+	0x6E, 0x77, 0xF0,
+	0x80, 0x01, 0x00,
+	0x11, 0x88, 0x20,
+	0x80, 0x00, 0x00,
+	0x7F, 0xFD, 0x00,
+	0x5C, 0xEF, 0xE0,
+	0x7F, 0xFE, 0x00,
+	0x6E, 0x77, 0xF0,
+	0x7F, 0xFE, 0x00,
+	0x6E, 0x77, 0xF0,
+	0x80, 0x01, 0x00,
+	0x11, 0x88, 0x20,
+	0x80, 0x00, 0x00,
+	0x7F, 0xFD, 0x00,
+	0x5C, 0xEF, 0xE0,
+	0x7F, 0xFE, 0x00,
+	0x6E, 0x77, 0xF0,
+	0x7F, 0xFE, 0x00,
+	0x6E, 0x77, 0xF0,
+	0x80, 0x01, 0x00,
+	0x11, 0x88, 0x20,
+	0x80, 0x00, 0x00,
+	0x7F, 0xFD, 0x00,
+	0x5C, 0xEF, 0xE0,
+	0x7F, 0xFE, 0x00,
+	0x6E, 0x77, 0xF0,
+	0x7F, 0xFE, 0x00,
+	0x6E, 0x77, 0xF0,
+	0x80, 0x01, 0x00,
+	0x11, 0x88, 0x20,
+	0x80, 0x00, 0x00,
+	0x7F, 0xFD, 0x00,
+	0x5C, 0xEF, 0xE0,
+	0x7F, 0xFE, 0x00,
+	0x6E, 0x77, 0xF0,
+	0x03, 0x04, 0x10,
+	0x7D, 0x0D, 0xB0,
+	0x03, 0x04, 0x10,
+	0x7D, 0x0D, 0xB0,
+	0x03, 0x04, 0x10,
+	0x7D, 0x0D, 0xB0,
+	0x03, 0x04, 0x10,
+	0x7D, 0x0D, 0xB0,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x06, 0x00,
+	0xFE, 0x80, 0x00,
+	0x0A, 0x80, 0x00,
+	0xDD, 0x00, 0x00,
+	0x68, 0xFF, 0x80,
+	0x34, 0x7F, 0x00,
+	0xFC, 0x80, 0x80,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x3F, 0xF0,
+	0x08, 0x5F, 0xB0,
+	0xEA, 0x91, 0x40,
+	0xF7, 0xA0, 0x50,
+	0x55, 0x2E, 0xD0,
+	0x00, 0x00, 0x00,
+	0x00, 0x51, 0x20,
+	0xF8, 0x3B, 0xA0,
+	0x19, 0x90, 0xF0,
+	0x5C, 0x00, 0x00,
+	0x19, 0x90, 0xF0,
+	0xF8, 0x3B, 0xA0,
+	0x00, 0x51, 0x20,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0xFF, 0xFE, 0x40,
+	0x00, 0x00, 0x00,
+	0x00, 0x0A, 0x30,
+	0x00, 0x00, 0x00,
+	0xFF, 0xE5, 0x50,
+	0x00, 0x00, 0x00,
+	0x00, 0x34, 0x70,
+	0x00, 0x00, 0x00,
+	0xFF, 0xA6, 0xF0,
+	0x00, 0x00, 0x00,
+	0x00, 0x8A, 0x40,
+	0x00, 0x00, 0x00,
+	0xFF, 0x35, 0xA0,
+	0x00, 0x00, 0x00,
+	0x01, 0x1C, 0x90,
+	0x00, 0x00, 0x00,
+	0xFE, 0x7A, 0x70,
+	0x00, 0x00, 0x00,
+	0x02, 0x0D, 0x20,
+	0x00, 0x00, 0x00,
+	0xFD, 0x3F, 0x80,
+	0x00, 0x00, 0x00,
+	0x03, 0xB9, 0x20,
+	0x00, 0x00, 0x00,
+	0xFA, 0xD2, 0x20,
+	0x00, 0x00, 0x00,
+	0x07, 0xAE, 0xA0,
+	0x00, 0x00, 0x00,
+	0xF2, 0xB3, 0xD0,
+	0x00, 0x00, 0x00,
+	0x28, 0xA6, 0x10,
+	0x40, 0x00, 0x00,
+	0x28, 0xA6, 0x10,
+	0x00, 0x00, 0x00,
+	0xF2, 0xB3, 0xD0,
+	0x00, 0x00, 0x00,
+	0x07, 0xAE, 0xA0,
+	0x00, 0x00, 0x00,
+	0xFA, 0xD2, 0x20,
+	0x00, 0x00, 0x00,
+	0x03, 0xB9, 0x20,
+	0x00, 0x00, 0x00,
+	0xFD, 0x3F, 0x80,
+	0x00, 0x00, 0x00,
+	0x02, 0x0D, 0x20,
+	0x00, 0x00, 0x00,
+	0xFE, 0x7A, 0x70,
+	0x00, 0x00, 0x00,
+	0x01, 0x1C, 0x90,
+	0x00, 0x00, 0x00,
+	0xFF, 0x35, 0xA0,
+	0x00, 0x00, 0x00,
+	0x00, 0x8A, 0x40,
+	0x00, 0x00, 0x00,
+	0xFF, 0xA6, 0xF0,
+	0x00, 0x00, 0x00,
+	0x00, 0x34, 0x70,
+	0x00, 0x00, 0x00,
+	0xFF, 0xE5, 0x50,
+	0x00, 0x00, 0x00,
+	0x00, 0x0A, 0x30,
+	0x00, 0x00, 0x00,
+	0xFF, 0xFE, 0x40,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x01, 0x00,
+	0x00, 0x07, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x04, 0x00, 0x00,
+	0x04, 0xFF, 0x00,
+	0x08, 0x40, 0x00,
+	0x0B, 0x40, 0x00,
+	0x7C, 0x00, 0x00,
+	0x04, 0x00, 0x00,
+	0x02, 0x10, 0x00,
+	0x00, 0x00, 0x00,
+	0x02, 0x00, 0x00,
+	0x08, 0x00, 0x00,
+	0x9E, 0xDD, 0xA0,
+	0x0C, 0x67, 0x50,
+	0x40, 0x00, 0x00,
+	0x00, 0x10, 0x60,
+	0x7F, 0xEF, 0xA0,
+	0x00, 0x00, 0x00,
+	0x00, 0x01, 0x00,
+	0x00, 0x01, 0x00,
+	0x00, 0x12, 0x00,
+	0x00, 0x10, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x05, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x80, 0x00,
+	0x00, 0xB5, 0x00,
+	0x00, 0xCB, 0x00,
+	0x00, 0x40, 0x00,
+	0x00, 0x80, 0x00,
+	0x00, 0x00, 0x00,
+	0x08, 0x00, 0x00,
+	0x07, 0xED, 0x00,
+	0x00, 0x80, 0x00,
+	0x08, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0xB1, 0x00,
+	0x01, 0x02, 0x00,
+	0x05, 0x7F, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x51, 0x00,
+	0x01, 0xDF, 0x00,
+	0x7F, 0xFF, 0xF0,
+	0xF0, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x7E, 0x00, 0x00,
+	0x02, 0x00, 0x00,
+	0x01, 0x4A, 0xA0,
+	0x06, 0x57, 0xF0,
+	0x06, 0x57, 0xF0,
+	0x00, 0x04, 0x00,
+	0x7F, 0xF0, 0x00,
+	0x00, 0x10, 0x00,
+	0x1D, 0x9A, 0x50,
+	0xF9, 0xA8, 0x10,
+	0x00, 0x56, 0x00,
+	0x01, 0xE0, 0x00,
+	0x7F, 0xFF, 0xF0,
+	0xF0, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x7E, 0x00, 0x00,
+	0x02, 0x00, 0x00,
+	0x01, 0x4A, 0xA0,
+	0x06, 0x57, 0xF0,
+	0x06, 0x57, 0xF0,
+	0x00, 0x04, 0x00,
+	0x7F, 0xF0, 0x00,
+	0x00, 0x10, 0x00,
+	0x1D, 0x9A, 0x50,
+	0xF9, 0xA8, 0x10,
+	0x40, 0x3B, 0x00,
+	0x3F, 0xFC, 0x30,
+	0x10, 0x00, 0x00,
+	0x7F, 0xFF, 0xF0,
+	0x01, 0x00, 0x00,
+	0x3A, 0xE2, 0x60,
+	0x8A, 0x3B, 0x40,
+	0xC9, 0xD2, 0x70,
+	0x75, 0x5B, 0xE0,
+	0x3A, 0xE2, 0x60,
+	0x7C, 0x00, 0x00,
+	0x04, 0x00, 0x00,
+	0x7F, 0xC0, 0x00,
+	0x00, 0x40, 0x00,
+	0x7C, 0x00, 0x00,
+	0x04, 0x00, 0x00,
+	0x08, 0x00, 0x00,
+	0x40, 0x00, 0x30,
+	0x20, 0x00, 0x00,
+	0x7F, 0xC0, 0x00,
+	0x00, 0x40, 0x00,
+	0x05, 0xA3, 0x00,
+	0x00, 0x14, 0xE0,
+	0x00, 0x50, 0x00,
+	0x0A, 0x06, 0x10,
+	0x7C, 0x00, 0x00,
+	0x04, 0x00, 0x00,
+	0x20, 0x00, 0x00,
+	0x60, 0x00, 0x00,
+	0x5A, 0x9D, 0xF0,
+	0x03, 0x2B, 0xF0,
+	0x3C, 0x6B, 0x80,
+	0x3F, 0xA1, 0xF0,
+	0x40, 0x01, 0xE0,
+	0x02, 0x00, 0x00,
+	0x0A, 0x06, 0x10,
+	0x3F, 0xFF, 0x10,
+	0x40, 0x5E, 0x90,
+	0x50, 0xC3, 0x30,
+	0x00, 0x50, 0x00,
+	0x03, 0xFD, 0x90,
+	0x7C, 0x00, 0x00,
+	0x04, 0x00, 0x00,
+	0x20, 0x00, 0x00,
+	0x60, 0x00, 0x00,
+	0x20, 0x26, 0xF0,
+	0x03, 0x2B, 0xF0,
+	0x3C, 0x6B, 0x80,
+	0x3F, 0xA1, 0xF0,
+	0x40, 0x01, 0xE0,
+	0x02, 0x00, 0x00,
+	0x03, 0xFD, 0x90,
+	0x3F, 0xFF, 0x10,
+	0x40, 0x5E, 0x90,
+	0x50, 0xC3, 0x30,
+	0x00, 0x00, 0x00,
+	0x00, 0x01, 0x00,
+	0x00, 0x09, 0x00,
+	0x00, 0x07, 0x00, /* 0x00, 0x08, 0x00, 0x08=Right, 0x07=Left */
+	0x00, 0x00, 0x00,
+	0x00, 0x01, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x35, 0x3B, 0xA4,
+	0x87, 0x08, 0xCA,
+	0xDB, 0x3A, 0xA2,
+	0x54, 0x6B, 0xA7,
+	0x4C, 0x10, 0x6B,
+	0x35, 0x3B, 0xA4,
+	0x87, 0x08, 0xCA,
+	0xDB, 0x3A, 0xA2,
+	0x54, 0x6B, 0xA7,
+	0x4C, 0x10, 0x6B,
+	0x3E, 0x1D, 0xB7,
+	0x83, 0xC4, 0x91,
+	0xC3, 0xA8, 0xF6,
+	0x7C, 0x1F, 0xD5,
+	0x3E, 0x1D, 0xB7,
+	0x25, 0xE3, 0x8C,
+	0xA9, 0x24, 0x30,
+	0xCF, 0x83, 0x1F,
+	0x6E, 0x64, 0xB3,
+	0x39, 0x0A, 0x41,
+	0x3A, 0xD6, 0xA1,
+	0x8A, 0x52, 0xBE,
+	0xC9, 0xE9, 0xF9,
+	0x75, 0x44, 0x7D,
+	0x3A, 0xD6, 0xA1,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x0E, 0x7D, 0xA0,
+	0x0E, 0x7D, 0xA0,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x80, 0x00,
+	0x00, 0x06, 0x00,
+	0x33, 0x33, 0x30,
+	0x01, 0x47, 0xB0,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x01, 0xEB, 0x80,
+	0x14, 0x00, 0x00,
+	0xC0, 0x00, 0x00,
+	0x10, 0x00, 0x00,
+	0x02, 0x00, 0x00,
+	0x19, 0x99, 0xA0,
+	0x00, 0x00, 0x00,
+	0x74, 0x7A, 0xE0,
+	0x40, 0x00, 0x00,
+	0x05, 0x1E, 0xC0,
+	0x02, 0x8F, 0x60,
+	0x05, 0x1E, 0xC0,
+	0x02, 0x8F, 0x60,
+	0x1C, 0xA7, 0xD0,
+	0x1C, 0xA7, 0xD0,
+	0x1C, 0xA7, 0xD0,
+	0x1C, 0xA7, 0xD0,
+	0x1C, 0xA7, 0xD0,
+	0x1C, 0xA7, 0xD0,
+	0x40, 0x26, 0xE0,
+	0x40, 0x26, 0xE0,
+	0x40, 0x26, 0xE0,
+	0x40, 0x26, 0xE0,
+	0x40, 0x26, 0xE0,
+	0x40, 0x26, 0xE0,
+	0x00, 0x08, 0x00,
+	0x00, 0x10, 0x00,
+	0x00, 0x28, 0x00,
+	0x00, 0x40, 0x00,
+	0x00, 0x58, 0x00,
+	0x00, 0x7F, 0x00,
+	0x00, 0x80, 0x00,
+	0x00, 0x06, 0x00,
+	0x33, 0x33, 0x30,
+	0x01, 0x47, 0xB0,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x01, 0xEB, 0x80,
+	0x14, 0x00, 0x00,
+	0xC0, 0x00, 0x00,
+	0x10, 0x00, 0x00,
+	0x02, 0x00, 0x00,
+	0x19, 0x99, 0xA0,
+	0x00, 0x00, 0x00,
+	0x74, 0x7A, 0xE0,
+	0x40, 0x00, 0x00,
+	0x05, 0x1E, 0xC0,
+	0x02, 0x8F, 0x60,
+	0x05, 0x1E, 0xC0,
+	0x02, 0x8F, 0x60,
+	0x1C, 0xA7, 0xD0,
+	0x1C, 0xA7, 0xD0,
+	0x1C, 0xA7, 0xD0,
+	0x1C, 0xA7, 0xD0,
+	0x1C, 0xA7, 0xD0,
+	0x1C, 0xA7, 0xD0,
+	0x40, 0x26, 0xE0,
+	0x40, 0x26, 0xE0,
+	0x40, 0x26, 0xE0,
+	0x40, 0x26, 0xE0,
+	0x40, 0x26, 0xE0,
+	0x40, 0x26, 0xE0,
+	0x00, 0x08, 0x00,
+	0x00, 0x10, 0x00,
+	0x00, 0x28, 0x00,
+	0x00, 0x40, 0x00,
+	0x00, 0x58, 0x00,
+	0x00, 0x7F, 0x00,
+	0x00, 0x00, 0x00,
+	0x0B, 0xFF, 0x00,
+	0x02, 0x80, 0x00,
+	0xB0, 0x00, 0x00,
+	0x00, 0x84, 0x00,
+	0x7F, 0xFF, 0x00,
+	0xF0, 0x00, 0x00,
+	0x40, 0x00, 0x00,
+	0x00, 0x01, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x3C, 0x00,
+	0x16, 0x98, 0x00,
+	0x00, 0x46, 0x00,
+	0x16, 0x98, 0x00,
+	0x00, 0x46, 0x00,
+	0x16, 0x98, 0x00,
+	0x00, 0x0A, 0x00,
+	0x16, 0x98, 0x00,
+	0x50, 0xC8, 0x00,
+	0x20, 0x0F, 0x00,
+	0x50, 0xC8, 0x00,
+	0x20, 0x0F, 0x00,
+	0x30, 0x1E, 0x00,
+	0x20, 0x00, 0x00,
+	0x50, 0xC8, 0x00,
+	0x20, 0x0A, 0x00,
+	0x30, 0x3C, 0x00,
+	0x16, 0x8C, 0x00,
+	0x06, 0x18, 0x00,
+	0x16, 0x98, 0x00,
+	0x00, 0x06, 0x00,
+	0x16, 0xC0, 0x00,
+	0x00, 0x3C, 0x00,
+	0x17, 0x58, 0x00,
+	0x00, 0x64, 0x00,
+	0x1F, 0x58, 0x00,
+	0x00, 0x50, 0x00,
+	0x17, 0x58, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x08, 0x00,
+	0x00, 0x02, 0x10,
+	0x07, 0xEB, 0x80,
+	0x04, 0x02, 0x70,
+	0x03, 0xE8, 0x00,
+	0x00, 0x01, 0x00,
+	0x14, 0x49, 0x61,
+	0x00, 0x00, 0x00,
+	0x00, 0x80, 0x00,
+	0x00, 0xA1, 0x24,
+	0x00, 0xCA, 0xDE,
+	0x00, 0xFF, 0x65,
+	0x01, 0x41, 0x85,
+	0x01, 0x94, 0xC6,
+	0x01, 0xFD, 0x94,
+	0x02, 0x81, 0x85,
+	0x03, 0x27, 0xA0,
+	0x03, 0xF8, 0xBD,
+	0x05, 0x9C, 0x2F,
+	0x07, 0xEC, 0xAA,
+	0x0B, 0x31, 0x90,
+	0x0F, 0xCF, 0xB7,
+	0x16, 0x55, 0x8D,
+	0x1F, 0x8C, 0x41,
+	0x7F, 0xFF, 0xFF,
+	0x65, 0xAC, 0x8C,
+	0x47, 0xFA, 0xCD,
+	0x32, 0xF5, 0x2D,
+	0x24, 0x13, 0x47,
+	0x19, 0x8A, 0x13,
+	0x12, 0x14, 0x9A,
+	0x0C, 0xCC, 0xCD,
+	0x7F, 0xFF, 0xFF,
+	0x7F, 0xFF, 0xFF,
+	0x7F, 0xFF, 0xFF,
+	0x7F, 0xFF, 0xFF,
+	0x7F, 0xFF, 0xFF,
+	0x7F, 0xFF, 0xFF,
+	0x7F, 0xFF, 0xFF,
+	0x7F, 0xFF, 0xFF,
+	0x03, 0xFF, 0x00,
+	0x00, 0x00, 0x00,
+	0x02, 0x02, 0x70,
+	0x02, 0xD6, 0xB0,
+	0x04, 0x02, 0x70,
+	0x05, 0xA9, 0xE0,
+	0x08, 0x00, 0x00,
+	0x0B, 0x4C, 0xE0,
+	0x0F, 0xF6, 0x50,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00,
+	0x21, 0x87, 0x00,
+	0x00, 0x00, 0x00,
+	0x21, 0x2F, 0x00,
+	0x40, 0x00, 0x00,
+	0x7F, 0x8A, 0xD0,
+	0xAA, 0xD1, 0xB0,
+	0xD5, 0xA3, 0x70,
+	0x65, 0xD8, 0x00,
+	0xF8, 0x00, 0x00,
+	0x60, 0x00, 0x00,
+	0x6E, 0xD9, 0xF0,
+	0x49, 0xE6, 0xA0,
+	0xE7, 0x5D, 0xD0,
+	0x10, 0x6C, 0x20,
+	0xF2, 0x50, 0x90,
+	0x0C, 0xC5, 0xE0,
+	0xF3, 0x3A, 0x20,
+	0x08, 0x00, 0x00,
+	0x5A, 0x82, 0x80,
+	0x00, 0x00, 0x00,
+	0x05, 0x05, 0x00,
+	0x07, 0x1B, 0x00,
+	0x08, 0xB5, 0x00,
+	0x0A, 0x11, 0x00,
+	0x0B, 0x44, 0x00,
+	0x0C, 0x5A, 0x00,
+	0x0D, 0x5B, 0x00,
+	0x0E, 0x4A, 0x00,
+	0x0F, 0x2C, 0x00,
+	0x10, 0x02, 0x00,
+	0x10, 0xCE, 0x00,
+	0x11, 0x91, 0x00,
+	0x12, 0x4E, 0x00,
+	0x13, 0x03, 0x00,
+	0x13, 0xB3, 0x00,
+	0x14, 0x5D, 0x00,
+	0x15, 0x02, 0x00,
+	0x15, 0xA3, 0x00,
+	0x16, 0x41, 0x00,
+	0x16, 0xDA, 0x00,
+	0x17, 0x70, 0x00,
+	0x18, 0x03, 0x00,
+	0x18, 0x93, 0x00,
+	0x19, 0x20, 0x00,
+	0x19, 0xAB, 0x00,
+	0x1A, 0x33, 0x00,
+	0x1A, 0xB9, 0x00,
+	0x1B, 0x3D, 0x00,
+	0x1B, 0xBF, 0x00,
+	0x1C, 0x3F, 0x00,
+	0x1C, 0xBD, 0x00,
+	0x1D, 0x39, 0x00,
+	0x1D, 0xB4, 0x00,
+	0x1E, 0x2E, 0x00,
+	0x1E, 0xA5, 0x00,
+	0x1F, 0x1C, 0x00,
+	0x1F, 0x91, 0x00,
+	0x20, 0x05, 0x00,
+	0x20, 0x77, 0x00,
+	0x20, 0xE8, 0x00,
+	0x21, 0x59, 0x00,
+	0x21, 0xC8, 0x00,
+	0x22, 0x36, 0x00,
+	0x22, 0xA3, 0x00,
+	0x23, 0x0F, 0x00,
+	0x23, 0x7A, 0x00,
+	0x23, 0xE4, 0x00,
+	0x24, 0x4D, 0x00,
+	0x24, 0xB6, 0x00,
+	0x25, 0x1D, 0x00,
+	0x25, 0x84, 0x00,
+	0x25, 0xEA, 0x00,
+	0x26, 0x50, 0x00,
+	0x26, 0xB4, 0x00,
+	0x27, 0x18, 0x00,
+	0x27, 0x7B, 0x00,
+	0x27, 0xDE, 0x00,
+	0x28, 0x3F, 0x00,
+	0x28, 0xA1, 0x00,
+	0x29, 0x01, 0x00,
+	0x29, 0x61, 0x00,
+	0x29, 0xC1, 0x00,
+	0x2A, 0x1F, 0x00,
+	0x00, 0x01, 0x00,
+	0x00, 0x0E, 0x00,
+	0x20, 0x16, 0x00,
+	0x10, 0x17, 0x00,
+	0x01, 0x03, 0x00,
+};
+
+
+static u8 ak7755_ofreg_basic[]= {
+	0xB2,0x00,0x00,    // OFREG Write Command
+    0x00, 0x00, 0x00,  // 0x000
+    0x00, 0x00, 0x00,  // 0x001
+    0x00, 0x00, 0x00,  // 0x002
+    0x00, 0x00, 0x00,  // 0x003
+    0x00, 0x00, 0x00,  // 0x004
+    0x00, 0x00, 0x00,  // 0x005
+    0x00, 0x00, 0x00,  // 0x006
+    0x00, 0x00, 0x00,  // 0x007
+};
+
+static u8 ak7755_acram_basic[]= {
+	0xBB,0x00,0x00,    // ACRAM Write Command
+    0x00, 0x00, 0x00,  // 0x000
+    0x00, 0x00, 0x00,  // 0x001
+    0x00, 0x00, 0x00,  // 0x002
+    0x00, 0x00, 0x00,  // 0x003
+    0x00, 0x00, 0x00,  // 0x004
+    0x00, 0x00, 0x00,  // 0x005
+    0x00, 0x00, 0x00,  // 0x006
+    0x00, 0x00, 0x00,  // 0x007
+};
+
+
diff --git a/sound/soc/codecs/ak7755ctl.h b/sound/soc/codecs/ak7755ctl.h
new file mode 100644
index 0000000..dd5e524
--- /dev/null
+++ b/sound/soc/codecs/ak7755ctl.h
@@ -0,0 +1,75 @@
+ /* ak7755ioctrl.h
+ *
+ * Copyright (C) 2014 Asahi Kasei Microdevices Corporation.
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *      14/04/09	     1.0
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __DSP_AK7755_H__
+#define __DSP_AK7755_H__
+
+/* IO CONTROL definition of AK7755 */
+#define AK7755_IOCTL_MAGIC     's'
+
+#define AK7755_MAGIC	0xD0
+#define MAX_WREG		32
+#define MAX_WCRAM		48
+
+enum ak7755_ram_type {
+	RAMTYPE_PRAM = 0,
+	RAMTYPE_CRAM,
+	RAMTYPE_OFREG,
+	RAMTYPE_ACRAM,
+};
+
+
+enum ak7755_status {
+	POWERDOWN = 0,
+	SUSPEND,
+	STANDBY,
+	DOWNLOAD,
+	RUN,
+};
+
+typedef struct _REG_CMD {
+	unsigned char addr;
+	unsigned char data;
+} REG_CMD;
+
+struct ak7755_wreg_handle {
+	REG_CMD *regcmd;
+	int len;
+};
+
+struct ak7755_wcram_handle{
+	int    addr;
+	unsigned char *cram;
+	int    len;
+};
+
+struct ak7755_loadram_handle {
+	int ramtype;
+	int mode;
+};
+
+#define AK7755_IOCTL_SETSTATUS	_IOW(AK7755_MAGIC, 0x10, int)
+#define AK7755_IOCTL_GETSTATUS	_IOR(AK7755_MAGIC, 0x11, int)
+#define AK7755_IOCTL_SETMIR		_IOW(AK7755_MAGIC, 0x12, int)
+#define AK7755_IOCTL_GETMIR		_IOR(AK7755_MAGIC, 0x13, unsigned long)
+#define AK7755_IOCTL_WRITEREG	_IOW(AK7755_MAGIC, 0x14, struct ak7755_wreg_handle)
+#define AK7755_IOCTL_WRITECRAM	_IOW(AK7755_MAGIC, 0x15, struct ak7755_wcram_handle)
+#define AK7755_IOCTL_LOADRAM	_IOW(AK7755_MAGIC, 0x16, struct ak7755_loadram_handle)
+
+#endif
+
diff --git a/sound/soc/codecs/ambarella_dummy.c b/sound/soc/codecs/ambarella_dummy.c
index f7c4177..4b6e882 100644
--- a/sound/soc/codecs/ambarella_dummy.c
+++ b/sound/soc/codecs/ambarella_dummy.c
@@ -51,7 +51,7 @@ static int ambdummy_set_bias_level(struct snd_soc_codec *codec,
 
 #define AMBDUMMY_RATES SNDRV_PCM_RATE_8000_48000
 
-#define AMBDUMMY_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
+#define AMBDUMMY_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 static struct snd_soc_dai_ops ambdummy_dai_ops = {
 	.digital_mute = ambdummy_mute,
diff --git a/sound/soc/codecs/arizona.c b/sound/soc/codecs/arizona.c
index 663a2a7..56815af 100644
--- a/sound/soc/codecs/arizona.c
+++ b/sound/soc/codecs/arizona.c
@@ -1057,7 +1057,7 @@ static int arizona_hw_params(struct snd_pcm_substream *substream,
 	int chan_limit = arizona->pdata.max_channels_clocked[dai->id - 1];
 	int bclk, lrclk, wl, frame, bclk_target;
 
-	if (params_rate(params) % 8000)
+	if (params_rate(params) % 4000)
 		rates = &arizona_44k1_bclk_rates[0];
 	else
 		rates = &arizona_48k_bclk_rates[0];
diff --git a/sound/soc/codecs/cs4271.c b/sound/soc/codecs/cs4271.c
index 03036b3..ffa4a2d 100644
--- a/sound/soc/codecs/cs4271.c
+++ b/sound/soc/codecs/cs4271.c
@@ -267,7 +267,7 @@ static int cs4271_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct cs4271_private *cs4271 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.enumerated.item[0] = cs4271->deemph;
+	ucontrol->value.integer.value[0] = cs4271->deemph;
 	return 0;
 }
 
@@ -277,7 +277,7 @@ static int cs4271_put_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct cs4271_private *cs4271 = snd_soc_codec_get_drvdata(codec);
 
-	cs4271->deemph = ucontrol->value.enumerated.item[0];
+	cs4271->deemph = ucontrol->value.integer.value[0];
 	return cs4271_set_deemph(codec);
 }
 
diff --git a/sound/soc/codecs/es8374.c b/sound/soc/codecs/es8374.c
new file mode 100644
index 0000000..12897c4
--- /dev/null
+++ b/sound/soc/codecs/es8374.c
@@ -0,0 +1,1564 @@
+/*
+ * es8374.c  --  ES8374 ALSA SoC Audio Codec
+ *
+ * Copyright (C) 2016 Everest Semiconductor Co., Ltd
+ *
+ * Authors:  XianqingZheng(xqzheng@ambarella.com)
+ *
+ * Based on es8374.c by David Yang(yangxiaohua@everest-semi.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+#include <linux/stddef.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <linux/of_gpio.h>
+#include "es8374.h"
+
+//#define ES8374_SPI
+/*
+ * es8374 register cache
+ */
+static struct reg_default  es8374_reg_defaults[] = {
+	{   0x00, 0x03 },
+	{   0x01, 0x03 },
+	{   0x02, 0x00 },
+	{   0x03, 0x20 },
+	{   0x04, 0x00 },
+	{   0x05, 0x11 },
+	{   0x06, 0x01 },
+	{   0x07, 0x00 },
+	{   0x08, 0x20 },
+	{   0x09, 0x80 },
+	{   0x0a, 0x4A },
+	{   0x0b, 0x00 },
+	{   0x0c, 0x00 },
+	{   0x0d, 0x00 },
+	{   0x0e, 0x00 },
+	{   0x0f, 0x00 },
+
+	{   0x10, 0x00 },
+	{   0x11, 0x00 },
+	{   0x12, 0x40 },
+	{   0x13, 0x40 },
+	{   0x14, 0x9C },
+	{   0x15, 0xBE },
+	{   0x16, 0x00 },
+	{   0x17, 0xA0 },
+	{   0x18, 0xFC },
+	{   0x19, 0x00 },
+	{   0x1a, 0x18 },
+	{   0x1b, 0x00 },
+	{   0x1c, 0x10 },
+	{   0x1d, 0x10 },
+	{   0x1e, 0x00 },
+	{   0x1f, 0x08 },
+
+	{   0x20, 0x08 },
+	{   0x21, 0xD4 },
+	{   0x22, 0x00 },
+	{   0x23, 0x00 },
+	{   0x24, 0x18 },
+	{   0x25, 0xC0 },
+	{   0x26, 0x1C },
+	{   0x27, 0x00 },
+	{   0x28, 0xB0 },
+	{   0x29, 0x32 },
+	{   0x2a, 0x03 },
+	{   0x2b, 0x00 },
+	{   0x2c, 0x0D },
+	{   0x2d, 0x06 },
+	{   0x2e, 0x1F },
+	{   0x2f, 0xF7 },
+
+	{   0x30, 0xFD },
+	{   0x31, 0xFF },
+	{   0x32, 0x1F },
+	{   0x33, 0xF7 },
+	{   0x34, 0xFD },
+	{   0x35, 0xFF },
+	{   0x36, 0x04 },
+	{   0x37, 0x01 },
+	{   0x38, 0xC0 },
+	{   0x39, 0x00 },
+	{   0x3a, 0x02 },
+	{   0x3b, 0x17 },
+	{   0x3c, 0xFD },
+	{   0x3d, 0xFF },
+	{   0x3e, 0x07 },
+	{   0x3f, 0xFD },
+
+	{   0x40, 0xFF },
+	{   0x41, 0x00 },
+	{   0x42, 0xFF },
+	{   0x43, 0xBB },
+	{   0x44, 0xFF },
+	{   0x45, 0x00 },
+	{   0x46, 0x00 },
+	{   0x47, 0x00 },
+	{   0x48, 0x00 },
+	{   0x49, 0x00 },
+	{   0x4a, 0x00 },
+	{   0x4b, 0x00 },
+	{   0x4c, 0x00 },
+	{   0x4d, 0x00 },
+	{   0x4e, 0x00 },
+	{   0x4f, 0x00 },
+
+	{   0x50, 0x00 },
+	{   0x51, 0x00 },
+	{   0x52, 0x00 },
+	{   0x53, 0x00 },
+	{   0x54, 0x00 },
+	{   0x55, 0x00 },
+	{   0x56, 0x00 },
+	{   0x57, 0x00 },
+	{   0x58, 0x00 },
+	{   0x59, 0x00 },
+	{   0x5a, 0x00 },
+	{   0x5b, 0x00 },
+	{   0x5c, 0x00 },
+	{   0x5d, 0x00 },
+	{   0x5e, 0x00 },
+	{   0x5f, 0x00 },
+
+	{   0x60, 0x00 },
+	{   0x61, 0x00 },
+	{   0x62, 0x00 },
+	{   0x63, 0x00 },
+	{   0x64, 0x00 },
+	{   0x65, 0x00 },
+	{   0x66, 0x00 },
+	{   0x67, 0x00 },
+	{   0x68, 0x00 },
+	{   0x69, 0x00 },
+	{   0x6a, 0x00 },
+	{   0x6b, 0x00 },
+	{   0x6c, 0x00 },
+	{   0x6d, 0x00 },
+	{   0x6e, 0x00 },
+	{   0x6f, 0x00 },
+
+};
+#if 0
+static u8 es8374_equalizer_src[] = {
+	0x0A, 0x9B, 0x32, 0x03, 0x5C, 0x5D, 0x4B, 0x24, 0x0A, 0x9B,
+	0x32, 0x03, 0x4C, 0x1F, 0x43, 0x05, 0x6D, 0x27, 0x54, 0x06,
+	0x4D, 0xE1, 0x32, 0x02, 0x3E, 0x55, 0x2A, 0x20, 0x4D, 0xE1,
+	0x32, 0x02, 0x2E, 0x17, 0x22, 0x01, 0x9F, 0xE7, 0x43, 0x25,
+	0x4B, 0xD9, 0x21, 0x01, 0xF9, 0xD4, 0x11, 0x21, 0x4B, 0xD9,
+	0x21, 0x01, 0xE9, 0x96, 0x19, 0x00, 0x4C, 0xE7, 0x22, 0x23,
+};
+#endif
+struct sp_config {
+	u8 spc, mmcc, spfs;
+	u32 srate;
+	u8 lrcdiv;
+	u8 sclkdiv;
+};
+
+/* codec private data */
+
+struct	es8374_private {
+	enum snd_soc_control_type control_type;
+	struct spi_device *spi;
+	struct i2c_client *i2c;
+
+	struct snd_soc_codec *codec;
+	struct regmap *regmap;
+	u32 clk_id;
+	u32 mclk;
+
+	/* platform dependant DVDD voltage configuration */
+/*	u8	dvdd_pwr_vol;
+	u8  pll_div;
+*/
+	int pwr_gpio;
+	unsigned int pwr_active;
+  	bool dmic_enable;
+	u8 reg_cache[110];
+};
+
+struct es8374_private *es8374_data;
+
+static bool es8374_volatile_register(struct device *dev,
+			unsigned int reg)
+{
+	if ((reg  < 0x80)) {
+		if((reg != 0x19) && (reg != 0x23)) {
+			return true;
+		} else {
+			return false;
+		}
+	} else {
+			return false;
+	}
+}
+
+static bool es8374_readable_register(struct device *dev,
+			unsigned int reg)
+{
+	if ((reg  < 0x80)) {
+		if((reg != 0x19) && (reg != 0x23)) {
+			return true;
+		} else {
+			return false;
+		}
+	} else {
+			return false;
+	}
+}
+static bool es8374_writable_register(struct device *dev,
+			unsigned int reg)
+{
+	if ((reg  < 0x80)) {
+		if((reg != 0x19) && (reg != 0x23)) {
+			return true;
+		} else {
+			return false;
+		}
+	} else {
+			return false;
+	}
+}
+
+
+/*
+*	Define ADC and DAC Volume
+*/
+static const DECLARE_TLV_DB_SCALE(vdac_tlv, 0, 50, 0);
+static const DECLARE_TLV_DB_SCALE(vadc_tlv, 0, 50, 0);
+/*
+*	Define D2SE MIC BOOST GAIN
+*/
+static const DECLARE_TLV_DB_SCALE(mic_boost_tlv, 0, 1500, 0);
+/*
+*	Define LINE PGA GAIN
+*/
+static const DECLARE_TLV_DB_SCALE(linin_pga_tlv, 0, 300, 0);
+/*
+*	Define dmic boost gain
+*/
+static const DECLARE_TLV_DB_SCALE(dmic_6db_scaleup_tlv, 0, 600, 0);
+/*
+*	Definitiiion ALC noise gate type
+*/
+
+static const char * const ng_type_txt[] = {"Constant PGA Gain",
+	"Mute ADC Output"};
+static const struct soc_enum ng_type =
+SOC_ENUM_SINGLE(ES8374_ALC_NGTH_REG2B, 6, 2, ng_type_txt);
+
+
+static const char * const alc_mode_txt[] = {
+	"ALC Mode",
+	"Limiter Mode"
+};
+
+static const struct soc_enum alc_mode =
+SOC_ENUM_SINGLE(ES8374_ALC_EN_MAX_GAIN_REG26, 5, 2, alc_mode_txt);
+
+/*
+*	Define MONO output gain
+*/
+static const DECLARE_TLV_DB_SCALE(mono_out_gain_tlv, 0, 150, 0);
+/*
+*	Definitiiion dac auto mute type
+*/
+
+static const char * const dac_auto_mute_type_txt[] = {
+	"AUTO MUTE DISABLE",
+	"MONO OUTPUT MUTE",
+	"SPEAKER MUTE",
+	"MONO OUT & SPEAKER MUTE"
+	};
+static const struct soc_enum dac_auto_mute_type =
+SOC_ENUM_SINGLE(ES8374_DAC_CONTROL_REG37, 4, 4, dac_auto_mute_type_txt);
+/*
+*	Definitiiion dac dsm mute type
+*/
+
+static const char * const dac_dsm_mute_type_txt[] = {
+	"DAC DSM UNMUTE",
+	"DAC DSM MUTE",
+	};
+static const struct soc_enum dac_dsm_mute_type =
+SOC_ENUM_SINGLE(ES8374_DAC_CONTROL_REG37, 0, 2, dac_dsm_mute_type_txt);
+
+/*
+ * es8374 Controls
+ */
+static const struct snd_kcontrol_new es8374_snd_controls[] = {
+	/*
+	* controls for capture path
+	*/
+	SOC_SINGLE_TLV("D2SE MIC BOOST GAIN",
+					ES8374_AIN_PWR_SRC_REG21, 2, 1, 0, mic_boost_tlv),
+	SOC_SINGLE_TLV("LIN PGA GAIN",
+					ES8374_AIN_PGA_REG22, 0, 15, 0, linin_pga_tlv),
+	SOC_SINGLE_TLV("DMIC 6DB SCALE UP GAIN",
+					ES8374_ADC_CONTROL_REG24, 7, 1, 0, dmic_6db_scaleup_tlv),
+	SOC_SINGLE("ADC Double FS Mode", ES8374_ADC_CONTROL_REG24, 6, 1, 0),
+	SOC_SINGLE("ADC Soft Ramp", ES8374_ADC_CONTROL_REG24, 4, 1, 0),
+	SOC_SINGLE("ADC MUTE", ES8374_ADC_CONTROL_REG24, 5, 1, 0),
+	SOC_SINGLE("ADC INVERTED", ES8374_ADC_CONTROL_REG24, 2, 1, 0),
+	SOC_SINGLE("ADC HPF COEFFICIENT", ES8374_ADC_HPF_REG2C, 0, 31, 0),
+//	SOC_SINGLE_TLV("ADC Capture Volume",
+//				ES8374_ADC_VOLUME_REG25, 0, 192, 1, adc_rec_tlv),
+	SOC_SINGLE("ALC Capture Target Volume", ES8374_ALC_LVL_HLD_REG28, 4, 15, 0),
+	SOC_SINGLE("ALC Capture Max PGA", ES8374_ALC_EN_MAX_GAIN_REG26, 0, 31, 0),
+	SOC_SINGLE("ALC Capture Min PGA", ES8374_ALC_MIN_GAIN_REG27, 0, 31, 0),
+//	SOC_ENUM("ALC Capture Function", alc_func),
+	SOC_ENUM("ALC Mode", alc_mode),
+	SOC_SINGLE("ALC Capture Hold Time", ES8374_ALC_LVL_HLD_REG28, 0, 15, 0),
+	SOC_SINGLE("ALC Capture Decay Time", ES8374_ALC_DCY_ATK_REG29, 4, 15, 0),
+	SOC_SINGLE("ALC Capture Attack Time", ES8374_ALC_DCY_ATK_REG29, 0, 15, 0),
+	SOC_SINGLE("ALC Capture NG Threshold", ES8374_ALC_NGTH_REG2B, 0, 31, 0),
+	SOC_ENUM("ALC Capture NG Type", ng_type),
+	SOC_SINGLE("ALC Capture NG Switch", ES8374_ALC_NGTH_REG2B, 5, 1, 0),
+
+	/*
+	* controls for playback path
+	*/
+	SOC_SINGLE("DAC Double FS Mode", ES8374_DAC_CONTROL_REG37, 7, 1, 0),
+	SOC_SINGLE("DAC Soft Ramp Rate", ES8374_DAC_CONTROL_REG36, 2, 7, 0),
+	SOC_SINGLE("DAC MUTE", ES8374_DAC_CONTROL_REG36, 5, 1, 0),
+	SOC_SINGLE("DAC OFFSET", ES8374_DAC_OFFSET_REG39, 0, 255, 0),
+	SOC_ENUM("DAC AUTO MUTE TYPE", dac_auto_mute_type),
+	SOC_ENUM("DAC DSM MUTE TYPE", dac_dsm_mute_type),
+
+	SOC_SINGLE_TLV("ADC Capture Volume",
+					ES8374_ADC_VOLUME_REG25, 0, 192, 1, vadc_tlv),
+	SOC_SINGLE_TLV("DAC Playback Volume",
+					ES8374_DAC_VOLUME_REG38, 0, 192, 1, vdac_tlv),
+	SOC_SINGLE_TLV("MONO OUT GAIN",
+					ES8374_MONO_GAIN_REG1B, 0, 15, 0, mono_out_gain_tlv),
+	SOC_SINGLE_TLV("SPEAKER MIXER GAIN",
+					ES8374_SPK_MIX_GAIN_REG1D, 0, 15, 0, mono_out_gain_tlv),
+	SOC_SINGLE_TLV("SPEAKER OUTPUT Volume",
+					ES8374_SPK_OUT_GAIN_REG1E, 0, 7, 0, mono_out_gain_tlv),
+};
+
+/*
+ * DAPM Controls
+ */
+/*
+* alc on/off
+*/
+static const char * const es8374_alc_enable_txt[] = {
+	"ALC OFF",
+	"ALC ON",
+};
+
+static const struct soc_enum es8374_alc_enable_enum =
+SOC_ENUM_SINGLE(ES8374_ALC_EN_MAX_GAIN_REG26, 6,
+	ARRAY_SIZE(es8374_alc_enable_txt), es8374_alc_enable_txt);
+
+
+static const struct snd_kcontrol_new es8374_alc_enable_controls =
+	SOC_DAPM_ENUM("Route", es8374_alc_enable_enum);
+/*
+* adc line in select
+*/
+static const char * const es8374_adc_input_src_txt[] = {
+	"LIN1-RIN1",
+	"LIN2-RIN2",
+};
+static const unsigned int es8374_adc_input_src_values[] = {
+	0, 1};
+static const struct soc_enum es8374_adc_input_src_enum =
+SOC_VALUE_ENUM_SINGLE(ES8374_AIN_PWR_SRC_REG21, 4, 0x30,
+			ARRAY_SIZE(es8374_adc_input_src_txt),
+			es8374_adc_input_src_txt,
+			es8374_adc_input_src_values);
+static const struct snd_kcontrol_new es8374_adc_input_src_controls =
+	SOC_DAPM_ENUM("Route", es8374_adc_input_src_enum);
+
+/*
+ * ANALOG IN MUX
+ */
+static const char * const es8374_analog_input_mux_txt[] = {
+	"LIN1",
+	"LIN2",
+	"DIFF OUT1",
+	"DIFF OUT2",
+	"PGA OUT1",
+	"PGA OUT2"
+};
+static const unsigned int es8374_analog_input_mux_values[] = {
+	0, 1, 2, 3, 4, 5};
+static const struct soc_enum es8374_analog_input_mux_enum =
+SOC_VALUE_ENUM_SINGLE(ES8374_MONO_MIX_REG1A, 0, 0x7,
+			ARRAY_SIZE(es8374_analog_input_mux_txt),
+			es8374_analog_input_mux_txt,
+			es8374_analog_input_mux_values);
+static const struct snd_kcontrol_new es8374_analog_input_mux_controls =
+SOC_DAPM_ENUM("Route", es8374_analog_input_mux_enum);
+/*
+ * MONO OUTPUT MIXER
+ */
+static const struct snd_kcontrol_new es8374_mono_out_mixer_controls[] = {
+	SOC_DAPM_SINGLE("LIN TO MONO OUT Switch", ES8374_MONO_MIX_REG1A, 6, 1, 0),
+	SOC_DAPM_SINGLE("DAC TO MONO OUT Switch", ES8374_MONO_MIX_REG1A, 7, 1, 0),
+};
+/*
+ * SPEAKER OUTPUT MIXER
+ */
+static const struct snd_kcontrol_new es8374_speaker_mixer_controls[] = {
+	SOC_DAPM_SINGLE("LIN TO SPEAKER OUT Switch", ES8374_SPK_MIX_REG1C, 6, 1, 0),
+	SOC_DAPM_SINGLE("DAC TO SPEAKER OUT Switch", ES8374_SPK_MIX_REG1C, 7, 1, 0),
+};
+/*
+ * digital microphone soure
+ */
+static const char * const es8374_dmic_mux_txt[] = {
+		"DMIC DISABLE1",
+		"DMIC DISABLE2",
+		"DMIC AT HIGH LEVEL",
+		"DMIC AT LOW LEVEL",
+};
+static const unsigned int es8374_dmic_mux_values[] = {
+		0, 1, 2, 3};
+static const struct soc_enum es8374_dmic_mux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8374_ADC_CONTROL_REG24, 0, 0x3,
+				ARRAY_SIZE(es8374_dmic_mux_txt),
+				es8374_dmic_mux_txt,
+				es8374_dmic_mux_values);
+static const struct snd_kcontrol_new es8374_dmic_mux_controls =
+	SOC_DAPM_ENUM("Route", es8374_dmic_mux_enum);
+/*
+ * ADC sdp  soure
+ */
+static const char * const es8374_adc_sdp_mux_txt[] = {
+		"FROM ADC OUT",
+		"FROM EQUALIZER",
+};
+static const unsigned int es8374_adc_sdp_mux_values[] = {
+		0, 1};
+static const struct soc_enum es8374_adc_sdp_mux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8374_EQ_SRC_REG2D, 7, 0x80,
+				ARRAY_SIZE(es8374_adc_sdp_mux_txt),
+				es8374_adc_sdp_mux_txt,
+				es8374_adc_sdp_mux_values);
+static const struct snd_kcontrol_new es8374_adc_sdp_mux_controls =
+	SOC_DAPM_ENUM("Route", es8374_adc_sdp_mux_enum);
+
+/*
+ * DAC dsm  soure
+ */
+static const char * const es8374_dac_dsm_mux_txt[] = {
+		"FROM SDP IN",
+		"FROM EQUALIZER",
+};
+static const unsigned int  es8374_dac_dsm_mux_values[] = {
+		0, 1};
+static const struct soc_enum  es8374_dac_dsm_mux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8374_EQ_SRC_REG2D, 6, 0x40,
+				ARRAY_SIZE(es8374_dac_dsm_mux_txt),
+				es8374_dac_dsm_mux_txt,
+				es8374_dac_dsm_mux_values);
+static const struct snd_kcontrol_new  es8374_dac_dsm_mux_controls =
+	SOC_DAPM_ENUM("Route", es8374_dac_dsm_mux_enum);
+/*
+ * equalizer data  soure
+ */
+static const char * const es8374_equalizer_src_mux_txt[] = {
+		"FROM ADC OUT",
+		"FROM SDP IN",
+};
+static const unsigned int  es8374_equalizer_src_mux_values[] = {
+		0, 1};
+static const struct soc_enum  es8374_equalizer_src_mux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8374_EQ_SRC_REG2D, 5, 0x20,
+				ARRAY_SIZE(es8374_equalizer_src_mux_txt),
+				es8374_equalizer_src_mux_txt,
+				es8374_equalizer_src_mux_values);
+static const struct snd_kcontrol_new  es8374_equalizer_src_mux_controls =
+	SOC_DAPM_ENUM("Route", es8374_equalizer_src_mux_enum);
+/*
+ * DAC data  soure
+ */
+static const char * const es8374_dac_data_mux_txt[] = {
+		"SELECT SDP LEFT DATA",
+		"SELECT SDP RIGHT DATA",
+};
+static const unsigned int  es8374_dac_data_mux_values[] = {
+		0, 1};
+static const struct soc_enum  es8374_dac_data_mux_enum =
+	SOC_VALUE_ENUM_SINGLE(ES8374_DAC_CONTROL_REG36, 6, 0x40,
+				ARRAY_SIZE(es8374_dac_data_mux_txt),
+				es8374_dac_data_mux_txt,
+				es8374_dac_data_mux_values);
+static const struct snd_kcontrol_new  es8374_dac_data_mux_controls =
+	SOC_DAPM_ENUM("Route", es8374_dac_data_mux_enum);
+
+static const struct snd_soc_dapm_widget es8374_dapm_widgets[] = {
+	/* Input Lines */
+		SND_SOC_DAPM_INPUT("DMIC"),
+		SND_SOC_DAPM_INPUT("MIC1"),
+		SND_SOC_DAPM_INPUT("MIC2"),
+		SND_SOC_DAPM_INPUT("LIN1"),
+		SND_SOC_DAPM_INPUT("LIN2"),
+
+	/*
+	*  Capture path
+	*/
+		SND_SOC_DAPM_MICBIAS("micbias", ES8374_ANA_REF_REG14,
+				4, 1),
+
+		/* Input MUX */
+		SND_SOC_DAPM_MUX("DIFFERENTIAL MUX", SND_SOC_NOPM, 0, 0,
+				&es8374_adc_input_src_controls),
+
+		SND_SOC_DAPM_PGA("DIFFERENTIAL PGA", SND_SOC_NOPM,
+				0, 0, NULL, 0),
+
+		SND_SOC_DAPM_PGA("LINE PGA", SND_SOC_NOPM,
+				0, 0, NULL, 0),
+
+		/* ADCs */
+		SND_SOC_DAPM_ADC("MONO ADC", NULL, SND_SOC_NOPM, 0, 0),
+
+		/* Dmic MUX */
+		SND_SOC_DAPM_MUX("DMIC MUX", SND_SOC_NOPM, 0, 0,
+				&es8374_dmic_mux_controls),
+
+		/* Dmic MUX */
+		SND_SOC_DAPM_MUX("ALC MUX", SND_SOC_NOPM, 0, 0,
+			&es8374_alc_enable_controls),
+
+
+		/* sdp MUX */
+		SND_SOC_DAPM_MUX("SDP OUT MUX", SND_SOC_NOPM, 0, 0,
+			&es8374_adc_sdp_mux_controls),
+
+		/* Digital Interface */
+		SND_SOC_DAPM_AIF_OUT("I2S OUT", "I2S1 Capture",  1,
+				SND_SOC_NOPM, 0, 0),
+
+		/*
+		*	Render path
+		*/
+		SND_SOC_DAPM_AIF_IN("I2S IN", "I2S1 Playback", 0,
+				SND_SOC_NOPM, 0, 0),
+
+		/*	DACs SDP DATA SRC MUX */
+		SND_SOC_DAPM_MUX("DAC SDP SRC MUX", SND_SOC_NOPM, 0, 0,
+				&es8374_dac_data_mux_controls),
+
+		/*	DACs  DATA SRC MUX */
+		SND_SOC_DAPM_MUX("DAC SRC MUX", SND_SOC_NOPM, 0, 0,
+			&es8374_dac_dsm_mux_controls),
+
+		SND_SOC_DAPM_DAC("MONO DAC", NULL, SND_SOC_NOPM, 0, 0),
+
+
+		/* hpmux for hp mixer */
+		SND_SOC_DAPM_MUX("ANALOG INPUT MUX", SND_SOC_NOPM, 0, 0,
+				&es8374_analog_input_mux_controls),
+
+		/* Output mixer  */
+		SND_SOC_DAPM_MIXER("MONO MIXER", SND_SOC_NOPM,
+				0, 0, &es8374_mono_out_mixer_controls[0], ARRAY_SIZE(es8374_mono_out_mixer_controls)),
+		SND_SOC_DAPM_MIXER("SPEAKER MIXER", SND_SOC_NOPM,
+				0, 0, &es8374_speaker_mixer_controls[0], ARRAY_SIZE(es8374_speaker_mixer_controls)),
+
+		/*
+		*	Equalizer path
+		*/
+		SND_SOC_DAPM_MUX("EQUALIZER MUX", SND_SOC_NOPM, 0, 0,
+				&es8374_equalizer_src_mux_controls),
+
+		/* Output Lines */
+		SND_SOC_DAPM_OUTPUT("MOUT"),
+		SND_SOC_DAPM_OUTPUT("SPKOUT"),
+
+};
+
+
+static const struct snd_soc_dapm_route es8374_dapm_routes[] = {
+	/*
+	 * record route map
+	 */
+	{"MIC1", NULL, "micbias"},
+	{"MIC2", NULL, "micbias"},
+	{"DMIC", NULL, "micbias"},
+
+	{"DIFFERENTIAL MUX", "LIN1-RIN1", "MIC1"},
+	{"DIFFERENTIAL MUX", "LIN2-RIN2", "MIC2"},
+
+	{"DIFFERENTIAL PGA", NULL, "DIFFERENTIAL MUX"},
+
+	{"LINE PGA", NULL, "DIFFERENTIAL PGA"},
+
+	{"MONO ADC", NULL, "LINE PGA"},
+
+	{"DMIC MUX", "DMIC DISABLE1", "MONO ADC"},
+	{"DMIC MUX", "DMIC DISABLE2", "MONO ADC"},
+	{"DMIC MUX", "DMIC AT HIGH LEVEL", "DMIC"},
+	{"DMIC MUX", "DMIC AT LOW LEVEL", "DMIC"},
+
+	{"ALC MUX", "ALC OFF", "DMIC MUX"},
+	{"ALC MUX", "ALC ON", "DMIC MUX"},
+
+	/*
+	* Equalizer path
+	*/
+	{"EQUALIZER MUX", "FROM ADC OUT", "ALC MUX"},
+	{"EQUALIZER MUX", "FROM SDP IN", "I2S IN"},
+
+	{"SDP OUT MUX", "FROM ADC OUT", "ALC MUX"},
+	{"SDP OUT MUX", "FROM EQUALIZER", "EQUALIZER MUX"},
+
+	{"I2S OUT", NULL, "SDP OUT MUX"},
+	/*
+	 * playback route map
+	 */
+	{"DAC SDP SRC MUX", "SELECT SDP LEFT DATA", "I2S IN"},
+	{"DAC SDP SRC MUX", "SELECT SDP RIGHT DATA", "I2S IN"},
+
+
+
+	{"DAC SRC MUX", "FROM SDP IN", "DAC SDP SRC MUX"},
+	{"DAC SRC MUX", "FROM EQUALIZER", "EQUALIZER MUX"},
+
+	{"MONO DAC", NULL, "DAC SRC MUX"},
+
+	{"ANALOG INPUT MUX", "LIN1", "LIN1"},
+	{"ANALOG INPUT MUX", "LIN2", "LIN2"},
+	{"ANALOG INPUT MUX", "DIFF OUT1", "DIFFERENTIAL MUX"},
+	{"ANALOG INPUT MUX", "DIFF OUT2", "DIFFERENTIAL PGA"},
+	{"ANALOG INPUT MUX", "PGA OUT1", "LINE PGA"},
+	{"ANALOG INPUT MUX", "PGA OUT2", "LINE PGA"},
+
+
+	{"MONO MIXER", "LIN TO MONO OUT Switch", "ANALOG INPUT MUX"},
+	{"MONO MIXER", "DAC TO MONO OUT Switch", "MONO DAC"},
+
+	{"SPEAKER MIXER", "LIN TO SPEAKER OUT Switch", "ANALOG INPUT MUX"},
+	{"SPEAKER MIXER", "DAC TO SPEAKER OUT Switch", "MONO DAC"},
+
+
+	{"MOUT", NULL, "MONO MIXER"},
+	{"SPKOUT", NULL, "SPEAKER MIXER"},
+
+};
+
+#if 0
+static int es8374_set_pll(struct snd_soc_dai *dai, int pll_id,
+			int source, unsigned int freq_in, unsigned int freq_out)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct es8374_private *priv = snd_soc_codec_get_drvdata(codec);
+	u16 reg;
+	u8 N, K1, K2, K3;
+	float tmp;
+	u32 Kcoefficient;
+	switch (pll_id) {
+	case ES8374_PLL:
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	/* Disable PLL  */
+	// pll hold in reset state
+	snd_soc_update_bits(codec, ES8374_PLL_CONTROL1_REG09,
+							0x40, 0x00);
+
+	if (!freq_in || !freq_out)
+		return 0;
+
+	switch (source) {
+
+		case ES8374_PLL_SRC_FRM_MCLK:
+			// Select PLL
+			snd_soc_update_bits(codec, ES8374_CLK_MANAGEMENT_REG02,
+									0x08, 0x08);
+			break;
+		default:
+			//Disable PLL
+			snd_soc_update_bits(codec, ES8374_CLK_MANAGEMENT_REG02,
+									0x08, 0x00);
+			return -EINVAL;
+	}
+	/*get N & K */
+	tmp = 0;
+	if (source == ES8374_PLL_SRC_FRM_MCLK) {
+			if(freq_in >19200000)
+			{
+				freq_in /= 2;
+				snd_soc_update_bits(codec, ES8374_CLK_MANAGEMENT_REG01,
+								0x80, 0x80);	/* mclk div2	= 1 */
+			}
+			tmp = (float)freq_out * (float)priv->pll_div + 4000;
+			tmp /= (float)freq_in;
+			N =  (u8)tmp;
+			tmp = tmp - (float)N;
+			tmp = tmp * 0.6573598222296 * (1<<22);
+			Kcoefficient = (u32)tmp;
+			K1 = Kcoefficient / 65536;
+			Kcoefficient = Kcoefficient - K1 * 65536;
+			K2 = Kcoefficient /256;
+			K3 = Kcoefficient - K2 * 256;
+		}
+		dev_dbg(codec->dev, "N=%x, K3=%x, K2=%x, K1=%x\n", N, K3, K2, K1);
+
+		reg =  snd_soc_read(codec, ES8374_PLL_N_REG0B);
+		reg &= 0xF0;
+		reg |= (N & 0x0F);
+		snd_soc_write(codec, ES8374_PLL_N_REG0B, reg);
+
+		K1 &= 0x3F;
+		snd_soc_write(codec, ES8374_PLL_K_REG0C, K1);
+		snd_soc_write(codec, ES8374_PLL_K_REG0D, K2);
+		snd_soc_write(codec, ES8374_PLL_K_REG0E, K3);
+
+
+		/* pll div 8 */
+		reg =  snd_soc_read(codec, ES8374_PLL_CONTROL1_REG09);
+		reg &= 0xfc;
+		reg |= 0x01;
+		snd_soc_write(codec, ES8374_PLL_CONTROL1_REG09, reg);
+
+		/* configure the pll power voltage  */
+		switch (priv->dvdd_pwr_vol) {
+			case 0x18:
+				snd_soc_update_bits(codec, ES8374_PLL_CONTROL2_REG0A, 0x0c, 0x00); /* dvdd=1.8v */
+				break;
+			case 0x25:
+				snd_soc_update_bits(codec, ES8374_PLL_CONTROL2_REG0A, 0x0c, 0x04); /* dvdd=2.5v */
+				break;
+			case 0x33:
+				snd_soc_update_bits(codec, ES8374_PLL_CONTROL2_REG0A, 0x0c, 0x08); /* dvdd=3.3v */
+				break;
+			default:
+				snd_soc_update_bits(codec, ES8374_PLL_CONTROL2_REG0A, 0x0c, 0x00); /* dvdd=1.8v */
+				break;
+		}
+		/* enable PLL  */
+		snd_soc_update_bits(codec, ES8374_PLL_CONTROL1_REG09,
+								0x40, 0x40);
+		priv->mclk = freq_out;
+		return 0;
+}
+#endif
+
+struct _coeff_div {
+	u32 mclk;       /* mclk frequency */
+	u32 rate;       /* sample rate */
+	u8 div;         /* adcclk and dacclk divider */
+	u8 fsmode;         /* adcclk and dacclk divider */
+	u8 divdouble;         /* adcclk and dacclk divider */
+	u8 lrck_h;      /* adclrck divider and daclrck divider */
+	u8 lrck_l;
+	u8 sr;          /* sclk divider */
+	u8 osr;         /* adc osr */
+};
+
+
+/* codec hifi mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+
+//	MCLK	,	LRCK,DIV,FSMODE,divDOUBLE,LRCK-H,LRCK-L,BCLK,OSR
+	/*
+	//12M288
+	{12288000, 96000 , 1 , 1 , 0 , 0x00 , 0x80 , 2 , 32},
+	{12288000, 64000 , 3 , 1 , 1 , 0x00 , 0xC0 , 2 , 32},
+	{12288000, 48000 , 1 , 0 , 0 , 0x01 , 0x00 , 2 , 32},
+	{12288000, 32000 , 3 , 0 , 1 , 0x01 , 0x80 , 2 , 32},
+	{12288000, 24000 , 2 , 0 , 0 , 0x02 , 0x00 , 2 , 32},
+	{12288000, 16000 , 3 , 0 , 0 , 0x03 , 0x00 , 2 , 32},
+	{12288000, 12000 , 4 , 0 , 0 , 0x04 , 0x00 , 2 , 32},
+	{12288000, 8000  , 6 , 0 , 0 , 0x06 , 0x00 , 2 , 32},
+
+	// 12M
+	{12000000, 96000 , 1 , 1 , 0 , 0x00 , 0x7D , 2 , 31},
+	{12000000, 88200 , 1 , 1 , 0 , 0x00 , 0x88 , 2 , 34},
+	{12000000, 48000 , 5 , 1 , 1 , 0x00 , 0xFA , 2 , 25},
+	{12000000, 44100 , 1 , 0 , 0 , 0x01 , 0x10 , 2 , 34},
+	{12000000, 32000 , 3 , 1 , 0 , 0x01 , 0x77 , 2 , 31},
+	{12000000, 24000 , 5 , 1 , 0 , 0x02 , 0x00 , 2 , 25},
+	{12000000, 22050 , 2 , 0 , 0 , 0x02 , 0x20 , 2 , 34},
+	{12000000, 16000 , 15, 1 , 1 , 0x02 , 0xEE , 2 , 25},
+	{12000000, 12000 , 5 , 0 , 0 , 0x03 , 0xE8 , 2 , 25},
+	{12000000, 11025 , 4 , 0 , 0 , 0x04 , 0x40 , 2 , 34},
+	{12000000, 8000  , 15, 0 , 1 , 0x05 , 0xDC , 2 , 25},
+
+	//11M2896
+	{11289600, 88200 , 1 , 1 , 0 , 0x00 , 0x80 , 2 , 32},
+	{11289600, 44100 , 1 , 0 , 0 , 0x01 , 0x00 , 2 , 32},
+	{11289600, 22050 , 2 , 0 , 0 , 0x02 , 0x00 , 2 , 32},
+	{11289600, 11025 , 4 , 0 , 0 , 0x04 , 0x00 , 2 , 32},
+
+*/
+
+	/* 8k */
+	{12288000, 8000  , 6 , 0 , 0 , 0x06 , 0x00 , 2 , 32},
+	{12000000, 8000  , 15, 0 , 1 , 0x05 , 0xDC , 2 , 25},
+	{11289600, 8000 , 6 , 0 , 0 , 0x05, 0x83, 20, 29},
+	{18432000, 8000 , 9 , 0 , 0 , 0x09, 0x00, 27, 32},
+	{16934400, 8000 , 8 , 0 , 0 , 0x08, 0x44, 25, 33},
+	{12000000, 8000 , 7 , 0 , 0 , 0x05, 0xdc, 21, 25},
+	{19200000, 8000 , 12, 0 , 0 , 0x09, 0x60, 27, 25},
+
+	/* 11.025k */
+	{11289600, 11025 , 4 , 0 , 0 , 0x04 , 0x00 , 2 , 32},
+	{12000000, 11025 , 4 , 0 , 0 , 0x04 , 0x40 , 2 , 34},
+	{16934400, 11025, 6 ,  0 , 0 , 0x06, 0x00, 21, 32},
+
+
+	/* 12k */
+	{12000000, 12000 , 5 , 0 , 0 , 0x03 , 0xE8 , 2 , 25},
+	{12288000, 12000 , 4 , 0 , 0 , 0x04 , 0x00 , 2 , 32},
+
+	/* 16k */
+	{12288000, 16000 , 3 , 0 , 0 , 0x03 , 0x00 , 2 , 32},
+	{18432000, 16000, 5 ,  0 , 0 , 0x04, 0x80, 18, 25},
+	{12000000, 16000 , 15, 1 , 1 , 0x02 , 0xEE , 2 , 25},
+	{19200000, 16000, 6 ,  0 , 0 , 0x04, 0xb0, 18, 25},
+
+	/* 22.05k */
+	{11289600, 22050 , 2 , 0 , 0 , 0x02 , 0x00 , 2 , 32},
+	{16934400, 22050, 3 ,  0 , 0 , 0x03, 0x00, 12, 32},
+	{12000000, 22050 , 2 , 0 , 0 , 0x02 , 0x20 , 2 , 34},
+
+	/* 24k */
+	{12000000, 24000 , 5 , 1 , 0 , 0x02 , 0x00 , 2 , 25},
+	{12288000, 24000 , 2 , 0 , 0 , 0x02 , 0x00 , 2 , 32},
+
+	/* 32k */
+	{12288000, 32000 , 3 , 0 , 1 , 0x01 , 0x80 , 2 , 32},
+	{18432000, 32000, 2 ,  0 , 0 , 0x02, 0x40, 9 , 32},
+	{12000000, 32000 , 3 , 1 , 0 , 0x01 , 0x77 , 2 , 31},
+	{19200000, 32000, 3 ,  0 , 0 , 0x02, 0x58, 10, 25},
+
+	/* 44.1k */
+	{11289600, 44100 , 1 , 0 , 0 , 0x01 , 0x00 , 2 , 32},
+	{16934400, 44100, 1 ,  0 , 0 , 0x01, 0x80, 6 , 32},
+	{12000000, 44100 , 1 , 0 , 0 , 0x01 , 0x10 , 2 , 34},
+
+	/* 48k */
+	{12288000, 48000 , 1 , 0 , 0 , 0x01 , 0x00 , 2 , 32},
+	{18432000, 48000, 1 ,  0 , 0 , 0x01, 0x80, 6 , 32},
+	{12000000, 48000 , 5 , 1 , 1 , 0x00 , 0xFA , 2 , 25},
+	{19200000, 48000, 2 ,  0 , 0 , 0x01, 0x90, 6, 25},
+
+	/* 64k */
+	{12288000, 64000 , 3 , 1 , 1 , 0x00 , 0xC0 , 2 , 32},
+
+	/* 88.2k */
+	{11289600, 88200 , 1 , 1 , 0 , 0x00 , 0x80 , 2 , 32},
+	{16934400, 88200, 1 ,  0 , 0 , 0x00, 0xc0, 3 , 48},
+	{12000000, 88200 , 1 , 1 , 0 , 0x00 , 0x88 , 2 , 34},
+
+	/* 96k */
+	{12288000, 96000 , 1 , 1 , 0 , 0x00 , 0x80 , 2 , 32},
+	{18432000, 96000, 1 ,  0 , 0 , 0x00, 0xc0, 3 , 48},
+	{12000000, 96000 , 1 , 1 , 0 , 0x00 , 0x7D , 2 , 31},
+	{19200000, 96000, 1 ,  0 , 0 , 0x00, 0xc8, 3 , 25},
+};
+static inline int get_coeff(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+/* The set of rates we can generate from the above for each SYSCLK */
+#if 0
+static unsigned int rates_12288[] = {
+	8000, 12000, 16000, 24000, 24000, 32000, 48000, 96000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_12288 = {
+	.count	= ARRAY_SIZE(rates_12288),
+	.list	= rates_12288,
+};
+
+static unsigned int rates_112896[] = {
+	8000, 11025, 22050, 44100,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_112896 = {
+	.count	= ARRAY_SIZE(rates_112896),
+	.list	= rates_112896,
+};
+
+static unsigned int rates_12[] = {
+	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,
+	48000, 88235, 96000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_12 = {
+	.count	= ARRAY_SIZE(rates_12),
+	.list	= rates_12,
+};
+#endif
+
+/*
+ * if PLL not be used, use internal clk1 for mclk,otherwise, use internal clk2 for PLL source.
+ */
+static int es8374_set_dai_sysclk(struct snd_soc_dai *dai,
+			int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	if (clk_id == ES8374_CLKID_MCLK) {
+		snd_soc_write(codec,0x09,0x80);	//pll set:reset on ,set start
+		snd_soc_write(codec,0x0C,0x00);	//pll set:k
+		snd_soc_write(codec,0x0D,0x00);	//pll set:k
+		snd_soc_write(codec,0x0E,0x00);	//pll set:k
+
+	}
+
+	return 0;
+}
+
+static int es8374_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u8 iface = 0;
+	u8 adciface = 0;
+	u8 daciface = 0;
+
+	iface    = snd_soc_read(codec, ES8374_MS_BCKDIV_REG0F);
+	adciface = snd_soc_read(codec, ES8374_ADC_FMT_REG10);
+	daciface = snd_soc_read(codec, ES8374_DAC_FMT_REG11);
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:    /* MASTER MODE */
+		iface |= 0x80;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:    /* SLAVE MODE */
+		iface &= 0x7F;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		adciface &= 0xFC;
+		daciface &= 0xFC;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		return -EINVAL;
+	case SND_SOC_DAIFMT_LEFT_J:
+		adciface &= 0xFC;
+		daciface &= 0xFC;
+		adciface |= 0x01;
+		daciface |= 0x01;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		adciface &= 0xDC;
+		daciface &= 0xDC;
+		adciface |= 0x03;
+		daciface |= 0x03;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		adciface &= 0xDC;
+		daciface &= 0xDC;
+		adciface |= 0x23;
+		daciface |= 0x23;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+
+	/* clock inversion */
+	if(((fmt & SND_SOC_DAIFMT_FORMAT_MASK)==SND_SOC_DAIFMT_I2S) ||
+		((fmt & SND_SOC_DAIFMT_FORMAT_MASK)==SND_SOC_DAIFMT_LEFT_J))
+		{
+
+		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+
+			iface    &= 0xDF;
+			adciface &= 0xDF;
+			daciface &= 0xDF;
+			break;
+		case SND_SOC_DAIFMT_IB_IF:
+			iface    |= 0x20;
+			adciface |= 0x20;
+			daciface |= 0x20;
+			break;
+		case SND_SOC_DAIFMT_IB_NF:
+			iface    |= 0x20;
+			adciface &= 0xDF;
+			daciface &= 0xDF;
+			break;
+		case SND_SOC_DAIFMT_NB_IF:
+			iface    &= 0xDF;
+			adciface |= 0x20;
+			daciface |= 0x20;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+	snd_soc_write(codec, ES8374_MS_BCKDIV_REG0F, iface);
+	snd_soc_write(codec, ES8374_ADC_FMT_REG10, adciface);
+	snd_soc_write(codec, ES8374_DAC_FMT_REG11, daciface);
+	return 0;
+}
+static int es8374_pcm_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int es8374_pcm_hw_params(struct snd_pcm_substream *substream,
+			struct snd_pcm_hw_params *params,
+			struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct es8374_private *es8374 = snd_soc_codec_get_drvdata(codec);
+	u16 iface;
+
+	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		iface = snd_soc_read(codec, ES8374_DAC_FMT_REG11) & 0xE3;
+		/* bit size */
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			iface |= 0x0c;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			iface |= 0x04;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			iface |= 0x10;
+			break;
+		}
+		/* set iface & srate */
+		snd_soc_write(codec, ES8374_DAC_FMT_REG11, iface);
+		/*set speak and mono for playback*/
+		snd_soc_write(codec, ES8374_MONO_MIX_REG1A, 0xA0);
+		snd_soc_write(codec, ES8374_SPK_MIX_REG1C, 0x90);
+
+	} else {
+		iface = snd_soc_read(codec, ES8374_ADC_FMT_REG10) & 0xE3;
+		/* bit size */
+		switch (params_format(params)) {
+		case SNDRV_PCM_FORMAT_S16_LE:
+			iface |= 0x0c;
+			break;
+		case SNDRV_PCM_FORMAT_S20_3LE:
+			iface |= 0x04;
+			break;
+		case SNDRV_PCM_FORMAT_S24_LE:
+			break;
+		case SNDRV_PCM_FORMAT_S32_LE:
+			iface |= 0x10;
+			break;
+		}
+		/* set iface */
+		snd_soc_write(codec, ES8374_ADC_FMT_REG10, iface);
+	}
+
+	if(es8374->dmic_enable){
+		snd_soc_write(codec, ES8374_ADC_CONTROL_REG24, 0x8A);  //6DB & DIMC=H
+		snd_soc_write(codec,0x12,0x40);
+		snd_soc_write(codec,0x13,0x40);
+		snd_soc_write(codec,0x22,0x00);
+		snd_soc_write(codec, 0x26, 0x50);
+		snd_soc_write(codec, 0x28, 0x80);
+
+	} else {
+		snd_soc_write(codec,0x24,0x08);	//adc set
+		snd_soc_write(codec, ES8374_GPIO_INSERT_REG6D, 0x1F);  //set gpio1 to GM SHORT
+	}
+
+/*
+*	please add the hardware clock divider setting to get the correct LRCK, SCLK frequency
+*/
+	return 0;
+}
+
+static int es8374_set_bias_level(struct snd_soc_codec *codec,
+			enum snd_soc_bias_level level)
+{
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		snd_soc_write(codec, ES8374_CLK_MANAGEMENT_REG01, 0x7f);
+		snd_soc_write(codec, ES8374_ANA_REF_REG14, 0x8a);
+		snd_soc_write(codec, ES8374_ANA_PWR_CTL_REG15, 0x40);
+		snd_soc_update_bits(codec, ES8374_AIN_PWR_SRC_REG21, 0xc0, 0x00);
+		snd_soc_write(codec, ES8374_MONO_MIX_REG1A, 0xa0);
+		snd_soc_write(codec, ES8374_SPK_MIX_REG1C, 0x90);
+		snd_soc_write(codec, ES8374_SPK_MIX_GAIN_REG1D, 0x02);
+		snd_soc_write(codec, ES8374_SPK_OUT_GAIN_REG1E, 0xa0);
+		snd_soc_write(codec, ES8374_DAC_CONTROL_REG36, 0x00);
+		snd_soc_write(codec, ES8374_DAC_CONTROL_REG37, 0x00);
+		snd_soc_write(codec, ES8374_DAC_VOLUME_REG38, 0x00);
+		snd_soc_write(codec, ES8374_ADC_VOLUME_REG25, 0x00);
+		snd_soc_write(codec, ES8374_AIN_PGA_REG22, 0x06);
+
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		snd_soc_update_bits(codec, ES8374_AIN_PWR_SRC_REG21, 0xc0, 0xc0);
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		snd_soc_update_bits(codec, ES8374_AIN_PWR_SRC_REG21, 0xc0, 0xc0);
+		snd_soc_write(codec, ES8374_ALC_LVL_HLD_REG28, 0x1c);
+		snd_soc_update_bits(codec, ES8374_AIN_PWR_SRC_REG21, 0xc0, 0x00);
+		snd_soc_write(codec, ES8374_ANA_PWR_CTL_REG15, 0xbf);
+		snd_soc_write(codec, ES8374_ANA_REF_REG14, 0x14);
+		snd_soc_write(codec, ES8374_CLK_MANAGEMENT_REG01, 0x03);
+		snd_soc_write(codec, ES8374_AIN_PGA_REG22, 0x00);
+		break;
+	}
+
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+/*
+static int es8374_set_tristate(struct snd_soc_dai *dai, int tristate)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	dev_dbg(codec->dev, "es8374_set_tristate........\n");
+	if(tristate) {
+		snd_soc_update_bits(codec, ES8374_MS_BCKDIV_REG0F,
+					0x40, 0x40);
+	} else {
+		snd_soc_update_bits(codec, ES8374_MS_BCKDIV_REG0F,
+					0x40, 0x00);
+	}
+
+	return 0;
+}
+*/
+
+static int es8374_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+
+	dev_dbg(codec->dev, "%s %d\n", __func__, mute);
+	if (mute) {
+		snd_soc_update_bits(codec, ES8374_DAC_CONTROL_REG36, 0x20, 0x20);
+	} else {
+		if (dai->playback_active)
+			snd_soc_update_bits(codec, ES8374_DAC_CONTROL_REG36, 0x20, 0x00);
+	}
+	return 0;
+}
+
+
+#define es8374_RATES SNDRV_PCM_RATE_8000_96000
+
+#define es8374_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+		SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops es8374_ops = {
+	.startup = es8374_pcm_startup,
+	.hw_params = es8374_pcm_hw_params,
+	.set_fmt = es8374_set_dai_fmt,
+	.set_sysclk = es8374_set_dai_sysclk,
+	.digital_mute = es8374_mute,
+};
+
+static struct snd_soc_dai_driver es8374_dai[] = {
+	{	.name = "ES8374 HiFi",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = es8374_RATES,
+			.formats = es8374_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = es8374_RATES,
+			.formats = es8374_FORMATS,
+		},
+		.ops = &es8374_ops,
+		.symmetric_rates = 1,
+	},
+};
+
+static int es8374_suspend(struct snd_soc_codec *codec)
+{
+	struct es8374_private *es8374 = snd_soc_codec_get_drvdata(codec);
+	int i;
+
+	for(i = 0; i <= 110; i++) {
+		es8374->reg_cache[i] = snd_soc_read(codec, i);
+	}
+
+	snd_soc_write(codec, ES8374_DAC_VOLUME_REG38, 0xc0);
+	snd_soc_write(codec, ES8374_ADC_VOLUME_REG25, 0xc0);
+	snd_soc_write(codec, ES8374_DAC_CONTROL_REG36, 0x20);
+	snd_soc_write(codec, ES8374_DAC_CONTROL_REG37, 0x21);
+	snd_soc_write(codec, ES8374_MONO_MIX_REG1A, 0x08);
+	snd_soc_write(codec, ES8374_SPK_MIX_REG1C, 0x10);
+	snd_soc_write(codec, ES8374_SPK_MIX_GAIN_REG1D, 0x10);
+	snd_soc_write(codec, ES8374_SPK_OUT_GAIN_REG1E, 0x40);
+	snd_soc_update_bits(codec, ES8374_AIN_PWR_SRC_REG21, 0xc0, 0x00);
+	snd_soc_write(codec, ES8374_ANA_PWR_CTL_REG15, 0xbf);
+	snd_soc_write(codec, ES8374_ANA_REF_REG14, 0x14);
+	snd_soc_write(codec, ES8374_CLK_MANAGEMENT_REG01, 0x03);
+
+	return 0;
+}
+
+static int es8374_resume(struct snd_soc_codec *codec)
+{
+	struct es8374_private *es8374 = snd_soc_codec_get_drvdata(codec);
+	int i;
+#if 0
+	snd_soc_write(codec, ES8374_CLK_MANAGEMENT_REG01, 0x7f);
+	snd_soc_write(codec, ES8374_ANA_REF_REG14, 0x8a);
+	snd_soc_write(codec, ES8374_ANA_PWR_CTL_REG15, 0x40);
+	snd_soc_update_bits(codec, ES8374_AIN_PWR_SRC_REG21, 0xc0, 0x50);
+	snd_soc_write(codec, ES8374_MONO_MIX_REG1A, 0xa0);
+	snd_soc_write(codec, ES8374_SPK_MIX_REG1C, 0x90);
+	snd_soc_write(codec, ES8374_SPK_MIX_GAIN_REG1D, 0x02);
+	snd_soc_write(codec, ES8374_SPK_OUT_GAIN_REG1E, 0xa0);
+	snd_soc_write(codec, ES8374_DAC_CONTROL_REG36, 0x00);
+	snd_soc_write(codec, ES8374_DAC_CONTROL_REG37, 0x00);
+	snd_soc_write(codec, ES8374_DAC_VOLUME_REG38, 0x00);
+	snd_soc_write(codec, ES8374_ADC_VOLUME_REG25, 0x00);
+#endif
+
+	for(i = 0; i <= 110; i++) {
+		snd_soc_write(codec, i, es8374->reg_cache[i]);
+	}
+
+	return 0;
+}
+
+static int es8374_parse_dts(struct es8374_private *es8374)
+{
+#ifdef CONFIG_OF
+	struct device *dev;
+	struct device_node *np;
+	enum of_gpio_flags flags;
+	int ret, dmic;
+
+	if (es8374->control_type == SND_SOC_I2C) {
+		dev = &(es8374->i2c->dev);
+	} else {
+		dev = &(es8374->spi->dev);
+	}
+
+	np = dev->of_node;
+
+	if (!np)
+		return -1;
+
+	ret = of_property_read_u32(np, "es8374,dmic", &dmic);
+	if(ret == 0 && dmic == 1) {
+		es8374->dmic_enable = 1;
+	} else {
+		es8374->dmic_enable = 0;
+	}
+
+	es8374->pwr_gpio = of_get_named_gpio_flags(np, "es8374,pwr-gpio", 0, &flags);
+	if (es8374->pwr_gpio < 0 || !gpio_is_valid(es8374->pwr_gpio)) {
+		es8374->pwr_gpio = -1;
+	} else {
+		es8374->pwr_active = !!(flags & OF_GPIO_ACTIVE_LOW);
+	}
+
+#endif
+
+	return 0;
+}
+
+static int es8374_probe(struct snd_soc_codec *codec)
+{
+	int ret = 0;
+	struct es8374_private *es8374 = es8374_data;
+
+	codec->control_data = es8374->regmap;
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);
+	if (ret < 0)
+		return ret;
+
+	es8374->codec = codec;
+	snd_soc_codec_set_drvdata(codec, es8374);
+
+	es8374_parse_dts(es8374);
+	if (gpio_is_valid(es8374->pwr_gpio)) {
+		ret = devm_gpio_request(codec->dev, es8374->pwr_gpio, "es8374 power pin");
+		if(ret == 0)
+			gpio_direction_output(es8374->pwr_gpio, es8374->pwr_active);
+	}
+
+	snd_soc_write(codec,0x00,0x3F);	//IC Rst start
+	msleep(1);  					//DELAY_MS
+	snd_soc_write(codec,0x00,0x03);	//IC Rst stop
+	snd_soc_write(codec,0x01,0x7F);	//IC clk on
+	snd_soc_write(codec,0x05,0x11);	//clk div set
+	snd_soc_write(codec,0x36,0x00);	//dac set
+	snd_soc_write(codec,0x12,0x30);	//timming set
+	snd_soc_write(codec,0x13,0x20);	//timming set
+	snd_soc_write(codec,0x21,0x50);	//adc set:	SEL LIN1 CH+PGAGAIN=0DB
+	snd_soc_write(codec,0x22,0xFF);	//adc set:	PGA GAIN=0DB
+	snd_soc_write(codec,0x21,0x10);	//adc set:	SEL LIN1 CH+PGAGAIN=0DB
+	snd_soc_write(codec,0x00,0x80);	// IC START
+	msleep(50);  					//DELAY_MS
+	snd_soc_write(codec,0x14,0x8A);	// IC START
+	snd_soc_write(codec,0x15,0x40);	// IC START
+	snd_soc_write(codec,0x1A,0xA0);	// monoout set
+	snd_soc_write(codec,0x1B,0x19);	// monoout set
+	snd_soc_write(codec,0x1C,0x90);	// spk set
+	snd_soc_write(codec,0x1D,0x02);	// spk set
+	snd_soc_write(codec,0x1F,0x00);	// spk set
+	snd_soc_write(codec,0x1E,0xA0);	// spk on
+	snd_soc_write(codec,0x28,0x00);	// alc set
+	snd_soc_write(codec,0x25,0x00);	// ADCVOLUME  on
+	snd_soc_write(codec,0x38,0x00);	// DACVOLUMEL on
+	snd_soc_write(codec,0x37,0x00);	// dac set
+	snd_soc_write(codec,0x6D,0x40);	//SEL:GPIO1=DMIC CLK OUT+SEL:GPIO2=PLL CLK OUT
+
+	es8374_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	return ret;
+}
+
+static int es8374_remove(struct snd_soc_codec *codec)
+{
+	es8374_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_es8374 = {
+	.probe =	es8374_probe,
+	.remove =	es8374_remove,
+	.suspend =	es8374_suspend,
+	.resume =	es8374_resume,
+	.set_bias_level = es8374_set_bias_level,
+
+	.controls = es8374_snd_controls,
+	.num_controls = ARRAY_SIZE(es8374_snd_controls),
+	.dapm_widgets = es8374_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(es8374_dapm_widgets),
+	.dapm_routes = es8374_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(es8374_dapm_routes),
+};
+
+static struct regmap_config es8374_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = ES8374_MAX_REGISTER,
+	.reg_defaults = es8374_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(es8374_reg_defaults),
+	.volatile_reg = es8374_volatile_register,
+	.writeable_reg = es8374_writable_register,
+	.readable_reg  = es8374_readable_register,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id es8374_if_dt_ids[] = {
+	{ .compatible = "ambarella,es8374", },
+	{ }
+};
+#endif
+
+#if defined(ES8374_SPI)
+static int es8374_spi_probe(struct spi_device *spi)
+{
+	struct es8374_private *es8374;
+	int ret;
+
+	es8374 = kzalloc(sizeof(struct es8374_private), GFP_KERNEL);
+	if (es8374 == NULL)
+		return -ENOMEM;
+
+	es8374->control_type = SND_SOC_SPI;
+	es8374->spi = spi;
+
+	spi_set_drvdata(spi, es8374);
+
+	es8374->regmap = devm_regmap_init_spi(spi, &es8374_regmap);
+	if (IS_ERR(es8374->regmap)) {
+		ret = PTR_ERR(es8374->regmap);
+		dev_err(&spi->dev, "regmap_init() failed: %d\n", ret);
+		return ret;
+	}
+
+	es8374_data = es8374;
+
+	ret = snd_soc_register_codec(&spi->dev,
+			&soc_codec_dev_es8374, &es8374_dai, 1);
+	if (ret < 0)
+		kfree(es8374);
+	return ret;
+}
+
+static int es8374_spi_remove(struct spi_device *spi)
+{
+	snd_soc_unregister_codec(&spi->dev);
+	kfree(spi_get_drvdata(spi));
+	return 0;
+}
+
+static struct spi_driver es8374_spi_driver = {
+	.driver = {
+		.name	= "es8374",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(es8374_if_dt_ids),
+#endif
+	},
+	.probe	= es8374_spi_probe,
+	.remove	= es8374_spi_remove,
+};
+#endif /* CONFIG_SPI_MASTER */
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+static void es8374_i2c_shutdown(struct i2c_client *i2c)
+{
+	struct snd_soc_codec *codec;
+	struct es8374_private *es8374;
+
+	es8374 = i2c_get_clientdata(i2c);
+	codec = es8374->codec;
+
+	snd_soc_write(codec, ES8374_DAC_VOLUME_REG38, 0xc0);
+	snd_soc_write(codec, ES8374_ADC_VOLUME_REG25, 0xc0);
+	snd_soc_write(codec, ES8374_DAC_CONTROL_REG36, 0x20);
+	snd_soc_write(codec, ES8374_DAC_CONTROL_REG37, 0x21);
+	snd_soc_write(codec, ES8374_MONO_MIX_REG1A, 0x08);
+	snd_soc_write(codec, ES8374_SPK_MIX_REG1C, 0x10);
+	snd_soc_write(codec, ES8374_SPK_MIX_GAIN_REG1D, 0x10);
+	snd_soc_write(codec, ES8374_SPK_OUT_GAIN_REG1E, 0x40);
+	snd_soc_update_bits(codec, ES8374_AIN_PWR_SRC_REG21, 0xc0, 0xc0);
+	snd_soc_write(codec, ES8374_ANA_PWR_CTL_REG15, 0xbf);
+	snd_soc_write(codec, ES8374_ANA_REF_REG14, 0x14);
+	snd_soc_write(codec, ES8374_CLK_MANAGEMENT_REG01, 0x03);
+
+	return;
+}
+
+static int es8374_i2c_probe(struct i2c_client *i2c_client,
+		const struct i2c_device_id *id)
+{
+	struct es8374_private *es8374;
+	int ret = -1;
+
+	es8374 = kzalloc(sizeof(*es8374), GFP_KERNEL);
+	if (es8374 == NULL)
+		return -ENOMEM;
+
+	es8374->control_type = SND_SOC_I2C;
+	es8374->i2c = i2c_client;
+
+	i2c_set_clientdata(i2c_client, es8374);
+	es8374->regmap = devm_regmap_init_i2c(i2c_client, &es8374_regmap);
+	if (IS_ERR(es8374->regmap)) {
+		ret = PTR_ERR(es8374->regmap);
+		dev_err(&i2c_client->dev, "regmap_init() failed: %d\n", ret);
+		return ret;
+	}
+
+	es8374_data = es8374;
+
+	ret =  snd_soc_register_codec(&i2c_client->dev, &soc_codec_dev_es8374,
+			&es8374_dai[0], ARRAY_SIZE(es8374_dai));
+	if (ret < 0) {
+		kfree(es8374);
+		return ret;
+	}
+
+	return ret;
+}
+
+static  int es8374_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	kfree(i2c_get_clientdata(client));
+	return 0;
+}
+
+static const struct i2c_device_id es8374_i2c_id[] = {
+	{"es8374", 0 },
+	{"10ES8374:00", 0},
+	{"10ES8374", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, es8374_i2c_id);
+
+static struct i2c_driver es8374_i2c_driver = {
+	.driver = {
+		.name	= "es8374",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(es8374_if_dt_ids),
+#endif
+	},
+	.shutdown	= es8374_i2c_shutdown,
+	.probe	= es8374_i2c_probe,
+	.remove	= es8374_i2c_remove,
+	.id_table	= es8374_i2c_id,
+};
+#endif
+
+static int __init es8374_init(void)
+{
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	return i2c_add_driver(&es8374_i2c_driver);
+#endif
+#ifdef ES8374_SPI
+	return spi_register_driver(&es8374_spi_driver);
+#endif
+}
+
+static void __exit es8374_exit(void)
+{
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	return i2c_del_driver(&es8374_i2c_driver);
+#endif
+#ifdef ES8374_SPI
+	return spi_unregister_driver(&es8374_spi_driver);
+#endif
+}
+
+module_init(es8374_init);
+module_exit(es8374_exit);
+
+MODULE_DESCRIPTION("ASoC es8374 driver");
+MODULE_AUTHOR("XianqingZheng <xqzheng@ambarella.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/sound/soc/codecs/es8374.h b/sound/soc/codecs/es8374.h
new file mode 100644
index 0000000..0d42700
--- /dev/null
+++ b/sound/soc/codecs/es8374.h
@@ -0,0 +1,151 @@
+/*
+* ES8374.h  --  ES8374 ALSA SoC Audio Codec
+*
+*
+*
+* Authors:
+*
+* Based on ES8374.h by David Yang
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*/
+
+#ifndef _ES8374_H
+#define _ES8374_H
+
+/*       THE REGISTER DEFINITION FORMAT            */
+/*
+*	ES8374_REGISTER NAME_REG_REGISTER ADDRESS
+*/
+#define ES8374_RESET_REG00			0x00  /* this register is used to reset digital,csm,clock manager etc.*/
+
+/*
+* Clock Scheme Register definition
+*/
+#define ES8374_CLK_MANAGEMENT_REG01		0x01 /* The register is used to turn on/off the clock for ADC, DAC, MCLK, BCLK and CLASS D */
+#define ES8374_CLK_MANAGEMENT_REG02		0x02 /* ADC, PLL clock */
+
+
+#define ES8374_ADC_OSR_REG03			0x03 /* The ADC OSR setting */
+#define ES8374_DAC_FLT_CNT_REG04		0x04 /* The DAC filter counter waiting cycles control */
+#define ES8374_CLK_DIV_REG05			0x05 /* ADC&DAC internal mclk Divider */
+#define ES8374_LRCK_DIV_REG06			0x06 /* The  LRCK divider */
+#define ES8374_LRCK_DIV_REG07			0x07
+#define ES8374_CLASS_D_DIV_REG08		0x08 /* Class D clock divider */
+/*
+* PLL control register definition
+*/
+#define ES8374_PLL_CONTROL1_REG09		0x09 /* Register 0x09 for PLL reset, power up/down, dither and divider settting */
+#define ES8374_PLL_CONTROL2_REG0A		0x0A /* Register 0x0A for PLL low power, gain, supply voltage and  vco setting */
+#define ES8374_PLL_N_REG0B			0x0B /* Register 0x0B for N and pll calibrate */
+#define ES8374_PLL_K_REG0C			0x0C /* Register 0x0C - 0x0E for PLLK */
+#define ES8374_PLL_K_REG0D			0x0D
+#define ES8374_PLL_K_REG0E			0x0E
+/*
+*	The serial digital audio port
+*/
+#define ES8374_MS_BCKDIV_REG0F			0x0F /* The setting for Master/Slave mode and BCLK divider */
+#define ES8374_ADC_FMT_REG10			0x10 /* ADC Format	*/
+#define ES8374_DAC_FMT_REG11			0x11 /* DAC Format	*/
+
+/*
+*	The system Control
+*/
+#define ES8374_CHP_INI_REG12			0x12 /* The time control for chip initialization	*/
+#define ES8374_POWERUP_REG13			0x13 /* The time control for power up	*/
+/*
+*	The analog control
+*/
+#define ES8374_ANA_REF_REG14			0x14 /* The analog reference */
+#define ES8374_ANA_PWR_CTL_REG15		0x15 /* The analog power up/down */
+#define ES8374_ANA_LOW_PWR_REG16		0x16 /* Low power setting*/
+#define ES8374_ANA_REF_LP_REG17			0x17 /* Reference and low power setting */
+#define ES8374_ANA_BIAS_REG18		  	0x18 /* Bias selecting */
+/*
+*	MONO OUT
+*/
+#define ES8374_MONO_MIX_REG1A			0x1A /* MonoMixer */
+#define ES8374_MONO_GAIN_REG1B			0x1B /* Mono Out Gain */
+/*
+* SPEAKER OUT
+*/
+#define ES8374_SPK_MIX_REG1C			0x1C /* Speaker Mixer */
+#define ES8374_SPK_MIX_GAIN_REG1D		0x1D /* Speaker Mixer Gain */
+#define ES8374_SPK_OUT_GAIN_REG1E		0x1E /* Speaker Output Gain */
+#define ES8374_SPK_CTL_REG1F		 	 0x1F /* Speaker control */
+#define ES8374_SPK_CTL_REG20		  	0x20 /* Speaker control */
+/*
+* Analog In
+*/
+#define ES8374_AIN_PWR_SRC_REG21		0x21 /* Power control and source selecting for AIN*/
+#define ES8374_AIN_PGA_REG22		  	0x22 /* AIN PGA Gain Control */
+/*
+*	ADC Control
+*/
+#define ES8374_ADC_CONTROL_REG24		0x24 /* adc and DMIC Setting */
+#define ES8374_ADC_VOLUME_REG25			0x25 /* adc volume */
+/*
+* ADC ALC
+*/
+#define ES8374_ALC_EN_MAX_GAIN_REG26		0x26 /* adc alc enable and max gain setting */
+#define ES8374_ALC_MIN_GAIN_REG27		0x27 /* ADC Alc min gain */
+#define ES8374_ALC_LVL_HLD_REG28		0x28 /* alc level and hold time control */
+#define ES8374_ALC_DCY_ATK_REG29		0x29 /* ALC DCY and ATK time control */
+#define ES8374_ALC_WIN_SIZE_REG2A		0x2A /* ALC WIN Size */
+#define ES8374_ALC_NGTH_REG2B		 	0x2B /* alc noise gate setting */
+/*
+*	ADC HPF setting
+*/
+#define ES8374_ADC_HPF_REG2C		    	0x2C /* The high pass filter coefficient*/
+/*
+*	Equalizer SRC setting
+*/
+#define ES8374_EQ_SRC_REG2D			0x2D /* adc src, dac src and EQ SRC setting */
+
+/*
+* ADC 1st shelving filter
+*/
+#define ES8374_ADC_SHV_A_REG2E		 	0x2E /* adc shelving A*/
+#define ES8374_ADC_SHV_A_REG2F		  	0x2F
+#define ES8374_ADC_SHV_A_REG30		 	0x30
+#define ES8374_ADC_SHV_A_REG31			0x31
+
+#define ES8374_ADC_SHV_B_REG32		 	0x32 /* ADC Shelving B*/
+#define ES8374_ADC_SHV_B_REG33		  	0x33
+#define ES8374_ADC_SHV_B_REG34		  	0x34
+#define ES8374_ADC_SHV_B_REG35			0x35
+
+/*
+* DAC control
+*/
+#define ES8374_DAC_CONTROL_REG36		0x36 /* dac control1 */
+#define ES8374_DAC_CONTROL_REG37		0x37 /* dac control2 */
+
+#define ES8374_DAC_VOLUME_REG38		    	0x38 /* dac volume */
+#define ES8374_DAC_OFFSET_REG39			0x39 /* DAC offset */
+
+/*
+* DAC 2nd shleving filter
+*/
+/* register 0x3A to 0x44 is for dac shelving filter */
+/*
+* Equalizer coeffient
+*/
+/* register 0x45 to 0x6c is for 2nd equalizer filter, this filter can be shared by DAC and ADC */
+
+#define ES8374_GPIO_INSERT_REG6D	    	0x6D /* GPIO & HP INSERT CONTROL */
+#define ES8374_FLAG_REG6E	  		0x6E /* Flag register */
+
+/* The End Of Register definition */
+
+#define ES8374_PLL			1
+#define ES8374_PLL_SRC_FRM_MCLK		1
+
+#define ES8374_CLKID_MCLK		0
+#define ES8374_CLKID_PLLO		1
+
+#define ES8374_MAX_REGISTER		128
+
+#endif
diff --git a/sound/soc/codecs/es8388.c b/sound/soc/codecs/es8388.c
index 47eb393..164141c 100644
--- a/sound/soc/codecs/es8388.c
+++ b/sound/soc/codecs/es8388.c
@@ -250,8 +250,10 @@ static const struct soc_enum monomux =
 static const struct snd_kcontrol_new es8388_monomux_controls =
 	SOC_DAPM_VALUE_ENUM("Route", monomux);
 
+#if 0
 static const struct snd_kcontrol_new adc_switch_ctl =
 SOC_DAPM_SINGLE("Switch",ES8388_ADCCONTROL7, 2, 1, 1);
+#endif
 
 static const struct snd_soc_dapm_widget es8388_dapm_widgets[] = {
 	/* DAC Part */
diff --git a/sound/soc/codecs/mc13783.c b/sound/soc/codecs/mc13783.c
index 8a8d936..d0fc215 100644
--- a/sound/soc/codecs/mc13783.c
+++ b/sound/soc/codecs/mc13783.c
@@ -604,14 +604,14 @@ static int mc13783_probe(struct snd_soc_codec *codec)
 				AUDIO_SSI_SEL, 0);
 	else
 		mc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_CODEC,
-				0, AUDIO_SSI_SEL);
+				AUDIO_SSI_SEL, AUDIO_SSI_SEL);
 
 	if (priv->dac_ssi_port == MC13783_SSI1_PORT)
 		mc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_DAC,
 				AUDIO_SSI_SEL, 0);
 	else
 		mc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_DAC,
-				0, AUDIO_SSI_SEL);
+				AUDIO_SSI_SEL, AUDIO_SSI_SEL);
 
 	mc13xxx_unlock(priv->mc13xxx);
 
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index 3b5f565..665e0dd 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -1111,13 +1111,7 @@ static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)
 		/* Enable VDDC charge pump */
 		ana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;
 	} else if (vddio >= 3100 && vdda >= 3100) {
-		/*
-		 * if vddio and vddd > 3.1v,
-		 * charge pump should be clean before set ana_pwr
-		 */
-		snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,
-				SGTL5000_VDDC_CHRGPMP_POWERUP, 0);
-
+		ana_pwr &= ~SGTL5000_VDDC_CHRGPMP_POWERUP;
 		/* VDDC use VDDIO rail */
 		lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
 		lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<
diff --git a/sound/soc/codecs/tas5086.c b/sound/soc/codecs/tas5086.c
index d447c4a..675a8fd 100644
--- a/sound/soc/codecs/tas5086.c
+++ b/sound/soc/codecs/tas5086.c
@@ -173,7 +173,7 @@ static int tas5086_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.enumerated.item[0] = priv->deemph;
+	ucontrol->value.integer.value[0] = priv->deemph;
 
 	return 0;
 }
@@ -184,7 +184,7 @@ static int tas5086_put_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);
 
-	priv->deemph = ucontrol->value.enumerated.item[0];
+	priv->deemph = ucontrol->value.integer.value[0];
 
 	return tas5086_set_deemph(codec);
 }
diff --git a/sound/soc/codecs/tlv320adc3xxx_amb.c b/sound/soc/codecs/tlv320adc3xxx_amb.c
new file mode 100644
index 0000000..a914fdd
--- /dev/null
+++ b/sound/soc/codecs/tlv320adc3xxx_amb.c
@@ -0,0 +1,1215 @@
+/*
+ * sound/soc/codecs/tlv320adc3xxx_amb.c
+ *
+ * Author: Dongge wu <dgwu@ambarella.com>
+ *
+ * History:
+ *	2015/10/28 - [Dongge wu] Created file
+ *
+ * Copyright (C) 2014-2018, Ambarella, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+
+/***************************** INCLUDES ************************************/
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "tlv320adc3xxx_amb.h"
+
+/*
+ * ****************************************************************************
+ *  Macros
+ * ****************************************************************************
+ *
+ */
+
+
+/* codec private data */
+struct adc3xxx_priv {
+	void *control_data;
+	unsigned int rst_pin;
+	unsigned int rst_active;
+	unsigned int sysclk;
+	int master;
+	u8 page_no;
+};
+
+static int adc3xxx_set_bias_level(struct snd_soc_codec *,
+				  enum snd_soc_bias_level);
+/*
+ * ADC3xxx register cache
+ * We can't read the ADC3xxx register space when we are
+ * using 2 wire for device control, so we cache them instead.
+ * There is no point in caching the reset register
+ */
+static const u8 adc3xxx_reg[ADC3xxx_CACHEREGNUM] = {
+	0x00, 0x00, 0x00, 0x00,	/* 0 */
+	0x00, 0x11, 0x04, 0x00,	/* 4 */
+	0x00, 0x00, 0x00, 0x00,	/* 8 */
+	0x00, 0x00, 0x00, 0x00,	/* 12 */
+	0x00, 0x00, 0x01, 0x01,	/* 16 */
+	0x80, 0x80, 0x04, 0x00,	/* 20 */
+	0x00, 0x00, 0x01, 0x00,	/* 24 */
+	0x00, 0x02, 0x01, 0x00,	/* 28 */
+	0x00, 0x10, 0x00, 0x00,	/* 32 */
+	0x00, 0x00, 0x02, 0x00,	/* 36 */
+	0x00, 0x00, 0x00, 0x00,	/* 40 */
+	0x00, 0x00, 0x00, 0x00,	/* 44 */
+	0x00, 0x00, 0x00, 0x00,	/* 48 */
+	0x00, 0x12, 0x00, 0x00,	/* 52 */
+	0x00, 0x00, 0x00, 0x44,	/* 56 */
+	0x00, 0x01, 0x00, 0x00,	/* 60 */
+	0x00, 0x00, 0x00, 0x00,	/* 64 */
+	0x00, 0x00, 0x00, 0x00,	/* 68 */
+	0x00, 0x00, 0x00, 0x00,	/* 72 */
+	0x00, 0x00, 0x00, 0x00,	/* 76 */
+	0x00, 0x00, 0x88, 0x00,	/* 80 */
+	0x00, 0x00, 0x00, 0x00,	/* 84 */
+	0x7F, 0x00, 0x00, 0x00,	/* 88 */
+	0x00, 0x00, 0x00, 0x00,	/* 92 */
+	0x7F, 0x00, 0x00, 0x00,	/* 96 */
+	0x00, 0x00, 0x00, 0x00,	/* 100 */
+	0x00, 0x00, 0x00, 0x00,	/* 104 */
+	0x00, 0x00, 0x00, 0x00,	/* 108 */
+	0x00, 0x00, 0x00, 0x00,	/* 112 */
+	0x00, 0x00, 0x00, 0x00,	/* 116 */
+	0x00, 0x00, 0x00, 0x00,	/* 120 */
+	0x00, 0x00, 0x00, 0x00,	/* 124 - PAGE0 Registers(127) ends here */
+	0x00, 0x00, 0x00, 0x00,	/* 128, PAGE1-0 */
+	0x00, 0x00, 0x00, 0x00,	/* 132, PAGE1-4 */
+	0x00, 0x00, 0x00, 0x00,	/* 136, PAGE1-8 */
+	0x00, 0x00, 0x00, 0x00,	/* 140, PAGE1-12 */
+	0x00, 0x00, 0x00, 0x00,	/* 144, PAGE1-16 */
+	0x00, 0x00, 0x00, 0x00,	/* 148, PAGE1-20 */
+	0x00, 0x00, 0x00, 0x00,	/* 152, PAGE1-24 */
+	0x00, 0x00, 0x00, 0x00,	/* 156, PAGE1-28 */
+	0x00, 0x00, 0x00, 0x00,	/* 160, PAGE1-32 */
+	0x00, 0x00, 0x00, 0x00,	/* 164, PAGE1-36 */
+	0x00, 0x00, 0x00, 0x00,	/* 168, PAGE1-40 */
+	0x00, 0x00, 0x00, 0x00,	/* 172, PAGE1-44 */
+	0x00, 0x00, 0x00, 0x00,	/* 176, PAGE1-48 */
+	0xFF, 0x00, 0x3F, 0xFF,	/* 180, PAGE1-52 */
+	0x00, 0x3F, 0x00, 0x80,	/* 184, PAGE1-56 */
+	0x80, 0x00, 0x00, 0x00,	/* 188, PAGE1-60 */
+};
+
+/*
+ * adc3xxx initialization data
+ * This structure initialization contains the initialization required for
+ * ADC3xxx.
+ * These registers values (reg_val) are written into the respective ADC3xxx
+ * register offset (reg_offset) to  initialize ADC3xxx.
+ * These values are used in adc3xxx_init() function only.
+ */
+struct adc3xxx_configs {
+	u8 reg_offset;
+	u8 reg_val;
+};
+
+/* The global Register Initialization sequence Array. During the Audio Driver
+ * Initialization, this array will be utilized to perform the default
+ * initialization of the audio Driver.
+ */
+static const struct adc3xxx_configs adc3xxx_reg_init[] = {
+	/* Select IN1L/IN1R Single Ended (0dB) inputs
+	 * use value 10 for no connection, this enables dapm
+	 * to switch ON/OFF inputs using MS Bit only.
+	 * with this setup, -6dB input option is not used.
+	 */
+	{LEFT_PGA_SEL_1, 0xA8},
+	{LEFT_PGA_SEL_2, 0x37},
+	{RIGHT_PGA_SEL_1, 0x28},
+	/* mute Left PGA + default gain */
+	{LEFT_APGA_CTRL, 0xc6},
+	/* mute Right PGA + default gain */
+	{RIGHT_APGA_CTRL, 0xc6},
+	{LEFT_CHN_AGC_1, 0x80},
+	{RIGHT_CHN_AGC_1, 0x80},
+	/* MICBIAS1=2.5V, MICBIAS2=2.5V */
+	{MICBIAS_CTRL, 0x50},
+	/* Use PLL for generating clocks from MCLK */
+	{CLKGEN_MUX, USE_PLL},
+	/* I2S, 16LE, codec as Master */
+	{INTERFACE_CTRL_1, 0x0C},
+	/*BDIV_CLKIN = ADC_CLK, BCLK & WCLK active when power-down */
+	{INTERFACE_CTRL_2, 0x02},
+
+	#ifdef ADC3101_CODEC_SUPPORT
+	/* Use Primary BCLK and WCLK */
+	{INTERFACE_CTRL_4, 0x0},
+	#endif
+
+	/* Left AGC Maximum Gain to 40db */
+	{LEFT_CHN_AGC_3, 0x50},
+	/* Right AGC Maximum Gain to 40db */
+	{RIGHT_CHN_AGC_3, 0X50},
+	/* ADC control, Gain soft-stepping disabled */
+	{ADC_DIGITAL, 0x02},
+	/* Fine Gain 0dB, Left/Right ADC Unmute */
+	{ADC_FGA, 0x00},
+
+	#ifdef ADC3101_CODEC_SUPPORT
+	/* DMCLK output = ADC_MOD_CLK */
+	{GPIO2_CTRL, 0x28},
+	/* DMDIN is in Dig_Mic_In mode */
+	{GPIO1_CTRL, 0x04},
+	#endif
+};
+
+/*
+ * PLL and Clock settings
+ */
+static const struct adc3xxx_rate_divs adc3xxx_divs[] = {
+	/*  mclk, rate, p, r, j, d, nadc, madc, aosr, bdiv */
+	/* 8k rate */
+	{12288000, 8000, 1, 1, 7, 0000, 42, 2, 128, 8, 188},
+	/* 11.025k rate */
+	//{12000000, 11025, 1, 1, 6, 8208, 29, 2, 128, 8, 188},
+	/* 16k rate */
+	{12288000, 16000, 1, 1, 7, 0000, 21, 2, 128, 8, 188},
+	/* 22.05k rate */
+	//{12000000, 22050, 1, 1, 7, 560, 15, 2, 128, 8, 188},
+	/* 32k rate */
+	{12288000, 32000, 1, 1, 8, 0000, 12, 2, 128, 8, 188},
+	/* 44.1k rate */
+	//{12000000, 44100, 1, 1, 7, 5264, 8, 2, 128, 8, 188},
+	/* 48k rate */
+	{12288000, 48000, 1, 1, 7, 0000, 7, 2, 128, 8, 188},
+	/* 88.2k rate */
+	//{12000000, 88200, 1, 1, 7, 5264, 4, 4, 64, 8, 188},
+	/* 96k rate */
+	//{12000000, 96000, 1, 1, 8, 1920, 4, 4, 64, 8, 188},
+};
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_get_divs
+ * Purpose  : This function is to get required divisor from the "adc3xxx_divs"
+ *            table.
+ *
+ *----------------------------------------------------------------------------
+ */
+static inline int adc3xxx_get_divs(int mclk, int rate)
+{
+	int i;
+
+	printk(KERN_INFO "adc3xxx_get_divs mclk = %d, rate = %d\n", mclk, rate);
+	for (i = 0; i < ARRAY_SIZE(adc3xxx_divs); i++) {
+		if ((adc3xxx_divs[i].rate == rate)
+		    && (adc3xxx_divs[i].mclk == mclk)) {
+			return i;
+		}
+	}
+
+	printk("Master clock and sample rate is not supported\n");
+	return -EINVAL;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_change_page
+ * Purpose  : This function is to switch between page 0 and page 1.
+ *
+ *----------------------------------------------------------------------------
+ */
+int adc3xxx_change_page(struct snd_soc_codec *codec, u8 new_page)
+{
+	struct adc3xxx_priv *adc3xxx = snd_soc_codec_get_drvdata(codec);
+
+	if (i2c_smbus_write_byte_data(codec->control_data, 0x0, new_page) < 0) {
+		printk("adc3xxx_change_page: I2C Wrte Error\n");
+		return -1;
+	}
+	adc3xxx->page_no = new_page;
+	return 0;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_write_reg_cache
+ * Purpose  : This function is to write adc3xxx register cache
+ *
+ *----------------------------------------------------------------------------
+ */
+static inline void adc3xxx_write_reg_cache(struct snd_soc_codec *codec,
+					   unsigned int reg, unsigned int value)
+{
+	u8 *cache = codec->reg_cache;
+	if (reg >= ADC3xxx_CACHEREGNUM)
+		return;
+	cache[reg] = value & 0xFF;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_read_reg_cache
+ * Purpose  : This function is to read adc3xxx register cache
+ *
+ *----------------------------------------------------------------------------
+ */
+static inline unsigned int adc3xxx_read_reg_cache(struct snd_soc_codec *codec,
+						  unsigned int reg)
+{
+	u8 *cache = codec->reg_cache;
+	if (reg >= ADC3xxx_CACHEREGNUM)
+		return -1;
+	return cache[reg];
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_write
+ * Purpose  : This function is to write to the adc3xxx register space.
+ *
+ *----------------------------------------------------------------------------
+ */
+int adc3xxx_write(struct snd_soc_codec *codec, unsigned int reg,
+		  unsigned int value)
+{
+	struct adc3xxx_priv *adc3xxx = snd_soc_codec_get_drvdata(codec);
+	u8 data[2];
+	u8 page;
+
+	page = reg / ADC3xxx_PAGE_SIZE;
+
+	if (adc3xxx->page_no != page) {
+		adc3xxx_change_page(codec, page);
+	}
+
+	/* data is
+	 *   D15..D8 adc3xxx register offset
+	 *   D7...D0 register data
+	 */
+	data[0] = reg % ADC3xxx_PAGE_SIZE;
+	data[1] = value & 0xFF;
+
+	if (i2c_smbus_write_byte_data(codec->control_data, data[0], data[1]) < 0) {
+		printk("adc3xxx_write: I2C write Error\n");
+		return -EIO;
+	}
+
+	/* Update register cache */
+	if ((page == 0) || (page == 1)) {
+		adc3xxx_write_reg_cache(codec, reg, data[1]);
+	}
+	return 0;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_read
+ * Purpose  : This function is to read the adc3xxx register space.
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	struct adc3xxx_priv *adc3xxx = snd_soc_codec_get_drvdata(codec);
+	u8 value, page;
+
+	page = reg / ADC3xxx_PAGE_SIZE;
+	if (adc3xxx->page_no != page) {
+		adc3xxx_change_page(codec, page);
+	}
+
+	/* write register address */
+	reg = reg % ADC3xxx_PAGE_SIZE;
+
+	/*  read register value */
+	value = i2c_smbus_read_word_data(codec->control_data, reg);
+	if (value < 0) {
+		printk("adc3xxx_read: I2C read Error\n");
+		return -EIO;
+	}
+
+	/* Update register cache */
+	if ((page == 0) || (page == 1)) {
+		adc3xxx_write_reg_cache(codec, reg, value);
+	}
+	return value;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : snd_soc_adc3xxx_put_volsw
+ * Purpose  : Callback to set the value of a mixer control.
+ *
+ *----------------------------------------------------------------------------
+ */
+static int snd_soc_adc3xxx_put_volsw(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	s8 val1, val2;
+	u8 reg;
+
+	val1 = ucontrol->value.integer.value[0];
+	val2 = ucontrol->value.integer.value[1];
+
+	if ((val1 >= ADC_POS_VOL)) {
+		if (val1 > ADC_MAX_VOLUME)
+			val1 = ADC_MAX_VOLUME;
+		val1 = val1 - ADC_POS_VOL;
+	} else if ((val1 >= 0) && (val1 <= 23)) {
+		val1 = ADC_POS_VOL - val1;
+		val1 = 128 - val1;
+	} else
+		return -EINVAL;
+
+	if (val2 >= ADC_POS_VOL) {
+		if (val2 > ADC_MAX_VOLUME)
+			val2 = ADC_MAX_VOLUME;
+		val2 = val2 - ADC_POS_VOL;
+	} else if ((val2 >= 0) && (val2 <= 23)) {
+		val2 = ADC_POS_VOL - val2;
+		val2 = 128 - val2;
+	} else
+		return -EINVAL;
+
+	reg = adc3xxx_read_reg_cache(codec, LADC_VOL) & (~0x7F);
+	adc3xxx_write(codec, LADC_VOL, reg | (val1 << 0));
+	reg = adc3xxx_read_reg_cache(codec, RADC_VOL) & (~0x7F);
+	adc3xxx_write(codec, RADC_VOL, reg | (val2 << 0));
+
+	return 0;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : snd_soc_adc3xxx_get_volsw
+ * Purpose  : Callback to get the value of a mixer control.
+ *
+ *----------------------------------------------------------------------------
+ */
+static int snd_soc_adc3xxx_get_volsw(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	u8 val1;
+	u8 val2;
+
+	val1 = adc3xxx_read_reg_cache(codec, LADC_VOL) & (0x7F);
+	if ((val1 >= 0) && (val1 <= 40)) {
+		val1 = val1 + ADC_POS_VOL;
+	} else if ((val1 >= 104) && (val1 <= 127)) {
+		val1 = val1 - 104;
+	} else
+		return -EINVAL;
+
+	val2 = adc3xxx_read_reg_cache(codec, RADC_VOL) & (0x7F);
+	if ((val2 >= 0) && (val2 <= 40)) {
+		val2 = val2 + ADC_POS_VOL;
+	} else if ((val2 >= 104) && (val2 <= 127)) {
+		val2 = val2 - 104;
+	} else
+		return -EINVAL;
+
+	ucontrol->value.integer.value[0] = val1;
+	ucontrol->value.integer.value[1] = val2;
+	return 0;
+
+}
+
+#define SOC_ADC3xxx_DOUBLE_R(xname, reg_left, reg_right, xshift, xmax, xinvert) \
+{       .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
+        .get = snd_soc_adc3xxx_get_volsw, .put = snd_soc_adc3xxx_put_volsw, \
+        .private_value = (unsigned long)&(struct soc_mixer_control) \
+                {.reg = reg_left, .rreg = reg_right, .shift = xshift, \
+                .max = xmax, .invert = xinvert} }
+
+static const char *micbias_voltage[] = { "off", "2V", "2.5V", "AVDD" };
+static const char *linein_attenuation[] = { "0db", "-6db" };
+static const char *adc_softstepping[] = { "1 step", "2 step", "off" };
+
+#define MICBIAS1_ENUM		0
+#define MICBIAS2_ENUM		1
+#define ATTLINEL1_ENUM		2
+#define ATTLINEL2_ENUM		3
+#define ATTLINEL3_ENUM		4
+#define ATTLINER1_ENUM		5
+#define ATTLINER2_ENUM		6
+#define ATTLINER3_ENUM		7
+#define ADCSOFTSTEP_ENUM	8
+
+/* Creates an array of the Single Ended Widgets*/
+static const struct soc_enum adc3xxx_enum[] = {
+	SOC_ENUM_SINGLE(MICBIAS_CTRL, 5, 4, micbias_voltage),
+	SOC_ENUM_SINGLE(MICBIAS_CTRL, 3, 4, micbias_voltage),
+	SOC_ENUM_SINGLE(LEFT_PGA_SEL_1, 0, 2, linein_attenuation),
+	SOC_ENUM_SINGLE(LEFT_PGA_SEL_1, 2, 2, linein_attenuation),
+	SOC_ENUM_SINGLE(LEFT_PGA_SEL_1, 4, 2, linein_attenuation),
+	SOC_ENUM_SINGLE(RIGHT_PGA_SEL_1, 0, 2, linein_attenuation),
+	SOC_ENUM_SINGLE(RIGHT_PGA_SEL_1, 2, 2, linein_attenuation),
+	SOC_ENUM_SINGLE(RIGHT_PGA_SEL_1, 4, 2, linein_attenuation),
+	SOC_ENUM_SINGLE(ADC_DIGITAL, 0, 3, adc_softstepping),
+};
+
+/* Various Controls For adc3xxx */
+static const struct snd_kcontrol_new adc3xxx_snd_controls[] = {
+	/* PGA Gain Volume Control */
+	SOC_DOUBLE_R("PGA Gain Volume Control (0=0dB, 80=40dB)",
+		    LEFT_APGA_CTRL, RIGHT_APGA_CTRL, 0, 0x50, 0),
+	/* Audio gain control (AGC) */
+	SOC_DOUBLE_R("Audio Gain Control (AGC)", LEFT_CHN_AGC_1,
+		     RIGHT_CHN_AGC_1, 7, 0x01, 0),
+	/* AGC Target level control */
+	SOC_DOUBLE_R("AGC Target Level Control", LEFT_CHN_AGC_1,
+		     RIGHT_CHN_AGC_1, 4, 0x07, 1),
+	/* AGC Maximum PGA applicable */
+	SOC_DOUBLE_R("AGC Maximum PGA Control", LEFT_CHN_AGC_3,
+		     RIGHT_CHN_AGC_3, 0, 0x50, 0),
+	/* AGC Attack Time control */
+	SOC_DOUBLE_R("AGC Attack Time control", LEFT_CHN_AGC_4,
+		     RIGHT_CHN_AGC_4, 3, 0x1F, 0),
+	/* AGC Decay Time control */
+	SOC_DOUBLE_R("AGC Decay Time control", LEFT_CHN_AGC_5,
+		     RIGHT_CHN_AGC_5, 3, 0x1F, 0),
+	/* AGC Noise Bounce control */
+	SOC_DOUBLE_R("AGC Noise bounce control", LEFT_CHN_AGC_6,
+		     RIGHT_CHN_AGC_6, 0, 0x1F, 0),
+	/* AGC Signal Bounce control */
+	SOC_DOUBLE_R("AGC Signal bounce control", LEFT_CHN_AGC_7,
+		     RIGHT_CHN_AGC_7, 0, 0x0F, 0),
+	/* Mic Bias voltage */
+	SOC_ENUM("Mic Bias 1 Voltage", adc3xxx_enum[MICBIAS1_ENUM]),
+	SOC_ENUM("Mic Bias 2 Voltage", adc3xxx_enum[MICBIAS2_ENUM]),
+	/* ADC soft stepping */
+	SOC_ENUM("ADC soft stepping", adc3xxx_enum[ADCSOFTSTEP_ENUM]),
+	/* Left/Right Input attenuation */
+	SOC_ENUM("Left Linein1 input attenuation",
+		 adc3xxx_enum[ATTLINEL1_ENUM]),
+	SOC_ENUM("Left Linein2 input attenuation",
+		 adc3xxx_enum[ATTLINEL2_ENUM]),
+	SOC_ENUM("Left Linein3 input attenuation",
+		 adc3xxx_enum[ATTLINEL3_ENUM]),
+	SOC_ENUM("Right Linein1 input attenuation",
+		 adc3xxx_enum[ATTLINER1_ENUM]),
+	SOC_ENUM("Right Linein2 input attenuation",
+		 adc3xxx_enum[ATTLINER2_ENUM]),
+	SOC_ENUM("Right Linein3 input attenuation",
+		 adc3xxx_enum[ATTLINER3_ENUM]),
+	/* ADC Volume */
+	SOC_ADC3xxx_DOUBLE_R("ADC Volume Control (0=-12dB, 64=+20dB)", LADC_VOL,
+		 RADC_VOL, 0, 64,0),
+	/* ADC Fine Volume */
+	SOC_SINGLE("Left ADC Fine Volume (0=-0.4dB, 4=0dB)", ADC_FGA, 4, 4, 1),
+	SOC_SINGLE("Right ADC Fine Volume (0=-0.4dB, 4=0dB)", ADC_FGA, 0, 4, 1),
+};
+
+/* Left input selection, Single Ended inputs and Differential inputs */
+static const struct snd_kcontrol_new left_input_mixer_controls[] = {
+	SOC_DAPM_SINGLE("IN1_L switch", LEFT_PGA_SEL_1, 1, 0x1, 1),
+	SOC_DAPM_SINGLE("IN2_L switch", LEFT_PGA_SEL_1, 3, 0x1, 1),
+	SOC_DAPM_SINGLE("IN3_L switch", LEFT_PGA_SEL_1, 5, 0x1, 1),
+	SOC_DAPM_SINGLE("DIF1_L switch", LEFT_PGA_SEL_1, 7, 0x1, 1),
+	SOC_DAPM_SINGLE("DIF2_L switch", LEFT_PGA_SEL_2, 5, 0x1, 1),
+	SOC_DAPM_SINGLE("DIF3_L switch", LEFT_PGA_SEL_2, 3, 0x1, 1), //DIF3_L
+	SOC_DAPM_SINGLE("IN1_R switch", LEFT_PGA_SEL_2, 1, 0x1, 1),
+};
+
+/* Right input selection, Single Ended inputs and Differential inputs */
+static const struct snd_kcontrol_new right_input_mixer_controls[] = {
+	SOC_DAPM_SINGLE("IN1_R switch", RIGHT_PGA_SEL_1, 1, 0x1, 1),
+	SOC_DAPM_SINGLE("IN2_R switch", RIGHT_PGA_SEL_1, 3, 0x1, 1),
+	SOC_DAPM_SINGLE("IN3_R switch", RIGHT_PGA_SEL_1, 5, 0x1, 1),
+	SOC_DAPM_SINGLE("DIF1_R switch", RIGHT_PGA_SEL_1, 7, 0x1, 1), // DIF1_R
+	SOC_DAPM_SINGLE("DIF2_R switch", RIGHT_PGA_SEL_2, 5, 0x1, 1),
+	SOC_DAPM_SINGLE("DIF3_R switch", RIGHT_PGA_SEL_2, 3, 0x1, 1),
+	SOC_DAPM_SINGLE("IN1_L switch", RIGHT_PGA_SEL_2, 1, 0x1, 1),
+};
+
+/* Left Digital Mic input for left ADC */
+static const struct snd_kcontrol_new left_input_dmic_controls[] = {
+	SOC_DAPM_SINGLE("Left ADC switch", ADC_DIGITAL, 3, 0x1, 0),
+};
+
+/* Right Digital Mic input for Right ADC */
+static const struct snd_kcontrol_new right_input_dmic_controls[] = {
+	SOC_DAPM_SINGLE("Right ADC switch", ADC_DIGITAL, 2, 0x1, 0),
+};
+
+/* adc3xxx Widget structure */
+static const struct snd_soc_dapm_widget adc3xxx_dapm_widgets[] = {
+
+	/* Left Input Selection */
+	SND_SOC_DAPM_MIXER("Left Input Selection", SND_SOC_NOPM, 0, 0,
+			   &left_input_mixer_controls[0],
+			   ARRAY_SIZE(left_input_mixer_controls)),
+	/* Right Input Selection */
+	SND_SOC_DAPM_MIXER("Right Input Selection", SND_SOC_NOPM, 0, 0,
+			   &right_input_mixer_controls[0],
+			   ARRAY_SIZE(right_input_mixer_controls)),
+	/*PGA selection */
+	SND_SOC_DAPM_PGA("Left PGA", LEFT_APGA_CTRL, 7, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Right PGA", RIGHT_APGA_CTRL, 7, 1, NULL, 0),
+
+	/*Digital Microphone Input Control for Left/Right ADC */
+	SND_SOC_DAPM_MIXER("Left DMic Input", SND_SOC_NOPM, 0, 0,
+			&left_input_dmic_controls[0],
+			ARRAY_SIZE(left_input_dmic_controls)),
+	SND_SOC_DAPM_MIXER("Right DMic Input", SND_SOC_NOPM , 0, 0,
+			&right_input_dmic_controls[0],
+			ARRAY_SIZE(right_input_dmic_controls)),
+
+	/* Left/Right ADC */
+	SND_SOC_DAPM_ADC("Left ADC", "Left Capture", ADC_DIGITAL, 7, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "Right Capture", ADC_DIGITAL, 6, 0),
+
+	/* Inputs */
+	SND_SOC_DAPM_INPUT("IN1_L"),
+	SND_SOC_DAPM_INPUT("IN1_R"),
+	SND_SOC_DAPM_INPUT("IN2_L"),
+	SND_SOC_DAPM_INPUT("IN2_R"),
+	SND_SOC_DAPM_INPUT("IN3_L"),
+	SND_SOC_DAPM_INPUT("IN3_R"),
+	SND_SOC_DAPM_INPUT("DIF1_L"),
+	SND_SOC_DAPM_INPUT("DIF2_L"),
+	SND_SOC_DAPM_INPUT("DIF3_L"),
+	SND_SOC_DAPM_INPUT("DIF1_R"),
+	SND_SOC_DAPM_INPUT("DIF2_R"),
+	SND_SOC_DAPM_INPUT("DIF3_R"),
+	SND_SOC_DAPM_INPUT("DMic_L"),
+	SND_SOC_DAPM_INPUT("DMic_R"),
+
+};
+
+/* DAPM Routing related array declaratiom */
+static const struct snd_soc_dapm_route intercon[] = {
+/* Left input selection from switchs */
+	{"Left Input Selection", "IN1_L switch", "IN1_L"},
+	{"Left Input Selection", "IN2_L switch", "IN2_L"},
+	{"Left Input Selection", "IN3_L switch", "IN3_L"},
+	{"Left Input Selection", "DIF1_L switch", "DIF1_L"},
+	{"Left Input Selection", "DIF2_L switch", "DIF2_L"},
+	{"Left Input Selection", "DIF3_L switch", "DIF3_L"},
+	{"Left Input Selection", "IN1_R switch", "IN1_R"},
+
+/* Left input selection to left PGA */
+	{"Left PGA", NULL, "Left Input Selection"},
+
+/* Left PGA to left ADC */
+	{"Left ADC", NULL, "Left PGA"},
+
+/* Right input selection from switchs */
+	{"Right Input Selection", "IN1_R switch", "IN1_R"},
+	{"Right Input Selection", "IN2_R switch", "IN2_R"},
+	{"Right Input Selection", "IN3_R switch", "IN3_R"},
+	{"Right Input Selection", "DIF1_R switch", "DIF1_R"},
+	{"Right Input Selection", "DIF2_R switch", "DIF2_R"},
+	{"Right Input Selection", "DIF3_R switch", "DIF3_R"},
+	{"Right Input Selection", "IN1_L switch", "IN1_L"},
+
+/* Right input selection to right PGA */
+	{"Right PGA", NULL, "Right Input Selection"},
+
+/* Right PGA to right ADC */
+	{"Right ADC", NULL, "Right PGA"},
+
+/* Left DMic Input selection from switch */
+	{"Left DMic Input", "Left ADC switch", "DMic_L"},
+
+/* Left DMic to left ADC */
+	{"Left ADC", NULL, "Left DMic Input"},
+
+/* Right DMic Input selection from switch */
+	{"Right DMic Input", "Right ADC switch", "DMic_R"},
+
+/* Right DMic to right ADC */
+	{"Right ADC", NULL, "Right DMic Input"},
+};
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_hw_params
+ * Purpose  : This function is to set the hardware parameters for adc3xxx.
+ *            The functions set the sample rate and audio serial data word
+ *            length.
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct adc3xxx_priv *adc3xxx = snd_soc_codec_get_drvdata(codec);
+	int i, width = 16;
+	u8 data, bdiv;
+
+	i = adc3xxx_get_divs(adc3xxx->sysclk, params_rate(params));
+
+	if (i < 0) {
+		printk("Clock configuration is not supported\n");
+		return i;
+	}
+
+	/* select data word length */
+	data =
+	    adc3xxx_read_reg_cache(codec, INTERFACE_CTRL_1) & (~WLENGTH_MASK);
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		width = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		data |= (0x01 << 4);
+		width = 20;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		data |= (0x02 << 4);
+		width = 24;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		data |= (0x03 << 4);
+		width = 32;
+		break;
+	}
+	adc3xxx_write(codec, INTERFACE_CTRL_1, data);
+
+	/* BCLK is derived from ADC_CLK */
+	if (width == 16) {
+		bdiv = adc3xxx_divs[i].bdiv_n;
+	} else {
+		bdiv =
+		    (adc3xxx_divs[i].aosr * adc3xxx_divs[i].madc) / (2 * width);
+	}
+
+	/* P & R values */
+	adc3xxx_write(codec, PLL_PROG_PR,
+		      (adc3xxx_divs[i].pll_p << PLLP_SHIFT) | (adc3xxx_divs[i].
+							       pll_r <<
+							       PLLR_SHIFT));
+	/* J value */
+	adc3xxx_write(codec, PLL_PROG_J, adc3xxx_divs[i].pll_j & PLLJ_MASK);
+	/* D value */
+	adc3xxx_write(codec, PLL_PROG_D_LSB,
+		      adc3xxx_divs[i].pll_d & PLLD_LSB_MASK);
+	adc3xxx_write(codec, PLL_PROG_D_MSB,
+		      (adc3xxx_divs[i].pll_d >> 8) & PLLD_MSB_MASK);
+	/* NADC */
+	adc3xxx_write(codec, ADC_NADC, adc3xxx_divs[i].nadc & NADC_MASK);
+	/* MADC */
+	adc3xxx_write(codec, ADC_MADC, adc3xxx_divs[i].madc & MADC_MASK);
+	/* AOSR */
+	adc3xxx_write(codec, ADC_AOSR, adc3xxx_divs[i].aosr & AOSR_MASK);
+	/* BDIV N Value */
+	adc3xxx_write(codec, BCLK_N_DIV, bdiv & BDIV_MASK);
+	msleep(10);
+
+	return 0;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_set_dai_sysclk
+ * Purpose  : This function is to set the DAI system clock
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct adc3xxx_priv *adc3xxx = snd_soc_codec_get_drvdata(codec);
+
+	adc3xxx->sysclk = freq;
+	return 0;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_set_dai_fmt
+ * Purpose  : This function is to set the DAI format
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct adc3xxx_priv *adc3xxx = snd_soc_codec_get_drvdata(codec);
+	u8 iface_reg;
+
+	iface_reg =
+	    adc3xxx_read_reg_cache(codec, INTERFACE_CTRL_1) & (~FMT_MASK);
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		adc3xxx->master = 1;
+		iface_reg |= BCLK_MASTER | WCLK_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		adc3xxx->master = 0;
+		iface_reg &= ~ (BCLK_MASTER | WCLK_MASTER ); //new repladec | with &
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM: //new case..just for debugging
+		printk("%s: SND_SOC_DAIFMT_CBS_CFM\n", __FUNCTION__);
+		adc3xxx->master = 0;
+		/* BCLK by codec ie BCLK output */
+		iface_reg |=  (BCLK_MASTER);
+		iface_reg &= ~(WCLK_MASTER);
+
+		break;
+	default:
+		printk("Invalid DAI master/slave interface\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * match both interface format and signal polarities since they
+	 * are fixed
+	 */
+	switch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK)) {
+	case (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF):
+		break;
+	case (SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_IB_NF):
+		iface_reg |= (0x01 << 6);
+		break;
+	case (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF):
+		iface_reg |= (0x01 << 6);
+		break;
+	case (SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_NB_NF):
+		iface_reg |= (0x02 << 6);
+		break;
+	case (SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF):
+		iface_reg |= (0x03 << 6);
+		break;
+	default:
+		printk("Invalid DAI format\n");
+		return -EINVAL;
+	}
+
+	/* set iface */
+	adc3xxx_write(codec, INTERFACE_CTRL_1, iface_reg);
+	return 0;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_set_bias_level
+ * Purpose  : This function is to get triggered when dapm events occurs.
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_set_bias_level(struct snd_soc_codec *codec,
+				  enum snd_soc_bias_level level)
+{
+	struct adc3xxx_priv *adc3xxx = snd_soc_codec_get_drvdata(codec);
+	u8 reg;
+
+	/* Check if  the New Bias level is equal to the existing one, if so return */
+	if (codec->dapm.bias_level  == level)
+	return 0;
+
+	/* all power is driven by DAPM system */
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		if (adc3xxx->master) {
+			/* Enable pll */
+			reg = adc3xxx_read_reg_cache(codec, PLL_PROG_PR);
+			adc3xxx_write(codec, PLL_PROG_PR, reg | ENABLE_PLL);
+
+			/* 10msec delay needed after PLL power-up */
+			mdelay(10);
+
+			/* Switch on NADC Divider */
+			reg = adc3xxx_read_reg_cache(codec, ADC_NADC);
+			adc3xxx_write(codec, ADC_NADC, reg | ENABLE_NADC);
+
+			/* Switch on MADC Divider */
+			reg = adc3xxx_read_reg_cache(codec, ADC_MADC);
+			adc3xxx_write(codec, ADC_MADC, reg | ENABLE_MADC);
+
+			/* Switch on BCLK_N Divider */
+			reg = adc3xxx_read_reg_cache(codec, BCLK_N_DIV);
+			adc3xxx_write(codec, BCLK_N_DIV, reg | ENABLE_BCLK);
+		}
+	      else{ //new
+			/* Enable pll */
+			reg = adc3xxx_read_reg_cache(codec, PLL_PROG_PR);
+			adc3xxx_write(codec, PLL_PROG_PR, reg | ENABLE_PLL);
+
+			/* 10msec delay needed after PLL power-up */
+			mdelay(10);
+
+			/*Switch on NADC Divider */
+			reg = adc3xxx_read_reg_cache(codec, ADC_NADC);
+			adc3xxx_write(codec, ADC_NADC, reg | ENABLE_NADC);
+
+			/* Switch on MADC Divider */
+			reg = adc3xxx_read_reg_cache(codec, ADC_MADC);
+			adc3xxx_write(codec, ADC_MADC, reg | ENABLE_MADC);
+
+			/* Switch on BCLK_N Divider */
+			reg = adc3xxx_read_reg_cache(codec, BCLK_N_DIV);
+			adc3xxx_write(codec, BCLK_N_DIV, reg | ~ENABLE_BCLK);
+
+		}
+		 msleep(350);
+		break;
+
+		/* partial On */
+	case SND_SOC_BIAS_PREPARE:
+		break;
+
+		/* Off, with power */
+	case SND_SOC_BIAS_STANDBY:
+		if (adc3xxx->master) {
+			/* switch off pll */
+			reg = adc3xxx_read_reg_cache(codec, PLL_PROG_PR);
+			adc3xxx_write(codec, PLL_PROG_PR, reg & (~ENABLE_PLL));
+			msleep(10);
+
+			/* Switch off NADC Divider */
+			reg = adc3xxx_read_reg_cache(codec, ADC_NADC);
+			adc3xxx_write(codec, ADC_NADC, reg & (~ENABLE_NADC));
+
+			/* Switch off MADC Divider */
+			reg = adc3xxx_read_reg_cache(codec, ADC_MADC);
+			adc3xxx_write(codec, ADC_MADC, reg & (~ENABLE_MADC));
+
+			/* Switch off BCLK_N Divider */
+			reg = adc3xxx_read_reg_cache(codec, BCLK_N_DIV);
+			adc3xxx_write(codec, BCLK_N_DIV, reg & (~ENABLE_BCLK));
+			msleep(100);
+		}
+		break;
+
+		/* Off without power */
+	case SND_SOC_BIAS_OFF:
+
+		/* power off Left/Right ADC channels */
+		reg = adc3xxx_read_reg_cache(codec, ADC_DIGITAL);
+		adc3xxx_write(codec, ADC_DIGITAL,
+			      reg & ~(LADC_PWR_ON | RADC_PWR_ON));
+
+		/* Turn off PLLs */
+		if (adc3xxx->master) {
+			/* switch off pll */
+			reg = adc3xxx_read_reg_cache(codec, PLL_PROG_PR);
+			adc3xxx_write(codec, PLL_PROG_PR, reg & (~ENABLE_PLL));
+
+			/* Switch off NADC Divider */
+			reg = adc3xxx_read_reg_cache(codec, ADC_NADC);
+			adc3xxx_write(codec, ADC_NADC, reg & (~ENABLE_NADC));
+
+			/* Switch off MADC Divider */
+			reg = adc3xxx_read_reg_cache(codec, ADC_MADC);
+			adc3xxx_write(codec, ADC_MADC, reg & (~ENABLE_MADC));
+
+			/* Switch off BCLK_N Divider */
+			reg = adc3xxx_read_reg_cache(codec, BCLK_N_DIV);
+			adc3xxx_write(codec, BCLK_N_DIV, reg & (~ENABLE_BCLK));
+		}
+		break;
+	}
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+static struct snd_soc_dai_ops adc3xxx_dai_ops = {
+	.hw_params	= adc3xxx_hw_params,
+	.set_sysclk = adc3xxx_set_dai_sysclk,
+	.set_fmt	= adc3xxx_set_dai_fmt,
+};
+
+struct snd_soc_dai_driver adc3xxx_dai = {
+	.name = "tlv320adc3xxx-hifi",
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = 2,
+		    .rates = ADC3xxx_RATES,
+		    .formats = ADC3xxx_FORMATS,
+		    },
+	.ops = &adc3xxx_dai_ops,
+};
+
+EXPORT_SYMBOL_GPL(adc3xxx_dai);
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : tlv320adc3xxx_init
+ * Purpose  : This function is to initialise the adc3xxx driver
+ *            register the mixer and dsp interfaces with the kernel.
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_init(struct snd_soc_codec *codec)
+{
+	int i, ret = 0;
+
+	codec->name = "tlv320adc3xxx";
+	codec->num_dai = 1;
+	codec->reg_cache =
+		kmemdup(adc3xxx_reg, sizeof(adc3xxx_reg), GFP_KERNEL);
+	if (codec->reg_cache == NULL)
+		return -ENOMEM;
+
+	/* Select Page 0 */
+	adc3xxx_write(codec, PAGE_SELECT, 0);
+	/* Issue software reset to adc3xxx */
+	adc3xxx_write(codec, RESET, SOFT_RESET);
+
+	adc3xxx_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	for (i = 0;
+	     i < sizeof(adc3xxx_reg_init) / sizeof(struct adc3xxx_configs);
+	     i++) {
+		adc3xxx_write(codec, adc3xxx_reg_init[i].reg_offset,
+			      adc3xxx_reg_init[i].reg_val);
+	}
+
+	//adc3xxx_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	return ret;
+
+	kfree(codec->reg_cache);
+	return ret;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_probe
+ * Purpose  : This is first driver function called by the SoC core driver.
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_probe(struct snd_soc_codec *codec)
+{
+	struct adc3xxx_priv *adc3xxx = NULL;
+	int ret = 0;
+
+	printk(KERN_INFO "ADC3xxx Audio Codec %s provided by Amba Dongge\n", ADC3xxx_VERSION);
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	codec->write = adc3xxx_write;
+	codec->read = adc3xxx_read;
+#endif
+
+	adc3xxx = (struct adc3xxx_priv *)snd_soc_codec_get_drvdata(codec);
+	codec->control_data = adc3xxx->control_data;
+	mutex_init(&codec->mutex);
+
+	ret = devm_gpio_request(codec->dev, adc3xxx->rst_pin, "adc3xxx reset");
+	if (ret < 0){
+		dev_err(codec->dev, "Failed to request rst_pin: %d\n", ret);
+		return ret;
+	}
+
+	/* Reset adc3xxx codec */
+	gpio_direction_output(adc3xxx->rst_pin, adc3xxx->rst_active);
+	msleep(2);
+	gpio_direction_output(adc3xxx->rst_pin, !adc3xxx->rst_active);
+
+	ret = adc3xxx_init(codec);
+
+	if (ret < 0) {
+		printk(KERN_ERR "adc3xxx: failed to initialise ADC3xxx\n");
+		devm_gpio_free(codec->dev, adc3xxx->rst_pin);
+	}
+
+	return ret;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_remove
+ * Purpose  : to remove adc3xxx soc device
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_remove(struct snd_soc_codec *codec)
+{
+	adc3xxx_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	return 0;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_suspend
+ * Purpose  : This function is to suspend the adc3xxx driver.
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_suspend(struct snd_soc_codec *codec)
+{
+	adc3xxx_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	return 0;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_resume
+ * Purpose  : This function is to resume the ADC3xxx driver
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_resume(struct snd_soc_codec *codec)
+{
+	snd_soc_cache_sync(codec);
+	adc3xxx_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	return 0;
+}
+
+struct snd_soc_codec_driver soc_codec_dev_adc3xxx = {
+	.probe = adc3xxx_probe,
+	.remove = adc3xxx_remove,
+	.suspend =	adc3xxx_suspend,
+	.resume =	adc3xxx_resume,
+	.set_bias_level = adc3xxx_set_bias_level,
+	.reg_cache_default	= adc3xxx_reg,
+	.reg_cache_size		= ARRAY_SIZE(adc3xxx_reg),
+	.reg_word_size		= sizeof(u8),
+	.reg_cache_step		= 1,
+
+	.controls = adc3xxx_snd_controls,
+	.num_controls = ARRAY_SIZE(adc3xxx_snd_controls),
+	.dapm_widgets = adc3xxx_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(adc3xxx_dapm_widgets),
+	.dapm_routes = intercon,
+	.num_dapm_routes = ARRAY_SIZE(intercon),
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_adc3xxx);
+
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_i2c_probe
+ * Purpose  : This function attaches the i2c client and initializes
+ *				adc3xxx CODEC.
+ *            NOTE:
+ *            This function is called from i2c core when the I2C address is
+ *            valid.
+ *            If the i2c layer weren't so broken, we could pass this kind of
+ *            data around
+ *
+ *----------------------------------------------------------------------------
+ */
+static int adc3xxx_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct device_node *np = i2c->dev.of_node;
+	struct adc3xxx_priv *adc3xxx = NULL;
+	enum of_gpio_flags flags;
+	int rst_pin;
+	int ret;
+
+	adc3xxx = kzalloc(sizeof(struct adc3xxx_priv), GFP_KERNEL);
+	if (adc3xxx == NULL) {
+		return -ENOMEM;
+	}
+
+	rst_pin = of_get_gpio_flags(np, 0, &flags);
+	if (rst_pin < 0 || !gpio_is_valid(rst_pin))
+		return -ENXIO;
+
+	adc3xxx->rst_pin = rst_pin;
+	adc3xxx->rst_active = !!(flags & OF_GPIO_ACTIVE_LOW);
+	adc3xxx->control_data = i2c;
+
+	i2c_set_clientdata(i2c, adc3xxx);
+	ret = snd_soc_register_codec(&i2c->dev,
+			&soc_codec_dev_adc3xxx, &adc3xxx_dai, 1);
+	if (ret < 0){
+		kfree(adc3xxx);
+		printk("\t[adc3xxx Error!] %s(%d)\n",__FUNCTION__,__LINE__);
+	}
+
+	return ret;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * Function : adc3xxx_i2c_remove
+ * Purpose  : This function removes the i2c client and uninitializes
+ *                              adc3xxx CODEC.
+ *            NOTE:
+ *            This function is called from i2c core
+ *            If the i2c layer weren't so broken, we could pass this kind of
+ *            data around
+ *
+ *----------------------------------------------------------------------------
+ */
+static int __exit adc3xxx_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	kfree(i2c_get_clientdata(client));
+	return 0;
+}
+
+static struct of_device_id tlv320adc3xxx_of_match[] = {
+	{ .compatible = "ambarella,tlv320adc3xxx",},
+	{},
+};
+MODULE_DEVICE_TABLE(of, tlv320adc3xxx_of_match);
+
+
+static const struct i2c_device_id adc3xxx_i2c_id[] = {
+	{"tlv320adc3xxx", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, adc3xxx_i2c_id);
+
+/* machine i2c codec control layer */
+static struct i2c_driver adc3xxx_i2c_driver = {
+	.driver = {
+		   .name = "tlv320adc3xxx-codec",
+		   .owner = THIS_MODULE,
+		   .of_match_table = tlv320adc3xxx_of_match,
+		   },
+	.probe = adc3xxx_i2c_probe,
+	.remove = adc3xxx_i2c_remove,
+	.id_table = adc3xxx_i2c_id,
+};
+#endif
+
+static int __init tlv320adc3xxx_init(void)
+{
+	return i2c_add_driver(&adc3xxx_i2c_driver);
+}
+
+static void __exit tlv320adc3xxx_exit(void)
+{
+	i2c_del_driver(&adc3xxx_i2c_driver);
+}
+
+module_init(tlv320adc3xxx_init);
+module_exit(tlv320adc3xxx_exit);
+
+MODULE_DESCRIPTION("ASoC TLV320ADC3xxx codec driver");
+MODULE_AUTHOR("dgwu@ambarella.com ");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/tlv320adc3xxx_amb.h b/sound/soc/codecs/tlv320adc3xxx_amb.h
new file mode 100644
index 0000000..e18f48e
--- /dev/null
+++ b/sound/soc/codecs/tlv320adc3xxx_amb.h
@@ -0,0 +1,378 @@
+/*
+ * sound/soc/codecs/tlv320adc3xxx_amb.H
+ *
+ * Author: Dongge wu <dgwu@ambarella.com>
+ *
+ * History:
+ *	2015/10/28 - [Dongge wu] Created file
+ *
+ * Copyright (C) 2014-2018, Ambarella, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+
+#ifndef _ADC3xxx_AMB_H
+#define _ADC3xxx_AMB_H
+
+#define AUDIO_NAME 			"tlv320adc3xxx"
+#define ADC3xxx_VERSION		"Rev A"
+
+#define ADC3101_CODEC_SUPPORT
+//#define ADC3001_CODEC_SUPPORT
+
+/* Macro enables or disables support for TiLoad in the driver */
+#define ADC3xxx_TiLoad
+//#undef ADC3xxx_TiLoad
+
+/* 8 bit mask value */
+#define ADC3xxx_8BITS_MASK           0xFF
+
+/* Enable slave / master mode for codec */
+#define ADC3xxx_MCBSP_SLAVE //codec master
+//#undef ADC3xxx_MCBSP_SLAVE
+
+
+/****************************************************************************/
+/* 							 Page 0 Registers 						 		*/
+/****************************************************************************/
+
+/* Page select register */
+#define PAGE_SELECT				0
+/* Software reset register */
+#define RESET					1
+
+/* 2-3 Reserved */
+
+/* PLL programming register B */
+#define CLKGEN_MUX				4
+/* PLL P and R-Val */
+#define PLL_PROG_PR				5
+/* PLL J-Val */
+#define PLL_PROG_J				6
+/* PLL D-Val MSB */
+#define PLL_PROG_D_MSB			7
+/* PLL D-Val LSB */
+#define PLL_PROG_D_LSB			8
+
+/* 9-17 Reserved */
+
+/* ADC NADC */
+#define ADC_NADC				18
+/* ADC MADC */
+#define ADC_MADC				19
+/* ADC AOSR */
+#define ADC_AOSR				20
+/* ADC IADC */
+#define ADC_IADC				21
+
+/* 23-24 Reserved */
+
+/* CLKOUT MUX */
+#define CLKOUT_MUX				25
+/* CLOCKOUT M divider value */
+#define CLKOUT_M_DIV			26
+/*Audio Interface Setting Register 1*/
+#define INTERFACE_CTRL_1		27
+/* Data Slot Offset (Ch_Offset_1) */
+#define CH_OFFSET_1				28
+/* ADC interface control 2 */
+#define INTERFACE_CTRL_2		29
+/* BCLK N Divider */
+#define BCLK_N_DIV				30
+/* Secondary audio interface control 1 */
+#define INTERFACE_CTRL_3		31
+/* Secondary audio interface control 2 */
+#define INTERFACE_CTRL_4		32
+/* Secondary audio interface control 3 */
+#define INTERFACE_CTRL_5		33
+/* I2S sync */
+#define I2S_SYNC				34
+
+/* 35 Reserved */
+
+/* ADC flag register */
+#define ADC_FLAG				36
+/* Data slot offset 2 (Ch_Offset_2) */
+#define CH_OFFSET_2				37
+/* I2S TDM control register */
+#define I2S_TDM_CTRL			38
+
+/* 39-41 Reserved */
+
+/* Interrupt flags (overflow) */
+#define INTR_FLAG_1				42
+/* Interrupt flags (overflow) */
+#define INTR_FLAG_2				43
+
+/* 44 Reserved */
+
+/* Interrupt flags ADC */
+#define INTR_FLAG_ADC1			45
+
+/* 46 Reserved */
+
+/* Interrupt flags ADC */
+#define INTR_FLAG_ADC2			47
+/* INT1 interrupt control */
+#define INT1_CTRL				48
+/* INT2 interrupt control */
+#define INT2_CTRL				49
+
+/* 50 Reserved */
+
+/* DMCLK/GPIO2 control */
+#define GPIO2_CTRL				51
+/* DMDIN/GPIO1 control */
+#define GPIO1_CTRL				52
+/* DOUT Control */
+#define DOUT_CTRL				53
+
+/* 54-56 Reserved */
+
+/* ADC sync control 1 */
+#define SYNC_CTRL_1				57
+/* ADC sync control 2 */
+#define SYNC_CTRL_2				58
+/* ADC CIC filter gain control */
+#define CIC_GAIN_CTRL			59
+
+/* 60 Reserved */
+
+/* ADC processing block selection  */
+#define PRB_SELECT				61
+/* Programmable instruction mode control bits */
+#define INST_MODE_CTRL			62
+
+/* 63-79 Reserved */
+
+/* Digital microphone polarity control */
+#define MIC_POLARITY_CTRL		80
+/* ADC Digital */
+#define ADC_DIGITAL				81
+/* ADC Fine Gain Adjust */
+#define	ADC_FGA					82
+/* Left ADC Channel Volume Control */
+#define LADC_VOL				83
+/* Right ADC Channel Volume Control */
+#define RADC_VOL				84
+/* ADC phase compensation */
+#define ADC_PHASE_COMP			85
+/* Left Channel AGC Control Register 1 */
+#define LEFT_CHN_AGC_1			86
+/* Left Channel AGC Control Register 2 */
+#define LEFT_CHN_AGC_2			87
+/* Left Channel AGC Control Register 3 */
+#define LEFT_CHN_AGC_3			88
+/* Left Channel AGC Control Register 4 */
+#define LEFT_CHN_AGC_4			89
+/* Left Channel AGC Control Register 5 */
+#define LEFT_CHN_AGC_5			90
+/* Left Channel AGC Control Register 6 */
+#define LEFT_CHN_AGC_6			91
+/* Left Channel AGC Control Register 7 */
+#define LEFT_CHN_AGC_7			92
+/* Left AGC gain */
+#define LEFT_AGC_GAIN			93
+/* Right Channel AGC Control Register 1 */
+#define RIGHT_CHN_AGC_1			94
+/* Right Channel AGC Control Register 2 */
+#define RIGHT_CHN_AGC_2 		95
+/* Right Channel AGC Control Register 3 */
+#define RIGHT_CHN_AGC_3			96
+/* Right Channel AGC Control Register 4 */
+#define RIGHT_CHN_AGC_4			97
+/* Right Channel AGC Control Register 5 */
+#define RIGHT_CHN_AGC_5			98
+/* Right Channel AGC Control Register 6 */
+#define RIGHT_CHN_AGC_6			99
+/* Right Channel AGC Control Register 7 */
+#define RIGHT_CHN_AGC_7			100
+/* Right AGC gain */
+#define RIGHT_AGC_GAIN			101
+
+/* 102-127 Reserved */
+
+/****************************************************************************/
+/* 							 Page 1 Registers 						 		*/
+/****************************************************************************/
+#define PAGE_1					128
+
+/* 1-25 Reserved */
+
+/* Dither control */
+#define DITHER_CTRL			(PAGE_1 + 26)
+
+/* 27-50 Reserved */
+
+/* MICBIAS Configuration Register */
+#define MICBIAS_CTRL		(PAGE_1 + 51)
+/* Left ADC input selection for Left PGA */
+#define LEFT_PGA_SEL_1		(PAGE_1 + 52)
+
+/* 53 Reserved */
+
+/* Right ADC input selection for Left PGA */
+#define LEFT_PGA_SEL_2		(PAGE_1 + 54)
+/* Right ADC input selection for right PGA */
+#define RIGHT_PGA_SEL_1		(PAGE_1 + 55)
+
+/* 56 Reserved */
+
+/* Right ADC input selection for right PGA */
+#define RIGHT_PGA_SEL_2		(PAGE_1 + 57)
+
+/* 58 Reserved */
+
+/* Left analog PGA settings */
+#define LEFT_APGA_CTRL		(PAGE_1 + 59)
+/* Right analog PGA settings */
+#define RIGHT_APGA_CTRL		(PAGE_1 + 60)
+/* ADC Low current Modes */
+#define LOW_CURRENT_MODES	(PAGE_1 + 61)
+/* ADC analog PGA flags */
+#define ANALOG_PGA_FLAGS	(PAGE_1 + 62)
+
+/* 63-127 Reserved */
+
+/****************************************************************************/
+/*						Macros and definitions							   	*/
+/****************************************************************************/
+
+/* ADC3xxx register space */
+#define ADC3xxx_CACHEREGNUM		192
+#define ADC3xxx_PAGE_SIZE		128
+
+#define ADC3xxx_RATES   SNDRV_PCM_RATE_8000_96000
+#define ADC3xxx_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+             SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+/* bits defined for easy usage */
+#define D7                    (0x01 << 7)
+#define D6                    (0x01 << 6)
+#define D5                    (0x01 << 5)
+#define D4                    (0x01 << 4)
+#define D3                    (0x01 << 3)
+#define D2                    (0x01 << 2)
+#define D1                    (0x01 << 1)
+#define D0                    (0x01 << 0)
+
+/****************************************************************************/
+/*						ADC3xxx Register bits							   	*/
+/****************************************************************************/
+/* PLL Enable bits */
+#define ENABLE_PLL              D7
+#define ENABLE_NADC             D7
+#define ENABLE_MADC             D7
+#define ENABLE_BCLK             D7
+
+/* Power bits */
+#define LADC_PWR_ON     		D7
+#define RADC_PWR_ON     		D6
+
+#define SOFT_RESET              D0
+#define BCLK_MASTER          	D3
+#define WCLK_MASTER         	D2
+
+/* Interface register masks */
+#define FMT_MASK				(D7|D6|D3|D2)
+#define WLENGTH_MASK			(D5|D4)
+
+/* PLL P/R bit offsets */
+#define PLLP_SHIFT      	4
+#define PLLR_SHIFT      	0
+#define PLL_PR_MASK			0x7F
+#define PLLJ_MASK			0x3F
+#define PLLD_MSB_MASK		0x3F
+#define PLLD_LSB_MASK		0xFF
+#define NADC_MASK			0x7F
+#define MADC_MASK			0x7F
+#define AOSR_MASK			0xFF
+#define IADC_MASK			0xFF
+#define BDIV_MASK			0x7F
+
+/* PLL_CLKIN bits */
+#define PLL_CLKIN_SHIFT			2
+#define PLL_CLKIN_MCLK			0x0
+#define PLL_CLKIN_BCLK			0x1
+#define PLL_CLKIN_ZERO			0x3
+
+/* CODEC_CLKIN bits */
+#define CODEC_CLKIN_SHIFT		0
+#define CODEC_CLKIN_MCLK		0x0
+#define CODEC_CLKIN_BCLK		0x1
+#define CODEC_CLKIN_PLL_CLK		0x3
+
+#define USE_PLL					(PLL_CLKIN_MCLK << PLL_CLKIN_SHIFT) |	\
+					            (CODEC_CLKIN_PLL_CLK << CODEC_CLKIN_SHIFT)
+
+/*  Analog PGA control bits */
+#define LPGA_MUTE				D7
+#define RPGA_MUTE				D7
+
+#define LPGA_GAIN_MASK			0x7F
+#define RPGA_GAIN_MASK			0x7F
+
+/* ADC current modes */
+#define ADC_LOW_CURR_MODE		D0
+
+/* Left ADC Input selection bits */
+#define LCH_SEL1_SHIFT			0
+#define LCH_SEL2_SHIFT			2
+#define LCH_SEL3_SHIFT			4
+#define LCH_SEL4_SHIFT			6
+
+#define LCH_SEL1X_SHIFT			0
+#define LCH_SEL2X_SHIFT			2
+#define LCH_SEL3X_SHIFT			4
+#define LCH_COMMON_MODE			D6
+#define BYPASS_LPGA				D7
+
+/* Right ADC Input selection bits */
+#define RCH_SEL1_SHIFT			0
+#define RCH_SEL2_SHIFT			2
+#define RCH_SEL3_SHIFT			4
+#define RCH_SEL4_SHIFT			6
+
+#define RCH_SEL1X_SHIFT			0
+#define RCH_SEL2X_SHIFT			2
+#define RCH_SEL3X_SHIFT			4
+#define RCH_COMMON_MODE			D6
+#define BYPASS_RPGA				D7
+
+/* MICBIAS control bits */
+#define MICBIAS1_SHIFT			5
+#define MICBIAS2_SHIFT			3
+
+#define ADC_MAX_VOLUME			64
+#define ADC_POS_VOL			24
+
+/****************** RATES TABLE FOR ADC3xxx ************************/
+struct adc3xxx_rate_divs {
+	u32 mclk;
+	u32 rate;
+	u8 pll_p;
+	u8 pll_r;
+	u8 pll_j;
+	u16 pll_d;
+	u8 nadc;
+	u8 madc;
+	u8 aosr;
+	u8 bdiv_n;
+	u8 iadc;
+};
+
+#endif /* _ADC3xxx_AMB_H */
diff --git a/sound/soc/codecs/wm2000.c b/sound/soc/codecs/wm2000.c
index 7fefd76..124fb53 100644
--- a/sound/soc/codecs/wm2000.c
+++ b/sound/soc/codecs/wm2000.c
@@ -605,7 +605,7 @@ static int wm2000_anc_mode_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
 
-	ucontrol->value.enumerated.item[0] = wm2000->anc_active;
+	ucontrol->value.integer.value[0] = wm2000->anc_active;
 
 	return 0;
 }
@@ -615,7 +615,7 @@ static int wm2000_anc_mode_put(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
-	int anc_active = ucontrol->value.enumerated.item[0];
+	int anc_active = ucontrol->value.integer.value[0];
 	int ret;
 
 	if (anc_active > 1)
@@ -638,7 +638,7 @@ static int wm2000_speaker_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
 
-	ucontrol->value.enumerated.item[0] = wm2000->spk_ena;
+	ucontrol->value.integer.value[0] = wm2000->spk_ena;
 
 	return 0;
 }
@@ -648,7 +648,7 @@ static int wm2000_speaker_put(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
-	int val = ucontrol->value.enumerated.item[0];
+	int val = ucontrol->value.integer.value[0];
 	int ret;
 
 	if (val > 1)
diff --git a/sound/soc/codecs/wm8731.c b/sound/soc/codecs/wm8731.c
index 10d492b..944b09b 100644
--- a/sound/soc/codecs/wm8731.c
+++ b/sound/soc/codecs/wm8731.c
@@ -121,7 +121,7 @@ static int wm8731_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.enumerated.item[0] = wm8731->deemph;
+	ucontrol->value.integer.value[0] = wm8731->deemph;
 
 	return 0;
 }
@@ -131,7 +131,7 @@ static int wm8731_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.enumerated.item[0];
+	int deemph = ucontrol->value.integer.value[0];
 	int ret = 0;
 
 	if (deemph > 1)
diff --git a/sound/soc/codecs/wm8737.c b/sound/soc/codecs/wm8737.c
index b80138f..1d37160 100644
--- a/sound/soc/codecs/wm8737.c
+++ b/sound/soc/codecs/wm8737.c
@@ -494,7 +494,8 @@ static int wm8737_set_bias_level(struct snd_soc_codec *codec,
 
 			/* Fast VMID ramp at 2*2.5k */
 			snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
-					    WM8737_VMIDSEL_MASK, 0x4);
+					    WM8737_VMIDSEL_MASK,
+					    2 << WM8737_VMIDSEL_SHIFT);
 
 			/* Bring VMID up */
 			snd_soc_update_bits(codec, WM8737_POWER_MANAGEMENT,
@@ -508,7 +509,8 @@ static int wm8737_set_bias_level(struct snd_soc_codec *codec,
 
 		/* VMID at 2*300k */
 		snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
-				    WM8737_VMIDSEL_MASK, 2);
+				    WM8737_VMIDSEL_MASK,
+				    1 << WM8737_VMIDSEL_SHIFT);
 
 		break;
 
diff --git a/sound/soc/codecs/wm8903.c b/sound/soc/codecs/wm8903.c
index 9d88437..79f4a21 100644
--- a/sound/soc/codecs/wm8903.c
+++ b/sound/soc/codecs/wm8903.c
@@ -446,7 +446,7 @@ static int wm8903_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.enumerated.item[0] = wm8903->deemph;
+	ucontrol->value.integer.value[0] = wm8903->deemph;
 
 	return 0;
 }
@@ -456,7 +456,7 @@ static int wm8903_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.enumerated.item[0];
+	int deemph = ucontrol->value.integer.value[0];
 	int ret = 0;
 
 	if (deemph > 1)
diff --git a/sound/soc/codecs/wm8903.h b/sound/soc/codecs/wm8903.h
index db94931..0bb4a64 100644
--- a/sound/soc/codecs/wm8903.h
+++ b/sound/soc/codecs/wm8903.h
@@ -172,7 +172,7 @@ extern int wm8903_mic_detect(struct snd_soc_codec *codec,
 #define WM8903_VMID_BUF_ENA_WIDTH                    1  /* VMID_BUF_ENA */
 
 #define WM8903_VMID_RES_50K                          2
-#define WM8903_VMID_RES_250K                         3
+#define WM8903_VMID_RES_250K                         4
 #define WM8903_VMID_RES_5K                           6
 
 /*
diff --git a/sound/soc/codecs/wm8904.c b/sound/soc/codecs/wm8904.c
index af62f84..c68d541 100644
--- a/sound/soc/codecs/wm8904.c
+++ b/sound/soc/codecs/wm8904.c
@@ -523,7 +523,7 @@ static int wm8904_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.enumerated.item[0] = wm8904->deemph;
+	ucontrol->value.integer.value[0] = wm8904->deemph;
 	return 0;
 }
 
@@ -532,7 +532,7 @@ static int wm8904_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.enumerated.item[0];
+	int deemph = ucontrol->value.integer.value[0];
 
 	if (deemph > 1)
 		return -EINVAL;
diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c
index 82c8ba9..475fc24 100644
--- a/sound/soc/codecs/wm8955.c
+++ b/sound/soc/codecs/wm8955.c
@@ -298,7 +298,7 @@ static int wm8955_configure_clocking(struct snd_soc_codec *codec)
 		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
 				    WM8955_K_17_9_MASK,
 				    (pll.k >> 9) & WM8955_K_17_9_MASK);
-		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
+		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_3,
 				    WM8955_K_8_0_MASK,
 				    pll.k & WM8955_K_8_0_MASK);
 		if (pll.k)
@@ -393,7 +393,7 @@ static int wm8955_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.enumerated.item[0] = wm8955->deemph;
+	ucontrol->value.integer.value[0] = wm8955->deemph;
 	return 0;
 }
 
@@ -402,7 +402,7 @@ static int wm8955_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.enumerated.item[0];
+	int deemph = ucontrol->value.integer.value[0];
 
 	if (deemph > 1)
 		return -EINVAL;
diff --git a/sound/soc/codecs/wm8958-dsp2.c b/sound/soc/codecs/wm8958-dsp2.c
index 754f88e..4892966 100644
--- a/sound/soc/codecs/wm8958-dsp2.c
+++ b/sound/soc/codecs/wm8958-dsp2.c
@@ -459,7 +459,7 @@ static int wm8958_put_mbc_enum(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct wm8994 *control = wm8994->wm8994;
-	int value = ucontrol->value.integer.value[0];
+	int value = ucontrol->value.enumerated.item[0];
 	int reg;
 
 	/* Don't allow on the fly reconfiguration */
@@ -549,7 +549,7 @@ static int wm8958_put_vss_enum(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct wm8994 *control = wm8994->wm8994;
-	int value = ucontrol->value.integer.value[0];
+	int value = ucontrol->value.enumerated.item[0];
 	int reg;
 
 	/* Don't allow on the fly reconfiguration */
@@ -582,7 +582,7 @@ static int wm8958_put_vss_hpf_enum(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct wm8994 *control = wm8994->wm8994;
-	int value = ucontrol->value.integer.value[0];
+	int value = ucontrol->value.enumerated.item[0];
 	int reg;
 
 	/* Don't allow on the fly reconfiguration */
@@ -749,7 +749,7 @@ static int wm8958_put_enh_eq_enum(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct wm8994 *control = wm8994->wm8994;
-	int value = ucontrol->value.integer.value[0];
+	int value = ucontrol->value.enumerated.item[0];
 	int reg;
 
 	/* Don't allow on the fly reconfiguration */
diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c
index 412d90f..ae5bb95 100644
--- a/sound/soc/codecs/wm8960.c
+++ b/sound/soc/codecs/wm8960.c
@@ -181,7 +181,7 @@ static int wm8960_get_deemph(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
 
-	ucontrol->value.enumerated.item[0] = wm8960->deemph;
+	ucontrol->value.integer.value[0] = wm8960->deemph;
 	return 0;
 }
 
@@ -190,7 +190,7 @@ static int wm8960_put_deemph(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
-	int deemph = ucontrol->value.enumerated.item[0];
+	int deemph = ucontrol->value.integer.value[0];
 
 	if (deemph > 1)
 		return -EINVAL;
@@ -242,7 +242,7 @@ SOC_SINGLE("PCM Playback -6dB Switch", WM8960_DACCTL1, 7, 1, 0),
 SOC_ENUM("ADC Polarity", wm8960_enum[0]),
 SOC_SINGLE("ADC High Pass Filter Switch", WM8960_DACCTL1, 0, 1, 0),
 
-SOC_ENUM("DAC Polarity", wm8960_enum[2]),
+SOC_ENUM("DAC Polarity", wm8960_enum[1]),
 SOC_SINGLE_BOOL_EXT("DAC Deemphasis Switch", 0,
 		    wm8960_get_deemph, wm8960_put_deemph),
 
@@ -392,7 +392,7 @@ static const struct snd_soc_dapm_route audio_paths[] = {
 	{ "Right Input Mixer", "Boost Switch", "Right Boost Mixer", },
 	{ "Right Input Mixer", NULL, "RINPUT1", },  /* Really Boost Switch */
 	{ "Right Input Mixer", NULL, "RINPUT2" },
-	{ "Right Input Mixer", NULL, "LINPUT3" },
+	{ "Right Input Mixer", NULL, "RINPUT3" },
 
 	{ "Left ADC", NULL, "Left Input Mixer" },
 	{ "Right ADC", NULL, "Right Input Mixer" },
diff --git a/sound/soc/codecs/wm8962.c b/sound/soc/codecs/wm8962.c
index 1ae1f8b..305d28d 100644
--- a/sound/soc/codecs/wm8962.c
+++ b/sound/soc/codecs/wm8962.c
@@ -363,8 +363,8 @@ static struct reg_default wm8962_reg[] = {
 	{ 16924, 0x0059 },   /* R16924 - HDBASS_PG_1 */
 	{ 16925, 0x999A },   /* R16925 - HDBASS_PG_0 */
 
-	{ 17048, 0x0083 },   /* R17408 - HPF_C_1 */
-	{ 17049, 0x98AD },   /* R17409 - HPF_C_0 */
+	{ 17408, 0x0083 },   /* R17408 - HPF_C_1 */
+	{ 17409, 0x98AD },   /* R17409 - HPF_C_0 */
 
 	{ 17920, 0x007F },   /* R17920 - ADCL_RETUNE_C1_1 */
 	{ 17921, 0xFFFF },   /* R17921 - ADCL_RETUNE_C1_0 */
diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c
index 2519c06..8d62148 100644
--- a/sound/soc/codecs/wm8994.c
+++ b/sound/soc/codecs/wm8994.c
@@ -361,7 +361,7 @@ static int wm8994_put_drc_enum(struct snd_kcontrol *kcontrol,
 	struct wm8994 *control = wm8994->wm8994;
 	struct wm8994_pdata *pdata = &control->pdata;
 	int drc = wm8994_get_drc(kcontrol->id.name);
-	int value = ucontrol->value.integer.value[0];
+	int value = ucontrol->value.enumerated.item[0];
 
 	if (drc < 0)
 		return drc;
@@ -468,7 +468,7 @@ static int wm8994_put_retune_mobile_enum(struct snd_kcontrol *kcontrol,
 	struct wm8994 *control = wm8994->wm8994;
 	struct wm8994_pdata *pdata = &control->pdata;
 	int block = wm8994_get_retune_mobile_block(kcontrol->id.name);
-	int value = ucontrol->value.integer.value[0];
+	int value = ucontrol->value.enumerated.item[0];
 
 	if (block < 0)
 		return block;
@@ -2679,7 +2679,7 @@ static struct {
 };
 
 static int fs_ratios[] = {
-	64, 128, 192, 256, 348, 512, 768, 1024, 1408, 1536
+	64, 128, 192, 256, 384, 512, 768, 1024, 1408, 1536
 };
 
 static int bclk_divs[] = {
diff --git a/sound/soc/dwc/designware_i2s.c b/sound/soc/dwc/designware_i2s.c
index 489a9ab..6a530af 100644
--- a/sound/soc/dwc/designware_i2s.c
+++ b/sound/soc/dwc/designware_i2s.c
@@ -100,10 +100,10 @@ static inline void i2s_clear_irqs(struct dw_i2s_dev *dev, u32 stream)
 
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		for (i = 0; i < 4; i++)
-			i2s_write_reg(dev->i2s_base, TOR(i), 0);
+			i2s_read_reg(dev->i2s_base, TOR(i));
 	} else {
 		for (i = 0; i < 4; i++)
-			i2s_write_reg(dev->i2s_base, ROR(i), 0);
+			i2s_read_reg(dev->i2s_base, ROR(i));
 	}
 }
 
diff --git a/sound/soc/pxa/Kconfig b/sound/soc/pxa/Kconfig
index 4d2e46f..20a57c0 100644
--- a/sound/soc/pxa/Kconfig
+++ b/sound/soc/pxa/Kconfig
@@ -1,7 +1,6 @@
 config SND_PXA2XX_SOC
 	tristate "SoC Audio for the Intel PXA2xx chip"
 	depends on ARCH_PXA
-	select SND_ARM
 	select SND_PXA2XX_LIB
 	help
 	  Say Y or M if you want to add support for codecs attached to
@@ -24,7 +23,6 @@ config SND_PXA2XX_AC97
 config SND_PXA2XX_SOC_AC97
 	tristate
 	select AC97_BUS
-	select SND_ARM
 	select SND_PXA2XX_LIB_AC97
 	select SND_SOC_AC97_BUS
 
diff --git a/sound/soc/samsung/s3c-i2s-v2.c b/sound/soc/samsung/s3c-i2s-v2.c
index 20e98d1..38c36cd 100644
--- a/sound/soc/samsung/s3c-i2s-v2.c
+++ b/sound/soc/samsung/s3c-i2s-v2.c
@@ -732,7 +732,7 @@ static int s3c2412_i2s_resume(struct snd_soc_dai *dai)
 #endif
 
 int s3c_i2sv2_register_component(struct device *dev, int id,
-			   struct snd_soc_component_driver *cmp_drv,
+			   const struct snd_soc_component_driver *cmp_drv,
 			   struct snd_soc_dai_driver *dai_drv)
 {
 	struct snd_soc_dai_ops *ops = drv->ops;
diff --git a/sound/soc/samsung/s3c-i2s-v2.h b/sound/soc/samsung/s3c-i2s-v2.h
index 90abab3..d068414 100644
--- a/sound/soc/samsung/s3c-i2s-v2.h
+++ b/sound/soc/samsung/s3c-i2s-v2.h
@@ -101,7 +101,7 @@ extern int s3c_i2sv2_probe(struct snd_soc_dai *dai,
  * soc core.
  */
 extern int s3c_i2sv2_register_component(struct device *dev, int id,
-					struct snd_soc_component_driver *cmp_drv,
+					const struct snd_soc_component_driver *cmp_drv,
 					struct snd_soc_dai_driver *dai_drv);
 
 #endif /* __SND_SOC_S3C24XX_S3C_I2SV2_I2S_H */
diff --git a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c
index 06a8000..2340554 100644
--- a/sound/soc/soc-compress.c
+++ b/sound/soc/soc-compress.c
@@ -384,17 +384,34 @@ int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)
 	struct snd_compr *compr;
 	char new_name[64];
 	int ret = 0, direction = 0;
+	int playback = 0, capture = 0;
 
 	/* check client and interface hw capabilities */
 	snprintf(new_name, sizeof(new_name), "%s %s-%d",
 			rtd->dai_link->stream_name, codec_dai->name, num);
 
 	if (codec_dai->driver->playback.channels_min)
+		playback = 1;
+	if (codec_dai->driver->capture.channels_min)
+		capture = 1;
+
+	capture = capture && cpu_dai->driver->capture.channels_min;
+	playback = playback && cpu_dai->driver->playback.channels_min;
+
+	/*
+	 * Compress devices are unidirectional so only one of the directions
+	 * should be set, check for that (xor)
+	 */
+	if (playback + capture != 1) {
+		dev_err(rtd->card->dev, "Invalid direction for compress P %d, C %d\n",
+				playback, capture);
+		return -EINVAL;
+	}
+
+	if(playback)
 		direction = SND_COMPRESS_PLAYBACK;
-	else if (codec_dai->driver->capture.channels_min)
-		direction = SND_COMPRESS_CAPTURE;
 	else
-		return -EINVAL;
+		direction = SND_COMPRESS_CAPTURE;
 
 	compr = kzalloc(sizeof(*compr), GFP_KERNEL);
 	if (compr == NULL) {
diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
index 02d2691..c6d408c 100644
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -1248,7 +1248,8 @@ static int dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream)
 		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &&
 		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&
 		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED) &&
-		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))
+		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP) &&
+		    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND))
 			continue;
 
 		dev_dbg(be->dev, "ASoC: hw_free BE %s\n",
diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c
index 319754c..646b667 100644
--- a/sound/synth/emux/emux_oss.c
+++ b/sound/synth/emux/emux_oss.c
@@ -69,7 +69,8 @@ snd_emux_init_seq_oss(struct snd_emux *emu)
 	struct snd_seq_oss_reg *arg;
 	struct snd_seq_device *dev;
 
-	if (snd_seq_device_new(emu->card, 0, SNDRV_SEQ_DEV_ID_OSS,
+	/* using device#1 here for avoiding conflicts with OPL3 */
+	if (snd_seq_device_new(emu->card, 1, SNDRV_SEQ_DEV_ID_OSS,
 			       sizeof(struct snd_seq_oss_reg), &dev) < 0)
 		return;
 
@@ -118,12 +119,8 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 	if (snd_BUG_ON(!arg || !emu))
 		return -ENXIO;
 
-	mutex_lock(&emu->register_mutex);
-
-	if (!snd_emux_inc_count(emu)) {
-		mutex_unlock(&emu->register_mutex);
+	if (!snd_emux_inc_count(emu))
 		return -EFAULT;
-	}
 
 	memset(&callback, 0, sizeof(callback));
 	callback.owner = THIS_MODULE;
@@ -135,7 +132,6 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 	if (p == NULL) {
 		snd_printk(KERN_ERR "can't create port\n");
 		snd_emux_dec_count(emu);
-		mutex_unlock(&emu->register_mutex);
 		return -ENOMEM;
 	}
 
@@ -148,8 +144,6 @@ snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)
 	reset_port_mode(p, arg->seq_mode);
 
 	snd_emux_reset_port(p);
-
-	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
 
@@ -195,13 +189,11 @@ snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)
 	if (snd_BUG_ON(!emu))
 		return -ENXIO;
 
-	mutex_lock(&emu->register_mutex);
 	snd_emux_sounds_off_all(p);
 	snd_soundfont_close_check(emu->sflist, SF_CLIENT_NO(p->chset.port));
 	snd_seq_event_port_detach(p->chset.client, p->chset.port);
 	snd_emux_dec_count(emu);
 
-	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
 
diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c
index 7778b8e..a020920 100644
--- a/sound/synth/emux/emux_seq.c
+++ b/sound/synth/emux/emux_seq.c
@@ -124,12 +124,10 @@ snd_emux_detach_seq(struct snd_emux *emu)
 	if (emu->voices)
 		snd_emux_terminate_all(emu);
 		
-	mutex_lock(&emu->register_mutex);
 	if (emu->client >= 0) {
 		snd_seq_delete_kernel_client(emu->client);
 		emu->client = -1;
 	}
-	mutex_unlock(&emu->register_mutex);
 }
 
 
@@ -269,8 +267,8 @@ snd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,
 /*
  * increment usage count
  */
-int
-snd_emux_inc_count(struct snd_emux *emu)
+static int
+__snd_emux_inc_count(struct snd_emux *emu)
 {
 	emu->used++;
 	if (!try_module_get(emu->ops.owner))
@@ -284,12 +282,21 @@ snd_emux_inc_count(struct snd_emux *emu)
 	return 1;
 }
 
+int snd_emux_inc_count(struct snd_emux *emu)
+{
+	int ret;
+
+	mutex_lock(&emu->register_mutex);
+	ret = __snd_emux_inc_count(emu);
+	mutex_unlock(&emu->register_mutex);
+	return ret;
+}
 
 /*
  * decrease usage count
  */
-void
-snd_emux_dec_count(struct snd_emux *emu)
+static void
+__snd_emux_dec_count(struct snd_emux *emu)
 {
 	module_put(emu->card->module);
 	emu->used--;
@@ -298,6 +305,12 @@ snd_emux_dec_count(struct snd_emux *emu)
 	module_put(emu->ops.owner);
 }
 
+void snd_emux_dec_count(struct snd_emux *emu)
+{
+	mutex_lock(&emu->register_mutex);
+	__snd_emux_dec_count(emu);
+	mutex_unlock(&emu->register_mutex);
+}
 
 /*
  * Routine that is called upon a first use of a particular port
@@ -317,7 +330,7 @@ snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)
 
 	mutex_lock(&emu->register_mutex);
 	snd_emux_init_port(p);
-	snd_emux_inc_count(emu);
+	__snd_emux_inc_count(emu);
 	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
@@ -340,7 +353,7 @@ snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)
 
 	mutex_lock(&emu->register_mutex);
 	snd_emux_sounds_off_all(p);
-	snd_emux_dec_count(emu);
+	__snd_emux_dec_count(emu);
 	mutex_unlock(&emu->register_mutex);
 	return 0;
 }
diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 9324913..37ecba3 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -174,6 +174,8 @@ struct snd_usb_midi_in_endpoint {
 		u8 running_status_length;
 	} ports[0x10];
 	u8 seen_f5;
+	bool in_sysex;
+	u8 last_cin;
 	u8 error_resubmit;
 	int current_port;
 };
@@ -465,6 +467,39 @@ static void snd_usbmidi_maudio_broken_running_status_input(
 }
 
 /*
+ * QinHeng CH345 is buggy: every second packet inside a SysEx has not CIN 4
+ * but the previously seen CIN, but still with three data bytes.
+ */
+static void ch345_broken_sysex_input(struct snd_usb_midi_in_endpoint *ep,
+				     uint8_t *buffer, int buffer_length)
+{
+	unsigned int i, cin, length;
+
+	for (i = 0; i + 3 < buffer_length; i += 4) {
+		if (buffer[i] == 0 && i > 0)
+			break;
+		cin = buffer[i] & 0x0f;
+		if (ep->in_sysex &&
+		    cin == ep->last_cin &&
+		    (buffer[i + 1 + (cin == 0x6)] & 0x80) == 0)
+			cin = 0x4;
+#if 0
+		if (buffer[i + 1] == 0x90) {
+			/*
+			 * Either a corrupted running status or a real note-on
+			 * message; impossible to detect reliably.
+			 */
+		}
+#endif
+		length = snd_usbmidi_cin_length[cin];
+		snd_usbmidi_input_data(ep, 0, &buffer[i + 1], length);
+		ep->in_sysex = cin == 0x4;
+		if (!ep->in_sysex)
+			ep->last_cin = cin;
+	}
+}
+
+/*
  * CME protocol: like the standard protocol, but SysEx commands are sent as a
  * single USB packet preceded by a 0x0F byte.
  */
@@ -650,6 +685,12 @@ static struct usb_protocol_ops snd_usbmidi_cme_ops = {
 	.output_packet = snd_usbmidi_output_standard_packet,
 };
 
+static struct usb_protocol_ops snd_usbmidi_ch345_broken_sysex_ops = {
+	.input = ch345_broken_sysex_input,
+	.output = snd_usbmidi_standard_output,
+	.output_packet = snd_usbmidi_output_standard_packet,
+};
+
 /*
  * AKAI MPD16 protocol:
  *
@@ -1326,6 +1367,7 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi* umidi,
 		 * Various chips declare a packet size larger than 4 bytes, but
 		 * do not actually work with larger packets:
 		 */
+	case USB_ID(0x0a67, 0x5011): /* Medeli DD305 */
 	case USB_ID(0x0a92, 0x1020): /* ESI M4U */
 	case USB_ID(0x1430, 0x474b): /* RedOctane GH MIDI INTERFACE */
 	case USB_ID(0x15ca, 0x0101): /* Textech USB Midi Cable */
@@ -2216,6 +2258,10 @@ int snd_usbmidi_create(struct snd_card *card,
 
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
+	case QUIRK_MIDI_CH345:
+		umidi->usb_protocol_ops = &snd_usbmidi_ch345_broken_sysex_ops;
+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
+		break;
 	default:
 		snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
 		err = -ENXIO;
@@ -2245,7 +2291,6 @@ int snd_usbmidi_create(struct snd_card *card,
 	else
 		err = snd_usbmidi_create_endpoints(umidi, endpoints);
 	if (err < 0) {
-		snd_usbmidi_free(umidi);
 		return err;
 	}
 
diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
index 061be0e..5ea5a18 100644
--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -891,6 +891,7 @@ static void volume_control_quirks(struct usb_mixer_elem_info *cval,
 	case USB_ID(0x046d, 0x081d): /* HD Webcam c510 */
 	case USB_ID(0x046d, 0x0825): /* HD Webcam c270 */
 	case USB_ID(0x046d, 0x0826): /* HD Webcam c525 */
+	case USB_ID(0x046d, 0x08ca): /* Logitech Quickcam Fusion */
 	case USB_ID(0x046d, 0x0991):
 	/* Most audio usb devices lie about volume resolution.
 	 * Most Logitech webcams have res = 384.
diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c
index 4df31b0..2d17f40f 100644
--- a/sound/usb/mixer_maps.c
+++ b/sound/usb/mixer_maps.c
@@ -330,6 +330,20 @@ static const struct usbmix_name_map scms_usb3318_map[] = {
 	{ 0 }
 };
 
+/* Bose companion 5, the dB conversion factor is 16 instead of 256 */
+static struct usbmix_dB_map bose_companion5_dB = {-5006, -6};
+static struct usbmix_name_map bose_companion5_map[] = {
+	{ 3, NULL, .dB = &bose_companion5_dB },
+	{ 0 }	/* terminator */
+};
+
+/* Dragonfly DAC 1.2, the dB conversion factor is 1 instead of 256 */
+static struct usbmix_dB_map dragonfly_1_2_dB = {0, 5000};
+static struct usbmix_name_map dragonfly_1_2_map[] = {
+	{ 7, NULL, .dB = &dragonfly_1_2_dB },
+	{ 0 }	/* terminator */
+};
+
 /*
  * Control map entries
  */
@@ -418,6 +432,11 @@ static struct usbmix_ctl_map usbmix_ctl_maps[] = {
 		.map = ebox44_map,
 	},
 	{
+		/* MAYA44 USB+ */
+		.id = USB_ID(0x2573, 0x0008),
+		.map = maya44_map,
+	},
+	{
 		/* KEF X300A */
 		.id = USB_ID(0x27ac, 0x1000),
 		.map = scms_usb3318_map,
@@ -427,6 +446,16 @@ static struct usbmix_ctl_map usbmix_ctl_maps[] = {
 		.id = USB_ID(0x25c4, 0x0003),
 		.map = scms_usb3318_map,
 	},
+	{
+		/* Bose Companion 5 */
+		.id = USB_ID(0x05a7, 0x1020),
+		.map = bose_companion5_map,
+	},
+	{
+		/* Dragonfly DAC 1.2 */
+		.id = USB_ID(0x21b4, 0x0081),
+		.map = dragonfly_1_2_map,
+	},
 	{ 0 } /* terminator */
 };
 
diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c
index c89a5bf..c311681 100644
--- a/sound/usb/mixer_quirks.c
+++ b/sound/usb/mixer_quirks.c
@@ -175,6 +175,7 @@ static const struct rc_config {
 	{ USB_ID(0x041e, 0x3040), 2, 2, 6, 6,  2,  0x6e91 }, /* Live! 24-bit */
 	{ USB_ID(0x041e, 0x3042), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 */
 	{ USB_ID(0x041e, 0x30df), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 Pro */
+	{ USB_ID(0x041e, 0x3237), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 Pro */
 	{ USB_ID(0x041e, 0x3048), 2, 2, 6, 6,  2,  0x6e91 }, /* Toshiba SB0500 */
 };
 
diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h
index d5bed1d..9ec5ce4 100644
--- a/sound/usb/quirks-table.h
+++ b/sound/usb/quirks-table.h
@@ -2773,6 +2773,74 @@ YAMAHA_DEVICE(0x7010, "UB99"),
 	}
 },
 
+/* Steinberg devices */
+{
+	/* Steinberg MI2 */
+	USB_DEVICE_VENDOR_SPEC(0x0a4e, 0x2040),
+	.driver_info = (unsigned long) & (const struct snd_usb_audio_quirk) {
+		.ifnum = QUIRK_ANY_INTERFACE,
+		.type = QUIRK_COMPOSITE,
+		.data = & (const struct snd_usb_audio_quirk[]) {
+			{
+				.ifnum = 0,
+				.type = QUIRK_AUDIO_STANDARD_INTERFACE
+			},
+			{
+				.ifnum = 1,
+				.type = QUIRK_AUDIO_STANDARD_INTERFACE
+			},
+			{
+				.ifnum = 2,
+				.type = QUIRK_AUDIO_STANDARD_INTERFACE
+			},
+			{
+				.ifnum = 3,
+				.type = QUIRK_MIDI_FIXED_ENDPOINT,
+				.data = &(const struct snd_usb_midi_endpoint_info) {
+					.out_cables = 0x0001,
+					.in_cables  = 0x0001
+				}
+			},
+			{
+				.ifnum = -1
+			}
+		}
+	}
+},
+{
+	/* Steinberg MI4 */
+	USB_DEVICE_VENDOR_SPEC(0x0a4e, 0x4040),
+	.driver_info = (unsigned long) & (const struct snd_usb_audio_quirk) {
+		.ifnum = QUIRK_ANY_INTERFACE,
+		.type = QUIRK_COMPOSITE,
+		.data = & (const struct snd_usb_audio_quirk[]) {
+			{
+				.ifnum = 0,
+				.type = QUIRK_AUDIO_STANDARD_INTERFACE
+			},
+			{
+				.ifnum = 1,
+				.type = QUIRK_AUDIO_STANDARD_INTERFACE
+			},
+			{
+				.ifnum = 2,
+				.type = QUIRK_AUDIO_STANDARD_INTERFACE
+			},
+			{
+				.ifnum = 3,
+				.type = QUIRK_MIDI_FIXED_ENDPOINT,
+				.data = &(const struct snd_usb_midi_endpoint_info) {
+					.out_cables = 0x0001,
+					.in_cables  = 0x0001
+				}
+			},
+			{
+				.ifnum = -1
+			}
+		}
+	}
+},
+
 /* TerraTec devices */
 {
 	USB_DEVICE_VENDOR_SPEC(0x0ccd, 0x0012),
@@ -2973,6 +3041,17 @@ YAMAHA_DEVICE(0x7010, "UB99"),
 	.idProduct = 0x1020,
 },
 
+/* QinHeng devices */
+{
+	USB_DEVICE(0x1a86, 0x752d),
+	.driver_info = (unsigned long) &(const struct snd_usb_audio_quirk) {
+		.vendor_name = "QinHeng",
+		.product_name = "CH345",
+		.ifnum = 1,
+		.type = QUIRK_MIDI_CH345
+	}
+},
+
 /* KeithMcMillen Stringport */
 {
 	USB_DEVICE(0x1f38, 0x0001),
diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 734c657..44550a4 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -313,6 +313,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 		[QUIRK_MIDI_CME] = create_any_midi_quirk,
 		[QUIRK_MIDI_AKAI] = create_any_midi_quirk,
 		[QUIRK_MIDI_FTDI] = create_any_midi_quirk,
+		[QUIRK_MIDI_CH345] = create_any_midi_quirk,
 		[QUIRK_AUDIO_STANDARD_INTERFACE] = create_standard_audio_quirk,
 		[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,
 		[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,
@@ -899,8 +900,12 @@ void snd_usb_set_interface_quirk(struct usb_device *dev)
 	 * "Playback Design" products need a 50ms delay after setting the
 	 * USB interface.
 	 */
-	if (le16_to_cpu(dev->descriptor.idVendor) == 0x23ba)
+	switch (le16_to_cpu(dev->descriptor.idVendor)) {
+	case 0x23ba: /* Playback Design */
+	case 0x0644: /* TEAC Corp. */
 		mdelay(50);
+		break;
+	}
 }
 
 void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
@@ -915,6 +920,14 @@ void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
 	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
+	/*
+	 * "TEAC Corp." products need a 20ms delay after each
+	 * class compliant request
+	 */
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x0644) &&
+	    (requesttype & USB_TYPE_MASK) == USB_TYPE_CLASS)
+		mdelay(20);
+
 	/* Marantz/Denon devices with USB DAC functionality need a delay
 	 * after each class compliant request
 	 */
diff --git a/sound/usb/usbaudio.h b/sound/usb/usbaudio.h
index bc43bca..d6f3fef 100644
--- a/sound/usb/usbaudio.h
+++ b/sound/usb/usbaudio.h
@@ -83,6 +83,7 @@ enum quirk_type {
 	QUIRK_MIDI_AKAI,
 	QUIRK_MIDI_US122L,
 	QUIRK_MIDI_FTDI,
+	QUIRK_MIDI_CH345,
 	QUIRK_AUDIO_STANDARD_INTERFACE,
 	QUIRK_AUDIO_FIXED_ENDPOINT,
 	QUIRK_AUDIO_EDIROL_UAXX,
diff --git a/tools/Makefile b/tools/Makefile
index 41067f3..b82a15b 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -22,6 +22,10 @@ help:
 	@echo '  from the kernel command line to build and install one of'
 	@echo '  the tools above'
 	@echo ''
+	@echo '  $$ make tools/all'
+	@echo ''
+	@echo '  builds all tools.'
+	@echo ''
 	@echo '  $$ make tools/install'
 	@echo ''
 	@echo '  installs all tools.'
@@ -50,6 +54,10 @@ selftests: FORCE
 turbostat x86_energy_perf_policy: FORCE
 	$(call descend,power/x86/$@)
 
+all: cgroup cpupower firewire lguest \
+		perf selftests turbostat usb \
+		virtio vm net x86_energy_perf_policy
+
 cpupower_install:
 	$(call descend,power/$(@:_install=),install)
 
diff --git a/tools/lib/traceevent/event-parse.c b/tools/lib/traceevent/event-parse.c
index 82b0606..c3efcf2 100644
--- a/tools/lib/traceevent/event-parse.c
+++ b/tools/lib/traceevent/event-parse.c
@@ -4190,13 +4190,12 @@ static void pretty_print(struct trace_seq *s, void *data, int size, struct event
 				    sizeof(long) != 8) {
 					char *p;
 
-					ls = 2;
 					/* make %l into %ll */
-					p = strchr(format, 'l');
-					if (p)
+					if (ls == 1 && (p = strchr(format, 'l')))
 						memmove(p+1, p, strlen(p)+1);
 					else if (strcmp(format, "%p") == 0)
 						strcpy(format, "0x%llx");
+					ls = 2;
 				}
 				switch (ls) {
 				case -2:
diff --git a/tools/perf/Documentation/perf-stat.txt b/tools/perf/Documentation/perf-stat.txt
index 2fe87fb..8c96047 100644
--- a/tools/perf/Documentation/perf-stat.txt
+++ b/tools/perf/Documentation/perf-stat.txt
@@ -50,6 +50,14 @@ OPTIONS
 --scale::
 	scale/normalize counter values
 
+-d::
+--detailed::
+	print more detailed statistics, can be specified up to 3 times
+
+	   -d:          detailed events, L1 and LLC data cache
+        -d -d:     more detailed events, dTLB and iTLB events
+     -d -d -d:     very detailed events, adding prefetch events
+
 -r::
 --repeat=<n>::
 	repeat command and print average + stddev (max: 100). 0 means forever.
diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c
index 326068a..bb34199 100644
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@ -1729,7 +1729,7 @@ static int process_nrcpus(struct perf_file_section *section __maybe_unused,
 	if (ph->needs_swap)
 		nr = bswap_32(nr);
 
-	ph->env.nr_cpus_online = nr;
+	ph->env.nr_cpus_avail = nr;
 
 	ret = readn(fd, &nr, sizeof(nr));
 	if (ret != sizeof(nr))
@@ -1738,7 +1738,7 @@ static int process_nrcpus(struct perf_file_section *section __maybe_unused,
 	if (ph->needs_swap)
 		nr = bswap_32(nr);
 
-	ph->env.nr_cpus_avail = nr;
+	ph->env.nr_cpus_online = nr;
 	return 0;
 }
 
diff --git a/tools/power/x86/turbostat/Makefile b/tools/power/x86/turbostat/Makefile
index d1b3a36..4039854 100644
--- a/tools/power/x86/turbostat/Makefile
+++ b/tools/power/x86/turbostat/Makefile
@@ -1,8 +1,12 @@
 CC		= $(CROSS_COMPILE)gcc
-BUILD_OUTPUT	:= $(PWD)
+BUILD_OUTPUT	:= $(CURDIR)
 PREFIX		:= /usr
 DESTDIR		:=
 
+ifeq ("$(origin O)", "command line")
+	BUILD_OUTPUT := $(O)
+endif
+
 turbostat : turbostat.c
 CFLAGS +=	-Wall
 CFLAGS +=	-DMSRHEADER='"../../../../arch/x86/include/uapi/asm/msr-index.h"'
diff --git a/tools/testing/selftests/efivarfs/efivarfs.sh b/tools/testing/selftests/efivarfs/efivarfs.sh
index 77edcdc..0572784 100644
--- a/tools/testing/selftests/efivarfs/efivarfs.sh
+++ b/tools/testing/selftests/efivarfs/efivarfs.sh
@@ -88,7 +88,11 @@ test_delete()
 		exit 1
 	fi
 
-	rm $file
+	rm $file 2>/dev/null
+	if [ $? -ne 0 ]; then
+		chattr -i $file
+		rm $file
+	fi
 
 	if [ -e $file ]; then
 		echo "$file couldn't be deleted" >&2
@@ -111,6 +115,7 @@ test_zero_size_delete()
 		exit 1
 	fi
 
+	chattr -i $file
 	printf "$attrs" > $file
 
 	if [ -e $file ]; then
@@ -141,7 +146,11 @@ test_valid_filenames()
 			echo "$file could not be created" >&2
 			ret=1
 		else
-			rm $file
+			rm $file 2>/dev/null
+			if [ $? -ne 0 ]; then
+				chattr -i $file
+				rm $file
+			fi
 		fi
 	done
 
@@ -174,7 +183,11 @@ test_invalid_filenames()
 
 		if [ -e $file ]; then
 			echo "Creating $file should have failed" >&2
-			rm $file
+			rm $file 2>/dev/null
+			if [ $? -ne 0 ]; then
+				chattr -i $file
+				rm $file
+			fi
 			ret=1
 		fi
 	done
diff --git a/tools/testing/selftests/efivarfs/open-unlink.c b/tools/testing/selftests/efivarfs/open-unlink.c
index 8c07644..4af74f7 100644
--- a/tools/testing/selftests/efivarfs/open-unlink.c
+++ b/tools/testing/selftests/efivarfs/open-unlink.c
@@ -1,10 +1,68 @@
+#include <errno.h>
 #include <stdio.h>
 #include <stdint.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <sys/ioctl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#include <linux/fs.h>
+
+static int set_immutable(const char *path, int immutable)
+{
+	unsigned int flags;
+	int fd;
+	int rc;
+	int error;
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return fd;
+
+	rc = ioctl(fd, FS_IOC_GETFLAGS, &flags);
+	if (rc < 0) {
+		error = errno;
+		close(fd);
+		errno = error;
+		return rc;
+	}
+
+	if (immutable)
+		flags |= FS_IMMUTABLE_FL;
+	else
+		flags &= ~FS_IMMUTABLE_FL;
+
+	rc = ioctl(fd, FS_IOC_SETFLAGS, &flags);
+	error = errno;
+	close(fd);
+	errno = error;
+	return rc;
+}
+
+static int get_immutable(const char *path)
+{
+	unsigned int flags;
+	int fd;
+	int rc;
+	int error;
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return fd;
+
+	rc = ioctl(fd, FS_IOC_GETFLAGS, &flags);
+	if (rc < 0) {
+		error = errno;
+		close(fd);
+		errno = error;
+		return rc;
+	}
+	close(fd);
+	if (flags & FS_IMMUTABLE_FL)
+		return 1;
+	return 0;
+}
 
 int main(int argc, char **argv)
 {
@@ -27,7 +85,7 @@ int main(int argc, char **argv)
 	buf[4] = 0;
 
 	/* create a test variable */
-	fd = open(path, O_WRONLY | O_CREAT);
+	fd = open(path, O_WRONLY | O_CREAT, 0600);
 	if (fd < 0) {
 		perror("open(O_WRONLY)");
 		return EXIT_FAILURE;
@@ -41,6 +99,18 @@ int main(int argc, char **argv)
 
 	close(fd);
 
+	rc = get_immutable(path);
+	if (rc < 0) {
+		perror("ioctl(FS_IOC_GETFLAGS)");
+		return EXIT_FAILURE;
+	} else if (rc) {
+		rc = set_immutable(path, 0);
+		if (rc < 0) {
+			perror("ioctl(FS_IOC_SETFLAGS)");
+			return EXIT_FAILURE;
+		}
+	}
+
 	fd = open(path, O_RDONLY);
 	if (fd < 0) {
 		perror("open");
diff --git a/virt/kvm/async_pf.c b/virt/kvm/async_pf.c
index ea475cd..ca2d05a 100644
--- a/virt/kvm/async_pf.c
+++ b/virt/kvm/async_pf.c
@@ -158,7 +158,7 @@ int kvm_setup_async_pf(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,
 	 * do alloc nowait since if we are going to sleep anyway we
 	 * may as well sleep faulting in page
 	 */
-	work = kmem_cache_zalloc(async_pf_cache, GFP_NOWAIT);
+	work = kmem_cache_zalloc(async_pf_cache, GFP_NOWAIT | __GFP_NOWARN);
 	if (!work)
 		return 0;
 
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index a17f190..f71c4ad 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -468,6 +468,16 @@ static struct kvm *kvm_create_vm(unsigned long type)
 	if (!kvm)
 		return ERR_PTR(-ENOMEM);
 
+	spin_lock_init(&kvm->mmu_lock);
+	atomic_inc(&current->mm->mm_count);
+	kvm->mm = current->mm;
+	kvm_eventfd_init(kvm);
+	mutex_init(&kvm->lock);
+	mutex_init(&kvm->irq_lock);
+	mutex_init(&kvm->slots_lock);
+	atomic_set(&kvm->users_count, 1);
+	INIT_LIST_HEAD(&kvm->devices);
+
 	r = kvm_arch_init_vm(kvm, type);
 	if (r)
 		goto out_err_nodisable;
@@ -497,16 +507,6 @@ static struct kvm *kvm_create_vm(unsigned long type)
 			goto out_err;
 	}
 
-	spin_lock_init(&kvm->mmu_lock);
-	kvm->mm = current->mm;
-	atomic_inc(&kvm->mm->mm_count);
-	kvm_eventfd_init(kvm);
-	mutex_init(&kvm->lock);
-	mutex_init(&kvm->irq_lock);
-	mutex_init(&kvm->slots_lock);
-	atomic_set(&kvm->users_count, 1);
-	INIT_LIST_HEAD(&kvm->devices);
-
 	r = kvm_init_mmu_notifier(kvm);
 	if (r)
 		goto out_err;
@@ -526,6 +526,7 @@ out_err_nodisable:
 		kfree(kvm->buses[i]);
 	kfree(kvm->memslots);
 	kvm_arch_free_vm(kvm);
+	mmdrop(current->mm);
 	return ERR_PTR(r);
 }
 
@@ -1549,8 +1550,8 @@ int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,
 	ghc->generation = slots->generation;
 	ghc->len = len;
 	ghc->memslot = gfn_to_memslot(kvm, start_gfn);
-	ghc->hva = gfn_to_hva_many(ghc->memslot, start_gfn, &nr_pages_avail);
-	if (!kvm_is_error_hva(ghc->hva) && nr_pages_avail >= nr_pages_needed) {
+	ghc->hva = gfn_to_hva_many(ghc->memslot, start_gfn, NULL);
+	if (!kvm_is_error_hva(ghc->hva) && nr_pages_needed <= 1) {
 		ghc->hva += offset;
 	} else {
 		/*
@@ -2446,7 +2447,7 @@ static long kvm_vm_ioctl(struct file *filp,
 		if (copy_from_user(&routing, argp, sizeof(routing)))
 			goto out;
 		r = -EINVAL;
-		if (routing.nr >= KVM_MAX_IRQ_ROUTES)
+		if (routing.nr > KVM_MAX_IRQ_ROUTES)
 			goto out;
 		if (routing.flags)
 			goto out;
