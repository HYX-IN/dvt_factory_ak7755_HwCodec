diff --git a/AmbaConfig b/AmbaConfig
index 71aeae1..40f4913 100644
--- a/AmbaConfig
+++ b/AmbaConfig
@@ -4,12 +4,29 @@
 ## History:
 ##    2008/02/19 - [Anthony Ginger] Create
 ##
-## Copyright (C) 2004-2009, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 choice
@@ -18,18 +35,6 @@ choice
 	help
 		Select the target arch.
 
-config CONFIG_ARCH_A5S
-	bool "A5S"
-
-config CONFIG_ARCH_A7L
-        bool "A7L"
-
-config CONFIG_ARCH_S2
-        bool "S2"
-
-config CONFIG_ARCH_S2E
-        bool "S2E"
-
 config CONFIG_ARCH_S2L
         bool "S2L"
 
@@ -39,28 +44,42 @@ config CONFIG_ARCH_S3
 config CONFIG_ARCH_S3L
         bool "S3L"
 
+config CONFIG_ARCH_S5
+	select CONFIG_4K_BOOT_IMAGE
+        bool "S5"
+
+config CONFIG_ARCH_H2
+	select CONFIG_4K_BOOT_IMAGE
+        bool "H2"
+
+config CONFIG_ARCH_S5L
+	select CONFIG_4K_BOOT_IMAGE
+        bool "S5L"
+
+config CONFIG_ARCH_CV1
+	select CONFIG_4K_BOOT_IMAGE
+        bool "CV1"
+
 endchoice
 
 choice
 	prompt "Build for CPU"
-	default CONFIG_CPU_ARM1136JS
+	default CONFIG_CPU_CORTEXA53
 	help
 		Select the CPU of the chip.
 
-config CONFIG_CPU_ARM1136JS
-	depends on CONFIG_ARCH_A5S || CONFIG_ARCH_A7L || CONFIG_ARCH_S2
-	bool "ARMv6 / ARM1136JS"
-
 config CONFIG_CPU_CORTEXA9
-	depends on CONFIG_ARCH_S2 || CONFIG_ARCH_S2E || CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || \
-		   CONFIG_ARCH_S3L
+	depends on CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || CONFIG_ARCH_S3L
 	bool "Cortex A9 / CodeSourcery"
 
 config CONFIG_CPU_CORTEXA9_HF
-	depends on CONFIG_ARCH_S2 || CONFIG_ARCH_S2E || CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || \
-		   CONFIG_ARCH_S3L
+	depends on CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || CONFIG_ARCH_S3L
 	bool "Cortex A9 / Linaro Hard Float"
 
+config CONFIG_CPU_CORTEXA53
+	depends on CONFIG_ARCH_S5 || CONFIG_ARCH_H2 || CONFIG_ARCH_S5L || CONFIG_ARCH_CV1
+	bool "Cortex A53"
+
 endchoice
 
 menu "Ambarella Board Configuration"
@@ -83,4 +102,3 @@ source amboot/config/amboot.hw.in
 source amboot/config/amboot.amboot.in
 
 endif
-
diff --git a/build/Makefile b/build/Makefile
index ae6be1c..4d66438 100644
--- a/build/Makefile
+++ b/build/Makefile
@@ -5,13 +5,31 @@
 ##    2005/01/26 - [Charles Chiou] created file
 ##    2007/10/23 - [Charles Chiou] migrated to the Linux tree
 ##    2008/02/19 - [Anthony Ginger] imported to AMBuild
+##    2017/03/22 - [Yupeng Chang ] change CC definition and add HOST_CC
 ##
-## Copyright (C) 2004-2007, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 AMBABUILD_TOPDIR	:= $(AMB_TOPDIR)
@@ -24,18 +42,38 @@ TOP			:= $(AMBABUILD_TOPDIR)/amboot
 SEDTOP			:= $(subst /,\\/,$(TOP))
 BUILD_DIR		:= $(dir $(DOT_CONFIG))
 
-#CROSS			:= $(TOOLCHAIN_PATH)/$(CROSS_COMPILE)
-CROSS			:= $(ARM_ELF_TOOLCHAIN_DIR)/bin/$(ARM_ELF_CROSS_COMPILE)
-AR			:= ar
-CC			:= gcc
-CPP			:= gcc -E
-LD			:= ld
-NM			:= nm
-OBJCOPY			:= objcopy
-RANLIB			:= ranlib
-STRIP			:= strip
+ifeq ($(CONFIG_ARMV8_AARCH32),y)
+CROSS			:= $(AARCH64_TOOLCHAIN_PATH)/$(AARCH64_CROSS_COMPILE)
+else
+CROSS			:= $(TOOLCHAIN_PATH)/$(CROSS_COMPILE)
+endif
+
+ifeq ($(CROSS), /)
+$(error Please Specify Toolchain!!!)
+endif
+
+#CROSS			:= $(ARM_ELF_TOOLCHAIN_DIR)/bin/$(ARM_ELF_CROSS_COMPILE)
+#ARM_ELF_TOOLCHAIN	:= yes
+
+AR			:= $(CROSS)ar
+CC			:= $(CROSS)gcc
+CPP			:= $(CROSS)gcc -E
+LD			:= $(CROSS)ld
+NM			:= $(CROSS)nm
+OBJCOPY		:= $(CROSS)objcopy
+RANLIB			:= $(CROSS)ranlib
+STRIP			:= $(CROSS)strip
+GCCDEP			:= $(CROSS)gcc -M -P
+
+HOST_AR		:= ar
+HOST_CC		:= gcc
+HOST_CPP		:= gcc -E
+HOST_LD		:= ld
+HOST_NM		:= nm
+HOST_OBJCOPY		:= objcopy
+HOST_RANLIB		:= ranlib
+HOST_STRIP		:= strip
 SED			:= sed
-GCCDEP			:= gcc -M -P
 
 MAKE_VERBOSE		= yes
 
diff --git a/config/Makefile.amboot b/config/Makefile.amboot
index 40cffe7..6382b26 100644
--- a/config/Makefile.amboot
+++ b/config/Makefile.amboot
@@ -5,13 +5,31 @@
 ##    2005/01/26 - [Charles Chiou] created file
 ##    2007/11/27 - [Charles Chiou] added echo supression
 ##    2008/02/19 - [Anthony Ginger] imported to AMBuild
+##    2015/11/10 - [Cao Rongrong] Support CortexA53
 ##
-## Copyright (C) 2004-2007, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 # Requirements:
@@ -21,51 +39,75 @@
 #	$(BSP)
 #	$(CROSS) and all the compilation tool variables.
 
-DEFINES =	-D__BUILD_AMBOOT__ -D__ARCH_$(ARCH)__ -D__BSP_$(BSP)__ \
-		$(EXTRA_DEFINES)
-INCLUDES =	-I$(TOP)/include -I$(TOP)/src/bld -I. \
+BUILD_TIME	= $(shell date +"%x %T")
+
+DEFINES		= -D__BUILD_AMBOOT__ -D__ARCH_$(ARCH)__ -D__BSP_$(BSP)__ \
+		$(EXTRA_DEFINES) -D__BUILD_TIME__="\"$(BUILD_TIME)\""
+INCLUDES	= -I$(TOP)/include -I$(TOP)/src/bld -I. \
 		-I$(BUILD_DIR) -I$(BSP_DIR) -I$(TOP)/src/bst
 
 ARCH_LO :=	$(shell gawk 'BEGIN { print tolower("$(ARCH)") }')
 SV_DIR :=	$(TOP)/sv/$(ARCH_LO)
 
-ARM1136JS_OPT	= -mcpu=arm1136j-s -mfpu=fpa
-CORTEXA9_OPT	= -march=armv7-a -mlittle-endian -mfpu=fpa
-ifeq ($(CPU),ARM1136JS)
-CPU_OPT =	$(ARM1136JS_OPT)
+OUTPUT_FORMAT_FLAG := elf32-littlearm
+
+ifeq ($(ARM_ELF_TOOLCHAIN),yes)
+CORTEXA9_OPT	= -march=armv7-a -marm -mfpu=fpa
+else
+CORTEXA9_OPT	= -march=armv7-a -mtune=cortex-a9 -marm -mfloat-abi=hard
 endif
+CORTEXA53_OPT	= -march=armv8-a -mgeneral-regs-only
+
 ifeq ($(CPU),CORTEXA9)
-CPU_OPT =	$(CORTEXA9_OPT)
+ARCH_CPU	= arm
+CPU_OPT		= $(CORTEXA9_OPT)
+CROSS_CPU_OPT	= $(CORTEXA9_OPT)
+endif
+ifeq ($(CPU),CORTEXA53)
+ARCH_CPU	= arm64
+CPU_OPT		= $(CORTEXA53_OPT)
+CROSS_CPU_OPT	= $(CORTEXA53_OPT)
+OUTPUT_FORMAT_FLAG := elf64-littleaarch64
 endif
 
+PANDORA_DIR := $(TOP)/pandora
+INCLUDES += -I$(PANDORA_DIR)
+PANDORA_ARCH_DIR := $(PANDORA_DIR)/$(ARCH_CPU)
+
+
 AFLAGS = \
-		-fomit-frame-pointer -fno-builtin -fno-strict-aliasing \
+		-fomit-frame-pointer \
 		-fno-common \
 		-nostdinc -D__ASM__ $(DEFINES) $(INCLUDES)
 
 CFLAGS_DEBUG = \
 		-Wall \
-		-fno-builtin -fno-strict-aliasing \
-		-fno-common \
+		$(CPU_OPT) \
+		-fno-builtin -fno-common \
 		-nostdinc $(DEFINES) -D__DEBUG_BUILD__ $(INCLUDES) \
 		-g -O0
 
 CFLAGS_RELEASE = \
 		-Wall \
-		-fno-builtin -fno-strict-aliasing \
-		-fno-common \
+		$(CPU_OPT) \
+		-fno-builtin -fno-common \
+		-Wl,--build-id=none \
 		-nostdinc $(DEFINES) -D__RELEASE_BUILD__ $(INCLUDES) \
 		-O3
 
+LDFLAGS		= \
+		$(CPU_OPT) -nostdlib \
+		-Wl,--build-id=none
+
 HOST_CFLAGS =	-D__BUILD_AMBOOT__ -D__BUILD_HOST__ \
 		-D__ARCH_$(ARCH)__ -D__BSP_$(BSP)__ $(EXTRA_DEFINES)
 
 __MAKE_HOST_OBJ = \
-		$(CC) $(HOST_CFLAGS) \
+		$(HOST_CC) $(HOST_CFLAGS) \
 		-I$(BUILD_DIR) -I$(TOP)/src -I$(TOP)/include -I$(TOP)/src/bld \
 		-I. -I$(BSP_DIR) -c $< -o $@
 __MAKE_HOST_EXE = \
-		$(CC) $(HOST_C_FLAGS) -o $@
+		$(HOST_CC) $(HOST_C_FLAGS) -o $@
 
 ifeq ($(MAKE_VERBOSE),yes)
 MAKE_HOST_OBJ =	$(__MAKE_HOST_OBJ)
@@ -84,12 +126,12 @@ ECHO_LDS =	@echo "  LDS       $@" ;
 ECHO_STRIP =	@echo "  STRIP     $@" ;
 endif
 
-__ASM_NDEBUG_OBJ =	$(CROSS)$(CC) $(CPU_OPT) $(AFLAGS) -c $< -o $@
-__ASM_DEBUG_OBJ =	$(CROSS)$(CC) $(CPU_OPT) $(AFLAGS) -Wa,-gdwarf2 -c $< -o $@
-ASM_NDEBUG_CORTEX_OBJ =	$(CROSS)$(CC) $(CORTEXA9_OPT) $(AFLAGS) -c $< -o $@
-ASM_DEBUG_CORTEX_OBJ =	$(CROSS)$(CC) $(CORTEXA9_OPT) $(AFLAGS) -Wa,-gdwarf2 -c $< -o $@
-__MAKE_DEBUG_OBJ =	$(CROSS)$(CC) $(CPU_OPT) $(CFLAGS_DEBUG) -c $< -o $@
-__MAKE_NDEBUG_OBJ =	$(CROSS)$(CC) $(CPU_OPT) $(CFLAGS_RELEASE) -c $< -o $@
+__ASM_NDEBUG_OBJ =	$(CC) $(CPU_OPT) $(AFLAGS) -c $< -o $@
+__ASM_DEBUG_OBJ =	$(CC) $(CPU_OPT) $(AFLAGS) -Wa,-gdwarf2 -c $< -o $@
+ASM_NDEBUG_CORTEX_OBJ =	$(CC) $(CROSS_CPU_OPT) $(AFLAGS) -c $< -o $@
+ASM_DEBUG_CORTEX_OBJ =	$(CC) $(CROSS_CPU_OPT) $(AFLAGS) -Wa,-gdwarf2 -c $< -o $@
+__MAKE_DEBUG_OBJ =	$(CC) $(CPU_OPT) $(CFLAGS_DEBUG) -c $< -o $@
+__MAKE_NDEBUG_OBJ =	$(CC) $(CPU_OPT) $(CFLAGS_RELEASE) -c $< -o $@
 
 ifeq ($(MAKE_VERBOSE),yes)
 ASM_DEBUG_OBJ =		$(__ASM_DEBUG_OBJ)
@@ -118,6 +160,17 @@ endif
 ifeq ($(DRAM_TYPE_DDR3),y)
 DRAM_TYPE = ddr3
 endif
+ifeq ($(DRAM_TYPE_LPDDR4),y)
+DRAM_TYPE = lpddr4
+endif
+
+# choose image
+IMAGE_DIR = image
+ifeq ($(CONFIG_4K_BOOT_IMAGE),y)
+ifeq ($(SV_DIR)/image_4k, $(wildcard $(SV_DIR)/image_4k))
+IMAGE_DIR = image_4k
+endif
+endif
 
 ## Link board lib if have
 ifeq ($(BSP_DIR)/libbst_external.a,$(wildcard $(BSP_DIR)/libbst_external.a))
@@ -163,31 +216,44 @@ else
 BSTCONFIG := $(SV_DIR)/bin/lnx/bstconfig
 endif
 
+ifeq ($(CONFIG_AARCH64_TRUSTZONE), y)
+ATF_BIN := $(SV_DIR)/atf/bl31.bin
+ifneq ($(wildcard $(ATF_BIN)), $(ATF_BIN))
+$(error "No ATF bin for TrustZone")
+endif
+endif
+
 ifeq ($(CONFIG_BOOT_MEDIA_EMMC),y)
-BST_BIN := $(SV_DIR)/image/amboot_emmc_$(DRAM_TYPE).bin
+BST_BIN := $(SV_DIR)/$(IMAGE_DIR)/amboot_emmc_$(DRAM_TYPE).bin
 else
 ifeq ($(CONFIG_BOOT_MEDIA_SPINOR),y)
-BST_BIN := $(SV_DIR)/image/amboot_spinor_$(DRAM_TYPE).bin
+BST_BIN := $(SV_DIR)/$(IMAGE_DIR)/amboot_spinor_$(DRAM_TYPE).bin
+else
+ifeq ($(CONFIG_BOOT_MEDIA_SPINAND),y)
+BST_BIN := $(SV_DIR)/$(IMAGE_DIR)/amboot_spinand_$(DRAM_TYPE).bin
 else
-BST_BIN := $(SV_DIR)/image/amboot_bst_$(DRAM_TYPE).bin
+BST_BIN := $(SV_DIR)/$(IMAGE_DIR)/amboot_bst_$(DRAM_TYPE).bin
+endif
 endif
 endif
 
 ## Enumerate BLD objects
-SRCS +=		$(TOP)/src/bld/trampoline.S \
-		$(TOP)/src/bld/mmu.S \
-		$(TOP)/src/bld/armcache.S \
-		$(TOP)/src/bld/cache.c \
-		$(TOP)/src/bld/jump.S \
+SRCS +=		$(TOP)/src/bld/$(ARCH_CPU)/trampoline.S \
+		$(TOP)/src/bld/$(ARCH_CPU)/mmu.S \
+		$(TOP)/src/bld/$(ARCH_CPU)/armcache.S \
+		$(TOP)/src/bld/$(ARCH_CPU)/cache.c \
+		$(TOP)/src/bld/$(ARCH_CPU)/jump.S \
+		$(TOP)/src/bld/eabi_compat.c \
 		$(TOP)/src/bld/rct.c \
+		$(TOP)/src/bld/irq.c \
 		$(TOP)/src/bld/strutil.c \
-		$(TOP)/src/bld/vic.c \
 		$(TOP)/src/bld/memcpy.c \
 		$(TOP)/src/bld/memmove.c \
 		$(TOP)/src/bld/memzero.c \
 		$(TOP)/src/bld/memset.c \
 		$(TOP)/src/bld/memcmp.c \
 		$(TOP)/src/bld/crc32.c \
+		$(TOP)/src/bld/gpio.c \
 		$(TOP)/src/bld/uart.c \
 		$(TOP)/src/bld/firmfl.c \
 		$(TOP)/src/bld/partition.c \
@@ -200,8 +266,9 @@ AMBOOT_BLD_OBJS = \
 		armcache.o \
 		cache.o \
 		jump.o \
-		vic.o \
+		eabi_compat.o \
 		rct.o \
+		irq.o \
 		strutil.o \
 		memcpy.o \
 		memmove.o \
@@ -209,12 +276,34 @@ AMBOOT_BLD_OBJS = \
 		memset.o \
 		memcmp.o \
 		crc32.o \
+		gpio.o \
 		uart.o \
 		firmfl.o \
 		partition.o \
 		loader.o \
 		main.o
 
+# flattern device tree
+SRCS +=	\
+		$(TOP)/src/bld/fdt_boot.c \
+		$(TOP)/src/bld/libfdt/fdt.c \
+		$(TOP)/src/bld/libfdt/fdt_ro.c \
+		$(TOP)/src/bld/libfdt/fdt_rw.c \
+		$(TOP)/src/bld/libfdt/fdt_strerror.c \
+		$(TOP)/src/bld/libfdt/fdt_sw.c \
+		$(TOP)/src/bld/libfdt/fdt_wip.c \
+		$(TOP)/src/bld/libfdt/fdt_empty_tree.c
+
+AMBOOT_BLD_OBJS	+= \
+		fdt_boot.o \
+		fdt.o \
+		fdt_ro.o \
+		fdt_rw.o \
+		fdt_strerror.o \
+		fdt_sw.o \
+		fdt_wip.o \
+		fdt_empty_tree.o
+
 ifeq ($(CONFIG_AMBOOT_COMMAND_SUPPORT),y)
 SRCS +=	\
 		$(TOP)/src/bld/command.c \
@@ -226,6 +315,8 @@ SRCS +=	\
 		$(TOP)/src/bld/cmd_reboot.c \
 		$(TOP)/src/bld/cmd_setenv.c \
 		$(TOP)/src/bld/cmd_show.c \
+		$(TOP)/src/bld/cmd_hexdump.c \
+		$(TOP)/src/bld/cmd_poweroff.c \
 		$(TOP)/src/bld/cmd_setmem.c
 
 AMBOOT_BLD_OBJS	+= \
@@ -238,6 +329,8 @@ AMBOOT_BLD_OBJS	+= \
 		cmd_reboot.o \
 		cmd_setenv.o \
 		cmd_show.o \
+		cmd_hexdump.o \
+		cmd_poweroff.o \
 		cmd_setmem.o
 
 ifeq ($(CONFIG_AMBOOT_ENABLE_ADC),y)
@@ -254,25 +347,58 @@ AMBOOT_BLD_OBJS	+= \
 endif
 endif
 
+
+ifeq ($(CPU),CORTEXA53)
+SRCS +=	\
+			$(TOP)/src/bld/$(ARCH_CPU)/armv8_helper.S \
+			$(TOP)/src/bld/$(ARCH_CPU)/vector.S
+
+AMBOOT_BLD_OBJS	+= \
+		armv8_helper.o \
+		vector.o
+
+else
+SRCS +=	\
+			$(TOP)/src/bld/$(ARCH_CPU)/div64.S \
+			$(TOP)/src/bld/$(ARCH_CPU)/udivsi3.S
+
+AMBOOT_BLD_OBJS	+= \
+		   div64.o \
+		   udivsi3.o
+endif
+
 # lib support
 SRCS += \
 		$(TOP)/src/bld/lib/vsprintf.c \
+		$(TOP)/src/bld/lib/random.c \
 		$(TOP)/src/bld/lib/memory.c
 
 AMBOOT_BLD_OBJS += \
-				   vsprintf.o \
-				   memory.o
+		   vsprintf.o \
+		   random.o \
+		   memory.o
 
 # thaw hibernation support
 ifeq ($(AMBOOT_THAW_HIBERNATION),y)
-SRCS += \
-		$(TOP)/src/bld/lib/thaw.c \
+SRCS +=	\
+		$(TOP)/src/bld/lib/thaw_lzo.c	\
 		$(TOP)/src/bld/cmd_thaw.c
 
 AMBOOT_BLD_OBJS += \
-				   thaw.o \
-				   cmd_thaw.o
-endif
+		   thaw_lzo.o			\
+		   cmd_thaw.o
+
+
+ifeq ($(ARCH_CPU), arm64)
+ifeq ($(CONFIG_ARMV8_AARCH32),y)
+AMBOOT_BLD_OBJS += \
+		   lzo_lib_aarch32.o
+else
+AMBOOT_BLD_OBJS += \
+		   lzo_lib_aarch64.o
+endif # CONFIG_ARMV8_AARCH32
+endif # ARCH_CPU
+endif # AMBOOT_THAW_HIBERNATION
 
 ifeq ($(SECURE_BOOT),y)
 SRCS +=	\
@@ -280,84 +406,45 @@ SRCS +=	\
 		$(TOP)/src/bld/secure/big_number.c \
 		$(TOP)/src/bld/secure/digest_sha256.c \
 		$(TOP)/src/bld/secure/pk_rsa.c \
-		$(TOP)/src/bld/secure/tiny_asn1.c \
-		$(TOP)/src/bld/secure/tiny_oid.c \
+		$(TOP)/src/bld/secure/aes.c \
+		$(TOP)/src/bld/secure/platform_misc.c \
 		$(TOP)/src/bld/secure/secure_boot.c \
+		$(TOP)/src/bld/secure/secure_boot_main.c
 
 AMBOOT_BLD_OBJS += \
 		crypt_utils.o \
 		big_number.o \
 		digest_sha256.o \
 		pk_rsa.o \
-		tiny_asn1.o \
-		tiny_oid.o \
-		secure_boot.o
-endif
-
-ifeq ($(CONFIG_AMBOOT_ENABLE_ATSHA204), y)
-ifeq ($(CONFIG_AMBOOT_BUILD_ATSHA204_FROM_SOURCE),y)
-SRCS +=	\
-		$(TOP)/src/bld/peripheral/driver_atsha204.c \
-		$(TOP)/src/bld/peripheral/library_atsha204.c
+		aes.o \
+		platform_misc.o \
+		secure_boot.o \
+		secure_boot_main.o
 endif
 
-AMBOOT_BLD_OBJS += \
-		driver_atsha204.o \
-		library_atsha204.o
-
-endif
-
-# flattern device tree
-ifeq ($(CONFIG_AMBOOT_BD_FDT_SUPPORT),y)
-SRCS +=	\
-		$(TOP)/src/bld/fdt_boot.c \
-		$(TOP)/src/bld/libfdt/fdt.c \
-		$(TOP)/src/bld/libfdt/fdt_ro.c \
-		$(TOP)/src/bld/libfdt/fdt_rw.c \
-		$(TOP)/src/bld/libfdt/fdt_strerror.c \
-		$(TOP)/src/bld/libfdt/fdt_sw.c \
-		$(TOP)/src/bld/libfdt/fdt_wip.c \
-		$(TOP)/src/bld/libfdt/fdt_empty_tree.c
-
-AMBOOT_BLD_OBJS	+= \
-		fdt_boot.o \
-		fdt.o \
-		fdt_ro.o \
-		fdt_rw.o \
-		fdt_strerror.o \
-		fdt_sw.o \
-		fdt_wip.o \
-		fdt_empty_tree.o
-
 ifeq ($(CONFIG_AMBOOT_COMMAND_SUPPORT),y)
 SRCS +=	\
 		$(TOP)/src/bld/cmd_fdt.c
 AMBOOT_BLD_OBJS	+= \
 		cmd_fdt.o
 endif
-endif
-
-ifeq ($(CONFIG_AMBOOT_BD_ATAG_SUPPORT),y)
-SRCS +=	\
-		$(TOP)/src/bld/atag.c
-AMBOOT_BLD_OBJS	+= \
-		atag.o
-endif
 
-ifeq ($(CONFIG_AMBOOT_BAPI_SUPPORT),y)
+ifeq ($(CONFIG_AMBOOT_ENABLE_NAND),y)
+ifeq ($(CONFIG_NAND_COMBO_CONTROLLER),y)
 SRCS +=	\
-		$(TOP)/src/bld/bapi.c
-
-AMBOOT_BLD_OBJS	+= \
-		bapi.o
-endif
+		$(TOP)/src/bld/nand_combo.c
 
-ifeq ($(CONFIG_AMBOOT_ENABLE_NAND),y)
+AMBOOT_BLD_OBJS += \
+		nand_combo.o
+else
+ifeq ($(CONFIG_PANDORA_RTOS),)
 SRCS +=	\
-		$(TOP)/src/bld/nand.c
+		$(TOP)/src/bld/nand_legacy.c
 
 AMBOOT_BLD_OBJS += \
-		nand.o
+		nand_legacy.o
+endif
+endif
 
 ifeq ($(CONFIG_NAND_USE_FLASH_BBT),y)
 SRCS +=	\
@@ -367,7 +454,9 @@ AMBOOT_BLD_OBJS += \
 		nand_bbt.o
 endif
 
-include $(TOP)/src/flashdb/slcnand/make.inc
+NANDDB_SRCS = $(wildcard $(TOP)/src/flashdb/slcnand/*.c)
+NANDDB_OBJS = $(patsubst %.c, %.o, $(notdir $(NANDDB_SRCS)))
+
 SRCS +=		$(NANDDB_SRCS)
 AMBOOT_BLD_OBJS += \
 		$(NANDDB_OBJS)
@@ -381,12 +470,10 @@ endif
 endif
 
 ifeq ($(CONFIG_AMBOOT_ENABLE_USB),y)
+
 SRCS += \
-		$(TOP)/src/bld/usb_irq.S \
 		$(TOP)/src/bld/usb_drv.c
-
 AMBOOT_BLD_OBJS += \
-		usb_irq.o \
 		usb_drv.o
 
 ifeq ($(CONFIG_AMBOOT_COMMAND_SUPPORT),y)
@@ -398,25 +485,12 @@ endif
 endif
 
 ifeq ($(CONFIG_AMBOOT_ENABLE_GPIO),y)
-SRCS += \
-		$(TOP)/src/bld/gpio.S
-
-AMBOOT_BLD_OBJS += \
-		gpio.o
-
 ifeq ($(CONFIG_AMBOOT_COMMAND_SUPPORT),y)
 SRCS +=	\
 		$(TOP)/src/bld/cmd_gpio.c
 AMBOOT_BLD_OBJS += \
 		cmd_gpio.o
 endif
-
-else
-SRCS += \
-		$(TOP)/src/bld/minipin.S
-
-AMBOOT_BLD_OBJS += \
-		minipin.o
 endif
 
 ifeq ($(CONFIG_AMBOOT_ENABLE_SPINOR),y)
@@ -424,11 +498,6 @@ SRCS += $(TOP)/src/bld/spinor.c
 AMBOOT_BLD_OBJS += \
 		spinor.o
 
-include $(TOP)/src/flashdb/spinor/make.inc
-SRCS +=		$(SPINORDB_SRCS)
-AMBOOT_BLD_OBJS += \
-		$(SPINORDB_OBJS)
-
 ifeq ($(CONFIG_AMBOOT_COMMAND_SUPPORT),y)
 SRCS +=	\
 		$(TOP)/src/bld/cmd_spinor.c
@@ -437,14 +506,29 @@ AMBOOT_BLD_OBJS += \
 endif
 endif
 
+ifeq ($(CONFIG_AMBOOT_ENABLE_SPINAND),y)
+SRCS += $(TOP)/src/bld/spinand.c
+AMBOOT_BLD_OBJS += \
+		spinand.o
+
+include $(TOP)/src/flashdb/spinand/make.inc
+SRCS +=		$(SPINANDDB_SRCS)
+AMBOOT_BLD_OBJS += \
+		$(SPINANDDB_OBJS)
+
+ifeq ($(CONFIG_AMBOOT_COMMAND_SUPPORT),y)
+SRCS +=	\
+		$(TOP)/src/bld/cmd_spinand.c
+AMBOOT_BLD_OBJS += \
+		cmd_spinand.o
+endif
+endif
+
 ifeq ($(CONFIG_AMBOOT_ENABLE_ETH),y)
 SRCS += \
-		$(TOP)/src/bld/eth_irq.S \
 		$(TOP)/src/bld/eth_drv.c \
 		$(TOP)/src/bld/eth_bld.c
-
 AMBOOT_BLD_OBJS += \
-		eth_irq.o \
 		eth_drv.o \
 		eth_bld.o
 
@@ -496,14 +580,42 @@ AMBOOT_BLD_OBJS += \
 		idc_bld.o
 endif
 
-SRCS +=		$(TOP)/src/bld/cortex_bld.c
-AMBOOT_BLD_OBJS += cortex_bld.o
+ifeq ($(CONFIG_AMBOOT_ENABLE_SPI),y)
+SRCS +=	\
+		$(TOP)/src/bld/spi_bld.c
+AMBOOT_BLD_OBJS += \
+		spi_bld.o
+endif
 
-ifeq ($(AMBOOT_DEV_BOOT_CORTEX),y)
-SRCS +=		$(TOP)/src/bld/cortex_bst.S
-AMBOOT_BLD_OBJS += cortex_bst.o
+# For peripheral devices
+ifeq ($(CONFIG_AMBOOT_ENABLE_ATSHA204), y)
+AMBOOT_BLD_OBJS += \
+		driver_atsha204.o \
+		library_atsha204.o
 endif
 
+ifeq ($(CONFIG_AMBOOT_ENABLE_PCA953X), y)
+SRCS +=		$(TOP)/src/bld/peripheral/pca953x.c
+AMBOOT_BLD_OBJS += \
+		pca953x.o
+endif
+
+ifeq ($(CONFIG_AMBOOT_ENABLE_MICREL), y)
+SRCS +=		$(TOP)/src/bld/peripheral/micrel.c
+AMBOOT_BLD_OBJS += \
+		micrel.o
+endif
+
+ifeq ($(CONFIG_AMBOOT_ENABLE_ISL12022M), y)
+SRCS +=		$(TOP)/src/bld/peripheral/isl12022m.c
+AMBOOT_BLD_OBJS += \
+		isl12022m.o
+endif
+
+# For secondary cortex boot
+SRCS +=		$(TOP)/src/bld/cortex_bld.c
+AMBOOT_BLD_OBJS += cortex_bld.o
+
 ifeq ($(AMBOOT_BOOT_DSP),y)
 SRCS +=	\
 		$(TOP)/src/bld/dsp/dsp.c \
@@ -512,11 +624,39 @@ AMBOOT_BLD_OBJS += \
 		dsp.o \
 		audio.o
 
+endif
+
 ifneq ($(wildcard $(TOP)/src/bld/dsp/$(ARCH_LO)/dsp_bo.o_shipped),)
 AMBOOT_BLD_OBJS += \
 		dsp_bo.o
 endif
 
+#SRCS +=		$(AMB_TOPDIR)/packages/img_algo_pandora/arch_$(ARCH_LO)/fb_aaa_algo.c
+#AMBOOT_BLD_OBJS += fb_aaa_algo.o
+ifneq ($(wildcard $(TOP)/src/bld/dsp/$(ARCH_LO)/fb_aaa_algo.o_shipped),)
+AMBOOT_BLD_OBJS += \
+		fb_aaa_algo.o
+endif
+
+ifeq ($(CONFIG_PANDORA_RTOS), y)
+SRCS +=	\
+		$(PANDORA_DIR)/schedule.c	\
+		$(PANDORA_DIR)/init.c		\
+		$(PANDORA_DIR)/nand_pandora.c
+
+AMBOOT_BLD_OBJS += \
+		schedule.o	\
+		init.o		\
+		nand_pandora.o
+
+
+SRCS +=	\
+		$(PANDORA_ARCH_DIR)/processor.c	\
+		$(PANDORA_ARCH_DIR)/pandora.S
+
+AMBOOT_BLD_OBJS += \
+		processor.o \
+		pandora.o
 endif
 
 ifeq ($(wildcard $(BSP_DIR)/make.amboot),$(BSP_DIR)/make.amboot)
@@ -580,8 +720,8 @@ bst_debug.bin: bst_release.bin
 bst_release.bin: $(BST_PAR) $(BST_BIN)
 	$(BSTCONFIG) -batch -parameters $(BST_PAR) -input $(BST_BIN) -output $@
 
-$(BST_PAR): $(BSP_DIR)/$(BST_PAR) bld_release.bin host_fixbstini
-	./host_fixbstini $< bld_release.bin > $@
+$(BST_PAR): $(BSP_DIR)/$(BST_PAR) bld_release.bin $(ATF_BIN) host_fixbstini
+	./host_fixbstini $< bld_release.bin $(ATF_BIN) > $@
 endif
 
 # Avoid to delete $(BST_PAR) $(MUL_BST_PAR) automatically by MAKE.
@@ -589,29 +729,29 @@ endif
 
 # BLD targets
 bld_debug.bin: bld_debug.elf
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -j .data -S -O binary $< $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -j .data -S -O binary $< $@
 
 bld_debug.elf: .temp/bld.lds $(AMBOOT_BLD_DEBUG_OBJS)
-	$(ECHO_LD) $(CROSS)$(CC) -Wl,-T,.temp/bld.lds -nostartfiles \
-		$(AMBOOT_BLD_DEBUG_OBJS) $(LD_BST_EXTERNAL) -o $@
-	$(ECHO_NM) $(CROSS)$(NM) -n $@ | grep -v '\( [aUw] \)\|\(__crc__\)' > \
+	$(ECHO_LD) $(CC) -Wl,-T,.temp/bld.lds -nostartfiles \
+		$(AMBOOT_BLD_DEBUG_OBJS) $(LD_BST_EXTERNAL) $(LDFLAGS) -o $@
+	$(ECHO_NM) $(NM) -n $@ | grep -v '\( [aUw] \)\|\(__crc__\)' > \
 		bld_debug.map
 
 bld_release.bin: bld_release.elf
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -j .data -S -O binary $< $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -j .data -S -O binary $< $@
 
 bld_release.elf: .temp/bld.lds $(AMBOOT_BLD_RELEASE_OBJS)
-	$(ECHO_LD) $(CROSS)$(CC) -Wl,-T,.temp/bld.lds -nostartfiles \
-		$(AMBOOT_BLD_RELEASE_OBJS) $(LD_BST_EXTERNAL) -o $@
-	$(ECHO_NM) $(CROSS)$(NM) -n $@ | grep -v '\( [aUw] \)\|\(__crc__\)' > \
+	$(ECHO_LD) $(CC) -Wl,-T,.temp/bld.lds -nostartfiles \
+		$(AMBOOT_BLD_RELEASE_OBJS) $(LD_BST_EXTERNAL) $(LDFLAGS) -o $@
+	$(ECHO_NM) $(NM) -n $@ | grep -v '\( [aUw] \)\|\(__crc__\)' > \
 		bld_release.map
-	$(ECHO_STRIP) $(CROSS)$(STRIP) --remove-section=.trash \
+	$(ECHO_STRIP) $(STRIP) --remove-section=.trash \
 		 --remove-section=.hugebuf --remove-section=.bldbuf \
 		 --remove-section=.splashbuf $@ 2> /dev/null
 
-.temp/bld.lds: $(TOP)/src/bld/bld.lds.cpp
+.temp/bld.lds: $(TOP)/src/bld/$(ARCH_CPU)/bld.lds.cpp
 	@mkdir -p .temp
-	$(ECHO_LDS) $(CROSS)$(CPP) -D__ASM__ $(DEFINES) $(INCLUDES) $< \
+	$(ECHO_LDS) $(CPP) -D__ASM__ $(DEFINES) $(INCLUDES) $< \
 		| sed /^#/d > $@
 
 # DSP targets
@@ -631,6 +771,10 @@ endif
 
 cortex_bst_debug.o: $(TOP)/src/bld/cortex_bst.S
 	$(ASM_DEBUG_CORTEX_OBJ)
+#fb_aaa_algo_debug.o: $(AMB_TOPDIR)/packages/img_algo_pandora/arch_$(ARCH_LO)/fb_aaa_algo.c
+#	$(MAKE_DEBUG_OBJ)
+#fb_aaa_algo_release.o: $(AMB_TOPDIR)/packages/img_algo_pandora/arch_$(ARCH_LO)/fb_aaa_algo.c
+#	$(MAKE_NDEBUG_OBJ)
 
 %_debug.o: $(TOP)/src/bld/%.c
 	$(MAKE_DEBUG_OBJ)
@@ -638,7 +782,7 @@ cortex_bst_debug.o: $(TOP)/src/bld/cortex_bst.S
 %_debug.o: $(TOP)/src/flashdb/slcnand/%.c
 	$(MAKE_DEBUG_OBJ)
 
-%_debug.o: $(TOP)/src/flashdb/spinor/%.c
+%_debug.o: $(TOP)/src/flashdb/spinand/%.c
 	$(MAKE_DEBUG_OBJ)
 
 %_debug.o: $(TOP)/src/bld/libfdt/%.c
@@ -662,16 +806,35 @@ cortex_bst_debug.o: $(TOP)/src/bld/cortex_bst.S
 %_debug.o: $(TOP)/src/bld/lib/%.c
 	$(MAKE_DEBUG_OBJ)
 
+%_debug.o: $(TOP)/src/bld/lib/%.o_shipped
+	cp $< $@
+
 %_debug.o: $(TOP)/src/bld/secure/%.c
 	$(MAKE_DEBUG_OBJ)
 
-ifeq ($(CONFIG_AMBOOT_BUILD_ATSHA204_FROM_SOURCE),y)
 %_debug.o: $(TOP)/src/bld/peripheral/%.c
 	$(MAKE_DEBUG_OBJ)
-else
+
 %_debug.o: $(TOP)/src/bld/peripheral/%.o_shipped
 	cp $< $@
-endif
+
+%_debug.o: $(TOP)/src/bld/$(ARCH_CPU)/%.S
+	$(ASM_DEBUG_OBJ)
+
+%_debug.o: $(TOP)/src/bld/$(ARCH_CPU)/%.c
+	$(MAKE_DEBUG_OBJ)
+
+%_debug.o: $(PANDORA_DIR)/%.S
+	$(ASM_DEBUG_OBJ)
+
+%_debug.o: $(PANDORA_DIR)/%.c
+	$(MAKE_DEBUG_OBJ)
+
+%_debug.o: $(PANDORA_ARCH_DIR)/%.S
+	$(ASM_DEBUG_OBJ)
+
+%_debug.o: $(PANDORA_ARCH_DIR)/%.c
+	$(MAKE_DEBUG_OBJ)
 
 %_release.o: $(TOP)/src/bld/%.S
 	$(ASM_NDEBUG_OBJ)
@@ -685,7 +848,7 @@ cortex_bst_release.o: $(TOP)/src/bld/cortex_bst.S
 %_release.o: $(TOP)/src/flashdb/slcnand/%.c
 	$(MAKE_NDEBUG_OBJ)
 
-%_release.o: $(TOP)/src/flashdb/spinor/%.c
+%_release.o: $(TOP)/src/flashdb/spinand/%.c
 	$(MAKE_NDEBUG_OBJ)
 
 %_release.o: $(TOP)/src/bld/libfdt/%.c
@@ -700,6 +863,8 @@ cortex_bst_release.o: $(TOP)/src/bld/cortex_bst.S
 %_release.o: $(TOP)/src/bld/dsp/%.c
 	$(MAKE_NDEBUG_OBJ)
 
+%_release.o: $(TOP)/src/bld/dsp/%.o_shipped
+	cp $< $@
 %_release.o: $(TOP)/src/bld/dsp/$(ARCH_LO)/%.o_shipped
 	cp $< $@
 
@@ -709,19 +874,39 @@ cortex_bst_release.o: $(TOP)/src/bld/cortex_bst.S
 %_release.o: $(TOP)/src/bld/lib/%.c
 	$(MAKE_NDEBUG_OBJ)
 
+%_release.o: $(TOP)/src/bld/lib/%.o_shipped
+	cp $< $@
+
 %_release.o: $(TOP)/src/bld/secure/%.c
 	$(MAKE_NDEBUG_OBJ)
 
-ifeq ($(CONFIG_AMBOOT_BUILD_ATSHA204_FROM_SOURCE),y)
 %_release.o: $(TOP)/src/bld/peripheral/%.c
 	$(MAKE_DEBUG_OBJ)
-else
+
 %_release.o: $(TOP)/src/bld/peripheral/%.o_shipped
 	cp $< $@
-endif
+
+%_release.o: $(TOP)/src/bld/$(ARCH_CPU)/%.c
+	$(MAKE_NDEBUG_OBJ)
+
+%_release.o: $(TOP)/src/bld/$(ARCH_CPU)/%.S
+	$(ASM_NDEBUG_OBJ)
+
+
+%_release.o: $(PANDORA_DIR)/%.c
+	$(MAKE_NDEBUG_OBJ)
+
+%_release.o: $(PANDORA_DIR)/%.S
+	$(ASM_NDEBUG_OBJ)
+
+%_release.o: $(PANDORA_ARCH_DIR)/%.c
+	$(MAKE_NDEBUG_OBJ)
+
+%_release.o: $(PANDORA_ARCH_DIR)/%.S
+	$(ASM_NDEBUG_OBJ)
 
 __MAKEDEP = \
-	$(CROSS)$(GCCDEP) $(DEFINES) $(INCLUDES) $(SRCS) > .deppre ; \
+	$(GCCDEP) $(DEFINES) $(INCLUDES) $(SRCS) > .deppre ; \
 	cat .deppre | sed -e s/.o:/_debug.o:/ > .dep ; \
 	cat .deppre | sed -e s/.o:/_release.o:/ >> .dep ; \
 	$(RM) .deppre
@@ -740,7 +925,12 @@ fwlist .fwlist:: $(HOST_UTILS)
 ifneq ($(MINIMAL_FIRMWARE_COMBO),y)
 	@./host_permutate $(HOST_PERMUTATE_ARG) >> .fwlist
 else
-	@./host_permutate -m $(HOST_PERMUTATE_ARG) | sed -e s/bld/bld\ bst_bld/g >> .fwlist
+	@./host_permutate -m $(HOST_PERMUTATE_ARG) >> .fwlist
+endif
+ifeq ($(CONFIG_AARCH64_TRUSTZONE), y)
+	@/bin/echo -n bst_bld_atf >> .fwlist
+else
+	@/bin/echo -n bst_bld >> .fwlist
 endif
 	@rm -rf memfwprog devfw
 
diff --git a/config/Makefile.archbsp b/config/Makefile.archbsp
index 12558c8..cc07c9d 100644
--- a/config/Makefile.archbsp
+++ b/config/Makefile.archbsp
@@ -6,13 +6,31 @@
 ##    2007/06/13 - [Charles Chiou] converted to automatic ARCH/BSP extraction
 ##		instead of hard-coding each one in this file
 ##    2008/02/19 - [Anthony Ginger] imported to AMBuild
+##    2015/11/10 - [Cao Rongrong] Support CortexA53
 ##
-## Copyright (C) 2004-2007, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 #
@@ -26,17 +44,17 @@ ARCH := $(shell grep CONFIG_ARCH $(DOT_CONFIG) | \
 
 # CPU
 
-ARM1136JS = A5S I1 A7L S2
-CORTEXA9 = S2E S2L S3 S3L
+CORTEXA9 = S2L S3 S3L
+CORTEXA53 = S5 H2 S5L CV1
 
-ifneq ($(filter $(ARCH),$(ARM1136JS)),)
-CPU = ARM1136JS
-EXTRA_DEFINES := -D__ARM1136JS__
-endif
 ifneq ($(filter $(ARCH),$(CORTEXA9)),)
 CPU = CORTEXA9
 EXTRA_DEFINES := -D__CORTEXA9__
 endif
+ifneq ($(filter $(ARCH),$(CORTEXA53)),)
+CPU = CORTEXA53
+EXTRA_DEFINES := -D__CORTEXA53__
+endif
 
 #
 # BSP
diff --git a/config/Makefile.devfw b/config/Makefile.devfw
index ab7a039..f9d6217 100644
--- a/config/Makefile.devfw
+++ b/config/Makefile.devfw
@@ -4,13 +4,31 @@
 ## History:
 ##    2005/02/27 - [Charles Chiou] created file
 ##
-## Copyright (C) 2004-2014, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
 ##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
 
 # Requirements:
 #	(1) Please define the following before including this Makefile,
@@ -35,6 +53,8 @@ YEAR :=			$(shell date +%Y | sed s/^0//)
 MONTH :=		$(shell date +%m | sed s/^0//)
 DAY :=			$(shell date +%d | sed s/^0//)
 
+MEMFWPROG_OPT :=
+
 # Because of the quoted string format that Kconfig uses, we need to
 # destringify the following variables before processing them:
 PBA :=			$(shell echo $(PBA))
@@ -67,6 +87,13 @@ __HAS_DSP__ = 1
 HOST_PERMUTATE_ARG +=   dsp
 endif
 
+ifneq ($(ATF_BIN),)
+ifeq ($(wildcard $(ATF_BIN)),$(ATF_BIN))
+__HAS_ATF__ = 1
+HOST_PERMUTATE_ARG +=	atf
+endif
+endif
+
 ifneq ($(PBA),)
 ifeq ($(wildcard $(PBA)),$(PBA))
 __HAS_PBA__ = 1
@@ -145,7 +172,7 @@ endif
 PAYLOAD_DEBUG =	\
 		.temp/bst_debug.fw \
 		.temp/bld_debug.fw \
-		.temp/splash.fw \
+		.temp/atf.fw \
 		.temp/pba.fw \
 		.temp/kernel.fw \
 		.temp/secondary.fw \
@@ -161,7 +188,7 @@ PAYLOAD_DEBUG =	\
 PAYLOAD_RELEASE = \
 		.temp/bst_release.fw \
 		.temp/bld_release.fw \
-		.temp/splash.fw \
+		.temp/atf.fw \
 		.temp/pba.fw \
 		.temp/kernel.fw \
 		.temp/secondary.fw \
@@ -188,22 +215,26 @@ MEMFWPROG_OBJS = \
 		mmu.o \
 		armcache.o \
 		cache.o \
-		gpio.o \
-		vic.o \
+		eabi_compat.o \
 		rct.o \
 		memcpy.o \
+		vsprintf.o \
+		memory.o \
 		memmove.o \
 		memzero.o \
 		memcmp.o \
+		memset.o \
+		random.o \
+		strutil.o \
 		crc32.o \
 		uart.o \
 		firmfl.o \
 		partition.o \
 		memfwprog.o \
-		$(NANDDB_OBJS) \
-		$(SPINORDB_OBJS)
+		$(SPINORDB_OBJS) \
+		$(SPINANDDB_OBJS)
 
-ifeq ($(CONFIG_AMBOOT_BD_FDT_SUPPORT),y)
+# flattern device tree
 MEMFWPROG_OBJS += \
 		dtb.o \
 		fdt_boot.o \
@@ -214,8 +245,17 @@ MEMFWPROG_OBJS += \
 		fdt_sw.o \
 		fdt_wip.o \
 		fdt_empty_tree.o
+
+ifeq ($(CPU), CORTEXA53)
+MEMFWPROG_OBJS += \
+		armv8_helper.o
+else
+MEMFWPROG_OBJS += \
+		div64.o \
+		udivsi3.o
 endif
 
+
 ifeq ($(wildcard $(BSP_DIR)/bsp_fw.c),$(BSP_DIR)/bsp_fw.c)
 MEMFWPROG_OBJS += bsp_fw.o
 endif
@@ -224,8 +264,17 @@ ifeq ($(wildcard $(BSP_DIR)/make.devfw),$(BSP_DIR)/make.devfw)
 include $(BSP_DIR)/make.devfw
 endif
 
+ifeq ($(CONFIG_AMBOOT_ENABLE_GPIO),y)
+MEMFWPROG_OBJS += gpio.o
+endif
+
 ifeq ($(CONFIG_AMBOOT_ENABLE_NAND),y)
-MEMFWPROG_OBJS += nand.o
+MEMFWPROG_OBJS += $(NANDDB_OBJS)
+ifeq ($(CONFIG_NAND_COMBO_CONTROLLER),y)
+MEMFWPROG_OBJS += nand_combo.o
+else
+MEMFWPROG_OBJS += nand_legacy.o
+endif
 ifeq ($(CONFIG_NAND_USE_FLASH_BBT),y)
 MEMFWPROG_OBJS += nand_bbt.o
 endif
@@ -239,8 +288,15 @@ ifeq ($(CONFIG_AMBOOT_ENABLE_SPINOR),y)
 MEMFWPROG_OBJS += spinor.o
 endif
 
-MEMFWPROG_DEBUG_OBJS = $(patsubst %.o,%_debug.o,$(MEMFWPROG_OBJS))
-MEMFWPROG_RELEASE_OBJS = $(patsubst %.o,%_release.o,$(MEMFWPROG_OBJS))
+ifeq ($(CONFIG_AMBOOT_ENABLE_SPINAND),y)
+MEMFWPROG_OBJS += spinand.o
+endif
+
+MEMFWPROG_DEBUG_OBJS = $(patsubst %.o,memfwprog/%_debug.o,$(MEMFWPROG_OBJS))
+MEMFWPROG_RELEASE_OBJS = $(patsubst %.o,memfwprog/%_release.o,$(MEMFWPROG_OBJS))
+
+# Avoid to delete $(MEMFWPROG_DEBUG_OBJS) $(MEMFWPROG_RELEASE_OBJS) automatically by MAKE.
+.PRECIOUS: $(MEMFWPROG_DEBUG_OBJS) $(MEMFWPROG_RELEASE_OBJS)
 
 MEMFWPROG_DEBUG = $(addsuffix _debug.elf,$(subst devfw,memfwprog,$(FIRMWARES)))
 MEMFWPROG_RELEASE = $(addsuffix _release.elf,$(subst devfw,memfwprog,$(FIRMWARES)))
@@ -251,44 +307,45 @@ ifeq ($(BUILD_DEBUG_MEMFWPROG),y)
 MEMFWPROG += $(MEMFWPROG_DEBUG)
 endif
 
+
 # MEMFWPROG targets
 
 memfwprog/%_debug.elf: .temp/header_%.fw $(PAYLOAD_DEBUG) \
 		$(MEMFWPROG_DEBUG_OBJS) .temp/memfwprog/%.lds
 	@mkdir -p memfwprog
-	$(ECHO_LD) $(CROSS)$(CC) -Wl,-T,.temp/$(subst _debug.elf,.lds,$@) \
-		-nostartfiles -o $@ $(MEMFWPROG_DEBUG_OBJS) $< \
+	$(ECHO_LD) $(CC) -Wl,-T,.temp/$(subst _debug.elf,.lds,$@) \
+		-nostartfiles $(CFLAGS_RELEASE) $(LDFLAGS) -o $@ $(MEMFWPROG_DEBUG_OBJS) $< \
 		$(PAYLOAD_DEBUG)
 
 memfwprog/%_release.elf: .temp/header_%.fw $(PAYLOAD_RELEASE) \
 		$(MEMFWPROG_RELEASE_OBJS) .temp/memfwprog/%.lds
 	@mkdir -p memfwprog
-	$(ECHO_LD) $(CROSS)$(CC) -Wl,-T,.temp/$(subst _release.elf,.lds,$@) \
-		-nostartfiles -o $@ $(MEMFWPROG_RELEASE_OBJS) $< \
+	$(ECHO_LD) $(CC) -Wl,-T,.temp/$(subst _release.elf,.lds,$@) \
+		-nostartfiles $(CFLAGS_RELEASE) $(LDFLAGS) -o $@ $(MEMFWPROG_RELEASE_OBJS) $< \
 		$(PAYLOAD_RELEASE)
-	@$(CROSS)$(STRIP) --remove-section=.trash $@ 2> /dev/null
+	@$(STRIP) --remove-section=.trash $@ 2> /dev/null
 
 memfwprog/%.bin: memfwprog/%.elf
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -O binary $< $@
+	$(ECHO_OCP) $(OBJCOPY) -O binary $< $@
 
 # DEVFW targets
 
 devfw/%_debug.bin: .temp/devfw/%_debug.efw
 	@mkdir -p devfw
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O binary $< $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O binary $< $@
 
 .temp/devfw/%_debug.efw: .temp/header_%.fw $(PAYLOAD_DEBUG) .temp/devfw/%.lds
 	@mkdir -p .temp/devfw
-	$(ECHO_LD) $(CROSS)$(LD) -T$(subst _debug.efw,.lds,$@) -o $@ \
+	$(ECHO_LD) $(LD) -T$(subst _debug.efw,.lds,$@) -o $@ \
 		$< $(PAYLOAD_DEBUG)
 
 devfw/%_release.bin: .temp/devfw/%_release.efw
 	@mkdir -p devfw
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O binary $< $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O binary $< $@
 
 .temp/devfw/%_release.efw: .temp/header_%.fw $(PAYLOAD_RELEASE) .temp/devfw/%.lds
 	@mkdir -p .temp
-	$(ECHO_LD) $(CROSS)$(LD) -T$(subst _release.efw,.lds,$@) -o $@ \
+	$(ECHO_LD) $(LD) -T$(subst _release.efw,.lds,$@) -o $@ \
 		$< $(PAYLOAD_RELEASE)
 
 # Object targets
@@ -297,17 +354,98 @@ devfw/%_release.bin: .temp/devfw/%_release.efw
 	@mkdir -p .temp
 	$(ASM_NDEBUG_OBJ)
 
-%_debug.o: $(TOP)/src/bld/%.S
-	$(ASM_DEBUG_OBJ)
+memfwprog/%_debug.o: $(TOP)/src/bld/%.c
+	@mkdir -p memfwprog
+	$(MAKE_DEBUG_OBJ) $(MEMFWPROG_OPT)
 
-%_debug.o: $(TOP)/src/bld/%.c
-	$(MAKE_DEBUG_OBJ)
+memfwprog/%_debug.o: $(TOP)/src/flashdb/slcnand/%.c
+	@mkdir -p memfwprog
+	$(MAKE_DEBUG_OBJ) $(MEMFWPROG_OPT)
 
-%_release.o: $(TOP)/src/bld/%.S
-	$(ASM_NDEBUG_OBJ)
+memfwprog/%_debug.o: $(TOP)/src/flashdb/spinand/%.c
+	@mkdir -p memfwprog
+	$(MAKE_DEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_debug.o: $(TOP)/src/bld/libfdt/%.c
+	@mkdir -p memfwprog
+	$(MAKE_DEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_debug.o: $(BSP_DIR)/%.S
+	@mkdir -p memfwprog
+	$(ASM_DEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_debug.o: $(BSP_DIR)/%.c
+	@mkdir -p memfwprog
+	$(MAKE_DEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_debug.o: $(TOP)/src/bld/dsp/%.c
+	@mkdir -p memfwprog
+	$(MAKE_DEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_debug.o: $(TOP)/src/bld/lib/%.c
+	@mkdir -p memfwprog
+	$(MAKE_DEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_debug.o: $(TOP)/src/bld/peripheral/%.c
+	@mkdir -p memfwprog
+	$(MAKE_DEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_debug.o: $(TOP)/src/bld/$(ARCH_CPU)/%.S
+	@mkdir -p memfwprog
+	$(ASM_DEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_debug.o: $(TOP)/src/bld/$(ARCH_CPU)/%.c
+	@mkdir -p memfwprog
+	$(MAKE_DEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(TOP)/src/bld/%.S
+	@mkdir -p memfwprog
+	$(ASM_NDEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(TOP)/src/bld/%.c
+	@mkdir -p memfwprog
+	$(MAKE_NDEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(TOP)/src/flashdb/slcnand/%.c
+	@mkdir -p memfwprog
+	$(MAKE_NDEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(TOP)/src/flashdb/spinand/%.c
+	@mkdir -p memfwprog
+	$(MAKE_NDEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(TOP)/src/bld/libfdt/%.c
+	@mkdir -p memfwprog
+	$(MAKE_NDEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(BSP_DIR)/%.S
+	@mkdir -p memfwprog
+	$(ASM_NDEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(BSP_DIR)/%.c
+	@mkdir -p memfwprog
+	$(MAKE_NDEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(TOP)/src/bld/fs/%.c
+	@mkdir -p memfwprog
+	$(MAKE_NDEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(TOP)/src/bld/lib/%.c
+	@mkdir -p memfwprog
+	$(MAKE_NDEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(TOP)/src/bld/peripheral/%.c
+	@mkdir -p memfwprog
+	$(MAKE_DEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(TOP)/src/bld/$(ARCH_CPU)/%.c
+	@mkdir -p memfwprog
+	$(MAKE_NDEBUG_OBJ) $(MEMFWPROG_OPT)
+
+memfwprog/%_release.o: $(TOP)/src/bld/$(ARCH_CPU)/%.S
+	@mkdir -p memfwprog
+	$(ASM_NDEBUG_OBJ) $(MEMFWPROG_OPT)
 
-%_release.o: $(TOP)/src/bld/%.c
-	$(MAKE_NDEBUG_OBJ)
 
 
 # DTB targets
@@ -315,22 +453,27 @@ ifeq ($(DTC),)
 $(error DTC is not specified)
 endif
 
+# BOARD_DTS maybe defined in $(BSP_DIR)/make.devfw
 ifeq ($(BSP_DIR)/$(BSP_BOARD_VER).dts,$(wildcard $(BSP_DIR)/$(BSP_BOARD_VER).dts))
-BOARD_DTS := $(BSP_BOARD_VER).dts
+BOARD_DTS ?= $(BSP_BOARD_VER).dts
 else
-BOARD_DTS := $(BSP_LO).dts
+BOARD_DTS ?= $(BSP_LO).dts
 endif
 
 BOARD_DTS_ASM := $(addsuffix .S,$(BOARD_DTS))
 
 $(BOARD_DTS_ASM): $(BSP_DIR)/$(BOARD_DTS)
-	@$(DTC) -I dts -O asm $(DTC_INCLUDES) -p 1024 -o $@ $<
-	@$(DTC) -I dts -O dtb $(DTC_INCLUDES) -p 1024 -o $(patsubst %.S,%.dtb,$@) $<
+	@$(ECHO_GCC) $(CC) -E -nostdinc -D__DTS__ $(DTC_CFLAG_INCLUDES) -U linux -x assembler-with-cpp $< | \
+		$(DTC) -I dts -O asm $(DTC_INCLUDES) -p 1024 -o $@
+	@$(ECHO_GCC) $(CC) -E -nostdinc -D__DTS__ $(DTC_CFLAG_INCLUDES) -U linux -x assembler-with-cpp $< | \
+		$(DTC) -I dts -O dtb $(DTC_INCLUDES) -p 1024 -o $(patsubst %.S,%.dtb,$@)
 
-dtb_debug.o: $(BOARD_DTS_ASM)
+memfwprog/dtb_debug.o: $(BOARD_DTS_ASM)
+	@mkdir -p memfwprog
 	$(ASM_DEBUG_OBJ)
 
-dtb_release.o: $(BOARD_DTS_ASM)
+memfwprog/dtb_release.o: $(BOARD_DTS_ASM)
+	@mkdir -p memfwprog
 	$(ASM_NDEBUG_OBJ)
 
 # Linker script targets
@@ -344,8 +487,8 @@ dtb_release.o: $(BOARD_DTS_ASM)
 	if [ "$(findstring bld,$@)" != "" ]; then \
 		mydefs="$$mydefs -D__LINK_BLD__"; \
 	fi; \
-	if [ "$(findstring splash,$@)" != "" ]; then \
-		mydefs="$$mydefs -D__LINK_SPL__"; \
+	if [ "$(findstring atf,$@)" != "" ]; then \
+		mydefs="$$mydefs -D__LINK_ATF__"; \
 	fi; \
 	if [ "$(findstring pba,$@)" != "" ]; then \
 		mydefs="$$mydefs -D__LINK_PBA__"; \
@@ -380,10 +523,10 @@ dtb_release.o: $(BOARD_DTS_ASM)
 	if [ "$(findstring adc,$@)" != "" ]; then \
 		mydefs="$$mydefs -D__LINK_ADC__"; \
 	fi; \
-	echo $(CROSS)$(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@; \
-	$(CROSS)$(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@
+	echo $(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@; \
+	$(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@
 
-.temp/memfwprog/%.lds: $(TOP)/src/bld/memfwprog.lds.cpp
+.temp/memfwprog/%.lds: $(TOP)/src/bld/$(ARCH_CPU)/memfwprog.lds.cpp
 	@mkdir -p .temp/memfwprog
 	@mydefs=""; \
 	if [ "$(findstring bst,$@)" != "" ]; then \
@@ -392,8 +535,8 @@ dtb_release.o: $(BOARD_DTS_ASM)
 	if [ "$(findstring bld,$@)" != "" ]; then \
 		mydefs="$$mydefs -D__LINK_BLD__"; \
 	fi; \
-	if [ "$(findstring splash,$@)" != "" ]; then \
-		mydefs="$$mydefs -D__LINK_SPL__"; \
+	if [ "$(findstring atf,$@)" != "" ]; then \
+		mydefs="$$mydefs -D__LINK_ATF__"; \
 	fi; \
 	if [ "$(findstring pba,$@)" != "" ]; then \
 		mydefs="$$mydefs -D__LINK_PBA__"; \
@@ -428,8 +571,8 @@ dtb_release.o: $(BOARD_DTS_ASM)
 	if [ "$(findstring adc,$@)" != "" ]; then \
 		mydefs="$$mydefs -D__LINK_ADC__"; \
 	fi; \
-	echo $(CROSS)$(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@; \
-	$(CROSS)$(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@
+	echo $(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@; \
+	$(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@
 
 # Temp. assembler file targets
 
@@ -442,8 +585,8 @@ dtb_release.o: $(BOARD_DTS_ASM)
 	if [ "$(findstring bld,$@)" != "" ]; then \
 		mydefs="$$mydefs -D__LINK_BLD__"; \
 	fi; \
-	if [ "$(findstring splash,$@)" != "" ]; then \
-		mydefs="$$mydefs -D__LINK_SPL__"; \
+	if [ "$(findstring atf,$@)" != "" ]; then \
+		mydefs="$$mydefs -D__LINK_ATF__"; \
 	fi; \
 	if [ "$(findstring pba,$@)" != "" ]; then \
 		mydefs="$$mydefs -D__LINK_PBA__"; \
@@ -478,8 +621,8 @@ dtb_release.o: $(BOARD_DTS_ASM)
 	if [ "$(findstring adc,$@)" != "" ]; then \
 		mydefs="$$mydefs -D__LINK_ADC__"; \
 	fi; \
-	echo $(CROSS)$(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@; \
-	$(CROSS)$(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@
+	echo $(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@; \
+	$(CPP) $(CFLAGS_DEBUG) -D__BSP_$(BSP)__ -D__ASM__ $$mydefs $< | sed /^#/d > $@
 
 #
 # Firmware object files
@@ -488,13 +631,13 @@ dtb_release.o: $(BOARD_DTS_ASM)
 ifeq ($(MUL_BST_ENABLE),yes)
 .temp/bst_debug.fw: $(foreach i,$(BST_DEBUG_BINS),.temp/$(subst .bin,.fw,$(i)))
 	@cat $^ > $@
-	@$(ECHO_OCP) $(CROSS)$(OBJCOPY) -I binary -B arm -O elf32-littlearm \
+	@$(ECHO_OCP) $(OBJCOPY) -I binary -B arm -O $(OUTPUT_FORMAT_FLAG) \
 		--rename-section .data=.text $@ $@
 
 .temp/bst_%_debug.fw: bst_%_debug.bin $(TOP)/src/bld/piggy_bst.S \
 		$(TOP)/src/bst/version.info $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -503,17 +646,17 @@ ifeq ($(MUL_BST_ENABLE),yes)
 		-DVERSION_INFO=$(TOP)/src/bst/version.info \
 		-DINCBIN=$< \
 		-c $(TOP)/src/bld/piggy_bst.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O binary $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O binary $@ $@
 
 .temp/bst_release.fw: $(foreach i,$(BST_RELEASE_BINS),.temp/$(subst .bin,.fw,$(i)))
 	@cat $^ > $@
-	@$(ECHO_OCP) $(CROSS)$(OBJCOPY) -I binary -B arm -O elf32-littlearm \
+	@$(ECHO_OCP) $(OBJCOPY) -I binary -B arm -O $(OUTPUT_FORMAT_FLAG) \
 		--rename-section .data=.text $@ $@
 
 .temp/bst_%_release.fw: bst_%_release.bin $(TOP)/src/bld/piggy_bst.S \
 		$(TOP)/src/bst/version.info $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -522,13 +665,13 @@ ifeq ($(MUL_BST_ENABLE),yes)
 		-DVERSION_INFO=$(TOP)/src/bst/version.info \
 		-DINCBIN=$< \
 		-c $(TOP)/src/bld/piggy_bst.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O binary $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O binary $@ $@
 
 else
 .temp/bst_debug.fw: bst_debug.bin $(TOP)/src/bld/piggy_bst.S \
 		$(TOP)/src/bst/version.info $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -537,12 +680,12 @@ else
 		-DVERSION_INFO=$(TOP)/src/bst/version.info \
 		-DINCBIN=$< \
 		-c $(TOP)/src/bld/piggy_bst.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 .temp/bst_release.fw: bst_release.bin $(TOP)/src/bld/piggy_bst.S \
 		$(TOP)/src/bst/version.info $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -551,13 +694,13 @@ else
 		-DVERSION_INFO=$(TOP)/src/bst/version.info \
 		-DINCBIN=$< \
 		-c $(TOP)/src/bld/piggy_bst.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 endif
 
 .temp/bld_debug.fw: bld_debug.bin $(TOP)/src/bld/piggy_bld.S \
 		$(TOP)/src/bld/version.info $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -566,12 +709,12 @@ endif
 		-DVERSION_INFO=$(TOP)/src/bld/version.info \
 		-DINCBIN=$< \
 		-c $(TOP)/src/bld/piggy_bld.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 .temp/bld_release.fw: bld_release.bin $(TOP)/src/bld/piggy_bld.S \
 		$(TOP)/src/bld/version.info $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -580,36 +723,31 @@ endif
 		-DVERSION_INFO=$(TOP)/src/bld/version.info \
 		-DINCBIN=$< \
 		-c $(TOP)/src/bld/piggy_bld.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
-ifdef __HAS_SPL__
-ifdef SPL_VIF
-SPL_VIF_DEF =		-DVERSION_INFO=$(SPL_VIF)
-else
-SPL_VIF_DEF =
-endif
+ifdef __HAS_ATF__
 
-.temp/splash.fw: $(SPL) $(TOP)/src/bld/piggy_splash.S \
-		 $(SPL_VIF) $(HOST_UTILS)
+.temp/atf.fw: $(ATF_BIN) $(TOP)/src/bld/piggy_atf.S \
+		 $(TOP)/vif/atf.info $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
 		-D__MONTH__=$(MONTH) \
 		-D__DAY__=$(DAY) \
-		$(SPL_VIF_DEF) \
-		-DINCBIN=$(SPL) \
-		-c $(TOP)/src/bld/piggy_splash.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+		-DVERSION_INFO=$(TOP)/vif/atf.info \
+		-DINCBIN=$(ATF_BIN) \
+		-c $(TOP)/src/bld/piggy_atf.S -o $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
-.temp/splash.fw:
+.temp/atf.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
-		-c $(TOP)/src/bld/piggy_splash.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
+		-c $(TOP)/src/bld/piggy_atf.S -o $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -623,7 +761,7 @@ endif
 .temp/pba.fw: $(PBA) $(TOP)/src/bld/piggy_pba.S \
 		 $(PBA_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -632,15 +770,15 @@ endif
 		$(PBA_VIF_DEF) \
 		-DINCBIN=$(PBA) \
 		-c $(TOP)/src/bld/piggy_pba.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/pba.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_pba.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -654,7 +792,7 @@ endif
 .temp/kernel.fw: $(KERNEL) $(TOP)/src/bld/piggy_kernel.S \
 		 $(KERNEL_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -663,15 +801,15 @@ endif
 		$(KERNEL_VIF_DEF) \
 		-DINCBIN=$(KERNEL) \
 		-c $(TOP)/src/bld/piggy_kernel.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/kernel.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_kernel.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -685,7 +823,7 @@ endif
 .temp/secondary.fw: $(SECONDARY) $(TOP)/src/bld/piggy_secondary.S \
 		 $(SECONDARY_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -694,15 +832,15 @@ endif
 		$(SECONDARY_VIF_DEF) \
 		-DINCBIN=$(SECONDARY) \
 		-c $(TOP)/src/bld/piggy_secondary.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/secondary.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_secondary.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -716,7 +854,7 @@ endif
 .temp/backup.fw: $(BACKUP) $(TOP)/src/bld/piggy_backup.S \
 		 $(BACKUP_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -725,15 +863,15 @@ endif
 		$(BACKUP_VIF_DEF) \
 		-DINCBIN=$(BACKUP) \
 		-c $(TOP)/src/bld/piggy_backup.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/backup.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_backup.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -747,7 +885,7 @@ endif
 .temp/ramdisk.fw: $(RAMDISK) $(TOP)/src/bld/piggy_ramdisk.S \
 		$(RAMDISK_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -756,15 +894,15 @@ endif
 		$(RAMDISK_VIF_DEF) \
 		-DINCBIN=$(RAMDISK) \
 		-c $(TOP)/src/bld/piggy_ramdisk.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/ramdisk.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_ramdisk.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -778,7 +916,7 @@ endif
 .temp/romfs.fw: $(ROMFS) $(TOP)/src/bld/piggy_romfs.S \
 		$(ROMFS_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -787,15 +925,15 @@ endif
 		$(ROMFS_VIF_DEF) \
 		-DINCBIN=$(ROMFS) \
 		-c $(TOP)/src/bld/piggy_romfs.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/romfs.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_romfs.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -809,7 +947,7 @@ endif
 .temp/dsp.fw: $(DSP) $(TOP)/src/bld/piggy_dsp.S \
 		$(DSP_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -818,15 +956,15 @@ endif
 		$(DSP_VIF_DEF) \
 		-DINCBIN=$(DSP) \
 		-c $(TOP)/src/bld/piggy_dsp.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/dsp.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_dsp.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -840,7 +978,7 @@ endif
 .temp/lnx.fw: $(LNX) $(TOP)/src/bld/piggy_lnx.S \
 		 $(LNX_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -849,15 +987,15 @@ endif
 		$(LNX_VIF_DEF) \
 		-DINCBIN=$(LNX) \
 		-c $(TOP)/src/bld/piggy_lnx.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/lnx.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_lnx.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -871,7 +1009,7 @@ endif
 .temp/swp.fw: $(SWP) $(TOP)/src/bld/piggy_swp.S \
 		 $(SWP_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -880,15 +1018,15 @@ endif
 		$(SWP_VIF_DEF) \
 		-DINCBIN=$(SWP) \
 		-c $(TOP)/src/bld/piggy_swp.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/swp.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_swp.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -902,7 +1040,7 @@ endif
 .temp/add.fw: $(ADD) $(TOP)/src/bld/piggy_add.S \
 		 $(ADD_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -911,15 +1049,15 @@ endif
 		$(ADD_VIF_DEF) \
 		-DINCBIN=$(ADD) \
 		-c $(TOP)/src/bld/piggy_add.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/add.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_add.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
@@ -933,7 +1071,7 @@ endif
 .temp/adc.fw: $(ADC) $(TOP)/src/bld/piggy_adc.S \
 		 $(ADC_VIF) $(HOST_UTILS)
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-DCRC32=$(word 3,$(shell ./host_crc32 $<)) \
 		-DIMG_LEN=$(word 2,$(shell ./host_crc32 $<)) \
 		-D__YEAR__=$(YEAR) \
@@ -942,15 +1080,15 @@ endif
 		$(ADC_VIF_DEF) \
 		-DINCBIN=$(ADC) \
 		-c $(TOP)/src/bld/piggy_adc.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 else
 
 .temp/adc.fw:
 	@mkdir -p .temp
-	$(ECHO_GCC) $(CROSS)$(CC) $(AFLAGS) \
+	$(ECHO_GCC) $(CC) $(AFLAGS) \
 		-c $(TOP)/src/bld/piggy_adc.S -o $@
-	$(ECHO_OCP) $(CROSS)$(OBJCOPY) -j .text -O elf32-littlearm $@ $@
+	$(ECHO_OCP) $(OBJCOPY) -j .text -O $(OUTPUT_FORMAT_FLAG) $@ $@
 
 endif
 
diff --git a/config/amboot.amboot.in b/config/amboot.amboot.in
index 4c25b31..d10e505 100644
--- a/config/amboot.amboot.in
+++ b/config/amboot.amboot.in
@@ -4,12 +4,29 @@
 ## History:
 ##    2007/08/22 - [Charles Chiou] created file (branch off)
 ##
-## Copyright (C) 2004-2007, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menu "AMBoot (boot loader)"
@@ -26,28 +43,52 @@ config CONFIG_BOOT_MEDIA_NAND
 config CONFIG_BOOT_MEDIA_EMMC
 	bool "Boot From eMMC"
 	depends on CONFIG_AMBOOT_ENABLE_SD
-	depends on CONFIG_ARCH_S2 || CONFIG_ARCH_S2E || CONFIG_ARCH_S2L || \
-		   CONFIG_ARCH_S3 || CONFIG_ARCH_S3L
 
 config CONFIG_BOOT_MEDIA_SPINOR
 	bool "Boot From SPI NOR"
 	depends on CONFIG_AMBOOT_ENABLE_SPINOR
-	depends on CONFIG_ARCH_S2E || CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || \
-		   CONFIG_ARCH_S3L
+
+config CONFIG_BOOT_MEDIA_SPINAND
+	bool "Boot From SPI NAND"
+	depends on CONFIG_AMBOOT_ENABLE_SPINAND
+
 endchoice
 
 config CONFIG_4K_BOOT_IMAGE
 	bool "Boot Image Size(BST) is 4KB"
 	default n
 
-menu "NAND Boot Options"
-depends on CONFIG_BOOT_MEDIA_NAND
+config CONFIG_AARCH64_TRUSTZONE
+	bool "Boot with TrustZone for ARMv8"
+	depends on CONFIG_CPU_CORTEXA53
+	default n
+	help
+		ARMv8 TrustZone works with ATF, i.e., ARM Trusted Firmware.
 
-endmenu
+config CONFIG_ARMV8_AARCH32
+	bool "Boot with AArch32 Kernel for ARMv8"
+	depends on CONFIG_CPU_CORTEXA53 && !CONFIG_AARCH64_TRUSTZONE
+	default n
+	help
+		ARMv8 uses AArch32 Kernel and AArch32 User Space.
+
+config CONFIG_ARMV8_AARCH32_THUMB2
+	bool "Boot with thumb2 AArch32 Kernel"
+	depends on CONFIG_ARMV8_AARCH32
+	default n
+	help
+		ARMv8 uses AArch32 thumb2 Kernel
 
 menu "eMMC Boot Options"
 depends on CONFIG_BOOT_MEDIA_EMMC
 
+config CONFIG_EMMC_BOOT_INTERFACE
+        string "Boot interface"
+        default "sd0"
+        help
+		This is used to select the sd interface which is used as emmc boot.
+		For exmaple, if you use sd0 as emmc boot, you need fill sd0 in it.
+
 choice
 	prompt "Boot Partition"
 	default CONFIG_EMMC_BOOT_PARTITION_BP1
@@ -75,32 +116,35 @@ config CONFIG_EMMC_BOOT_RST_DISABLE
 
 endchoice
 
-endmenu
+choice
+	prompt "Boot Voltage for EMMC"
+	default CONFIG_EMMC_BOOT_3_3V
 
-menu "Common Boot Options"
+config CONFIG_EMMC_BOOT_3_3V
+	bool "Boot EMMC In 3.3V"
 
-config CONFIG_AMBOOT_COMMAND_SUPPORT
-	bool "Boot with amboot shell Support"
-	default y
+config CONFIG_EMMC_BOOT_1_8V
+	bool "Boot EMMC In 1.8V"
 
-choice
-	prompt "Boot Data"
-	default CONFIG_AMBOOT_BD_FDT_SUPPORT
+endchoice
 
-config CONFIG_AMBOOT_BD_FDT_SUPPORT
-	bool "FDT"
+menu "BLD Option"
+config CONFIG_EMMC_BLD_OPTION
+	bool "BLD With BST In Boot Partition"
+	depends on CONFIG_BOOT_MEDIA_EMMC
+	default n
+endmenu
 
-config CONFIG_AMBOOT_BD_ATAG_SUPPORT
-	bool "ATAG"
+endmenu
 
-config CONFIG_AMBOOT_BD_NONE_SUPPORT
-	bool "Disabled"
+menu "Common Boot Options"
 
-endchoice
+config CONFIG_AMBOOT_COMMAND_SUPPORT
+	bool "Boot with amboot shell Support"
+	default y
 
 config CONFIG_AMBOOT_FDT_LOW_ADDR
 	bool "Place DTB before Kernel"
-	depends on CONFIG_AMBOOT_BD_FDT_SUPPORT
 	default n
 	help
 		If select, DTB will be placed at (KERNEL_RAM_START & 0xfff00000).
@@ -112,7 +156,6 @@ config CONFIG_AMBOOT_SEARCH_PTB
 
 config CONFIG_AMBOOT_BD_CMDLINE
 	string "Booting cmdline"
-	depends on CONFIG_AMBOOT_BD_FDT_SUPPORT || CONFIG_AMBOOT_BD_ATAG_SUPPORT
 	default ""
 	help
 		Enter the booting parameter command line here. Note: the value
@@ -120,20 +163,6 @@ config CONFIG_AMBOOT_BD_CMDLINE
 		into flash, but could be later modified interactively at the
 		AMBoot command prompt.
 
-config CONFIG_AMBOOT_BAPI_SUPPORT
-	bool "Boot with BAPI Support"
-	default y
-
-config CONFIG_AMBOOT_BAPI_ZERO_FB
-	bool "Zero FB memory"
-	default y
-	depends on CONFIG_AMBOOT_BAPI_SUPPORT
-
-config CONFIG_AMBOOT_BAPI_AOSS
-	bool "Auto save BAPI AOSS"
-	default n
-	depends on CONFIG_AMBOOT_BAPI_SUPPORT
-
 config AMBOOT_DEFAULT_SN
 	string "Default SN"
 	default ""
@@ -143,21 +172,12 @@ config AMBOOT_DEFAULT_LINUX_MACHINE_ID
 	default 5010 if CONFIG_ARCH_S3L
 	default 4604 if CONFIG_ARCH_S3
 	default 4603 if CONFIG_ARCH_S2L
-	default 4121 if CONFIG_ARCH_S2
-	default 5009 if CONFIG_ARCH_S2E
-	default 3601 if CONFIG_ARCH_A7
-	default 2873 if CONFIG_ARCH_A7L
-	default 2872 if CONFIG_ARCH_A5S
 	default 1223
 	help
 		Default: 1223
-		A5S: 2872
-		A7L: 2873
-		A7: 3601
-		S2: 4121
-		S2E: 5009
 		S2L: 4603
 		S3: 4604
+		S3L: 5010
 
 config AMBOOT_DEV_AUTO_BOOT
 	bool "Automatically boot up the system"
@@ -197,20 +217,13 @@ config AMBOOT_DEV_USBDL_MODE
 
 endchoice
 
-config AMBOOT_DEV_BOOT_CORTEX
-	bool "Boot Cortex"
-	depends on AMBOOT_DEV_NORMAL_MODE
-	depends on CONFIG_ARCH_S2
-	default n
-	help
-		Boot Cortex by ARM11
-
 config AMBOOT_BOOT_SECONDARY_CORTEX
 	bool "Boot Secondary Cortex"
 	depends on AMBOOT_DEV_NORMAL_MODE
-	depends on CONFIG_ARCH_S2E || CONFIG_ARCH_S3
+	depends on CONFIG_ARCH_S3 || CONFIG_ARCH_S5 || CONFIG_ARCH_H2 || \
+		   CONFIG_ARCH_S5L || CONFIG_ARCH_CV1
+
 	default y
-	default n
 	help
 		Boot second Cortex by first Cortex
 
@@ -226,6 +239,10 @@ config DRAM_TYPE_LPDDR3
 	bool
 	default n
 
+config DRAM_TYPE_LPDDR4
+	bool
+	default n
+
 endmenu
 
 config BUILD_DEVFW
@@ -243,9 +260,22 @@ config SECURE_BOOT
 		Secure boot with crypto chip
 
 config AMBOOT_THAW_HIBERNATION
-	bool "Build thaw from hibernation"
+	bool "Build thaw from hibernation with lzo uncompress"
+	default n
+	help
+
+config AMBOOT_LZO_RESERVE_SIZE
+	hex "AMBoot LZO reserve size"
+	depends on AMBOOT_THAW_HIBERNATION
+	default 0x00300000
+	help
+
+config CONFIG_PANDORA_RTOS
+	bool "Build Pandora real time operating system"
 	default n
+#	select CONFIG_AARCH64_TRUSTZONE if CONFIG_CPU_CORTEXA53
 	help
+		Pandora is a real time operating system for fastboot.
 
 config MINIMAL_FIRMWARE_COMBO
 	bool "Minimal Fimrware Combinations"
@@ -429,5 +459,9 @@ config AMBOOT_BOOT_DSP
 	bool
 	default n
 
+config AMBOOT_DSP_LOG_CAPTURE
+	bool
+	default n
+
 endmenu
 
diff --git a/config/amboot.hw.in b/config/amboot.hw.in
index f897296..b4040ca 100644
--- a/config/amboot.hw.in
+++ b/config/amboot.hw.in
@@ -6,27 +6,39 @@
 ##    2007/10/24 - [Charles Chiou] imported to Linux tree
 ##    2008/02/19 - [Anthony Ginger] imported to AMBuild
 ##
-## Copyright (C) 2004-2007, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menu "Hardware Options"
 depends on BUILD_AMBARELLA_FIRMWARE
 
-config ARCH_SUPPORT_BCH_ID5
-	bool
-	default y if CONFIG_ARCH_S2 || CONFIG_ARCH_S2E || CONFIG_ARCH_S2L || \
-		     CONFIG_ARCH_S3 || CONFIG_ARCH_S3L
-	default n
-
-config ARCH_SUPPORT_SPINOR
+config CONFIG_NAND_COMBO_CONTROLLER
 	bool
-	default y if CONFIG_ARCH_S2E || CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || \
-		     CONFIG_ARCH_S3L
+	default n if CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || CONFIG_ARCH_S3L || \
+		     CONFIG_ARCH_S5 || CONFIG_ARCH_S5L
+	default y
 
 config CONFIG_FLASH_PAGE_256
 	bool
@@ -64,12 +76,11 @@ config CONFIG_FLASH_ERASE_256k
 	bool
 	default n
 
-config CONFIG_AMBOOT_ENABLE_NAND
+menuconfig CONFIG_AMBOOT_ENABLE_NAND
 	bool "Support NAND Driver"
 	default y
 
-menu "NAND Subsystem Options"
-depends on CONFIG_AMBOOT_ENABLE_NAND
+if CONFIG_AMBOOT_ENABLE_NAND
 
 config CONFIG_NAND_ERASE_UNUSED_BLOCK
 	bool "Erase unused NAND block when programming"
@@ -340,12 +351,19 @@ config CONFIG_NAND_HY27US4G86F2D
 	help
 		Hynix H27US4G86F2D 4Gbit NAND
 
+config CONFIG_NAND_H27U2G8F2C
+	bool "Hynix H27U2G8F2C"
+	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		Hynix H27U2G8F2C 2Gbitx8 NAND flash
+
 config CONFIG_NAND_H27U2G8F2D
 	bool "Hynix H27U2G8F2D"
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		Hynix H27U2G8F2D 2Gbitx8 NAND flash
 
@@ -373,6 +391,14 @@ config CONFIG_NAND_MX30LF2GE8AB
 	help
 		Macronix MX30LF2GE8AB 2Gb NAND
 
+config CONFIG_NAND_MX30LF4GE8AB
+	bool "Macronix MX30LF4GE8AB"
+	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		Macronix MX30LF4GE8AB 4Gb NAND
+
 config CONFIG_NAND_ST128W3A
 	bool "ST NAND128W3A"
 	select CONFIG_NAND_P512_E16K
@@ -490,7 +516,6 @@ config CONFIG_NAND_TC58NVG0S3H
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		TOSHIBA TC58NVG0S3H 1Gbit 8-bit ECC NAND
 
@@ -499,7 +524,6 @@ config CONFIG_NAND_TC58NVG1S3H
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		TOSHIBA TC58NVG1S3H 2Gbit 8-bit ECC NAND
 
@@ -541,7 +565,6 @@ config CONFIG_NAND_MT29F1G08ABAEA
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		Micron MT29F1G08ABAEA 1Gbitx8 NAND flash
 
@@ -550,7 +573,6 @@ config CONFIG_NAND_MT29F2G08ABA
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		Micron MT29F2G08ABA 2Gbitx8 NAND flash
 
@@ -567,19 +589,41 @@ config CONFIG_NAND_MT29F4G08ABADA
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		Micron MT29F4G08ABADA 4Gbitx8 NAND flash
 
+config CONFIG_NAND_MT29F4G08ABBDA
+	bool "Micron MT29F4G08ABBDA"
+	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		Micron MT29F4G08ABBDA 4Gbitx8 NAND flash
+
 config CONFIG_NAND_MT29F2G08ABAFA
 	bool "Micron MT29F2G08ABAFA"
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		Micron MT29F2G08ABAFA 2Gbitx8 NAND flash
 
+config CONFIG_NAND_MT29F2G08ABBEA
+	bool "Micron MT29F2G08ABBEA"
+	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		Micron MT29F2G08ABBEA 2Gbitx8 NAND flash
+
+config CONFIG_NAND_MT29F2G08ABAGA
+	bool "Micron MT29F2G08ABAGA"
+	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		Micron MT29F2G08ABAGA 2Gbitx8 NAND flash
+
 config CONFIG_NAND_CT48248NS486G1
 	bool "Chipsip CT48248NS486G1"
 	select CONFIG_NAND_P2K_E128K
@@ -625,7 +669,6 @@ config CONFIG_NAND_F59L1G81MA
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		ESMT F59L1G81MA 1Gbit NAND
 
@@ -634,7 +677,6 @@ config CONFIG_NAND_F59L2G81A
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		ESMT F59L2G81A (or EoN EN27LN2G08) 2Gbit NAND
 
@@ -643,7 +685,6 @@ config CONFIG_NAND_F59L4G81A
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		ESMT F59L4G81A (or EoN EN27LN4G08) 4Gbit NAND
 
@@ -663,6 +704,14 @@ config CONFIG_NAND_S34ML02G1
 	help
 		Spansion S34ML02G1 2Gbit NAND
 
+config CONFIG_NAND_S34MS02G1
+	bool "Spansion S34MS02G1"
+	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		Spansion S34MS02G1 2Gbit NAND
+
 config CONFIG_NAND_S34ML04G1
 	bool "Spansion S34ML04G1"
 	select CONFIG_NAND_P2K_E128K
@@ -671,12 +720,27 @@ config CONFIG_NAND_S34ML04G1
 	help
 		Spansion S34ML04G1 4Gbit NAND
 
+config CONFIG_NAND_S34MS04G1
+	bool "Spansion S34MS04G1"
+	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		Spansion S34MS04G1 4Gbit NAND
+
+config CONFIG_NAND_S34ML08G1
+	bool "Spansion S34ML08G1"
+	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		Spansion S34ML08G1 8Gbit NAND
+
 config CONFIG_NAND_S34ML01G2
 	bool "Spansion S34ML01G2"
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		Spansion S34ML01G2 1Gbit NAND
 
@@ -685,7 +749,6 @@ config CONFIG_NAND_S34ML02G2
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		Spansion S34ML02G2 2Gbit NAND
 
@@ -694,80 +757,71 @@ config CONFIG_NAND_S34ML04G2
 	select CONFIG_NAND_P2K_E128K
 	select CONFIG_FLASH_PAGE_2K
 	select CONFIG_FLASH_ERASE_128k
-	depends on ARCH_SUPPORT_BCH_ID5
 	help
 		Spansion S34ML04G2 4Gbit NAND
 
 config CONFIG_NAND_W29N01GVSCAA
 	bool "WINBOND W29N01GVSCAA"
 	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
 	help
 		WINBOND W29N01GVSCAA 1Gbit NAND
 
+config CONFIG_NAND_W29N01HVXINF
+	bool "WINBOND W29N01HVXINF"
+	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		WINBOND W29N01HVXINF 1Gbit NAND
+
 config CONFIG_NAND_W29N02GVSIAA
 	bool "WINBOND W29N02GVSIAA"
 	select CONFIG_NAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
 	help
 		WINBOND W29N02GVSIAA 2Gbit NAND
 endchoice
 
-choice
-	prompt "NAND Flash Devices"
-	default CONFIG_NAND_1DEVICE
-	help
-		Select the number of NAND device(s)/chip(s)
-
-config CONFIG_NAND_1DEVICE
-       bool "1"
-       help
-		1 Device/chip
-
-config CONFIG_NAND_2DEVICE
-       bool "2"
-       help
-		2 Devices/chips
+endif
 
-config CONFIG_NAND_4DEVICE
-       bool "4"
-       help
-		4 Devices/chips
-
-endchoice
-
-endmenu
-
-config CONFIG_AMBOOT_ENABLE_CRYPTO_CHIP
-	bool "Support Crypto chip"
+menuconfig CONFIG_AMBOOT_ENABLE_SD
+	bool "Support SD Driver"
 	default n
 
-config CONFIG_AMBOOT_ENABLE_ATSHA204
-	bool "Support Crypto chip, Atmel ATSHA204"
-	depends on CONFIG_AMBOOT_ENABLE_CRYPTO_CHIP
-	default y
+if CONFIG_AMBOOT_ENABLE_SD
 
-config CONFIG_AMBOOT_BUILD_ATSHA204_FROM_SOURCE
-	bool "build Atmel ATSHA204 from source code"
-	depends on CONFIG_AMBOOT_ENABLE_ATSHA204
-	default n
+choice
+	prompt "SD Shmoo Algorithm"
+	default CONFIG_SD_SHMOO_PHY_TURNING
+	depends on CONFIG_AMBOOT_ENABLE_SD
+	help
+		Select Shmoo Algorithm for SD
 
-config CONFIG_AMBOOT_ENABLE_SD
-	bool "Support SD Driver"
-	default n
+config CONFIG_SD_SHMOO_PHY_TURNING
+	bool "SD Shmoo base on sd phy"
+	help
+		This is used to adjust SD timing for s2e, s2l, and compatibility with s3l
 
-menu "SD Subsystem Options"
-depends on CONFIG_AMBOOT_ENABLE_SD
+config CONFIG_SD_SHMOO_SD_CTL
+	bool "SD Shmoo base on sd controller"
+	depends on CONFIG_ARCH_S3L
+	help
+		This is used to adjust SD timing for s3l and later chip
 
-endmenu
+endchoice
+
+endif
 
-config CONFIG_AMBOOT_ENABLE_SPINOR
+menuconfig CONFIG_AMBOOT_ENABLE_SPINOR
 	bool "Support SPI NOR Driver"
-	depends on ARCH_SUPPORT_SPINOR
 	default n
 	help
 		Enable the SPI Nor driver if it is present on the target board
 
-menu "SPI NOR Subsystem Options"
-depends on CONFIG_AMBOOT_ENABLE_SPINOR
+if CONFIG_AMBOOT_ENABLE_SPINOR
 
 config CONFIG_SPINOR_P512_E256K
 	bool
@@ -784,29 +838,13 @@ choice
 	help
 		Select the onboard SPI NOR flash type
 
-config CONFIG_SPI_NOR_W25Q64FV
-	bool "Winbond W25Q64FV(GigaDevice GD25Q64C)"
-	select CONFIG_SPINOR_P256_E64K
-	select CONFIG_FLASH_PAGE_256
-	select CONFIG_FLASH_ERASE_64k
-	help
-		Winbond W25Q64FV/GigaDevice GD25Q64C 64Mbit NOR
-
-config CONFIG_SPI_NOR_W25Q128FV
-	bool "Winbond W25Q128FV (GigaDevice GD25Q128C)"
+config CONFIG_SPI_NOR_NORMAL
+	bool "SPI NOR FLASH WITH 256BYTE PAGE SIZE"
 	select CONFIG_SPINOR_P256_E64K
 	select CONFIG_FLASH_PAGE_256
 	select CONFIG_FLASH_ERASE_64k
 	help
-		Winbond W25Q128FV/GigaDevice GD25Q128C 128Mbit NOR
-
-config CONFIG_SPI_NOR_N25Q256A
-	bool "Micron N25Q256A"
-	select CONFIG_SPINOR_P256_E64K
-	select CONFIG_FLASH_PAGE_256
-	select CONFIG_FLASH_ERASE_64k
-	help
-		Micron N25Q256A 256Mbit NOR
+		SPI NOR Flash that has 256Bytes page size
 
 config CONFIG_SPI_NOR_FL01GS
 	bool "Spansion FL01GS"
@@ -816,63 +854,82 @@ config CONFIG_SPI_NOR_FL01GS
 	help
 		Spansion FL01GS NOR
 
-config CONFIG_SPI_NOR_MX25L25645G
-	bool "Macronix MX25L25645G (Winbond W25Q256FV)"
-	select CONFIG_SPINOR_P256_E64K
-	select CONFIG_FLASH_PAGE_256
-	select CONFIG_FLASH_ERASE_64k
-	help
-		Macronix MX25L25645G/Winbond W25Q256FV 256Mbit NOR
+endchoice
 
-config CONFIG_SPI_NOR_GD25Q512
-	bool "GigaDevice GD25Q512"
-	select CONFIG_SPINOR_P256_E64K
-	select CONFIG_FLASH_PAGE_256
-	select CONFIG_FLASH_ERASE_64k
+endif
+
+menuconfig CONFIG_AMBOOT_ENABLE_SPINAND
+	bool "Support SPI NAND Driver"
+	default n
 	help
-		 GigaDevice GD25Q512 512Mbit NOR
-endchoice
+		Enable the SPI NAND driver if it is present on the target board
 
-endmenu
+if CONFIG_AMBOOT_ENABLE_SPINAND
 
-config CONFIG_AMBOOT_ENABLE_SPI
-	bool "Support SPI Driver"
+config CONFIG_SPINAND
+	bool
 	default n
 
-menu "SPI Subsystem Options"
-depends on CONFIG_AMBOOT_ENABLE_SPI
+config CONFIG_SPINAND_USE_FLASH_BBT
+	bool "SPINAND Flash use BBT on Flash"
+	default y
 
-endmenu
+config CONFIG_SPINAND_USE_RESET_PIN
+	bool "SPINAND Flash Use RESET Pin"
+	default n
+	help
+		SPINAND Flash use SIO3 as RESET pin function
 
-config CONFIG_AMBOOT_ENABLE_IDC
-	bool "Support IDC Driver"
+config CONFIG_SPINAND_P2K_E128K
+	bool
 	default n
 
-menu "IDC Subsystem Options"
-depends on CONFIG_AMBOOT_ENABLE_IDC
+choice
+	prompt "SPI NAND Flash Type"
+	default CONFIG_SPI_NAND_GD5F2GQ4UC
+	depends on CONFIG_AMBOOT_ENABLE_SPINAND
+	help
+		Select the onboard SPI NAND flash type
 
-config CONFIG_AMBOOT_ENABLE_ISL12022M
-	bool "Support ISL12022M"
-	default n
+config CONFIG_SPI_NAND_GD5F1GQ4UC
+	bool "GigaDevice GD5F1GQ4UC"
+	select CONFIG_SPINAND
+	select CONFIG_SPINAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		 GigaDevice GD5F1GQ4UC 1Gbit Nand
 
-config CONFIG_AMBOOT_ENABLE_PCA953X
-	bool "Support PCA953X"
+config CONFIG_SPI_NAND_GD5F2GQ4UC
+	bool "GigaDevice GD5F2GQ4UC"
+	select CONFIG_SPINAND
+	select CONFIG_SPINAND_P2K_E128K
+	select CONFIG_FLASH_PAGE_2K
+	select CONFIG_FLASH_ERASE_128k
+	help
+		 GigaDevice GD5F2GQ4UC 2Gbit Nand
+
+endchoice
+
+endif
+
+config CONFIG_AMBOOT_ENABLE_SPI
+	bool "Support SPI Driver"
 	default n
 
-endmenu
+config CONFIG_AMBOOT_ENABLE_IDC
+	bool "Support IDC Driver"
+	default n
 
-config CONFIG_AMBOOT_ENABLE_ETH
+menuconfig CONFIG_AMBOOT_ENABLE_ETH
 	bool "Support ETH Driver"
 	default y
-	depends on !CONFIG_ARCH_A7L
-
-menu "ETH Subsystem Options"
-depends on CONFIG_AMBOOT_ENABLE_ETH
 
+if CONFIG_AMBOOT_ENABLE_ETH
 choice
 	prompt "PHY Clock"
 	default CONFIG_AMBOOT_ETH_PHY_CLK_INTERNAL
-	depends on CONFIG_ARCH_S2 || CONFIG_ARCH_S2E
+	depends on CONFIG_ARCH_S5L || CONFIG_ARCH_CV1
 
 config CONFIG_AMBOOT_ETH_PHY_CLK_EXTERNAL
         bool "Use external gtx clock"
@@ -882,26 +939,20 @@ config CONFIG_AMBOOT_ETH_PHY_CLK_INTERNAL
 
 endchoice
 
-endmenu
+config CONFIG_AMBOOT_ETH_PHY_CLK_INVERT
+	bool "Invert ethernet clock"
+	default y
+
+endif
 
 config CONFIG_AMBOOT_ENABLE_USB
 	bool "Support USB Driver"
 	default y
 
-menu "USB Subsystem Options"
-depends on CONFIG_AMBOOT_ENABLE_USB
-
-endmenu
-
 config CONFIG_AMBOOT_ENABLE_GPIO
 	bool "Support GPIO Driver"
 	default y
 
-menu "GPIO Subsystem Options"
-depends on CONFIG_AMBOOT_ENABLE_GPIO
-
-endmenu
-
 choice
 	prompt "UART Port"
 	default CONFIG_AMBOOT_ENABLE_UART0
@@ -912,6 +963,11 @@ config CONFIG_AMBOOT_DISABLE_UART
 config CONFIG_AMBOOT_ENABLE_UART0
 	bool "UART0"
 
+config CONFIG_AMBOOT_ENABLE_UART1
+	bool "UART1"
+
+config CONFIG_AMBOOT_ENABLE_UART2
+	bool "UART2"
 endchoice
 
 menu "UART Subsystem Options"
@@ -939,6 +995,53 @@ endchoice
 
 endmenu
 
+menu "Audio Subsystem Options"
+
+choice
+	prompt "Audio Sample Rate"
+	default AMBOOT_AUDIO_16000
+	help
+		Select the sample rate for audio in amboot
+
+config AMBOOT_AUDIO_8000
+	bool "8000"
+
+config AMBOOT_AUDIO_16000
+	bool "16000"
+
+config AMBOOT_AUDIO_48000
+	bool "48000"
+
+endchoice
+
+choice
+	prompt "Audio Sample Bit"
+	default AMBOOT_AUDIO_16BIT
+	help
+		Select the sample bit for audio in amboot
+
+config AMBOOT_AUDIO_16BIT
+	bool "sample 16bit"
+
+config AMBOOT_AUDIO_32BIT
+	bool "sample 32bit"
+endchoice
+
+choice
+	prompt "Audio I2S Mode"
+	default AMBOOT_AUDIO_MODE_MASTER
+	help
+		Select the mode for i2s in amboot
+
+config AMBOOT_AUDIO_MODE_MASTER
+	bool "AMBA i2s mode :Master"
+
+config AMBOOT_AUDIO_MODE_SLAVE
+	bool "AMBA i2s mode :Slave"
+endchoice
+
+endmenu
+
 config CONFIG_AMBOOT_ENABLE_ADC
 	bool "Support ADC diag"
 	default n
@@ -947,5 +1050,33 @@ config CONFIG_AMBOOT_ENABLE_IR
 	bool "Support IR diag"
 	default n
 
-endmenu
+config CONFIG_AMBOOT_ENABLE_MULTI_VIN
+	bool "Support Multi-Vin"
+	default n
+	help
+		valid only when both multi-vin and single-vin exist
+
+comment "Peripheral Devices"
+
+config CONFIG_AMBOOT_ENABLE_ATSHA204
+	bool "Support Crypto chip, Atmel ATSHA204"
+	depends on SECURE_BOOT
+	select CONFIG_AMBOOT_ENABLE_IDC
+	default y
+
+config CONFIG_AMBOOT_ENABLE_PCA953X
+	bool "Support PCA953X"
+	select CONFIG_AMBOOT_ENABLE_IDC
+	default n
 
+config CONFIG_AMBOOT_ENABLE_ISL12022M
+	bool "Support Isl12022m"
+	select CONFIG_AMBOOT_ENABLE_IDC
+	default n
+
+config CONFIG_AMBOOT_ENABLE_MICREL
+        bool "Support Micrel Ethernet Phy"
+        depends on CONFIG_AMBOOT_ENABLE_ETH
+        default n
+
+endmenu
diff --git a/config/amboot.mem.in b/config/amboot.mem.in
index ac61727..6abe2f9 100644
--- a/config/amboot.mem.in
+++ b/config/amboot.mem.in
@@ -6,12 +6,29 @@
 ##    2007/10/24 - [Charles Chiou] imported to Linux tree
 ##    2008/02/19 - [Anthony Ginger] imported to AMBuild
 ##
-## Copyright (C) 2004-2007, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 menu "Memory Options"
@@ -21,9 +38,8 @@ menu "AMBoot memory options"
 
 config AMBOOT_BLD_RAM_START
 	hex "AMBoot bootloader starting address"
-	default 0x00000000 if CONFIG_ARCH_S2E || CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || \
-			      CONFIG_ARCH_S3L
-	default 0xC0000000
+	default 0x00000000 if !CONFIG_AARCH64_TRUSTZONE
+	default 0x00100000
 	help
 		The AMBoot bootloader starting address - The bootloader code is
 		the 2nd-stage code that is loaded by the AMBoot bootstrapper
@@ -58,9 +74,7 @@ menu "RTOS memory options"
 
 config KERNEL_RAM_START
 	hex "Kernel start address"
-	default 0x00208000 if CONFIG_ARCH_S2E || CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || \
-			      CONFIG_ARCH_S3L
-	default 0xC0208000
+	default 0x00208000
 	help
 		KERNEL DRAM Start = (KERNEL_RAM_START & 0xFFF00000)
 		KERNEL DRAM Size = (IDSP_RAM_START -
@@ -68,19 +82,22 @@ config KERNEL_RAM_START
 
 config AMBARELLA_INITRD_PHYS
 	hex "Initrd start address"
-	default 0x00A00000 if CONFIG_ARCH_S2E || CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || \
-			      CONFIG_ARCH_S3L
-	default 0xC0A00000
+	default 0x00A00000
 
 config IDSP_RAM_START
 	hex "DSP DRAM start address"
-	default 0x08000000 if CONFIG_ARCH_S2E || CONFIG_ARCH_S2L || CONFIG_ARCH_S3 || \
-			      CONFIG_ARCH_S3L
-	default 0xC8000000
+	default 0x08000000
 	help
 		DSP DRAM Start = IDSP_RAM_START
 		DSP DRAM Size = (DRAM_SIZE - (IDSP_RAM_START - DRAM_START_ADDR))
 
+config CV_RAM_START
+	hex "CV DRAM start address"
+	default 0x10000000
+	depends on CONFIG_ARCH_CV1
+	help
+		CV DRAM Start = CV_RAM_START
+
 config DSP_FASTDATA_SIZE
 	hex "DSP Reserved Buffer Size for Fastboot Data(Sync data from amboot to IAV)"
 	default 0x0000000
diff --git a/include/adc.h b/include/adc.h
index 4fa5e12..0182f7c 100644
--- a/include/adc.h
+++ b/include/adc.h
@@ -3,21 +3,66 @@
  *
  * Author: Roy Su <qiangsu@ambarella.com>
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __AMBOOT_ADC_H__
 #define __AMBOOT_ADC_H__
 
+/* ADC partition memory layout
+ *
+ * +-------------------------------------------------------------------------+
+ * |  ADC  | adc_node |            | adc_node |            |
+ * |       |----------| iso config |----------| tone_curve |...rgb2yuv...le...
+ * |  hdr  |   next   |            |  next    |            |
+ * +-------------------------------------------------------------------------+
+ *              |                  ^    |                  ^ ......
+ *              |__________________|    |__________________|
+ *
+ */
+
 //add for smart 3a params in adc partition
-#define ADCFW_IMG_MAGIC			(0x43525243)
+#if defined(CONFIG_ARCH_S2L)
+#define ADCFW_IMG_MAGIC			(0x12160513)
+#elif defined(CONFIG_ARCH_S3L)
+#define ADCFW_IMG_MAGIC			(0x13160513)
+#elif defined(CONFIG_ARCH_S5)
+#define ADCFW_IMG_MAGIC			(0x11160513)
+#else
+#define ADCFW_IMG_MAGIC			(0xFF160513)
+#endif
+
+#define LAST_NODE_OFFSET	(0xFFFFFFFF)
+struct adc_node {
+	unsigned int pf_id;
+	unsigned int bin_size;
+	unsigned int next_offset;
+}__attribute__((packed));
 
-struct smart3a_file_info { /* 4 + (4 * 5) + 5 + 3 = 32 */
+struct smart3a_file_info { /* 4 + (4 * 5) + 6 + 2 = 32 */
 	unsigned int	offset;
 	/* AWB */
 	unsigned int	r_gain;
@@ -33,27 +78,44 @@ struct smart3a_file_info { /* 4 + (4 * 5) + 5 + 3 = 32 */
 	/* Sensor 2 AGC Register */
 	unsigned char para3;
 	unsigned char para4;
+	unsigned char para5;
 
-	unsigned char rev[3];
+	unsigned char rev[2];
 }__attribute__((packed));
 
+struct params_info { /* (4 * 1) + (5 * 4) + (5 * 4) + 32 + 2 + 18= 96 */
+	unsigned char enable_audio;
+	unsigned char enable_fastosd;
+	unsigned char enable_ldc;
+	unsigned char rotation_mode;
+
+	unsigned int stream0_enable;
+	unsigned int stream0_resolution;
+	unsigned int stream0_fmt;
+	unsigned int stream0_fps;
+	unsigned int stream0_bitrate;
+
+	unsigned int stream1_enable;
+	unsigned int stream1_resolution;
+	unsigned int stream1_fmt;
+	unsigned int stream1_fps;
+	unsigned int stream1_bitrate;
 
-struct video_param_info { /* 4 + 4 + 4  + 4 = 16 */
-      unsigned int enable_video_param;
-      unsigned int video_mode;
-      unsigned int bitrate_quality;
-      unsigned int res;
+	char fastosd_string[32];
+	unsigned char enable_vca;
+	unsigned char vca_frame_num;
+	unsigned char reserved[18];
 }__attribute__((packed));
 
-struct adcfw_header { /* 4 + 4 + 2 + 2 + 20 + (32 * 4) + 96 = 256 */
+struct adcfw_header { /* 4 + 4 + 2 + 2 + 20 + (32 * 5) + 96 = 288 */
 	unsigned int	magic;
 	unsigned int	fw_size; /* totally fw size including the header */
 	unsigned short	smart3a_num;
 	unsigned short	smart3a_size;
-	unsigned char head_rev[20];
-	struct smart3a_file_info smart3a[4];
-       struct video_param_info video_param;
-	unsigned char rev[80];
+	unsigned int	adc_hdr_size;
+	unsigned char reserved[16];
+	struct smart3a_file_info smart3a[5];
+	struct params_info params_in_amboot;
 }__attribute__((packed));
 
 #endif
diff --git a/include/ambhw/adc.h b/include/ambhw/adc.h
index cb7d5e0..077e93e 100644
--- a/include/ambhw/adc.h
+++ b/include/ambhw/adc.h
@@ -1,333 +1,277 @@
-/*
- * ambhw/adc.h
- *
- * History:
- *	2006/12/27 - [Charles Chiou] created file
- *
- * Copyright (C) 2004-2014, Ambarella, Inc.
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- */
-
-#ifndef __AMBHW__ADC__
-#define __AMBHW__ADC__
-
-/* ==========================================================================*/
-#if (CHIP_REV == A7L)
-#define ADC_NUM_CHANNELS		8
-#elif (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define ADC_NUM_CHANNELS		12
-#elif (CHIP_REV == S3)
-#define ADC_NUM_CHANNELS		5
-#else
-#define ADC_NUM_CHANNELS		4
-#endif
-
-#if (CHIP_REV == A5S)
-#define ADC_SUPPORT_THRESHOLD_INT	0
-#define ADC_SUPPORT_SLOT		0
-#else
-#define ADC_SUPPORT_THRESHOLD_INT	1
-#define ADC_SUPPORT_SLOT		1
-#endif
-
-/* ==========================================================================*/
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define ADC_OFFSET			0x1D000
-#else
-#define ADC_OFFSET			0xD000
-#endif
-#define ADC_BASE			(APB_BASE + ADC_OFFSET)
-#define ADC_REG(x)			(ADC_BASE + (x))
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S)
-#define ADC_CONTROL_TYPE		0
-#define ADC_CONTROL_OFFSET		0x00
-#define ADC_ENABLE_OFFSET		0x18
-#else
-#define ADC_CONTROL_TYPE		1
-#define ADC_CONTROL_OFFSET		0x04
-#define ADC_ENABLE_OFFSET		ADC_CONTROL_OFFSET
-#endif
-
-#if (CHIP_REV == A5S)
-/* NOTE: ADC channel is re-order for A5S to make life easier */
-#define ADC_DATA0_OFFSET		0x04
-#define ADC_DATA1_OFFSET		0x08
-#define ADC_DATA2_OFFSET		0x0c
-#define ADC_DATA3_OFFSET		0x10
-#else
-#define ADC_DATA0_OFFSET		0x150
-#define ADC_DATA1_OFFSET		0x154
-#define ADC_DATA2_OFFSET		0x158
-#define ADC_DATA3_OFFSET		0x15c
-#endif
-
-#define ADC_COUNTER_OFFSET		0x008
-
-#if (CHIP_REV == A5S)
-#define ADC_CHAN0_INTR_OFFSET		0x44
-#define ADC_CHAN1_INTR_OFFSET		0x48
-#define ADC_CHAN2_INTR_OFFSET		0x4c
-#define ADC_CHAN3_INTR_OFFSET		0x50
-#else
-#define ADC_CHAN0_INTR_OFFSET		0x120
-#define ADC_CHAN1_INTR_OFFSET		0x124
-#define ADC_CHAN2_INTR_OFFSET		0x128
-#define ADC_CHAN3_INTR_OFFSET		0x12c
-#endif
-
-#if (CHIP_REV == A7L)
-#define ADC_DATA4_OFFSET		0x100
-#define ADC_DATA5_OFFSET		0x104
-#define ADC_DATA6_OFFSET		0x108
-#define ADC_DATA7_OFFSET		0x10c
-#define ADC_CHAN4_INTR_OFFSET		0x110
-#define ADC_CHAN5_INTR_OFFSET		0x114
-#define ADC_CHAN6_INTR_OFFSET		0x118
-#define ADC_CHAN7_INTR_OFFSET		0x11c
-#elif (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S3)
-#define ADC_DATA4_OFFSET		0x160
-#define ADC_DATA5_OFFSET		0x164
-#define ADC_DATA6_OFFSET		0x168
-#define ADC_DATA7_OFFSET		0x16c
-#define ADC_CHAN4_INTR_OFFSET		0x130
-#define ADC_CHAN5_INTR_OFFSET		0x134
-#define ADC_CHAN6_INTR_OFFSET		0x138
-#define ADC_CHAN7_INTR_OFFSET		0x13c
-#else
-#define ADC_DATA4_OFFSET		0x54
-#define ADC_DATA5_OFFSET		0x58
-#define ADC_DATA6_OFFSET		0x5c
-#define ADC_DATA7_OFFSET		0x60
-#define ADC_CHAN4_INTR_OFFSET		0x64
-#define ADC_CHAN5_INTR_OFFSET		0x68
-#define ADC_CHAN6_INTR_OFFSET		0x6c
-#define ADC_CHAN7_INTR_OFFSET		0x70
-#endif
-
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define ADC_DATA8_OFFSET		0x170
-#define ADC_DATA9_OFFSET		0x174
-#define ADC_DATA10_OFFSET		0x178
-#define ADC_DATA11_OFFSET		0x17c
-#define ADC_CHAN8_INTR_OFFSET		0x140
-#define ADC_CHAN9_INTR_OFFSET		0x144
-#define ADC_CHAN10_INTR_OFFSET		0x148
-#define ADC_CHAN11_INTR_OFFSET		0x14c
-#else
-#define ADC_DATA8_OFFSET		0x60
-#define ADC_DATA9_OFFSET		0x70
-#define ADC_CHAN8_INTR_OFFSET		0x120
-#define ADC_CHAN9_INTR_OFFSET		0x124
-#endif
-
-/* S2, S2L and S3 */
-#define ADC_STATUS_OFFSET		0x000
-#define ADC_SLOT_NUM_OFFSET		0x00c
-#define ADC_SLOT_PERIOD_OFFSET		0x010
-#define ADC_CTRL_INTR_TABLE_OFFSET	0x044
-#define ADC_DATA_INTR_TABLE_OFFSET	0x048
-#define ADC_FIFO_INTR_TABLE_OFFSET	0x04c
-#define ADC_ERR_STATUS_OFFSET		0x050
-
-#define ADC_SLOT_CTRL_0_OFFSET		0x100
-#define ADC_SLOT_CTRL_1_OFFSET		0x104
-#define ADC_SLOT_CTRL_2_OFFSET		0x108
-#define ADC_SLOT_CTRL_3_OFFSET		0x10c
-#define ADC_SLOT_CTRL_4_OFFSET		0x110
-#define ADC_SLOT_CTRL_5_OFFSET		0x114
-#define ADC_SLOT_CTRL_6_OFFSET		0x118
-#define ADC_SLOT_CTRL_7_OFFSET		0x11c
-
-#define ADC_FIFO_CTRL_0_OFFSET		0x180
-#define ADC_FIFO_CTRL_1_OFFSET		0x184
-#define ADC_FIFO_CTRL_2_OFFSET		0x188
-#define ADC_FIFO_CTRL_3_OFFSET		0x18C
-#define ADC_FIFO_CTRL_OFFSET		0x190
-
-#define ADC_FIFO_STATUS_0_OFFSET	0x1a0
-#define ADC_FIFO_STATUS_1_OFFSET	0x1a4
-#define ADC_FIFO_STATUS_2_OFFSET	0x1a8
-#define ADC_FIFO_STATUS_3_OFFSET	0x1ac
-
-#define ADC_EC_ADC_OFFSET		0x1C0
-#define ADC_EC_REFVAL_OFFSET		0x1C4
-#define ADC_EC_RESHAPE_OFFSET		0x1C8
-
-#define ADC_FIFO_DATA0_OFFSET		0x200
-#define ADC_FIFO_DATA1_OFFSET		0x280
-#define ADC_FIFO_DATA2_OFFSET		0x300
-#define ADC_FIFO_DATA3_OFFSET		0x380
-
-/* A7 */
-#define ADC_DATA4_SAMPLE0_OFFSET	0x60
-#define ADC_DATA4_SAMPLE1_OFFSET	0x64
-#define ADC_DATA4_SAMPLE2_OFFSET	0x68
-#define ADC_DATA4_SAMPLE3_OFFSET	0x6c
-#define ADC_DATA5_SAMPLE0_OFFSET	0x70
-#define ADC_DATA5_SAMPLE1_OFFSET	0x74
-#define ADC_DATA5_SAMPLE2_OFFSET	0x78
-#define ADC_DATA5_SAMPLE3_OFFSET	0x5c
-
-#define ADC_CONTROL_REG			ADC_REG(ADC_CONTROL_OFFSET)
-#define ADC_COUNTER_REG			ADC_REG(ADC_COUNTER_OFFSET)
-#define ADC_ENABLE_REG			ADC_REG(ADC_ENABLE_OFFSET)
-
-#define ADC_DATA0_REG			ADC_REG(ADC_DATA0_OFFSET)
-#define ADC_DATA1_REG			ADC_REG(ADC_DATA1_OFFSET)
-#define ADC_DATA2_REG			ADC_REG(ADC_DATA2_OFFSET)
-#define ADC_DATA3_REG			ADC_REG(ADC_DATA3_OFFSET)
-#define ADC_DATA4_REG			ADC_REG(ADC_DATA4_OFFSET)
-#define ADC_DATA5_REG			ADC_REG(ADC_DATA5_OFFSET)
-#define ADC_DATA6_REG			ADC_REG(ADC_DATA6_OFFSET)
-#define ADC_DATA7_REG			ADC_REG(ADC_DATA7_OFFSET)
-#define ADC_DATA8_REG			ADC_REG(ADC_DATA8_OFFSET)
-#define ADC_DATA9_REG			ADC_REG(ADC_DATA9_OFFSET)
-
-#define ADC_CHAN0_INTR_REG		ADC_REG(ADC_CHAN0_INTR_OFFSET)
-#define ADC_CHAN1_INTR_REG		ADC_REG(ADC_CHAN1_INTR_OFFSET)
-#define ADC_CHAN2_INTR_REG		ADC_REG(ADC_CHAN2_INTR_OFFSET)
-#define ADC_CHAN3_INTR_REG		ADC_REG(ADC_CHAN3_INTR_OFFSET)
-#define ADC_CHAN4_INTR_REG		ADC_REG(ADC_CHAN4_INTR_OFFSET)
-#define ADC_CHAN5_INTR_REG		ADC_REG(ADC_CHAN5_INTR_OFFSET)
-#define ADC_CHAN6_INTR_REG		ADC_REG(ADC_CHAN6_INTR_OFFSET)
-#define ADC_CHAN7_INTR_REG		ADC_REG(ADC_CHAN7_INTR_OFFSET)
-#define ADC_CHAN8_INTR_REG		ADC_REG(ADC_CHAN8_INTR_OFFSET)
-#define ADC_CHAN9_INTR_REG		ADC_REG(ADC_CHAN9_INTR_OFFSET)
-
-#define ADC_DATA4_SAMPLE0_REG		ADC_REG(ADC_DATA4_SAMPLE0_OFFSET)
-#define ADC_DATA4_SAMPLE1_REG		ADC_REG(ADC_DATA4_SAMPLE1_OFFSET)
-#define ADC_DATA4_SAMPLE2_REG		ADC_REG(ADC_DATA4_SAMPLE2_OFFSET)
-#define ADC_DATA4_SAMPLE3_REG		ADC_REG(ADC_DATA4_SAMPLE3_OFFSET)
-#define ADC_DATA5_SAMPLE0_REG		ADC_REG(ADC_DATA5_SAMPLE0_OFFSET)
-#define ADC_DATA5_SAMPLE1_REG		ADC_REG(ADC_DATA5_SAMPLE1_OFFSET)
-#define ADC_DATA5_SAMPLE2_REG		ADC_REG(ADC_DATA5_SAMPLE2_OFFSET)
-#define ADC_DATA5_SAMPLE3_REG		ADC_REG(ADC_DATA5_SAMPLE3_OFFSET)
-
-/* valid only for S2/S2E/S2L/S3/S3L */
-#define ADC_STATUS_REG			ADC_REG(ADC_STATUS_OFFSET)
-#define ADC_SLOT_NUM_REG		ADC_REG(ADC_SLOT_NUM_OFFSET)
-#define ADC_SLOT_PERIOD_REG		ADC_REG(ADC_SLOT_PERIOD_OFFSET)
-#define ADC_CTRL_INTR_TABLE_REG		ADC_REG(ADC_CTRL_INTR_TABLE_OFFSET)
-#define ADC_DATA_INTR_TABLE_REG		ADC_REG(ADC_DATA_INTR_TABLE_OFFSET)
-#define ADC_FIFO_INTR_TABLE_REG		ADC_REG(ADC_FIFO_INTR_TABLE_OFFSET)
-#define ADC_ERR_STATUS_REG		ADC_REG(ADC_ERR_STATUS_OFFSET)
-
-#define ADC_SLOT_CTRL_0_REG		ADC_REG(ADC_SLOT_CTRL_0_OFFSET)
-#define ADC_SLOT_CTRL_1_REG		ADC_REG(ADC_SLOT_CTRL_1_OFFSET)
-#define ADC_SLOT_CTRL_2_REG		ADC_REG(ADC_SLOT_CTRL_2_OFFSET)
-#define ADC_SLOT_CTRL_3_REG		ADC_REG(ADC_SLOT_CTRL_3_OFFSET)
-#define ADC_SLOT_CTRL_4_REG		ADC_REG(ADC_SLOT_CTRL_4_OFFSET)
-#define ADC_SLOT_CTRL_5_REG		ADC_REG(ADC_SLOT_CTRL_5_OFFSET)
-#define ADC_SLOT_CTRL_6_REG		ADC_REG(ADC_SLOT_CTRL_6_OFFSET)
-#define ADC_SLOT_CTRL_7_REG		ADC_REG(ADC_SLOT_CTRL_7_OFFSET)
-
-#define ADC_FIFO_CTRL_0_REG		ADC_REG(ADC_FIFO_CTRL_0_OFFSET)
-#define ADC_FIFO_CTRL_1_REG		ADC_REG(ADC_FIFO_CTRL_1_OFFSET)
-#define ADC_FIFO_CTRL_2_REG		ADC_REG(ADC_FIFO_CTRL_2_OFFSET)
-#define ADC_FIFO_CTRL_3_REG		ADC_REG(ADC_FIFO_CTRL_3_OFFSET)
-#define ADC_FIFO_CTRL_REG		ADC_REG(ADC_FIFO_CTRL_OFFSET)
-
-#define ADC_FIFO_STATUS_0_REG		ADC_REG(ADC_FIFO_STATUS_0_OFFSET)
-#define ADC_FIFO_STATUS_1_REG		ADC_REG(ADC_FIFO_STATUS_1_OFFSET)
-#define ADC_FIFO_STATUS_2_REG		ADC_REG(ADC_FIFO_STATUS_2_OFFSET)
-#define ADC_FIFO_STATUS_3_REG		ADC_REG(ADC_FIFO_STATUS_3_OFFSET)
-
-#define ADC_EC_ADC_REG			ADC_REG(ADC_EC_ADC_OFFSET)
-#define ADC_EC_REFVAL_REG		ADC_REG(ADC_EC_REFVAL_OFFSET)
-#define ADC_EC_RESHAPE_REG		ADC_REG(ADC_EC_RESHAPE_OFFSET)
-
-#define ADC_FIFO_DATA0_REG		ADC_REG(ADC_FIFO_DATA0_OFFSET)
-#define ADC_FIFO_DATA1_REG		ADC_REG(ADC_FIFO_DATA1_OFFSET)
-#define ADC_FIFO_DATA2_REG		ADC_REG(ADC_FIFO_DATA2_OFFSET)
-#define ADC_FIFO_DATA3_REG		ADC_REG(ADC_FIFO_DATA3_OFFSET)
-
-#define ADC_DATA10_REG			ADC_REG(ADC_DATA10_OFFSET)
-#define ADC_DATA11_REG			ADC_REG(ADC_DATA11_OFFSET)
-#define ADC_CHAN10_INTR_REG		ADC_REG(ADC_CHAN10_INTR_OFFSET)
-#define ADC_CHAN11_INTR_REG		ADC_REG(ADC_CHAN11_INTR_OFFSET)
-
-#if (CHIP_REV == A7L)
-#error "ADC_DATA_REG/ADC_CHAN_INTR_REG(ch) Not Implemented"
-#else
-#define ADC_DATA_OFFSET(ch)		(ADC_DATA0_OFFSET + (ch) * 4)
-#define ADC_DATA_REG(ch)		ADC_REG(ADC_DATA_OFFSET(ch))
-#define ADC_FIFO_CTRL_X_OFFSET(fifoNo)	(ADC_FIFO_CTRL_0_OFFSET + (fifoNo) * 4)
-#define ADC_FIFO_CTRL_X_REG(fifoNo)	ADC_REG(ADC_FIFO_CTRL_X_OFFSET(fifoNo))
-#define ADC_CHAN_INTR_OFFSET(ch)	(ADC_CHAN0_INTR_OFFSET + (ch) * 4)
-#define ADC_CHAN_INTR_REG(ch)		ADC_REG(ADC_CHAN_INTR_OFFSET(ch))
-#endif
-
-#define ADC16_CTRL_OFFSET		0x198
-#define ADC16_CTRL_REG			RCT_REG(ADC16_CTRL_OFFSET)
-
-/* ADC_CONTROL_REG */
-#define ADC_CONTROL_GYRO_SAMPLE_MODE	0x08
-
-/* valid only for S2/S2E/S2L/S3/S3L */
-#define ADC_CONTROL_RESET		0x01
-#define ADC_FIFO_OVER_INT_EN		(0x1 << 31)
-#define ADC_FIFO_UNDR_INT_EN		(0x1 << 30)
-#define ADC_FIFO_DEPTH			0x80
-#define ADC_FIFO_TH			(((ADC_FIFO_DEPTH >> 2)-1) << 16)
-#define ADC_FIFO_CLEAR			0x1
-#define ADC_FIFO_ID_SHIFT		12
-#define ADC_FIFO_CONTROL_CLEAR		0x01
-#define ADC_FIFO_NUMBER		        0x04
-
-#define ADC_CTRL_SCALER_POWERDOWN	0x100
-#define ADC_CTRL_POWERDOWN		0x2
-#define ADC_CTRL_CLK_SOURCE_SCALER	0x0
-#define ADC_CTRL_CLK_SOURCE_AUDIO	0x1
-
-#if (CHIP_REV == A5S)
-#define ADC_CONTROL_MODE		0x04
-#define ADC_CONTROL_ENABLE		0x01
-#define ADC_CONTROL_START		0x02
-#else
-#define ADC_CONTROL_MODE		0x02
-#define ADC_CONTROL_ENABLE		0x04
-#define ADC_CONTROL_START		0x08
-#endif
-#define ADC_CONTROL_STATUS		0x01
-
-#if (CHIP_REV == A5S)
-#define ADC_EN_HI(x)			((x) << 31)
-#define ADC_EN_LO(x)			((x) << 30)
-#else
-#define ADC_EN_HI(x)			((x) << 31)
-#define ADC_EN_LO(x)			((x) << 31)
-#endif
-
-#define ADC_VAL_HI(x)			(((x) & 0xfff) << 16)
-#define ADC_VAL_LO(x)			((x) & 0xfff)
-/* ==========================================================================*/
-
-#define ADC_MAX_SLOT_NUMBER		8
-
-#define ADC_CH0				(1 << 0)
-#define ADC_CH1				(1 << 1)
-#define ADC_CH2				(1 << 2)
-#define ADC_CH3				(1 << 3)
-#define ADC_CH4				(1 << 4)
-#define ADC_CH5				(1 << 5)
-#define ADC_CH6				(1 << 6)
-#define ADC_CH7				(1 << 7)
-#define ADC_CH8				(1 << 8)
-#define ADC_CH9				(1 << 9)
-#define ADC_CH10			(1 << 10)
-#define ADC_CH11			(1 << 11)
-
-/* ==========================================================================*/
-#ifndef __ASM__
-
-#endif
-/* ==========================================================================*/
-
-#endif
-
+/*
+ * ambhw/adc.h
+ *
+ * History:
+ *	2006/12/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBHW__ADC__
+#define __AMBHW__ADC__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+#if (CHIP_REV == S3) || (CHIP_REV == S5)
+#define ADC_NUM_CHANNELS		5
+#elif (CHIP_REV == CV1)
+#define ADC_NUM_CHANNELS		3
+#else
+#define ADC_NUM_CHANNELS		4
+#endif
+
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L) || \
+	(CHIP_REV == S5) || (CHIP_REV == S5L)
+#define ADC_OFFSET			0x1D000
+#else
+#define ADC_OFFSET			0x3000
+#endif
+
+#define ADC_BASE			(APB_N_BASE + ADC_OFFSET)
+#define ADC_REG(x)			(ADC_BASE + (x))
+
+/* ==========================================================================*/
+
+#if (CHIP_REV == S5)
+#define ADC_SUPPORT_T2V		1
+#define ADC_T2V_CHANNEL		4
+#define T2V_BASE_LINE_DATA	0x6F0
+#define T2V_BASE_LINE		20
+#elif (CHIP_REV == CV1)
+#define ADC_SUPPORT_T2V		1
+#define ADC_T2V_CHANNEL		2
+#define T2V_BASE_LINE_DATA	0x6F0
+#define T2V_BASE_LINE		20
+#else
+#define ADC_SUPPORT_T2V		0
+#endif
+
+#if (CHIP_REV == S3)
+#define ADC_PERIOD_CYCLE		5
+#elif (CHIP_REV == S2L) || (CHIP_REV == S3L)
+#define ADC_PERIOD_CYCLE		6
+#else
+#define ADC_PERIOD_CYCLE		20
+#endif
+
+#define ADC_MAX_CLOCK			12000000
+#define ADC_MAX_FIFO_DEPTH		1024
+
+/* ==========================================================================*/
+#define ADC_STATUS_OFFSET		0x000
+#define ADC_CONTROL_OFFSET		0x004
+#define ADC_COUNTER_OFFSET		0x008
+#define ADC_SLOT_NUM_OFFSET		0x00c
+#define ADC_SLOT_PERIOD_OFFSET		0x010
+#define ADC_CTRL_INTR_TABLE_OFFSET	0x044
+#define ADC_DATA_INTR_TABLE_OFFSET	0x048
+#define ADC_FIFO_INTR_TABLE_OFFSET	0x04c
+#define ADC_ERR_STATUS_OFFSET		0x050
+
+#define ADC_SLOT_CTRL_0_OFFSET		0x100
+#define ADC_SLOT_CTRL_1_OFFSET		0x104
+#define ADC_SLOT_CTRL_2_OFFSET		0x108
+#define ADC_SLOT_CTRL_3_OFFSET		0x10c
+#define ADC_SLOT_CTRL_4_OFFSET		0x110
+#define ADC_SLOT_CTRL_5_OFFSET		0x114
+#define ADC_SLOT_CTRL_6_OFFSET		0x118
+#define ADC_SLOT_CTRL_7_OFFSET		0x11c
+
+#define ADC_CHAN0_INTR_OFFSET		0x120
+#define ADC_CHAN1_INTR_OFFSET		0x124
+#define ADC_CHAN2_INTR_OFFSET		0x128
+#define ADC_CHAN3_INTR_OFFSET		0x12c
+/* if ADC_NUM_CHANNELS > 4 */
+#define ADC_CHAN4_INTR_OFFSET		0x130
+#define ADC_CHAN5_INTR_OFFSET		0x134
+#define ADC_CHAN6_INTR_OFFSET		0x138
+#define ADC_CHAN7_INTR_OFFSET		0x13c
+/* if ADC_NUM_CHANNELS > 8 */
+#define ADC_CHAN8_INTR_OFFSET		0x140
+#define ADC_CHAN9_INTR_OFFSET		0x144
+#define ADC_CHAN10_INTR_OFFSET		0x148
+#define ADC_CHAN11_INTR_OFFSET		0x14c
+
+#define ADC_DATA0_OFFSET		0x150
+#define ADC_DATA1_OFFSET		0x154
+#define ADC_DATA2_OFFSET		0x158
+#define ADC_DATA3_OFFSET		0x15c
+/* if ADC_NUM_CHANNELS > 4 */
+#define ADC_DATA4_OFFSET		0x160
+#define ADC_DATA5_OFFSET		0x164
+#define ADC_DATA6_OFFSET		0x168
+#define ADC_DATA7_OFFSET		0x16c
+/* if ADC_NUM_CHANNELS > 8 */
+#define ADC_DATA8_OFFSET		0x170
+#define ADC_DATA9_OFFSET		0x174
+#define ADC_DATA10_OFFSET		0x178
+#define ADC_DATA11_OFFSET		0x17c
+
+#define ADC_FIFO_CTRL_0_OFFSET		0x180
+#define ADC_FIFO_CTRL_1_OFFSET		0x184
+#define ADC_FIFO_CTRL_2_OFFSET		0x188
+#define ADC_FIFO_CTRL_3_OFFSET		0x18C
+#define ADC_FIFO_CTRL_OFFSET		0x190
+
+#define ADC_FIFO_STATUS_0_OFFSET	0x1a0
+#define ADC_FIFO_STATUS_1_OFFSET	0x1a4
+#define ADC_FIFO_STATUS_2_OFFSET	0x1a8
+#define ADC_FIFO_STATUS_3_OFFSET	0x1ac
+
+#define ADC_EC_CONTROL_OFFSET		0x1B0
+#define ADC_EC_COUNTER_OFFSET		0x1B4
+#define ADC_EC_COUNTER_TH_OFFSET	0x1B8
+#define ADC_EC_PARAM_OFFSET		0x1BC
+
+#define ADC_EC_ADC_OFFSET		0x1C0
+#define ADC_EC_REFVAL_OFFSET		0x1C4
+#define ADC_EC_RESHAPE_OFFSET		0x1C8
+
+#define ADC_FIFO_DATA0_OFFSET		0x200
+#define ADC_FIFO_DATA1_OFFSET		0x280
+#define ADC_FIFO_DATA2_OFFSET		0x300
+#define ADC_FIFO_DATA3_OFFSET		0x380
+
+#define ADC_STATUS_REG			ADC_REG(ADC_STATUS_OFFSET)
+#define ADC_CONTROL_REG			ADC_REG(ADC_CONTROL_OFFSET)
+#define ADC_COUNTER_REG			ADC_REG(ADC_COUNTER_OFFSET)
+#define ADC_SLOT_NUM_REG		ADC_REG(ADC_SLOT_NUM_OFFSET)
+#define ADC_SLOT_PERIOD_REG		ADC_REG(ADC_SLOT_PERIOD_OFFSET)
+#define ADC_CTRL_INTR_TABLE_REG		ADC_REG(ADC_CTRL_INTR_TABLE_OFFSET)
+#define ADC_DATA_INTR_TABLE_REG		ADC_REG(ADC_DATA_INTR_TABLE_OFFSET)
+#define ADC_FIFO_INTR_TABLE_REG		ADC_REG(ADC_FIFO_INTR_TABLE_OFFSET)
+#define ADC_ERR_STATUS_REG		ADC_REG(ADC_ERR_STATUS_OFFSET)
+
+#define ADC_SLOT_CTRL_0_REG		ADC_REG(ADC_SLOT_CTRL_0_OFFSET)
+#define ADC_SLOT_CTRL_1_REG		ADC_REG(ADC_SLOT_CTRL_1_OFFSET)
+#define ADC_SLOT_CTRL_2_REG		ADC_REG(ADC_SLOT_CTRL_2_OFFSET)
+#define ADC_SLOT_CTRL_3_REG		ADC_REG(ADC_SLOT_CTRL_3_OFFSET)
+#define ADC_SLOT_CTRL_4_REG		ADC_REG(ADC_SLOT_CTRL_4_OFFSET)
+#define ADC_SLOT_CTRL_5_REG		ADC_REG(ADC_SLOT_CTRL_5_OFFSET)
+#define ADC_SLOT_CTRL_6_REG		ADC_REG(ADC_SLOT_CTRL_6_OFFSET)
+#define ADC_SLOT_CTRL_7_REG		ADC_REG(ADC_SLOT_CTRL_7_OFFSET)
+
+#define ADC_CHAN0_INTR_REG		ADC_REG(ADC_CHAN0_INTR_OFFSET)
+#define ADC_CHAN1_INTR_REG		ADC_REG(ADC_CHAN1_INTR_OFFSET)
+#define ADC_CHAN2_INTR_REG		ADC_REG(ADC_CHAN2_INTR_OFFSET)
+#define ADC_CHAN3_INTR_REG		ADC_REG(ADC_CHAN3_INTR_OFFSET)
+#define ADC_CHAN4_INTR_REG		ADC_REG(ADC_CHAN4_INTR_OFFSET)
+#define ADC_CHAN5_INTR_REG		ADC_REG(ADC_CHAN5_INTR_OFFSET)
+#define ADC_CHAN6_INTR_REG		ADC_REG(ADC_CHAN6_INTR_OFFSET)
+#define ADC_CHAN7_INTR_REG		ADC_REG(ADC_CHAN7_INTR_OFFSET)
+#define ADC_CHAN8_INTR_REG		ADC_REG(ADC_CHAN8_INTR_OFFSET)
+#define ADC_CHAN9_INTR_REG		ADC_REG(ADC_CHAN9_INTR_OFFSET)
+#define ADC_CHAN10_INTR_REG		ADC_REG(ADC_CHAN10_INTR_OFFSET)
+#define ADC_CHAN11_INTR_REG		ADC_REG(ADC_CHAN11_INTR_OFFSET)
+
+#define ADC_DATA0_REG			ADC_REG(ADC_DATA0_OFFSET)
+#define ADC_DATA1_REG			ADC_REG(ADC_DATA1_OFFSET)
+#define ADC_DATA2_REG			ADC_REG(ADC_DATA2_OFFSET)
+#define ADC_DATA3_REG			ADC_REG(ADC_DATA3_OFFSET)
+#define ADC_DATA4_REG			ADC_REG(ADC_DATA4_OFFSET)
+#define ADC_DATA5_REG			ADC_REG(ADC_DATA5_OFFSET)
+#define ADC_DATA6_REG			ADC_REG(ADC_DATA6_OFFSET)
+#define ADC_DATA7_REG			ADC_REG(ADC_DATA7_OFFSET)
+#define ADC_DATA8_REG			ADC_REG(ADC_DATA8_OFFSET)
+#define ADC_DATA9_REG			ADC_REG(ADC_DATA9_OFFSET)
+#define ADC_DATA10_REG			ADC_REG(ADC_DATA10_OFFSET)
+#define ADC_DATA11_REG			ADC_REG(ADC_DATA11_OFFSET)
+
+#define ADC_FIFO_CTRL_0_REG		ADC_REG(ADC_FIFO_CTRL_0_OFFSET)
+#define ADC_FIFO_CTRL_1_REG		ADC_REG(ADC_FIFO_CTRL_1_OFFSET)
+#define ADC_FIFO_CTRL_2_REG		ADC_REG(ADC_FIFO_CTRL_2_OFFSET)
+#define ADC_FIFO_CTRL_3_REG		ADC_REG(ADC_FIFO_CTRL_3_OFFSET)
+#define ADC_FIFO_CTRL_REG		ADC_REG(ADC_FIFO_CTRL_OFFSET)
+
+#define ADC_FIFO_STATUS_0_REG		ADC_REG(ADC_FIFO_STATUS_0_OFFSET)
+#define ADC_FIFO_STATUS_1_REG		ADC_REG(ADC_FIFO_STATUS_1_OFFSET)
+#define ADC_FIFO_STATUS_2_REG		ADC_REG(ADC_FIFO_STATUS_2_OFFSET)
+#define ADC_FIFO_STATUS_3_REG		ADC_REG(ADC_FIFO_STATUS_3_OFFSET)
+
+#define ADC_EC_CONTROL_REG		ADC_REG(ADC_EC_CONTROL_OFFSET)
+#define ADC_EC_CONTROL_REG		ADC_REG(ADC_EC_CONTROL_OFFSET)
+#define ADC_EC_COUNTER_TH_REG		ADC_REG(ADC_EC_COUNTER_TH_OFFSET)
+#define ADC_EC_PARAM_REG		ADC_REG(ADC_EC_PARAM_OFFSET)
+
+#define ADC_EC_ADC_REG			ADC_REG(ADC_EC_ADC_OFFSET)
+#define ADC_EC_REFVAL_REG		ADC_REG(ADC_EC_REFVAL_OFFSET)
+#define ADC_EC_RESHAPE_REG		ADC_REG(ADC_EC_RESHAPE_OFFSET)
+
+#define ADC_FIFO_DATA0_REG		ADC_REG(ADC_FIFO_DATA0_OFFSET)
+#define ADC_FIFO_DATA1_REG		ADC_REG(ADC_FIFO_DATA1_OFFSET)
+#define ADC_FIFO_DATA2_REG		ADC_REG(ADC_FIFO_DATA2_OFFSET)
+#define ADC_FIFO_DATA3_REG		ADC_REG(ADC_FIFO_DATA3_OFFSET)
+
+#define ADC_SLOT_CTRL_X_OFFSET(n)	(ADC_SLOT_CTRL_0_OFFSET + (n) * 4)
+#define ADC_SLOT_CTRL_X_REG(n)		ADC_REG(ADC_SLOT_CTRL_X_OFFSET(n))
+
+#define ADC_INT_CTRL_X_OFFSET(n)	(ADC_CHAN0_INTR_OFFSET + (n) * 4)
+#define ADC_INT_CTRL_X_REG(n)		ADC_REG(ADC_INT_CTRL_X_OFFSET(n))
+
+#define ADC_DATA_X_OFFSET(n)		(ADC_DATA0_OFFSET + (n) * 4)
+#define ADC_DATA_X_REG(n)		ADC_REG(ADC_DATA_X_OFFSET(n))
+
+#define ADC_FIFO_CTRL_X_OFFSET(n)	(ADC_FIFO_CTRL_0_OFFSET + (n) * 4)
+#define ADC_FIFO_CTRL_X_REG(n)		ADC_REG(ADC_FIFO_CTRL_X_OFFSET(n))
+
+#define ADC_FIFO_STATUS_X_OFFSET(n)	(ADC_FIFO_STATUS_0_OFFSET + (n) * 4)
+#define ADC_FIFO_STATUS_X_REG(n)	ADC_REG(ADC_FIFO_STATUS_X_OFFSET(n))
+
+#define ADC_FIFO_DATA_X_OFFSET(n)	(ADC_FIFO_DATA0_OFFSET + (n) * 0x80)
+#define ADC_FIFO_DATA_X_REG(n)		ADC_REG(ADC_FIFO_DATA_X_OFFSET(n))
+
+
+/* ==========================================================================*/
+
+#define ADC_STATUS_STATUS		0x01
+
+#define ADC_CONTROL_CLEAR		0x01
+#define ADC_CONTROL_MODE		0x02
+#define ADC_CONTROL_ENABLE		0x04
+#define ADC_CONTROL_START		0x08
+
+#define ADC_FIFO_OVER_INT_EN		(0x1 << 31)
+#define ADC_FIFO_UNDR_INT_EN		(0x1 << 30)
+#define ADC_FIFO_DEPTH			0x80
+#define ADC_FIFO_TH(n)			((n) << 16)
+#define ADC_FIFO_CLEAR			0x1
+#define ADC_FIFO_ID(n)			((n) << 12)
+#define ADC_FIFO_NUMBER		        0x04
+
+#define ADC_INT_THRESHOLD_EN		(1 << 31)
+#define ADC_VAL_HI(x)			(((x) & 0xfff) << 16)
+#define ADC_VAL_LO(x)			((x) & 0xfff)
+
+/* ==========================================================================*/
+
+#ifndef __ASM__
+
+#endif
+/* ==========================================================================*/
+
+#endif
+
diff --git a/include/ambhw/cache.h b/include/ambhw/cache.h
index 937334c..d89e20d 100644
--- a/include/ambhw/cache.h
+++ b/include/ambhw/cache.h
@@ -3,21 +3,36 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __AMBHW__CACHE_H__
 #define __AMBHW__CACHE_H__
 
 /*===========================================================================*/
-#define ENABLE_DRAIN_WRITE_BUF
-
-/*===========================================================================*/
 #define CLINE	5			/* 32 byte cache line size */
 #define NWAY	2			/* 4 way cache */
 #define I7SET	5
@@ -45,6 +60,9 @@ extern void _clean_d_cache(void);
 extern void _clean_flush_d_cache(void);
 extern void _clean_flush_all_cache(void);
 extern void _drain_write_buffer(void);
+extern void _clean_d_cache_range(void *addr, unsigned int size);
+extern void _flush_d_cache_range(void *addr, unsigned int size);
+extern void _clean_flush_d_cache_range(void *addr, unsigned int size);
 extern void flush_all_cache_region(void *addr, unsigned int size);
 extern void clean_flush_all_cache_region(void *addr, unsigned int size);
 extern void flush_i_cache_region(void *addr, unsigned int size);
diff --git a/include/ambhw/chip.h b/include/ambhw/chip.h
index 7dc71bb..dfc20ca 100644
--- a/include/ambhw/chip.h
+++ b/include/ambhw/chip.h
@@ -1,71 +1,80 @@
-/**
- * ambhw/chip.h
- *
- * History:
- *	2007/11/29 - [Charles Chiou] created file
- *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+/**
+ * ambhw/chip.h
+ *
+ * History:
+ *	2007/11/29 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
-
-#ifndef __AMBHW__CHIP_H__
-#define __AMBHW__CHIP_H__
-
-/* ==========================================================================*/
-#define A5S		(5100)
-#define A7L		(7500)
-#define A8		(8000)
-#define S2		(9000)
-#define S2E		(9100)
-#define S2L		(12000)
-#define S3		(11000)
-#define S3L		(13000)
-
-#define CHIP_ID(x)	((x / 1000))
-#define CHIP_MAJOR(x)	((x / 100) % 10)
-#define CHIP_MINOR(x)	((x / 10) % 10)
-
-#if defined(CONFIG_ARCH_A5S)
-#define CHIP_REV	A5S
-#elif defined(CONFIG_ARCH_A7L)
-#define CHIP_REV	A7L
-#elif defined(CONFIG_ARCH_S2)
-#define CHIP_REV	S2
-#elif defined(CONFIG_ARCH_S2E)
-#define CHIP_REV	S2E
-#elif defined(CONFIG_ARCH_A8)
-#define CHIP_REV	A8
-#elif defined(CONFIG_ARCH_S2L)
-#define CHIP_REV	S2L
-#elif defined(CONFIG_ARCH_S3)
-#define CHIP_REV	S3
-#elif defined(CONFIG_ARCH_S3L)
-#define CHIP_REV	S3L
-#else
-#error "Undefined CHIP_REV"
-#endif
-
-/* ==========================================================================*/
-#if (CHIP_REV == A8)
-#define REF_CLK_FREQ			27000000
-#else
-#define REF_CLK_FREQ			24000000
-#endif
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S) || (CHIP_REV == A7L)
-#define	CHIP_BROKEN_UNALIGNED_ACCESS	1
-#endif
-
-#if (CHIP_REV == S3)
-#define	CHIP_FIX_2NDCORTEX_BOOT	1
-#endif
-
-/* ==========================================================================*/
-
-#endif
-
+
+#ifndef __AMBHW__CHIP_H__
+#define __AMBHW__CHIP_H__
+
+#include <config.h>
+
+/* ==========================================================================*/
+#define S2L		(12000)
+#define S3		(11000)
+#define S3L		(13000)
+#define S5		(15000)
+#define S5L		(16000)
+#define CV1		(20000)
+
+#define CHIP_ID(x)	((x / 1000))
+#define CHIP_MAJOR(x)	((x / 100) % 10)
+#define CHIP_MINOR(x)	((x / 10) % 10)
+
+#if defined(CONFIG_ARCH_S2L)
+#define CHIP_REV	S2L
+#elif defined(CONFIG_ARCH_S3)
+#define CHIP_REV	S3
+#elif defined(CONFIG_ARCH_S3L)
+#define CHIP_REV	S3L
+#elif defined(CONFIG_ARCH_S5)
+#define CHIP_REV	S5
+#elif defined(CONFIG_ARCH_H2)
+#define CHIP_REV	S5
+#elif defined(CONFIG_ARCH_S5L)
+#define CHIP_REV	S5L
+#elif defined(CONFIG_ARCH_CV1)
+#define CHIP_REV	CV1
+#else
+#error "Undefined CHIP_REV"
+#endif
+
+/* ==========================================================================*/
+#define REF_CLK_FREQ			24000000
+
+/* ==========================================================================*/
+
+#if (CHIP_REV == S3)
+#define	CHIP_FIX_2NDCORTEX_BOOT	1
+#endif
+
+/* ==========================================================================*/
+
+#endif
+
diff --git a/include/ambhw/cortex.h b/include/ambhw/cortex.h
index b6063ed..9ff397b 100644
--- a/include/ambhw/cortex.h
+++ b/include/ambhw/cortex.h
@@ -3,27 +3,64 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __AMBHW__CORTEX_H__
 #define __AMBHW__CORTEX_H__
 
 /*===========================================================================*/
-#define CORTEX_BST_MAGIC			(0xffaa5500)
-#define CORTEX_BST_INVALID			(0xdeadbeaf)
-#define CORTEX_BST_START_COUNTER		(0xffffffff)
-#define CORTEX_BST_WAIT_LIMIT			(0x00010000)
-#define AXI_CORTEX_RESET(x)			((x) << 5)
-#define AXI_CORTEX_CLOCK(x)			((x) << 8)
+#define CORTEX_BST_MAGIC		(0xffaa5500)
+#define CORTEX_BST_INVALID		(0xdeadbeaf)
+#define CORTEX_BST_START_COUNTER	(0xffffffff)
+#define CORTEX_BST_WAIT_LIMIT		(0x00010000)
+#define AXI_CORTEX_RESET(x)		((x) << 5)
+#define AXI_CORTEX_CLOCK(x)		((x) << 8)
+
+#define CORTEX_BOOT_ADDRESS		(0x00000000)
+#define CORTEX_BOOT_STRAP_ALIGN		(32)
+
+#if (CHIP_REV == S2L) || (CHIP_REV == S3L)
+#define AXI_CFG_OFFSET			0x1000
+#elif (CHIP_REV == S3) || (CHIP_REV == S5) || (CHIP_REV == S5L)
+#define AXI_CFG_OFFSET			0x10000
+#else
+#define AXI_CFG_OFFSET			0x0000
+#endif
+#define AXI_CFG_BASE			(AXI_BASE + AXI_CFG_OFFSET)
 
-#define CORTEX_BOOT_ADDRESS			(0x00000000)
-#define CORTEX_BOOT_STRAP_ALIGN			(32)
+#define CORTEX_RESET_REG		(AXI_CFG_BASE + 0x28)
+#define	AXI_SYS_TIME_CTRL		(AXI_CFG_BASE + 0x14)
+
+
+#if (CHIP_REV == S5)
+#define AXI_SYS_TIMER_DIVISOR		128
+#else
+#define AXI_SYS_TIMER_DIVISOR		16
+#endif
 
 /* ==========================================================================*/
 #ifndef __ASM__
@@ -34,7 +71,7 @@ extern int bld_cortex_boot(int verbose, u32 jump_addr);
 
 /* used for ARM11 boot Cortex */
 extern u32 cortex_processor_start[];
-extern u32 cortex_atag_data[];
+extern u32 cortex_boot_data[];
 extern u32 cortex_machine_id[];
 extern u32 cortex_processor0_r0[];
 extern u32 cortex_processor_status[];
@@ -43,7 +80,11 @@ extern void cortex_bst_head();
 extern void cortex_bst_end();
 
 /* used for Cortex boot Cortex */
+#if defined(__aarch64__)
+extern u64 secondary_cortex_jump[];
+#else
 extern u32 secondary_cortex_jump[];
+#endif
 extern int bld_boot_secondary_cortex(void);
 
 extern int amboot_bsp_cortex_init_pre(void)
diff --git a/include/ambhw/dma.h b/include/ambhw/dma.h
index e426577..92922fa 100644
--- a/include/ambhw/dma.h
+++ b/include/ambhw/dma.h
@@ -1,220 +1,170 @@
-/*
- * ambhw/dma.h
- *
- * History:
- *	2006/12/27 - [Charles Chiou] created file
- *
- * Copyright (C) 2006-2008, Ambarella, Inc.
- */
-
-#ifndef __AMBHW__DMA_H__
-#define __AMBHW__DMA_H__
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S) || (CHIP_REV == A7L)
-#define NUM_DMA_CHANNELS 		4
-#elif (CHIP_REV == S2)
-#define NUM_DMA_CHANNELS 		5
-#else
-#define NUM_DMA_CHANNELS 		8
-#endif
-
-#define DMA_OFFSET			0x5000
-#define DMA_BASE			(AHB_BASE + DMA_OFFSET)
-#define DMA_REG(x)			(DMA_BASE + (x))
-
-#define FDMA_OFFSET			0x12000
-#define FDMA_BASE			(AHB_BASE + FDMA_OFFSET)
-#define FDMA_REG(x)			(FDMA_BASE + (x))
-
-/* ==========================================================================*/
-
-#define INVALID_DMA_CHAN		0xFF
-
-#if (CHIP_REV == S2L)
-#define NOR_SPI_TX_DMA_CHAN		0 /* share with SSI0 */
-#define NOR_SPI_RX_DMA_CHAN		1 /* share with SSI0 */
-#define SSI1_TX_DMA_CHAN		2
-#define SSI1_RX_DMA_CHAN		3
-#define UART_TX_DMA_CHAN		4 /* share with SSIS0 */
-#define UART_RX_DMA_CHAN		5 /* share with SSIS0 */
-#define I2S_RX_DMA_CHAN			6
-#define I2S_TX_DMA_CHAN			7
-/* non-existed dma channel */
-#define MS_AHB_SSI_TX_DMA_CHAN		INVALID_DMA_CHAN
-#define SPDIF_AHB_SSI_DMA_CHAN		INVALID_DMA_CHAN
-#define SLIM_TX_DMA_CHAN		INVALID_DMA_CHAN
-#define SLIM_RX_DMA_CHAN		INVALID_DMA_CHAN
-
-#elif (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define NOR_SPI_TX_DMA_CHAN		0
-#define NOR_SPI_RX_DMA_CHAN		1
-#define SSI1_TX_DMA_CHAN		2
-#define SSI1_RX_DMA_CHAN		3
-#define UART_TX_DMA_CHAN		4
-#define UART_RX_DMA_CHAN		5
-#define I2S_RX_DMA_CHAN			6
-#define I2S_TX_DMA_CHAN			7
-
-#elif (CHIP_REV == S2E)
-#define NOR_SPI_TX_DMA_CHAN		0
-#define I2S_RX_DMA_CHAN			1
-#define I2S_TX_DMA_CHAN			2
-#define I2S1_RX_DMA_CHAN		3
-#define I2S1_TX_DMA_CHAN		4
-#define UART_RX_DMA_CHAN		5
-#define UART_TX_DMA_CHAN		6
-#define NOR_SPI_RX_DMA_CHAN		7
-/* non-existed dma channel */
-#define SSI1_TX_DMA_CHAN		INVALID_DMA_CHAN
-#define SSI1_RX_DMA_CHAN		INVALID_DMA_CHAN
-
-#else
-#define I2S_RX_DMA_CHAN			1
-#define I2S_TX_DMA_CHAN			2
-#define MS_AHB_SSI_TX_DMA_CHAN		3
-#define SPDIF_AHB_SSI_DMA_CHAN		4
-/* non-existed dma channel */
-#define NOR_SPI_TX_DMA_CHAN		INVALID_DMA_CHAN
-#define NOR_SPI_RX_DMA_CHAN		INVALID_DMA_CHAN
-#define SSI1_TX_DMA_CHAN		INVALID_DMA_CHAN
-#define SSI1_RX_DMA_CHAN		INVALID_DMA_CHAN
-#define UART_TX_DMA_CHAN		INVALID_DMA_CHAN
-#define UART_RX_DMA_CHAN		INVALID_DMA_CHAN
-#define SLIM_TX_DMA_CHAN		INVALID_DMA_CHAN
-#define SLIM_RX_DMA_CHAN		INVALID_DMA_CHAN
-
-#endif
-
-/* ==========================================================================*/
-#define DMA_CHAN_CTR_REG(x)		DMA_REG((0x300 + ((x) << 4)))
-#define DMA_CHAN_SRC_REG(x)		DMA_REG((0x304 + ((x) << 4)))
-#define DMA_CHAN_DST_REG(x)		DMA_REG((0x308 + ((x) << 4)))
-#define DMA_CHAN_STA_REG(x)		DMA_REG((0x30c + ((x) << 4)))
-#define DMA_CHAN_DA_REG(x)		DMA_REG((0x380 + ((x) << 2)))
-
-/* ==========================================================================*/
-
-#define FDMA_CHAN_CTR_REG(x)		FDMA_REG((0x300 + ((x) << 4)))
-#define FDMA_CHAN_SRC_REG(x)		FDMA_REG((0x304 + ((x) << 4)))
-#define FDMA_CHAN_DST_REG(x)		FDMA_REG((0x308 + ((x) << 4)))
-#define FDMA_CHAN_STA_REG(x)		FDMA_REG((0x30c + ((x) << 4)))
-#define FDMA_CHAN_DA_REG(x)		FDMA_REG((0x380 + ((x) << 2)))
-#define FDMA_CHAN_DSM_CTR_REG(x)	FDMA_REG((0x3a0 + ((x) << 4)))
-
-#define FDMA_CHAN_SPR_CNT_REG(x)	FDMA_REG((0x200 + ((x) << 4)))
-#define FDMA_CHAN_SPR_SRC_REG(x)	FDMA_REG((0x204 + ((x) << 4)))
-#define FDMA_CHAN_SPR_DST_REG(x)	FDMA_REG((0x208 + ((x) << 4)))
-#define FDMA_CHAN_SPR_STA_REG(x)	FDMA_REG((0x20c + ((x) << 4)))
-#define FDMA_CHAN_SPR_DA_REG(x)		FDMA_REG((0x280 + ((x) << 2)))
-
-/* ==========================================================================*/
-
-#define DMA_INT_OFFSET			0x3f0
-#define DMA_PAUSE_SET_OFFSET		0x3f4
-#define DMA_PAUSE_CLR_OFFSET		0x3f8
-#define DMA_EARLY_END_OFFSET		0x3fc
-
-/* ==========================================================================*/
-
-/* DMA_CHANX_CTR_REG */
-#define DMA_CHANX_CTR_EN		0x80000000
-#define DMA_CHANX_CTR_D			0x40000000
-#define DMA_CHANX_CTR_WM		0x20000000
-#define DMA_CHANX_CTR_RM		0x10000000
-#define DMA_CHANX_CTR_NI		0x08000000
-#define DMA_CHANX_CTR_BLK_1024B		0x07000000
-#define DMA_CHANX_CTR_BLK_512B		0x06000000
-#define DMA_CHANX_CTR_BLK_256B		0x05000000
-#define DMA_CHANX_CTR_BLK_128B		0x04000000
-#define DMA_CHANX_CTR_BLK_64B		0x03000000
-#define DMA_CHANX_CTR_BLK_32B		0x02000000
-#define DMA_CHANX_CTR_BLK_16B		0x01000000
-#define DMA_CHANX_CTR_BLK_8B		0x00000000
-#define DMA_CHANX_CTR_TS_8B		0x00C00000
-#define DMA_CHANX_CTR_TS_4B		0x00800000
-#define DMA_CHANX_CTR_TS_2B		0x00400000
-#define DMA_CHANX_CTR_TS_1B		0x00000000
-
-/* DMA descriptor bit fields */
-#define DMA_DESC_EOC			0x01000000
-#define DMA_DESC_WM			0x00800000
-#define DMA_DESC_RM			0x00400000
-#define DMA_DESC_NI			0x00200000
-#define DMA_DESC_TS_8B			0x00180000
-#define DMA_DESC_TS_4B			0x00100000
-#define DMA_DESC_TS_2B			0x00080000
-#define DMA_DESC_TS_1B			0x00000000
-#define DMA_DESC_BLK_1024B		0x00070000
-#define DMA_DESC_BLK_512B		0x00060000
-#define DMA_DESC_BLK_256B		0x00050000
-#define DMA_DESC_BLK_128B		0x00040000
-#define DMA_DESC_BLK_64B		0x00030000
-#define DMA_DESC_BLK_32B		0x00020000
-#define DMA_DESC_BLK_16B		0x00010000
-#define DMA_DESC_BLK_8B			0x00000000
-#define DMA_DESC_ID			0x00000004
-#define DMA_DESC_IE			0x00000002
-#define DMA_DESC_ST			0x00000001
-
-/* DMA_CHANX_STA_REG */
-#define DMA_CHANX_STA_DM		0x80000000
-#define DMA_CHANX_STA_OE		0x40000000
-#define DMA_CHANX_STA_DA		0x20000000
-#define DMA_CHANX_STA_DD		0x10000000
-#define DMA_CHANX_STA_OD		0x08000000
-#define DMA_CHANX_STA_ME		0x04000000
-#define DMA_CHANX_STA_BE		0x02000000
-#define DMA_CHANX_STA_RWE		0x01000000
-#define DMA_CHANX_STA_AE		0x00800000
-#define DMA_CHANX_STA_DN		0x00400000
-
-/* DMA_INT_REG */
-#define DMA_INT_CHAN(x)			(0x1 << (x))
-
-#define DMA_INT_CHAN4			0x00000010
-#define DMA_INT_CHAN3			0x00000008
-#define DMA_INT_CHAN2			0x00000004
-#define DMA_INT_CHAN1			0x00000002
-#define DMA_INT_CHAN0			0x00000001
-
-/* DMA_DUAL_SPACE_MODE_REG */
-#define DMA_DSM_EN                      0x80000000
-#define DMA_DSM_MAJP_2KB                0x00000090
-#define DMA_DSM_SPJP_64B                0x00000004
-#define DMA_DSM_SPJP_128B               0x00000005
-
-#if (CHIP_REV == S3) || (CHIP_REV == S2E) || (CHIP_REV == S3L)
-#define DMA_NODC_MN_BURST_SIZE	(DMA_CHANX_CTR_BLK_512B | DMA_CHANX_CTR_TS_8B)
-#define DMA_NODC_SP_BURST_SIZE	(DMA_CHANX_CTR_BLK_16B | DMA_CHANX_CTR_TS_8B)
-#define DMA_DESC_MN_BURST_SIZE	(DMA_DESC_BLK_512B | DMA_DESC_TS_8B)
-#define DMA_DESC_SP_BURST_SIZE	(DMA_DESC_BLK_16B | DMA_DESC_TS_8B)
-#define DMA_NODC_MN_BURST_SIZE8	(DMA_CHANX_CTR_BLK_512B | DMA_CHANX_CTR_TS_8B)
-#define FIO_MN_BURST_SIZE	(FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B)
-#define FIO_SP_BURST_SIZE	(FIO_DMACTR_BLK_16B | FIO_DMACTR_TS8B)
-#define FIO_MN_BURST_SIZE8	(FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B)
-#else
-#define DMA_NODC_MN_BURST_SIZE	(DMA_CHANX_CTR_BLK_512B | DMA_CHANX_CTR_TS_4B)
-#define DMA_NODC_SP_BURST_SIZE	(DMA_CHANX_CTR_BLK_16B | DMA_CHANX_CTR_TS_4B)
-#define DMA_DESC_MN_BURST_SIZE	(DMA_DESC_BLK_512B | DMA_DESC_TS_4B)
-#define DMA_DESC_SP_BURST_SIZE	(DMA_DESC_BLK_16B | DMA_DESC_TS_4B)
-#define DMA_NODC_MN_BURST_SIZE8	(DMA_CHANX_CTR_BLK_512B | DMA_CHANX_CTR_TS_8B)
-#define FIO_MN_BURST_SIZE	(FIO_DMACTR_BLK_512B | FIO_DMACTR_TS4B)
-#define FIO_SP_BURST_SIZE	(FIO_DMACTR_BLK_16B | FIO_DMACTR_TS4B)
-#define FIO_MN_BURST_SIZE8	(FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B)
-#endif
-
-
-struct dma_desc {
-	u32 src;
-	u32 dst;
-	u32 next_desc;
-	u32 rpt_addr;
-	u32 xfr_count;
-	u32 attr;
-	u32 rsvd;
-	u32 rpt;
-};
-
-#endif /* __AMBHW__DMA_H__ */
-
+/*
+ * ambhw/dma.h
+ *
+ * History:
+ *	2006/12/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBHW__DMA_H__
+#define __AMBHW__DMA_H__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+#if (CHIP_REV == CV1)
+#define DMA_INSTANCES			2
+#define NUM_DMA_CHANNELS 		16
+#else
+#define DMA_INSTANCES			1
+#define NUM_DMA_CHANNELS 		8
+#endif
+
+#if (CHIP_REV == CV1)
+#define DMA0_OFFSET			0xA000
+#else
+#define DMA0_OFFSET			0x5000
+#endif
+#define DMA0_BASE			(AHB_N_BASE + DMA0_OFFSET)
+#define DMA0_REG(x)			(DMA0_BASE + (x))
+
+#define DMA1_OFFSET			0xB000
+#define DMA1_BASE			(AHB_N_BASE + DMA1_OFFSET)
+#define DMA1_REG(x)			(DMA1_BASE + (x))
+
+/* ==========================================================================*/
+
+#define INVALID_DMA_CHAN		0xFF
+
+#define NOR_SPI_TX_DMA_CHAN		0
+#define NOR_SPI_RX_DMA_CHAN		1
+#define SSI1_TX_DMA_CHAN		2
+#define SSI1_RX_DMA_CHAN		3
+#define UART_TX_DMA_CHAN		4
+#define UART_RX_DMA_CHAN		5
+#define I2S_RX_DMA_CHAN			6
+#define I2S_TX_DMA_CHAN			7
+
+/* ==========================================================================*/
+#define DMA0_CHAN_CTR_REG(x)		DMA0_REG((0x300 + ((x) << 4)))
+#define DMA0_CHAN_SRC_REG(x)		DMA0_REG((0x304 + ((x) << 4)))
+#define DMA0_CHAN_DST_REG(x)		DMA0_REG((0x308 + ((x) << 4)))
+#define DMA0_CHAN_STA_REG(x)		DMA0_REG((0x30c + ((x) << 4)))
+#define DMA0_CHAN_DA_REG(x)		DMA0_REG((0x380 + ((x) << 2)))
+
+#define DMA1_CHAN_CTR_REG(x)		DMA1_REG((0x300 + ((x) << 4)))
+#define DMA1_CHAN_SRC_REG(x)		DMA1_REG((0x304 + ((x) << 4)))
+#define DMA1_CHAN_DST_REG(x)		DMA1_REG((0x308 + ((x) << 4)))
+#define DMA1_CHAN_STA_REG(x)		DMA1_REG((0x30c + ((x) << 4)))
+#define DMA1_CHAN_DA_REG(x)		DMA1_REG((0x380 + ((x) << 2)))
+
+/* ==========================================================================*/
+
+#define DMA_INT_OFFSET			0x3f0
+#define DMA_PAUSE_SET_OFFSET		0x3f4
+#define DMA_PAUSE_CLR_OFFSET		0x3f8
+#define DMA_EARLY_END_OFFSET		0x3fc
+
+/* ==========================================================================*/
+
+/* DMA_CHANX_CTR_REG */
+#define DMA_CHANX_CTR_EN		0x80000000
+#define DMA_CHANX_CTR_D			0x40000000
+#define DMA_CHANX_CTR_WM		0x20000000
+#define DMA_CHANX_CTR_RM		0x10000000
+#define DMA_CHANX_CTR_NI		0x08000000
+#define DMA_CHANX_CTR_BLK_1024B		0x07000000
+#define DMA_CHANX_CTR_BLK_512B		0x06000000
+#define DMA_CHANX_CTR_BLK_256B		0x05000000
+#define DMA_CHANX_CTR_BLK_128B		0x04000000
+#define DMA_CHANX_CTR_BLK_64B		0x03000000
+#define DMA_CHANX_CTR_BLK_32B		0x02000000
+#define DMA_CHANX_CTR_BLK_16B		0x01000000
+#define DMA_CHANX_CTR_BLK_8B		0x00000000
+#define DMA_CHANX_CTR_TS_8B		0x00C00000
+#define DMA_CHANX_CTR_TS_4B		0x00800000
+#define DMA_CHANX_CTR_TS_2B		0x00400000
+#define DMA_CHANX_CTR_TS_1B		0x00000000
+
+/* DMA descriptor bit fields */
+#define DMA_DESC_EOC			0x01000000
+#define DMA_DESC_WM			0x00800000
+#define DMA_DESC_RM			0x00400000
+#define DMA_DESC_NI			0x00200000
+#define DMA_DESC_TS_8B			0x00180000
+#define DMA_DESC_TS_4B			0x00100000
+#define DMA_DESC_TS_2B			0x00080000
+#define DMA_DESC_TS_1B			0x00000000
+#define DMA_DESC_BLK_1024B		0x00070000
+#define DMA_DESC_BLK_512B		0x00060000
+#define DMA_DESC_BLK_256B		0x00050000
+#define DMA_DESC_BLK_128B		0x00040000
+#define DMA_DESC_BLK_64B		0x00030000
+#define DMA_DESC_BLK_32B		0x00020000
+#define DMA_DESC_BLK_16B		0x00010000
+#define DMA_DESC_BLK_8B			0x00000000
+#define DMA_DESC_ID			0x00000004
+#define DMA_DESC_IE			0x00000002
+#define DMA_DESC_ST			0x00000001
+
+/* DMA_CHANX_STA_REG */
+#define DMA_CHANX_STA_DM		0x80000000
+#define DMA_CHANX_STA_OE		0x40000000
+#define DMA_CHANX_STA_DA		0x20000000
+#define DMA_CHANX_STA_DD		0x10000000
+#define DMA_CHANX_STA_OD		0x08000000
+#define DMA_CHANX_STA_ME		0x04000000
+#define DMA_CHANX_STA_BE		0x02000000
+#define DMA_CHANX_STA_RWE		0x01000000
+#define DMA_CHANX_STA_AE		0x00800000
+#define DMA_CHANX_STA_DN		0x00400000
+
+/* DMA_INT_REG */
+#define DMA_INT_CHAN(x)			(0x1 << (x))
+
+/* DMA_DUAL_SPACE_MODE_REG */
+#define DMA_DSM_EN                      0x80000000
+#define DMA_DSM_MAJP_2KB                0x00000090
+#define DMA_DSM_SPJP_64B                0x00000004
+#define DMA_DSM_SPJP_128B               0x00000005
+
+/* ==========================================================================*/
+
+
+struct dma_desc {
+	u32 src;
+	u32 dst;
+	u32 next_desc;
+	u32 rpt_addr;
+	u32 xfr_count;
+	u32 attr;
+	u32 rsvd;
+	u32 rpt;
+};
+
+#endif /* __AMBHW__DMA_H__ */
+
diff --git a/include/ambhw/drctl.h b/include/ambhw/drctl.h
index e5897f7..1006510 100644
--- a/include/ambhw/drctl.h
+++ b/include/ambhw/drctl.h
@@ -1,57 +1,68 @@
-/*
- * ambhw/drctl.h
- *
- * History:
- *	2007/01/27 - [Charles Chiou] created file
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- */
-
-#ifndef __AMBHW__DRCTRL_H__
-#define __AMBHW__DRCTRL_H__
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S) || (CHIP_REV == S2)
-#define DRAM_PHYS_BASE			0x60000000
-#elif (CHIP_REV == A7L)
-#define DRAM_PHYS_BASE			0xFFFE0000
-#else
-#define DRAM_PHYS_BASE			0xDFFE0000
-#endif
-
-#if (CHIP_REV == A5S) || (CHIP_REV == S2)
-#define DRAM_DRAM_OFFSET 		0x4000
-#define DRAM_DDRC_OFFSET  		DRAM_DRAM_OFFSET
-#else
-#define DRAM_DRAM_OFFSET 		0x0000
-#define DRAM_DDRC_OFFSET  		0x0800
-#endif
-
-#define DDRC_REG(x)			(DRAM_PHYS_BASE + DRAM_DDRC_OFFSET + (x))
-#define DRAM_REG(x)			(DRAM_PHYS_BASE + DRAM_DRAM_OFFSET + (x))
-
+/*
+ * ambhw/drctl.h
+ *
+ * History:
+ *	2007/01/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBHW__DRCTRL_H__
+#define __AMBHW__DRCTRL_H__
+
+#include <ambhw/chip.h>
+
 /* ==========================================================================*/
-#define DDRC_CTL_OFFSET			(0x00)
-#define DDRC_CFG_OFFSET			(0x04)
-#define DDRC_TIMING1_OFFSET		(0x08)
-#define DDRC_TIMING2_OFFSET		(0x0C)
-#define DDRC_TIMING3_OFFSET		(0x10)
-#define DDRC_INIT_CTL_OFFSET		(0x14)
-#define DDRC_MODE_OFFSET		(0x18)
-#define DDRC_SELF_REF_OFFSET		(0x1C)
-#define DDRC_DQS_SYNC_OFFSET		(0x20)
-#define DDRC_PAD_ZCTL_OFFSET		(0x24)
-#define DDRC_ZQ_CALIB_OFFSET		(0x28)
-#define DDRC_RSVD_SPACE_OFFSET		(0x2C)
-#define DDRC_BYTE_MAP_OFFSET		(0x30)
-#define DDRC_DDR3PLUS_BNKGRP_OFFSET	(0x34)
-#define DDRC_POWER_DOWN_OFFSET		(0x38)
-#define DDRC_DLL_CALIB_OFFSET		(0x3C)
-#define DDRC_DEBUG1_OFFSET		(0x40)
-
-/* ==========================================================================*/
-#endif /* __AMBHW__DRCTRL_H__ */
-
+
+#define DRAM_DRAM_OFFSET 		0x0000
+#define DRAM_DDRC_OFFSET  		0x0800
+
+#define DRAM_PHYS_BASE			0xDFFE0000
+#define DDRC_REG(x)			(DRAM_PHYS_BASE + DRAM_DDRC_OFFSET + (x))
+#define DRAM_REG(x)			(DRAM_PHYS_BASE + DRAM_DRAM_OFFSET + (x))
+
+/* ==========================================================================*/
+#define DDRC_CTL_OFFSET			(0x00)
+#define DDRC_CFG_OFFSET			(0x04)
+#define DDRC_TIMING1_OFFSET		(0x08)
+#define DDRC_TIMING2_OFFSET		(0x0C)
+#define DDRC_TIMING3_OFFSET		(0x10)
+#define DDRC_INIT_CTL_OFFSET		(0x14)
+#define DDRC_MODE_OFFSET		(0x18)
+#define DDRC_SELF_REF_OFFSET		(0x1C)
+#define DDRC_DQS_SYNC_OFFSET		(0x20)
+#define DDRC_PAD_ZCTL_OFFSET		(0x24)
+#define DDRC_ZQ_CALIB_OFFSET		(0x28)
+#define DDRC_RSVD_SPACE_OFFSET		(0x2C)
+#define DDRC_BYTE_MAP_OFFSET		(0x30)
+#define DDRC_DDR3PLUS_BNKGRP_OFFSET	(0x34)
+#define DDRC_POWER_DOWN_OFFSET		(0x38)
+#define DDRC_DLL_CALIB_OFFSET		(0x3C)
+#define DDRC_DEBUG1_OFFSET		(0x40)
+
+/* ==========================================================================*/
+#endif /* __AMBHW__DRCTRL_H__ */
+
diff --git a/include/ambhw/eth.h b/include/ambhw/eth.h
index ea06481..66f8209 100644
--- a/include/ambhw/eth.h
+++ b/include/ambhw/eth.h
@@ -1,445 +1,466 @@
-/*
- * ambhw/eth.h
- *
- * History:
- *	2007/01/27 - [Charles Chiou] created file
- *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+/*
+ * ambhw/eth.h
+ *
+ * History:
+ *	2007/01/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
-
-#ifndef __AMBHW__ETH_H__
-#define __AMBHW__ETH_H__
-
-/* ==========================================================================*/
-#if (CHIP_REV == A7L)
-#define ETH_INSTANCES	0
-#else
-#define ETH_INSTANCES	1
-#endif
-
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == A8)
-#define SUPPORT_GMII	1
-#else
-#define SUPPORT_GMII	0
-#endif
-
-#if (CHIP_REV == S3)
-#define ETH_ENHANCED 1
-#else
-#define ETH_ENHANCED 0
-#endif
-/* ==========================================================================*/
-#define ETH_OFFSET			0xE000
-#define ETH_DMA_OFFSET			0xF000
-#define ETH2_OFFSET			0x18000
-#define ETH2_DMA_OFFSET			0x19000
-
-#define ETH_BASE			(AHB_BASE + ETH_OFFSET)
-#define ETH_DMA_BASE			(AHB_BASE + ETH_DMA_OFFSET)
-#define ETH2_BASE			(AHB_BASE + ETH2_OFFSET)
-#define ETH2_DMA_BASE			(AHB_BASE + ETH2_DMA_OFFSET)
-
-#define ETH_REG(x)			(ETH_BASE + (x))
-#define ETH_DMA_REG(x)			(ETH_DMA_BASE + (x))
-#define ETH2_REG(x)			(ETH2_BASE + (x))
-#define ETH2_DMA_REG(x)			(ETH2_DMA_BASE + (x))
-
-/* ==========================================================================*/
-#define ETH_MAC_CFG_OFFSET		0x0000
-#define ETH_MAC_FRAME_FILTER_OFFSET	0x0004
-#define ETH_MAC_HASH_HI_OFFSET		0x0008
-#define ETH_MAC_HASH_LO_OFFSET		0x000c
-#define ETH_MAC_GMII_ADDR_OFFSET	0x0010
-#define ETH_MAC_GMII_DATA_OFFSET	0x0014
-#define ETH_MAC_FLOW_CTR_OFFSET		0x0018
-#define ETH_MAC_VLAN_TAG_OFFSET		0x001c
-#define ETH_MAC_VERSION_OFFSET		0x0020
-#define ETH_MAC_DEBUG_OFFSET		0x0024
-#define ETH_MAC_WKUPFMFILTER_OFFSET	0x0028
-#define ETH_MAC_PMT_OFFSET		0x002C
-#define ETH_MAC_LPI_CS_OFFSET		0x0030
-#define ETH_MAC_LPI_TIMERS_OFFSET	0x0034
-#define ETH_MAC_INTERRUPT_STATUS_OFFSET	0x0038
-#define ETH_MAC_INTERRUPT_MASK_OFFSET	0x003C
-#define ETH_MAC_MAC0_HI_OFFSET		0x0040
-#define ETH_MAC_MAC0_LO_OFFSET		0x0044
-#define ETH_MAC_MAC1_HI_OFFSET		0x0048
-#define ETH_MAC_MAC1_LO_OFFSET		0x004c
-#define ETH_MAC_MAC2_HI_OFFSET		0x0050
-#define ETH_MAC_MAC2_LO_OFFSET		0x0054
-#define ETH_MAC_AN_STATUS_OFFSET	0x00C4
-#define ETH_MAC_RGMII_CS_OFFSET		0x00D8
-#define ETH_MAC_GPIO_OFFSET		0x00E0
-
-#define ETH_DMA_BUS_MODE_OFFSET		0x1000
-#define ETH_DMA_TX_POLL_DMD_OFFSET	0x1004
-#define ETH_DMA_RX_POLL_DMD_OFFSET	0x1008
-#define ETH_DMA_RX_DESC_LIST_OFFSET	0x100c
-#define ETH_DMA_TX_DESC_LIST_OFFSET	0x1010
-#define ETH_DMA_STATUS_OFFSET		0x1014
-#define ETH_DMA_OPMODE_OFFSET		0x1018
-#define ETH_DMA_INTEN_OFFSET		0x101c
-#define ETH_DMA_MISS_FRAME_BOCNT_OFFSET	0x1020
-#define ETH_DMA_HOST_TX_DESC_OFFSET	0x1048
-#define ETH_DMA_HOST_RX_DESC_OFFSET	0x104c
-#define ETH_DMA_HOST_TX_BUF_OFFSET	0x1050
-#define ETH_DMA_HOST_RX_BUF_OFFSET	0x1054
-
-/* ETH_MAC_CFG_REG */
-#define ETH_MAC_CFG_WD			0x00800000
-#define ETH_MAC_CFG_JD			0x00400000
-#define ETH_MAC_CFG_BE			0x00200000
-#define ETH_MAC_CFG_JE			0x00100000
-#define ETH_MAC_CFG_IFG_96		0x000e0000
-#define ETH_MAC_CFG_IFG_88		0x000c0000
-#define ETH_MAC_CFG_IFG_80		0x000a0000
-#define ETH_MAC_CFG_IFG_72		0x00080000
-#define ETH_MAC_CFG_IFG_64		0x00060000
-#define ETH_MAC_CFG_IFG_56		0x00040000
-#define ETH_MAC_CFG_IFG_48		0x00020000
-#define ETH_MAC_CFG_IFG_40		0x00000000
-#define ETH_MAC_CFG_DCRS		0x00010000
-#define ETH_MAC_CFG_PS			0x00008000
-#define ETH_MAC_CFG_FES			0x00004000
-#define ETH_MAC_CFG_DO			0x00002000
-#define ETH_MAC_CFG_LM			0x00001000
-#define ETH_MAC_CFG_DM			0x00000800
-#define ETH_MAC_CFG_IPC			0x00000400
-#define ETH_MAC_CFG_DR			0x00000200
-#define ETH_MAC_CFG_LUD			0x00000100
-#define ETH_MAC_CFG_ACS			0x00000080
-#define ETH_MAC_CFG_BL_1		0x00000060
-#define ETH_MAC_CFG_BL_4		0x00000040
-#define ETH_MAC_CFG_BL_8		0x00000020
-#define ETH_MAC_CFG_BL_10		0x00000000
-#define ETH_MAC_CFG_DC			0x00000010
-#define ETH_MAC_CFG_TE			0x00000008	/* Transmitter Enable */
-#define ETH_MAC_CFG_RE			0x00000004	/* Receiver Enable  */
-
-/* ETH_MAC_FRAME_FILTER_REG */
-#define ETH_MAC_FRAME_FILTER_RA		0x80000000
-#define ETH_MAC_FRAME_FILTER_SAF	0x00000200
-#define ETH_MAC_FRAME_FILTER_SAIF	0x00000100
-#define ETH_MAC_FRAME_FILTER_PCF_PASS	0x000000c0
-#define ETH_MAC_FRAME_FILTER_PCF_FAIL	0x00000040
-#define ETH_MAC_FRAME_FILTER_PCF_ALL	0x00000000
-#define ETH_MAC_FRAME_FILTER_DBF	0x00000020
-#define ETH_MAC_FRAME_FILTER_PM		0x00000010
-#define ETH_MAC_FRAME_FILTER_DAIF	0x00000008
-#define ETH_MAC_FRAME_FILTER_HMC	0x00000004
-#define ETH_MAC_FRAME_FILTER_HUC	0x00000002
-#define ETH_MAC_FRAME_FILTER_PR		0x00000001
-
-/* ETH_MAC_GMII_ADDR_REG */
-#define ETH_MAC_GMII_ADDR_PA(x)		(((x) & 0x1f) << 11)
-#define ETH_MAC_GMII_ADDR_GR(x)		(((x) & 0x1f) << 6)
-#define ETH_MAC_GMII_ADDR_CR_250_300MHZ	0x00000014
-#define ETH_MAC_GMII_ADDR_CR_150_250MHZ	0x00000010
-#define ETH_MAC_GMII_ADDR_CR_35_60MHZ	0x0000000c
-#define ETH_MAC_GMII_ADDR_CR_20_35MHZ	0x00000008
-#define ETH_MAC_GMII_ADDR_CR_100_150MHZ	0x00000004
-#define ETH_MAC_GMII_ADDR_CR_60_100MHZ	0x00000000
-#define ETH_MAC_GMII_ADDR_GW		0x00000002
-#define ETH_MAC_GMII_ADDR_GB		0x00000001
-
-/* ETH_MAC_FLOW_CTR_REG */
-#define ETH_MAC_FLOW_CTR_PT(x)		(((x) & 0xffff) << 16)
-#define ETH_MAC_FLOW_CTR_PLT_256	0x00000030
-#define ETH_MAC_FLOW_CTR_PLT_144	0x00000020
-#define ETH_MAC_FLOW_CTR_PLT_28		0x00000010
-#define ETH_MAC_FLOW_CTR_PLT_4		0x00000000
-#define ETH_MAC_FLOW_CTR_UP		0x00000008
-#define ETH_MAC_FLOW_CTR_RFE		0x00000004
-#define ETH_MAC_FLOW_CTR_TFE		0x00000002
-#define ETH_MAC_FLOW_CTR_FCBBPA		0x00000001
-
-/* ETH_MAC_VERSION_REG */
-#define ETH_MAC_VERSION_USER(v)		(((x) & 0x0000ff00) >> 8)
-#define ETH_MAC_VERSION_SYN(v)		((x) & 0x000000ff)
-
-/* ETH_DMA_BUS_MODE_REG */
-#define ETH_DMA_BUS_MODE_FB		0x00010000
-#define ETH_DMA_BUS_MODE_PR4		0x0000c000
-#define ETH_DMA_BUS_MODE_PR3		0x00008000
-#define ETH_DMA_BUS_MODE_PR2		0x00004000
-#define ETH_DMA_BUS_MODE_PR1		0x00000000
-#define ETH_DMA_BUS_MODE_PBL_32		0x00002000
-#define ETH_DMA_BUS_MODE_PBL_16		0x00001000
-#define ETH_DMA_BUS_MODE_PBL_8		0x00000800
-#define ETH_DMA_BUS_MODE_PBL_4		0x00000400
-#define ETH_DMA_BUS_MODE_PBL_2		0x00000200
-#define ETH_DMA_BUS_MODE_PBL_1		0x00000100
-#define ETH_DMA_BUS_MODE_ATDS		0x00000080
-#define ETH_DMA_BUS_MODE_DSL(len)	((len & 0x1f) << 2)
-#define ETH_DMA_BUS_MODE_DA_RX		0x00000002
-#define ETH_DMA_BUS_MODE_DA_TX		0x00000000
-#define ETH_DMA_BUS_MODE_SWR		0x00000001
-
-/* ETH_DMA_STATUS_REG */
-#define ETH_DMA_STATUS_GPI		0x10000000
-#define ETH_DMA_STATUS_GMI		0x08000000
-#define ETH_DMA_STATUS_GLI		0x04000000
-#define ETH_DMA_STATUS_EB_MASK		0x03800000
-#define ETH_DMA_STATUS_EB_TXDMA		0x02000000
-#define ETH_DMA_STATUS_EB_RXDMA		0x00000000
-#define ETH_DMA_STATUS_EB_RXFER		0x01000000
-#define ETH_DMA_STATUS_EB_TXFER		0x00000000
-#define ETH_DMA_STATUS_EB_DESC		0x00800000
-#define ETH_DMA_STATUS_EB_DBUF		0x00000000
-#define ETH_DMA_STATUS_TS_MASK		0x00700000
-#define ETH_DMA_STATUS_TS_CTD		0x00700000
-#define ETH_DMA_STATUS_TS_SUSP		0x00600000
-#define ETH_DMA_STATUS_TS_READ		0x00300000
-#define ETH_DMA_STATUS_TS_WAIT		0x00200000
-#define ETH_DMA_STATUS_TS_FETCH		0x00100000
-#define ETH_DMA_STATUS_TS_STOP		0x00000000
-#define ETH_DMA_STATUS_RS_MASK		0x000e0000
-#define ETH_DMA_STATUS_RS_RCV		0x000e0000
-#define ETH_DMA_STATUS_RS_CRD		0x000a0000
-#define ETH_DMA_STATUS_RS_SUSP		0x00080000
-#define ETH_DMA_STATUS_RS_WAIT		0x00060000
-#define ETH_DMA_STATUS_RS_FETCH		0x00020000
-#define ETH_DMA_STATUS_RS_STOP		0x00000000
-#define ETH_DMA_STATUS_NIS		0x00010000
-#define ETH_DMA_STATUS_AIS		0x00008000
-#define ETH_DMA_STATUS_ERI		0x00004000
-#define ETH_DMA_STATUS_FBI		0x00002000
-#define ETH_DMA_STATUS_ETI		0x00000400
-#define ETH_DMA_STATUS_RWT		0x00000200
-#define ETH_DMA_STATUS_RPS		0x00000100
-#define ETH_DMA_STATUS_RU		0x00000080
-#define ETH_DMA_STATUS_RI		0x00000040
-#define ETH_DMA_STATUS_UNF		0x00000020
-#define ETH_DMA_STATUS_OVF		0x00000010
-#define ETH_DMA_STATUS_TJT		0x00000008
-#define ETH_DMA_STATUS_TU		0x00000004
-#define ETH_DMA_STATUS_TPS		0x00000002
-#define ETH_DMA_STATUS_TI		0x00000001
-
-/* ETH_DMA_OPMODE_REG */
-#define ETH_DMA_OPMODE_DT		0x04000000
-#define ETH_DMA_OPMODE_RSF		0x02000000
-#define ETH_DMA_OPMODE_DFF		0x01000000
-#define ETH_DMA_OPMODE_TSF		0x00200000
-#define ETH_DMA_OPMODE_FTF		0x00100000
-#define ETH_DMA_OPMODE_TTC_16		0x0001c000
-#define ETH_DMA_OPMODE_TTC_24		0x00018000
-#define ETH_DMA_OPMODE_TTC_32		0x00014000
-#define ETH_DMA_OPMODE_TTC_40		0x00010000
-#define ETH_DMA_OPMODE_TTC_256		0x0000c000
-#define ETH_DMA_OPMODE_TTC_192		0x00008000
-#define ETH_DMA_OPMODE_TTC_128		0x00004000
-#define ETH_DMA_OPMODE_TTC_64		0x00000000
-#define ETH_DMA_OPMODE_ST		0x00002000
-#define ETH_DMA_OPMODE_RFD_4K		0x00001800
-#define ETH_DMA_OPMODE_RFD_3K		0x00001000
-#define ETH_DMA_OPMODE_RFD_2K		0x00000800
-#define ETH_DMA_OPMODE_RFD_1K		0x00000000
-#define ETH_DMA_OPMODE_RFA_4K		0x00000600
-#define ETH_DMA_OPMODE_RFA_3K		0x00000400
-#define ETH_DMA_OPMODE_RFA_2K		0x00000200
-#define ETH_DMA_OPMODE_RFA_1K		0x00000000
-#define ETH_DMA_OPMODE_EFC		0x00000100
-#define ETH_DMA_OPMODE_FEF		0x00000080
-#define ETH_DMA_OPMODE_FUF		0x00000040
-#define ETH_DMA_OPMODE_RTC_128		0x00000018
-#define ETH_DMA_OPMODE_RTC_96		0x00000010
-#define ETH_DMA_OPMODE_RTC_32		0x00000008
-#define ETH_DMA_OPMODE_RTC_64		0x00000000
-#define ETH_DMA_OPMODE_OSF		0x00000004
-#define ETH_DMA_OPMODE_SR		0x00000002
-
-/* ETH_DMA_INTEN_REG */
-#define ETH_DMA_INTEN_NIE		0x00010000
-#define ETH_DMA_INTEN_AIE		0x00008000
-#define ETH_DMA_INTEN_ERE		0x00004000
-#define ETH_DMA_INTEN_FBE		0x00002000
-#define ETH_DMA_INTEN_ETE		0x00000400
-#define ETH_DMA_INTEN_RWE		0x00000200
-#define ETH_DMA_INTEN_RSE		0x00000100
-#define ETH_DMA_INTEN_RUE		0x00000080
-#define ETH_DMA_INTEN_RIE		0x00000040
-#define ETH_DMA_INTEN_UNE		0x00000020
-#define ETH_DMA_INTEN_OVE		0x00000010
-#define ETH_DMA_INTEN_TJE		0x00000008
-#define ETH_DMA_INTEN_TUE		0x00000004
-#define ETH_DMA_INTEN_TSE		0x00000002
-#define ETH_DMA_INTEN_TIE		0x00000001
-
-/* ETH_DMA_MISS_FRAME_BOCNT_REG */
-#define ETH_DMA_MISS_FRAME_BOCNT_FIFO		0x10000000
-#define ETH_DMA_MISS_FRAME_BOCNT_APP(v)		(((v) & 0x0ffe0000) >> 17)
-#define ETH_DMA_MISS_FRAME_BOCNT_FRAME		0x00001000
-#define ETH_DMA_MISS_FRAME_BOCNT_HOST(v)	((v) & 0x0000ffff)
-
-/* Receive Descriptor 0 (RDES0) */
-#define ETH_RDES0_OWN			0x80000000
-#define ETH_RDES0_AFM			0x40000000
-#define ETH_RDES0_FL(v)			(((v) & 0x3fff0000) >> 16)
-#define ETH_RDES0_ES			0x00008000
-#define ETH_RDES0_DE			0x00004000
-#define ETH_RDES0_SAF			0x00002000
-#define ETH_RDES0_LE			0x00001000
-#define ETH_RDES0_OE			0x00000800
-#define ETH_RDES0_VLAN			0x00000400
-#define ETH_RDES0_FS			0x00000200
-#define ETH_RDES0_LS			0x00000100
-#define ETH_RDES0_IPC			0x00000080
-#define ETH_RDES0_LC			0x00000040
-#define ETH_RDES0_FT			0x00000020
-#define ETH_RDES0_RWT			0x00000010
-#define ETH_RDES0_RE			0x00000008
-#define ETH_RDES0_DBE			0x00000004
-#define ETH_RDES0_CE			0x00000002
-#define ETH_RDES0_RX			0x00000001
-
-#define ETH_RDES0_COE_MASK		0x000000a1
-#define ETH_RDES0_COE_LENLT600		0x00000000	/* Bit(5:7:0)=>0 IEEE 802.3 type frame Length field is Lessthan 0x0600			*/
-#define ETH_RDES0_COE_UNSUPPORTED	0x00000001	/* Bit(5:7:0)=>1 Payload & Ip header checksum bypassed (unsuppported payload) 		*/
-#define ETH_RDES0_COE_RESERVED		0x00000080	/* Bit(5:7:0)=>2 Reserved						 		*/
-#define ETH_RDES0_COE_CHKBYPASS		0x00000081	/* Bit(5:7:0)=>3 Neither IPv4 nor IPV6. So checksum bypassed 		 		*/
-#define ETH_RDES0_COE_NOCHKERROR	0x00000020	/* Bit(5:7:0)=>4 No IPv4/IPv6 Checksum error detected					*/
-#define ETH_RDES0_COE_PLCHKERROR	0x00000021	/* Bit(5:7:0)=>5 Payload checksum error detected for Ipv4/Ipv6 frames			*/
-#define ETH_RDES0_COE_HDRCHKERROR	0x000000a0	/* Bit(5:7:0)=>6 Ip header checksum error detected for Ipv4 frames			*/
-#define ETH_RDES0_COE_HDRPLCHKERROR	0x000000a1	/* Bit(5:7:0)=>7 Payload & Ip header checksum error detected for Ipv4/Ipv6 frames	*/
-
-/* Receive Descriptor 1 (RDES1) */
-#define ETH_RDES1_DIC			0x80000000
-#define ETH_RDES1_RER			0x02000000
-#define ETH_RDES1_RCH			0x01000000
-#define ETH_RDES1_RBS2(v)		(((v) & 0x003ff800) >> 11)	/* Receive Buffer 2 Size */
-#define ETH_RDES1_RBS1(v)		((v) & 0x000007ff)		/* Receive Buffer 1 Size */
-#define ETH_RDES1_RBS2x(x)		(((x) << 11) & 0x003ff800)	/* Receive Buffer 2 Size */
-#define ETH_RDES1_RBS1x(x)		((x) & 0x000007ff)		/* Receive Buffer 1 Size */
-
-/* Transmit Descriptor 0 (TDES0) */
-#define ETH_TDES0_OWN			0x80000000
-#define ETH_TDES0_TTSS			0x00020000
-#define ETH_TDES0_IHE			0x00010000
-#define ETH_TDES0_ES			0x00008000
-#define ETH_TDES0_JT			0x00004000
-#define ETH_TDES0_FF			0x00002000
-#define ETH_TDES0_PCE			0x00001000
-#define ETH_TDES0_LCA			0x00000800
-#define ETH_TDES0_NC			0x00000400
-#define ETH_TDES0_LCO			0x00000200
-#define ETH_TDES0_EC			0x00000100
-#define ETH_TDES0_VF			0x00000080
-#define ETH_TDES0_CC(v)			(((v) & 0x00000078) >> 3)
-#define ETH_TDES0_ED			0x00000004
-#define ETH_TDES0_UF			0x00000002
-#define ETH_TDES0_DB			0x00000001
-#define ETH_TDES0_ES_MASK		(ETH_TDES0_UF | ETH_TDES0_ED | \
-					ETH_TDES0_EC | ETH_TDES0_LCO | \
-					ETH_TDES0_NC | ETH_TDES0_LCA | \
-					ETH_TDES0_FF | ETH_TDES0_JT | \
-					ETH_TDES0_ES)
-
-/* Transmit Descriptor 1 (TDES1) */
-#define ETH_TDES1_IC			0x80000000
-#define ETH_TDES1_LS			0x40000000
-#define ETH_TDES1_FS			0x20000000
-#define ETH_TDES1_CIC_TUI		0x10000000
-#define ETH_TDES1_CIC_HDR		0x08000000
-#define ETH_TDES1_DC			0x04000000
-#define ETH_TDES1_TER			0x02000000
-#define ETH_TDES1_TCH			0x01000000
-#define ETH_TDES1_DP			0x00800000
-#define ETH_TDES1_TBS2(v)		(((v) & 0x003ff800) >> 11)
-#define ETH_TDES1_TBS1(v)		((v) & 0x000007ff)
-#define ETH_TDES1_TBS2x(x)		(((x) << 11) & 0x003ff800)
-#define ETH_TDES1_TBS1x(x)		((x) & 0x000007ff)
-
-/* ==========================================================================*/
-#define ETH_ENHANCED_RDES0_OWN		0x80000000
-#define ETH_ENHANCED_RDES0_AFM		0x40000000
-#define ETH_ENHANCED_RDES0_FL(v)	(((v) & 0x3FFF0000) >> 16)
-#define ETH_ENHANCED_RDES0_ES		0x00008000
-#define ETH_ENHANCED_RDES0_DE		0x00004000
-#define ETH_ENHANCED_RDES0_SAF		0x00002000
-#define ETH_ENHANCED_RDES0_LE		0x00001000
-#define ETH_ENHANCED_RDES0_OE		0x00000800
-#define ETH_ENHANCED_RDES0_VLAN		0x00000400
-#define ETH_ENHANCED_RDES0_FS		0x00000200
-#define ETH_ENHANCED_RDES0_LS		0x00000100
-#define ETH_ENHANCED_RDES0_IPC		0x00000080
-#define ETH_ENHANCED_RDES0_LC		0x00000040
-#define ETH_ENHANCED_RDES0_FT		0x00000020
-#define ETH_ENHANCED_RDES0_RWT		0x00000010
-#define ETH_ENHANCED_RDES0_RE		0x00000008
-#define ETH_ENHANCED_RDES0_DBE		0x00000004
-#define ETH_ENHANCED_RDES0_CE		0x00000002
-#define ETH_ENHANCED_RDES0_RX		0x00000001
-
-#define ETH_ENHANCED_RDES1_DIC		0x80000000
-#define ETH_ENHANCED_RDES1_RER		0x00008000
-#define ETH_ENHANCED_RDES1_RCH		0x00004000
-#define ETH_ENHANCED_RDES1_RBS2(v)	(((v) & 0x1FFF0000) >> 16)
-#define ETH_ENHANCED_RDES1_RBS1(v)	((v) & 0x00001FFF)
-#define ETH_ENHANCED_RDES1_RBS2x(x)	(((x) << 16) & 0x1FFF0000)
-#define ETH_ENHANCED_RDES1_RBS1x(x)	((x) & 0x00001FFF)
-
-#define ETH_ENHANCED_TDES0_OWN		0x80000000
-#define ETH_ENHANCED_TDES0_IC		0x40000000
-#define ETH_ENHANCED_TDES0_LS		0x20000000
-#define ETH_ENHANCED_TDES0_FS		0x10000000
-#define ETH_ENHANCED_TDES0_DC		0x08000000
-#define ETH_ENHANCED_TDES0_DP		0x04000000
-#define ETH_ENHANCED_TDES0_CRCR		0x01000000
-#define ETH_ENHANCED_TDES0_CIC_V2	0x00C00000
-#define ETH_ENHANCED_TDES0_CIC_V1	0x00800000
-#define ETH_ENHANCED_TDES0_CIC_HDR	0x00400000
-#define ETH_ENHANCED_TDES0_TER		0x00200000
-#define ETH_ENHANCED_TDES0_TCH		0x00100000
-#define ETH_ENHANCED_TDES0_TTSS		0x00020000
-#define ETH_ENHANCED_TDES0_IHE		0x00010000
-#define ETH_ENHANCED_TDES0_ES		0x00008000
-#define ETH_ENHANCED_TDES0_JT		0x00004000
-#define ETH_ENHANCED_TDES0_FF		0x00002000
-#define ETH_ENHANCED_TDES0_IPE		0x00001000
-#define ETH_ENHANCED_TDES0_LCA		0x00000800
-#define ETH_ENHANCED_TDES0_NC		0x00000400
-#define ETH_ENHANCED_TDES0_LCO		0x00000200
-#define ETH_ENHANCED_TDES0_EC		0x00000100
-#define ETH_ENHANCED_TDES0_VF		0x00000080
-#define ETH_ENHANCED_TDES0_CC(v)	(((v) & 0x00000078) >> 3)
-#define ETH_ENHANCED_TDES0_ED		0x00000004
-#define ETH_ENHANCED_TDES0_UF		0x00000002
-#define ETH_ENHANCED_TDES0_DB		0x00000001
-#define ETH_ENHANCED_TDES0_ES_MASK	(ETH_ENHANCED_TDES0_UF | \
-					ETH_ENHANCED_TDES0_ED | \
-					ETH_ENHANCED_TDES0_EC | \
-					ETH_ENHANCED_TDES0_LCO | \
-					ETH_ENHANCED_TDES0_NC | \
-					ETH_ENHANCED_TDES0_LCA | \
-					ETH_ENHANCED_TDES0_FF | \
-					ETH_ENHANCED_TDES0_JT | \
-					ETH_ENHANCED_TDES0_ES)
-
-#define ETH_ENHANCED_TDES1_SAIC_MAC1	0x80000000
-#define ETH_ENHANCED_TDES1_SAIC_REPLACE	0x40000000
-#define ETH_ENHANCED_TDES1_SAIC_INCLUDE	0x20000000
-#define ETH_ENHANCED_TDES1_TBS2(v)	(((v) & 0x1FFF0000) >> 16)
-#define ETH_ENHANCED_TDES1_TBS1(v)	((v) & 0x00001FFF)
-#define ETH_ENHANCED_TDES1_TBS2x(x)	(((x) << 16) & 0x1FFF0000)
-#define ETH_ENHANCED_TDES1_TBS1x(x)	((x) & 0x00001FFF)
-
+
+#ifndef __AMBHW__ETH_H__
+#define __AMBHW__ETH_H__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+#define ETH_INSTANCES			1
+
+#if (CHIP_REV == S2L) || (CHIP_REV == S3L)
+#define SUPPORT_GMII			0
+#define ETH_ENHANCED			0
+#else
+#define SUPPORT_GMII			1
+#define ETH_ENHANCED			1
+#endif
+
+/* ==========================================================================*/
+#define ETH_OFFSET			0xE000
+#define ETH_DMA_OFFSET			0xF000
+
+#define ETH_BASE			(AHB_N_BASE + ETH_OFFSET)
+#define ETH_DMA_BASE			(AHB_N_BASE + ETH_DMA_OFFSET)
+
+#define ETH_REG(x)			(ETH_BASE + (x))
+#define ETH_DMA_REG(x)			(ETH_DMA_BASE + (x))
+
+/* ==========================================================================*/
+#define ETH_MAC_CFG_OFFSET		0x0000
+#define ETH_MAC_FRAME_FILTER_OFFSET	0x0004
+#define ETH_MAC_HASH_HI_OFFSET		0x0008
+#define ETH_MAC_HASH_LO_OFFSET		0x000c
+#define ETH_MAC_GMII_ADDR_OFFSET	0x0010
+#define ETH_MAC_GMII_DATA_OFFSET	0x0014
+#define ETH_MAC_FLOW_CTR_OFFSET		0x0018
+#define ETH_MAC_VLAN_TAG_OFFSET		0x001c
+#define ETH_MAC_VERSION_OFFSET		0x0020
+#define ETH_MAC_DEBUG_OFFSET		0x0024
+#define ETH_MAC_WKUPFMFILTER_OFFSET	0x0028
+#define ETH_MAC_PMT_OFFSET		0x002C
+#define ETH_MAC_LPI_CS_OFFSET		0x0030
+#define ETH_MAC_LPI_TIMERS_OFFSET	0x0034
+#define ETH_MAC_INTERRUPT_STATUS_OFFSET	0x0038
+#define ETH_MAC_INTERRUPT_MASK_OFFSET	0x003C
+#define ETH_MAC_MAC0_HI_OFFSET		0x0040
+#define ETH_MAC_MAC0_LO_OFFSET		0x0044
+#define ETH_MAC_MAC1_HI_OFFSET		0x0048
+#define ETH_MAC_MAC1_LO_OFFSET		0x004c
+#define ETH_MAC_MAC2_HI_OFFSET		0x0050
+#define ETH_MAC_MAC2_LO_OFFSET		0x0054
+#define ETH_MAC_AN_STATUS_OFFSET	0x00C4
+#define ETH_MAC_RGMII_CS_OFFSET		0x00D8
+#define ETH_MAC_GPIO_OFFSET		0x00E0
+
+#define ETH_DMA_BUS_MODE_OFFSET		0x1000
+#define ETH_DMA_TX_POLL_DMD_OFFSET	0x1004
+#define ETH_DMA_RX_POLL_DMD_OFFSET	0x1008
+#define ETH_DMA_RX_DESC_LIST_OFFSET	0x100c
+#define ETH_DMA_TX_DESC_LIST_OFFSET	0x1010
+#define ETH_DMA_STATUS_OFFSET		0x1014
+#define ETH_DMA_OPMODE_OFFSET		0x1018
+#define ETH_DMA_INTEN_OFFSET		0x101c
+#define ETH_DMA_MISS_FRAME_BOCNT_OFFSET	0x1020
+#define ETH_DMA_HOST_TX_DESC_OFFSET	0x1048
+#define ETH_DMA_HOST_RX_DESC_OFFSET	0x104c
+#define ETH_DMA_HOST_TX_BUF_OFFSET	0x1050
+#define ETH_DMA_HOST_RX_BUF_OFFSET	0x1054
+#define ETH_DMA_HWFEA_OFFSET		0x1058
+
+/* ETH_MAC_CFG_REG */
+#define ETH_MAC_CFG_WD			0x00800000
+#define ETH_MAC_CFG_JD			0x00400000
+#define ETH_MAC_CFG_BE			0x00200000
+#define ETH_MAC_CFG_JE			0x00100000
+#define ETH_MAC_CFG_IFG_96		0x000e0000
+#define ETH_MAC_CFG_IFG_88		0x000c0000
+#define ETH_MAC_CFG_IFG_80		0x000a0000
+#define ETH_MAC_CFG_IFG_72		0x00080000
+#define ETH_MAC_CFG_IFG_64		0x00060000
+#define ETH_MAC_CFG_IFG_56		0x00040000
+#define ETH_MAC_CFG_IFG_48		0x00020000
+#define ETH_MAC_CFG_IFG_40		0x00000000
+#define ETH_MAC_CFG_DCRS		0x00010000
+#define ETH_MAC_CFG_PS			0x00008000
+#define ETH_MAC_CFG_FES			0x00004000
+#define ETH_MAC_CFG_DO			0x00002000
+#define ETH_MAC_CFG_LM			0x00001000
+#define ETH_MAC_CFG_DM			0x00000800
+#define ETH_MAC_CFG_IPC			0x00000400
+#define ETH_MAC_CFG_DR			0x00000200
+#define ETH_MAC_CFG_LUD			0x00000100
+#define ETH_MAC_CFG_ACS			0x00000080
+#define ETH_MAC_CFG_BL_1		0x00000060
+#define ETH_MAC_CFG_BL_4		0x00000040
+#define ETH_MAC_CFG_BL_8		0x00000020
+#define ETH_MAC_CFG_BL_10		0x00000000
+#define ETH_MAC_CFG_DC			0x00000010
+#define ETH_MAC_CFG_TE			0x00000008	/* Transmitter Enable */
+#define ETH_MAC_CFG_RE			0x00000004	/* Receiver Enable  */
+
+/* ETH_MAC_FRAME_FILTER_REG */
+#define ETH_MAC_FRAME_FILTER_RA		0x80000000
+#define ETH_MAC_FRAME_FILTER_SAF	0x00000200
+#define ETH_MAC_FRAME_FILTER_SAIF	0x00000100
+#define ETH_MAC_FRAME_FILTER_PCF_PASS	0x000000c0
+#define ETH_MAC_FRAME_FILTER_PCF_FAIL	0x00000040
+#define ETH_MAC_FRAME_FILTER_PCF_ALL	0x00000000
+#define ETH_MAC_FRAME_FILTER_DBF	0x00000020
+#define ETH_MAC_FRAME_FILTER_PM		0x00000010
+#define ETH_MAC_FRAME_FILTER_DAIF	0x00000008
+#define ETH_MAC_FRAME_FILTER_HMC	0x00000004
+#define ETH_MAC_FRAME_FILTER_HUC	0x00000002
+#define ETH_MAC_FRAME_FILTER_PR		0x00000001
+
+/* ETH_MAC_GMII_ADDR_REG */
+#define ETH_MAC_GMII_ADDR_PA(x)		(((x) & 0x1f) << 11)
+#define ETH_MAC_GMII_ADDR_GR(x)		(((x) & 0x1f) << 6)
+#define ETH_MAC_GMII_ADDR_CR_250_300MHZ	0x00000014
+#define ETH_MAC_GMII_ADDR_CR_150_250MHZ	0x00000010
+#define ETH_MAC_GMII_ADDR_CR_35_60MHZ	0x0000000c
+#define ETH_MAC_GMII_ADDR_CR_20_35MHZ	0x00000008
+#define ETH_MAC_GMII_ADDR_CR_100_150MHZ	0x00000004
+#define ETH_MAC_GMII_ADDR_CR_60_100MHZ	0x00000000
+#define ETH_MAC_GMII_ADDR_GW		0x00000002
+#define ETH_MAC_GMII_ADDR_GB		0x00000001
+
+/* ETH_MAC_FLOW_CTR_REG */
+#define ETH_MAC_FLOW_CTR_PT(x)		(((x) & 0xffff) << 16)
+#define ETH_MAC_FLOW_CTR_PLT_256	0x00000030
+#define ETH_MAC_FLOW_CTR_PLT_144	0x00000020
+#define ETH_MAC_FLOW_CTR_PLT_28		0x00000010
+#define ETH_MAC_FLOW_CTR_PLT_4		0x00000000
+#define ETH_MAC_FLOW_CTR_UP		0x00000008
+#define ETH_MAC_FLOW_CTR_RFE		0x00000004
+#define ETH_MAC_FLOW_CTR_TFE		0x00000002
+#define ETH_MAC_FLOW_CTR_FCBBPA		0x00000001
+
+/* ETH_MAC_VERSION_REG */
+#define ETH_MAC_VERSION_USER(x)		(((x) & 0x0000ff00) >> 8)
+#define ETH_MAC_VERSION_SYN(x)		((x) & 0x000000ff)
+
+/* ETH_DMA_BUS_MODE_REG */
+#define ETH_DMA_BUS_MODE_FB		0x00010000
+#define ETH_DMA_BUS_MODE_PR4		0x0000c000
+#define ETH_DMA_BUS_MODE_PR3		0x00008000
+#define ETH_DMA_BUS_MODE_PR2		0x00004000
+#define ETH_DMA_BUS_MODE_PR1		0x00000000
+#define ETH_DMA_BUS_MODE_PBL_32		0x00002000
+#define ETH_DMA_BUS_MODE_PBL_16		0x00001000
+#define ETH_DMA_BUS_MODE_PBL_8		0x00000800
+#define ETH_DMA_BUS_MODE_PBL_4		0x00000400
+#define ETH_DMA_BUS_MODE_PBL_2		0x00000200
+#define ETH_DMA_BUS_MODE_PBL_1		0x00000100
+#define ETH_DMA_BUS_MODE_ATDS		0x00000080
+#define ETH_DMA_BUS_MODE_DSL(len)	((len & 0x1f) << 2)
+#define ETH_DMA_BUS_MODE_DA_RX		0x00000002
+#define ETH_DMA_BUS_MODE_DA_TX		0x00000000
+#define ETH_DMA_BUS_MODE_SWR		0x00000001
+
+/* ETH_DMA_STATUS_REG */
+#define ETH_DMA_STATUS_GPI		0x10000000
+#define ETH_DMA_STATUS_GMI		0x08000000
+#define ETH_DMA_STATUS_GLI		0x04000000
+#define ETH_DMA_STATUS_EB_MASK		0x03800000
+#define ETH_DMA_STATUS_EB_TXDMA		0x02000000
+#define ETH_DMA_STATUS_EB_RXDMA		0x00000000
+#define ETH_DMA_STATUS_EB_RXFER		0x01000000
+#define ETH_DMA_STATUS_EB_TXFER		0x00000000
+#define ETH_DMA_STATUS_EB_DESC		0x00800000
+#define ETH_DMA_STATUS_EB_DBUF		0x00000000
+#define ETH_DMA_STATUS_TS_MASK		0x00700000
+#define ETH_DMA_STATUS_TS_CTD		0x00700000
+#define ETH_DMA_STATUS_TS_SUSP		0x00600000
+#define ETH_DMA_STATUS_TS_READ		0x00300000
+#define ETH_DMA_STATUS_TS_WAIT		0x00200000
+#define ETH_DMA_STATUS_TS_FETCH		0x00100000
+#define ETH_DMA_STATUS_TS_STOP		0x00000000
+#define ETH_DMA_STATUS_RS_MASK		0x000e0000
+#define ETH_DMA_STATUS_RS_RCV		0x000e0000
+#define ETH_DMA_STATUS_RS_CRD		0x000a0000
+#define ETH_DMA_STATUS_RS_SUSP		0x00080000
+#define ETH_DMA_STATUS_RS_WAIT		0x00060000
+#define ETH_DMA_STATUS_RS_FETCH		0x00020000
+#define ETH_DMA_STATUS_RS_STOP		0x00000000
+#define ETH_DMA_STATUS_NIS		0x00010000
+#define ETH_DMA_STATUS_AIS		0x00008000
+#define ETH_DMA_STATUS_ERI		0x00004000
+#define ETH_DMA_STATUS_FBI		0x00002000
+#define ETH_DMA_STATUS_ETI		0x00000400
+#define ETH_DMA_STATUS_RWT		0x00000200
+#define ETH_DMA_STATUS_RPS		0x00000100
+#define ETH_DMA_STATUS_RU		0x00000080
+#define ETH_DMA_STATUS_RI		0x00000040
+#define ETH_DMA_STATUS_UNF		0x00000020
+#define ETH_DMA_STATUS_OVF		0x00000010
+#define ETH_DMA_STATUS_TJT		0x00000008
+#define ETH_DMA_STATUS_TU		0x00000004
+#define ETH_DMA_STATUS_TPS		0x00000002
+#define ETH_DMA_STATUS_TI		0x00000001
+
+/* ETH_DMA_OPMODE_REG */
+#define ETH_DMA_OPMODE_DT		0x04000000
+#define ETH_DMA_OPMODE_RSF		0x02000000
+#define ETH_DMA_OPMODE_DFF		0x01000000
+#define ETH_DMA_OPMODE_TSF		0x00200000
+#define ETH_DMA_OPMODE_FTF		0x00100000
+#define ETH_DMA_OPMODE_TTC_16		0x0001c000
+#define ETH_DMA_OPMODE_TTC_24		0x00018000
+#define ETH_DMA_OPMODE_TTC_32		0x00014000
+#define ETH_DMA_OPMODE_TTC_40		0x00010000
+#define ETH_DMA_OPMODE_TTC_256		0x0000c000
+#define ETH_DMA_OPMODE_TTC_192		0x00008000
+#define ETH_DMA_OPMODE_TTC_128		0x00004000
+#define ETH_DMA_OPMODE_TTC_64		0x00000000
+#define ETH_DMA_OPMODE_ST		0x00002000
+#define ETH_DMA_OPMODE_RFD_4K		0x00001800
+#define ETH_DMA_OPMODE_RFD_3K		0x00001000
+#define ETH_DMA_OPMODE_RFD_2K		0x00000800
+#define ETH_DMA_OPMODE_RFD_1K		0x00000000
+#define ETH_DMA_OPMODE_RFA_4K		0x00000600
+#define ETH_DMA_OPMODE_RFA_3K		0x00000400
+#define ETH_DMA_OPMODE_RFA_2K		0x00000200
+#define ETH_DMA_OPMODE_RFA_1K		0x00000000
+#define ETH_DMA_OPMODE_EFC		0x00000100
+#define ETH_DMA_OPMODE_FEF		0x00000080
+#define ETH_DMA_OPMODE_FUF		0x00000040
+#define ETH_DMA_OPMODE_RTC_128		0x00000018
+#define ETH_DMA_OPMODE_RTC_96		0x00000010
+#define ETH_DMA_OPMODE_RTC_32		0x00000008
+#define ETH_DMA_OPMODE_RTC_64		0x00000000
+#define ETH_DMA_OPMODE_OSF		0x00000004
+#define ETH_DMA_OPMODE_SR		0x00000002
+
+/* ETH_DMA_INTEN_REG */
+#define ETH_DMA_INTEN_NIE		0x00010000
+#define ETH_DMA_INTEN_AIE		0x00008000
+#define ETH_DMA_INTEN_ERE		0x00004000
+#define ETH_DMA_INTEN_FBE		0x00002000
+#define ETH_DMA_INTEN_ETE		0x00000400
+#define ETH_DMA_INTEN_RWE		0x00000200
+#define ETH_DMA_INTEN_RSE		0x00000100
+#define ETH_DMA_INTEN_RUE		0x00000080
+#define ETH_DMA_INTEN_RIE		0x00000040
+#define ETH_DMA_INTEN_UNE		0x00000020
+#define ETH_DMA_INTEN_OVE		0x00000010
+#define ETH_DMA_INTEN_TJE		0x00000008
+#define ETH_DMA_INTEN_TUE		0x00000004
+#define ETH_DMA_INTEN_TSE		0x00000002
+#define ETH_DMA_INTEN_TIE		0x00000001
+
+/* ETH_DMA_MISS_FRAME_BOCNT_REG */
+#define ETH_DMA_MISS_FRAME_BOCNT_FIFO		0x10000000
+#define ETH_DMA_MISS_FRAME_BOCNT_APP(v)		(((v) & 0x0ffe0000) >> 17)
+#define ETH_DMA_MISS_FRAME_BOCNT_FRAME		0x00001000
+#define ETH_DMA_MISS_FRAME_BOCNT_HOST(v)	((v) & 0x0000ffff)
+
+/* ETH_DMA_HW_FEATURE_REG */
+#define ETH_DMA_HWFEA_ACTPHYIF_GMII	0x00000000	/* also MII */
+#define ETH_DMA_HWFEA_ACTPHYIF_RGMII	0x10000000
+#define ETH_DMA_HWFEA_ACTPHYIF_SGMII	0x20000000
+#define ETH_DMA_HWFEA_ACTPHYIF_TBI	0x30000000
+#define ETH_DMA_HWFEA_ACTPHYIF_RMII	0x40000000
+#define ETH_DMA_HWFEA_ACTPHYIF_RTBI	0x50000000
+#define ETH_DMA_HWFEA_ACTPHYIF_SMII	0x60000000
+#define ETH_DMA_HWFEA_ACTPHYIF_RevMII	0x70000000
+#define ETH_DMA_HWFEA_ACTPHYIF_MASK	0x70000000
+
+
+/* Receive Descriptor 0 (RDES0) */
+#define ETH_RDES0_OWN			0x80000000
+#define ETH_RDES0_AFM			0x40000000
+#define ETH_RDES0_FL(v)			(((v) & 0x3fff0000) >> 16)
+#define ETH_RDES0_ES			0x00008000
+#define ETH_RDES0_DE			0x00004000
+#define ETH_RDES0_SAF			0x00002000
+#define ETH_RDES0_LE			0x00001000
+#define ETH_RDES0_OE			0x00000800
+#define ETH_RDES0_VLAN			0x00000400
+#define ETH_RDES0_FS			0x00000200
+#define ETH_RDES0_LS			0x00000100
+#define ETH_RDES0_IPC			0x00000080
+#define ETH_RDES0_LC			0x00000040
+#define ETH_RDES0_FT			0x00000020
+#define ETH_RDES0_RWT			0x00000010
+#define ETH_RDES0_RE			0x00000008
+#define ETH_RDES0_DBE			0x00000004
+#define ETH_RDES0_CE			0x00000002
+#define ETH_RDES0_RX			0x00000001
+
+#define ETH_RDES0_COE_MASK		0x000000a1
+#define ETH_RDES0_COE_LENLT600		0x00000000	/* Bit(5:7:0)=>0 IEEE 802.3 type frame Length field is Lessthan 0x0600			*/
+#define ETH_RDES0_COE_UNSUPPORTED	0x00000001	/* Bit(5:7:0)=>1 Payload & Ip header checksum bypassed (unsuppported payload) 		*/
+#define ETH_RDES0_COE_RESERVED		0x00000080	/* Bit(5:7:0)=>2 Reserved						 		*/
+#define ETH_RDES0_COE_CHKBYPASS		0x00000081	/* Bit(5:7:0)=>3 Neither IPv4 nor IPV6. So checksum bypassed 		 		*/
+#define ETH_RDES0_COE_NOCHKERROR	0x00000020	/* Bit(5:7:0)=>4 No IPv4/IPv6 Checksum error detected					*/
+#define ETH_RDES0_COE_PLCHKERROR	0x00000021	/* Bit(5:7:0)=>5 Payload checksum error detected for Ipv4/Ipv6 frames			*/
+#define ETH_RDES0_COE_HDRCHKERROR	0x000000a0	/* Bit(5:7:0)=>6 Ip header checksum error detected for Ipv4 frames			*/
+#define ETH_RDES0_COE_HDRPLCHKERROR	0x000000a1	/* Bit(5:7:0)=>7 Payload & Ip header checksum error detected for Ipv4/Ipv6 frames	*/
+
+/* Receive Descriptor 1 (RDES1) */
+#define ETH_RDES1_DIC			0x80000000
+#define ETH_RDES1_RER			0x02000000
+#define ETH_RDES1_RCH			0x01000000
+#define ETH_RDES1_RBS2(v)		(((v) & 0x003ff800) >> 11)	/* Receive Buffer 2 Size */
+#define ETH_RDES1_RBS1(v)		((v) & 0x000007ff)		/* Receive Buffer 1 Size */
+#define ETH_RDES1_RBS2x(x)		(((x) << 11) & 0x003ff800)	/* Receive Buffer 2 Size */
+#define ETH_RDES1_RBS1x(x)		((x) & 0x000007ff)		/* Receive Buffer 1 Size */
+
+/* Transmit Descriptor 0 (TDES0) */
+#define ETH_TDES0_OWN			0x80000000
+#define ETH_TDES0_TTSS			0x00020000
+#define ETH_TDES0_IHE			0x00010000
+#define ETH_TDES0_ES			0x00008000
+#define ETH_TDES0_JT			0x00004000
+#define ETH_TDES0_FF			0x00002000
+#define ETH_TDES0_PCE			0x00001000
+#define ETH_TDES0_LCA			0x00000800
+#define ETH_TDES0_NC			0x00000400
+#define ETH_TDES0_LCO			0x00000200
+#define ETH_TDES0_EC			0x00000100
+#define ETH_TDES0_VF			0x00000080
+#define ETH_TDES0_CC(v)			(((v) & 0x00000078) >> 3)
+#define ETH_TDES0_ED			0x00000004
+#define ETH_TDES0_UF			0x00000002
+#define ETH_TDES0_DB			0x00000001
+#define ETH_TDES0_ES_MASK		(ETH_TDES0_UF | ETH_TDES0_ED | \
+					ETH_TDES0_EC | ETH_TDES0_LCO | \
+					ETH_TDES0_NC | ETH_TDES0_LCA | \
+					ETH_TDES0_FF | ETH_TDES0_JT | \
+					ETH_TDES0_ES)
+
+/* Transmit Descriptor 1 (TDES1) */
+#define ETH_TDES1_IC			0x80000000
+#define ETH_TDES1_LS			0x40000000
+#define ETH_TDES1_FS			0x20000000
+#define ETH_TDES1_CIC_TUI		0x10000000
+#define ETH_TDES1_CIC_HDR		0x08000000
+#define ETH_TDES1_DC			0x04000000
+#define ETH_TDES1_TER			0x02000000
+#define ETH_TDES1_TCH			0x01000000
+#define ETH_TDES1_DP			0x00800000
+#define ETH_TDES1_TBS2(v)		(((v) & 0x003ff800) >> 11)
+#define ETH_TDES1_TBS1(v)		((v) & 0x000007ff)
+#define ETH_TDES1_TBS2x(x)		(((x) << 11) & 0x003ff800)
+#define ETH_TDES1_TBS1x(x)		((x) & 0x000007ff)
+
+/* ==========================================================================*/
+#define ETH_ENHANCED_RDES0_OWN		0x80000000
+#define ETH_ENHANCED_RDES0_AFM		0x40000000
+#define ETH_ENHANCED_RDES0_FL(v)	(((v) & 0x3FFF0000) >> 16)
+#define ETH_ENHANCED_RDES0_ES		0x00008000
+#define ETH_ENHANCED_RDES0_DE		0x00004000
+#define ETH_ENHANCED_RDES0_SAF		0x00002000
+#define ETH_ENHANCED_RDES0_LE		0x00001000
+#define ETH_ENHANCED_RDES0_OE		0x00000800
+#define ETH_ENHANCED_RDES0_VLAN		0x00000400
+#define ETH_ENHANCED_RDES0_FS		0x00000200
+#define ETH_ENHANCED_RDES0_LS		0x00000100
+#define ETH_ENHANCED_RDES0_IPC		0x00000080
+#define ETH_ENHANCED_RDES0_LC		0x00000040
+#define ETH_ENHANCED_RDES0_FT		0x00000020
+#define ETH_ENHANCED_RDES0_RWT		0x00000010
+#define ETH_ENHANCED_RDES0_RE		0x00000008
+#define ETH_ENHANCED_RDES0_DBE		0x00000004
+#define ETH_ENHANCED_RDES0_CE		0x00000002
+#define ETH_ENHANCED_RDES0_RX		0x00000001
+
+/* Definition for ethernet enhanced descriptor. */
+#define ETH_ENHANCED_RDES1_DIC		0x80000000
+#define ETH_ENHANCED_RDES1_RER		0x00008000
+#define ETH_ENHANCED_RDES1_RCH		0x00004000
+#define ETH_ENHANCED_RDES1_RBS2(v)	(((v) & 0x1FFF0000) >> 16)
+#define ETH_ENHANCED_RDES1_RBS1(v)	((v) & 0x00001FFF)
+#define ETH_ENHANCED_RDES1_RBS2x(x)	(((x) << 16) & 0x1FFF0000)
+#define ETH_ENHANCED_RDES1_RBS1x(x)	((x) & 0x00001FFF)
+
+#define ETH_ENHANCED_TDES0_OWN		0x80000000
+#define ETH_ENHANCED_TDES0_IC		0x40000000
+#define ETH_ENHANCED_TDES0_LS		0x20000000
+#define ETH_ENHANCED_TDES0_FS		0x10000000
+#define ETH_ENHANCED_TDES0_DC		0x08000000
+#define ETH_ENHANCED_TDES0_DP		0x04000000
+#define ETH_ENHANCED_TDES0_CRCR		0x01000000
+#define ETH_ENHANCED_TDES0_CIC_V2	0x00C00000
+#define ETH_ENHANCED_TDES0_CIC_V1	0x00800000
+#define ETH_ENHANCED_TDES0_CIC_HDR	0x00400000
+#define ETH_ENHANCED_TDES0_TER		0x00200000
+#define ETH_ENHANCED_TDES0_TCH		0x00100000
+#define ETH_ENHANCED_TDES0_TTSS		0x00020000
+#define ETH_ENHANCED_TDES0_IHE		0x00010000
+#define ETH_ENHANCED_TDES0_ES		0x00008000
+#define ETH_ENHANCED_TDES0_JT		0x00004000
+#define ETH_ENHANCED_TDES0_FF		0x00002000
+#define ETH_ENHANCED_TDES0_IPE		0x00001000
+#define ETH_ENHANCED_TDES0_LCA		0x00000800
+#define ETH_ENHANCED_TDES0_NC		0x00000400
+#define ETH_ENHANCED_TDES0_LCO		0x00000200
+#define ETH_ENHANCED_TDES0_EC		0x00000100
+#define ETH_ENHANCED_TDES0_VF		0x00000080
+#define ETH_ENHANCED_TDES0_CC(v)	(((v) & 0x00000078) >> 3)
+#define ETH_ENHANCED_TDES0_ED		0x00000004
+#define ETH_ENHANCED_TDES0_UF		0x00000002
+#define ETH_ENHANCED_TDES0_DB		0x00000001
+#define ETH_ENHANCED_TDES0_ES_MASK	(ETH_ENHANCED_TDES0_UF | \
+					ETH_ENHANCED_TDES0_ED | \
+					ETH_ENHANCED_TDES0_EC | \
+					ETH_ENHANCED_TDES0_LCO | \
+					ETH_ENHANCED_TDES0_NC | \
+					ETH_ENHANCED_TDES0_LCA | \
+					ETH_ENHANCED_TDES0_FF | \
+					ETH_ENHANCED_TDES0_JT | \
+					ETH_ENHANCED_TDES0_ES)
+
+#define ETH_ENHANCED_TDES1_SAIC_MAC1	0x80000000
+#define ETH_ENHANCED_TDES1_SAIC_REPLACE	0x40000000
+#define ETH_ENHANCED_TDES1_SAIC_INCLUDE	0x20000000
+#define ETH_ENHANCED_TDES1_TBS2(v)	(((v) & 0x1FFF0000) >> 16)
+#define ETH_ENHANCED_TDES1_TBS1(v)	((v) & 0x00001FFF)
+#define ETH_ENHANCED_TDES1_TBS2x(x)	(((x) << 16) & 0x1FFF0000)
+#define ETH_ENHANCED_TDES1_TBS1x(x)	((x) & 0x00001FFF)
+
 /* ==========================================================================*/
 #ifndef __ASM__
-/* ==========================================================================*/
-
+/* ==========================================================================*/
+
 extern int amboot_bsp_eth_init_pre(void *dev)
 	__attribute__ ((weak));
 extern int amboot_bsp_eth_init_post(void *dev)
-	__attribute__ ((weak));
+	__attribute__ ((weak));
 /* ==========================================================================*/
-#endif
+#endif
 /* ==========================================================================*/
-
-#endif
-
+
+#endif
+
diff --git a/include/ambhw/gic.h b/include/ambhw/gic.h
new file mode 100644
index 0000000..89411ed
--- /dev/null
+++ b/include/ambhw/gic.h
@@ -0,0 +1,550 @@
+
+/**
+ * gic.h
+ *
+ * History:
+ *    2015/12/1 - Jorney(qtu@ambarella.com) created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __AMBOOT_GIC_H
+#define __AMBOOT_GIC_H
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+#if (CHIP_REV == S5) || (CHIP_REV == S5L)
+#define GIC_BASE		0xF0040000
+#else
+#define GIC_BASE		0xF3000000
+#endif
+
+#define GICD_OFFSET			0x1000
+#define GICC_OFFSET			0x2000
+
+#define GICD_BASE			(GIC_BASE + GICD_OFFSET)
+#define GICC_BASE			(GIC_BASE + GICC_OFFSET)
+#define GICD_REG(x)			(GICD_BASE + (x))
+#define GICC_REG(x)			(GICC_BASE + (x))
+
+
+/* GIC distribute */
+#define GICD_CTLR			0x0000
+#define GICD_TYPER			0x0004
+#define GICD_IIDR			0x0008
+#define GICD_STATUSR			0x0010
+#define GICD_SETSPI_NSR			0x0040
+#define GICD_CLRSPI_NSR			0x0048
+#define GICD_SETSPI_SR			0x0050
+#define GICD_CLRSPI_SR			0x0058
+#define GICD_SEIR			0x0068
+#define GICD_IGROUPR			0x0080
+#define GICD_ISENABLER			0x0100
+#define GICD_ICENABLER			0x0180
+#define GICD_ISPENDR			0x0200
+#define GICD_ICPENDR			0x0280
+#define GICD_ISACTIVER			0x0300
+#define GICD_ICACTIVER			0x0380
+#define GICD_IPRIORITYR			0x0400
+#define GICD_ICFGR			0x0C00
+#define GICD_IGRPMODR			0x0D00
+#define GICD_NSACR			0x0E00
+#define GICD_IROUTER			0x6000
+#define GICD_IDREGS			0xFFD0
+#define GICD_PIDR2			0xFFE8
+#define GICD_ITARGETSR			0x0800
+#define GICD_SGIR			0x0F00
+#define GICD_CPENDSGIR			0x0F10
+#define GICD_SPENDSGIR			0x0F20
+
+/* GIC cpu interface */
+#define GICC_CTRL			0x00
+#define GICC_PMR			0x04
+#define GICC_BPR			0x08
+#define GICC_IAR			0x0c
+#define GICC_EOIR			0x10
+#define GICC_RPR			0x14
+#define GICC_HPPIR			0x18
+#define GICC_ABPR			0x1c
+#define GICC_AIAR			0x20
+#define GICC_AEOIR			0x24
+#define GICC_AHPPIR			0x28
+#define GICC_APRN			0xd0
+#define GICC_IIDR			0xfc
+
+/* ==========================================================================*/
+#define ICC_CTLR_EL3			S3_6_C12_C12_4
+#define ICC_SRE_EL3			S3_6_C12_C12_5
+#define ICC_IGRPEN1_EL3			S3_6_C12_C12_7
+
+/* ==========================================================================*/
+#define SGI_INT_VEC(x)			(x)
+#define PPI_INT_VEC(x)			(x)
+#define SPI_INT_VEC(x)			((x) + 32)
+
+/* ==========================================================================*/
+#if (CHIP_REV == S5)
+#define AXI_SOFT_IRQ0			SPI_INT_VEC(0)
+#define AXI_SOFT_IRQ1			SPI_INT_VEC(1)
+#define AXI_SOFT_IRQ2			SPI_INT_VEC(2)
+#define AXI_SOFT_IRQ3			SPI_INT_VEC(3)
+#define AXI_SOFT_IRQ4			SPI_INT_VEC(4)
+#define AXI_SOFT_IRQ5			SPI_INT_VEC(5)
+#define AXI_SOFT_IRQ6			SPI_INT_VEC(6)
+#define TIMER1_IRQ			SPI_INT_VEC(7)
+#define TIMER2_IRQ			SPI_INT_VEC(8)
+#define TIMER3_IRQ			SPI_INT_VEC(9)
+#define TIMER4_IRQ			SPI_INT_VEC(10)
+#define TIMER5_IRQ			SPI_INT_VEC(11)
+#define TIMER6_IRQ			SPI_INT_VEC(12)
+#define TIMER7_IRQ			SPI_INT_VEC(13)
+#define TIMER8_IRQ			SPI_INT_VEC(14)
+#define PMU_IRQ				SPI_INT_VEC(15)
+#define AXI_SOFT_IRQ7			SPI_INT_VEC(16)
+#define AXI_SOFT_IRQ8			SPI_INT_VEC(17)
+#define AXI_SOFT_IRQ9			SPI_INT_VEC(18)
+#define AXI_SOFT_IRQ10			SPI_INT_VEC(19)
+#define AXI_SOFT_IRQ11			SPI_INT_VEC(20)
+#define AXI_SOFT_IRQ12			SPI_INT_VEC(21)
+#define AXI_SOFT_IRQ13			SPI_INT_VEC(22)
+#define TIMER11_IRQ			SPI_INT_VEC(23)
+#define TIMER12_IRQ			SPI_INT_VEC(24)
+#define TIMER13_IRQ			SPI_INT_VEC(25)
+#define TIMER14_IRQ			SPI_INT_VEC(26)
+#define TIMER15_IRQ			SPI_INT_VEC(27)
+#define TIMER16_IRQ			SPI_INT_VEC(28)
+#define TIMER17_IRQ			SPI_INT_VEC(29)
+#define TIMER18_IRQ			SPI_INT_VEC(30)
+#define PMU1_IRQ			SPI_INT_VEC(31)
+
+#define IDSP_VIN_STAT_IRQ		SPI_INT_VEC(32)
+#define IDSP_VIN_MVSYNC_IRQ		SPI_INT_VEC(33)
+#define IDSP_VIN_VSYNC_IRQ		SPI_INT_VEC(34)
+#define IDSP_VIN_SOF_IRQ		SPI_INT_VEC(35)
+#define IDSP_VIN_DVSYNC_IRQ		SPI_INT_VEC(36)
+#define IDSP_VIN_LAST_PIXEL_IRQ		SPI_INT_VEC(37)
+#define IDSP_PIP_STAT_IRQ		SPI_INT_VEC(38)
+#define IDSP_PIP_MVSYNC_IRQ		SPI_INT_VEC(39)
+#define IDSP_PIP_VSYNC_IRQ		SPI_INT_VEC(40)
+#define IDSP_PIP_SOF_IRQ		SPI_INT_VEC(41)
+#define IDSP_PIP_DVSYNC_IRQ		SPI_INT_VEC(42)
+#define IDSP_PIP_LAST_PIXEL_IRQ		SPI_INT_VEC(43)
+#define VOUT_TV_SYNC_IRQ		SPI_INT_VEC(44)
+#define VOUT_LCD_SYNC_IRQ		SPI_INT_VEC(45)
+#define CODE_VDSP_0_IRQ			SPI_INT_VEC(46)
+#define CODE_VDSP_1_IRQ			SPI_INT_VEC(47)
+#define CODE_VDSP_2_IRQ			SPI_INT_VEC(48)
+#define CODE_VDSP_3_IRQ			SPI_INT_VEC(49)
+#define CODE_VDSP_4_IRQ			SPI_INT_VEC(50)
+#define CODE_VDSP_5_IRQ			SPI_INT_VEC(51)
+#define CODE_VDSP_6_IRQ			SPI_INT_VEC(52)
+#define CODE_VDSP_7_IRQ			SPI_INT_VEC(53)
+#define VIN_IRQ				SPI_INT_VEC(54)
+#define ORC_VOUT0_IRQ			SPI_INT_VEC(55)
+#define VOUT_IRQ			SPI_INT_VEC(56)
+#define VDSP_ORC_BKPT_IRQ		SPI_INT_VEC(57)
+#define VDSP_EORC0_BKPT_IRQ		SPI_INT_VEC(58)
+#define VDSP_DORC_BRPT_IRQ		SPI_INT_VEC(59)
+#define VDSP_PIP_CODING_IRQ		SPI_INT_VEC(60)
+#define USB3_IRQ			SPI_INT_VEC(61)
+#define TIMER10_IRQ			SPI_INT_VEC(62)
+#define TIMER9_IRQ			SPI_INT_VEC(63)
+
+#define CANC_IRQ			SPI_INT_VEC(64)
+#define ETH_IRQ				SPI_INT_VEC(65)
+#define USB_EHCI_IRQ			SPI_INT_VEC(66)
+#define USB_OHCI_IRQ			SPI_INT_VEC(67)
+#define USBC_IRQ			SPI_INT_VEC(68)
+#define DMA_IRQ				SPI_INT_VEC(69)
+#define DMA_FIOS_IRQ			SPI_INT_VEC(70)
+#define FIOS_ECC_IRQ			SPI_INT_VEC(71)
+#define FIOCMD_IRQ			SPI_INT_VEC(72)
+#define FIODMA_IRQ			SPI_INT_VEC(73)
+#define GDMA_IRQ			SPI_INT_VEC(74)
+#define SDXC_IRQ			SPI_INT_VEC(75)
+#define SDIO_IRQ			SPI_INT_VEC(76)
+#define SD_IRQ				SPI_INT_VEC(77)
+#define NOR_SPI				SPI_INT_VEC(78)
+#define SSI_MASTER1_IRQ			SPI_INT_VEC(79)
+#define SSI_MASTER0_IRQ			SPI_INT_VEC(80)
+#define SSI_SLAVE_IRQ			SPI_INT_VEC(81)
+#define UART1_IRQ			SPI_INT_VEC(82)
+#define IDC2_IRQ			SPI_INT_VEC(83)
+#define IDC1_IRQ			SPI_INT_VEC(84)
+#define IDC0_IRQ			SPI_INT_VEC(85)
+#define IRIF_IRQ			SPI_INT_VEC(86)
+#define I2STX_IRQ			SPI_INT_VEC(87)
+#define I2SRX_IRQ			SPI_INT_VEC(88)
+#define IDC_SLAVE_IRQ			SPI_INT_VEC(89)
+#define HIF_ARM2_IRQ			SPI_INT_VEC(90)
+#define HIF_ARM1_IRQ			SPI_INT_VEC(91)
+#define TS_CH1_RX_IRQ			SPI_INT_VEC(92)
+#define TS_CH0_RX_IRQ			SPI_INT_VEC(93)
+#define TS_CH1_TX_IRQ			SPI_INT_VEC(94)
+#define TS_CH0_TX_IRQ			SPI_INT_VEC(95)
+
+#define USBVBUS_IRQ			SPI_INT_VEC(96)
+#define USB_DIGITAL_ID_CHANGE_IRQ	SPI_INT_VEC(97)
+#define USB_CONNECT_CHANGE_IRQ		SPI_INT_VEC(98)
+#define USB_CHARGE_IRQ			SPI_INT_VEC(99)
+#define SD2CD_IRQ			SPI_INT_VEC(100)
+#define SD1CD_IRQ			SPI_INT_VEC(101)
+#define SD0CD_IRQ			SPI_INT_VEC(102)
+#define ADC_LEVEL_IRQ			SPI_INT_VEC(103)
+#define HDMI_IRQ			SPI_INT_VEC(104)
+#define WDT_IRQ				SPI_INT_VEC(105)
+#define SLIM_IRQ			SPI_INT_VEC(106)
+#define ETH_PMT_IRQ			SPI_INT_VEC(107)
+#define UART0_IRQ			SPI_INT_VEC(108)
+#define MOTOR_IRQ			SPI_INT_VEC(109)
+/* SPI_INT_VEC(110) ~ SPI_INT_VEC(112) are NULL */
+#define L2CC_ERR_IRQ			SPI_INT_VEC(113)
+#define L2CC_INTR_IRQ			SPI_INT_VEC(114)
+#define L2CC_INTR1_IRQ			SPI_INT_VEC(115)
+#define AXI_SWI_IRQ			SPI_INT_VEC(116)
+#define AXI_SWI1_IRQ			SPI_INT_VEC(117)
+/* SPI_INT_VEC(118) ~ SPI_INT_VEC(119) are NULL */
+#define GPIO4_IRQ			SPI_INT_VEC(120)
+#define GPIO3_IRQ			SPI_INT_VEC(121)
+#define GPIO2_IRQ			SPI_INT_VEC(122)
+#define GPIO1_IRQ			SPI_INT_VEC(123)
+#define GPIO0_IRQ			SPI_INT_VEC(124)
+#define USB3_BC_IRQ			SPI_INT_VEC(125)
+#define TIMER20_IRQ			SPI_INT_VEC(126)
+#define TIMER19_IRQ			SPI_INT_VEC(127)
+
+#define CRYPTO0_MD5_IRQ			SPI_INT_VEC(128)
+#define CRYPTO1_MD5_IRQ			SPI_INT_VEC(129)
+#define CRYPTO2_MD5_IRQ			SPI_INT_VEC(130)
+#define CRYPTO3_MD5_IRQ			SPI_INT_VEC(131)
+#define CRYPTO0_DES_IRQ			SPI_INT_VEC(132)
+#define CRYPTO1_DES_IRQ			SPI_INT_VEC(133)
+#define CRYPTO2_DES_IRQ			SPI_INT_VEC(134)
+#define CRYPTO3_DES_IRQ			SPI_INT_VEC(135)
+#define CRYPTO0_AES_IRQ			SPI_INT_VEC(136)
+#define CRYPTO1_AES_IRQ			SPI_INT_VEC(137)
+#define CRYPTO2_AES_IRQ			SPI_INT_VEC(138)
+#define CRYPTO3_AES_IRQ			SPI_INT_VEC(139)
+#define CRYPTO0_SHA1_IRQ		SPI_INT_VEC(140)
+#define CRYPTO1_SHA1_IRQ		SPI_INT_VEC(141)
+#define CRYPTO2_SHA1_IRQ		SPI_INT_VEC(142)
+#define CRYPTO3_SHA1_IRQ		SPI_INT_VEC(143)
+#define IDSP_PIP3_ASYNC_IRQ		SPI_INT_VEC(144)
+#define IDSP_PIP3_STAT_IRQ		SPI_INT_VEC(145)
+#define IDSP_PIP3_SOF_IRQ		SPI_INT_VEC(146)
+#define IDSP_PIP3_LAST_PIXEL_IRQ	SPI_INT_VEC(147)
+#define IDSP_PIP3_DVSYNC_IRQ		SPI_INT_VEC(148)
+#define IDSP_PIP2_ASYNC_IRQ		SPI_INT_VEC(149)
+#define IDSP_PIP2_STAT_IRQ		SPI_INT_VEC(150)
+#define IDSP_PIP2_SOF_IRQ		SPI_INT_VEC(151)
+#define IDSP_PIP2_LAST_PIXEL_IRQ	SPI_INT_VEC(152)
+#define IDSP_PIP2_DVSYNC_IRQ		SPI_INT_VEC(153)
+#define FDET_IRQ			SPI_INT_VEC(154)
+#define CODE_PIP3_IRQ			SPI_INT_VEC(155)
+#define CODE_PIP2_IRQ			SPI_INT_VEC(156)
+#define PWC_ALRAM			SPI_INT_VEC(157)
+
+#define NR_IRQS				SPI_INT_VEC(158)
+
+#elif (CHIP_REV == S5L)
+#define TIMER1_IRQ			SPI_INT_VEC(0)
+#define TIMER2_IRQ			SPI_INT_VEC(1)
+#define TIMER3_IRQ			SPI_INT_VEC(2)
+#define TIMER4_IRQ			SPI_INT_VEC(3)
+#define TIMER5_IRQ			SPI_INT_VEC(4)
+#define TIMER6_IRQ			SPI_INT_VEC(5)
+#define TIMER7_IRQ			SPI_INT_VEC(6)
+#define AXI_SOFT_IRQ0			SPI_INT_VEC(7)
+#define AXI_SOFT_IRQ1			SPI_INT_VEC(8)
+#define AXI_SOFT_IRQ2			SPI_INT_VEC(9)
+#define AXI_SOFT_IRQ3			SPI_INT_VEC(10)
+#define AXI_SOFT_IRQ4			SPI_INT_VEC(11)
+#define AXI_SOFT_IRQ5			SPI_INT_VEC(12)
+#define AXI_SOFT_IRQ6			SPI_INT_VEC(13)
+#define AXI_SOFT_IRQ7			SPI_INT_VEC(14)
+#define AXI_SOFT_IRQ8			SPI_INT_VEC(15)
+#define AXI_SOFT_IRQ9			SPI_INT_VEC(16)
+#define AXI_SOFT_IRQ10			SPI_INT_VEC(17)
+#define AXI_SOFT_IRQ11			SPI_INT_VEC(18)
+#define AXI_SOFT_IRQ12			SPI_INT_VEC(19)
+#define AXI_SOFT_IRQ13			SPI_INT_VEC(20)
+#define AXI_SWI_IRQ			SPI_INT_VEC(21)
+#define AXI_SWI1_IRQ			SPI_INT_VEC(22)
+#define PMU_IRQ				SPI_INT_VEC(23)
+#define PMU1_IRQ			SPI_INT_VEC(24)
+#define L2CC_INTR_IRQ			SPI_INT_VEC(25)
+#define L2CC_INTR1_IRQ			SPI_INT_VEC(26)
+#define AXI_EXTERR_IRQ			SPI_INT_VEC(27)
+#define GPIO4_IRQ			SPI_INT_VEC(28)
+/* SPI_INT_VEC(29) ~ SPI_INT_VEC(30) are NULL */
+#define AXI_INTERR_IRQ			SPI_INT_VEC(31)
+
+#define IDSP_VIN_MVSYNC_IRQ		SPI_INT_VEC(32)
+#define IDSP_VIN_VSYNC_IRQ		SPI_INT_VEC(33)
+#define IDSP_VIN_SOF_IRQ		SPI_INT_VEC(34)
+#define IDSP_VIN_DVSYNC_IRQ		SPI_INT_VEC(35)
+#define IDSP_VIN_LAST_PIXEL_IRQ		SPI_INT_VEC(36)
+#define GDMA_IRQ			SPI_INT_VEC(37)
+#define IDSP_PIP_MVSYNC_IRQ		SPI_INT_VEC(38)
+#define IDSP_PIP_VSYNC_IRQ		SPI_INT_VEC(39)
+#define IDSP_PIP_SOF_IRQ		SPI_INT_VEC(40)
+#define IDSP_PIP_DVSYNC_IRQ		SPI_INT_VEC(41)
+#define IDSP_PIP_LAST_PIXEL_IRQ		SPI_INT_VEC(42)
+#define VOUT_TV_SYNC_IRQ		SPI_INT_VEC(43)
+#define VOUT_LCD_SYNC_IRQ		SPI_INT_VEC(44)
+#define CODE_VDSP_0_IRQ			SPI_INT_VEC(45)
+#define CODE_VDSP_1_IRQ			SPI_INT_VEC(46)
+#define CODE_VDSP_2_IRQ			SPI_INT_VEC(47)
+#define CODE_VDSP_3_IRQ			SPI_INT_VEC(48)
+#define GPIO3_IRQ			SPI_INT_VEC(49)
+#define GPIO2_IRQ			SPI_INT_VEC(50)
+#define GPIO1_IRQ			SPI_INT_VEC(51)
+#define GPIO0_IRQ			SPI_INT_VEC(52)
+#define VIN_IRQ				SPI_INT_VEC(53)
+#define ORC_VOUT0_IRQ			SPI_INT_VEC(54)
+#define VOUT_IRQ			SPI_INT_VEC(55)
+#define VDSP_PIP_CODING_IRQ		SPI_INT_VEC(56)
+#define ADC_LEVEL_IRQ			SPI_INT_VEC(57)
+#define HDMI_IRQ			SPI_INT_VEC(58)
+#define WDT_IRQ				SPI_INT_VEC(59)
+#define ETH_PMT_IRQ			SPI_INT_VEC(60)
+#define UART0_IRQ			SPI_INT_VEC(61)
+#define MOTOR_IRQ			SPI_INT_VEC(62)
+#define TIMER8_IRQ			SPI_INT_VEC(63)
+
+#define PWC_ALRAM			SPI_INT_VEC(64)
+#define ETH_IRQ				SPI_INT_VEC(65)
+#define USB_EHCI_IRQ			SPI_INT_VEC(66)
+#define USB_OHCI_IRQ			SPI_INT_VEC(67)
+#define USBC_IRQ			SPI_INT_VEC(68)
+#define DMA_IRQ				SPI_INT_VEC(69)
+#define DMA_FIOS_IRQ			SPI_INT_VEC(70)
+#define FIOS_ECC_IRQ			SPI_INT_VEC(71)
+#define FIOCMD_IRQ			SPI_INT_VEC(72)
+#define FIODMA_IRQ			SPI_INT_VEC(73)
+#define SDXC_IRQ			SPI_INT_VEC(74)
+#define SD_IRQ				SPI_INT_VEC(75)
+#define NOR_SPI				SPI_INT_VEC(76)
+#define SSI_MASTER1_IRQ			SPI_INT_VEC(77)
+#define SSI_MASTER0_IRQ			SPI_INT_VEC(78)
+#define SSI_SLAVE_IRQ			SPI_INT_VEC(79)
+#define UART1_IRQ			SPI_INT_VEC(80)
+#define IDC2_IRQ			SPI_INT_VEC(81)
+#define IDC1_IRQ			SPI_INT_VEC(82)
+#define IDC0_IRQ			SPI_INT_VEC(83)
+#define IRIF_IRQ			SPI_INT_VEC(84)
+#define I2STX_IRQ			SPI_INT_VEC(85)
+#define I2SRX_IRQ			SPI_INT_VEC(86)
+#define USBVBUS_IRQ			SPI_INT_VEC(87)
+#define USB_DIGITAL_ID_CHANGE_IRQ	SPI_INT_VEC(88)
+#define USB_CONNECT_CHANGE_IRQ		SPI_INT_VEC(89)
+#define USB_CHARGE_IRQ			SPI_INT_VEC(90)
+#define SDXC_CD_IRQ			SPI_INT_VEC(91)
+#define SD_CD_IRQ			SPI_INT_VEC(92)
+#define UART2_IRQ			SPI_INT_VEC(93)
+#define SSI_MASTER2_IRQ			SPI_INT_VEC(94)
+#define IDC3_IRQ			SPI_INT_VEC(95)
+
+#define NR_IRQS				SPI_INT_VEC(96)
+
+#elif (CHIP_REV == CV1)
+#define AXI0_EXTERR_IRQ			SPI_INT_VEC(2)
+#define AXI1_EXTERR_IRQ			SPI_INT_VEC(3)
+#define PMU0_0_IRQ			SPI_INT_VEC(4)
+#define PMU0_1_IRQ			SPI_INT_VEC(5)
+#define L2CC0_INTR_IRQ			SPI_INT_VEC(6)
+#define L2CC0_INTR1_IRQ			SPI_INT_VEC(7)
+#define PMU1_0_IRQ			SPI_INT_VEC(8)
+#define PMU1_1_IRQ			SPI_INT_VEC(9)
+#define L2CC1_INTR_IRQ			SPI_INT_VEC(10)
+#define L2CC1_INTR1_IRQ			SPI_INT_VEC(11)
+#define AXI0_INTERR_IRQ			SPI_INT_VEC(12)
+#define AXI1_INTERR_IRQ			SPI_INT_VEC(13)
+#define ADC_LEVEL_IRQ			SPI_INT_VEC(14)
+#define MOTOR_IRQ			SPI_INT_VEC(15)
+#define IDC0_IRQ			SPI_INT_VEC(16)
+#define IDC1_IRQ			SPI_INT_VEC(17)
+#define IDC2_IRQ			SPI_INT_VEC(18)
+#define IDC3_IRQ			SPI_INT_VEC(19)
+#define IDCS_IRQ			SPI_INT_VEC(20)
+#define IRIF_IRQ			SPI_INT_VEC(21)
+#define UART0_IRQ			SPI_INT_VEC(22)
+#define TIMER1_IRQ			SPI_INT_VEC(23)
+#define TIMER2_IRQ			SPI_INT_VEC(24)
+#define TIMER3_IRQ			SPI_INT_VEC(25)
+#define TIMER4_IRQ			SPI_INT_VEC(26)
+#define TIMER5_IRQ			SPI_INT_VEC(27)
+#define TIMER6_IRQ			SPI_INT_VEC(28)
+#define TIMER7_IRQ			SPI_INT_VEC(29)
+#define TIMER8_IRQ			SPI_INT_VEC(30)
+#define TIMER9_IRQ			SPI_INT_VEC(31)
+
+#define TIMER10_IRQ			SPI_INT_VEC(32)
+#define TIMER11_IRQ			SPI_INT_VEC(33)
+#define TIMER12_IRQ			SPI_INT_VEC(34)
+#define TIMER13_IRQ			SPI_INT_VEC(35)
+#define TIMER14_IRQ			SPI_INT_VEC(36)
+#define TIMER15_IRQ			SPI_INT_VEC(37)
+#define TIMER16_IRQ			SPI_INT_VEC(38)
+#define TIMER17_IRQ			SPI_INT_VEC(39)
+#define TIMER18_IRQ			SPI_INT_VEC(40)
+#define TIMER19_IRQ			SPI_INT_VEC(41)
+#define TIMER20_IRQ			SPI_INT_VEC(42)
+#define WDT_IRQ				SPI_INT_VEC(43)
+#define GPIO0_IRQ			SPI_INT_VEC(44)
+#define GPIO1_IRQ			SPI_INT_VEC(45)
+#define GPIO2_IRQ			SPI_INT_VEC(46)
+#define GPIO3_IRQ			SPI_INT_VEC(47)
+#define GPIO4_IRQ			SPI_INT_VEC(48)
+#define GPIO5_IRQ			SPI_INT_VEC(49)
+#define GPIO6_IRQ			SPI_INT_VEC(50)
+#define USB_DIGITAL_ID_CHANGE_IRQ	SPI_INT_VEC(51)
+#define USBVBUS_IRQ			SPI_INT_VEC(52)
+#define USB_CONNECT_CHANGE_IRQ		SPI_INT_VEC(53)
+#define USB_CHARGE_IRQ			SPI_INT_VEC(54)
+#define SDXC_CD_IRQ			SPI_INT_VEC(55)
+#define SD_CD_IRQ			SPI_INT_VEC(56)
+#define ETH_PMT_IRQ			SPI_INT_VEC(57)
+#define ETH_IRQ				SPI_INT_VEC(58)
+#define UART0_AHB_IRQ			SPI_INT_VEC(59)
+#define UART1_AHB_IRQ			SPI_INT_VEC(60)
+#define UART2_AHB_IRQ			SPI_INT_VEC(61)
+#define UART3_AHB_IRQ			SPI_INT_VEC(62)
+#define UART4_AHB_IRQ			SPI_INT_VEC(63)
+
+#define UART5_AHB_IRQ			SPI_INT_VEC(64)
+#define USB_EHCI_IRQ			SPI_INT_VEC(65)
+#define USB_OHCI_IRQ			SPI_INT_VEC(66)
+#define USBC_IRQ			SPI_INT_VEC(67)
+#define FIO_IRQ				SPI_INT_VEC(68)
+#define FIO_ECC_IRQ			SPI_INT_VEC(69)
+#define GDMA_IRQ			SPI_INT_VEC(70)
+#define SDXC_IRQ			SPI_INT_VEC(71)
+#define SD_IRQ				SPI_INT_VEC(72)
+#define NOR_SPI				SPI_INT_VEC(73)
+#define SSI_MASTER0_IRQ			SPI_INT_VEC(74)
+#define SSI_MASTER1_IRQ			SPI_INT_VEC(75)
+#define SSI_MASTER2_IRQ			SPI_INT_VEC(76)
+#define SSI_MASTER3_IRQ			SPI_INT_VEC(77)
+#define SSI_MASTER4_IRQ			SPI_INT_VEC(78)
+#define SSI_MASTER5_IRQ			SPI_INT_VEC(79)
+#define SSI_SLAVE_IRQ			SPI_INT_VEC(80)
+#define I2STX_IRQ			SPI_INT_VEC(81)
+#define I2SRX_IRQ			SPI_INT_VEC(82)
+#define DMA0_IRQ			SPI_INT_VEC(83)
+#define DMA1_IRQ			SPI_INT_VEC(84)
+#define HDMI_IRQ			SPI_INT_VEC(85)
+#define CANC0_IRQ			SPI_INT_VEC(86)
+#define CANC1_IRQ			SPI_INT_VEC(87)
+#define VOUT_TV_SYNC_IRQ		SPI_INT_VEC(88)
+#define VOUT_LCD_SYNC_IRQ		SPI_INT_VEC(89)
+#define RNG_IRQ				SPI_INT_VEC(90)
+#define AXI_SOFT_IRQ0			SPI_INT_VEC(91)
+#define AXI_SOFT_IRQ1			SPI_INT_VEC(92)
+#define AXI_SOFT_IRQ2			SPI_INT_VEC(93)
+#define AXI_SOFT_IRQ3			SPI_INT_VEC(94)
+#define AXI_SOFT_IRQ4			SPI_INT_VEC(95)
+
+#define AXI_SOFT_IRQ5			SPI_INT_VEC(96)
+#define AXI_SOFT_IRQ6			SPI_INT_VEC(97)
+#define AXI_SOFT_IRQ7			SPI_INT_VEC(98)
+#define AXI_SOFT_IRQ8			SPI_INT_VEC(99)
+#define AXI_SOFT_IRQ9			SPI_INT_VEC(100)
+#define AXI_SOFT_IRQ10			SPI_INT_VEC(101)
+#define AXI_SOFT_IRQ11			SPI_INT_VEC(102)
+#define AXI_SOFT_IRQ12			SPI_INT_VEC(103)
+#define AXI_SOFT_IRQ13			SPI_INT_VEC(104)
+#define DRAM_ERROR_IRQ			SPI_INT_VEC(105)
+#define VP0_IRQ				SPI_INT_VEC(106)
+#define VP1_IRQ				SPI_INT_VEC(107)
+#define ROLLING_SHUTTER_IRQ		SPI_INT_VEC(108)
+#define FDET_IRQ			SPI_INT_VEC(109)
+#define IDSP_VIN_MVSYNC_IRQ		SPI_INT_VEC(110)
+#define IDSP_VIN_VSYNC_IRQ		SPI_INT_VEC(111)
+#define IDSP_VIN_STAT_IRQ		SPI_INT_VEC(112)
+#define IDSP_VIN_SOF_IRQ		SPI_INT_VEC(113)
+#define IDSP_VIN_LAST_PIXEL_IRQ		SPI_INT_VEC(114)
+#define IDSP_VIN_DVSYNC_IRQ		SPI_INT_VEC(115)
+#define IDSP_PIP3_VSYNC_IRQ		SPI_INT_VEC(116)
+#define IDSP_PIP3_STAT_IRQ		SPI_INT_VEC(117)
+#define IDSP_PIP3_SOF_IRQ		SPI_INT_VEC(118)
+#define IDSP_PIP3_LAST_PIXEL_IRQ	SPI_INT_VEC(119)
+#define IDSP_PIP3_DVSYNC_IRQ		SPI_INT_VEC(120)
+#define IDSP_PIP2_VSYNC_IRQ		SPI_INT_VEC(121)
+#define IDSP_PIP2_STAT_IRQ		SPI_INT_VEC(122)
+#define IDSP_PIP2_SOF_IRQ		SPI_INT_VEC(123)
+#define IDSP_PIP2_LAST_PIXEL_IRQ	SPI_INT_VEC(124)
+#define IDSP_PIP2_DVSYNC_IRQ		SPI_INT_VEC(125)
+#define IDSP_PIP_MVSYNC_IRQ		SPI_INT_VEC(126)
+#define IDSP_PIP_VSYNC_IRQ		SPI_INT_VEC(127)
+
+#define IDSP_PIP_STAT_IRQ		SPI_INT_VEC(128)
+#define IDSP_PIP_SOF_IRQ		SPI_INT_VEC(129)
+#define IDSP_PIP_LAST_PIXEL_IRQ		SPI_INT_VEC(130)
+#define IDSP_PIP_DVSYNC_IRQ		SPI_INT_VEC(131)
+#define IDSP_MINI_VIN_VSYNC_IRQ		SPI_INT_VEC(132)
+#define IDSP_MINI_VIN_STAT_IRQ		SPI_INT_VEC(133)
+#define IDSP_MINI_VIN_SOF_IRQ		SPI_INT_VEC(134)
+#define IDSP_MINI_VIN_LAST_PIXEL_IRQ	SPI_INT_VEC(135)
+#define IDSP_MINI_VIN_DVSYNC_IRQ	SPI_INT_VEC(136)
+#define SMEM_ERROR_IRQ			SPI_INT_VEC(137)
+#define MINI_VIN_IRQ			SPI_INT_VEC(138)
+#define VIN_IRQ				SPI_INT_VEC(139)
+#define CODE_VDSP_0_IRQ			SPI_INT_VEC(140)
+#define CODE_VDSP_1_IRQ			SPI_INT_VEC(141)
+#define CODE_VDSP_2_IRQ			SPI_INT_VEC(142)
+#define CODE_VDSP_3_IRQ			SPI_INT_VEC(143)
+#define VOUT_LCD_IRQ			SPI_INT_VEC(144)
+#define VOUT_TV_IRQ			SPI_INT_VEC(145)
+#define VOUT_C_IRQ			SPI_INT_VEC(146)
+#define VOUT_D_IRQ			SPI_INT_VEC(147)
+#define VDSP_PIP_CODING_IRQ		SPI_INT_VEC(148)
+#define VDSP_PIP2_CODING_IRQ		SPI_INT_VEC(149)
+#define VDSP_PIP3_CODING_IRQ		SPI_INT_VEC(150)
+#define L2C_ERR_IRQ			SPI_INT_VEC(151)
+#define VORC_THREAD0_IRQ		SPI_INT_VEC(152)
+#define VORC_THREAD1_IRQ		SPI_INT_VEC(153)
+#define VORC_THREAD2_IRQ		SPI_INT_VEC(154)
+#define VORC_THREAD3_IRQ		SPI_INT_VEC(155)
+#define SORC_THREAD0_IRQ		SPI_INT_VEC(156)
+#define SORC_THREAD1_IRQ		SPI_INT_VEC(157)
+#define SORC_THREAD2_IRQ		SPI_INT_VEC(158)
+#define SORC_THREAD3_IRQ		SPI_INT_VEC(159)
+#define PWC_ALRAM			SPI_INT_VEC(160)
+
+#define NR_IRQS				SPI_INT_VEC(161)
+
+/* ==========================================================================*/
+#else
+#error "Not supported!"
+
+#endif
+
+/* ==========================================================================*/
+#ifndef __ASM__
+
+#endif
+#endif
diff --git a/include/ambhw/gpio.h b/include/ambhw/gpio.h
index dcf9684..c91dbb0 100644
--- a/include/ambhw/gpio.h
+++ b/include/ambhw/gpio.h
@@ -3,66 +3,110 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __AMBHW__GPIO_H__
 #define __AMBHW__GPIO_H__
 
+#include <ambhw/chip.h>
+
 /* ==========================================================================*/
-#if (CHIP_REV == A7L)
-#define GPIO_INSTANCES			4
-#define GPIO_MAX_LINES			128
-#elif (CHIP_REV == A5S)
-#define GPIO_INSTANCES			3
-#define GPIO_MAX_LINES			96
-#elif (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define GPIO_INSTANCES			5
-#define GPIO_MAX_LINES			138
-#elif (CHIP_REV == A8)
-#define GPIO_INSTANCES			1
-#define GPIO_MAX_LINES			16
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3L)
+#if (CHIP_REV == S2L)
 #define GPIO_INSTANCES			4
 #define GPIO_MAX_LINES			114
+#elif (CHIP_REV == S3L)
+#define GPIO_INSTANCES			4
+#define GPIO_MAX_LINES			121
 #elif (CHIP_REV == S3)
 #define GPIO_INSTANCES			7
 #define GPIO_MAX_LINES			201
+#elif (CHIP_REV == S5)
+#define GPIO_INSTANCES			5
+#define GPIO_MAX_LINES			132
+#elif (CHIP_REV == S5L)
+#define GPIO_INSTANCES			5
+#define GPIO_MAX_LINES			139
+#elif (CHIP_REV == CV1)
+#define GPIO_INSTANCES			7
+#define GPIO_MAX_LINES			218
 #else
 #error "Not supported!"
 #endif
 
 /* ==========================================================================*/
+#if (CHIP_REV == CV1)
+#define GPIO0_OFFSET			0x3000
+#else
 #define GPIO0_OFFSET			0x9000
+#endif
+
+#if (CHIP_REV == CV1)
+#define GPIO1_OFFSET			0x4000
+#else
 #define GPIO1_OFFSET			0xA000
+#endif
+
+#if (CHIP_REV == CV1)
+#define GPIO2_OFFSET			0x5000
+#else
 #define GPIO2_OFFSET			0xE000
-#if (CHIP_REV == A5S)
-#define GPIO3_OFFSET			0x1F000
-#elif (CHIP_REV == A7L)
-#define GPIO3_OFFSET			0x1E000
+#endif
+
+#if (CHIP_REV == CV1)
+#define GPIO3_OFFSET			0x6000
 #else
 #define GPIO3_OFFSET			0x10000
 #endif
+
+#if (CHIP_REV == CV1)
+#define GPIO4_OFFSET			0x7000
+#else
 #define GPIO4_OFFSET			0x11000
-#if (CHIP_REV == S3)
-#define GPIO5_OFFSET			0xD000
+#endif
+
+#if (CHIP_REV == CV1)
+#define GPIO5_OFFSET			0x8000
 #else
-#define GPIO5_OFFSET			0x12000
+#define GPIO5_OFFSET			0xD000
 #endif
+
+#if (CHIP_REV == CV1)
+#define GPIO6_OFFSET			0x9000
+#else
 #define GPIO6_OFFSET			0x14000
+#endif
 
-#define GPIO0_BASE			(APB_BASE + GPIO0_OFFSET)
-#define GPIO1_BASE			(APB_BASE + GPIO1_OFFSET)
-#define GPIO2_BASE			(APB_BASE + GPIO2_OFFSET)
-#define GPIO3_BASE			(APB_BASE + GPIO3_OFFSET)
-#define GPIO4_BASE			(APB_BASE + GPIO4_OFFSET)
-#define GPIO5_BASE			(APB_BASE + GPIO5_OFFSET)
-#define GPIO6_BASE			(APB_BASE + GPIO6_OFFSET)
+#define GPIO0_BASE			(APB_S_BASE + GPIO0_OFFSET)
+#define GPIO1_BASE			(APB_S_BASE + GPIO1_OFFSET)
+#define GPIO2_BASE			(APB_S_BASE + GPIO2_OFFSET)
+#define GPIO3_BASE			(APB_S_BASE + GPIO3_OFFSET)
+#define GPIO4_BASE			(APB_S_BASE + GPIO4_OFFSET)
+#define GPIO5_BASE			(APB_S_BASE + GPIO5_OFFSET)
+#define GPIO6_BASE			(APB_S_BASE + GPIO6_OFFSET)
 
 #define GPIO0_REG(x)			(GPIO0_BASE + (x))
 #define GPIO1_REG(x)			(GPIO1_BASE + (x))
@@ -73,16 +117,11 @@
 #define GPIO6_REG(x)			(GPIO6_BASE + (x))
 
 /* ==========================================================================*/
-#if (CHIP_REV == A5S)
-#define GPIO_PAD_PULL_CTRL_SUPPORT		0
-#else
-#define GPIO_PAD_PULL_CTRL_SUPPORT		1
-#endif
 
-#if (CHIP_REV == A7L) || (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == A8)
-#define GPIO_PAD_PULL_OFFSET			0xD000
+#if (CHIP_REV == CV1)
+#define GPIO_PAD_PULL_OFFSET		0x1000
 #else
-#define GPIO_PAD_PULL_OFFSET			0x15000
+#define GPIO_PAD_PULL_OFFSET		0x15000
 #endif
 
 #define GPIO_PAD_PULL_EN_0_OFFSET	0x80
@@ -108,7 +147,7 @@
 					(0x10C + (((bank) - 5) * 4)) : \
 					(0x94 + ((bank) * 4)))
 
-#define GPIO_PAD_PULL_BASE		(APB_BASE + GPIO_PAD_PULL_OFFSET)
+#define GPIO_PAD_PULL_BASE		(APB_S_BASE + GPIO_PAD_PULL_OFFSET)
 #define GPIO_PAD_PULL_REG(x)		(GPIO_PAD_PULL_BASE + (x))
 
 /* ==========================================================================*/
@@ -126,12 +165,6 @@
 #define GPIO_ENABLE_OFFSET		0x2c
 
 /* ==========================================================================*/
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define	IOMUX_SUPPORT			1
-#else
-#define	IOMUX_SUPPORT			0
-#endif
-
 #define IOMUX_REG0_0_OFFSET		0x00
 #define IOMUX_REG0_1_OFFSET		0x04
 #define IOMUX_REG0_2_OFFSET		0x08
@@ -156,8 +189,12 @@
 #define IOMUX_CTRL_SET_OFFSET		0xf0
 #define IOMUX_REG_OFFSET(bank, n)	(((bank) * 0xc) + ((n) * 4))
 
+#if (CHIP_REV == CV1)
+#define IOMUX_OFFSET			0x0000
+#else
 #define IOMUX_OFFSET			0x16000
-#define IOMUX_BASE			(APB_BASE + IOMUX_OFFSET)
+#endif
+#define IOMUX_BASE			(APB_S_BASE + IOMUX_OFFSET)
 #define IOMUX_REG(x)			(IOMUX_BASE + (x))
 
 /* ==========================================================================*/
@@ -182,26 +219,30 @@
 #define GPIO_FUNC_HW			2
 
 /* ==========================================================================*/
-#ifndef __ASM__
+
+#define PINID_TO_BANK(p)		((p) >> 5)
+#define PINID_TO_OFFSET(p)		((p) & 0x1f)
+
 /* ==========================================================================*/
 
-extern void minipin_init(void);
+#ifndef __ASM__
 
-#ifdef CONFIG_AMBOOT_ENABLE_GPIO
 extern void gpio_init(void);
-extern void gpio_config_hw(int gpio, int alt_func);
-extern void gpio_config_sw_in(int gpio);
-extern void gpio_config_sw_out(int gpio);
-extern void gpio_set(int gpio);
-extern void gpio_clr(int gpio);
+extern void gpio_mini_init(u32 boot_from);
+
+#ifdef CONFIG_AMBOOT_ENABLE_GPIO
+extern int gpio_config_hw(int gpio, int alt_func);
+extern int gpio_config_sw_in(int gpio);
+extern int gpio_config_sw_out(int gpio);
+extern int gpio_set(int gpio);
+extern int gpio_clr(int gpio);
 extern int gpio_get(int gpio);
 #else
-static inline void gpio_init(void) { }
-static inline void gpio_config_hw(int gpio, int alt_func) { }
-static inline void gpio_config_sw_in(int gpio) { }
-static inline void gpio_config_sw_out(int gpio) { }
-static inline void gpio_set(int gpio) { }
-static inline void gpio_clr(int gpio) { }
+static inline int gpio_config_hw(int gpio, int alt_func) {return -1; }
+static inline int gpio_config_sw_in(int gpio) {return -1; }
+static inline int gpio_config_sw_out(int gpio) {return -1; }
+static inline int gpio_set(int gpio) {return -1; }
+static inline int gpio_clr(int gpio) {return -1; }
 static inline int gpio_get(int gpio) {return -1; }
 
 #endif
diff --git a/include/ambhw/i2s.h b/include/ambhw/i2s.h
index a76535c..34275a7 100644
--- a/include/ambhw/i2s.h
+++ b/include/ambhw/i2s.h
@@ -4,22 +4,45 @@
  * History:
  *	2007/01/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2006-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
  */
 
 #ifndef __AMBHW__I2S_H__
 #define __AMBHW__I2S_H__
 
+#include <ambhw/chip.h>
+
 /* ==========================================================================*/
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define I2S_OFFSET			0x1A000
+#if (CHIP_REV == CV1)
+#define I2S_OFFSET			0xD000
 #else
-#define I2S_OFFSET			0xA000
+#define I2S_OFFSET			0x1A000
 #endif
-#define I2S_BASE			(AHB_BASE + I2S_OFFSET)
-#define I2S_BASE_PHYS 			(AHB_PHYS_BASE + I2S_OFFSET)
+#define I2S_BASE			(AHB_N_BASE + I2S_OFFSET)
 #define I2S_REG(x)			(I2S_BASE + (x))
-#define I2S_REG_PHYS(x)  		(I2S_BASE_PHYS + (x))
 
 /* ==========================================================================*/
 #define I2S_MODE_OFFSET				0x00
@@ -71,50 +94,56 @@
 #define I2S_24BITMUX_MODE_REG			I2S_REG(0x50)
 #define I2S_GATEOFF_REG				I2S_REG(0x54)
 #define I2S_CHANNEL_SELECT_REG			I2S_REG(0x58)
-#define I2S_RX_DATA_DMA_REG			I2S_REG_PHYS(0x80)
-#define I2S_TX_LEFT_DATA_DMA_REG		I2S_REG_PHYS(0xc0)
-
-#define I2S_TX_FIFO_RESET_BIT		(1 << 4)
-#define I2S_RX_FIFO_RESET_BIT		(1 << 3)
-#define I2S_TX_ENABLE_BIT		(1 << 2)
-#define I2S_RX_ENABLE_BIT		(1 << 1)
-#define I2S_FIFO_RESET_BIT		(1 << 0)
-
-#define I2S_RX_LOOPBACK_BIT		(1 << 3)
-#define I2S_RX_ORDER_BIT		(1 << 2)
-#define I2S_RX_WS_MST_BIT		(1 << 1)
-#define I2S_RX_WS_INV_BIT		(1 << 0)
-
-#define I2S_TX_LOOPBACK_BIT		(1 << 7)
-#define I2S_TX_ORDER_BIT		(1 << 6)
-#define I2S_TX_WS_MST_BIT		(1 << 5)
-#define I2S_TX_WS_INV_BIT		(1 << 4)
-#define I2S_TX_UNISON_BIT		(1 << 3)
-#define I2S_TX_MUTE_BIT			(1 << 2)
-#define I2S_TX_MONO_MASK		0xfffffffc
-#define I2S_TX_MONO_RIGHT		(1 << 1)
-#define I2S_TX_MONO_LEFT		(1 << 0)
-
-#define I2S_CLK_WS_OUT_EN		(1 << 9)
-#define I2S_CLK_BCLK_OUT_EN		(1 << 8)
-#define I2S_CLK_BCLK_OUTPUT		(1 << 7)
-#define I2S_CLK_MASTER_MODE		(I2S_CLK_WS_OUT_EN	|	\
-					 I2S_CLK_BCLK_OUT_EN	|	\
-					 I2S_CLK_BCLK_OUTPUT)
-#define I2S_CLK_TX_PO_FALL		(1 << 6)
-#define I2S_CLK_RX_PO_FALL		(1 << 5)
-#define I2S_CLK_DIV_MASK		0xffffffe0
-
-#define I2S_RX_SHIFT_ENB		(1 << 1)
-#define I2S_TX_SHIFT_ENB		(1 << 0)
-
-#define I2S_2CHANNELS_ENB		0x00
-#define I2S_4CHANNELS_ENB		0x01
-#define I2S_6CHANNELS_ENB		0x02
-
-#define I2S_FIFO_THRESHOLD_INTRPT	0x08
-#define I2S_FIFO_FULL_INTRPT		0x02
-#define I2S_FIFO_EMPTY_INTRPT		0x01
+#define I2S_RX_DATA_DMA_REG			I2S_REG(0x80)
+#define I2S_TX_LEFT_DATA_DMA_REG		I2S_REG(0xc0)
+
+#define I2S_LEFT_JUSTIFIED_MODE			0x0
+#define I2S_RIGHT_JUSTIFIED_MODE		0x1
+#define I2S_MSB_EXTEND_MODE			0x2
+#define I2S_I2S_MODE				0x4
+#define I2S_DSP_MODE				0x6
+
+#define I2S_TX_FIFO_RESET_BIT			(1 << 4)
+#define I2S_RX_FIFO_RESET_BIT			(1 << 3)
+#define I2S_TX_ENABLE_BIT			(1 << 2)
+#define I2S_RX_ENABLE_BIT			(1 << 1)
+#define I2S_FIFO_RESET_BIT			(1 << 0)
+
+#define I2S_RX_LOOPBACK_BIT			(1 << 3)
+#define I2S_RX_ORDER_BIT			(1 << 2)
+#define I2S_RX_WS_MST_BIT			(1 << 1)
+#define I2S_RX_WS_INV_BIT			(1 << 0)
+
+#define I2S_TX_LOOPBACK_BIT			(1 << 7)
+#define I2S_TX_ORDER_BIT			(1 << 6)
+#define I2S_TX_WS_MST_BIT			(1 << 5)
+#define I2S_TX_WS_INV_BIT			(1 << 4)
+#define I2S_TX_UNISON_BIT			(1 << 3)
+#define I2S_TX_MUTE_BIT				(1 << 2)
+#define I2S_TX_MONO_MASK			0xfffffffc
+#define I2S_TX_MONO_RIGHT			(1 << 1)
+#define I2S_TX_MONO_LEFT			(1 << 0)
+
+#define I2S_CLK_WS_OUT_EN			(1 << 9)
+#define I2S_CLK_BCLK_OUT_EN			(1 << 8)
+#define I2S_CLK_BCLK_OUTPUT			(1 << 7)
+#define I2S_CLK_MASTER_MODE			(I2S_CLK_WS_OUT_EN	|	\
+						 I2S_CLK_BCLK_OUT_EN	|	\
+						 I2S_CLK_BCLK_OUTPUT)
+#define I2S_CLK_TX_PO_FALL			(1 << 6)
+#define I2S_CLK_RX_PO_FALL			(1 << 5)
+#define I2S_CLK_DIV_MASK			0xffffffe0
+
+#define I2S_RX_SHIFT_ENB			(1 << 1)
+#define I2S_TX_SHIFT_ENB			(1 << 0)
+
+#define I2S_2CHANNELS_ENB			0x00
+#define I2S_4CHANNELS_ENB			0x01
+#define I2S_6CHANNELS_ENB			0x02
+
+#define I2S_FIFO_THRESHOLD_INTRPT		0x08
+#define I2S_FIFO_FULL_INTRPT			0x02
+#define I2S_FIFO_EMPTY_INTRPT			0x01
 
 /* I2S_24BITMUX_MODE_REG */
 #define I2S_24BITMUX_MODE_ENABLE		0x1
@@ -123,6 +152,13 @@
 #define I2S_24BITMUX_MODE_DMA_BOOTSEL		0x8
 
 /* ==========================================================================*/
+#if defined(AMBOOT_AUDIO_8000)
+#define AUDIO_SAMPLE_RATE			8000
+#elif defined(AMBOOT_AUDIO_48000)
+#define AUDIO_SAMPLE_RATE			48000
+#else
+#define AUDIO_SAMPLE_RATE                       16000
+#endif
 
 #endif
 
diff --git a/include/ambhw/idc.h b/include/ambhw/idc.h
index 4018b36..46d3625 100644
--- a/include/ambhw/idc.h
+++ b/include/ambhw/idc.h
@@ -1,112 +1,137 @@
-/*
- * ambhw/idc.h
- *
- * History:
- *	2006/12/27 - [Charles Chiou] created file
- *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+/*
+ * ambhw/idc.h
+ *
+ * History:
+ *	2006/12/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
-
-#ifndef __AMBHW__IDC_H__
-#define __AMBHW__IDC_H__
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S) || (CHIP_REV == A7L)
-#define IDC_INSTANCES			2
-#define IDC_SUPPORT_INTERNAL_MUX	1
-#define IDC3_BUS_MUX			GPIO(36)
-#else
-#define IDC_INSTANCES			3
-#define IDC_SUPPORT_INTERNAL_MUX	0
-#endif
-
-/* ==========================================================================*/
-#define IDC_OFFSET			0x3000
-#define IDC_BASE			(APB_BASE + IDC_OFFSET)
-#define IDC_REG(x)			(IDC_BASE + (x))
-
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define IDC2_OFFSET			0x1000
-#else
-#define IDC2_OFFSET			0x7000
-#endif
-#define IDC2_BASE			(APB_BASE + IDC2_OFFSET)
-#define IDC2_REG(x)			(IDC2_BASE + (x))
-
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define IDC3_OFFSET			0x13000
-#elif (CHIP_REV == A8)
-#define IDC3_OFFSET			0xE000
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define IDC3_OFFSET			0x7000
-#endif
-#define IDC3_BASE			(APB_BASE + IDC3_OFFSET)
-#define IDC3_REG(x)			(IDC3_BASE + (x))
-
-/* ==========================================================================*/
-#define IDC_ENR_OFFSET			0x00
-#define IDC_CTRL_OFFSET			0x04
-#define IDC_DATA_OFFSET			0x08
-#define IDC_STS_OFFSET			0x0c
-#define IDC_PSLL_OFFSET			0x10
-#define IDC_PSLH_OFFSET			0x14
-#define IDC_FMCTRL_OFFSET		0x18
-#define IDC_FMDATA_OFFSET		0x1c
-#define IDC_DUTYCYCLE_OFFSET	0x24
-#define IDC_ENR_REG_ENABLE		(0x01)
-#define IDC_ENR_REG_DISABLE		(0x00)
-
-#define IDC_CTRL_STOP			(0x08)
-#define IDC_CTRL_START			(0x04)
-#define IDC_CTRL_IF			(0x02)
-#define IDC_CTRL_ACK			(0x01)
-#define IDC_CTRL_CLS			(0x00)
-
-#define IDC_FIFO_BUF_SIZE		(63)
-
-#define IDC_FMCTRL_STOP			(0x08)
-#define IDC_FMCTRL_START		(0x04)
-#define IDC_FMCTRL_IF			(0x02)
-
+
+#ifndef __AMBHW__IDC_H__
+#define __AMBHW__IDC_H__
+
+#include <ambhw/chip.h>
+
 /* ==========================================================================*/
-#define IDC_INT_MAX_WAIT_LOOP		24000
-
-#define IDC_MASTER1			0
-#define IDC_MASTER2			1
-#define IDC_MASTER3			2
-
+#if (CHIP_REV == S5L) || (CHIP_REV == CV1)
+#define IDC_INSTANCES			4
+#else
+#define IDC_INSTANCES			3
+#endif
+
+#if (CHIP_REV == CV1)
+#define IDC0_OFFSET			0x8000
+#else
+#define IDC0_OFFSET			0x3000
+#endif
+#define IDC0_BASE			(APB_N_BASE + IDC0_OFFSET)
+#define IDC0_REG(x)			(IDC0_BASE + (x))
+
+#if (CHIP_REV == CV1)
+#define IDC1_OFFSET			0x9000
+#else
+#define IDC1_OFFSET			0x1000
+#endif
+#define IDC1_BASE			(APB_N_BASE + IDC1_OFFSET)
+#define IDC1_REG(x)			(IDC1_BASE + (x))
+
+#if (CHIP_REV == CV1)
+#define IDC2_OFFSET			0xA000
+#else
+#define IDC2_OFFSET			0x7000
+#endif
+#define IDC2_BASE			(APB_N_BASE + IDC2_OFFSET)
+#define IDC2_REG(x)			(IDC2_BASE + (x))
+
+#if (CHIP_REV == CV1)
+#define IDC3_OFFSET			0xB000
+#else
+#define IDC3_OFFSET			0x13000
+#endif
+#define IDC3_BASE			(APB_N_BASE + IDC3_OFFSET)
+#define IDC3_REG(x)			(IDC3_BASE + (x))
+
+/* ==========================================================================*/
+#define IDC_ENR_OFFSET			0x00
+#define IDC_CTRL_OFFSET			0x04
+#define IDC_DATA_OFFSET			0x08
+#define IDC_STS_OFFSET			0x0c
+#define IDC_PSLL_OFFSET			0x10
+#define IDC_PSLH_OFFSET			0x14
+#define IDC_FMCTRL_OFFSET		0x18
+#define IDC_FMDATA_OFFSET		0x1c
+#define IDC_DUTYCYCLE_OFFSET		0x24
+
+#define IDC_ENR_REG_ENABLE		(0x01)
+#define IDC_ENR_REG_DISABLE		(0x00)
+
+#define IDC_CTRL_STOP			(0x08)
+#define IDC_CTRL_START			(0x04)
+#define IDC_CTRL_IF			(0x02)
+#define IDC_CTRL_ACK			(0x01)
+#define IDC_CTRL_CLS			(0x00)
+
+#define IDC_STS_FIFO_EMP		(0x04)
+#define IDC_STS_FIFO_FUL		(0x02)
+
+#define IDC_FIFO_BUF_SIZE		(63)
+
+#define IDC_FMCTRL_STOP			(0x08)
+#define IDC_FMCTRL_START		(0x04)
+#define IDC_FMCTRL_IF			(0x02)
+
+/* ==========================================================================*/
+#define IDC_INT_MAX_WAIT_LOOP		24000
+
+#define IDC_MASTER1			0
+#define IDC_MASTER2			1
+#define IDC_MASTER3			2
+#define IDC_MASTER4			3
+
 /* ==========================================================================*/
 #ifndef __ASM__
-/* ==========================================================================*/
-
-extern void idc_bld_init(u8 idc_id, u32 freq_hz);
-
-extern u8 idc_bld_isl12022m_read(u8 idc_id, u8 sub_adds);
-extern void idc_bld_isl12022m_write(u8 idc_id, u8 sub_adds, u8 reg_val);
-
-extern u8 idc_bld_pca953x_read(u8 idc_id, u8 adds, u8 sub_adds);
-extern void idc_bld_pca953x_write(u8 idc_id, u8 adds, u8 sub_adds, u8 reg_val);
-
-extern u16 idc_bld_read_16_16(u8 idc_id, u8 adds, u16 sub_adds);
-extern void idc_bld_write_16_16(u8 idc_id, u8 adds, u16 sub_adds, u16 reg_val);
-extern u8 idc_bld_read_16_8(u8 idc_id, u8 adds, u16 sub_adds);
-extern void idc_bld_write_16_8(u8 idc_id, u8 adds, u16 sub_adds, u8 reg_val);
-extern u8 idc_bld_read_8_8(u8 idc_id, u8 adds, u8 sub_adds);
-extern void idc_bld_write_8_8(u8 idc_id, u8 adds, u8 sub_adds, u8 reg_val);
-
-extern int idc_bld_send_buf_without_ack(unsigned char idc_id, unsigned char adds, unsigned char* buf, int count);
-extern int idc_bld_send_buf(unsigned char idc_id, unsigned char adds, unsigned char* send_buf, int send_len);
-extern int idc_bld_recv_buf(unsigned char idc_id, unsigned char adds, unsigned char* recv_buf, int recv_len);
-extern int idc_bld_read_buf(unsigned char idc_id, unsigned char adds, unsigned char* read_buf, int read_len);
-
 /* ==========================================================================*/
-#endif
+
+extern void idc_bld_init(u8 idc_id, u32 freq_hz);
+
+extern u16 idc_bld_read_16_16(u8 idc_id, u8 adds, u16 sub_adds);
+extern void idc_bld_write_16_16(u8 idc_id, u8 adds, u16 sub_adds, u16 reg_val);
+extern u8 idc_bld_read_16_8(u8 idc_id, u8 adds, u16 sub_adds);
+extern void idc_bld_write_16_8(u8 idc_id, u8 adds, u16 sub_adds, u8 reg_val);
+extern u8 idc_bld_read_8_8(u8 idc_id, u8 adds, u8 sub_adds);
+extern void idc_bld_write_8_8(u8 idc_id, u8 adds, u8 sub_adds, u8 reg_val);
+
+extern int idc_bld_send_buf_without_ack(unsigned char idc_id, unsigned char adds, unsigned char* buf, int count);
+extern int idc_bld_send_buf(unsigned char idc_id, unsigned char adds, unsigned char* send_buf, int send_len);
+extern int idc_bld_recv_buf(unsigned char idc_id, unsigned char adds, unsigned char* recv_buf, int recv_len);
+extern int idc_bld_read_buf(unsigned char idc_id, unsigned char adds, unsigned char* read_buf, int read_len);
+
+/* ==========================================================================*/
+#endif
 /* ==========================================================================*/
-
-#endif
-
+
+#endif
+
diff --git a/include/ambhw/ir.h b/include/ambhw/ir.h
index b50d72f..e252c9d 100644
--- a/include/ambhw/ir.h
+++ b/include/ambhw/ir.h
@@ -1,38 +1,67 @@
-/*
- * ambhw/ir.h
- *
- * History:
- *	2006/12/27 - [Charles Chiou] created file
- *
- * Copyright (C) 2006-2007, Ambarella, Inc.
- */
-
-#ifndef __AMBHW__IR_H__
-#define __AMBHW__IR_H__
-
-/* ==========================================================================*/
-#define IR_OFFSET			0x6000
-#define IR_BASE				(APB_BASE + IR_OFFSET)
-#define IR_REG(x)			(IR_BASE + (x))
-
-/* ==========================================================================*/
-#define IR_CONTROL_OFFSET		0x00
-#define IR_STATUS_OFFSET		0x04
-#define IR_DATA_OFFSET			0x08
-
-#define IR_CONTROL_REG			IR_REG(0x00)
-#define IR_STATUS_REG			IR_REG(0x04)
-#define IR_DATA_REG			IR_REG(0x08)
-
-/* IR_CONTROL_REG */
-#define IR_CONTROL_RESET		0x00004000
-#define IR_CONTROL_ENB			0x00002000
-#define IR_CONTROL_LEVINT		0x00001000
-#define IR_CONTROL_INTLEV(x)		(((x) & 0x3f)  << 4)
-#define IR_CONTROL_FIFO_OV		0x00000008
-#define IR_CONTROL_INTENB		0x00000004
-
-#define IR_STATUS_COUNT(x)		((x) & 0x3f)
-#define IR_DATA_DATA(x)			((x) & 0xffff)
-
-#endif
+/*
+ * ambhw/ir.h
+ *
+ * History:
+ *	2006/12/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBHW__IR_H__
+#define __AMBHW__IR_H__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+#if (CHIP_REV == CV1)
+#define IR_OFFSET			0x1000
+#else
+#define IR_OFFSET			0x6000
+#endif
+#define IR_BASE				(APB_N_BASE + IR_OFFSET)
+#define IR_REG(x)			(IR_BASE + (x))
+
+/* ==========================================================================*/
+#define IR_CONTROL_OFFSET		0x00
+#define IR_STATUS_OFFSET		0x04
+#define IR_DATA_OFFSET			0x08
+
+#define IR_CONTROL_REG			IR_REG(0x00)
+#define IR_STATUS_REG			IR_REG(0x04)
+#define IR_DATA_REG			IR_REG(0x08)
+
+/* IR_CONTROL_REG */
+#define IR_CONTROL_RESET		0x00004000
+#define IR_CONTROL_ENB			0x00002000
+#define IR_CONTROL_LEVINT		0x00001000
+#define IR_CONTROL_INTLEV(x)		(((x) & 0x3f)  << 4)
+#define IR_CONTROL_FIFO_OV		0x00000008
+#define IR_CONTROL_INTENB		0x00000004
+
+#define IR_STATUS_COUNT(x)		((x) & 0x3f)
+#define IR_DATA_DATA(x)			((x) & 0xffff)
+
+#endif
diff --git a/include/ambhw/memory.h b/include/ambhw/memory.h
index a72b3f9..6fcebc3 100644
--- a/include/ambhw/memory.h
+++ b/include/ambhw/memory.h
@@ -3,54 +3,78 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __AMBHW__MEMORY_H__
 #define __AMBHW__MEMORY_H__
 
+#include <ambhw/chip.h>
+
 /*===========================================================================*/
-#if (CHIP_REV == A8)
-#define DRAM_START_ADDR		0x00000000
-#define AHB_PHYS_BASE		0xE0000000
-#define APB_PHYS_BASE		0xE8000000
-#define DBGBUS_PHYS_BASE	APB_PHYS_BASE
-#define PHY_BUS_MAP_TYPE	1
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define DRAM_START_ADDR		0x00000000
-#define AHB_PHYS_BASE		0xE0000000
-#define APB_PHYS_BASE		0xE8000000
-#define DBGBUS_PHYS_BASE	0xEC000000
-#define PHY_BUS_MAP_TYPE	1
-#elif (CHIP_REV == S2E)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L) || \
+	(CHIP_REV == S5) || (CHIP_REV == S5L)
 #define DRAM_START_ADDR		0x00000000
-#define AHB_PHYS_BASE		0x60000000
-#define APB_PHYS_BASE		0x70000000
-#define DBGBUS_PHYS_BASE	APB_PHYS_BASE
-#define PHY_BUS_MAP_TYPE	2
+#define AHB_BASE		0xE0000000
+#define APB_BASE		0xE8000000
+#define DBGBUS_BASE		0xEC000000
+#define AXI_BASE		0xF0000000
 #else
-#define DRAM_START_ADDR		0xC0000000
-#define AHB_PHYS_BASE		0x60000000
-#define APB_PHYS_BASE		0x70000000
-#define DBGBUS_PHYS_BASE	APB_PHYS_BASE
-#define PHY_BUS_MAP_TYPE	0
+#define DRAM_START_ADDR		0x00000000
+#define AHB_N_BASE		0xE0000000
+#define APB_N_BASE		0xE4000000
+#define AHB_S_BASE		0xE8000000
+#define APB_S_BASE		0xEC000000
+#define DBGBUS_BASE		0xED000000
+#define AXI_BASE		0xF2000000
+#endif
+
+#ifndef AHB_N_BASE
+#define AHB_N_BASE		AHB_BASE
+#endif
+#ifndef AHB_S_BASE
+#define AHB_S_BASE		AHB_BASE
+#endif
+#ifndef APB_N_BASE
+#define APB_N_BASE		APB_BASE
+#endif
+#ifndef APB_S_BASE
+#define APB_S_BASE		APB_BASE
 #endif
 
-/* The boot-loader still deals with physical address */
-#define AHB_BASE		AHB_PHYS_BASE
-#define APB_BASE		APB_PHYS_BASE
-#define DBGBUS_BASE		DBGBUS_PHYS_BASE
 
 /*===========================================================================*/
 #ifndef DRAM_SIZE
 #error "DRAM_SIZE undefined!"
 #endif
 
+#if IDSP_RAM_START > DRAM_SIZE
+#error "IDSP_RAM_START overflow DRAM_SIZE!"
+#endif
+
 #define SIZE_1KB		(1 * 1024)
 #define SIZE_1KB_MASK		(SIZE_1KB - 1)
 #define SIZE_1MB		(1024 * 1024)
@@ -58,30 +82,16 @@
 
 #define DRAM_END_ADDR		(DRAM_START_ADDR + DRAM_SIZE - 1)
 
-#ifndef AMBOOT_BLD_RAM_START
-#define AMBOOT_BLD_RAM_START	DRAM_START_ADDR
-#endif
-#define AMBOOT_BLD_RAM_MAX_SIZE	(0x000f0000)
+#define AMBOOT_BLD_RAM_MAX_SIZE	(0x00100000)
 #define AMBOOT_BLD_RAM_MAX_END	(AMBOOT_BLD_RAM_START + AMBOOT_BLD_RAM_MAX_SIZE)
 
-#ifndef MEMFWPROG_RAM_START
-#define MEMFWPROG_RAM_START	(DRAM_START_ADDR + (1 * SIZE_1MB))
-#endif
+#define MEMFWPROG_RAM_START	(DRAM_START_ADDR + (4 * SIZE_1MB))
 #define MEMFWPROG_HOOKCMD_SIZE	(0x00010000)
 
 #define AMBOOT_DTB_MAX_SIZE	(0x00008000)
 /* ptb buffer is used to store the DTB and PTB, and must be multiple of 2048 */
 #define AMBOOT_PTB_BUF_SIZE	(AMBOOT_DTB_MAX_SIZE + 0x00002000)
 
-/*===========================================================================*/
-#if defined(AMBOOT_DEV_BOOT_CORTEX)
-#define CORTEX_TO_ARM11(x)	((x) + 0xC0000000)
-#define ARM11_TO_CORTEX(x)	((x) - 0xC0000000)
-#else
-#define CORTEX_TO_ARM11(x)	(x)
-#define ARM11_TO_CORTEX(x)	(x)
-#endif
-
 /* ==========================================================================*/
 #ifndef __ASM__
 /* ==========================================================================*/
@@ -97,6 +107,7 @@ extern unsigned char __heap_start[];
 extern unsigned char __heap_end[];
 
 extern unsigned int ambausb_boot_from[];
+extern unsigned int ambausb_boot_usb[];
 
 /* ==========================================================================*/
 #endif
diff --git a/include/ambhw/nand.h b/include/ambhw/nand.h
index 633f2dc..ac5576e 100644
--- a/include/ambhw/nand.h
+++ b/include/ambhw/nand.h
@@ -3,267 +3,87 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __AMBHW_NAND_H__
 #define __AMBHW_NAND_H__
 
-/* ==========================================================================*/
+#include <ambhw/chip.h>
 
-#if (CHIP_REV == S2E) || (CHIP_REV == S3L)
-#define NAND_ECC_RPT_NUM_SUPPORT	1
+#ifdef CONFIG_NAND_COMBO_CONTROLLER
+#include <ambhw/nand_combo.h>
 #else
-#define NAND_ECC_RPT_NUM_SUPPORT	0
+#include <ambhw/nand_legacy.h>
 #endif
 
-/* ==========================================================================*/
-#define FLASH_CTR_OFFSET		0x120
-#define FLASH_CMD_OFFSET		0x124
-#define FLASH_TIM0_OFFSET		0x128
-#define FLASH_TIM1_OFFSET		0x12c
-#define FLASH_TIM2_OFFSET		0x130
-#define FLASH_TIM3_OFFSET		0x134
-#define FLASH_TIM4_OFFSET		0x138
-#define FLASH_TIM5_OFFSET		0x13c
-#define FLASH_STA_OFFSET		0x140
-#define FLASH_ID_OFFSET			0x144
-#define FLASH_CFI_OFFSET		0x148
-#define FLASH_LEN_OFFSET		0x14c
-#define FLASH_INT_OFFSET		0x150
-#define FLASH_EX_CTR_OFFSET		0x15c
-#define FLASH_EX_ID_OFFSET		0x160
-/* followings are for customer command, start from S3L */
-#define FLASH_TIM6_OFFSET		0x164
-#define FLASH_CC_OFFSET			0x170
-#define FLASH_CC_WORD_OFFSET		0x174
-#define FLASH_CC_DATA0_OFFSET		0x180
-#define FLASH_CC_DATA1_OFFSET		0x184
-#define FLASH_CC_DATA2_OFFSET		0x188
-#define FLASH_CC_DATA3_OFFSET		0x18c
-#define FLASH_CC_DATA4_OFFSET		0x190
-#define FLASH_CC_DATA5_OFFSET		0x194
-#define FLASH_CC_DATA6_OFFSET		0x198
-#define FLASH_CC_DATA7_OFFSET		0x19c
-
-#define NAND_CTR_REG			FIO_REG(0x120)
-#define NAND_CMD_REG			FIO_REG(0x124)
-#define NAND_TIM0_REG			FIO_REG(0x128)
-#define NAND_TIM1_REG			FIO_REG(0x12c)
-#define NAND_TIM2_REG			FIO_REG(0x130)
-#define NAND_TIM3_REG			FIO_REG(0x134)
-#define NAND_TIM4_REG			FIO_REG(0x138)
-#define NAND_TIM5_REG			FIO_REG(0x13c)
-#define NAND_STA_REG			FIO_REG(0x140)
-#define NAND_ID_REG			FIO_REG(0x144)
-#define NAND_COPY_ADDR_REG		FIO_REG(0x148)
-#define NAND_LEN_REG			FIO_REG(0x14c)
-#define NAND_INT_REG			FIO_REG(0x150)
-#define NAND_EXT_CTR_REG		FIO_REG(0x15c)
-#define NAND_EXT_ID5_REG		FIO_REG(0x160)
-/* followings are for customer command, start from S3L */
-#define NAND_TIM6_REG			FIO_REG(0x164)
-#define NAND_CC_REG			FIO_REG(0x170)
-#define NAND_CC_WORD_REG		FIO_REG(0x174)
-#define NAND_CC_DATA0_REG		FIO_REG(0x180)
-#define NAND_CC_DATA1_REG		FIO_REG(0x184)
-#define NAND_CC_DATA2_REG		FIO_REG(0x188)
-#define NAND_CC_DATA3_REG		FIO_REG(0x18c)
-#define NAND_CC_DATA4_REG		FIO_REG(0x190)
-#define NAND_CC_DATA5_REG		FIO_REG(0x194)
-#define NAND_CC_DATA6_REG		FIO_REG(0x198)
-#define NAND_CC_DATA7_REG		FIO_REG(0x19c)
-
-#define NAND_READ_CMDWORD_REG		FIO_REG(0x154)
-#define NAND_PROG_CMDWORD_REG		FIO_REG(0x158)
-#define NAND_CMDWORD1(x)		((x) << 16)
-#define NAND_CMDWORD2(x)		((x) & 0xff)
-
-#define NAND_CPS1_ADDR_REG		FIO_REG(0x154)
-#define NAND_CPD1_ADDR_REG		FIO_REG(0x158)
-#define NAND_CPS2_ADDR_REG		FIO_REG(0x15c)
-#define NAND_CPD2_ADDR_REG		FIO_REG(0x160)
-#define NAND_CPS3_ADDR_REG		FIO_REG(0x164)
-#define NAND_CPD3_ADDR_REG		FIO_REG(0x168)
-#define NAND_NBR_SPA_REG		FIO_REG(0x16c)
-
-#define NAND_CTR_A(x)			((x) << 28)
-#define NAND_CTR_SA			0x08000000
-#define NAND_CTR_SE			0x04000000
-#define NAND_CTR_C2			0x02000000
-#define NAND_CTR_P3			0x01000000
-#define NAND_CTR_I4			0x00800000
-#define NAND_CTR_RC			0x00400000
-#define NAND_CTR_CC			0x00200000
-#define NAND_CTR_CE			0x00100000
-#define NAND_CTR_EC_MAIN		0x00080000
-#define NAND_CTR_EC_SPARE		0x00040000
-#define NAND_CTR_EG_MAIN		0x00020000
-#define NAND_CTR_EG_SPARE		0x00010000
-#define NAND_CTR_WP			0x00000200
-#define NAND_CTR_IE			0x00000100
-#define NAND_CTR_XS			0x00000080
-#define NAND_CTR_SZ_8G			0x00000070
-#define NAND_CTR_SZ_4G			0x00000060
-#define NAND_CTR_SZ_2G			0x00000050
-#define NAND_CTR_SZ_1G			0x00000040
-#define NAND_CTR_SZ_512M		0x00000030
-#define NAND_CTR_SZ_256M		0x00000020
-#define NAND_CTR_SZ_128M		0x00000010
-#define NAND_CTR_SZ_64M			0x00000000
-#define NAND_CTR_4BANK			0x00000008
-#define NAND_CTR_2BANK			0x00000004
-#define NAND_CTR_1BANK			0x00000000
-#define NAND_CTR_WD_64BIT		0x00000003
-#define NAND_CTR_WD_32BIT		0x00000002
-#define NAND_CTR_WD_16BIT		0x00000001
-#define NAND_CTR_WD_8BIT		0x00000000
-
-#define NAND_CTR_INTLVE			0x80000000
-#define NAND_CTR_SPRBURST		0x40000000
-#define NAND_CFG_STAT_ENB		0x00002000
-#define NAND_CTR_2INTL			0x00001000
-#define NAND_CTR_K9			0x00000800
-
-#define NAND_CTR_WAS			0x00000400
-
-#define NAND_AMB_CMD_ADDR(x)		((x) << 4)
-#define NAND_AMB_CMD_NOP		0x0
-#define NAND_AMB_CMD_DMA		0x1
-#define NAND_AMB_CMD_RESET		0x2
-#define NAND_AMB_CMD_NOP2		0x3
-#define NAND_AMB_CMD_NOP3		0x4
-#define NAND_AMB_CMD_NOP4		0x5
-#define NAND_AMB_CMD_NOP5		0x6
-#define NAND_AMB_CMD_COPYBACK		0x7
-#define NAND_AMB_CMD_NOP6		0x8
-#define NAND_AMB_CMD_ERASE		0x9
-#define NAND_AMB_CMD_READID		0xa
-#define NAND_AMB_CMD_NOP7		0xb
-#define NAND_AMB_CMD_READSTATUS		0xc
-#define NAND_AMB_CMD_NOP8		0xd
-#define NAND_AMB_CMD_READ		0xe
-#define NAND_AMB_CMD_PROGRAM		0xf
-
-/* NAND_TIM0_REG (NAND mode) */
-#define NAND_TIM0_TCLS(x)		((x) << 24)
-#define NAND_TIM0_TALS(x)		((x) << 16)
-#define NAND_TIM0_TCS(x)		((x) << 8)
-#define NAND_TIM0_TDS(x)		(x)
-
-/* NAND_TIM1_REG (NAND mode) */
-#define NAND_TIM1_TCLH(x)		((x) << 24)
-#define NAND_TIM1_TALH(x)		((x) << 16)
-#define NAND_TIM1_TCH(x)		((x) << 8)
-#define NAND_TIM1_TDH(x)		(x)
+struct nand_ns_info {
+	u32	nand_id;
+	u8	id5;
+};
 
-/* NAND_TIM2_REG (NAND mode) */
-#define NAND_TIM2_TWP(x)		((x) << 24)
-#define NAND_TIM2_TWH(x)		((x) << 16)
-#define NAND_TIM2_TWB(x)		((x) << 8)
-#define NAND_TIM2_TRR(x)		(x)
+static const struct nand_ns_info ns_nand_ids[] = {
+	{0xC2F18095, 0x02},
+	{0xC2DA9095, 0x06},
+	{0xC2DA9095, 0x56},
+	{0xC2D3D195, 0x5A},
+	{0xECDC1095, 0x56},
+};
 
-/* NAND_TIM3_REG (NAND mode) */
-#define NAND_TIM3_TRP(x)		((x) << 24)
-#define NAND_TIM3_TREH(x)		((x) << 16)
-#define NAND_TIM3_TRB(x)		((x) << 8)
-#define NAND_TIM3_TCEH(x)		(x)
+#define FLASH_TIMING_MIN(x, offs) flash_timing(0, x, offs)
+#define FLASH_TIMING_MAX(x, offs) flash_timing(1, x, offs)
 
-/* NAND_TIM4_REG (NAND mode) */
-#define NAND_TIM4_TRDELAY(x)		((x) << 24)
-#define NAND_TIM4_TCLR(x)		((x) << 16)
-#define NAND_TIM4_TWHR(x)		((x) << 8)
-#define NAND_TIM4_TIR(x)		(x)
-
-/* NAND_TIM5_REG (NAND mode) */
-#define NAND_TIM5_TWW(x)		((x) << 16)
-#define NAND_TIM5_TRHZ(x)		((x) << 8)
-#define NAND_TIM5_TAR(x)		(x)
-
-/* NAND_INT_REG (NAND mode) */
-#define NAND_INT_DI			0x1
-
-/* NAND_EXT_CTR_REG */
-#define NAND_EXT_CTR_I5			0x00800000
-#define NAND_EXT_CTR_SP_2X		0x00000001
-
-/* ==========================================================================*/
-#define EC_MDSD		0	/* check main disable and spare disable */
-#define EC_MDSE		1	/* check main disable and spare enable */
-#define EC_MESD		2	/* check main enable and spare disable */
-#define EC_MESE		3	/* check main enable and spare enable */
-
-#define EG_MDSD		0	/* generate main disable and spare disable */
-#define EG_MDSE		1	/* generate main disable and spare enable */
-#define EG_MESD		2	/* generate main enable and spare disable */
-#define EG_MESE		3	/* generate main enable and spare enable */
+#ifndef ROUND_DOWN
+#define ROUND_DOWN(size, align)	((size) & ~((align) - 1))
+#endif
 
-/**
- * Define for xdhost and nand_host
- */
-#define MAIN_ONLY		0
-#define SPARE_ONLY		1
-#define MAIN_ECC		2
-#define SPARE_ECC		3
-#define SPARE_ONLY_BURST	4
-#define SPARE_ECC_BURST		5
+extern u32 get_nand_freq_hz(void);
 
-/* ECC use bch-x bytes */
-#define NAND_ECC_BCH6_BYTES	40	/* 10Bytes/512Bytes, so 40B/2048B */
-#define NAND_ECC_BCH8_BYTES	52	/* 13Bytes/512Bytes, so 52B/2048B */
+static inline int flash_timing(int minmax, int val, int offs)
+{
+	u32 clk, x;
+	int n, r;
 
+	val = (val >> offs) & 0xff;
 
-#define FIO_DMA_CHAN		0
-#define FDMA_CTR_OFFSET		(0x300 + ((FIO_DMA_CHAN) << 4))
-#define FDMA_SRC_OFFSET		(0x304 + ((FIO_DMA_CHAN) << 4))
-#define FDMA_DST_OFFSET		(0x308 + ((FIO_DMA_CHAN) << 4))
-#define FDMA_STA_OFFSET		(0x30c + ((FIO_DMA_CHAN) << 4))
-#define FDMA_DA_OFFSET		(0x380 + ((FIO_DMA_CHAN) << 2))
-#define FDMA_INT_OFFSET		(0x3f0)
+	/* to avoid overflow, divid clk by 1000000 first */
+	clk = get_nand_freq_hz() / 1000000;
 
-#define FDMA_SPR_CNT_OFFSET	(0x200 + ((FIO_DMA_CHAN) << 4))
-#define FDMA_SPR_SRC_OFFSET	(0x204 + ((FIO_DMA_CHAN) << 4))
-#define FDMA_SPR_DST_OFFSET	(0x208 + ((FIO_DMA_CHAN) << 4))
-#define FDMA_SPR_STA_OFFSET	(0x20c + ((FIO_DMA_CHAN) << 4))
-#define FDMA_SPR_DA_OFFSET	(0x280 + ((FIO_DMA_CHAN) << 2))
-#define FDMA_DSM_CTR_OFFSET	(0x3a0 + ((FIO_DMA_CHAN) << 2))
+	x = val * clk;
+	n = x / 1000;
+	r = x % 1000;
 
-/* ==========================================================================*/
-#ifndef __ASM__
-/* ==========================================================================*/
+	if (r != 0)
+		n++;
 
-extern int nand_init(void);
-extern int nand_is_init(void);
-extern int nand_reset(void);
-extern int nand_mark_bad_block(u32 block);
-extern int nand_is_bad_block(u32 block);
-extern void nand_output_bad_block(u32 block, int bb_type);
-extern int nand_read_data(u8 *dst, u8 *src, int len);
-extern int nand_read_pages(u32 block, u32 page, u32 pages, const u8 *main_buf,
-	const u8 *spare_buf, u32 enable_ecc);
-extern int nand_prog_pages(u32 block, u32 page, u32 pages, const u8 *main_buf,
-	const u8 *spare_buf);
-extern int nand_prog_pages_noecc(u32 block, u32 page, u32 pages, const u8 *buf);
-extern int nand_read_spare(u32 block, u32 page, u32 pages, const u8 *buf);
-extern int nand_prog_spare(u32 block, u32 page, u32 pages, const u8 *buf);
-extern int nand_erase_block(u32 block);
-#if defined(CONFIG_NAND_USE_FLASH_BBT)
-extern int nand_scan_bbt(int verbose);
-extern int nand_update_bbt(u32 bblock, u32 gblock);
-extern int nand_erase_bbt(void);
-extern int nand_isbad_bbt(u32 block);
-extern int nand_show_bbt(void);
-extern int nand_has_bbt(void);
-#endif
+	if (minmax)
+		n--;
 
-/* ==========================================================================*/
-#endif
-/* ==========================================================================*/
+	return (n < 1 ? 1 : n) << offs;
+}
 
 #endif
 
diff --git a/include/ambhw/nand_combo.h b/include/ambhw/nand_combo.h
new file mode 100644
index 0000000..403847a
--- /dev/null
+++ b/include/ambhw/nand_combo.h
@@ -0,0 +1,316 @@
+/**
+ * ambhw/nand_combo.h
+ *
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBHW_NAND_COMBO_H__
+#define __AMBHW_NAND_COMBO_H__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+
+#define FIO_OFFSET			0x2000
+#define FIO_4K_OFFSET			0x3000
+
+#define FIO_BASE			(AHB_N_BASE + FIO_OFFSET)
+#define FIO_4K_BASE			(AHB_N_BASE + FIO_4K_OFFSET)
+
+#define FIO_REG(x)			(FIO_BASE + (x))
+#define FIO_4K_REG(x)			(FIO_4K_BASE + (x))
+
+/* Flash I/O Subsystem */
+#define FIO_CTRL_OFFSET			0x00
+#define FIO_RAW_INT_STATUS_OFFSET	0x04
+#define FIO_CTRL2_OFFSET		0x08
+#define FIO_INT_ENABLE_OFFSET		0x0C
+#define FIO_INT_STATUS_OFFSET		0x10
+#define FIO_ECC_RPT_CFG_OFFSET		0xA0
+#define FIO_ECC_RPT_STATUS_OFFSET	0xA4
+#define FIO_ECC_RPT_STATUS2_OFFSET	0xA8
+
+#define FIO_CTRL_REG			FIO_REG(0x00)
+#define FIO_RAW_INT_STATUS_REG		FIO_REG(0x04)
+#define FIO_CTRL2_REG			FIO_REG(0x08)
+#define FIO_INT_ENABLE_REG		FIO_REG(0x0C)
+#define FIO_INT_STATUS_REG		FIO_REG(0x10)
+#define FIO_ECC_RPT_CFG_REG		FIO_REG(0xA0)
+#define FIO_ECC_RPT_STATUS_REG		FIO_REG(0xA4)
+#define FIO_ECC_RPT_STATUS2_REG		FIO_REG(0xA8)
+
+/* NAND Flash Controller */
+#define NAND_CTRL_OFFSET		0x120
+#define NAND_CMD_OFFSET			0x124
+#define NAND_TIMING0_OFFSET		0x128
+#define NAND_TIMING1_OFFSET		0x12c
+#define NAND_TIMING2_OFFSET		0x130
+#define NAND_TIMING3_OFFSET		0x134
+#define NAND_TIMING4_OFFSET		0x138
+#define NAND_TIMING5_OFFSET		0x13c
+#define NAND_STATUS_OFFSET		0x140
+#define NAND_ID_OFFSET			0x144
+#define NAND_COPY_ADDR_OFFSET		0x148
+#define NAND_EXT_CTRL_OFFSET		0x15c
+#define NAND_EXT_ID_OFFSET		0x160
+#define NAND_TIMING6_OFFSET		0x164
+
+#define NAND_CC_OFFSET			0x170
+#define NAND_CC_WORD_OFFSET		0x174
+#define NAND_CP_ADDR_H_OFFSET		0x17C
+#define NAND_CC_DAT0_OFFSET		0x180
+#define NAND_CC_DAT1_OFFSET		0x184
+#define NAND_CC_DAT2_OFFSET		0x188
+#define NAND_CC_DAT3_OFFSET		0x18C
+#define NAND_CC_DAT4_OFFSET		0x190
+#define NAND_CC_DAT5_OFFSET		0x194
+#define NAND_CC_DAT6_OFFSET		0x198
+#define NAND_CC_DAT7_OFFSET		0x19C
+
+#define NAND_CTRL_REG			FIO_REG(0x120)
+#define NAND_CMD_REG			FIO_REG(0x124)
+#define NAND_TIMING0_REG		FIO_REG(0x128)
+#define NAND_TIMING1_REG		FIO_REG(0x12c)
+#define NAND_TIMING2_REG		FIO_REG(0x130)
+#define NAND_TIMING3_REG		FIO_REG(0x134)
+#define NAND_TIMING4_REG		FIO_REG(0x138)
+#define NAND_TIMING5_REG		FIO_REG(0x13c)
+#define NAND_STATUS_REG			FIO_REG(0x140)
+#define NAND_ID_REG			FIO_REG(0x144)
+#define NAND_COPY_ADDR_REG		FIO_REG(0x148)
+#define NAND_EXT_CTRL_REG		FIO_REG(0x15c)
+#define NAND_EXT_ID_REG			FIO_REG(0x160)
+#define NAND_TIMING6_REG		FIO_REG(0x164)
+
+#define NAND_CC_REG			FIO_REG(0x170)
+#define NAND_CC_WORD_REG		FIO_REG(0x174)
+#define NAND_CP_ADDR_H_REG		FIO_REG(0x17C)
+#define NAND_CC_DAT0_REG		FIO_REG(0x180)
+#define NAND_CC_DAT1_REG		FIO_REG(0x184)
+#define NAND_CC_DAT2_REG		FIO_REG(0x188)
+#define NAND_CC_DAT3_REG		FIO_REG(0x18C)
+#define NAND_CC_DAT4_REG		FIO_REG(0x190)
+#define NAND_CC_DAT5_REG		FIO_REG(0x194)
+#define NAND_CC_DAT6_REG		FIO_REG(0x198)
+#define NAND_CC_DAT7_REG		FIO_REG(0x19C)
+
+/* FDMA Engine */
+#define FDMA_SP_MEM_ADDR_OFFSET		0x204
+#define FDMA_MN_CTRL_OFFSET		0x300
+#define FDMA_MN_MEM_ADDR_OFFSET		0x304
+#define FDMA_MN_STATUS_OFFSET		0x30c
+#define FDMA_MN_DESC_ADDR_OFFSET	0x380
+#define FDMA_DSM_CTRL_OFFSET		0x3a0
+
+#define FDMA_SP_MEM_ADDR_REG		FIO_REG(0x204)
+#define FDMA_MN_CTRL_REG		FIO_REG(0x300)
+#define FDMA_MN_MEM_ADDR_REG		FIO_REG(0x304)
+#define FDMA_MN_STATUS_REG		FIO_REG(0x30c)
+#define FDMA_MN_DESC_ADDR_REG		FIO_REG(0x380)
+#define FDMA_DSM_CTRL_REG		FIO_REG(0x3a0)
+
+/*
+ * Bitwise Definition for Flash I/O Subsystem
+ */
+
+/* FIO_CTRL_REG */
+#define FIO_CTRL_SKIP_BLANK_ECC		0x00000080
+#define FIO_CTRL_ECC_BCH_ENABLE		0x00000040
+#define FIO_CTRL_ECC_BCH8		0x00000020 /* this bit is RO */
+#define FIO_CTRL_RDERR_STOP		0x00000008
+#define FIO_CTRL_RANDOM_READ		0x00000002
+
+/* FIO_RAW_INT_STATUS_REG */
+/* FIO_INT_ENABLE_REG */
+/* FIO_INT_STATUS_REG */
+#define FIO_INT_ECC_RPT_UNCORR		0x00000020
+#define FIO_INT_ECC_RPT_THRESH		0x00000010
+#define FIO_INT_AXI_BUS_ERR		0x00000004
+#define FIO_INT_SND_LOOP_TIMEOUT	0x00000002
+#define FIO_INT_OPERATION_DONE		0x00000001
+
+/* FIO_ECC_RPT_CFG_REG */
+#define FIO_ECC_RPT_ERR_NUM_TH(x)	((x) << 16)
+
+/* FIO_ECC_RPT_STATUS_REG */
+#define FIO_ECC_RPT_ERR_DET		0x80000000
+#define FIO_ECC_RPT_CORR_FAIL		0x40000000
+#define FIO_ECC_RPT_CORR_FAIL_OV	0x20000000
+#define FIO_ECC_RPT_MAX_ERR_NUM(v)	(((v) >> 20) & 0xf)
+#define FIO_ECC_RPT_BLK_ADDR(v)		((v) & 0xffff)
+
+/* FIO_ECC_RPT_STATUS2_REG */
+#define FIO_ECC_RPT_UNCORR_BLK_ADDR(v)	((v) & 0xffff)
+
+
+/*
+ * Bitwise Definition for NAND Flash Controller
+ */
+
+/* NAND_CTRL_REG */
+#define NAND_CTRL_A33_32(x)		((x) << 28)
+#define NAND_CTRL_SPARE_ADDR		0x08000000
+#define NAND_CTRL_P3			0x01000000
+#define NAND_CTRL_I4			0x00800000
+#define NAND_CTRL_WAS			0x00000400
+#define NAND_CTRL_WP			0x00000200
+#define NAND_CTRL_SIZE_8G		0x00000070
+#define NAND_CTRL_SIZE_4G		0x00000060
+#define NAND_CTRL_SIZE_2G		0x00000050
+#define NAND_CTRL_SIZE_1G		0x00000040
+#define NAND_CTRL_SIZE_512M		0x00000030
+#define NAND_CTRL_SIZE_256M		0x00000020
+#define NAND_CTRL_SIZE_128M		0x00000010
+#define NAND_CTRL_SIZE_64M		0x00000000
+
+/* NAND_CMD_REG */
+#define NAND_CMD_A31_4(x)		((x) & 0xfffffff0)
+#define NAND_CMD_CMD(c)			((c) & 0xf)
+
+/* NAND_EXT_CTRL_REG */
+#define NAND_EXT_CTRL_4K_PAGE		0x02000000
+#define NAND_EXT_CTRL_DEV_SZ3		0x01000000
+#define NAND_EXT_CTRL_I5		0x00800000
+#define NAND_EXT_CTRL_SPARE_2X		0x00000001
+
+/* NAND_CC_REG */
+#define NAND_CC_TERMINATE_CE		0x80000000
+#define NAND_CC_DATA_SRC_REGISTER	0x00000000
+#define NAND_CC_DATA_SRC_DMA		0x00400000
+#define NAND_CC_ADDR2_NI		0x00080000
+#define NAND_CC_ADDR1_NI		0x00040000
+#define NAND_CC_ADDR_SRC(x)		((x) << 16)
+#define NAND_CC_CMD1(x)			((x) << 14)
+#define NAND_CC_ADDR_CYCLE(x)		((x) << 11)
+#define NAND_CC_CMD2(x)			((x) << 9)
+#define NAND_CC_RW_READ			0x00000100
+#define NAND_CC_RW_WRITE		0x00000080
+#define NAND_CC_RW_NODATA		0x00000000
+#define NAND_CC_WAIT_RB			0x00000020
+#define NAND_CC_WAIT_TWHR		0x00000040
+#define NAND_CC_DATA_CYCLE(x)		((x) << 0)
+
+/* NAND_CC_WORD_REG */
+#define NAND_CC_WORD_CMD1VAL0(c)	((c) & 0xff)
+#define NAND_CC_WORD_CMD1VAL1(c)	(((c) & 0xff) << 8)
+#define NAND_CC_WORD_CMD2VAL0(c)	(((c) & 0xff) << 16)
+#define NAND_CC_WORD_CMD2VAL1(c)	(((c) & 0xff) << 24)
+
+
+/*
+ * Bitwise Definition for FDMA Engine
+ */
+
+/* FDMA_MN_CTRL_REG */
+#define FDMA_CTRL_ENABLE		0x80000000
+#define FDMA_CTRL_DESC_MODE		0x40000000
+#define FDMA_CTRL_WRITE_MEM		0x20000000
+#define FDMA_CTRL_READ_MEM		0x00000000
+#define FDMA_CTRL_BLK_SIZE_32B		0x02000000
+#define FDMA_CTRL_BLK_SIZE_64B		0x03000000
+#define FDMA_CTRL_BLK_SIZE_128B		0x04000000
+#define FDMA_CTRL_BLK_SIZE_256B		0x05000000
+#define FDMA_CTRL_BLK_SIZE_512B		0x06000000
+#define FDMA_CTRL_BLK_SIZE_1024B	0x07000000
+
+/* FDMA_MN_STATUS_REG */
+#define FDMA_STATUS_DESC_BUS_ERR	0x40000000
+#define FDMA_STATUS_DESC_ADDR_ERR	0x20000000
+#define FDMA_STATUS_DESC_DMA_DONE	0x10000000
+#define FDMA_STATUS_DESC_1ST_DONE	0x08000000
+#define FDMA_STATUS_DMA_BUS_ERR		0x02000000
+#define FDMA_STATUS_DMA_ADDR_ERR	0x00800000
+#define FDMA_STATUS_DMA_DONE		0x00400000
+#define FDMA_STATUS_XFER_COUNT(n)	((n) & 0x003fffff)
+
+/* FDMA_DSM_CTRL_REG */
+#define FDMA_DSM_SPARE_JP_SIZE_16B	0x04
+#define FDMA_DSM_SPARE_JP_SIZE_32B	0x05
+#define FDMA_DSM_MAIN_JP_SIZE_512B	0x90
+
+/* ==========================================================================*/
+#ifndef __ASM__
+/* ==========================================================================*/
+
+#if (CHIP_REV == S2L)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{54, 55, 56, 61, 62, 63, 64, 65, \
+					 66, 67, 68, 69, 70, 71, 72}
+#elif (CHIP_REV == S3)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{115, 116, 117, 122, 123, 124, 125, \
+					 126, 127, 128, 129, 130, 131, 132, 133}
+#elif (CHIP_REV == S3L)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{55, 56, 57, 62, 63, 64, 65, 66, \
+					 67, 68, 69, 70, 71, 72, 73}
+#elif (CHIP_REV == S5)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{56, 57, 58, 63, 64, 65, 66, 67, \
+					 68, 69, 70, 71, 72, 73, 74}
+#elif (CHIP_REV == S5L)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{72, 73, 74, 79, 80, 81, 82, 83, \
+					 84, 85, 86, 87, 88, 89, 90}
+#elif (CHIP_REV == CV1)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{86, 87, 88, 93, 94, 95, 96, 97, \
+					 98, 99, 100, 101, 102, 103, 104}
+#else
+#error "MINIPIN nand: not defined!"
+#endif
+
+extern int nand_init(void);
+extern int nand_mark_bad_block(u32 block);
+extern int nand_is_bad_block(u32 block);
+extern int nand_correct_offset(u32 start_blk, u32 offset, u32 *c_offset);
+extern void nand_output_bad_block(u32 block, int bb_type);
+extern int nand_read_data(u8 *dst, u8 *src, int len);
+extern int nand_read_pages(u32 block, u32 page, u32 pages, u8 *main_buf,
+	u8 *spare_buf, u32 enable_ecc);
+extern int nand_prog_pages(u32 block, u32 page, u32 pages, u8 *main_buf,
+	u8 *spare_buf);
+extern int nand_prog_pages_noecc(u32 block, u32 page, u32 pages, u8 *buf);
+extern int nand_read_spare(u32 block, u32 page, u32 pages, u8 *spare_buf);
+extern int nand_prog_spare(u32 block, u32 page, u32 pages, u8 *spare_buf);
+extern int nand_erase_block(u32 block);
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+extern int nand_scan_bbt(int verbose);
+extern int nand_update_bbt(u32 bblock, u32 gblock);
+extern int nand_erase_bbt(void);
+extern int nand_isbad_bbt(u32 block);
+extern int nand_show_bbt(void);
+extern int nand_has_bbt(void);
+#endif
+
+/* ==========================================================================*/
+#endif
+/* ==========================================================================*/
+
+#endif
+
diff --git a/include/ambhw/nand_legacy.h b/include/ambhw/nand_legacy.h
new file mode 100644
index 0000000..d175199
--- /dev/null
+++ b/include/ambhw/nand_legacy.h
@@ -0,0 +1,478 @@
+/**
+ * ambhw/nand_legacy.h
+ *
+ * Author: Anthony Ginger <hfjiang@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBHW_NAND_LEGACY_H__
+#define __AMBHW_NAND_LEGACY_H__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+
+#define FIO_FIFO_OFFSET			0x0000
+#define FIO_OFFSET			0x1000
+#define FIO_4K_OFFSET			0x30000
+
+#define FIO_FIFO_BASE			(AHB_N_BASE + FIO_FIFO_OFFSET)
+#define FIO_BASE			(AHB_N_BASE + FIO_OFFSET)
+#define FIO_4K_BASE			(AHB_N_BASE + FIO_4K_OFFSET)
+
+#define FIO_REG(x)			(FIO_BASE + (x))
+#define FIO_4K_REG(x)			(FIO_4K_BASE + (x))
+
+/* ==========================================================================*/
+
+#if (CHIP_REV == S2L)  || (CHIP_REV == S3)
+#define FIO_SUPPORT_SKIP_BLANK_ECC	0
+#else
+#define FIO_SUPPORT_SKIP_BLANK_ECC	1
+#endif
+
+#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#define NAND_ECC_RPT_NUM_SUPPORT	0
+#else
+#define NAND_ECC_RPT_NUM_SUPPORT	1
+#endif
+
+#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#define NAND_CUSTOM_CMD_SUPPORT	0
+#else
+#define NAND_CUSTOM_CMD_SUPPORT	1
+#endif
+
+/* ==========================================================================*/
+
+#define FIO_CTR_OFFSET			0x000
+#define FIO_STA_OFFSET			0x004
+#define FIO_DMACTR_OFFSET		0x080
+#define FIO_DMAADR_OFFSET		0x084
+#define FIO_DMASTA_OFFSET		0x08c
+#define FIO_DSM_CTR_OFFSET              0x0a0
+#define FIO_ECC_RPT_STA_OFFSET          0x0a4
+
+#define FLASH_CTR_OFFSET		0x120
+#define FLASH_CMD_OFFSET		0x124
+#define FLASH_TIM0_OFFSET		0x128
+#define FLASH_TIM1_OFFSET		0x12c
+#define FLASH_TIM2_OFFSET		0x130
+#define FLASH_TIM3_OFFSET		0x134
+#define FLASH_TIM4_OFFSET		0x138
+#define FLASH_TIM5_OFFSET		0x13c
+#define FLASH_STA_OFFSET		0x140
+#define FLASH_ID_OFFSET			0x144
+#define FLASH_CFI_OFFSET		0x148
+#define FLASH_LEN_OFFSET		0x14c
+#define FLASH_INT_OFFSET		0x150
+#define FLASH_EX_CTR_OFFSET		0x15c
+#define FLASH_EX_ID_OFFSET		0x160
+
+/* followings are for customer command, start from S3L */
+#define FLASH_TIM6_OFFSET		0x164
+#define FLASH_CC_OFFSET			0x170
+#define FLASH_CC_WORD_OFFSET		0x174
+#define FLASH_CC_DATA0_OFFSET		0x180
+#define FLASH_CC_DATA1_OFFSET		0x184
+#define FLASH_CC_DATA2_OFFSET		0x188
+#define FLASH_CC_DATA3_OFFSET		0x18c
+#define FLASH_CC_DATA4_OFFSET		0x190
+#define FLASH_CC_DATA5_OFFSET		0x194
+#define FLASH_CC_DATA6_OFFSET		0x198
+#define FLASH_CC_DATA7_OFFSET		0x19c
+
+#define FIO_CTR_REG			FIO_REG(0x000)
+#define FIO_STA_REG			FIO_REG(0x004)
+#define FIO_DMACTR_REG			FIO_REG(0x080)
+#define FIO_DMAADR_REG			FIO_REG(0x084)
+#define FIO_DMASTA_REG			FIO_REG(0x08c)
+#define FIO_DSM_CTR_REG			FIO_REG(0x0a0)
+#define FIO_ECC_RPT_STA_REG		FIO_REG(0x0a4)
+
+#define NAND_CTR_REG			FIO_REG(0x120)
+#define NAND_CMD_REG			FIO_REG(0x124)
+#define NAND_TIMING0_REG		FIO_REG(0x128)
+#define NAND_TIMING1_REG		FIO_REG(0x12c)
+#define NAND_TIMING2_REG		FIO_REG(0x130)
+#define NAND_TIMING3_REG		FIO_REG(0x134)
+#define NAND_TIMING4_REG		FIO_REG(0x138)
+#define NAND_TIMING5_REG		FIO_REG(0x13c)
+#define NAND_STA_REG			FIO_REG(0x140)
+#define NAND_ID_REG			FIO_REG(0x144)
+#define NAND_COPY_ADDR_REG		FIO_REG(0x148)
+#define NAND_LEN_REG			FIO_REG(0x14c)
+#define NAND_INT_REG			FIO_REG(0x150)
+#define NAND_EXT_CTR_REG		FIO_REG(0x15c)
+#define NAND_EXT_ID5_REG		FIO_REG(0x160)
+
+/* followings are for customer command, start from S3L */
+#define NAND_TIMING6_REG		FIO_REG(0x164)
+#define NAND_CC_REG			FIO_REG(0x170)
+#define NAND_CC_WORD_REG		FIO_REG(0x174)
+#define NAND_CC_DATA0_REG		FIO_REG(0x180)
+#define NAND_CC_DATA1_REG		FIO_REG(0x184)
+#define NAND_CC_DATA2_REG		FIO_REG(0x188)
+#define NAND_CC_DATA3_REG		FIO_REG(0x18c)
+#define NAND_CC_DATA4_REG		FIO_REG(0x190)
+#define NAND_CC_DATA5_REG		FIO_REG(0x194)
+#define NAND_CC_DATA6_REG		FIO_REG(0x198)
+#define NAND_CC_DATA7_REG		FIO_REG(0x19c)
+
+#define NAND_READ_CMDWORD_REG		FIO_REG(0x154)
+#define NAND_PROG_CMDWORD_REG		FIO_REG(0x158)
+#define NAND_CMDWORD1(x)		((x) << 16)
+#define NAND_CMDWORD2(x)		((x) & 0xff)
+
+#define NAND_CPS1_ADDR_REG		FIO_REG(0x154)
+#define NAND_CPD1_ADDR_REG		FIO_REG(0x158)
+#define NAND_CPS2_ADDR_REG		FIO_REG(0x15c)
+#define NAND_CPD2_ADDR_REG		FIO_REG(0x160)
+#define NAND_CPS3_ADDR_REG		FIO_REG(0x164)
+#define NAND_CPD3_ADDR_REG		FIO_REG(0x168)
+#define NAND_NBR_SPA_REG		FIO_REG(0x16c)
+
+
+/* ==========================================================================*/
+
+/* FIO_CTR_REG */
+#define FIO_CTR_DA			0x00020000
+#define FIO_CTR_DR			0x00010000
+#define FIO_CTR_SX			0x00000100
+#if (FIO_SUPPORT_SKIP_BLANK_ECC == 1)
+#define FIO_CTR_SKIP_BLANK		0x00000080
+#else
+#define FIO_CTR_SKIP_BLANK		0x00000000
+#endif
+#define FIO_CTR_ECC_8BIT		0x00000060
+#define FIO_CTR_ECC_6BIT		0x00000040
+#define FIO_CTR_RS			0x00000010
+#define FIO_CTR_SE			0x00000008
+#define FIO_CTR_CO			0x00000004
+#define FIO_CTR_RR			0x00000002
+#define FIO_CTR_XD			0x00000001
+
+/* FIO_STA_REG */
+#define FIO_STA_SI			0x00000008
+#define FIO_STA_CI			0x00000004
+#define FIO_STA_XI			0x00000002
+#define FIO_STA_FI			0x00000001
+
+/* FIO_DMACTR_REG */
+#define FIO_DMACTR_EN			0x80000000
+#define FIO_DMACTR_RM			0x40000000
+#define FIO_DMACTR_SD			0x30000000
+#define FIO_DMACTR_CF			0x20000000
+#define FIO_DMACTR_XD			0x10000000
+#define FIO_DMACTR_FL			0x00000000
+#define FIO_DMACTR_BLK_32768B		0x0c000000
+#define FIO_DMACTR_BLK_16384B		0x0b000000
+#define FIO_DMACTR_BLK_8192B		0x0a000000
+#define FIO_DMACTR_BLK_4096B		0x09000000
+#define FIO_DMACTR_BLK_2048B		0x08000000
+#define FIO_DMACTR_BLK_1024B		0x07000000
+#define FIO_DMACTR_BLK_256B		0x05000000
+#define FIO_DMACTR_BLK_512B		0x06000000
+#define FIO_DMACTR_BLK_128B		0x04000000
+#define FIO_DMACTR_BLK_64B		0x03000000
+#define FIO_DMACTR_BLK_32B		0x02000000
+#define FIO_DMACTR_BLK_16B		0x01000000
+#define FIO_DMACTR_BLK_8B		0x00000000
+#define FIO_DMACTR_TS8B			0x00c00000
+#define FIO_DMACTR_TS4B			0x00800000
+#define FIO_DMACTR_TS2B			0x00400000
+#define FIO_DMACTR_TS1B			0x00000000
+
+/* FIO_DMASTA_REG */
+#define FIO_DMASTA_RE			0x04000000
+#define FIO_DMASTA_AE			0x02000000
+#define FIO_DMASTA_DN			0x01000000
+
+/* FIO_DSM_CTR_REG */
+#define FIO_DSM_EN			0x80000000
+#define FIO_DSM_MAJP_2KB		0x00000090
+#define FIO_DSM_SPJP_64B		0x00000004
+#define FIO_DSM_SPJP_128B		0x00000005
+
+/* FIO_ECC_RPT_REG */
+#define FIO_ECC_RPT_ERR			0x80000000
+#define FIO_ECC_RPT_FAIL		0x40000000
+
+/* NAND_CTR_REG */
+#define NAND_CTR_A(x)			((x) << 28)
+#define NAND_CTR_SA			0x08000000
+#define NAND_CTR_SE			0x04000000
+#define NAND_CTR_C2			0x02000000
+#define NAND_CTR_P3			0x01000000
+#define NAND_CTR_I4			0x00800000
+#define NAND_CTR_RC			0x00400000
+#define NAND_CTR_CC			0x00200000
+#define NAND_CTR_CE			0x00100000
+#define NAND_CTR_EC_MAIN		0x00080000
+#define NAND_CTR_EC_SPARE		0x00040000
+#define NAND_CTR_EG_MAIN		0x00020000
+#define NAND_CTR_EG_SPARE		0x00010000
+#define NAND_CTR_WP			0x00000200
+#define NAND_CTR_IE			0x00000100
+#define NAND_CTR_XS			0x00000080
+#define NAND_CTR_SZ_8G			0x00000070
+#define NAND_CTR_SZ_4G			0x00000060
+#define NAND_CTR_SZ_2G			0x00000050
+#define NAND_CTR_SZ_1G			0x00000040
+#define NAND_CTR_SZ_512M		0x00000030
+#define NAND_CTR_SZ_256M		0x00000020
+#define NAND_CTR_SZ_128M		0x00000010
+#define NAND_CTR_SZ_64M			0x00000000
+#define NAND_CTR_4BANK			0x00000008
+#define NAND_CTR_2BANK			0x00000004
+#define NAND_CTR_1BANK			0x00000000
+#define NAND_CTR_WD_64BIT		0x00000003
+#define NAND_CTR_WD_32BIT		0x00000002
+#define NAND_CTR_WD_16BIT		0x00000001
+#define NAND_CTR_WD_8BIT		0x00000000
+
+#define NAND_CTR_INTLVE			0x80000000
+#define NAND_CTR_SPRBURST		0x40000000
+#define NAND_CFG_STAT_ENB		0x00002000
+#define NAND_CTR_2INTL			0x00001000
+#define NAND_CTR_K9			0x00000800
+
+#define NAND_CTR_WAS			0x00000400
+
+/* NAND_CMD_REG */
+#define NAND_AMB_CMD_ADDR(x)		((x) << 4)
+#define NAND_AMB_CMD_NOP		0x0
+#define NAND_AMB_CMD_DMA		0x1
+#define NAND_AMB_CMD_RESET		0x2
+#define NAND_AMB_CMD_NOP2		0x3
+#define NAND_AMB_CMD_NOP3		0x4
+#define NAND_AMB_CMD_NOP4		0x5
+#define NAND_AMB_CMD_NOP5		0x6
+#define NAND_AMB_CMD_COPYBACK		0x7
+#define NAND_AMB_CMD_NOP6		0x8
+#define NAND_AMB_CMD_ERASE		0x9
+#define NAND_AMB_CMD_READID		0xa
+#define NAND_AMB_CMD_NOP7		0xb
+#define NAND_AMB_CMD_READSTATUS		0xc
+#define NAND_AMB_CMD_NOP8		0xd
+#define NAND_AMB_CMD_READ		0xe
+#define NAND_AMB_CMD_PROGRAM		0xf
+
+/* NAND_CC_REG */
+#define NAND_CC_TERM_CE_HIGH	0x80000000
+#define NAND_CC_CMD1_VAL0		0x00004000
+#define NAND_CC_CMD1_VAL1		0x00008000
+#define NAND_CC_CMD2_VAL0		0x00000200
+#define NAND_CC_CMD2_VAL1		0x00000400
+#define NAND_CC_RW_WE			0x00000080
+#define NAND_CC_RW_RE			0x00000100
+#define NAND_CC_WAIT_RB			0x00000020
+#define NAND_CC_WAIT_TWHR		0x00000040
+
+/* NAND_INT_REG (NAND mode) */
+#define NAND_INT_DI			0x1
+
+/* NAND_EXT_CTR_REG */
+#define NAND_EXT_CTR_I5			0x00800000
+#define NAND_EXT_CTR_SP_2X		0x00000001
+
+/* ==========================================================================*/
+
+#define FDMA_OFFSET			0x12000
+#define FDMA_BASE			(AHB_N_BASE + FDMA_OFFSET)
+#define FDMA_REG(x)			(FDMA_BASE + (x))
+
+#define FDMA_CTR_OFFSET			0x300
+#define FDMA_SRC_OFFSET			0x304
+#define FDMA_DST_OFFSET			0x308
+#define FDMA_STA_OFFSET			0x30c
+#define FDMA_DA_OFFSET			0x380
+#define FDMA_DSM_CTR_OFFSET		0x3a0
+#define FDMA_INT_OFFSET			0x3f0
+
+#define FDMA_SPR_CNT_OFFSET		0x200
+#define FDMA_SPR_SRC_OFFSET		0x204
+#define FDMA_SPR_DST_OFFSET		0x208
+#define FDMA_SPR_STA_OFFSET		0x20c
+#define FDMA_SPR_DA_OFFSET		0x280
+
+#define FDMA_CHAN_CTR_REG		FDMA_REG(FDMA_CTR_OFFSET)
+#define FDMA_CHAN_SRC_REG		FDMA_REG(FDMA_SRC_OFFSET)
+#define FDMA_CHAN_DST_REG		FDMA_REG(FDMA_DST_OFFSET)
+#define FDMA_CHAN_STA_REG		FDMA_REG(FDMA_STA_OFFSET)
+#define FDMA_CHAN_DA_REG		FDMA_REG(FDMA_DA_OFFSET)
+#define FDMA_CHAN_DSM_CTR_REG		FDMA_REG(FDMA_DSM_CTR_OFFSET)
+
+#define FDMA_CHAN_SPR_CNT_REG		FDMA_REG(FDMA_SPR_CNT_OFFSET)
+#define FDMA_CHAN_SPR_SRC_REG		FDMA_REG(FDMA_SPR_SRC_OFFSET)
+#define FDMA_CHAN_SPR_DST_REG		FDMA_REG(FDMA_SPR_DST_OFFSET)
+#define FDMA_CHAN_SPR_STA_REG		FDMA_REG(FDMA_SPR_STA_OFFSET)
+#define FDMA_CHAN_SPR_DA_REG		FDMA_REG(FDMA_SPR_DA_OFFSET)
+
+
+/* FDMA_CTR_REG */
+#define FDMA_CHAN_CTR_EN		0x80000000
+#define FDMA_CHAN_CTR_D			0x40000000
+#define FDMA_CHAN_CTR_WM		0x20000000
+#define FDMA_CHAN_CTR_RM		0x10000000
+#define FDMA_CHAN_CTR_NI		0x08000000
+#define FDMA_CHAN_CTR_BLK_1024B		0x07000000
+#define FDMA_CHAN_CTR_BLK_512B		0x06000000
+#define FDMA_CHAN_CTR_BLK_256B		0x05000000
+#define FDMA_CHAN_CTR_BLK_128B		0x04000000
+#define FDMA_CHAN_CTR_BLK_64B		0x03000000
+#define FDMA_CHAN_CTR_BLK_32B		0x02000000
+#define FDMA_CHAN_CTR_BLK_16B		0x01000000
+#define FDMA_CHAN_CTR_BLK_8B		0x00000000
+#define FDMA_CHAN_CTR_TS_8B		0x00C00000
+#define FDMA_CHAN_CTR_TS_4B		0x00800000
+#define FDMA_CHAN_CTR_TS_2B		0x00400000
+#define FDMA_CHAN_CTR_TS_1B		0x00000000
+
+/* FDMA descriptor bit fields */
+#define FDMA_DESC_EOC			0x01000000
+#define FDMA_DESC_WM			0x00800000
+#define FDMA_DESC_RM			0x00400000
+#define FDMA_DESC_NI			0x00200000
+#define FDMA_DESC_TS_8B			0x00180000
+#define FDMA_DESC_TS_4B			0x00100000
+#define FDMA_DESC_TS_2B			0x00080000
+#define FDMA_DESC_TS_1B			0x00000000
+#define FDMA_DESC_BLK_1024B		0x00070000
+#define FDMA_DESC_BLK_512B		0x00060000
+#define FDMA_DESC_BLK_256B		0x00050000
+#define FDMA_DESC_BLK_128B		0x00040000
+#define FDMA_DESC_BLK_64B		0x00030000
+#define FDMA_DESC_BLK_32B		0x00020000
+#define FDMA_DESC_BLK_16B		0x00010000
+#define FDMA_DESC_BLK_8B		0x00000000
+#define FDMA_DESC_ID			0x00000004
+#define FDMA_DESC_IE			0x00000002
+#define FDMA_DESC_ST			0x00000001
+
+/* FDMA_STA_REG */
+#define FDMA_CHAN_STA_DM		0x80000000
+#define FDMA_CHAN_STA_OE		0x40000000
+#define FDMA_CHAN_STA_DA		0x20000000
+#define FDMA_CHAN_STA_DD		0x10000000
+#define FDMA_CHAN_STA_OD		0x08000000
+#define FDMA_CHAN_STA_ME		0x04000000
+#define FDMA_CHAN_STA_BE		0x02000000
+#define FDMA_CHAN_STA_RWE		0x01000000
+#define FDMA_CHAN_STA_AE		0x00800000
+#define FDMA_CHAN_STA_DN		0x00400000
+
+/* ==========================================================================*/
+
+#define EC_MDSD			0 /* check main disable and spare disable */
+#define EC_MDSE			1 /* check main disable and spare enable */
+#define EC_MESD			2 /* check main enable and spare disable */
+#define EC_MESE			3 /* check main enable and spare enable */
+
+#define EG_MDSD			0 /* generate main disable and spare disable */
+#define EG_MDSE			1 /* generate main disable and spare enable */
+#define EG_MESD			2 /* generate main enable and spare disable */
+#define EG_MESE			3 /* generate main enable and spare enable */
+
+#define MAIN_ONLY		0
+#define SPARE_ONLY		1
+#define MAIN_ECC		2
+#define SPARE_ECC		3
+
+#if (CHIP_REV == S2L)
+#define FDMA_NODC_MN_BURST_SIZE	(FDMA_CHAN_CTR_BLK_512B | FDMA_CHAN_CTR_TS_4B)
+#define FDMA_NODC_SP_BURST_SIZE	(FDMA_CHAN_CTR_BLK_16B | FDMA_CHAN_CTR_TS_4B)
+#define FDMA_DESC_MN_BURST_SIZE	(FDMA_DESC_BLK_512B | FDMA_DESC_TS_4B)
+#define FDMA_DESC_SP_BURST_SIZE	(FDMA_DESC_BLK_16B | FDMA_DESC_TS_4B)
+#else
+#define FDMA_NODC_MN_BURST_SIZE	(FDMA_CHAN_CTR_BLK_512B | FDMA_CHAN_CTR_TS_8B)
+#define FDMA_NODC_SP_BURST_SIZE	(FDMA_CHAN_CTR_BLK_16B | FDMA_CHAN_CTR_TS_8B)
+#define FDMA_DESC_MN_BURST_SIZE	(FDMA_DESC_BLK_512B | FDMA_DESC_TS_8B)
+#define FDMA_DESC_SP_BURST_SIZE	(FDMA_DESC_BLK_16B | FDMA_DESC_TS_8B)
+#endif
+
+/* ==========================================================================*/
+#ifndef __ASM__
+/* ==========================================================================*/
+
+#if (CHIP_REV == S2L)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{54, 55, 56, 61, 62, 63, 64, 65, \
+					 66, 67, 68, 69, 70, 71, 72}
+#elif (CHIP_REV == S3)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{115, 116, 117, 122, 123, 124, 125, \
+					 126, 127, 128, 129, 130, 131, 132, 133}
+#elif (CHIP_REV == S3L)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{55, 56, 57, 62, 63, 64, 65, 66, \
+					 67, 68, 69, 70, 71, 72, 73}
+#elif (CHIP_REV == S5)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{56, 57, 58, 63, 64, 65, 66, 67, \
+					 68, 69, 70, 71, 72, 73, 74}
+#elif (CHIP_REV == S5L)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{72, 73, 74, 79, 80, 81, 82, 83, \
+					 84, 85, 86, 87, 88, 89, 90}
+#elif (CHIP_REV == CV1)
+#define MINIPIN_NAND_ALTFUNC		2
+#define MINIPIN_NAND_PIN		{86, 87, 88, 93, 94, 95, 96, 97, \
+					 98, 99, 100, 101, 102, 103, 104}
+#else
+#error "MINIPIN nand: not defined!"
+#endif
+
+extern int nand_init(void);
+extern int nand_mark_bad_block(u32 block);
+extern int nand_is_bad_block(u32 block);
+extern int nand_correct_offset(u32 start_blk, u32 offset, u32 *c_offset);
+extern void nand_output_bad_block(u32 block, int bb_type);
+extern int nand_read_data(u8 *dst, u8 *src, int len);
+extern int nand_read_pages(u32 block, u32 page, u32 pages, u8 *main_buf,
+	u8 *spare_buf, u32 enable_ecc);
+extern int nand_prog_pages(u32 block, u32 page, u32 pages, u8 *main_buf,
+	u8 *spare_buf);
+extern int nand_prog_pages_noecc(u32 block, u32 page, u32 pages, u8 *buf);
+extern int nand_read_spare(u32 block, u32 page, u32 pages, u8 *buf);
+extern int nand_prog_spare(u32 block, u32 page, u32 pages, u8 *buf);
+extern int nand_erase_block(u32 block);
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+extern int nand_scan_bbt(int verbose);
+extern int nand_update_bbt(u32 bblock, u32 gblock);
+extern int nand_erase_bbt(void);
+extern int nand_isbad_bbt(u32 block);
+extern int nand_show_bbt(void);
+extern int nand_has_bbt(void);
+#endif
+
+/* ==========================================================================*/
+#endif
+/* ==========================================================================*/
+
+#endif
+
diff --git a/include/ambhw/rct.h b/include/ambhw/rct.h
index 5e61111..f515a25 100644
--- a/include/ambhw/rct.h
+++ b/include/ambhw/rct.h
@@ -1,737 +1,805 @@
-/*
- * ambhw/rct.h
- *
- * History:
- *	2006/12/27 - [Charles Chiou] created file
- *
- * Copyright (C) 2006-2008, Ambarella, Inc.
- */
-
-#ifndef __AMBHW_RCT_H__
-#define __AMBHW_RCT_H__
-
-/* ==========================================================================*/
-#define RCT_OFFSET			0x170000
-#if (CHIP_REV == A8) || (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define RCT_BASE			(DBGBUS_BASE + RCT_OFFSET)
-#define RCT_PHYS_BASE			(DBGBUS_PHYS_BASE + RCT_OFFSET)
-#else
-#define RCT_BASE			(APB_BASE + RCT_OFFSET)
-#define RCT_PHYS_BASE			(APB_PHYS_BASE + RCT_OFFSET)
-#endif
-#define RCT_REG(x)			(RCT_BASE + (x))
-
-/* ==========================================================================*/
-#define PLL_LOCK_OFFSET			0x2C
-#define SOFT_OR_DLL_RESET_OFFSET	0x68
-
-#define PLL_LOCK_REG			RCT_REG(PLL_LOCK_OFFSET)
-#define SOFT_OR_DLL_RESET_REG		RCT_REG(SOFT_OR_DLL_RESET_OFFSET)
-
-/* ==========================================================================*/
-#define FIO_RESET_OFFSET		0x74
-#define FIO_RESET_REG			RCT_REG(FIO_RESET_OFFSET)
-#define FIO_RESET_FIO_RST		0x00000008
-#define FIO_RESET_CF_RST		0x00000004
-#define FIO_RESET_XD_RST		0x00000002
-#define FIO_RESET_FLASH_RST		0x00000001
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S) || (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define USBP1_CTRL_OFFSET		0x88
-#define UDC_SOFT_RESET_OFFSET		USBP1_CTRL_OFFSET
-#define UDC_SOFT_RESET_MASK		0x20000000
-#else
-#define USBC_CTRL_OFFSET		0x2cc
-#define UDC_SOFT_RESET_OFFSET		USBC_CTRL_OFFSET
-#define UDC_SOFT_RESET_MASK		0x2
-#endif
-#define UDC_SOFT_RESET_REG		RCT_REG(UDC_SOFT_RESET_OFFSET)
-
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define USB0_IS_HOST_MASK		0x00000020
-#else
-#define USBP0_SEL_OFFSET		0x2c0
-#define USBP0_SEL_REG			RCT_REG(USBP0_SEL_OFFSET)
-#define USB0_IS_HOST_MASK		0x00000002
-#endif
-
-/* ==========================================================================*/
-#define PLL_AUDIO_CTRL_OFFSET		0x54
-#define PLL_AUDIO_FRAC_OFFSET		0x58
-#define SCALER_AUDIO_POST_OFFSET	0x5C
-#define SCALER_AUDIO_PRE_OFFSET		0x60
-#define PLL_AUDIO_CTRL2_OFFSET		0x124
-#define PLL_AUDIO_CTRL3_OFFSET		0x12c
-
-#define PLL_AUDIO_CTRL_REG		RCT_REG(PLL_AUDIO_CTRL_OFFSET)
-#define PLL_AUDIO_FRAC_REG		RCT_REG(PLL_AUDIO_FRAC_OFFSET)
-#define SCALER_AUDIO_POST_REG		RCT_REG(SCALER_AUDIO_POST_OFFSET)
-#define SCALER_AUDIO_PRE_REG		RCT_REG(SCALER_AUDIO_PRE_OFFSET)
-#define PLL_AUDIO_CTRL2_REG		RCT_REG(PLL_AUDIO_CTRL2_OFFSET)
-#define PLL_AUDIO_CTRL3_REG		RCT_REG(PLL_AUDIO_CTRL3_OFFSET)
-
-/* ==========================================================================*/
-#define ANA_PWR_OFFSET			0x50
-#define ANA_PWR_REG			RCT_REG(ANA_PWR_OFFSET)
-#define ANA_PWR_POWER_DOWN		0x0020
-
-#define SYS_CONFIG_OFFSET		0x34
-#define SYS_CONFIG_REG			RCT_REG(SYS_CONFIG_OFFSET)
-
-#define WDT_RST_L_OFFSET		0x78
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define UNLOCK_WDT_RST_L_OFFSET		0x50
-#define UNLOCK_WDT_RST_L_VAL		0x80
-#else
-#define UNLOCK_WDT_RST_L_OFFSET		0x260
-#define UNLOCK_WDT_RST_L_VAL		0x01
-#endif
-#define WDT_RST_L_REG			RCT_REG(WDT_RST_L_OFFSET)
-#define UNLOCK_WDT_RST_L_REG		RCT_REG(UNLOCK_WDT_RST_L_OFFSET)
-
-/* ==========================================================================*/
-#define CG_UART_OFFSET			0x38
-#define CG_SSI_OFFSET			0x3C
-#define CG_MOTOR_OFFSET			0x40
-#define CG_IR_OFFSET			0x44
-#define CG_HOST_OFFSET			0x48
-#define CG_PWM_OFFSET			0x84
-#define CG_SSI2_OFFSET			0xEC
-#define CLK_REF_SSI_OFFSET		0x19c
-#define CG_SSI3_OFFSET			0x518
-#define CLK_REF_SSI3_OFFSET		0x51c
-
-#define CG_UART_REG			RCT_REG(CG_UART_OFFSET)
-#define CG_SSI_REG			RCT_REG(CG_SSI_OFFSET)
-#define CG_MOTOR_REG			RCT_REG(CG_MOTOR_OFFSET)
-#define CG_IR_REG			RCT_REG(CG_IR_OFFSET)
-#define CG_HOST_REG			RCT_REG(CG_HOST_OFFSET)
-#define CG_PWM_REG			RCT_REG(CG_PWM_OFFSET)
-#define CG_SSI2_REG			RCT_REG(CG_SSI2_OFFSET)
-#define CG_SSI3_REG			RCT_REG(CG_SSI3_OFFSET)
-#define CLK_REF_SSI_REG			RCT_REG(CLK_REF_SSI_OFFSET)
-#define CLK_REF_SSI3_REG		RCT_REG(CLK_REF_SSI3_OFFSET)
-
-#define UART_CLK_SRC_CLK_REF		0x00
-#define UART_CLK_SRC_CORE		0x01
-#define UART_CLK_SRC_IDSP		0x03
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define UART_CLK_SRC_SEL_OFFSET		0x320
-#else
-#define UART_CLK_SRC_SEL_OFFSET		0x1C8
-#endif
-#define UART_CLK_SRC_SEL_REG		RCT_REG(UART_CLK_SRC_SEL_OFFSET)
-
-/* ==========================================================================*/
-#define PLL_CORE_CTRL_OFFSET		0x00
-#define PLL_CORE_FRAC_OFFSET		0x04
-#define PLL_CORE_CTRL2_OFFSET		0x100
-#define PLL_CORE_CTRL3_OFFSET		0x104
-#define PLL_CORE_CTRL_REG		RCT_REG(PLL_CORE_CTRL_OFFSET)
-#define PLL_CORE_FRAC_REG		RCT_REG(PLL_CORE_FRAC_OFFSET)
-#define PLL_CORE_CTRL2_REG		RCT_REG(PLL_CORE_CTRL2_OFFSET)
-#define PLL_CORE_CTRL3_REG		RCT_REG(PLL_CORE_CTRL3_OFFSET)
-
-#if ((CHIP_REV == A5S) || (CHIP_REV == S2) || (CHIP_REV == S2E))
-#define SCALER_CORE_POST_OFFSET		0x118
-#define CORE_CLK_RATIO_1X_OFFSET	0x24C
-#define SCALER_CORE_POST_REG		RCT_REG(SCALER_CORE_POST_OFFSET)
-#define CORE_CLK_RATIO_1X_REG		RCT_REG(CORE_CLK_RATIO_1X_OFFSET)
-#endif
-
-/* ==========================================================================*/
-
-#define PLL_HDMILC_CTRL_OFFSET		0x404
-#define PLL_HDMILC_FRAC_OFFSET		0x408
-#define PLL_HDMILC_CTRL2_OFFSET		0x40c
-#define PLL_HDMILC_CTRL3_OFFSET		0x410
-#define PLL_HDMILC_CTRL4_OFFSET		0x418
-#define PLL_HDMILC_CTRL_REG		RCT_REG(PLL_HDMILC_CTRL_OFFSET)
-#define PLL_HDMILC_FRAC_REG		RCT_REG(PLL_HDMILC_FRAC_OFFSET)
-#define PLL_HDMILC_CTRL2_REG		RCT_REG(PLL_HDMILC_CTRL2_OFFSET)
-#define PLL_HDMILC_CTRL3_REG		RCT_REG(PLL_HDMILC_CTRL3_OFFSET)
-#define PLL_HDMILC_CTRL4_REG		RCT_REG(PLL_HDMILC_CTRL4_OFFSET)
-
-/* ==========================================================================*/
-#define PLL_IDSP_CTRL_OFFSET		0xE4
-#define PLL_IDSP_FRAC_OFFSET		0xE8
-#define PLL_IDSP_CTRL2_OFFSET		0x108
-#define PLL_IDSP_CTRL3_OFFSET		0x10C
-#define SCALER_IDSP_POST_OFFSET		0x1F4
-
-#define PLL_IDSP_CTRL_REG		RCT_REG(PLL_IDSP_CTRL_OFFSET)
-#define PLL_IDSP_FRAC_REG		RCT_REG(PLL_IDSP_FRAC_OFFSET)
-#define PLL_IDSP_CTRL2_REG		RCT_REG(PLL_IDSP_CTRL2_OFFSET)
-#define PLL_IDSP_CTRL3_REG		RCT_REG(PLL_IDSP_CTRL3_OFFSET)
-#define SCALER_IDSP_POST_REG		RCT_REG(SCALER_IDSP_POST_OFFSET)
-
-/* ==========================================================================*/
-#define PLL_DDR_CTRL_OFFSET		0xDC
-#define PLL_DDR_FRAC_OFFSET		0xE0
-#define PLL_DDR_CTRL2_OFFSET		0x110
-#define PLL_DDR_CTRL3_OFFSET		0x114
-
-#define PLL_DDR_CTRL_REG		RCT_REG(PLL_DDR_CTRL_OFFSET)
-#define PLL_DDR_FRAC_REG		RCT_REG(PLL_DDR_FRAC_OFFSET)
-#define PLL_DDR_CTRL2_REG		RCT_REG(PLL_DDR_CTRL2_OFFSET)
-#define PLL_DDR_CTRL3_REG		RCT_REG(PLL_DDR_CTRL3_OFFSET)
-
-/* ==========================================================================*/
-#define PLL_SENSOR_CTRL_OFFSET		0x24
-#define PLL_SENSOR_FRAC_OFFSET		0x28
-#define PLL_SENSOR_CTRL2_OFFSET		0x11C
-#define PLL_SENSOR_CTRL3_OFFSET		0x120
-#define SCALER_SENSOR_PRE_OFFSET	0x4C
-#define SCALER_SENSOR_POST_OFFSET	0x30
-#define CLK_SI_INPUT_MODE_OFFSET	0xBC
-
-#define PLL_SENSOR_CTRL_REG		RCT_REG(PLL_SENSOR_CTRL_OFFSET)
-#define PLL_SENSOR_FRAC_REG		RCT_REG(PLL_SENSOR_FRAC_OFFSET)
-#define PLL_SENSOR_CTRL2_REG		RCT_REG(PLL_SENSOR_CTRL2_OFFSET)
-#define PLL_SENSOR_CTRL3_REG		RCT_REG(PLL_SENSOR_CTRL3_OFFSET)
-#define SCALER_SENSOR_PRE_REG		RCT_REG(SCALER_SENSOR_PRE_OFFSET)
-#define SCALER_SENSOR_POST_REG		RCT_REG(SCALER_SENSOR_POST_OFFSET)
-#define CLK_SI_INPUT_MODE_REG		RCT_REG(CLK_SI_INPUT_MODE_OFFSET)
-
-/* ==========================================================================*/
-
-#define HDMI_CLOCK_CTRL_OFFSET          0x008
-#define PLL_HDMI_CTRL_OFFSET		0x164
-#define PLL_HDMI_CTRL2_OFFSET		0x150
-#define PLL_HDMI_CTRL3_OFFSET		0x154
-#define PLL_HDMI_FRAC_OFFSET		0x168
-#define SCALER_HDMI_PRE_OFFSET		0x170
-#define SCALER_HDMI_POST_OFFSET		0x16C
-
-#define HDMI_CLOCK_CTRL_REG		RCT_REG(HDMI_CLOCK_CTRL_OFFSET)
-#define PLL_HDMI_CTRL_REG		RCT_REG(PLL_HDMI_CTRL_OFFSET)
-#define PLL_HDMI_CTRL2_REG		RCT_REG(PLL_HDMI_CTRL2_OFFSET)
-#define PLL_HDMI_CTRL3_REG		RCT_REG(PLL_HDMI_CTRL3_OFFSET)
-#define PLL_HDMI_FRAC_REG		RCT_REG(PLL_HDMI_FRAC_OFFSET)
-#define SCALER_HDMI_PRE_REG		RCT_REG(SCALER_HDMI_PRE_OFFSET)
-#define SCALER_HDMI_POST_REG		RCT_REG(SCALER_HDMI_POST_OFFSET)
-
-#define USE_CLK_SI_4_CLK_VO_OFFSET  	0xB8
-#define CLK_REF_VIDEO_EXTERNAL_OFFSET	0xAC
-
-#define USE_CLK_SI_4_CLK_VO_REG		RCT_REG(USE_CLK_SI_4_CLK_VO_OFFSET)
-#define CLK_REF_VIDEO_EXTERNAL_REG	RCT_REG(CLK_REF_VIDEO_EXTERNAL_OFFSET)
-
-/* ==========================================================================*/
-#define PLL_VIDEO_CTRL_OFFSET		0x14
-#define PLL_VIDEO_FRAC_OFFSET		0x18
-#define SCALER_VIDEO_PRE_OFFSET		0x1C
-#define SCALER_VIDEO_POST_OFFSET	0xA0
-#define PLL_VIDEO_CTRL2_OFFSET		0x130
-#define PLL_VIDEO_CTRL3_OFFSET		0x134
-#define PLL_VIDEO_CTRL_REG		RCT_REG(PLL_VIDEO_CTRL_OFFSET)
-#define PLL_VIDEO_FRAC_REG		RCT_REG(PLL_VIDEO_FRAC_OFFSET)
-#define SCALER_VIDEO_PRE_REG		RCT_REG(SCALER_VIDEO_PRE_OFFSET)
-#define SCALER_VIDEO_POST_REG		RCT_REG(SCALER_VIDEO_POST_OFFSET)
-#define PLL_VIDEO_CTRL2_REG		RCT_REG(PLL_VIDEO_CTRL2_OFFSET)
-#define PLL_VIDEO_CTRL3_REG		RCT_REG(PLL_VIDEO_CTRL3_OFFSET)
-
-#define PLL_VIDEO2_CTRL_OFFSET		0xC0
-#define PLL_VIDEO2_FRAC_OFFSET		0xC4
-#define SCALER_VIDEO2_PRE_OFFSET	0xC8
-#define SCALER_VIDEO2_POST_OFFSET	0xCC
-#define PLL_VIDEO2_CTRL2_OFFSET		0x13C
-#define PLL_VIDEO2_CTRL3_OFFSET		0x140
-#define USE_CLK_SI_4_VO2_OFFSET		0xD0
-#define USE_EXTERNAL_VD2_CLK_OFFSET	0xD4
-#define CLK_REF_VIDEO2_EXTERNAL_OFFSET	0xD8
-
-#define PLL_VIDEO2_CTRL_REG		RCT_REG(PLL_VIDEO2_CTRL_OFFSET)
-#define PLL_VIDEO2_FRAC_REG		RCT_REG(PLL_VIDEO2_FRAC_OFFSET)
-#define SCALER_VIDEO2_PRE_REG		RCT_REG(SCALER_VIDEO2_PRE_OFFSET)
-#define SCALER_VIDEO2_POST_REG		RCT_REG(SCALER_VIDEO2_POST_OFFSET)
-#define PLL_VIDEO2_CTRL2_REG		RCT_REG(PLL_VIDEO2_CTRL2_OFFSET)
-#define PLL_VIDEO2_CTRL3_REG		RCT_REG(PLL_VIDEO2_CTRL3_OFFSET)
-#define USE_CLK_SI_4_VO2_REG		RCT_REG(USE_CLK_SI_4_VO2_OFFSET)
-#define USE_EXTERNAL_VD2_CLK_REG	RCT_REG(USE_EXTERNAL_VD2_CLK_OFFSET)
-#define CLK_REF_VIDEO2_EXTERNAL_REG	RCT_REG(CLK_REF_VIDEO2_EXTERNAL_OFFSET)
-
-/* ==========================================================================*/
-#define SCALER_ARM_ASYNC_OFFSET		0x1F0
-
-#define SCALER_ARM_ASYNC_REG		RCT_REG(SCALER_ARM_ASYNC_OFFSET)
-
-/* ==========================================================================*/
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define PLL_CORTEX_CTRL_OFFSET		0x264
-#define PLL_CORTEX_FRAC_OFFSET		0x268
-#define PLL_CORTEX_CTRL2_OFFSET		0x26C
-#define PLL_CORTEX_CTRL3_OFFSET		0x270
-#else
-#define PLL_CORTEX_CTRL_OFFSET		0x2B0
-#define PLL_CORTEX_FRAC_OFFSET		0x2B4
-#define PLL_CORTEX_CTRL2_OFFSET		0x2B8
-#define PLL_CORTEX_CTRL3_OFFSET		0x2BC
-#endif
-
-#define PLL_CORTEX_CTRL_REG		RCT_REG(PLL_CORTEX_CTRL_OFFSET)
-#define PLL_CORTEX_FRAC_REG		RCT_REG(PLL_CORTEX_FRAC_OFFSET)
-#define PLL_CORTEX_CTRL2_REG		RCT_REG(PLL_CORTEX_CTRL2_OFFSET)
-#define PLL_CORTEX_CTRL3_REG		RCT_REG(PLL_CORTEX_CTRL3_OFFSET)
-
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define SCALER_GTX_POST_OFFSET		0x2C8
-#define ENET_GTXCLK_SRC_OFFSET		0x2CC
-#endif
-#define SCALER_GTX_POST_REG		RCT_REG(SCALER_GTX_POST_OFFSET)
-#define ENET_GTXCLK_SRC_REG		RCT_REG(ENET_GTXCLK_SRC_OFFSET)
-
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define PLL_ENET_CTRL_OFFSET		0x520
-#define PLL_ENET_FRAC_OFFSET		0x524
-#define PLL_ENET_CTRL2_OFFSET		0x528
-#define PLL_ENET_CTRL3_OFFSET		0x52C
-#define SCALER_ENET_POST_OFFSET		0x534
-#endif
-#define PLL_ENET_CTRL_REG		RCT_REG(PLL_ENET_CTRL_OFFSET)
-#define PLL_ENET_FRAC_REG		RCT_REG(PLL_ENET_FRAC_OFFSET)
-#define PLL_ENET_CTRL2_REG		RCT_REG(PLL_ENET_CTRL2_OFFSET)
-#define PLL_ENET_CTRL3_REG		RCT_REG(PLL_ENET_CTRL3_OFFSET)
-#define SCALER_ENET_POST_REG		RCT_REG(SCALER_ENET_POST_OFFSET)
-
-/* ==========================================================================*/
-#define SCALER_SD48_OFFSET		0x0C
-#define SCALER_SD48_REG			RCT_REG(SCALER_SD48_OFFSET)
-
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define SCALER_SDIO_OFFSET		0x10
-#else
-#define SCALER_SDIO_OFFSET		0x430
-#endif
-#define SCALER_SDIO_REG			RCT_REG(SCALER_SDIO_OFFSET)
-
-#define SCALER_SDXC_OFFSET		0x434
-#define SCALER_SDXC_REG			RCT_REG(SCALER_SDXC_OFFSET)
-
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define PLL_SD_CTRL_OFFSET		0x4AC
-#define PLL_SD_FRAC_OFFSET		0x4B0
-#define PLL_SD_CTRL2_OFFSET		0x4B4
-#define PLL_SD_CTRL3_OFFSET		0x4B8
-#elif (CHIP_REV == S2E)
-#define SDVCO_FOR_GTX_SOURCE            0x00000010
-#define FUNC_MISC_CTRL_OFFSET           0x328
-#define PLL_SD_CTRL_OFFSET		0x354
-#define PLL_SD_FRAC_OFFSET		0x360
-#define PLL_SD_CTRL2_OFFSET		0x358
-#define PLL_SD_CTRL3_OFFSET		0x35C
-#define FUNC_MISC_CTRL_REG		RCT_REG(FUNC_MISC_CTRL_OFFSET)
-#endif
-#define PLL_SD_CTRL_REG			RCT_REG(PLL_SD_CTRL_OFFSET)
-#define PLL_SD_FRAC_REG			RCT_REG(PLL_SD_FRAC_OFFSET)
-#define PLL_SD_CTRL2_REG		RCT_REG(PLL_SD_CTRL2_OFFSET)
-#define PLL_SD_CTRL3_REG		RCT_REG(PLL_SD_CTRL3_OFFSET)
-
-#if (CHIP_REV == A5S) || (CHIP_REV == S2)
-#define SD_SOFT_PHY_SUPPORT		0
-#else
-#define SD_SOFT_PHY_SUPPORT		1
-#endif
-
-#if (SD_SOFT_PHY_SUPPORT == 1)
-#define SD_PHY_CLKOUT_BYPASS		1 << 26
-#define SD_PHY_RESET			1 << 25
-#define SD_PHY_RX_CLK_POL		1 << 19
-#define SD_PHY_DATA_CMD_BYPASS		1 << 18
-#define SD_PHY_DLL_BYPASS		1 << 17
-
-#if (CHIP_REV == S2E)
-#define SD_PHY_CTRL_0_OFFSET		0x340
-#define SD_PHY_CTRL_1_OFFSET		0x344
-#define SD_PHY_OBSV_OFFSET		0x348
-#else
-#define SD_PHY_CTRL_0_OFFSET		0x4C0
-#define SD_PHY_CTRL_1_OFFSET		0x4C4
-#define SD_PHY_OBSV_OFFSET		0x4F0
-#endif
-#define SD_PHY_CTRL_0_REG		RCT_REG(SD_PHY_CTRL_0_OFFSET)
-#define SD_PHY_CTRL_1_REG		RCT_REG(SD_PHY_CTRL_1_OFFSET)
-#define SD_PHY_OBSV_REG			RCT_REG(SD_PHY_OBSV_OFFSET)
-
-#if (CHIP_REV == S3L)
-#define SDXC_PHY_CTRL_0_OFFSET		0x4C8
-#define SDXC_PHY_CTRL_1_OFFSET		0x4CC
-#define SDXC_PHY_OBSV_OFFSET		0x4F0
-#define SDXC_PHY_CTRL_0_REG		RCT_REG(SDXC_PHY_CTRL_0_OFFSET)
-#define SDXC_PHY_CTRL_1_REG		RCT_REG(SDXC_PHY_CTRL_1_OFFSET)
-#define SDXC_PHY_OBSV_REG		RCT_REG(SDXC_PHY_OBSV_OFFSET)
-#endif
-
-#else
-#define MS_DELAY_CTRL_OFFSET		0x1D0
-#define MS_DELAY_CTRL_REG		RCT_REG(MS_DELAY_CTRL_OFFSET)
-#endif
-
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S) || (CHIP_REV == A7L) || (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define ADC_SOFT_RESET			0x0
-#else
-#define ADC_SOFT_RESET			0x10000
-#endif
-#define SCALER_ADC_OFFSET		0x09C
-#define SCALER_ADC_REG			RCT_REG(SCALER_ADC_OFFSET)
-
-#define ADC16_CTRL_OFFSET		0x198
-#define ADC16_CTRL_REG			RCT_REG(ADC16_CTRL_OFFSET)
-
-/* ==========================================================================*/
-#define AHB_MISC_EN_OFFSET		0x21C
-#define AHB_MISC_EN_REG			RCT_REG(AHB_MISC_EN_OFFSET)
-
-/* ==========================================================================*/
-#define IOCTRL_GPIO_OFFSET		0x1F8
-#define IOCTRL_GPIO_REG			RCT_REG(IOCTRL_GPIO_OFFSET)
-
-#define IOCTRL_MISC1_OFFSET		0x1FC
-#define IOCTRL_MISC1_REG		RCT_REG(IOCTRL_MISC1_OFFSET)
-
-#define IOCTRL_MISC2_OFFSET		0x200
-#define IOCTRL_MISC2_REG		RCT_REG(IOCTRL_MISC2_OFFSET)
-
-#define IOCTRL_SMIOA_OFFSET		0x204
-#define IOCTRL_SMIOA_REG		RCT_REG(IOCTRL_SMIOA_OFFSET)
-
-#define IOCTRL_SMIOB_OFFSET		0x208
-#define IOCTRL_SMIOB_REG		RCT_REG(IOCTRL_SMIOB_OFFSET)
-
-#define IOCTRL_SMIOC_OFFSET		0x20C
-#define IOCTRL_SMIOC_REG		RCT_REG(IOCTRL_SMIOC_OFFSET)
-
-#define IOCTRL_SMIOD_OFFSET		0x210
-#define IOCTRL_SMIOD_REG		RCT_REG(IOCTRL_SMIOD_OFFSET)
-
-#define IOCTRL_VD1_OFFSET		0x214
-#define IOCTRL_VD1_REG			RCT_REG(IOCTRL_VD1_OFFSET)
-
-#define IOCTRL_SENSOR_OFFSET		0x218
-#define IOCTRL_SENSOR_REG		RCT_REG(IOCTRL_SENSOR_OFFSET)
-
-#define IOCTRL_STRIG_OFFSET		0x250
-#define IOCTRL_STRIG_REG		RCT_REG(IOCTRL_STRIG_OFFSET)
-
-#define IOCTRL_SDXC_OFFSET		0x2F4
-#define IOCTRL_SDXC_REG			RCT_REG(IOCTRL_SDXC_OFFSET)
-
-#define SDXC_PULL_CTRL_OFFSET		0x2F8
-#define SDXC_PULL_CTRL_REG		RCT_REG(SDXC_PULL_CTRL_OFFSET)
-
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define IOCTRL_DRIVE_STRENGTH_3MA	0x0
-#define IOCTRL_DRIVE_STRENGTH_12MA	0x1
-#define IOCTRL_DRIVE_STRENGTH_6MA	0x2
-#define IOCTRL_DRIVE_STRENGTH_18MA	0x3
-#else
-#define IOCTRL_DRIVE_STRENGTH_2MA	0x0
-#define IOCTRL_DRIVE_STRENGTH_8MA	0x1
-#define IOCTRL_DRIVE_STRENGTH_4MA	0x2
-#define IOCTRL_DRIVE_STRENGTH_12MA	0x3
-#endif
-
-#if (CHIP_REV == A5S)
-#define GPIO_PAD_DS_SUPPORT		0
-#else
-#define GPIO_PAD_DS_SUPPORT		1
-#endif
-
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define GPIO_DS0_0_OFFSET		0x270
-#define GPIO_DS0_1_OFFSET		0x274
-#define GPIO_DS0_2_OFFSET		0x278
-#define GPIO_DS0_3_OFFSET		0x27C
-#define GPIO_DS0_4_OFFSET		0x280
-#define GPIO_DS1_0_OFFSET		0x284
-#define GPIO_DS1_1_OFFSET		0x288
-#define GPIO_DS1_2_OFFSET		0x28C
-#define GPIO_DS1_3_OFFSET		0x290
-#define GPIO_DS1_4_OFFSET		0x294
-#define GPIO_DS0_OFFSET(bank)		(0x270 + ((bank) * 4))
-#define GPIO_DS1_OFFSET(bank)		(0x284 + ((bank) * 4))
-
-#else
-#define GPIO_DS0_0_OFFSET		0x314
-#define GPIO_DS1_0_OFFSET		0x318
-#define GPIO_DS0_1_OFFSET		0x31C
-#define GPIO_DS1_1_OFFSET		0x320
-#define GPIO_DS0_2_OFFSET		0x324
-#define GPIO_DS1_2_OFFSET		0x328
-#define GPIO_DS0_3_OFFSET		0x32C
-#define GPIO_DS1_3_OFFSET		0x330
-#define GPIO_DS0_4_OFFSET		0x438
-#define GPIO_DS1_4_OFFSET		0x43C
-#define GPIO_DS0_5_OFFSET		0x440
-#define GPIO_DS1_5_OFFSET		0x444
-#define GPIO_DS0_6_OFFSET		0x448
-#define GPIO_DS1_6_OFFSET		0x44C
-#define GPIO_DS0_OFFSET(bank)		((bank) >= 4 ? \
-					(0x438 + (((bank) - 4) * 8)) : \
-					(0x314 + ((bank) * 8)))
-#define GPIO_DS1_OFFSET(bank)		((bank) >= 4 ? \
-					(0x438 + (((bank) - 4) * 8) + 4) : \
-					(0x314 + ((bank) * 8) + 4))
-#endif
-
-#define GPIO_DS0_0_REG			RCT_REG(GPIO_DS0_0_OFFSET)
-#define GPIO_DS1_0_REG			RCT_REG(GPIO_DS1_0_OFFSET)
-#define GPIO_DS0_1_REG			RCT_REG(GPIO_DS0_1_OFFSET)
-#define GPIO_DS1_1_REG			RCT_REG(GPIO_DS1_1_OFFSET)
-#define GPIO_DS0_2_REG			RCT_REG(GPIO_DS0_2_OFFSET)
-#define GPIO_DS1_2_REG			RCT_REG(GPIO_DS1_2_OFFSET)
-#define GPIO_DS0_3_REG			RCT_REG(GPIO_DS0_3_OFFSET)
-#define GPIO_DS1_3_REG			RCT_REG(GPIO_DS1_3_OFFSET)
-#define GPIO_DS0_4_REG			RCT_REG(GPIO_DS0_4_OFFSET)
-#define GPIO_DS1_4_REG			RCT_REG(GPIO_DS1_4_OFFSET)
-#define GPIO_DS0_5_REG			RCT_REG(GPIO_DS0_5_OFFSET)
-#define GPIO_DS1_5_REG			RCT_REG(GPIO_DS1_5_OFFSET)
-#define GPIO_DS0_6_REG			RCT_REG(GPIO_DS0_6_OFFSET)
-#define GPIO_DS1_6_REG			RCT_REG(GPIO_DS1_6_OFFSET)
-
-/* ==========================================================================*/
-#define RCT_TIMER_OFFSET		0x254
-#define RCT_TIMER_CTRL_OFFSET		0x258
-
-#define RCT_TIMER_REG			RCT_REG(RCT_TIMER_OFFSET)
-#define RCT_TIMER_CTRL_REG		RCT_REG(RCT_TIMER_CTRL_OFFSET)
-
-/* ==========================================================================*/
-
-/* Secure and Scratchpad */
-#define AHB_SCRATCHPAD_OFFSET		0x1B000
-#define AHB_SECURE_OFFSET		0x1D000
-#define AHB_SCRATCHPAD_BASE		(AHB_BASE + AHB_SCRATCHPAD_OFFSET)
-#define AHB_SECURE_BASE			(AHB_BASE + AHB_SECURE_OFFSET)
-#define AHB_SCRATCHPAD_REG(x)		(AHB_SCRATCHPAD_BASE + (x))
-#define AHB_SECURE_REG(x)		(AHB_SECURE_BASE + (x))
-
-#if (CHIP_REV == S3L)
-#define AHBSP_PRI_IRQ_C0_OFFSET		0x38
-#define AHBSP_PRI_IRQ_C1_OFFSET		-1 /* not supported */
-#else
-#define AHBSP_PRI_IRQ_C0_OFFSET		0x3C
-#define AHBSP_PRI_IRQ_C1_OFFSET		0x40
-#endif
-#define AHBSP_PRI_IRQ_C0_REG		AHB_SCRATCHPAD_REG(AHBSP_PRI_IRQ_C0_OFFSET)
-#define AHBSP_PRI_IRQ_C1_REG		AHB_SCRATCHPAD_REG(AHBSP_PRI_IRQ_C1_OFFSET)
-
-/* ==========================================================================*/
-
-#if (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define DMA_SUPPORT_SELECT_CHANNEL	1
-#else
-#define DMA_SUPPORT_SELECT_CHANNEL	0
-#endif
-
-#if (CHIP_REV == S3)
-#define AHBSP_DMA_CHANNEL_SEL_OFFSET	0x30
-#elif (CHIP_REV == S3L)
-#define AHBSP_DMA_CHANNEL_SEL_OFFSET	0x2C
-#endif
-#define AHBSP_DMA_CHANNEL_SEL_REG	AHB_SCRATCHPAD_REG(AHBSP_DMA_CHANNEL_SEL_OFFSET)
-
-#define SSI0_TX_DMA_REQ_IDX		0
-#define SSI0_RX_DMA_REQ_IDX		1
-#define SSI1_TX_DMA_REQ_IDX		2
-#define SSI1_RX_DMA_REQ_IDX		3
-#define NOR_SPI_TX_DMA_REQ_IDX		4
-#define NOR_SPI_RX_DMA_REQ_IDX		5
-#define SSIS0_TX_DMA_REQ_IDX		6
-#define SSIS0_RX_DMA_REQ_IDX		7
-#define UART_TX_DMA_REQ_IDX		8
-#define UART_RX_DMA_REQ_IDX		9
-#define I2S_TX_DMA_REQ_IDX		10
-#define I2S_RX_DMA_REQ_IDX		11
-#define SLIM_TX_DMA_REQ_IDX		12
-#define SLIM_RX_DMA_REQ_IDX		13
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S) || (CHIP_REV == A7L)
-#define	POC_BOOT_MAP_TYPE		0
-#define POC_BOOT_FROM_MASK		0x00010500
-#define POC_BOOT_FROM_USB		0x00000000
-#define POC_BOOT_FROM_BYPASS		0x00000100
-#define POC_BOOT_FROM_NAND		0x00000400
-#define POC_BOOT_FROM_EMMC		0xFFFFFFFF /* not supported */
-#define POC_BOOT_FROM_SPINOR		0xFFFFFFFF /* not supported */
-#define POC_BOOT_FROM_HIF		0xFFFFFFFF /* not supported */
-#elif (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define	POC_BOOT_MAP_TYPE		0
-#define POC_BOOT_FROM_MASK		0x00003140
-#define POC_BOOT_FROM_BYPASS		0x00000040
-#define POC_BOOT_FROM_USB		0x00000000
-#define POC_BOOT_FROM_NAND		0x00000100
-#define POC_BOOT_FROM_SPINOR		0x00001000 /* not supported on S2 */
-#define POC_BOOT_FROM_EMMC		0x00002000
-#define POC_BOOT_FROM_HIF		0xFFFFFFFF /* not supported */
-#elif (CHIP_REV == S3)
-#define	POC_BOOT_MAP_TYPE		1
-#define POC_BOOT_FROM_MASK		0x00000570
-#define POC_BOOT_FROM_BYPASS		0x00000100
-#define POC_BOOT_FROM_USB		0x00000400
-#define POC_BOOT_FROM_SPINOR		0x00000000
-#define POC_BOOT_FROM_NAND		0x00000010
-#define POC_BOOT_FROM_EMMC		0x00000020
-#define POC_BOOT_FROM_HIF		0x00000040
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3L)
-#define	POC_BOOT_MAP_TYPE		1
-#define POC_BOOT_FROM_MASK		0x00000530
-#define POC_BOOT_FROM_BYPASS		0x00000100
-#define POC_BOOT_FROM_USB		0x00000400
-#define POC_BOOT_FROM_SPINOR		0x00000000
-#define POC_BOOT_FROM_NAND		0x00000010
-#define POC_BOOT_FROM_EMMC		0x00000020
-#define POC_BOOT_FROM_HIF		0xFFFFFFFF /* not supported */
-#endif
-
-#define RCT_BOOT_FROM_BYPASS		0x80000000
-#define RCT_BOOT_FROM_NAND		0x00000001
-#define RCT_BOOT_FROM_USB		0x00000002
-#define RCT_BOOT_FROM_EMMC		0x00000004
-#define RCT_BOOT_FROM_SPINOR		0x00000008
-#define RCT_BOOT_FROM_HIF		0x00000010
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S)
-#define SYS_CONFIG_NAND_PAGE_SIZE	0x00000020
-#define SYS_CONFIG_NAND_READ_CONFIRM	0x00000040
-#define SYS_CONFIG_NAND_ECC_BCH_EN	0x00000000
-#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00000000
-#elif (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define SYS_CONFIG_NAND_PAGE_SIZE	0x00000010
-#define SYS_CONFIG_NAND_READ_CONFIRM	0x00000020
-#define SYS_CONFIG_NAND_ECC_BCH_EN	0x00000400
-#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00000800
-#else
+/*
+ * ambhw/rct.h
+ *
+ * History:
+ *	2006/12/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBHW_RCT_H__
+#define __AMBHW_RCT_H__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+#if (CHIP_REV == CV1)
+#define RCT_OFFSET			0x00080000
+#else
+#define RCT_OFFSET			0x00170000
+#endif
+#define RCT_BASE			(DBGBUS_BASE + RCT_OFFSET)
+#define RCT_REG(x)			(RCT_BASE + (x))
+
+#define RCT_INVALID_OFFSET		0x14
+
+/* ==========================================================================*/
+#define PLL_LOCK_OFFSET			0x2C
+#define SOFT_OR_DLL_RESET_OFFSET	0x68
+
+#define PLL_LOCK_REG			RCT_REG(PLL_LOCK_OFFSET)
+#define SOFT_OR_DLL_RESET_REG		RCT_REG(SOFT_OR_DLL_RESET_OFFSET)
+
+/* ==========================================================================*/
+#define FIO_RESET_OFFSET		0x74
+#define FIO_RESET_REG			RCT_REG(FIO_RESET_OFFSET)
+#define FIO_RESET_FIO_RST		0x00000008
+#define FIO_RESET_CF_RST		0x00000004
+#define FIO_RESET_XD_RST		0x00000002
+#define FIO_RESET_FLASH_RST		0x00000001
+
+/* ==========================================================================*/
+
+#define USBC_CTRL_OFFSET		0x2cc
+#define UDC_SOFT_RESET_OFFSET		USBC_CTRL_OFFSET
+#define UDC_SOFT_RESET_MASK		0x2
+#define UDC_SOFT_RESET_REG		RCT_REG(UDC_SOFT_RESET_OFFSET)
+
+#define USBP0_SEL_OFFSET		0x2c0
+#define USBP0_SEL_REG			RCT_REG(USBP0_SEL_OFFSET)
+#define USB0_IS_HOST_MASK		0x00000002
+#define USBP0_FORCE_TO_DEVICE		1
+
+/* ==========================================================================*/
+#define PLL_AUDIO_CTRL_OFFSET		0x54
+#define PLL_AUDIO_FRAC_OFFSET		0x58
+#define SCALER_AUDIO_POST_OFFSET	0x5C
+#define SCALER_AUDIO_PRE_OFFSET		0x60
+#define PLL_AUDIO_CTRL2_OFFSET		0x124
+#define PLL_AUDIO_CTRL3_OFFSET		0x12c
+
+#define PLL_AUDIO_CTRL_REG		RCT_REG(PLL_AUDIO_CTRL_OFFSET)
+#define PLL_AUDIO_FRAC_REG		RCT_REG(PLL_AUDIO_FRAC_OFFSET)
+#define SCALER_AUDIO_POST_REG		RCT_REG(SCALER_AUDIO_POST_OFFSET)
+#define SCALER_AUDIO_PRE_REG		RCT_REG(SCALER_AUDIO_PRE_OFFSET)
+#define PLL_AUDIO_CTRL2_REG		RCT_REG(PLL_AUDIO_CTRL2_OFFSET)
+#define PLL_AUDIO_CTRL3_REG		RCT_REG(PLL_AUDIO_CTRL3_OFFSET)
+
+/* ==========================================================================*/
+#define ANA_PWR_OFFSET			0x50
+#define ANA_PWR_REG			RCT_REG(ANA_PWR_OFFSET)
+#define ANA_PWR_POWER_DOWN		0x0020
+
+#define SYS_CONFIG_OFFSET		0x34
+#define SYS_CONFIG_REG			RCT_REG(SYS_CONFIG_OFFSET)
+
+/* ==========================================================================*/
+
+#define UNLOCK_WDT_RST_L_VAL		0x01
+
+#define WDT_RST_L_OFFSET		0x78
+#define UNLOCK_WDT_RST_L_OFFSET		0x260
+#define WDT_RST_L_REG			RCT_REG(WDT_RST_L_OFFSET)
+#define UNLOCK_WDT_RST_L_REG		RCT_REG(UNLOCK_WDT_RST_L_OFFSET)
+
+/* ==========================================================================*/
+#define CG_UART_OFFSET			0x38
+#define CG_SSI_OFFSET			0x3C
+#define CG_MOTOR_OFFSET			0x40
+#define CG_IR_OFFSET			0x44
+#define CG_HOST_OFFSET			0x48
+#define CG_PWM_OFFSET			0x84
+#define CG_SSI2_OFFSET			0xEC
+#define CLK_REF_SSI_OFFSET		0x19c
+#define CG_SSI3_OFFSET			0x518
+#define CLK_REF_SSI3_OFFSET		0x51c
+#if (CHIP_REV == S5L)
+#define CG_UART1_OFFSET			0x75c
+#else
+#define CG_UART1_OFFSET			CG_UART_OFFSET
+#endif
+#define CG_UART2_OFFSET			0x764
+#define CG_UART3_OFFSET			0x71c
+#define CG_UART4_OFFSET			0x720
+#define CG_UART5_OFFSET			0x724
+#define CG_UART6_OFFSET			0x728
+
+#define CG_UART_REG			RCT_REG(CG_UART_OFFSET)
+#define CG_SSI_REG			RCT_REG(CG_SSI_OFFSET)
+#define CG_MOTOR_REG			RCT_REG(CG_MOTOR_OFFSET)
+#define CG_IR_REG			RCT_REG(CG_IR_OFFSET)
+#define CG_HOST_REG			RCT_REG(CG_HOST_OFFSET)
+#define CG_PWM_REG			RCT_REG(CG_PWM_OFFSET)
+#define CG_SSI2_REG			RCT_REG(CG_SSI2_OFFSET)
+#define CG_SSI3_REG			RCT_REG(CG_SSI3_OFFSET)
+#define CLK_REF_SSI_REG			RCT_REG(CLK_REF_SSI_OFFSET)
+#define CLK_REF_SSI3_REG		RCT_REG(CLK_REF_SSI3_OFFSET)
+#define CG_UART1_REG			RCT_REG(CG_UART1_OFFSET)
+#define CG_UART2_REG			RCT_REG(CG_UART2_OFFSET)
+#define CG_UART3_REG			RCT_REG(CG_UART3_OFFSET)
+#define CG_UART4_REG			RCT_REG(CG_UART4_OFFSET)
+#define CG_UART5_REG			RCT_REG(CG_UART5_OFFSET)
+#define CG_UART6_REG			RCT_REG(CG_UART6_OFFSET)
+
+#define UART_CLK_SRC_CLK_REF		0x00
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L) || (CHIP_REV == S5)
+#define UART_CLK_SRC_CORE		0x01
+#define UART_CLK_SRC_IDSP		0x03
+#elif (CHIP_REV == S5L)
+#define UART_CLK_SRC_CORTEX		0x01
+#define UART_CLK_SRC_ENET		0x03
+#else
+#define UART_CLK_SRC_CORE		0x01
+#define UART_CLK_SRC_ENET		0x02
+#define UART_CLK_SRC_SD			0x03
+#endif
+
+#define UART_CLK_SRC_SEL_OFFSET		0x1C8
+#define UART1_CLK_SRC_SEL_OFFSET	0x72c
+#define UART2_CLK_SRC_SEL_OFFSET	0x730
+#define UART3_CLK_SRC_SEL_OFFSET	0x734
+#define UART4_CLK_SRC_SEL_OFFSET	0x738
+#define UART5_CLK_SRC_SEL_OFFSET	0x73c
+#define UART6_CLK_SRC_SEL_OFFSET	0x740
+#define UART_CLK_SRC_SEL_REG		RCT_REG(UART_CLK_SRC_SEL_OFFSET)
+#define UART1_CLK_SRC_SEL_REG		RCT_REG(UART1_CLK_SRC_SEL_OFFSET)
+#define UART2_CLK_SRC_SEL_REG		RCT_REG(UART2_CLK_SRC_SEL_OFFSET)
+#define UART3_CLK_SRC_SEL_REG		RCT_REG(UART3_CLK_SRC_SEL_OFFSET)
+#define UART4_CLK_SRC_SEL_REG		RCT_REG(UART4_CLK_SRC_SEL_OFFSET)
+#define UART5_CLK_SRC_SEL_REG		RCT_REG(UART5_CLK_SRC_SEL_OFFSET)
+#define UART6_CLK_SRC_SEL_REG		RCT_REG(UART6_CLK_SRC_SEL_OFFSET)
+
+/* ==========================================================================*/
+#define PLL_CORE_CTRL_OFFSET		0x00
+#define PLL_CORE_FRAC_OFFSET		0x04
+#define PLL_CORE_CTRL2_OFFSET		0x100
+#define PLL_CORE_CTRL3_OFFSET		0x104
+#define PLL_CORE_CTRL_REG		RCT_REG(PLL_CORE_CTRL_OFFSET)
+#define PLL_CORE_FRAC_REG		RCT_REG(PLL_CORE_FRAC_OFFSET)
+#define PLL_CORE_CTRL2_REG		RCT_REG(PLL_CORE_CTRL2_OFFSET)
+#define PLL_CORE_CTRL3_REG		RCT_REG(PLL_CORE_CTRL3_OFFSET)
+
+/* ==========================================================================*/
+
+#define PLL_HDMILC_CTRL_OFFSET		0x404
+#define PLL_HDMILC_FRAC_OFFSET		0x408
+#define PLL_HDMILC_CTRL2_OFFSET		0x40c
+#define PLL_HDMILC_CTRL3_OFFSET		0x410
+#define PLL_HDMILC_CTRL4_OFFSET		0x418
+#define PLL_HDMILC_CTRL_REG		RCT_REG(PLL_HDMILC_CTRL_OFFSET)
+#define PLL_HDMILC_FRAC_REG		RCT_REG(PLL_HDMILC_FRAC_OFFSET)
+#define PLL_HDMILC_CTRL2_REG		RCT_REG(PLL_HDMILC_CTRL2_OFFSET)
+#define PLL_HDMILC_CTRL3_REG		RCT_REG(PLL_HDMILC_CTRL3_OFFSET)
+#define PLL_HDMILC_CTRL4_REG		RCT_REG(PLL_HDMILC_CTRL4_OFFSET)
+
+/* ==========================================================================*/
+#define CKEN_CLUSTER_REG_OFFSET		0x8C
+#define PLL_IDSP_CTRL_OFFSET		0xE4
+#define PLL_IDSP_FRAC_OFFSET		0xE8
+#define PLL_IDSP_CTRL2_OFFSET		0x108
+#define PLL_IDSP_CTRL3_OFFSET		0x10C
+#define SCALER_IDSP_POST_OFFSET		0x1F4
+
+#define CKEN_CLUSTER_REG		RCT_REG(CKEN_CLUSTER_REG_OFFSET)
+#define PLL_IDSP_CTRL_REG		RCT_REG(PLL_IDSP_CTRL_OFFSET)
+#define PLL_IDSP_FRAC_REG		RCT_REG(PLL_IDSP_FRAC_OFFSET)
+#define PLL_IDSP_CTRL2_REG		RCT_REG(PLL_IDSP_CTRL2_OFFSET)
+#define PLL_IDSP_CTRL3_REG		RCT_REG(PLL_IDSP_CTRL3_OFFSET)
+#define SCALER_IDSP_POST_REG		RCT_REG(SCALER_IDSP_POST_OFFSET)
+
+/* ==========================================================================*/
+#define PLL_DDR_CTRL_OFFSET		0xDC
+#define PLL_DDR_FRAC_OFFSET		0xE0
+#define PLL_DDR_CTRL2_OFFSET		0x110
+#define PLL_DDR_CTRL3_OFFSET		0x114
+
+#define PLL_DDR_CTRL_REG		RCT_REG(PLL_DDR_CTRL_OFFSET)
+#define PLL_DDR_FRAC_REG		RCT_REG(PLL_DDR_FRAC_OFFSET)
+#define PLL_DDR_CTRL2_REG		RCT_REG(PLL_DDR_CTRL2_OFFSET)
+#define PLL_DDR_CTRL3_REG		RCT_REG(PLL_DDR_CTRL3_OFFSET)
+
+/* ==========================================================================*/
+#define PLL_SENSOR_CTRL_OFFSET		0x24
+#define PLL_SENSOR_FRAC_OFFSET		0x28
+#define PLL_SENSOR_CTRL2_OFFSET		0x11C
+#define PLL_SENSOR_CTRL3_OFFSET		0x120
+#define SCALER_SENSOR_PRE_OFFSET	0x4C
+#define SCALER_SENSOR_POST_OFFSET	0x30
+#define CLK_SI_INPUT_MODE_OFFSET	0xBC
+#define SCALER_SENSOR_VIN_OFFSET	0x230
+
+#define PLL_SENSOR_CTRL_REG		RCT_REG(PLL_SENSOR_CTRL_OFFSET)
+#define PLL_SENSOR_FRAC_REG		RCT_REG(PLL_SENSOR_FRAC_OFFSET)
+#define PLL_SENSOR_CTRL2_REG		RCT_REG(PLL_SENSOR_CTRL2_OFFSET)
+#define PLL_SENSOR_CTRL3_REG		RCT_REG(PLL_SENSOR_CTRL3_OFFSET)
+#define SCALER_SENSOR_PRE_REG		RCT_REG(SCALER_SENSOR_PRE_OFFSET)
+#define SCALER_SENSOR_POST_REG		RCT_REG(SCALER_SENSOR_POST_OFFSET)
+#define CLK_SI_INPUT_MODE_REG		RCT_REG(CLK_SI_INPUT_MODE_OFFSET)
+#define SCALER_SENSOR_VIN_REG		RCT_REG(SCALER_SENSOR_VIN_OFFSET)
+
+/* ==========================================================================*/
+
+#define HDMI_CLOCK_CTRL_OFFSET          0x008
+#define PLL_HDMI_CTRL_OFFSET		0x164
+#define PLL_HDMI_CTRL2_OFFSET		0x150
+#define PLL_HDMI_CTRL3_OFFSET		0x154
+#define PLL_HDMI_FRAC_OFFSET		0x168
+#define SCALER_HDMI_PRE_OFFSET		0x170
+#define SCALER_HDMI_POST_OFFSET		0x16C
+
+#define HDMI_CLOCK_CTRL_REG		RCT_REG(HDMI_CLOCK_CTRL_OFFSET)
+#define PLL_HDMI_CTRL_REG		RCT_REG(PLL_HDMI_CTRL_OFFSET)
+#define PLL_HDMI_CTRL2_REG		RCT_REG(PLL_HDMI_CTRL2_OFFSET)
+#define PLL_HDMI_CTRL3_REG		RCT_REG(PLL_HDMI_CTRL3_OFFSET)
+#define PLL_HDMI_FRAC_REG		RCT_REG(PLL_HDMI_FRAC_OFFSET)
+#define SCALER_HDMI_PRE_REG		RCT_REG(SCALER_HDMI_PRE_OFFSET)
+#define SCALER_HDMI_POST_REG		RCT_REG(SCALER_HDMI_POST_OFFSET)
+
+#define USE_CLK_SI_4_CLK_VO_OFFSET  	0xB8
+#define CLK_REF_VIDEO_EXTERNAL_OFFSET	0xAC
+
+#define USE_CLK_SI_4_CLK_VO_REG		RCT_REG(USE_CLK_SI_4_CLK_VO_OFFSET)
+#define CLK_REF_VIDEO_EXTERNAL_REG	RCT_REG(CLK_REF_VIDEO_EXTERNAL_OFFSET)
+
+/* ==========================================================================*/
+#define PLL_VIDEO_CTRL_OFFSET		0x14
+#define PLL_VIDEO_FRAC_OFFSET		0x18
+#define SCALER_VIDEO_PRE_OFFSET		0x1C
+#define SCALER_VIDEO_POST_OFFSET	0xA0
+#define PLL_VIDEO_CTRL2_OFFSET		0x130
+#define PLL_VIDEO_CTRL3_OFFSET		0x134
+#define PLL_VIDEO_CTRL_REG		RCT_REG(PLL_VIDEO_CTRL_OFFSET)
+#define PLL_VIDEO_FRAC_REG		RCT_REG(PLL_VIDEO_FRAC_OFFSET)
+#define SCALER_VIDEO_PRE_REG		RCT_REG(SCALER_VIDEO_PRE_OFFSET)
+#define SCALER_VIDEO_POST_REG		RCT_REG(SCALER_VIDEO_POST_OFFSET)
+#define PLL_VIDEO_CTRL2_REG		RCT_REG(PLL_VIDEO_CTRL2_OFFSET)
+#define PLL_VIDEO_CTRL3_REG		RCT_REG(PLL_VIDEO_CTRL3_OFFSET)
+
+#define PLL_VIDEO2_CTRL_OFFSET		0xC0
+#define PLL_VIDEO2_FRAC_OFFSET		0xC4
+#define SCALER_VIDEO2_PRE_OFFSET	0xC8
+#define SCALER_VIDEO2_POST_OFFSET	0xCC
+#define PLL_VIDEO2_CTRL2_OFFSET		0x13C
+#define PLL_VIDEO2_CTRL3_OFFSET		0x140
+#define USE_CLK_SI_4_VO2_OFFSET		0xD0
+#define USE_EXTERNAL_VD2_CLK_OFFSET	0xD4
+#define CLK_REF_VIDEO2_EXTERNAL_OFFSET	0xD8
+
+#define PLL_VIDEO2_CTRL_REG		RCT_REG(PLL_VIDEO2_CTRL_OFFSET)
+#define PLL_VIDEO2_FRAC_REG		RCT_REG(PLL_VIDEO2_FRAC_OFFSET)
+#define SCALER_VIDEO2_PRE_REG		RCT_REG(SCALER_VIDEO2_PRE_OFFSET)
+#define SCALER_VIDEO2_POST_REG		RCT_REG(SCALER_VIDEO2_POST_OFFSET)
+#define PLL_VIDEO2_CTRL2_REG		RCT_REG(PLL_VIDEO2_CTRL2_OFFSET)
+#define PLL_VIDEO2_CTRL3_REG		RCT_REG(PLL_VIDEO2_CTRL3_OFFSET)
+#define USE_CLK_SI_4_VO2_REG		RCT_REG(USE_CLK_SI_4_VO2_OFFSET)
+#define USE_EXTERNAL_VD2_CLK_REG	RCT_REG(USE_EXTERNAL_VD2_CLK_OFFSET)
+#define CLK_REF_VIDEO2_EXTERNAL_REG	RCT_REG(CLK_REF_VIDEO2_EXTERNAL_OFFSET)
+
+/* ==========================================================================*/
+#define SCALER_ARM_ASYNC_OFFSET		0x1F0
+
+#define SCALER_ARM_ASYNC_REG		RCT_REG(SCALER_ARM_ASYNC_OFFSET)
+
+/* ==========================================================================*/
+#define PLL_CORTEX_CTRL_OFFSET		0x264
+#define PLL_CORTEX_FRAC_OFFSET		0x268
+#define PLL_CORTEX_CTRL2_OFFSET		0x26C
+#define PLL_CORTEX_CTRL3_OFFSET		0x270
+#define PLL_CORTEX_CTRL_REG		RCT_REG(PLL_CORTEX_CTRL_OFFSET)
+#define PLL_CORTEX_FRAC_REG		RCT_REG(PLL_CORTEX_FRAC_OFFSET)
+#define PLL_CORTEX_CTRL2_REG		RCT_REG(PLL_CORTEX_CTRL2_OFFSET)
+#define PLL_CORTEX_CTRL3_REG		RCT_REG(PLL_CORTEX_CTRL3_OFFSET)
+
+/* ==========================================================================*/
+
+#if (CHIP_REV == S3L) || (CHIP_REV == S5L)
+#define ENET_CLK_SRC_SEL_OFFSET		0x544
+#else
+#define ENET_CLK_SRC_SEL_OFFSET		0x6B8
+#endif
+#define ENET_CLK_SRC_SEL_REG		RCT_REG(ENET_CLK_SRC_SEL_OFFSET)
+
+#define SCALER_GTX_POST_OFFSET		0x2A8
+#define ENET_GTXCLK_SRC_OFFSET		0x2B0
+#define SCALER_GTX_POST_REG		RCT_REG(SCALER_GTX_POST_OFFSET)
+#define ENET_GTXCLK_SRC_REG		RCT_REG(ENET_GTXCLK_SRC_OFFSET)
+
+#define PLL_ENET_CTRL_OFFSET		0x520
+#define PLL_ENET_FRAC_OFFSET		0x524
+#define PLL_ENET_CTRL2_OFFSET		0x528
+#define PLL_ENET_CTRL3_OFFSET		0x52C
+#define SCALER_ENET_POST_OFFSET		0x534
+#define PLL_ENET_CTRL_REG		RCT_REG(PLL_ENET_CTRL_OFFSET)
+#define PLL_ENET_FRAC_REG		RCT_REG(PLL_ENET_FRAC_OFFSET)
+#define PLL_ENET_CTRL2_REG		RCT_REG(PLL_ENET_CTRL2_OFFSET)
+#define PLL_ENET_CTRL3_REG		RCT_REG(PLL_ENET_CTRL3_OFFSET)
+#define SCALER_ENET_POST_REG		RCT_REG(SCALER_ENET_POST_OFFSET)
+
+/* ==========================================================================*/
+#define SCALER_SD48_OFFSET		0x0C
+#define SCALER_SD48_REG			RCT_REG(SCALER_SD48_OFFSET)
+
+#define SCALER_SDIO_OFFSET		0x430
+#define SCALER_SDIO_REG			RCT_REG(SCALER_SDIO_OFFSET)
+
+#define SCALER_SDXC_OFFSET		0x434
+#define SCALER_SDXC_REG			RCT_REG(SCALER_SDXC_OFFSET)
+
+#define PLL_SD_CTRL_OFFSET		0x4AC
+#define PLL_SD_FRAC_OFFSET		0x4B0
+#define PLL_SD_CTRL2_OFFSET		0x4B4
+#define PLL_SD_CTRL3_OFFSET		0x4B8
+#define PLL_SD_CTRL_REG			RCT_REG(PLL_SD_CTRL_OFFSET)
+#define PLL_SD_FRAC_REG			RCT_REG(PLL_SD_FRAC_OFFSET)
+#define PLL_SD_CTRL2_REG		RCT_REG(PLL_SD_CTRL2_OFFSET)
+#define PLL_SD_CTRL3_REG		RCT_REG(PLL_SD_CTRL3_OFFSET)
+
+#if (CHIP_REV == S2L) || (CHIP_REV == S3)
+#define SDXC_SOFT_PHY_SUPPORT		0
+#else
+#define SDXC_SOFT_PHY_SUPPORT		1
+#endif
+
+#define SD_PHY_CLKIN_POL		1 << 27
+#define SD_PHY_CLKOUT_BYPASS		1 << 26
+#define SD_PHY_RESET			1 << 25
+#define SD_PHY_RX_CLK_POL		1 << 19
+#define SD_PHY_DATA_CMD_BYPASS		1 << 18
+#define SD_PHY_DLL_BYPASS		1 << 17
+
+#define SD_PHY_CTRL_0_OFFSET		0x4C0
+#define SD_PHY_CTRL_1_OFFSET		0x4C4
+#define SD_PHY_OBSV_OFFSET		0x4F0
+#define SD_PHY_CTRL_0_REG		RCT_REG(SD_PHY_CTRL_0_OFFSET)
+#define SD_PHY_CTRL_1_REG		RCT_REG(SD_PHY_CTRL_1_OFFSET)
+#define SD_PHY_OBSV_REG			RCT_REG(SD_PHY_OBSV_OFFSET)
+
+#if (SDXC_SOFT_PHY_SUPPORT == 1)
+#define SDXC_PHY_CTRL_0_OFFSET		0x4C8
+#define SDXC_PHY_CTRL_1_OFFSET		0x4CC
+#define SDXC_PHY_OBSV_OFFSET		0x4F0
+#define SDXC_PHY_CTRL_0_REG		RCT_REG(SDXC_PHY_CTRL_0_OFFSET)
+#define SDXC_PHY_CTRL_1_REG		RCT_REG(SDXC_PHY_CTRL_1_OFFSET)
+#define SDXC_PHY_OBSV_REG		RCT_REG(SDXC_PHY_OBSV_OFFSET)
+#endif
+
+#if (CHIP_REV == S5) || (CHIP_REV == CV1)
+#define SD_PHY_CTRL_2_OFFSET		0x664
+#define SDXC_PHY_CTRL_2_OFFSET		0x668
+#else
+#define SD_PHY_CTRL_2_OFFSET		0x6f0
+#define SDXC_PHY_CTRL_2_OFFSET		0x6f4
+#endif
+#define SD_PHY_CTRL_2_REG		RCT_REG(SD_PHY_CTRL_2_OFFSET)
+#define SDXC_PHY_CTRL_2_REG		RCT_REG(SDXC_PHY_CTRL_2_OFFSET)
+
+#define MS_DELAY_CTRL_OFFSET		0x1D0
+#define MS_DELAY_CTRL_REG		RCT_REG(MS_DELAY_CTRL_OFFSET)
+
+
+/* ==========================================================================*/
+
+#define PLL_NAND_CTRL_OFFSET		0x6f8
+#define PLL_NAND_FRAC_OFFSET		0x6fc
+#define PLL_NAND_CTRL2_OFFSET		0x700
+#define PLL_NAND_CTRL3_OFFSET		0x704
+#define PLL_NAND_CTRL_REG		RCT_REG(PLL_NAND_CTRL_OFFSET)
+#define PLL_NAND_FRAC_REG		RCT_REG(PLL_NAND_FRAC_OFFSET)
+#define PLL_NAND_CTRL2_REG		RCT_REG(PLL_NAND_CTRL2_OFFSET)
+#define PLL_NAND_CTRL3_REG		RCT_REG(PLL_NAND_CTRL3_OFFSET)
+
+
+/* ==========================================================================*/
+#define ADC_SOFT_RESET			0x10000
+#define SCALER_ADC_OFFSET		0x09C
+#define SCALER_ADC_REG			RCT_REG(SCALER_ADC_OFFSET)
+
+#define T2V_CTRL_OFFSET			0x1A0
+#define T2V_CTRL_REG			RCT_REG(T2V_CTRL_OFFSET)
+
+#define ADC16_CTRL_OFFSET		0x198
+#define ADC16_CTRL_REG			RCT_REG(ADC16_CTRL_OFFSET)
+
+#define ADC_POWER_DOWN			0x2
+
+/* ==========================================================================*/
+#define AHB_MISC_OFFSET			0x21c
+#define AHB_MISC_REG			RCT_REG(AHB_MISC_OFFSET)
+#define AHB_MISC_EN_REG			AHB_MISC_REG
+
+/* ==========================================================================*/
+#define IOCTRL_GPIO_OFFSET		0x1F8
+#define IOCTRL_GPIO_REG			RCT_REG(IOCTRL_GPIO_OFFSET)
+
+#define IOCTRL_MISC1_OFFSET		0x1FC
+#define IOCTRL_MISC1_REG		RCT_REG(IOCTRL_MISC1_OFFSET)
+
+#define IOCTRL_MISC2_OFFSET		0x200
+#define IOCTRL_MISC2_REG		RCT_REG(IOCTRL_MISC2_OFFSET)
+
+#define IOCTRL_SMIOA_OFFSET		0x204
+#define IOCTRL_SMIOA_REG		RCT_REG(IOCTRL_SMIOA_OFFSET)
+
+#define IOCTRL_SMIOB_OFFSET		0x208
+#define IOCTRL_SMIOB_REG		RCT_REG(IOCTRL_SMIOB_OFFSET)
+
+#define IOCTRL_SMIOC_OFFSET		0x20C
+#define IOCTRL_SMIOC_REG		RCT_REG(IOCTRL_SMIOC_OFFSET)
+
+#define IOCTRL_SMIOD_OFFSET		0x210
+#define IOCTRL_SMIOD_REG		RCT_REG(IOCTRL_SMIOD_OFFSET)
+
+#define IOCTRL_VD1_OFFSET		0x214
+#define IOCTRL_VD1_REG			RCT_REG(IOCTRL_VD1_OFFSET)
+
+#define IOCTRL_SENSOR_OFFSET		0x218
+#define IOCTRL_SENSOR_REG		RCT_REG(IOCTRL_SENSOR_OFFSET)
+
+#define IOCTRL_STRIG_OFFSET		0x250
+#define IOCTRL_STRIG_REG		RCT_REG(IOCTRL_STRIG_OFFSET)
+
+#define IOCTRL_SDXC_OFFSET		0x2F4
+#define IOCTRL_SDXC_REG			RCT_REG(IOCTRL_SDXC_OFFSET)
+
+#define SDXC_PULL_CTRL_OFFSET		0x2F8
+#define SDXC_PULL_CTRL_REG		RCT_REG(SDXC_PULL_CTRL_OFFSET)
+
+#define IOCTRL_DRIVE_STRENGTH_2MA	0x0
+#define IOCTRL_DRIVE_STRENGTH_8MA	0x1
+#define IOCTRL_DRIVE_STRENGTH_4MA	0x2
+#define IOCTRL_DRIVE_STRENGTH_12MA	0x3
+
+#define GPIO_DS0_0_OFFSET		0x314
+#define GPIO_DS1_0_OFFSET		0x318
+#define GPIO_DS0_1_OFFSET		0x31C
+#define GPIO_DS1_1_OFFSET		0x320
+#define GPIO_DS0_2_OFFSET		0x324
+#define GPIO_DS1_2_OFFSET		0x328
+#define GPIO_DS0_3_OFFSET		0x32C
+#define GPIO_DS1_3_OFFSET		0x330
+#define GPIO_DS0_4_OFFSET		0x438
+#define GPIO_DS1_4_OFFSET		0x43C
+#define GPIO_DS0_5_OFFSET		0x440
+#define GPIO_DS1_5_OFFSET		0x444
+#define GPIO_DS0_6_OFFSET		0x448
+#define GPIO_DS1_6_OFFSET		0x44C
+#define GPIO_DS0_OFFSET(bank)		((bank) >= 4 ? \
+					(0x438 + (((bank) - 4) * 8)) : \
+					(0x314 + ((bank) * 8)))
+#define GPIO_DS1_OFFSET(bank)		((bank) >= 4 ? \
+					(0x438 + (((bank) - 4) * 8) + 4) : \
+					(0x314 + ((bank) * 8) + 4))
+
+#define GPIO_DS0_0_REG			RCT_REG(GPIO_DS0_0_OFFSET)
+#define GPIO_DS1_0_REG			RCT_REG(GPIO_DS1_0_OFFSET)
+#define GPIO_DS0_1_REG			RCT_REG(GPIO_DS0_1_OFFSET)
+#define GPIO_DS1_1_REG			RCT_REG(GPIO_DS1_1_OFFSET)
+#define GPIO_DS0_2_REG			RCT_REG(GPIO_DS0_2_OFFSET)
+#define GPIO_DS1_2_REG			RCT_REG(GPIO_DS1_2_OFFSET)
+#define GPIO_DS0_3_REG			RCT_REG(GPIO_DS0_3_OFFSET)
+#define GPIO_DS1_3_REG			RCT_REG(GPIO_DS1_3_OFFSET)
+#define GPIO_DS0_4_REG			RCT_REG(GPIO_DS0_4_OFFSET)
+#define GPIO_DS1_4_REG			RCT_REG(GPIO_DS1_4_OFFSET)
+#define GPIO_DS0_5_REG			RCT_REG(GPIO_DS0_5_OFFSET)
+#define GPIO_DS1_5_REG			RCT_REG(GPIO_DS1_5_OFFSET)
+#define GPIO_DS0_6_REG			RCT_REG(GPIO_DS0_6_OFFSET)
+#define GPIO_DS1_6_REG			RCT_REG(GPIO_DS1_6_OFFSET)
+
+/* ==========================================================================*/
+
+#define RCT_TIMER_INSTANCES		2
+
+#define RCT_TIMER_OFFSET		0x254
+#define RCT_TIMER_CTRL_OFFSET		0x258
+#define RCT_TIMER_REG			RCT_REG(RCT_TIMER_OFFSET)
+#define RCT_TIMER_CTRL_REG		RCT_REG(RCT_TIMER_CTRL_OFFSET)
+
+#define RCT_TIMER2_OFFSET		0x494
+#define RCT_TIMER2_CTRL_OFFSET		0x498
+#define RCT_TIMER2_REG			RCT_REG(RCT_TIMER2_OFFSET)
+#define RCT_TIMER2_CTRL_REG		RCT_REG(RCT_TIMER2_CTRL_OFFSET)
+
+/* ==========================================================================*/
+
+/* Secure and Scratchpad */
+#if (CHIP_REV == CV1)
+#define AHB_SCRATCHPAD_OFFSET		0x1000
+#define AHB_SECURE_OFFSET		RCT_INVALID_OFFSET
+#else
+#define AHB_SCRATCHPAD_OFFSET		0x1B000
+#define AHB_SECURE_OFFSET		0x1D000
+#endif
+#define AHB_SCRATCHPAD_BASE		(AHB_S_BASE + AHB_SCRATCHPAD_OFFSET)
+#define AHB_SECURE_BASE			(AHB_S_BASE + AHB_SECURE_OFFSET)
+#define AHB_SCRATCHPAD_REG(x)		(AHB_SCRATCHPAD_BASE + (x))
+#define AHB_SECURE_REG(x)		(AHB_SECURE_BASE + (x))
+
+#define AHBSP_CTL_OFFSET		0x0C
+#define AHBSP_CTL_REG			AHB_SCRATCHPAD_REG(AHBSP_CTL_OFFSET)
+
+#if (CHIP_REV == S3L)
+#define AHBSP_PRI_IRQ_C0_OFFSET		0x38
+#define AHBSP_PRI_IRQ_C1_OFFSET		-1 /* not supported */
+#else
+#define AHBSP_PRI_IRQ_C0_OFFSET		0x3C
+#define AHBSP_PRI_IRQ_C1_OFFSET		0x40
+#endif
+#define AHBSP_PRI_IRQ_C0_REG		AHB_SCRATCHPAD_REG(AHBSP_PRI_IRQ_C0_OFFSET)
+#define AHBSP_PRI_IRQ_C1_REG		AHB_SCRATCHPAD_REG(AHBSP_PRI_IRQ_C1_OFFSET)
+
+/* ==========================================================================*/
+
+#if (CHIP_REV == S2L)
+#define DMA_SUPPORT_SELECT_CHANNEL	0
+#else
+#define DMA_SUPPORT_SELECT_CHANNEL	1
+#endif
+
+#if (CHIP_REV == S3) || (CHIP_REV == S5) || (CHIP_REV == CV1)
+#define AHBSP_DMA0_SEL0_OFFSET		0x30
+#else
+#define AHBSP_DMA0_SEL0_OFFSET		0x2C
+#endif
+#define AHBSP_DMA0_SEL0_REG		AHB_SCRATCHPAD_REG(AHBSP_DMA0_SEL0_OFFSET)
+
+#define AHBSP_DMA0_SEL1_OFFSET		0x34
+#define AHBSP_DMA0_SEL1_REG		AHB_SCRATCHPAD_REG(AHBSP_DMA0_SEL1_OFFSET)
+
+#define AHBSP_DMA1_SEL0_OFFSET		0x38
+#define AHBSP_DMA1_SEL0_REG		AHB_SCRATCHPAD_REG(AHBSP_DMA1_SEL0_OFFSET)
+
+#define AHBSP_DMA1_SEL1_OFFSET		0x3C
+#define AHBSP_DMA1_SEL1_REG		AHB_SCRATCHPAD_REG(AHBSP_DMA1_SEL1_OFFSET)
+
+#define SSI0_TX_DMA_REQ_IDX		0
+#define SSI0_RX_DMA_REQ_IDX		1
+#define SSI1_TX_DMA_REQ_IDX		2
+#define SSI1_RX_DMA_REQ_IDX		3
+#define NOR_SPI_TX_DMA_REQ_IDX		4
+#define NOR_SPI_RX_DMA_REQ_IDX		5
+#define SSIS0_TX_DMA_REQ_IDX		6
+#define SSIS0_RX_DMA_REQ_IDX		7
+#define UART1_TX_DMA_REQ_IDX		8
+#define UART1_RX_DMA_REQ_IDX		9
+#define I2S_TX_DMA_REQ_IDX		10
+#define I2S_RX_DMA_REQ_IDX		11
+#if (CHIP_REV == S3) || (CHIP_REV == S3L) || (CHIP_REV == S5)
+#define SLIM_TX_DMA_REQ_IDX		12
+#define SLIM_RX_DMA_REQ_IDX		13
+#else
+#define UART2_TX_DMA_REQ_IDX		12
+#define UART2_RX_DMA_REQ_IDX		13
+#endif
+#if (CHIP_REV == S3) || (CHIP_REV == S3L) || (CHIP_REV == S5) || (CHIP_REV == S5L)
+#define SSI2_TX_DMA_REQ_IDX		14
+#define SSI2_RX_DMA_REQ_IDX		15
+#else
+#define UART3_TX_DMA_REQ_IDX		14
+#define UART3_RX_DMA_REQ_IDX		15
+#endif
+#define UART4_TX_DMA_REQ_IDX		16
+#define UART4_RX_DMA_REQ_IDX		17
+#define UART5_TX_DMA_REQ_IDX		18
+#define UART5_RX_DMA_REQ_IDX		19
+#define UART6_TX_DMA_REQ_IDX		20
+#define UART6_RX_DMA_REQ_IDX		21
+#if (CHIP_REV == CV1)
+#define SSI2_TX_DMA_REQ_IDX		22
+#define SSI2_RX_DMA_REQ_IDX		23
+#endif
+#define SSI3_TX_DMA_REQ_IDX		24
+#define SSI3_RX_DMA_REQ_IDX		25
+#define SSI4_TX_DMA_REQ_IDX		26
+#define SSI4_RX_DMA_REQ_IDX		27
+#define SSI5_TX_DMA_REQ_IDX		28
+#define SSI5_RX_DMA_REQ_IDX		29
+
+/* ==========================================================================*/
+
+#define	POC_ETH_IS_ENABLED		0x00000001
+
+#if (CHIP_REV == S5) || (CHIP_REV == CV1)
+#define	POC_GCLK_CORE_DIV2_MASK		0x00800000
+#elif (CHIP_REV == S5L)
+#define	POC_GCLK_CORE_DIV2_MASK		0x00100000
+#else
+#define	POC_GCLK_CORE_DIV2_MASK		0x00000000
+#endif
+
+#if (CHIP_REV == S3)
+#define POC_BOOT_FROM_MASK		0x00000570
+#define POC_BOOT_FROM_BYPASS		0x00000100
+#define POC_BOOT_FROM_USB		0x00000400
+#define POC_BOOT_FROM_SPINOR		0x00000000
+#define POC_BOOT_FROM_NAND		0x00000010
+#define POC_BOOT_FROM_EMMC		0x00000020
+#define POC_BOOT_FROM_HIF		0x00000040
+#define POC_BOOT_FROM_SPI		0xFFFFFFFF /* not supported */
+#elif (CHIP_REV == S2L) || (CHIP_REV == S3L)
+#define POC_BOOT_FROM_MASK		0x00000530
+#define POC_BOOT_FROM_BYPASS		0x00000100
+#define POC_BOOT_FROM_USB		0x00000400
+#define POC_BOOT_FROM_SPINOR		0x00000000
+#define POC_BOOT_FROM_NAND		0x00000010
+#define POC_BOOT_FROM_EMMC		0x00000020
+#define POC_BOOT_FROM_HIF		0xFFFFFFFF /* not supported */
+#elif (CHIP_REV == S5) || (CHIP_REV == CV1)
+#define POC_BOOT_FROM_MASK		0x00000570
+#define POC_BOOT_FROM_BYPASS		0x00000100
+#define POC_BOOT_FROM_USB		0x00000400
+#define POC_BOOT_FROM_SPINOR		0x00000000
+#define POC_BOOT_FROM_NAND		0x00000010
+#define POC_BOOT_FROM_EMMC		0x00000020
+#define POC_BOOT_FROM_SPI		0x00000030
+#define POC_BOOT_FROM_HIF		0x00000040
+#elif (CHIP_REV == S5L)
+#define POC_BOOT_FROM_MASK		0x00000530
+#define POC_BOOT_FROM_BYPASS		0x00000100
+#define POC_BOOT_FROM_USB		0x00000400
+#define POC_BOOT_FROM_SPINOR		0x00000000
+#define POC_BOOT_FROM_NAND		0x00000010
+#define POC_BOOT_FROM_EMMC		0x00000020
+#define POC_BOOT_FROM_SPI		0x00000030
+#define POC_BOOT_FROM_HIF		0xFFFFFFFF /* not supported */
+#endif
+
+#define RCT_BOOT_FROM_BYPASS		0x80000000
+#define RCT_BOOT_FROM_NAND		0x00000001
+#define RCT_BOOT_FROM_USB		0x00000002
+#define RCT_BOOT_FROM_EMMC		0x00000004
+#define RCT_BOOT_FROM_SPINOR		0x00000008
+#define RCT_BOOT_FROM_HIF		0x00000010
+
+/* ==========================================================================*/
+#if (CHIP_REV == CV1)
+#define SYS_CONFIG_NAND_4K_FIFO		0x00000000 /* not used */
+#define SYS_CONFIG_NAND_PAGE_SIZE	0x00040000
+#define SYS_CONFIG_NAND_READ_CONFIRM	0x00000000 /* not used */
+#define SYS_CONFIG_NAND_ECC_BCH_EN	0x00010000
+#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00008000
+#else
+#define SYS_CONFIG_NAND_4K_FIFO	0x00080000
 #define SYS_CONFIG_NAND_PAGE_SIZE	0x00040000
 #define SYS_CONFIG_NAND_READ_CONFIRM	0x00020000
 #define SYS_CONFIG_NAND_ECC_BCH_EN	0x00010000
-#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00008000
-#endif
-
-/* these definition are used by software */
-#define RCT_BOOT_NAND_AUTO		0x00000000
-#define RCT_BOOT_NAND_PAGE_SIZE		0x00000001
-#define RCT_BOOT_NAND_READ_CONFIRM	0x00000002
-#define RCT_BOOT_NAND_ECC_BCH_EN	0x00000004
-#define RCT_BOOT_NAND_ECC_SPARE_2X	0x00000008
-
-/* ==========================================================================*/
-#if (CHIP_REV == S2)
-#define SYS_CONFIG_MMC_HS		0x00010000
-#define SYS_CONFIG_MMC_DDR		0x00020000
-#define SYS_CONFIG_MMC_4BIT		0x00040000
-#define SYS_CONFIG_MMC_8BIT		0x00080000
-#elif (CHIP_REV == S2E)
-#define SYS_CONFIG_MMC_HS		0x00010000
-#define SYS_CONFIG_MMC_DDR		0x00000000 /* not supported */
-#define SYS_CONFIG_MMC_4BIT		0x00040000
-#define SYS_CONFIG_MMC_8BIT		0x00080000
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3)
+#define SYS_CONFIG_NAND_ECC_SPARE_2X	0x00008000
+#endif
+
+/* these definition are used by software */
+#define RCT_BOOT_NAND_AUTO		0x00000000
+#define RCT_BOOT_NAND_PAGE_SIZE		0x00000001
+#define RCT_BOOT_NAND_READ_CONFIRM	0x00000002
+#define RCT_BOOT_NAND_ECC_BCH_EN	0x00000004
+#define RCT_BOOT_NAND_ECC_SPARE_2X	0x00000008
+
+/* ==========================================================================*/
+#if (CHIP_REV == S2L) || (CHIP_REV == S3)
 #define SYS_CONFIG_MMC_HS		0x00008000
 #define SYS_CONFIG_MMC_DDR		0x00004000
 #define SYS_CONFIG_MMC_4BIT		0x00020000
-#define SYS_CONFIG_MMC_8BIT		0x00010000
-#elif (CHIP_REV == S3L)
-#define SYS_CONFIG_MMC_HS		0x00000000
-#define SYS_CONFIG_MMC_DDR		0x00000000
-#define SYS_CONFIG_MMC_4BIT		0x00010000
-#define SYS_CONFIG_MMC_8BIT		0x00008000
-#else
-#define SYS_CONFIG_MMC_HS		0x00000000
-#define SYS_CONFIG_MMC_DDR		0x00000000
-#define SYS_CONFIG_MMC_4BIT		0x00000000
-#define SYS_CONFIG_MMC_8BIT		0x00000000
-#endif
-
-/* these definition are used by software */
-#define RCT_BOOT_EMMC_AUTO		0x00000000
-#define RCT_BOOT_EMMC_HS		0x00000001
-#define RCT_BOOT_EMMC_DDR		0x00000002
-#define RCT_BOOT_EMMC_4BIT		0x00000004
-#define RCT_BOOT_EMMC_8BIT		0x00000008
-
-/* ==========================================================================*/
+#define SYS_CONFIG_MMC_8BIT		0x00010000
+#elif (CHIP_REV == S5) || (CHIP_REV == CV1)
+#define SYS_CONFIG_MMC_HS		0x00004000
+#define SYS_CONFIG_MMC_DDR		0x00000000 /* not supported */
+#define SYS_CONFIG_MMC_4BIT		0x00010000
+#define SYS_CONFIG_MMC_8BIT		0x00008000
+#else
+#define SYS_CONFIG_MMC_HS		0x00000000 /* not supported */
+#define SYS_CONFIG_MMC_DDR		0x00000000 /* not supported */
+#define SYS_CONFIG_MMC_4BIT		0x00010000
+#define SYS_CONFIG_MMC_8BIT		0x00008000
+#endif
+
+/* these definition are used by software */
+#define RCT_BOOT_EMMC_AUTO		0x00000000
+#define RCT_BOOT_EMMC_HS		0x00000001
+#define RCT_BOOT_EMMC_DDR		0x00000002
+#define RCT_BOOT_EMMC_4BIT		0x00000004
+#define RCT_BOOT_EMMC_8BIT		0x00000008
+
+/* ==========================================================================*/
 #ifndef __ASM__
-/* ==========================================================================*/
-
+/* ==========================================================================*/
+
 extern void rct_pll_init(void);
 extern u32 get_apb_bus_freq_hz(void);
 extern u32 get_ahb_bus_freq_hz(void);
 extern u32 get_core_bus_freq_hz(void);
 extern u32 get_ddr_freq_hz(void);
-extern u32 get_idsp_freq_hz(void);
+extern u32 get_idsp_freq_hz(void);
 extern u32 get_cortex_freq_hz(void);
-extern u32 get_arm_bus_freq_hz(void);
+extern u32 get_enet_freq_hz(void);
+extern u32 get_nand_freq_hz(void);
 
 extern u32 rct_boot_from(void);
-extern u32 rct_is_eth_enabled(void);
-extern u32 rct_get_nand_poc(void);
-extern u32 rct_get_emmc_poc(void);
-
-extern void rct_timer_enable();
-extern void rct_timer_disable();
-extern void rct_timer_reset_count();
-extern u32 rct_timer_get_count();
-extern u32 rct_timer_get_tick();
-extern u32 rct_timer_tick2ms(u32 s_tck, u32 e_tck);
-extern void rct_timer_dly_ms(u32 dly_tim);
-extern u32 rct_timer_get_frequency_div_1000();
-extern void rct_timer_delay_ticks(u32 ticks);
-
+extern u32 rct_is_eth_enabled(void);
+extern u32 rct_get_nand_poc(void);
+extern u32 rct_get_emmc_poc(void);
+
+extern void rct_timer_reset_count();
+extern u32 rct_timer_get_count();
+extern u32 rct_timer_get_tick();
+extern u32 rct_timer_tick2ms(u32 s_tck, u32 e_tck);
+extern void rct_timer_dly_ms(u32 dly_tim);
+extern void rct_timer2_reset_count();
+extern u32 rct_timer2_get_count();
+extern u32 rct_timer2_get_tick();
+extern u32 rct_timer2_tick2ms(u32 s_tck, u32 e_tck);
+extern void rct_timer2_dly_ms(u32 dly_tim);
+
 extern u32 get_gtx_freq_hz(void);
-
-extern void amboot_rct_reset_chip_pre(void)
+
+extern void amboot_rct_reset_chip_pre(void)
 	__attribute__ ((weak));
-extern void amboot_rct_reset_chip_sdmmc(void)
+extern void amboot_rct_reset_chip_sdmmc(void)
 	__attribute__ ((weak));
 extern void rct_reset_chip(void);
-extern void rct_reset_fio(void);
-
-extern void rct_set_uart_pll(void);
-extern u32 get_uart_freq_hz(void);
-
-
-extern void rct_set_ssi_pll(void);
-extern u32 get_ssi_freq_hz(void);
-
-extern void rct_set_ssi2_pll(void);
+extern void rct_reset_fio(void);
+
+extern void rct_set_uart_pll(u32 reg);
+extern u32 get_uart_freq_hz(u32 reg);
+
+
+extern void rct_set_ssi_pll(void);
+extern u32 get_ssi_freq_hz(void);
+
+extern void rct_set_ssi2_pll(void);
 extern u32 get_ssi2_freq_hz(void);
-
-extern void rct_set_ssi3_pll(void);
-extern u32 get_ssi3_freq_hz(void);
-
+
+extern void rct_set_ssi3_pll(void);
+extern u32 get_ssi3_freq_hz(void);
+
 extern void rct_set_sd_pll(u32 freq_hz);
 extern u32 get_sd_freq_hz(void);
-
-extern void rct_set_sdio_pll(u32 freq_hz);
+
+extern void rct_set_sdio_pll(u32 freq_hz);
 extern u32 get_sdio_freq_hz(void);
-
-extern void rct_set_sdxc_pll(u32 freq_hz);
-extern u32 get_sdxc_freq_hz(void);
-
-extern void rct_set_so_pll(void);
-extern void rct_set_vo_pll(void);
-extern void rct_set_vo2_pll(void);
-
-extern void rct_set_audio_pll(void);
-
+
+extern void rct_set_sdxc_pll(u32 freq_hz);
+extern u32 get_sdxc_freq_hz(void);
+
+extern void rct_set_so_pll(void);
+extern void rct_set_vo_pll(void);
+extern void rct_set_vo2_pll(void);
+
+extern void rct_set_audio_pll(void);
+
 extern void rct_enable_usb(void);
 extern void rct_suspend_usb(void);
 extern void rct_usb_reset(void);
-
-extern void rct_show_pll(void);
-extern void rct_show_boot_from(u32 boot_from);
-
-extern void dma_channel_select(void);
-
-/* ==========================================================================*/
-#endif
-/* ==========================================================================*/
-
-#endif
-
+
+extern void rct_show_pll(void);
+extern void rct_show_boot_from(u32 boot_from);
+
+extern void dma_channel_select(void);
+
+extern void rct_power_off(void);
+/* ==========================================================================*/
+#endif
+/* ==========================================================================*/
+
+#endif
+
diff --git a/include/ambhw/sd.h b/include/ambhw/sd.h
index d2a65fa..3eb20c0 100644
--- a/include/ambhw/sd.h
+++ b/include/ambhw/sd.h
@@ -1,378 +1,411 @@
-/*
- * ambhw/sd.h
- *
- * History:
- *	2007/01/27 - [Charles Chiou] created file
- *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- */
-
-#ifndef __AMBHW__SD_H__
-#define __AMBHW__SD_H__
-
-/* ==========================================================================*/
-#if (CHIP_REV == A7L) || (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S3L)
-#define SD_INSTANCES			2
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define SD_INSTANCES			3
-#else
-#define SD_INSTANCES			1
-#endif
-
-#if (CHIP_REV == S2) || (CHIP_REV == S2E) || (CHIP_REV == S2L) || (CHIP_REV == S3)
-#define SD_SUPPORT_SDIO			1
-#else
-#define SD_SUPPORT_SDIO			0
-#endif
-
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define SD_SUPPORT_SDXC			1
-#else
-#define SD_SUPPORT_SDXC			0
-#endif
-
-/* ==========================================================================*/
-#define SD0_OFFSET			0x2000
-#define SD1_OFFSET			0xC000
-#define SD2_OFFSET			0x1F000
-
-#define SD0_BASE			(AHB_BASE + SD0_OFFSET)
-#define SD1_BASE			(AHB_BASE + SD1_OFFSET)
-#define SD2_BASE			(AHB_BASE + SD2_OFFSET)
-#define SD_BASE(id)			((id == 0) ? SD0_BASE : \
-					 (id == 1) ? SD1_BASE : SD2_BASE)
-
-#define SD0_REG(x)			(SD0_BASE + (x))
-#define SD2_REG(x)			(SD1_BASE + (x))
-#define SD3_REG(x)			(SD2_BASE + (x))
-
-/* ==========================================================================*/
-#define SD_DMA_ADDR_OFFSET		0x000
-#define SD_BLK_SZ_OFFSET		0x004	/* Half word */
-#define SD_BLK_CNT_OFFSET		0x006	/* Half word */
-#define SD_ARG_OFFSET			0x008
-#define SD_XFR_OFFSET			0x00C	/* Half word */
-#define SD_CMD_OFFSET			0x00E	/* Half word */
-#define SD_RSP0_OFFSET			0x010
-#define SD_RSP1_OFFSET			0x014
-#define SD_RSP2_OFFSET			0x018
-#define SD_RSP3_OFFSET			0x01C
-#define SD_DATA_OFFSET			0x020
-#define SD_STA_OFFSET			0x024
-#define SD_HOST_OFFSET			0x028	/* Byte */
-#define SD_PWR_OFFSET			0x029	/* Byte */
-#define SD_GAP_OFFSET			0x02A	/* Byte */
-#define SD_WAK_OFFSET			0x02B	/* Byte */
-#define SD_CLK_OFFSET			0x02C	/* Half word */
-#define SD_TMO_OFFSET			0x02E	/* Byte */
-#define SD_RESET_OFFSET			0x02F	/* Byte */
-#define SD_NIS_OFFSET			0x030	/* Half word */
-#define SD_EIS_OFFSET			0x032	/* Half word */
-#define SD_NISEN_OFFSET			0x034	/* Half word */
-#define SD_EISEN_OFFSET			0x036	/* Half word */
-#define SD_NIXEN_OFFSET			0x038	/* Half word */
-#define SD_EIXEN_OFFSET			0x03A	/* Half word */
-#define SD_AC12ES_OFFSET		0x03C	/* Half word */
-#define SD_HOST2_OFFSET			0x03E	/* Half word */
-#define SD_CAP_OFFSET			0x040
-#define SD_CUR_OFFSET			0x048
-#define SD_ADMA_STA_OFFSET		0x054
-#define SD_ADMA_ADDR_OFFSET		0x058
-#define SD_XC_CTR_OFFSET		0x060
-#define SD_BOOT_CTR_OFFSET		0x070
-#define SD_BOOT_STA_OFFSET		0x074
-#define SD_VOL_SW_OFFSET		0x07C
-#define SD_LAT_CTRL_OFFSET		0x0F8
-#define SD_SIST_OFFSET			0x0FC	/* Half word */
-#define SD_VER_OFFSET			0x0FE	/* Half word */
-
-/* SD_BLK_SZ_REG */
-#define SD_BLK_SZ_4KB			0x0000
-#define SD_BLK_SZ_8KB			0x1000
-#define SD_BLK_SZ_16KB			0x2000
-#define SD_BLK_SZ_32KB			0x3000
-#define SD_BLK_SZ_64KB			0x4000
-#define SD_BLK_SZ_128KB			0x5000
-#define SD_BLK_SZ_256KB			0x6000
-#define SD_BLK_SZ_512KB			0x7000
-
-/* SD_XFR_REG */
-#define SD_XFR_MUL_SEL			0x0020
-#define SD_XFR_SGL_SEL			0x0000
-#define SD_XFR_CTH_SEL			0x0010
-#define SD_XFR_HTC_SEL			0x0000
-#define SD_XFR_AC12_EN			0x0004
-#define SD_XFR_BLKCNT_EN		0x0002
-#define SD_XFR_DMA_EN			0x0001
-
-/* SD_CMD_REG */
-#define SD_CMD_IDX(x)			((x) << 8)
-#define SD_CMD_NORMAL			0x00000000
-#define SD_CMD_SUSPEND			0x00000040
-#define SD_CMD_RESUME			0x00000080
-#define SD_CMD_ABORT			0x000000C0
-#define SD_CMD_DATA			0x00000020
-#define SD_CMD_CHKIDX			0x00000010
-#define SD_CMD_CHKCRC			0x00000008
-#define SD_CMD_RSP_NONE			0x00000000
-#define SD_CMD_RSP_136			0x00000001
-#define SD_CMD_RSP_48			0x00000002
-#define SD_CMD_RSP_48BUSY		0x00000003
-
-/* SD_STA_REG */
-#define SD_STA_DAT_LSL(x)		((((x) & 0x1e000000) >> 25) | \
-					 (((x) & 0x00f00000) >> 20))
-#define SD_STA_CMD_LSL(x)		(((x)  & 0x01000000) >> 24)
-#define SD_STA_WPS_PL			0x00080000
-#define SD_STA_CDP_L			0x00040000
-#define SD_STA_CSS			0x00020000
-#define SD_STA_CARD_INSERTED		0x00010000
-#define SD_STA_BUFFER_READ_EN		0x00000800
-#define SD_STA_BUFFER_WRITE_EN		0x00000400
-#define SD_STA_READ_XFR_ACTIVE		0x00000200
-#define SD_STA_WRITE_XFR_ACTIVE		0x00000100
-#define SD_STA_DAT_ACTIVE		0x00000004
-#define SD_STA_CMD_INHIBIT_DAT		0x00000002
-#define SD_STA_CMD_INHIBIT_CMD		0x00000001
-
-/* SD_HOST_REG */
-#define SD_HOST_ADMA			0x10
-#define SD_HOST_8BIT			0x08
-#define SD_HOST_HIGH_SPEED		0x04
-#define SD_HOST_4BIT			0x02
-#define SD_HOST_LED_ON			0x01
-
-/* SD_PWR_REG */
-#if (CHIP_REV == A5S)
-#define SD_PWR_3_3V			0x0e
-#define SD_PWR_3_0V			0x0c
-#define SD_PWR_1_8V			0x0a
-#else
-/* SD_PWR_REG only care about bit[3] */
-#define SD_PWR_3_3V			0x08
-#define SD_PWR_3_0V			0x08
-#define SD_PWR_1_8V			0x00
-#endif
-
-#define SD_PWR_ON			0x01
-#define SD_PWR_OFF			0x00
-
-/* SD_GAP_REG */
-#define SD_GAP_INT_AT_GAP		0x08
-#define SD_GAP_READ_WAIT		0x04
-#define SD_GAP_CONT_REQ			0x02
-#define SD_GAP_STOP_AT_GAP		0x01
-
-/* SD_WAK_REG */
-#define SD_WAK_ON_CARD_RMV		0x04
-#define SD_WAK_ON_CARD_IST		0x02
-#define SD_WAK_ON_CARD_INT		0x01
-
-/* SD_CLK_REG */
-#define SD_CLK_DIV_256			0x8000
-#define SD_CLK_DIV_128			0x4000
-#define SD_CLK_DIV_64			0x2000
-#define SD_CLK_DIV_32			0x1000
-#define SD_CLK_DIV_16			0x0800
-#define SD_CLK_DIV_8			0x0400
-#define SD_CLK_DIV_4			0x0200
-#define SD_CLK_DIV_2			0x0100
-#define SD_CLK_DIV_1			0x0000
-#define SD_CLK_EN			0x0004
-#define SD_CLK_ICLK_STABLE		0x0002
-#define SD_CLK_ICLK_EN			0x0001
-
-/* SD_TMO_REG */
-
-/* SD_RESET_REG */
-#define SD_RESET_DAT			0x04
-#define SD_RESET_CMD			0x02
-#define SD_RESET_ALL			0x01
-
-/* SD_NIS_REG */
-#define SD_NIS_ERROR			0x8000
-#define SD_NIS_CARD			0x0100
-#define SD_NIS_REMOVAL			0x0080
-#define SD_NIS_INSERT			0x0040
-#define SD_NIS_READ_READY		0x0020
-#define SD_NIS_WRITE_READY		0x0010
-#define SD_NIS_DMA			0x0008
-#define SD_NIS_BLOCK_GAP		0x0004
-#define SD_NIS_XFR_DONE			0x0002
-#define SD_NIS_CMD_DONE			0x0001
-
-/* SD_EIS_REG */
-#define SD_EIS_ADMA_ERR			0x0200
-#define SD_EIS_ACMD12_ERR		0x0100
-#define SD_EIS_CURRENT_ERR		0x0080
-#define SD_EIS_DATA_BIT_ERR		0x0040
-#define SD_EIS_DATA_CRC_ERR		0x0020
-#define SD_EIS_DATA_TMOUT_ERR		0x0010
-#define SD_EIS_CMD_IDX_ERR		0x0008
-#define SD_EIS_CMD_BIT_ERR		0x0004
-#define SD_EIS_CMD_CRC_ERR		0x0002
-#define SD_EIS_CMD_TMOUT_ERR		0x0001
-
-/* SD_NISEN_REG */
-#define SD_NISEN_CARD			0x0100
-#define SD_NISEN_REMOVAL		0x0080
-#define SD_NISEN_INSERT			0x0040
-#define SD_NISEN_READ_READY		0x0020
-#define SD_NISEN_WRITE_READY		0x0010
-#define SD_NISEN_DMA			0x0008
-#define SD_NISEN_BLOCK_GAP		0x0004
-#define SD_NISEN_XFR_DONE		0x0002
-#define SD_NISEN_CMD_DONE		0x0001
-
-/* SD_EISEN_REG */
-#define SD_EISEN_ADMA_ERR		0x0200
-#define SD_EISEN_ACMD12_ERR		0x0100
-#define SD_EISEN_CURRENT_ERR		0x0080
-#define SD_EISEN_DATA_BIT_ERR		0x0040
-#define SD_EISEN_DATA_CRC_ERR		0x0020
-#define SD_EISEN_DATA_TMOUT_ERR		0x0010
-#define SD_EISEN_CMD_IDX_ERR		0x0008
-#define SD_EISEN_CMD_BIT_ERR		0x0004
-#define SD_EISEN_CMD_CRC_ERR		0x0002
-#define SD_EISEN_CMD_TMOUT_ERR		0x0001
-
-/* SD_NIXEN_REG */
-#define SD_NIXEN_CARD			0x0100
-#define SD_NIXEN_REMOVAL		0x0080
-#define SD_NIXEN_INSERT			0x0040
-#define SD_NIXEN_READ_READY		0x0020
-#define SD_NIXEN_WRITE_READY		0x0010
-#define SD_NIXEN_DMA			0x0008
-#define SD_NIXEN_BLOCK_GAP		0x0004
-#define SD_NIXEN_XFR_DONE		0x0002
-#define SD_NIXEN_CMD_DONE		0x0001
-
-/* SD_EIXEN_REG */
-#define SD_EIXEN_ADMA_ERR		0x0200
-#define SD_EIXEN_ACMD12_ERR		0x0100
-#define SD_EIXEN_CURRENT_ERR		0x0080
-#define SD_EIXEN_DATA_BIT_ERR		0x0040
-#define SD_EIXEN_DATA_CRC_ERR		0x0020
-#define SD_EIXEN_DATA_TMOUT_ERR		0x0010
-#define SD_EIXEN_CMD_IDX_ERR		0x0008
-#define SD_EIXEN_CMD_BIT_ERR		0x0004
-#define SD_EIXEN_CMD_CRC_ERR		0x0002
-#define SD_EIXEN_CMD_TMOUT_ERR		0x0001
-
-/* SD_AC12ES_REG */
-#if (CHIP_REV == A5S)
-#define SD_AC12ES_NOT_ISSUED		0x0040
-#define SD_AC12ES_INDEX			0x0020
-#define SD_AC12ES_END_BIT		0x0010
-#else
-#define SD_AC12ES_NOT_ISSUED		0x0080
-#define SD_AC12ES_INDEX			0x0010
-#define SD_AC12ES_END_BIT		0x0008
-#endif
-#define SD_AC12ES_CRC_ERROR		0x0004
-#define SD_AC12ES_TMOUT_ERROR		0x0002
-#define SD_AC12ES_NOT_EXECED		0x0001
-
-/* SD_ADMA_STA_REG */
-#define SD_ADMA_STA_ST_STOP		0x00000000
-#define SD_ADMA_STA_ST_FDS		0x00000001
-#define SD_ADMA_STA_ST_TFR		0x00000003
-#define SD_ADMA_STA_LEN_ERR		0x00000004
-
-/* SD_CAP_REG */
-#define SD_CAP_INTMODE			0x08000000
-#define SD_CAP_VOL_1_8V			0x04000000
-#define SD_CAP_VOL_3_0V			0x02000000
-#define SD_CAP_VOL_3_3V			0x01000000
-#define SD_CAP_SUS_RES			0x00800000
-#define SD_CAP_DMA			0x00400000
-#define SD_CAP_HIGH_SPEED		0x00200000
-#define SD_CAP_ADMA_SUPPORT		0x00080000
-#define SD_CAP_MAX_512B_BLK		0x00000000
-#define SD_CAP_MAX_1KB_BLK		0x00010000
-#define SD_CAP_MAX_2KB_BLK		0x00020000
-#define SD_CAP_BASE_FREQ(x)		(((x) & 0x3f00) >> 8)
-#define SD_CAP_TOCLK_KHZ		0x00000000
-#define SD_CAP_TOCLK_MHZ		0x00000080
-#define SD_CAP_TOCLK_FREQ(x)		(((x) & 0x3f))
-
-/* SD_XC_CTR_REG */
-#define SD_XC_CTR_DDR_EN		0x00008000
-#define SD_XC_CTR_VOL_1_8V		0x00000001
-#define SD_XC_CTR_VOL_3_3V		0x00000000
-
-/* SD_BOOT_CTR_REG */
-#define SD_BOOT_CTR_RST_EN		0x00010000
-
-/* SD_BOOT_STA_REG */
-#define SD_BOOT_STA_END_ALT		0x01010000
-#define SD_BOOT_STA_BOOT_RDY		0x00000001
-
-/* SD_VOL_SW_REG */
-#define SD_VOL_SW_CMD_STAT_H		0x00010000
-#define SD_VOL_SW_DAT_STAT_H		0x00000007
-
-/* SD_VER_REG */
-#define SD_VER_VENDOR(x)		((x) >> 8)
-#define SD_VER_SPEC(x)			((x) & 0xf)
-
-#define SD_ADMA_TBL_LINE_SIZE		(8)
-#define SD_ADMA_TBL_LINE_MAX_LEN	(0x40000)
-#define SD_ADMA_TBL_ATTR_NOP		(0x0000)
-#define SD_ADMA_TBL_ATTR_RSV		(0x0010)
-#define SD_ADMA_TBL_ATTR_TRAN		(0x0020)
-#define SD_ADMA_TBL_ATTR_LINK		(0x0030)
-#define SD_ADMA_TBL_ATTR_WORD		(0x0008)
-#define SD_ADMA_TBL_ATTR_INT		(0x0004)
-#define SD_ADMA_TBL_ATTR_END		(0x0002)
-#define SD_ADMA_TBL_ATTR_VALID		(0x0001)
-
-/* ==========================================================================*/
-#define SMIO_2				GPIO(64)
-#define SMIO_3				GPIO(65)
-#define SMIO_4				GPIO(66)
-#define SMIO_5				GPIO(67)
-#define SD1_CD				GPIO(67)
-#define SMIO_6				GPIO(68)
-#define SMIO_38				GPIO(69)
-#define SMIO_39				GPIO(70)
-#define SMIO_40				GPIO(71)
-#define SMIO_41				GPIO(72)
-#define SMIO_42				GPIO(73)
-#define SMIO_43				GPIO(74)
-#define SMIO_44				GPIO(75)
-#define SMIO_45				GPIO(76)
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S)
-#define AMBA_SD_MAX_SLOT_NUM		(2)
-#else
-#define AMBA_SD_MAX_SLOT_NUM		(1)
-#endif
-
-#define sd_slot_is_valid(slot)		((SD_SUPPORT_SDXC == 1) && ((slot) == 2) ? 1 : \
-					(SD_SUPPORT_SDIO == 1) && ((slot) == 1) ? 1 : \
-					((slot) == 0) ? 1 : 0)
-
-#if (CHIP_REV == A5S) || (CHIP_REV == A7L) || (CHIP_REV == S2)
-#define sd_addr_is_unlign(addr)		((addr) & 0x3)
-#else
-#define sd_addr_is_unlign(addr)		0
-#endif
-
+/*
+ * ambhw/sd.h
+ *
+ * History:
+ *	2007/01/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBHW__SD_H__
+#define __AMBHW__SD_H__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+#if (CHIP_REV == S3L) || (CHIP_REV == S5L) || (CHIP_REV == CV1)
+#define SD_INSTANCES			2
+#elif (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S5)
+#define SD_INSTANCES			3
+#else
+#define SD_INSTANCES			1
+#endif
+
+#if (CHIP_REV == S3L) || (CHIP_REV == S5L) || (CHIP_REV == CV1)
+#define SD_SUPPORT_SDIO			0
+#else
+#define SD_SUPPORT_SDIO			1
+#endif
+
+#define SD_SUPPORT_SDXC			1
+
+/* ==========================================================================*/
+#if (CHIP_REV == CV1)
+#define SD0_OFFSET			0x4000
+#else
+#define SD0_OFFSET			0x2000
+#endif
+
+#define SD1_OFFSET			0xC000
+
+#if (CHIP_REV == CV1)
+#define SD2_OFFSET			0x5000
+#else
+#define SD2_OFFSET			0x1F000
+#endif
+
+#define SD0_BASE			(AHB_N_BASE + SD0_OFFSET)
+#define SD1_BASE			(AHB_N_BASE + SD1_OFFSET)
+#define SD2_BASE			(AHB_N_BASE + SD2_OFFSET)
+#define SD_BASE(id)			((id == 0) ? SD0_BASE : \
+					 (id == 1) ? SD1_BASE : SD2_BASE)
+
+#define SD0_REG(x)			(SD0_BASE + (x))
+#define SD2_REG(x)			(SD1_BASE + (x))
+#define SD3_REG(x)			(SD2_BASE + (x))
+
+/* ==========================================================================*/
+#define SD_DMA_ADDR_OFFSET		0x000
+#define SD_BLK_SZ_OFFSET		0x004	/* Half word */
+#define SD_BLK_CNT_OFFSET		0x006	/* Half word */
+#define SD_ARG_OFFSET			0x008
+#define SD_XFR_OFFSET			0x00C	/* Half word */
+#define SD_CMD_OFFSET			0x00E	/* Half word */
+#define SD_RSP0_OFFSET			0x010
+#define SD_RSP1_OFFSET			0x014
+#define SD_RSP2_OFFSET			0x018
+#define SD_RSP3_OFFSET			0x01C
+#define SD_DATA_OFFSET			0x020
+#define SD_STA_OFFSET			0x024
+#define SD_HOST_OFFSET			0x028	/* Byte */
+#define SD_PWR_OFFSET			0x029	/* Byte */
+#define SD_GAP_OFFSET			0x02A	/* Byte */
+#define SD_WAK_OFFSET			0x02B	/* Byte */
+#define SD_CLK_OFFSET			0x02C	/* Half word */
+#define SD_TMO_OFFSET			0x02E	/* Byte */
+#define SD_RESET_OFFSET			0x02F	/* Byte */
+#define SD_NIS_OFFSET			0x030	/* Half word */
+#define SD_EIS_OFFSET			0x032	/* Half word */
+#define SD_NISEN_OFFSET			0x034	/* Half word */
+#define SD_EISEN_OFFSET			0x036	/* Half word */
+#define SD_NIXEN_OFFSET			0x038	/* Half word */
+#define SD_EIXEN_OFFSET			0x03A	/* Half word */
+#define SD_AC12ES_OFFSET		0x03C	/* Half word */
+#define SD_HOST2_OFFSET			0x03E	/* Half word */
+#define SD_CAP_OFFSET			0x040
+#define SD_CUR_OFFSET			0x048
+#define SD_ADMA_STA_OFFSET		0x054
+#define SD_ADMA_ADDR_OFFSET		0x058
+#define SD_XC_CTR_OFFSET		0x060
+#define SD_BOOT_CTR_OFFSET		0x070
+#define SD_BOOT_STA_OFFSET		0x074
+#define SD_VOL_SW_OFFSET		0x07C
+#define SD_DELAY_SEL_L			0x0D8
+#define SD_DELAY_SEL_H			0x0DC
+#define SD_LAT_CTRL_OFFSET		0x0F8
+#define SD_SIST_OFFSET			0x0FC	/* Half word */
+#define SD_VER_OFFSET			0x0FE	/* Half word */
+
+/* SD_BLK_SZ_REG */
+#define SD_BLK_SZ_4KB			0x0000
+#define SD_BLK_SZ_8KB			0x1000
+#define SD_BLK_SZ_16KB			0x2000
+#define SD_BLK_SZ_32KB			0x3000
+#define SD_BLK_SZ_64KB			0x4000
+#define SD_BLK_SZ_128KB			0x5000
+#define SD_BLK_SZ_256KB			0x6000
+#define SD_BLK_SZ_512KB			0x7000
+
+/* SD_XFR_REG */
+#define SD_XFR_MUL_SEL			0x0020
+#define SD_XFR_SGL_SEL			0x0000
+#define SD_XFR_CTH_SEL			0x0010
+#define SD_XFR_HTC_SEL			0x0000
+#define SD_XFR_AC12_EN			0x0004
+#define SD_XFR_BLKCNT_EN		0x0002
+#define SD_XFR_DMA_EN			0x0001
+
+/* SD_CMD_REG */
+#define SD_CMD_IDX(x)			((x) << 8)
+#define SD_CMD_NORMAL			0x00000000
+#define SD_CMD_SUSPEND			0x00000040
+#define SD_CMD_RESUME			0x00000080
+#define SD_CMD_ABORT			0x000000C0
+#define SD_CMD_DATA			0x00000020
+#define SD_CMD_CHKIDX			0x00000010
+#define SD_CMD_CHKCRC			0x00000008
+#define SD_CMD_RSP_NONE			0x00000000
+#define SD_CMD_RSP_136			0x00000001
+#define SD_CMD_RSP_48			0x00000002
+#define SD_CMD_RSP_48BUSY		0x00000003
+
+/* SD_STA_REG */
+#define SD_STA_DAT_LSL(x)		((((x) & 0x1e000000) >> 25) | \
+					 (((x) & 0x00f00000) >> 20))
+#define SD_STA_CMD_LSL(x)		(((x)  & 0x01000000) >> 24)
+#define SD_STA_WPS_PL			0x00080000
+#define SD_STA_CDP_L			0x00040000
+#define SD_STA_CSS			0x00020000
+#define SD_STA_CARD_INSERTED		0x00010000
+#define SD_STA_BUFFER_READ_EN		0x00000800
+#define SD_STA_BUFFER_WRITE_EN		0x00000400
+#define SD_STA_READ_XFR_ACTIVE		0x00000200
+#define SD_STA_WRITE_XFR_ACTIVE		0x00000100
+#define SD_STA_DAT_ACTIVE		0x00000004
+#define SD_STA_CMD_INHIBIT_DAT		0x00000002
+#define SD_STA_CMD_INHIBIT_CMD		0x00000001
+
+/* SD_HOST_REG */
+#define SD_HOST_ADMA			0x10
+#define SD_HOST_8BIT			0x08
+#define SD_HOST_HIGH_SPEED		0x04
+#define SD_HOST_4BIT			0x02
+#define SD_HOST_LED_ON			0x01
+
+/* SD_PWR_REG only care about bit[3] */
+#define SD_PWR_3_3V			0x08
+#define SD_PWR_3_0V			0x08
+#define SD_PWR_1_8V			0x00
+
+#define SD_PWR_ON			0x01
+#define SD_PWR_OFF			0x00
+
+/* SD_GAP_REG */
+#define SD_GAP_INT_AT_GAP		0x08
+#define SD_GAP_READ_WAIT		0x04
+#define SD_GAP_CONT_REQ			0x02
+#define SD_GAP_STOP_AT_GAP		0x01
+
+/* SD_WAK_REG */
+#define SD_WAK_ON_CARD_RMV		0x04
+#define SD_WAK_ON_CARD_IST		0x02
+#define SD_WAK_ON_CARD_INT		0x01
+
+/* SD_CLK_REG */
+#define SD_CLK_DIV_256			0x8000
+#define SD_CLK_DIV_128			0x4000
+#define SD_CLK_DIV_64			0x2000
+#define SD_CLK_DIV_32			0x1000
+#define SD_CLK_DIV_16			0x0800
+#define SD_CLK_DIV_8			0x0400
+#define SD_CLK_DIV_4			0x0200
+#define SD_CLK_DIV_2			0x0100
+#define SD_CLK_DIV_1			0x0000
+#define SD_CLK_EN			0x0004
+#define SD_CLK_ICLK_STABLE		0x0002
+#define SD_CLK_ICLK_EN			0x0001
+
+/* SD_TMO_REG */
+
+/* SD_RESET_REG */
+#define SD_RESET_DAT			0x04
+#define SD_RESET_CMD			0x02
+#define SD_RESET_ALL			0x01
+
+/* SD_NIS_REG */
+#define SD_NIS_ERROR			0x8000
+#define SD_NIS_CARD			0x0100
+#define SD_NIS_REMOVAL			0x0080
+#define SD_NIS_INSERT			0x0040
+#define SD_NIS_READ_READY		0x0020
+#define SD_NIS_WRITE_READY		0x0010
+#define SD_NIS_DMA			0x0008
+#define SD_NIS_BLOCK_GAP		0x0004
+#define SD_NIS_XFR_DONE			0x0002
+#define SD_NIS_CMD_DONE			0x0001
+
+/* SD_EIS_REG */
+#define SD_EIS_ADMA_ERR			0x0200
+#define SD_EIS_ACMD12_ERR		0x0100
+#define SD_EIS_CURRENT_ERR		0x0080
+#define SD_EIS_DATA_BIT_ERR		0x0040
+#define SD_EIS_DATA_CRC_ERR		0x0020
+#define SD_EIS_DATA_TMOUT_ERR		0x0010
+#define SD_EIS_CMD_IDX_ERR		0x0008
+#define SD_EIS_CMD_BIT_ERR		0x0004
+#define SD_EIS_CMD_CRC_ERR		0x0002
+#define SD_EIS_CMD_TMOUT_ERR		0x0001
+
+/* SD_NISEN_REG */
+#define SD_NISEN_CARD			0x0100
+#define SD_NISEN_REMOVAL		0x0080
+#define SD_NISEN_INSERT			0x0040
+#define SD_NISEN_READ_READY		0x0020
+#define SD_NISEN_WRITE_READY		0x0010
+#define SD_NISEN_DMA			0x0008
+#define SD_NISEN_BLOCK_GAP		0x0004
+#define SD_NISEN_XFR_DONE		0x0002
+#define SD_NISEN_CMD_DONE		0x0001
+
+/* SD_EISEN_REG */
+#define SD_EISEN_ADMA_ERR		0x0200
+#define SD_EISEN_ACMD12_ERR		0x0100
+#define SD_EISEN_CURRENT_ERR		0x0080
+#define SD_EISEN_DATA_BIT_ERR		0x0040
+#define SD_EISEN_DATA_CRC_ERR		0x0020
+#define SD_EISEN_DATA_TMOUT_ERR		0x0010
+#define SD_EISEN_CMD_IDX_ERR		0x0008
+#define SD_EISEN_CMD_BIT_ERR		0x0004
+#define SD_EISEN_CMD_CRC_ERR		0x0002
+#define SD_EISEN_CMD_TMOUT_ERR		0x0001
+
+/* SD_NIXEN_REG */
+#define SD_NIXEN_CARD			0x0100
+#define SD_NIXEN_REMOVAL		0x0080
+#define SD_NIXEN_INSERT			0x0040
+#define SD_NIXEN_READ_READY		0x0020
+#define SD_NIXEN_WRITE_READY		0x0010
+#define SD_NIXEN_DMA			0x0008
+#define SD_NIXEN_BLOCK_GAP		0x0004
+#define SD_NIXEN_XFR_DONE		0x0002
+#define SD_NIXEN_CMD_DONE		0x0001
+
+/* SD_EIXEN_REG */
+#define SD_EIXEN_ADMA_ERR		0x0200
+#define SD_EIXEN_ACMD12_ERR		0x0100
+#define SD_EIXEN_CURRENT_ERR		0x0080
+#define SD_EIXEN_DATA_BIT_ERR		0x0040
+#define SD_EIXEN_DATA_CRC_ERR		0x0020
+#define SD_EIXEN_DATA_TMOUT_ERR		0x0010
+#define SD_EIXEN_CMD_IDX_ERR		0x0008
+#define SD_EIXEN_CMD_BIT_ERR		0x0004
+#define SD_EIXEN_CMD_CRC_ERR		0x0002
+#define SD_EIXEN_CMD_TMOUT_ERR		0x0001
+
+/* SD_AC12ES_REG */
+#define SD_AC12ES_NOT_ISSUED		0x0080
+#define SD_AC12ES_INDEX			0x0010
+#define SD_AC12ES_END_BIT		0x0008
+#define SD_AC12ES_CRC_ERROR		0x0004
+#define SD_AC12ES_TMOUT_ERROR		0x0002
+#define SD_AC12ES_NOT_EXECED		0x0001
+
+/* SD_ADMA_STA_REG */
+#define SD_ADMA_STA_ST_STOP		0x00000000
+#define SD_ADMA_STA_ST_FDS		0x00000001
+#define SD_ADMA_STA_ST_TFR		0x00000003
+#define SD_ADMA_STA_LEN_ERR		0x00000004
+
+/* SD_CAP_REG */
+#define SD_CAP_INTMODE			0x08000000
+#define SD_CAP_VOL_1_8V			0x04000000
+#define SD_CAP_VOL_3_0V			0x02000000
+#define SD_CAP_VOL_3_3V			0x01000000
+#define SD_CAP_SUS_RES			0x00800000
+#define SD_CAP_DMA			0x00400000
+#define SD_CAP_HIGH_SPEED		0x00200000
+#define SD_CAP_ADMA_SUPPORT		0x00080000
+#define SD_CAP_MAX_512B_BLK		0x00000000
+#define SD_CAP_MAX_1KB_BLK		0x00010000
+#define SD_CAP_MAX_2KB_BLK		0x00020000
+#define SD_CAP_BASE_FREQ(x)		(((x) & 0x3f00) >> 8)
+#define SD_CAP_TOCLK_KHZ		0x00000000
+#define SD_CAP_TOCLK_MHZ		0x00000080
+#define SD_CAP_TOCLK_FREQ(x)		(((x) & 0x3f))
+
+/* SD_XC_CTR_REG */
+#define SD_XC_CTR_DDR_EN		0x00008000
+#define SD_XC_CTR_VOL_1_8V		0x00000001
+#define SD_XC_CTR_VOL_3_3V		0x00000000
+
+/* SD_BOOT_CTR_REG */
+#define SD_BOOT_CTR_RST_EN		0x00010000
+
+/* SD_BOOT_STA_REG */
+#define SD_BOOT_STA_END_ALT		0x01010000
+#define SD_BOOT_STA_BOOT_RDY		0x00000001
+
+/* SD_VOL_SW_REG */
+#define SD_VOL_SW_CMD_STAT_H		0x00010000
+#define SD_VOL_SW_DAT_STAT_H		0x00000007
+
+/* SD_VER_REG */
+#define SD_VER_VENDOR(x)		((x) >> 8)
+#define SD_VER_SPEC(x)			((x) & 0xf)
+
+#define SD_ADMA_TBL_LINE_SIZE		(8)
+#define SD_ADMA_TBL_LINE_MAX_LEN	(0x40000)
+#define SD_ADMA_TBL_ATTR_NOP		(0x0000)
+#define SD_ADMA_TBL_ATTR_RSV		(0x0010)
+#define SD_ADMA_TBL_ATTR_TRAN		(0x0020)
+#define SD_ADMA_TBL_ATTR_LINK		(0x0030)
+#define SD_ADMA_TBL_ATTR_WORD		(0x0008)
+#define SD_ADMA_TBL_ATTR_INT		(0x0004)
+#define SD_ADMA_TBL_ATTR_END		(0x0002)
+#define SD_ADMA_TBL_ATTR_VALID		(0x0001)
+
+/* ==========================================================================*/
+#define SMIO_2				GPIO(64)
+#define SMIO_3				GPIO(65)
+#define SMIO_4				GPIO(66)
+#define SMIO_5				GPIO(67)
+#define SD1_CD				GPIO(67)
+#define SMIO_6				GPIO(68)
+#define SMIO_38				GPIO(69)
+#define SMIO_39				GPIO(70)
+#define SMIO_40				GPIO(71)
+#define SMIO_41				GPIO(72)
+#define SMIO_42				GPIO(73)
+#define SMIO_43				GPIO(74)
+#define SMIO_44				GPIO(75)
+#define SMIO_45				GPIO(76)
+
+/* ==========================================================================*/
+#define sd_slot_is_valid(slot)		((SD_SUPPORT_SDXC == 1) && ((slot) == 2) ? 1 : \
+					(SD_SUPPORT_SDIO == 1) && ((slot) == 1) ? 1 : \
+					((slot) == 0) ? 1 : 0)
+
 /* ==========================================================================*/
 #ifndef __ASM__
-/* ==========================================================================*/
-
-extern int amboot_bsp_sd_slot_init(int slot, int volt) __attribute__ ((weak));
-extern int amboot_bsp_sd_phy_init(int slot, int mode) __attribute__ ((weak));
-
 /* ==========================================================================*/
-#endif
+
+#if (CHIP_REV == S2L)
+#define MINIPIN_EMMC_ALTFUNC		2
+#define MINIPIN_EMMC_PIN		{57, 58, 59, 60, 73, 74, 75, 76, \
+					 77, 78, 79, 80}
+#elif (CHIP_REV == S3)
+#define MINIPIN_EMMC_ALTFUNC		2
+#define MINIPIN_EMMC_PIN		{118, 119, 120, 121, 134, 135, 136, \
+					 137, 138, 139, 140, 141, 154}
+#elif (CHIP_REV == S3L)
+#define MINIPIN_EMMC_ALTFUNC		2
+#define MINIPIN_EMMC_PIN		{58, 59, 60, 61, 74, 75, 76, 77, \
+					 78, 79, 80, 81, 94}
+#elif (CHIP_REV == S5)
+#define MINIPIN_EMMC_ALTFUNC		2
+#define MINIPIN_EMMC_PIN		{59, 60, 61, 62, 75, 76, 77, 78, \
+					 79, 80, 81, 82, 95}
+#elif (CHIP_REV == S5L)
+#define MINIPIN_EMMC_ALTFUNC		2
+#define MINIPIN_EMMC_PIN		{75, 76, 77, 78, 91, 92, 93, 94, \
+					 95, 96, 97, 98, 111}
+#elif (CHIP_REV == CV1)
+#define MINIPIN_EMMC_ALTFUNC		2
+#define MINIPIN_EMMC_PIN		{89, 90, 91, 92, 105, 106, 107, 108, \
+					 109, 110, 111, 112, 125}
+#else
+#error "MINIPIN emmc: not defined!"
+#endif
+
+extern int amboot_bsp_sd_slot_init(int slot, int volt) __attribute__ ((weak));
+extern int amboot_bsp_sd_phy_init(int slot, int mode) __attribute__ ((weak));
+
+/* ==========================================================================*/
+#endif
 /* ==========================================================================*/
-
-#endif
-
+
+#endif
+
diff --git a/include/ambhw/spi.h b/include/ambhw/spi.h
index 4531759..7508e23 100644
--- a/include/ambhw/spi.h
+++ b/include/ambhw/spi.h
@@ -1,212 +1,183 @@
-/*
- * ambhw/spi.h
- *
- * History:
- *	2006/12/27 - [Charles Chiou] created file
- *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+/*
+ * ambhw/spi.h
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
- */
-
-#ifndef __AMBHW__SPI_H__
-#define __AMBHW__SPI_H__
-
-/* ==========================================================================*/
-#if (CHIP_REV == A5S)
-#define SPI_INSTANCES				2
-#define SPI_AHB_INSTANCES			0
-#define SPI_SLAVE_INSTANCES			1
-#define SPI_AHB_SLAVE_INSTANCES			0
-#elif (CHIP_REV == S2)
-#define SPI_INSTANCES				1
-#define SPI_AHB_INSTANCES			0
-#define SPI_SLAVE_INSTANCES			1
-#define SPI_AHB_SLAVE_INSTANCES			0
-#elif (CHIP_REV == S2E)
-#define SPI_INSTANCES				2
-#define SPI_AHB_INSTANCES			0
-#define SPI_SLAVE_INSTANCES			1
-#define SPI_AHB_SLAVE_INSTANCES			0
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define SPI_INSTANCES				0
-#define SPI_AHB_INSTANCES			2
-#define SPI_SLAVE_INSTANCES			0
-#define SPI_AHB_SLAVE_INSTANCES			1
-#elif (CHIP_REV == A7L)
-#define SPI_INSTANCES				1
-#define SPI_AHB_INSTANCES			0
-#define SPI_SLAVE_INSTANCES			1
-#define SPI_AHB_SLAVE_INSTANCES			0
-#else
-#define SPI_INSTANCES				1
-#define SPI_AHB_INSTANCES			0
-#define SPI_SLAVE_INSTANCES			0
-#define SPI_AHB_SLAVE_INSTANCES			0
-#endif
-
-#if (CHIP_REV == A5S)
-#define SPI_SUPPORT_MASTER_CHANGE_ENA_POLARITY	0
-#define SPI_SUPPORT_MASTER_DELAY_START_TIME	0
-#define SPI_SUPPORT_NSM_SHAKE_START_BIT_CHSANGE	0
-#else
-#define SPI_SUPPORT_MASTER_CHANGE_ENA_POLARITY	1
-#define SPI_SUPPORT_MASTER_DELAY_START_TIME	1 // S2L only support ssi0, remember to fix it
-#define SPI_SUPPORT_NSM_SHAKE_START_BIT_CHSANGE	1 // S2 and S2L is not explain this in PRM
-#endif
-
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define SPI_TARGET_FRAME	1
-#else
-#define SPI_TARGET_FRAME	0
-#endif
-
-/* ==========================================================================*/
-#if (SPI_INSTANCES >= 1)
-#define SPI_OFFSET			0x2000
-#define SPI_BASE			(APB_BASE + SPI_OFFSET)
-#define SPI_REG(x)			(SPI_BASE + (x))
-#endif
-
-#if (SPI_SLAVE_INSTANCES >= 1)
-#if (CHIP_REV == A7L)
-#define SPI_SLAVE_OFFSET		0x1000
-#else
-#define SPI_SLAVE_OFFSET		0x1E000
-#endif
-#define SPI_SLAVE_BASE			(APB_BASE + SPI_SLAVE_OFFSET)
-#define SPI_SLAVE_REG(x)		(SPI_SLAVE_BASE + (x))
-#endif
-
-#if (SPI_INSTANCES >= 2)
-#define SPI2_OFFSET			0xF000
-#define SPI2_BASE			(APB_BASE + SPI2_OFFSET)
-#define SPI2_REG(x)			(SPI2_BASE + (x))
-#endif
-
-#if (SPI_INSTANCES >= 3)
-#define SPI3_OFFSET			0x15000
-#define SPI3_BASE			(APB_BASE + SPI3_OFFSET)
-#define SPI3_REG(x)			(SPI3_BASE + (x))
-#endif
-
-#if (SPI_INSTANCES >= 4)
-#define SPI4_OFFSET			0x16000
-#define SPI4_BASE			(APB_BASE + SPI4_OFFSET)
-#define SPI4_REG(x)			(SPI4_BASE + (x))
-#endif
-
-#if (SPI_AHB_INSTANCES == 1)
-#define SSI_DMA_OFFSET			0xD000
-#define SSI_DMA_BASE			(AHB_BASE + SSI_DMA_OFFSET)
-#define SSI_DMA_REG(x)			(SSI_DMA_BASE + (x))
-#endif
-
-#if (SPI_AHB_INSTANCES == 2)
-#define SPI_OFFSET			0x20000
-#define SPI_BASE			(AHB_BASE + SPI_OFFSET)
-#define SPI_REG(x)			(SPI_BASE + (x))
-
-#define SPI2_OFFSET			0x21000
-#define SPI2_BASE			(AHB_BASE + SPI2_OFFSET)
-#define SPI2_REG(x)			(SPI2_BASE + (x))
-#endif
-
-#if (SPI_AHB_SLAVE_INSTANCES >= 1)
-#define SPI_AHB_SLAVE_OFFSET		0x26000
-#define SPI_AHB_SLAVE_BASE		(AHB_BASE + SPI_AHB_SLAVE_OFFSET)
-#define SPI_AHB_SLAVE_REG(x)		(SPI_AHB_SLAVE_BASE + (x))
-#endif
-
-#define SPI_MASTER_INSTANCES		(SPI_INSTANCES + SPI_AHB_INSTANCES)
-
-
-/* ==========================================================================*/
-/* SPI_FIFO_SIZE */
-#define SPI_DATA_FIFO_SIZE_16		0x10
-#define SPI_DATA_FIFO_SIZE_32		0x20
-#define SPI_DATA_FIFO_SIZE_64		0x40
-#define SPI_DATA_FIFO_SIZE_128		0x80
-
-/****************************************************/
-/* Controller registers definitions                 */
-/****************************************************/
-
-#define SPI_CTRLR0_OFFSET		0x00
-#define SPI_CTRLR1_OFFSET		0x04
-#define SPI_SSIENR_OFFSET		0x08
-#define SPI_MWCR_OFFSET			0x0c // no PRM explain it and no code use it. should be commented after check
-#define SPI_SER_OFFSET			0x10
-#define SPI_BAUDR_OFFSET		0x14
-#define SPI_TXFTLR_OFFSET		0x18
-#define SPI_RXFTLR_OFFSET		0x1c
-#define SPI_TXFLR_OFFSET		0x20
-#define SPI_RXFLR_OFFSET		0x24
-#define SPI_SR_OFFSET			0x28
-#define SPI_IMR_OFFSET			0x2c
-#define SPI_ISR_OFFSET			0x30
-#define SPI_RISR_OFFSET			0x34
-#define SPI_TXOICR_OFFSET		0x38
-#define SPI_RXOICR_OFFSET		0x3c
-#define SPI_RXUICR_OFFSET		0x40
-#define SPI_MSTICR_OFFSET		0x44
-#define SPI_ICR_OFFSET			0x48
-#define SPI_DMAC_OFFSET			0x4c
-#define SPI_IDR_OFFSET			0x58
-#define SPI_VERSION_ID_OFFSET		0x5c
-#define SPI_DR_OFFSET			0x60
-
-#if (SPI_SUPPORT_MASTER_CHANGE_ENA_POLARITY == 1)
-#define SPI_SSIENPOLR_OFFSET		0x260
-#endif
-#if (SPI_SUPPORT_MASTER_DELAY_START_TIME == 1)
-#define SPI_SCLK_OUT_DLY_OFFSET		0x264
-#endif
-#if (SPI_SUPPORT_NSM_SHAKE_START_BIT_CHSANGE == 1)
-#define SPI_START_BIT_OFFSET		0x268
-#endif
-
-#if (SPI_TARGET_FRAME == 1)
-#define SPI_TARGET_FRAME_COUNT	0x27c
-#define SPI_FRAME_COUNT			0x280
-#define SPI_FCRICR				0x284
-#define SPI_TX_FRAME_COUNT		0x288
-#endif
-/* ==========================================================================*/
-/* SPI rw mode */
-#define SPI_WRITE_READ		0
-#define SPI_WRITE_ONLY		1
-#define SPI_READ_ONLY		2
-
-/* Tx FIFO empty interrupt mask */
-#define SPI_TXEIS_MASK		0x00000001
-#define SPI_TXOIS_MASK 		0x00000002
-#define SPI_RXFIS_MASK 		0x00000010
-#define SPI_FCRIS_MASK 		0x00000100
-
-/* SPI Parameters */
-#define SPI_DUMMY_DATA		0xffff
-#define MAX_QUERY_TIMES		10
-
-/* Default SPI settings */
-#define SPI_MODE		SPI_MODE_0
-#define SPI_SCPOL		0
-#define SPI_SCPH		0
-#define SPI_FRF			0
-#define SPI_CFS			0x0
-#define SPI_DFS			0xf
-#define SPI_BAUD_RATE		200000
-
+ * History:
+ *	2006/12/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBHW__SPI_H__
+#define __AMBHW__SPI_H__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+#if (CHIP_REV == S5L)
+#define SPI_AHB_INSTANCES			3
+#define SPI_AHB_SLAVE_INSTANCES			1
+#elif (CHIP_REV == CV1)
+#define SPI_AHB_INSTANCES			6
+#define SPI_AHB_SLAVE_INSTANCES			1
+#else
+#define SPI_AHB_INSTANCES			2
+#define SPI_AHB_SLAVE_INSTANCES			1
+#endif
+
+#if (CHIP_REV == S2L) || (CHIP_REV == S3L) || (CHIP_REV == S3) || \
+	(CHIP_REV == S5) || (CHIP_REV == S5L)
+#define SPI0_OFFSET			0x20000
+#define SPI1_OFFSET			0x21000
+#define SPI2_OFFSET			0x22000
+#define SPI_SLAVE_OFFSET		0x26000
+#else
+#define SPI0_OFFSET			0x11000
+#define SPI1_OFFSET			0x12000
+#define SPI2_OFFSET			0x13000
+#define SPI3_OFFSET			0x14000
+#define SPI4_OFFSET			0x15000
+#define SPI5_OFFSET			0x1C000
+#define SPI_SLAVE_OFFSET		0x10000
+#endif
+
+#define SPI0_BASE			(AHB_N_BASE + SPI0_OFFSET)
+#define SPI1_BASE			(AHB_N_BASE + SPI1_OFFSET)
+#define SPI2_BASE			(AHB_N_BASE + SPI2_OFFSET)
+#define SPI3_BASE			(AHB_N_BASE + SPI3_OFFSET)
+#define SPI4_BASE			(AHB_N_BASE + SPI4_OFFSET)
+#define SPI5_BASE			(AHB_N_BASE + SPI5_OFFSET)
+#define SPI_SLAVE_BASE			(AHB_N_BASE + SPI_SLAVE_OFFSET)
+#define SPI0_REG(x)			(SPI0_BASE + (x))
+#define SPI1_REG(x)			(SPI1_BASE + (x))
+#define SPI2_REG(x)			(SPI2_BASE + (x))
+#define SPI3_REG(x)			(SPI3_BASE + (x))
+#define SPI4_REG(x)			(SPI4_BASE + (x))
+#define SPI5_REG(x)			(SPI5_BASE + (x))
+#define SPI_SLAVE_REG(x)		(SPI_SLAVE_BASE + (x))
+
 /* ==========================================================================*/
+#define SPI_MASTER1			0
+#define SPI_MASTER2			1
+#define SPI_MASTER3			2
+
+/* ==========================================================================*/
+/* SPI_FIFO_SIZE */
+#define SPI_DATA_FIFO_SIZE_16		0x10
+#define SPI_DATA_FIFO_SIZE_32		0x20
+#define SPI_DATA_FIFO_SIZE_64		0x40
+#define SPI_DATA_FIFO_SIZE_128		0x80
+
+/****************************************************/
+/* Controller registers definitions                 */
+/****************************************************/
+
+#define SPI_CTRLR0_OFFSET		0x00
+#define SPI_CTRLR1_OFFSET		0x04
+#define SPI_SSIENR_OFFSET		0x08
+#define SPI_MWCR_OFFSET			0x0c // no PRM explain it and no code use it. should be commented after check
+#define SPI_SER_OFFSET			0x10
+#define SPI_BAUDR_OFFSET		0x14
+#define SPI_TXFTLR_OFFSET		0x18
+#define SPI_RXFTLR_OFFSET		0x1c
+#define SPI_TXFLR_OFFSET		0x20
+#define SPI_RXFLR_OFFSET		0x24
+#define SPI_SR_OFFSET			0x28
+#define SPI_IMR_OFFSET			0x2c
+#define SPI_ISR_OFFSET			0x30
+#define SPI_RISR_OFFSET			0x34
+#define SPI_TXOICR_OFFSET		0x38
+#define SPI_RXOICR_OFFSET		0x3c
+#define SPI_RXUICR_OFFSET		0x40
+#define SPI_MSTICR_OFFSET		0x44
+#define SPI_ICR_OFFSET			0x48
+#define SPI_DMAC_OFFSET			0x4c
+#define SPI_IDR_OFFSET			0x58
+#define SPI_VERSION_ID_OFFSET		0x5c
+#define SPI_DR_OFFSET			0x60
+
+#define SPI_SSIENPOLR_OFFSET		0x260
+#define SPI_SCLK_OUT_DLY_OFFSET		0x264
+#define SPI_START_BIT_OFFSET		0x268
+
+/* ==========================================================================*/
+/* SPI rw mode */
+#define SPI_WRITE_READ		0
+#define SPI_WRITE_ONLY		1
+#define SPI_READ_ONLY		2
+
+/* Tx FIFO empty interrupt mask */
+#define SPI_TXEIS_MASK		0x00000001
+#define SPI_TXOIS_MASK 		0x00000002
+#define SPI_RXFIS_MASK 		0x00000010
+#define SPI_FCRIS_MASK 		0x00000100
+
+/* SPI Parameters */
+#define SPI_DUMMY_DATA		0xffff
+#define MAX_QUERY_TIMES		10
+#define SPI_POLLING_MAX_WAIT_LOOP 5000000
+
+/* Default SPI settings */
+#define SPI_SCPOL		0
+#define SPI_SCPH		0
+#define SPI_FRF			0
+#define SPI_CFS			0x0
+#define SPI_DFS			0xf
+#define SPI_BAUD_RATE		200000
+
+/* ==========================================================================*/
+typedef struct ambarella_spi_cfg_info {
+	u8	spi_mode;
+	u8	cfs_dfs;
+	u8	cs_gpio;
+	u8	cs_change;
+	u32	baud_rate;
+} amba_spi_cfg_t;
+
+#define SPI_CPHA		0x01
+#define SPI_CPOL		0x02
+
+#define SPI_MODE_0		(0|0)
+#define SPI_MODE_1		(0|SPI_CPHA)
+#define SPI_MODE_2		(SPI_CPOL|0)
+#define SPI_MODE_3		(SPI_CPOL|SPI_CPHA)
+
+#define SPI_CS_HIGH		0x04
+#define SPI_LSB_FIRST	0x08
+/* ==========================================================================*/
+
 #ifndef __ASM__
-/* ==========================================================================*/
-
 /* ==========================================================================*/
-#endif
+extern void spi_bld_init(u8 spi_id, amba_spi_cfg_t *spi_cfg);
+extern int spi_bld_write(u8 spi_id, u8 *tx_buf, int tx_len);
+extern int spi_bld_read(u8 spi_id, u8 *rx_buf, int rx_len);
+extern int spi_bld_write_then_read(u8 spi_id, u8 *tx_buf, int tx_len, u8 *rx_buf, int rx_len);
+
+/* ==========================================================================*/
+#endif
 /* ==========================================================================*/
-
-#endif
-
+
+#endif
+
diff --git a/include/ambhw/spinor.h b/include/ambhw/spinor.h
index 3d32a49..7249d00 100644
--- a/include/ambhw/spinor.h
+++ b/include/ambhw/spinor.h
@@ -1,26 +1,48 @@
 /**
- * system/include/flash/spinor.h
+ * ambhw/spinor.h
  *
  * History:
  *    2014/05/05 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __SPINOR_H__
 #define __SPINOR_H__
 
-#if (CHIP_REV == S2E)
-#define SPINOR_OFFSET			0xD000
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+
+#if (CHIP_REV == CV1)
+#define SPINOR_OFFSET			0x1000
 #else
 #define SPINOR_OFFSET			0x31000
 #endif
-#define SPINOR_BASE			(AHB_BASE + SPINOR_OFFSET)
+#define SPINOR_BASE			(AHB_N_BASE + SPINOR_OFFSET)
 #define SPINOR_REG(x)			(SPINOR_BASE + (x))
 
 #define SPINOR_LENGTH_OFFSET		0x00
@@ -136,20 +158,84 @@
 #define SPINOR_MAX_DATA_LENGTH		0x3ffff0
 #define SPINOR_OPERATION_TIMEOUT	5000
 
+#ifndef __ASM__
+/* ==========================================================================*/
+
+#if (CHIP_REV == S2L)
+#define MINIPIN_SPINOR_ALTFUNC		3
+#define MINIPIN_SPINOR_PIN		{55, 56, 61, 62, 63, 64, 65, 66, \
+					 67, 68, 69, 70, 71, 72}
+#elif (CHIP_REV == S3)
+#define MINIPIN_SPINOR_ALTFUNC		3
+#define MINIPIN_SPINOR_PIN		{55, 56, 61, 62, 63, 64, 65, 66, \
+					 67, 68, 69, 70, 71, 72}
+#elif (CHIP_REV == S3L)
+#define MINIPIN_SPINOR_ALTFUNC		3
+#define MINIPIN_SPINOR_PIN		{56, 57, 62, 63, 64, 65, 66, 67, \
+					 68, 69, 70, 71, 72}
+#elif (CHIP_REV == S5)
+#define MINIPIN_SPINOR_ALTFUNC		3
+#define MINIPIN_SPINOR_PIN		{57, 58, 63, 64, 65, 66, 67, 68, \
+					 69, 70, 71, 72, 73}
+#elif (CHIP_REV == S5L)
+#define MINIPIN_SPINOR_ALTFUNC		3
+#define MINIPIN_SPINOR_PIN		{73, 74, 79, 80, 81, 82, 83, 84, \
+					 85, 86, 87, 88, 89}
+#elif (CHIP_REV == CV1)
+#define MINIPIN_SPINOR_ALTFUNC		3
+#define MINIPIN_SPINOR_PIN		{87, 88, 93, 94, 95, 96, 97, 98, \
+					 99, 100, 101, 102, 103}
+#else
+#error "MINIPIN spinor: not defined!"
+#endif
+
+#if defined(CONFIG_AMBOOT_ENABLE_SPINOR)
 extern int spinor_init(void);
 extern int spinor_send_alone_cmd(u8 cmd_id);
 extern int spinor_read_reg(u8 cmd_id, void *buf, u8 len);
 extern int spinor_write_reg(u8 cmd_id, void *buf, u8 len);
 extern int spinor_erase_sector(u32 sector);
-extern int (*spinor_read_data)(u32 address, void *buf, int len);
 extern int spinor_write_data(u32 address, void *buf, int len);
 extern int spinor_write_boot_header(void);
 
 
 /* customised function implemented by each spi nor flash */
-extern int spinor_flash_reset(void);
-extern int spinor_flash_4b_mode(void);
+extern void spinor_flash_reset(void);
 extern int spinor_erase_chip(void);
+#elif defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+extern int spinand_wait_till_ready();
+extern int spinand_init(void);
+extern int spinor_send_alone_cmd(u8 cmd_id);
+extern int spinor_read_reg(u8 cmd_id, void *buf, u8 len);
+extern int spinor_write_reg(u8 cmd_id, void *buf, u8 len);
+extern int spinand_erase_block(u32 block_id);
+/* customised function implemented by each spi nor flash */
+extern int spinand_flash_reset(void);
+extern int spinand_read_data(u8 *dst, u8 *src, int len);
+extern int spinand_read_page(u32 page, u32 offset, void *buf, int len, u32 enable_ecc);
+extern int spinand_read_spare(u32 block, u32 page, u32 pages, void *buf);
+extern int spinand_program_page(u32 page, u16 offset, void *buf, int len);
+extern int spinand_is_bad_block(u32 block);
+extern void spinand_output_bad_block(u32 block, int bb_type);
+extern int spinand_mark_bad_block(u32 block);
+extern int spinand_prog_pages(u32 block, u32 page, u32 pages,
+		void *wbuf);
+extern int spinand_read_pages(u32 block, u32 page, u32 pages,
+		void *rbuf, u32 enable_ecc);
+
+#if defined(CONFIG_SPINAND_USE_FLASH_BBT)
+extern int spinand_scan_bbt(int verbose);
+extern int spinand_update_bbt(u32 bblock, u32 gblock);
+extern int spinand_erase_bbt(void);
+extern int spinand_isbad_bbt(u32 block);
+extern int spinand_show_bbt(void);
+extern int spinand_has_bbt(void);
+#endif
 
+/* ==========================================================================*/
 #endif
+/* ==========================================================================*/
 
+#endif
+
+#endif
diff --git a/include/ambhw/timer.h b/include/ambhw/timer.h
index 8acad9d..32eae2d 100644
--- a/include/ambhw/timer.h
+++ b/include/ambhw/timer.h
@@ -4,30 +4,56 @@
  * History:
  *	2006/12/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __AMBHW__TIMER_H__
 #define __AMBHW__TIMER_H__
 
+#include <ambhw/chip.h>
+
 /* ==========================================================================*/
+#if (CHIP_REV == CV1)
+#define TIMER_OFFSET			0x5000
+#else
 #define TIMER_OFFSET			0xB000
-#define TIMER_BASE			(APB_BASE + TIMER_OFFSET)
+#endif
+#define TIMER_BASE			(APB_N_BASE + TIMER_OFFSET)
 #define TIMER_REG(x)			(TIMER_BASE + (x))
 
+#if (CHIP_REV == CV1)
+#define TIMER1_OFFSET			0x6000
+#else
 #define TIMER1_OFFSET			0xF000
-#define TIMER1_BASE			(APB_BASE + TIMER1_OFFSET)
+#endif
+#define TIMER1_BASE			(APB_N_BASE + TIMER1_OFFSET)
 #define TIMER1_REG(x)			(TIMER1_BASE + (x))
 
 /* ==========================================================================*/
-#if (CHIP_REV == A5S)
-#define INTERVAL_TIMER_INSTANCES		3
-#elif (CHIP_REV == S3)
+#if (CHIP_REV == S3) || (CHIP_REV == S5) || (CHIP_REV == CV1)
 #define INTERVAL_TIMER_INSTANCES		20
 #else
 #define INTERVAL_TIMER_INSTANCES		8
diff --git a/include/ambhw/uart.h b/include/ambhw/uart.h
index d2c99b7..0dd9280 100644
--- a/include/ambhw/uart.h
+++ b/include/ambhw/uart.h
@@ -1,170 +1,227 @@
-/*
- * ambhw/uart.h
- *
- * History:
- *	2006/12/27 - [Charles Chiou] created file
- *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+/*
+ * ambhw/uart.h
+ *
+ * History:
+ *	2006/12/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
-
-#ifndef __AMBHW__UART_H__
-#define __AMBHW__UART_H__
-
-/* ==========================================================================*/
-#if (CHIP_REV == A8) || (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define	UART_INSTANCES			4
-#else
-#define	UART_INSTANCES			2
-#endif
-
-/* ==========================================================================*/
-#define UART_OFFSET			0x5000
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define UART1_OFFSET			0x32000
-#else
-#define UART1_OFFSET			0x1F000
-#endif
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define UART2_OFFSET			0x14000
-#define UART3_OFFSET			0x15000
-#elif (CHIP_REV == A8)
-#define UART2_OFFSET			0x13000
-#define UART3_OFFSET			0x14000
-#endif
-
-#define UART0_BASE			(APB_BASE + UART_OFFSET)
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-#define UART1_BASE			(AHB_BASE + UART1_OFFSET)
-#else
-#define UART1_BASE			(APB_BASE + UART1_OFFSET)
-#endif
-#if (CHIP_REV == A8) || (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define UART2_BASE			(APB_BASE + UART2_OFFSET)
-#define UART3_BASE			(APB_BASE + UART3_OFFSET)
-#endif
-
-#define UART0_REG(x)			(UART0_BASE + (x))
-#define UART1_REG(x)			(UART1_BASE + (x))
-#if (CHIP_REV == A8) || (CHIP_REV == S2) || (CHIP_REV == S2E)
-#define UART2_REG(x)			(UART2_BASE + (x))
-#define UART3_REG(x)			(UART3_BASE + (x))
-#endif
-/* ==========================================================================*/
-#define UART_RB_OFFSET			0x00
-#define UART_TH_OFFSET			0x00
-#define UART_DLL_OFFSET			0x00
-#define UART_IE_OFFSET			0x04
-#define UART_DLH_OFFSET			0x04
-#define UART_II_OFFSET			0x08
-#define UART_FC_OFFSET			0x08
-#define UART_LC_OFFSET			0x0c
-#define UART_MC_OFFSET			0x10
-#define UART_LS_OFFSET			0x14
-#define UART_MS_OFFSET			0x18
-#define UART_SC_OFFSET			0x1c	/* Byte */
-#define UART_DMAE_OFFSET		0x28
-#define UART_DMAF_OFFSET		0x40	/* DMA fifo */
-#define UART_US_OFFSET			0x7c
-#define UART_TFL_OFFSET			0x80
-#define UART_RFL_OFFSET			0x84
-#define UART_SRR_OFFSET			0x88
-
-/* UART[x]_IE_REG */
-#define UART_IE_PTIME			0x80
-#define UART_IE_ETOI			0x20
-#define UART_IE_EBDI			0x10
-#define UART_IE_EDSSI			0x08
-#define UART_IE_ELSI			0x04
-#define UART_IE_ETBEI			0x02
-#define UART_IE_ERBFI			0x01
-
-/* UART[x]_II_REG */
-#define UART_II_MODEM_STATUS_CHANGED	0x00
-#define UART_II_NO_INT_PENDING		0x01
-#define UART_II_THR_EMPTY		0x02
-#define UART_II_RCV_DATA_AVAIL		0x04
-#define UART_II_RCV_STATUS		0x06
-#define UART_II_CHAR_TIMEOUT		0x0c
-
-/* UART[x]_FC_REG */
-#define UART_FC_RX_ONECHAR		0x00
-#define UART_FC_RX_QUARTER_FULL		0x40
-#define UART_FC_RX_HALF_FULL		0x80
-#define UART_FC_RX_2_TO_FULL		0xc0
-#define UART_FC_TX_EMPTY		0x00
-#define UART_FC_TX_2_IN_FIFO		0x10
-#define UART_FC_TX_QUATER_IN_FIFO	0x20
-#define UART_FC_TX_HALF_IN_FIFO		0x30
-#define UART_FC_XMITR			0x04
-#define UART_FC_RCVRR			0x02
-#define UART_FC_FIFOE			0x01
-
-/* UART[x]_LC_REG */
-#define UART_LC_DLAB			0x80
-#define UART_LC_BRK			0x40
-#define UART_LC_EVEN_PARITY		0x10
-#define UART_LC_ODD_PARITY		0x00
-#define UART_LC_PEN			0x08
-#define UART_LC_STOP_2BIT		0x04
-#define UART_LC_STOP_1BIT		0x00
-#define UART_LC_CLS_8_BITS		0x03
-#define UART_LC_CLS_7_BITS		0x02
-#define UART_LC_CLS_6_BITS		0x01
-#define UART_LC_CLS_5_BITS		0x00
-/*	quick defs */
-#define	UART_LC_8N1			0x03
-#define	UART_LC_7E1			0x0a
-
-/* UART[x]_MC_REG */
-#define UART_MC_SIRE			0x40
-#define UART_MC_AFCE			0x20
-#define UART_MC_LB			0x10
-#define UART_MC_OUT2			0x08
-#define UART_MC_OUT1			0x04
-#define UART_MC_RTS			0x02
-#define UART_MC_DTR			0x01
-
-/* UART[x]_LS_REG */
-#define UART_LS_FERR			0x80
-#define UART_LS_TEMT			0x40
-#define UART_LS_THRE			0x20
-#define UART_LS_BI			0x10
-#define UART_LS_FE			0x08
-#define UART_LS_PE			0x04
-#define UART_LS_OE			0x02
-#define UART_LS_DR			0x01
-
-/* UART[x]_MS_REG */
-#define UART_MS_DCD			0x80
-#define UART_MS_RI			0x40
-#define UART_MS_DSR			0x20
-#define UART_MS_CTS			0x10
-#define UART_MS_DDCD			0x08
-#define UART_MS_TERI			0x04
-#define UART_MS_DDSR			0x02
-#define UART_MS_DCTS			0x01
-
-/* UART[x]_US_REG */
-#define UART_US_RFF			0x10
-#define UART_US_RFNE			0x08
-#define UART_US_TFE			0x04
-#define UART_US_TFNF			0x02
-#define UART_US_BUSY			0x01
-
+
+#ifndef __AMBHW__UART_H__
+#define __AMBHW__UART_H__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+#if (CHIP_REV == S5L)
+#define	UART_INSTANCES			3
+#elif (CHIP_REV == CV1)
+#define	UART_INSTANCES			7
+#else
+#define	UART_INSTANCES			2
+#endif
+
+/* ==========================================================================*/
+#if (CHIP_REV == CV1)
+#define UART0_OFFSET			0x0000
+#else
+#define UART0_OFFSET			0x5000
+#endif
+
+#if (CHIP_REV == CV1)
+#define UART1_OFFSET			0x16000
+#else
+#define UART1_OFFSET			0x32000
+#endif
+
+#if (CHIP_REV == CV1)
+#define UART2_OFFSET			0x17000
+#else
+#define UART2_OFFSET			0x33000
+#endif
+
+#if (CHIP_REV == CV1)
+#define UART3_OFFSET			0x18000
+#else
+#define UART3_OFFSET			0x15000
+#endif
+
+#define UART4_OFFSET			0x19000
+#define UART5_OFFSET			0x1A000
+#define UART6_OFFSET			0x1B000
+
+#define UART0_BASE			(APB_N_BASE + UART0_OFFSET)
+#define UART1_BASE			(AHB_N_BASE + UART1_OFFSET)
+#define UART2_BASE			(AHB_N_BASE + UART2_OFFSET)
+#define UART3_BASE			(AHB_N_BASE + UART3_OFFSET)
+#define UART4_BASE			(AHB_N_BASE + UART4_OFFSET)
+#define UART5_BASE			(AHB_N_BASE + UART5_OFFSET)
+#define UART6_BASE			(AHB_N_BASE + UART6_OFFSET)
+
+#define UART0_REG(x)			(UART0_BASE + (x))
+#define UART1_REG(x)			(UART1_BASE + (x))
+#define UART2_REG(x)			(UART2_BASE + (x))
+#define UART3_REG(x)			(UART3_BASE + (x))
+#define UART4_REG(x)			(UART4_BASE + (x))
+#define UART5_REG(x)			(UART5_BASE + (x))
+#define UART6_REG(x)			(UART6_BASE + (x))
+
+/* ==========================================================================*/
+#define UART_RB_OFFSET			0x00
+#define UART_TH_OFFSET			0x00
+#define UART_DLL_OFFSET			0x00
+#define UART_IE_OFFSET			0x04
+#define UART_DLH_OFFSET			0x04
+#define UART_II_OFFSET			0x08
+#define UART_FC_OFFSET			0x08
+#define UART_LC_OFFSET			0x0c
+#define UART_MC_OFFSET			0x10
+#define UART_LS_OFFSET			0x14
+#define UART_MS_OFFSET			0x18
+#define UART_SC_OFFSET			0x1c	/* Byte */
+#define UART_DMAE_OFFSET		0x28
+#define UART_DMAF_OFFSET		0x40	/* DMA fifo */
+#define UART_US_OFFSET			0x7c
+#define UART_TFL_OFFSET			0x80
+#define UART_RFL_OFFSET			0x84
+#define UART_SRR_OFFSET			0x88
+
+/* UART[x]_IE_REG */
+#define UART_IE_PTIME			0x80
+#define UART_IE_ETOI			0x20
+#define UART_IE_EBDI			0x10
+#define UART_IE_EDSSI			0x08
+#define UART_IE_ELSI			0x04
+#define UART_IE_ETBEI			0x02
+#define UART_IE_ERBFI			0x01
+
+/* UART[x]_II_REG */
+#define UART_II_MODEM_STATUS_CHANGED	0x00
+#define UART_II_NO_INT_PENDING		0x01
+#define UART_II_THR_EMPTY		0x02
+#define UART_II_RCV_DATA_AVAIL		0x04
+#define UART_II_RCV_STATUS		0x06
+#define UART_II_CHAR_TIMEOUT		0x0c
+
+/* UART[x]_FC_REG */
+#define UART_FC_RX_ONECHAR		0x00
+#define UART_FC_RX_QUARTER_FULL		0x40
+#define UART_FC_RX_HALF_FULL		0x80
+#define UART_FC_RX_2_TO_FULL		0xc0
+#define UART_FC_TX_EMPTY		0x00
+#define UART_FC_TX_2_IN_FIFO		0x10
+#define UART_FC_TX_QUATER_IN_FIFO	0x20
+#define UART_FC_TX_HALF_IN_FIFO		0x30
+#define UART_FC_XMITR			0x04
+#define UART_FC_RCVRR			0x02
+#define UART_FC_FIFOE			0x01
+
+/* UART[x]_LC_REG */
+#define UART_LC_DLAB			0x80
+#define UART_LC_BRK			0x40
+#define UART_LC_EVEN_PARITY		0x10
+#define UART_LC_ODD_PARITY		0x00
+#define UART_LC_PEN			0x08
+#define UART_LC_STOP_2BIT		0x04
+#define UART_LC_STOP_1BIT		0x00
+#define UART_LC_CLS_8_BITS		0x03
+#define UART_LC_CLS_7_BITS		0x02
+#define UART_LC_CLS_6_BITS		0x01
+#define UART_LC_CLS_5_BITS		0x00
+/*	quick defs */
+#define	UART_LC_8N1			0x03
+#define	UART_LC_7E1			0x0a
+
+/* UART[x]_MC_REG */
+#define UART_MC_SIRE			0x40
+#define UART_MC_AFCE			0x20
+#define UART_MC_LB			0x10
+#define UART_MC_OUT2			0x08
+#define UART_MC_OUT1			0x04
+#define UART_MC_RTS			0x02
+#define UART_MC_DTR			0x01
+
+/* UART[x]_LS_REG */
+#define UART_LS_FERR			0x80
+#define UART_LS_TEMT			0x40
+#define UART_LS_THRE			0x20
+#define UART_LS_BI			0x10
+#define UART_LS_FE			0x08
+#define UART_LS_PE			0x04
+#define UART_LS_OE			0x02
+#define UART_LS_DR			0x01
+
+/* UART[x]_MS_REG */
+#define UART_MS_DCD			0x80
+#define UART_MS_RI			0x40
+#define UART_MS_DSR			0x20
+#define UART_MS_CTS			0x10
+#define UART_MS_DDCD			0x08
+#define UART_MS_TERI			0x04
+#define UART_MS_DDSR			0x02
+#define UART_MS_DCTS			0x01
+
+/* UART[x]_US_REG */
+#define UART_US_RFF			0x10
+#define UART_US_RFNE			0x08
+#define UART_US_TFE			0x04
+#define UART_US_TFNF			0x02
+#define UART_US_BUSY			0x01
+
 /* ==========================================================================*/
 #ifndef __ASM__
-/* ==========================================================================*/
+/* ==========================================================================*/
+
+#if (CHIP_REV == S2L)
+#define MINIPIN_UART_ALTFUNC		1
+#define MINIPIN_UART_PIN		{39, 40}
+#elif (CHIP_REV == S3)
+#define MINIPIN_UART_ALTFUNC		1
+#define MINIPIN_UART_PIN		{36, 37}
+#elif (CHIP_REV == S3L)
+#define MINIPIN_UART_ALTFUNC		1
+#define MINIPIN_UART_PIN		{40, 41}
+#elif (CHIP_REV == S5)
+#define MINIPIN_UART_ALTFUNC		1
+#define MINIPIN_UART_PIN		{31, 32}
+#elif (CHIP_REV == S5L)
+#define MINIPIN_UART_ALTFUNC		1
+#define MINIPIN_UART_PIN		{45, 46}
+#elif (CHIP_REV == CV1)
+#define MINIPIN_UART_ALTFUNC		1
+#define MINIPIN_UART_PIN		{51, 52}
+#else
+#error "MINIPIN uart: not defined!"
+#endif
 
 extern void uart_init(void);
 extern void uart_putchar(char c);
 extern void uart_getchar(char *c);
 extern void uart_puthex(u32 h);
-extern void uart_putbin(u32 h, int bits, int show_0);
+extern void uart_putbin(u32 h, int bits, int show_0);
 extern void uart_putbyte(u32 h);
 extern void uart_putdec(u32 d);
 extern int  uart_putstr(const char *str);
@@ -177,12 +234,8 @@ extern int  uart_getcmd(char *cmd, int n, int timeout);
 extern int  uart_getblock(char *buf, int n, int timeout);
 
 /* ==========================================================================*/
-#endif
+#endif
 /* ==========================================================================*/
-
-extern int uart_get_rsakey_1024(void* p_key);
-extern void uart_print_rsakey_1024(void* p_key);
-extern int uart_get_onechar_blocked();
-
-#endif /* __AMBHW__UART_H__ */
-
+
+#endif /* __AMBHW__UART_H__ */
+
diff --git a/include/ambhw/usbdc.h b/include/ambhw/usbdc.h
index a0c2898..984d855 100644
--- a/include/ambhw/usbdc.h
+++ b/include/ambhw/usbdc.h
@@ -1,168 +1,193 @@
-/*
- * ambhw/usbdc.h
- *
- * History:
- *	2007/01/27 - [Charles Chiou] created file
- *
- * Copyright (C) 2006-2007, Ambarella, Inc.
- */
-
-#ifndef __AMBHW__USBDC_H__
-#define __AMBHW__USBDC_H__
-
-/* ==========================================================================*/
-#define USBDC_OFFSET			0x6000
-#define USBDC_BASE			(AHB_BASE + USBDC_OFFSET)
-#define USBDC_REG(x)			(USBDC_BASE + (x))
-
-/****************************************************/
-/* Capabilities based on chip revision              */
-/****************************************************/
-
-/* None so far */
-
-/****************************************************/
-/* Controller registers definitions                 */
-/****************************************************/
-/************************************************************/
-/* USB Device Controller IN/OUT Endpoint-Specific Registers */
-/************************************************************/
-
-#define UDC_EP_IN_BASE			USBDC_BASE
-
-#define UDC_EP_IN_CTRL_REG(n)		(UDC_EP_IN_BASE + 0x0000 + 0x0020*(n))
-#define UDC_EP_IN_STS_REG(n)		(UDC_EP_IN_BASE + 0x0004 + 0x0020*(n))
-#define UDC_EP_IN_BUF_SZ_REG(n)		(UDC_EP_IN_BASE + 0x0008 + 0x0020*(n))
-#define UDC_EP_IN_MAX_PKT_SZ_REG(n)	(UDC_EP_IN_BASE + 0x000c + 0x0020*(n))
-#define UDC_EP_IN_DAT_DESC_PTR_REG(n)	(UDC_EP_IN_BASE + 0x0014 + 0x0020*(n))
-#define UDC_EP_IN_WR_CFM_REG(n)		(UDC_EP_IN_BASE + 0x001c + 0x0020*(n))
-
-#define UDC_EP_OUT_BASE			(USBDC_BASE + 0x0200)
-
-#define UDC_EP_OUT_CTRL_REG(n)		(UDC_EP_OUT_BASE + 0x0000 + 0x0020*(n))
-#define UDC_EP_OUT_STS_REG(n)		(UDC_EP_OUT_BASE + 0x0004 + 0x0020*(n))
-#define UDC_EP_OUT_PKT_FRM_NUM_REG(n)	(UDC_EP_OUT_BASE + 0x0008 + 0x0020*(n))
-#define UDC_EP_OUT_MAX_PKT_SZ_REG(n)	(UDC_EP_OUT_BASE + 0x000c + 0x0020*(n))
-#define UDC_EP_OUT_SETUP_BUF_PTR_REG(n)	(UDC_EP_OUT_BASE + 0x0010 + 0x0020*(n))
-#define UDC_EP_OUT_DAT_DESC_PTR_REG(n)	(UDC_EP_OUT_BASE + 0x0014 + 0x0020*(n))
-#define UDC_EP_OUT_RD_CFM_ZO_REG(n)	(UDC_EP_OUT_BASE + 0x001c + 0x0020*(n))
-
-/* UDC_EP_IN_CTRL_REG(n) and UDC_EP_OUT_CTRL_REG(n) */
-
-#define UDC_EP_CTRL_RRDY		0x00000200
-#define UDC_EP_CTRL_CNAK		0x00000100
-#define UDC_EP_CTRL_SNAK		0x00000080
-#define UDC_EP_CTRL_NAK			0x00000040
-#define UDC_EP_CTRL_ET			0x00000030
-#define UDC_EP_CTRL_P			0x00000008
-#define UDC_EP_CTRL_SN			0x00000004
-#define UDC_EP_CTRL_F			0x00000002
-#define UDC_EP_CTRL_S			0x00000001
-
-/* UDC_EP_IN_STS_REG(n) and UDC_EP_OUT_STS_REG(n) */
-#define UDC_EP_STS_RX_PKT_SZ		0x007ff800
-#define UDC_EP_STS_TDC			0x00000400
-#define UDC_EP_STS_HE			0x00000200
-#define UDC_EP_STS_BNA			0x00000080
-#define UDC_EP_STS_IN			0x00000040
-#define UDC_EP_STS_OUT			0x00000030
-
-/* UDC_EP_IN_BUF_SZ_REG(n) and UDC_EP_OUT_PKT_FRM_NUM_REG(n) */
-#define UDC_EP_IN_BUF_SZ		0x0000ffff
-#define UDC_EP_OUT_PKT_FRM_NUM		0x0000ffff
-
-/* UDC_EP_IN_MAX_PKT_SZ_REG(n) and UDC_EP_OUT_MAX_PKT_SZ_REG(n) */
-#define UDC_EP_MAX_PKT_BUF_SZ		0xffff0000
-#define UDC_EP_MAX_PKT_FRM_NUM		0x0000ffff
-
-/* UDC_EP_OUT_SETUP_BUF_PTR_REG(n) */
-/* UDC_EP_IN_DAT_DESC_PTR_REG(n) and UDC_EP_OUT_DAT_DESC_PTR_REG(n) */
-/* UDC_EP_IN_WR_CFM_REG(n) and UDC_EP_OUT_RD_CFM_ZO_REG(n) */
-
-
-/* ---------------------------------------------------------------------- */
-
-/******************************************/
-/* USB Device Controller Global Registers */
-/******************************************/
-#define UDC_REG(x)			(USBDC_BASE + (x))
-#define UDC_CFG_REG			UDC_REG(0x400)
-#define UDC_CTRL_REG			UDC_REG(0x404)
-#define UDC_STS_REG			UDC_REG(0x408)
-#define UDC_INTR_REG			UDC_REG(0x40c)
-#define UDC_INTR_MSK_REG		UDC_REG(0x410)
-#define UDC_EP_INTR_REG			UDC_REG(0x414)
-#define UDC_EP_INTR_MSK_REG		UDC_REG(0x418)
-#define UDC_TEST_MODE_REG		UDC_REG(0x41c)
-
-/* UDC_CFG_REG */
-#define UDC_CFG_DDR			0x00080000
-#define UDC_CFG_SET_DESC		0x00040000
-#define UDC_CFG_CSR_PRG			0x00020000
-#define UDC_CFG_HALT			0x00010000
-#define UDC_CFG_HS_TIMEOUT		0x0000e000
-#define UDC_CFG_PS_TIMEOUT		0x00001c00
-#define UDC_CFG_PHY_ERROR		0x00000200
-#define UDC_CFG_STS_i			0x00000100
-#define UDC_CFG_STS			0x00000080
-#define UDC_CFG_DIR			0x00000040
-#define UDC_CFG_P1			0x00000020
-#define UDC_CFG_SS			0x00000010
-#define UDC_CFG_SP			0x00000008
-#define UDC_CFG_RWKP			0x00000004
-#define UDC_CFG_SPD			0x00000003
-
-/* UDC_CTRL_REG */
-#define UDC_CTRL_THLEN			0xff000000
-#define UDC_CTRL_BRLEN			0x00ff0000
-#define UDC_CTRL_CSR_DONE		0x00002000
-#define UDC_CTRL_DEVNAK			0x00001000
-#define UDC_CTRL_SCALE			0x00000800
-#define UDC_CTRL_SD			0x00000400
-#define UDC_CTRL_MODE			0x00000200
-#define UDC_CTRL_BREN			0x00000100
-#define UDC_CTRL_THE			0x00000080
-#define UDC_CTRL_BF			0x00000040
-#define UDC_CTRL_BE			0x00000020
-#define UDC_CTRL_DU			0x00000010
-#define UDC_CTRL_TDE			0x00000008
-#define UDC_CTRL_RDE			0x00000004
-#define UDC_CTRL_RES			0x00000001
-
-/* UDC_STS_REG */
-#define UDC_STS_TS			0xfffc0000
-#define UDC_STS_PHY_ERROR		0x00010000
-#define UDC_STS_RXFIFO_EMPTY		0x00008000
-#define UDC_STS_ENUM_SPD		0x00006000
-#define UDC_STS_SUSP			0x00001000
-#define UDC_STS_ALT			0x00000f00
-#define UDC_STS_INTF			0x000000f0
-#define UDC_STS_CFG			0x0000000f
-
-/* UDC_INTR_REG */
-#define UDC_INTR_ENUM			0x00000040
-#define UDC_INTR_SOF			0x00000020
-#define UDC_INTR_US			0x00000010
-#define UDC_INTR_UR			0x00000008
-#define UDC_INTR_ES			0x00000004
-#define UDC_INTR_SI			0x00000002
-#define UDC_INTR_SC			0x00000001
-
-/* UDC_INTR_MSK_REG */
-#define UDC_INTR_MSK_ENUM		0x00000040
-#define UDC_INTR_MSK_SOF		0x00000020
-#define UDC_INTR_MSK_US			0x00000010
-#define UDC_INTR_MSK_UR			0x00000008
-#define UDC_INTR_MSK_ES			0x00000004
-#define UDC_INTR_MSK_SI			0x00000002
-#define UDC_INTR_MSK_SC			0x00000001
-
-/* UDC_EP_INTR_REG */
-/* UDC_EP_INTR_MSK_REG */
-
-/* UDC_TEST_MODE_REG */
-#define UDC_TEST_MODE_TSTMODE		0x00000001
-
+/*
+ * ambhw/usbdc.h
+ *
+ * History:
+ *	2007/01/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBHW__USBDC_H__
+#define __AMBHW__USBDC_H__
+
+#include <ambhw/chip.h>
+
+/* ==========================================================================*/
+#define USBDC_OFFSET			0x6000
+#define USBDC_BASE			(AHB_N_BASE + USBDC_OFFSET)
+#define USBDC_REG(x)			(USBDC_BASE + (x))
+
+/****************************************************/
+/* Capabilities based on chip revision              */
+/****************************************************/
+
+/* None so far */
+
+/****************************************************/
+/* Controller registers definitions                 */
+/****************************************************/
+/************************************************************/
+/* USB Device Controller IN/OUT Endpoint-Specific Registers */
+/************************************************************/
+
+#define UDC_EP_IN_BASE			USBDC_BASE
+
+#define UDC_EP_IN_CTRL_REG(n)		(UDC_EP_IN_BASE + 0x0000 + 0x0020*(n))
+#define UDC_EP_IN_STS_REG(n)		(UDC_EP_IN_BASE + 0x0004 + 0x0020*(n))
+#define UDC_EP_IN_BUF_SZ_REG(n)		(UDC_EP_IN_BASE + 0x0008 + 0x0020*(n))
+#define UDC_EP_IN_MAX_PKT_SZ_REG(n)	(UDC_EP_IN_BASE + 0x000c + 0x0020*(n))
+#define UDC_EP_IN_DAT_DESC_PTR_REG(n)	(UDC_EP_IN_BASE + 0x0014 + 0x0020*(n))
+#define UDC_EP_IN_WR_CFM_REG(n)		(UDC_EP_IN_BASE + 0x001c + 0x0020*(n))
+
+#define UDC_EP_OUT_BASE			(USBDC_BASE + 0x0200)
+
+#define UDC_EP_OUT_CTRL_REG(n)		(UDC_EP_OUT_BASE + 0x0000 + 0x0020*(n))
+#define UDC_EP_OUT_STS_REG(n)		(UDC_EP_OUT_BASE + 0x0004 + 0x0020*(n))
+#define UDC_EP_OUT_PKT_FRM_NUM_REG(n)	(UDC_EP_OUT_BASE + 0x0008 + 0x0020*(n))
+#define UDC_EP_OUT_MAX_PKT_SZ_REG(n)	(UDC_EP_OUT_BASE + 0x000c + 0x0020*(n))
+#define UDC_EP_OUT_SETUP_BUF_PTR_REG(n)	(UDC_EP_OUT_BASE + 0x0010 + 0x0020*(n))
+#define UDC_EP_OUT_DAT_DESC_PTR_REG(n)	(UDC_EP_OUT_BASE + 0x0014 + 0x0020*(n))
+#define UDC_EP_OUT_RD_CFM_ZO_REG(n)	(UDC_EP_OUT_BASE + 0x001c + 0x0020*(n))
+
+/* UDC_EP_IN_CTRL_REG(n) and UDC_EP_OUT_CTRL_REG(n) */
+
+#define UDC_EP_CTRL_RRDY		0x00000200
+#define UDC_EP_CTRL_CNAK		0x00000100
+#define UDC_EP_CTRL_SNAK		0x00000080
+#define UDC_EP_CTRL_NAK			0x00000040
+#define UDC_EP_CTRL_ET			0x00000030
+#define UDC_EP_CTRL_P			0x00000008
+#define UDC_EP_CTRL_SN			0x00000004
+#define UDC_EP_CTRL_F			0x00000002
+#define UDC_EP_CTRL_S			0x00000001
+
+/* UDC_EP_IN_STS_REG(n) and UDC_EP_OUT_STS_REG(n) */
+#define UDC_EP_STS_RX_PKT_SZ		0x007ff800
+#define UDC_EP_STS_TDC			0x00000400
+#define UDC_EP_STS_HE			0x00000200
+#define UDC_EP_STS_BNA			0x00000080
+#define UDC_EP_STS_IN			0x00000040
+#define UDC_EP_STS_OUT			0x00000030
+
+/* UDC_EP_IN_BUF_SZ_REG(n) and UDC_EP_OUT_PKT_FRM_NUM_REG(n) */
+#define UDC_EP_IN_BUF_SZ		0x0000ffff
+#define UDC_EP_OUT_PKT_FRM_NUM		0x0000ffff
+
+/* UDC_EP_IN_MAX_PKT_SZ_REG(n) and UDC_EP_OUT_MAX_PKT_SZ_REG(n) */
+#define UDC_EP_MAX_PKT_BUF_SZ		0xffff0000
+#define UDC_EP_MAX_PKT_FRM_NUM		0x0000ffff
+
+/* UDC_EP_OUT_SETUP_BUF_PTR_REG(n) */
+/* UDC_EP_IN_DAT_DESC_PTR_REG(n) and UDC_EP_OUT_DAT_DESC_PTR_REG(n) */
+/* UDC_EP_IN_WR_CFM_REG(n) and UDC_EP_OUT_RD_CFM_ZO_REG(n) */
+
+
+/* ---------------------------------------------------------------------- */
+
+/******************************************/
+/* USB Device Controller Global Registers */
+/******************************************/
+#define UDC_REG(x)			(USBDC_BASE + (x))
+#define UDC_CFG_REG			UDC_REG(0x400)
+#define UDC_CTRL_REG			UDC_REG(0x404)
+#define UDC_STS_REG			UDC_REG(0x408)
+#define UDC_INTR_REG			UDC_REG(0x40c)
+#define UDC_INTR_MSK_REG		UDC_REG(0x410)
+#define UDC_EP_INTR_REG			UDC_REG(0x414)
+#define UDC_EP_INTR_MSK_REG		UDC_REG(0x418)
+#define UDC_TEST_MODE_REG		UDC_REG(0x41c)
+
+/* UDC_CFG_REG */
+#define UDC_CFG_DDR			0x00080000
+#define UDC_CFG_SET_DESC		0x00040000
+#define UDC_CFG_CSR_PRG			0x00020000
+#define UDC_CFG_HALT			0x00010000
+#define UDC_CFG_HS_TIMEOUT		0x0000e000
+#define UDC_CFG_PS_TIMEOUT		0x00001c00
+#define UDC_CFG_PHY_ERROR		0x00000200
+#define UDC_CFG_STS_i			0x00000100
+#define UDC_CFG_STS			0x00000080
+#define UDC_CFG_DIR			0x00000040
+#define UDC_CFG_P1			0x00000020
+#define UDC_CFG_SS			0x00000010
+#define UDC_CFG_SP			0x00000008
+#define UDC_CFG_RWKP			0x00000004
+#define UDC_CFG_SPD			0x00000003
+
+/* UDC_CTRL_REG */
+#define UDC_CTRL_THLEN			0xff000000
+#define UDC_CTRL_BRLEN			0x00ff0000
+#define UDC_CTRL_CSR_DONE		0x00002000
+#define UDC_CTRL_DEVNAK			0x00001000
+#define UDC_CTRL_SCALE			0x00000800
+#define UDC_CTRL_SD			0x00000400
+#define UDC_CTRL_MODE			0x00000200
+#define UDC_CTRL_BREN			0x00000100
+#define UDC_CTRL_THE			0x00000080
+#define UDC_CTRL_BF			0x00000040
+#define UDC_CTRL_BE			0x00000020
+#define UDC_CTRL_DU			0x00000010
+#define UDC_CTRL_TDE			0x00000008
+#define UDC_CTRL_RDE			0x00000004
+#define UDC_CTRL_RES			0x00000001
+
+/* UDC_STS_REG */
+#define UDC_STS_TS			0xfffc0000
+#define UDC_STS_PHY_ERROR		0x00010000
+#define UDC_STS_RXFIFO_EMPTY		0x00008000
+#define UDC_STS_ENUM_SPD		0x00006000
+#define UDC_STS_SUSP			0x00001000
+#define UDC_STS_ALT			0x00000f00
+#define UDC_STS_INTF			0x000000f0
+#define UDC_STS_CFG			0x0000000f
+
+/* UDC_INTR_REG */
+#define UDC_INTR_ENUM			0x00000040
+#define UDC_INTR_SOF			0x00000020
+#define UDC_INTR_US			0x00000010
+#define UDC_INTR_UR			0x00000008
+#define UDC_INTR_ES			0x00000004
+#define UDC_INTR_SI			0x00000002
+#define UDC_INTR_SC			0x00000001
+
+/* UDC_INTR_MSK_REG */
+#define UDC_INTR_MSK_ENUM		0x00000040
+#define UDC_INTR_MSK_SOF		0x00000020
+#define UDC_INTR_MSK_US			0x00000010
+#define UDC_INTR_MSK_UR			0x00000008
+#define UDC_INTR_MSK_ES			0x00000004
+#define UDC_INTR_MSK_SI			0x00000002
+#define UDC_INTR_MSK_SC			0x00000001
+
+/* UDC_EP_INTR_REG */
+/* UDC_EP_INTR_MSK_REG */
+
+/* UDC_TEST_MODE_REG */
+#define UDC_TEST_MODE_TSTMODE		0x00000001
+
 /*===========================================================================*/
 /* Flags used by usb_boot() */
 #define USB_DL_NORMAL		0x01
@@ -176,20 +201,20 @@
 #define USB_FLAG_TEST_DOWNLOAD	0x0100
 #define USB_FLAG_TEST_PLL	0x0200
 #define USB_FLAG_TEST_MASK	(USB_FLAG_TEST_DOWNLOAD | USB_FLAG_TEST_PLL)
-
+
 /* ==========================================================================*/
 #ifndef __ASM__
-/* ==========================================================================*/
+/* ==========================================================================*/
 
-extern void init_usb_pll(void);
-extern u32 usb_download(void *addr, int exec, int flag);
-extern int usb_check_connected(void);
+extern void init_usb_pll(void);
+extern u32 usb_download(void *addr, int exec, int flag);
+extern int usb_check_connected(void);
 extern void usb_boot(u8 usbdl_mode);
 extern void usb_disconnect(void);
-
+
 /* ==========================================================================*/
-#endif
+#endif
 /* ==========================================================================*/
 
-#endif
-
+#endif
+
diff --git a/include/ambhw/vic.h b/include/ambhw/vic.h
index 0ed6427..d8507cf 100644
--- a/include/ambhw/vic.h
+++ b/include/ambhw/vic.h
@@ -3,38 +3,42 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __AMBHW__VIC_H__
 #define __AMBHW__VIC_H__
 
+#include <ambhw/chip.h>
+
 /* ==========================================================================*/
-#if (CHIP_REV == A5S)
-#define VIC_INSTANCES			(2)
-#define VIC_SUPPORT_CPU_OFFLOAD		(0)
-#define VIC_SUPPORT_REPRIORITIZE	(0)
-#elif (CHIP_REV == A7L)
-#define VIC_INSTANCES			(2)
-#define VIC_SUPPORT_CPU_OFFLOAD		(1)
-#define VIC_SUPPORT_REPRIORITIZE	(1)
-#elif (CHIP_REV == S2)
-#define VIC_INSTANCES			(3)
-#define VIC_SUPPORT_CPU_OFFLOAD		(0)
-#define VIC_SUPPORT_REPRIORITIZE	(0)
-#elif (CHIP_REV == S2E) || (CHIP_REV == S3L)
+#if (CHIP_REV == S3L)
 #define VIC_INSTANCES			(3)
 #define VIC_SUPPORT_CPU_OFFLOAD		(2)
 #define VIC_SUPPORT_REPRIORITIZE	(1)
-#elif (CHIP_REV == A8)
-#define VIC_INSTANCES			(3)
-#define VIC_SUPPORT_CPU_OFFLOAD		(1)
-#define VIC_SUPPORT_REPRIORITIZE	(1)
 #elif (CHIP_REV == S2L)
 #define VIC_INSTANCES			(3)
 #define VIC_SUPPORT_CPU_OFFLOAD		(1)
@@ -51,9 +55,6 @@
 #if (CHIP_REV == S3)
 #define VIC_NULL_PRI_IRQ_VAL		(0x00000060)
 #define VIC_NULL_PRI_IRQ_FIX		(0)
-#elif (CHIP_REV == S2E)
-#define VIC_NULL_PRI_IRQ_VAL		(0x00000040)
-#define VIC_NULL_PRI_IRQ_FIX		(1)
 #else
 #define VIC_NULL_PRI_IRQ_VAL		(0xffffffff)
 #define VIC_NULL_PRI_IRQ_FIX		(0)
@@ -65,53 +66,32 @@
 #endif
 
 /* ==========================================================================*/
-#define VIC_OFFSET			0x3000
-#define VIC2_OFFSET			0x10000
-#define VIC3_OFFSET			0x1C000
-#define VIC4_OFFSET			0x11000
+#define VIC0_OFFSET			0x3000
+#define VIC1_OFFSET			0x10000
+#define VIC2_OFFSET			0x1C000
+#define VIC3_OFFSET			0x11000
 
-#define VIC_BASE			(AHB_BASE + VIC_OFFSET)
+#define VIC0_BASE			(AHB_BASE + VIC0_OFFSET)
+#define VIC1_BASE			(AHB_BASE + VIC1_OFFSET)
 #define VIC2_BASE			(AHB_BASE + VIC2_OFFSET)
 #define VIC3_BASE			(AHB_BASE + VIC3_OFFSET)
-#define VIC4_BASE			(AHB_BASE + VIC4_OFFSET)
 
-#define VIC_REG(x)			(VIC_BASE + (x))
+#define VIC0_REG(x)			(VIC0_BASE + (x))
+#define VIC1_REG(x)			(VIC1_BASE + (x))
 #define VIC2_REG(x)			(VIC2_BASE + (x))
 #define VIC3_REG(x)			(VIC3_BASE + (x))
-#define VIC4_REG(x)			(VIC4_BASE + (x))
+#define VIC_REG(b, x)			((b) == 0 ? VIC0_REG((x)) : \
+					 (b) == 1 ? VIC1_REG((x)) : \
+					 (b) == 2 ? VIC2_REG((x)) : \
+					 	    VIC3_REG((x)))
 
 /* ==========================================================================*/
 #define NR_VIC_IRQ_SIZE			(32)
 
-#if defined(CONFIG_ARM_GIC)
-#define VIC_IRQ(x)			((x) + 32)
-#define NR_SPI_IRQS			(256)
-#define SGI_INT_VEC(x)			(x)
-#define PPI_INT_VEC(x)			(x)
-#define SPI_INT_VEC(x)			(x)
-#else
-#define VIC_IRQ(x)			(x)
-#endif
-
-#define VIC_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 0)
-#define VIC2_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 1)
-#define VIC3_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 2)
-#define VIC4_INT_VEC(x)			(VIC_IRQ(x) + NR_VIC_IRQ_SIZE * 3)
-
-#ifndef NR_SPI_IRQS
-#define NR_VIC_IRQS			(VIC_INSTANCES * NR_VIC_IRQ_SIZE)
-#define GPIO_INT_VEC(x)			(NR_VIC_IRQS + x)
-#else
-#define NR_VIC_IRQS			NR_SPI_IRQS
-#define GPIO_INT_VEC(x)			(NR_SPI_IRQS + x)
-#endif
-
-#ifndef CONFIG_AMBARELLA_EXT_IRQ_NUM
-#define CONFIG_AMBARELLA_EXT_IRQ_NUM	(64)
-#endif
-#define EXT_IRQ(x)			GPIO_INT_VEC(AMBGPIO_SIZE + x)
-
-#define NR_IRQS				EXT_IRQ(CONFIG_AMBARELLA_EXT_IRQ_NUM)
+#define VIC0_INT_VEC(x)			((x) + NR_VIC_IRQ_SIZE * 0)
+#define VIC1_INT_VEC(x)			((x) + NR_VIC_IRQ_SIZE * 1)
+#define VIC2_INT_VEC(x)			((x) + NR_VIC_IRQ_SIZE * 2)
+#define VIC3_INT_VEC(x)			((x) + NR_VIC_IRQ_SIZE * 3)
 
 /* ==========================================================================*/
 #define VIC_IRQ_STA_OFFSET			(0x00)
@@ -155,785 +135,319 @@
 #define VIC_INT_EDGE_CLR_OFFSET			(0x98)
 
 /* ==========================================================================*/
-#if (CHIP_REV == A5S)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define VDSP_IRQ			VIC_INT_VEC(3)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define HIF_ARM1_IRQ			VIC_INT_VEC(5)
-#define HIF_ARM2_IRQ			VIC_INT_VEC(6)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SSI_IRQ				VIC_INT_VEC(20)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define CFCD1_IRQ			VIC_INT_VEC(23)
-#define SD1CD_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define SSI_SLAVE_IRQ			VIC_INT_VEC(26)
-#define ETH_IRQ				VIC_INT_VEC(27)
-#define IDSP_ERROR_IRQ			VIC_INT_VEC(28)
-#define VOUT_SYNC_MISSED_IRQ		VIC_INT_VEC(29)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-#define CFCD2_IRQ			VIC_INT_VEC(31)
-
-#define AUDIO_ORC_IRQ			VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define VOUT1_SYNC_MISSED_IRQ		VIC2_INT_VEC(3)
-#define IDC2_IRQ			VIC2_INT_VEC(4)
-#define IDSP_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_VSYNC_IRQ			VIC2_INT_VEC(6)
-#define IDSP_SENSOR_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define SSI2_IRQ			VIC2_INT_VEC(9)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(12)
-#define AES_IRQ				VIC2_INT_VEC(13)
-#define DES_IRQ				VIC2_INT_VEC(14)
-#define MS_IRQ				VIC2_INT_VEC(15)
-#define GDMA_IRQ			VIC2_INT_VEC(16)
-#define MOTOR_IRQ			VIC2_INT_VEC(17)
-#define PMU_IRQ				VIC2_INT_VEC(31)
-
-/* ==========================================================================*/
-#elif (CHIP_REV == A7L)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define GDMA_IRQ			VIC_INT_VEC(3)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define SD1CD_IRQ			VIC_INT_VEC(5)
-#define VDSP_IRQ			VIC_INT_VEC(6)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SSI_IRQ				VIC_INT_VEC(20)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define CFCD2_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define IDC2_IRQ			VIC_INT_VEC(26)
-#define IDSP_ERROR_IRQ			VIC_INT_VEC(28)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-
-#define PMU_IRQ				VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define IDSP_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_VSYNC_IRQ			VIC2_INT_VEC(6)
-#define IDSP_SENSOR_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define SSI_SLAVE_IRQ			VIC2_INT_VEC(9)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(12)
-#define MS_IRQ				VIC2_INT_VEC(15)
-#define MOTOR_IRQ			VIC2_INT_VEC(17)
-#define GPIO3_IRQ			VIC2_INT_VEC(19)
-#define DRAM_ERROR_IRQ			VIC2_INT_VEC(23)
-#define SD2_IRQ				VIC2_INT_VEC(24)
-#define TIMER4_IRQ			VIC2_INT_VEC(27)
-#define TIMER5_IRQ			VIC2_INT_VEC(28)
-#define TIMER6_IRQ			VIC2_INT_VEC(29)
-#define TIMER7_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
-
-/* ==========================================================================*/
-#elif (CHIP_REV == S2)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define USB_CHARGE_IRQ			VIC_INT_VEC(5)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SSI_IRQ				VIC_INT_VEC(20)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define CFCD1_IRQ			VIC_INT_VEC(23)
-#define SD1CD_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define SSI_SLAVE_IRQ			VIC_INT_VEC(26)
-#define ETH_IRQ				VIC_INT_VEC(27)
-#define IDSP_SOFT_IRQ			VIC_INT_VEC(28)
-#define GPIO3_IRQ			VIC_INT_VEC(29)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-
-#define ROLLING_SHUTTER_IRQ		VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define IDSP_VIN_SOFT_IRQ		VIC2_INT_VEC(3)
-#define IDC2_IRQ			VIC2_INT_VEC(4)
-#define IDSP_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_VSYNC_IRQ			VIC2_INT_VEC(6)
-#define IDSP_SENSOR_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define FIOS_ECC_IRQ			VIC2_INT_VEC(9)
-
-#define GPIO4_IRQ			VIC2_INT_VEC(16)
-#define MOTOR_IRQ			VIC2_INT_VEC(17)
-#define GDMA_IRQ			VIC2_INT_VEC(18)
-#define FACE_DET_IRQ			VIC2_INT_VEC(19)
-#define SD2_IRQ				VIC2_INT_VEC(20)
-#define SSI_MASTER_IRQ			VIC2_INT_VEC(21)
-#define IDSP_PROG_IRQ			VIC2_INT_VEC(26)
-
-#define VDSP_PIP_SVSYNC_IRQ		VIC3_INT_VEC(0)
-#define IDSP_PIP_SVSYNC_IRQ		VIC3_INT_VEC(1)
-#define IDSP_PIP_PROG_IRQ		VIC3_INT_VEC(2)
-#define IDSP_PIP_LAST_PIXEL_IRQ		VIC3_INT_VEC(3)
-#define CORTEX_CORE0_IRQ		VIC3_INT_VEC(4)
-#define CORTEX_CORE1_IRQ		VIC3_INT_VEC(5)
-#define ETH_PMT_INTR_IRQ		VIC3_INT_VEC(6)
-#define I2S1_RX_IRQ			VIC3_INT_VEC(7)
-#define I2S1_TX_IRQ			VIC3_INT_VEC(8)
-#define USB_EHCI_IRQ			VIC3_INT_VEC(9)
-#define AXI_SOFT_IRQ(x)			VIC3_INT_VEC((x) + 10)	/* 0 <= x <= 13 */
-#define CORTEX_WDT_IRQ			VIC3_INT_VEC(24)
-#define USB_OHCI_IRQ			VIC3_INT_VEC(25)
-#define IDC3_IRQ			VIC3_INT_VEC(26)
-#define UART2_IRQ			VIC3_INT_VEC(27)
-#define UART3_IRQ			VIC3_INT_VEC(28)
-#define PMU_IRQ				VIC3_INT_VEC(31)
-
-#if defined(CONFIG_ARM_GIC)
-#define VOUT_IRQ			VIC4_INT_VEC(0)
-#define VIN_IRQ				VIC4_INT_VEC(1)
-#define TIMER1_IRQ			VIC4_INT_VEC(2)
-#define TIMER2_IRQ			VIC4_INT_VEC(3)
-#define TIMER3_IRQ			VIC4_INT_VEC(4)
-#define WDT_IRQ				VIC4_INT_VEC(5)
-#define VOUT_TV_SYNC_IRQ		VIC4_INT_VEC(6)
-#define VOUT_LCD_SYNC_IRQ		VIC4_INT_VEC(7)
-#define ORC_VOUT0_IRQ			VIC4_INT_VEC(8)
-#define TIMER4_IRQ			VIC4_INT_VEC(9)
-#define TIMER5_IRQ			VIC4_INT_VEC(10)
-#define TIMER6_IRQ			VIC4_INT_VEC(11)
-#define TIMER7_IRQ			VIC4_INT_VEC(12)
-#define TIMER8_IRQ			VIC4_INT_VEC(13)
-#define CODE_VDSP_0_IRQ			VIC4_INT_VEC(14)
-#define CODE_VDSP_1_IRQ			VIC4_INT_VEC(15)
-#define CODE_VDSP_2_IRQ			VIC4_INT_VEC(16)
-#define CODE_VDSP_3_IRQ			VIC4_INT_VEC(17)
-#define MD5_IRQ				VIC4_INT_VEC(24)
-#define DES_IRQ				VIC4_INT_VEC(25)
-#define AES_IRQ				VIC4_INT_VEC(26)
-#define SHA1_IRQ			VIC4_INT_VEC(27)
-#else
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(14)
-#define TIMER4_IRQ			VIC2_INT_VEC(27)
-#define TIMER5_IRQ			VIC2_INT_VEC(28)
-#define TIMER6_IRQ			VIC2_INT_VEC(29)
-#define TIMER7_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
-#define CODE_VDSP_0_IRQ			VIC_INT_VEC(3)
-#define CODE_VDSP_1_IRQ			VIC2_INT_VEC(24)
-#define CODE_VDSP_2_IRQ			VIC2_INT_VEC(23)
-#define CODE_VDSP_3_IRQ			VIC2_INT_VEC(22)
-#define DES_IRQ				VIC2_INT_VEC(12)
-#define AES_IRQ				VIC2_INT_VEC(13)
-#define MD5_SHA1_IRQ			VIC2_INT_VEC(25)
-#endif
-
-#define GLOBAL_TIMER_IRQ		PPI_INT_VEC(27)
-#define LEGACY_FIQ			PPI_INT_VEC(28)
-#define LOCAL_TIMER_IRQ			PPI_INT_VEC(29)
-#define LOCAL_WDOG_IRQ			PPI_INT_VEC(30)
-#define LEGACY_IRQ			PPI_INT_VEC(31)
-
-#define DDD_IRQ				SPI_INT_VEC(153)
-#define DECODE_ERROR_IRQ		SPI_INT_VEC(154)
-#define SLAVE_ERROR_IRQ			SPI_INT_VEC(155)
-#define FMEM_READ_ERROR_IRQ		SPI_INT_VEC(156)
-#define FMEM_WRITE_ERROR_IRQ		SPI_INT_VEC(157)
-#define L2CC_ECNTR_IRQ			SPI_INT_VEC(158)
-#define L2CC_COMBINED_IRQ		SPI_INT_VEC(159)
-
-/* ==========================================================================*/
-#elif (CHIP_REV == S2E)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define CODE_VDSP_0_IRQ			VIC_INT_VEC(3)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define USB_CHARGE_IRQ			VIC_INT_VEC(5)
-#define PMU_IRQ				VIC_INT_VEC(6)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SSI_IRQ				VIC_INT_VEC(20)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define SD1CD_IRQ			VIC_INT_VEC(23)
-#define SD0CD_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define SSI_SLAVE_IRQ			VIC_INT_VEC(26)
-#define ETH_IRQ				VIC_INT_VEC(27)
-#define IDSP_SOFT_IRQ			VIC_INT_VEC(28)
-#define GPIO3_IRQ			VIC_INT_VEC(29)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-#define PMU1_IRQ			VIC_INT_VEC(31)
-
-#define ROLLING_SHUTTER_IRQ		VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define IDSP_VIN_SOFT_IRQ		VIC2_INT_VEC(3)
-#define IDC2_IRQ			VIC2_INT_VEC(4)
-#define IDSP_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_VSYNC_IRQ			VIC2_INT_VEC(6)
-#define IDSP_SENSOR_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define FIOS_ECC_IRQ			VIC2_INT_VEC(9)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define AES_IRQ				VIC2_INT_VEC(12)
-#define DES_IRQ				VIC2_INT_VEC(13)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(14)
-#define MD5_IRQ				VIC2_INT_VEC(15)
-#define GPIO4_IRQ			VIC2_INT_VEC(16)
-#define MOTOR_IRQ			VIC2_INT_VEC(17)
-#define GDMA_IRQ			VIC2_INT_VEC(18)
-#define L2CC_INTR1_IRQ			VIC2_INT_VEC(19)
-#define SD2_IRQ				VIC2_INT_VEC(20)
-#define SSI_MASTER_IRQ			VIC2_INT_VEC(21)
-#define CODE_VDSP_3_IRQ			VIC2_INT_VEC(22)
-#define CODE_VDSP_2_IRQ			VIC2_INT_VEC(23)
-#define CODE_VDSP_1_IRQ			VIC2_INT_VEC(24)
-#define L2CC_INTR_IRQ			VIC2_INT_VEC(25)
-#define IDSP_PROG_IRQ			VIC2_INT_VEC(26)
-#define TIMER4_IRQ			VIC2_INT_VEC(27)
-#define TIMER5_IRQ			VIC2_INT_VEC(28)
-#define TIMER6_IRQ			VIC2_INT_VEC(29)
-#define TIMER7_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
-
-#define VDSP_PIP_SVSYNC_IRQ		VIC3_INT_VEC(0)
-#define IDSP_PIP_SVSYNC_IRQ		VIC3_INT_VEC(1)
-#define IDSP_PIP_PROG_IRQ		VIC3_INT_VEC(2)
-#define IDSP_PIP_LAST_PIXEL_IRQ		VIC3_INT_VEC(3)
-#define CORTEX_CORE0_IRQ		VIC3_INT_VEC(4)
-#define CORTEX_CORE1_IRQ		VIC3_INT_VEC(5)
-#define ETH_PMT_INTR_IRQ		VIC3_INT_VEC(6)
-#define I2S1_RX_IRQ			VIC3_INT_VEC(7)
-#define I2S1_TX_IRQ			VIC3_INT_VEC(8)
-#define USB_EHCI_IRQ			VIC3_INT_VEC(9)
-#define IPI00_IRQ			VIC3_INT_VEC(10)
-#define IPI01_IRQ			VIC3_INT_VEC(11)
-#define IPI02_IRQ			VIC3_INT_VEC(12)
-#define IPI03_IRQ			VIC3_INT_VEC(13)
-#define IPI04_IRQ			VIC3_INT_VEC(14)
-#define IPI05_IRQ			VIC3_INT_VEC(15)
-#define IPI06_IRQ			VIC3_INT_VEC(16)
-#define IPI10_IRQ			VIC3_INT_VEC(17)
-#define IPI11_IRQ			VIC3_INT_VEC(18)
-#define IPI12_IRQ			VIC3_INT_VEC(19)
-#define IPI13_IRQ			VIC3_INT_VEC(20)
-#define IPI14_IRQ			VIC3_INT_VEC(21)
-#define IPI15_IRQ			VIC3_INT_VEC(22)
-#define IPI16_IRQ			VIC3_INT_VEC(23)
-#define SHA1_IRQ			VIC3_INT_VEC(24)
-#define USB_OHCI_IRQ			VIC3_INT_VEC(25)
-#define IDC3_IRQ			VIC3_INT_VEC(26)
-#define UART2_IRQ			VIC3_INT_VEC(27)
-#define UART3_IRQ			VIC3_INT_VEC(28)
-
-/* ==========================================================================*/
-#elif (CHIP_REV == A8)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define ROLLING_SHUTTER_IRQ		VIC_INT_VEC(3)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define HIF_ARM1_IRQ			VIC_INT_VEC(5)
-#define HIF_ARM2_IRQ			VIC_INT_VEC(6)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SSI_IRQ				VIC_INT_VEC(20)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define CFCD1_IRQ			VIC_INT_VEC(23)
-#define SD1CD_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define SSI_SLAVE_IRQ			VIC_INT_VEC(26)
-#define ETH_IRQ				VIC_INT_VEC(27)
-#define IDSP_SOFT_IRQ			VIC_INT_VEC(28)
-#define ETH_POWER_IRQ			VIC_INT_VEC(29)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-#define CFCD2_IRQ			VIC_INT_VEC(31)
-
-#define DRAM_AXI_ERROR_IRQ		VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define SSI3_IRQ			VIC2_INT_VEC(3)
-#define IDC2_IRQ			VIC2_INT_VEC(4)
-#define IDSP_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_VSYNC_IRQ			VIC2_INT_VEC(6)
-#define IDSP_SENSOR_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define SSI2_IRQ			VIC2_INT_VEC(9)
-#define AES_IRQ				VIC2_INT_VEC(13)
-#define DES_IRQ				VIC2_INT_VEC(14)
-#define MS_IRQ				VIC2_INT_VEC(15)
-#define USB_EHCI_IRQ			VIC2_INT_VEC(16)
-#define MOTOR_IRQ			VIC2_INT_VEC(17)
-#define MD5_SHA1_IRQ			VIC2_INT_VEC(18)
-#define GPIO3_IRQ			VIC2_INT_VEC(19)
-#define GPIO4_IRQ			VIC2_INT_VEC(20)
-#define GPIO5_IRQ			VIC2_INT_VEC(21)
-#define SATA_IRQ			VIC2_INT_VEC(22)
-#define DRAM_ERROR_IRQ			VIC2_INT_VEC(23)
-#define SD2_IRQ				VIC2_INT_VEC(24)
-#define UART2_IRQ			VIC2_INT_VEC(25)
-#define UART3_IRQ			VIC2_INT_VEC(26)
-
-#define GSSI_IRQ			VIC3_INT_VEC(0)
-#define SSI4_IRQ			VIC3_INT_VEC(1)
-#define PMU_IRQ				VIC3_INT_VEC(2)
-#define SD2CD_IRQ			VIC3_INT_VEC(3)
-#define CORTEX_CORE0_IRQ		VIC3_INT_VEC(4)
-#define CORTEX_CORE1_IRQ		VIC3_INT_VEC(5)
-#define TS_CH1_RX_IRQ			VIC3_INT_VEC(6)
-#define TS_CH0_RX_IRQ			VIC3_INT_VEC(7)
-#define TS_CH1_TX_IRQ			VIC3_INT_VEC(8)
-#define TS_CH0_TX_IRQ			VIC3_INT_VEC(9)
-#define AXI_SOFT_IRQ(x)			VIC3_INT_VEC((x) + 10)	/* 0 <= x <= 13 */
-#define CORTEX_WDT_IRQ			VIC3_INT_VEC(24)
-#define USB_OHCI_IRQ			VIC3_INT_VEC(25)
-#define SPDIF_IRQ			VIC3_INT_VEC(26)
-#define SSI_AHB_IRQ			VIC3_INT_VEC(27)
-#define IDC3_IRQ			VIC3_INT_VEC(28)
-
-#if defined(CONFIG_ARM_GIC)
-#define VOUT_IRQ			VIC4_INT_VEC(0)
-#define VIN_IRQ				VIC4_INT_VEC(1)
-#define TIMER1_IRQ			VIC4_INT_VEC(2)
-#define TIMER2_IRQ			VIC4_INT_VEC(3)
-#define TIMER3_IRQ			VIC4_INT_VEC(4)
-#define WDT_IRQ				VIC4_INT_VEC(5)
-#define VOUT_TV_SYNC_IRQ		VIC4_INT_VEC(6)
-#define VOUT_LCD_SYNC_IRQ		VIC4_INT_VEC(7)
-#define ORC_VOUT0_IRQ			VIC4_INT_VEC(8)
-#define TIMER4_IRQ			VIC4_INT_VEC(9)
-#define TIMER5_IRQ			VIC4_INT_VEC(10)
-#define TIMER6_IRQ			VIC4_INT_VEC(11)
-#define TIMER7_IRQ			VIC4_INT_VEC(12)
-#define TIMER8_IRQ			VIC4_INT_VEC(13)
-#define CODING_ORC0_IRQ			VIC4_INT_VEC(14)
-#define CODING_ORC1_IRQ			VIC4_INT_VEC(15)
-#define CODING_ORC2_IRQ			VIC4_INT_VEC(16)
-#define CODING_ORC3_IRQ			VIC4_INT_VEC(17)
-#else
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(12)
-#define TIMER4_IRQ			VIC2_INT_VEC(27)
-#define TIMER5_IRQ			VIC2_INT_VEC(28)
-#define TIMER6_IRQ			VIC2_INT_VEC(29)
-#define TIMER7_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
-#define CODING_ORC0_IRQ			VIC3_INT_VEC(28)
-#define CODING_ORC1_IRQ			VIC3_INT_VEC(29)
-#define CODING_ORC2_IRQ			VIC3_INT_VEC(30)
-#define CODING_ORC3_IRQ			VIC3_INT_VEC(31)
-#endif
-
-#define GLOBAL_TIMER_IRQ		PPI_INT_VEC(27)
-#define LEGACY_FIQ			PPI_INT_VEC(28)
-#define LOCAL_TIMER_IRQ			PPI_INT_VEC(29)
-#define LOCAL_WDOG_IRQ			PPI_INT_VEC(30)
-#define LEGACY_IRQ			PPI_INT_VEC(31)
-
-#define DDD_IRQ				SPI_INT_VEC(153)
-#define DECODE_ERROR_IRQ		SPI_INT_VEC(154)
-#define SLAVE_ERROR_IRQ			SPI_INT_VEC(155)
-#define FMEM_READ_ERROR_IRQ		SPI_INT_VEC(156)
-#define FMEM_WRITE_ERROR_IRQ		SPI_INT_VEC(157)
-#define L2CC_ECNTR_IRQ			SPI_INT_VEC(158)
-#define L2CC_COMBINED_IRQ		SPI_INT_VEC(159)
-
-/* ==========================================================================*/
-#elif (CHIP_REV == S2L)
-#define USBVBUS_IRQ			VIC_INT_VEC(0)
-#define VOUT_IRQ			VIC_INT_VEC(1)
-#define VIN_IRQ				VIC_INT_VEC(2)
-#define CODE_VDSP_0_IRQ			VIC_INT_VEC(3)
-#define USBC_IRQ			VIC_INT_VEC(4)
-#define USB_CHARGE_IRQ			VIC_INT_VEC(5)
-#define SD2CD_IRQ			VIC_INT_VEC(6)
-#define I2STX_IRQ			VIC_INT_VEC(7)
-#define I2SRX_IRQ			VIC_INT_VEC(8)
-#define UART0_IRQ			VIC_INT_VEC(9)
-#define GPIO0_IRQ			VIC_INT_VEC(10)
-#define GPIO1_IRQ			VIC_INT_VEC(11)
-#define TIMER1_IRQ			VIC_INT_VEC(12)
-#define TIMER2_IRQ			VIC_INT_VEC(13)
-#define TIMER3_IRQ			VIC_INT_VEC(14)
-#define DMA_IRQ				VIC_INT_VEC(15)
-#define FIOCMD_IRQ			VIC_INT_VEC(16)
-#define FIODMA_IRQ			VIC_INT_VEC(17)
-#define SD_IRQ				VIC_INT_VEC(18)
-#define IDC_IRQ				VIC_INT_VEC(19)
-#define SD3_IRQ				VIC_INT_VEC(20)
-#define WDT_IRQ				VIC_INT_VEC(21)
-#define IRIF_IRQ			VIC_INT_VEC(22)
-#define SD1CD_IRQ			VIC_INT_VEC(23)
-#define SD0CD_IRQ			VIC_INT_VEC(24)
-#define UART1_IRQ			VIC_INT_VEC(25)
-#define MOTOR_IRQ			VIC_INT_VEC(26)
-#define ETH_IRQ				VIC_INT_VEC(27)
-#define USB_CONNECT_CHANGE_IRQ		VIC_INT_VEC(28)
-#define GPIO3_IRQ			VIC_INT_VEC(29)
-#define GPIO2_IRQ			VIC_INT_VEC(30)
-
-#define ETH_PMT_IRQ			VIC2_INT_VEC(0)
-#define DMA_FIOS_IRQ			VIC2_INT_VEC(1)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(2)
-#define SSI_MASTER0_IRQ			VIC2_INT_VEC(3)
-#define IDC3_IRQ			VIC2_INT_VEC(4)
-#define SSI_MASTER1_IRQ			VIC2_INT_VEC(5)
-#define SSI_SLAVE_IRQ			VIC2_INT_VEC(6)
-#define USB_EHCI_IRQ			VIC2_INT_VEC(7)
-#define HDMI_IRQ			VIC2_INT_VEC(8)
-#define FIOS_ECC_IRQ			VIC2_INT_VEC(9)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(10)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(11)
-#define USB_OHCI_IRQ			VIC2_INT_VEC(12)
-#define NOR_SPI				VIC2_INT_VEC(13)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(14)
-#define GDMA_IRQ			VIC2_INT_VEC(18)
-#define IDC2_IRQ			VIC2_INT_VEC(19)
-#define SD2_IRQ				VIC2_INT_VEC(20)
-#define IDSP_PIP_VSYNC_IRQ		VIC2_INT_VEC(21)
-#define IDSP_PIP_SOF_IRQ		VIC2_INT_VEC(22)
-#define IDSP_PIP_MVSYNC_IRQ		VIC2_INT_VEC(23)
-#define IDSP_PIP_LAST_PIXEL_IRQ		VIC2_INT_VEC(24)
-#define IDSP_PIP_DVSYNC_IRQ		VIC2_INT_VEC(25)
-#define VDSP_PIP_CODING_IRQ		VIC2_INT_VEC(26)
-#define TIMER4_IRQ			VIC2_INT_VEC(27)
-#define TIMER5_IRQ			VIC2_INT_VEC(28)
-#define TIMER6_IRQ			VIC2_INT_VEC(29)
-#define TIMER7_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
-
-#define IDSP_VIN_MVSYNC_IRQ		VIC3_INT_VEC(0)
-#define IDSP_VIN_VSYNC_IRQ		VIC3_INT_VEC(1)
-#define IDSP_VIN_SOF_IRQ		VIC3_INT_VEC(2)
-#define IDSP_VIN_DVSYNC_IRQ		VIC3_INT_VEC(3)
-#define IDSP_VIN_LAST_PIXEL_IRQ		VIC3_INT_VEC(4)
-#define L2CC_INTR_IRQ			VIC3_INT_VEC(21)
-#define MD5_IRQ				VIC3_INT_VEC(22)
-#define DES_IRQ				VIC3_INT_VEC(23)
-#define AES_IRQ				VIC3_INT_VEC(24)
-#define SHA1_IRQ			VIC3_INT_VEC(25)
-#define USB_DIGITAL_ID_CHANGE_IRQ	VIC3_INT_VEC(27)
-#define PMU_IRQ				VIC3_INT_VEC(28)
-#define L2CC_DECERR_IRQ			VIC3_INT_VEC(29)
-#define L2CC_SLVERR_IRQ			VIC3_INT_VEC(30)
-#define L2CC_ECNTR_IRQ			VIC3_INT_VEC(31)
-
-/* ==========================================================================*/
-#elif (CHIP_REV == S3)
-#define IPI00_IRQ			VIC_INT_VEC(0)
-#define IPI01_IRQ			VIC_INT_VEC(1)
-#define IPI02_IRQ			VIC_INT_VEC(2)
-#define IPI03_IRQ			VIC_INT_VEC(3)
-#define IPI04_IRQ			VIC_INT_VEC(4)
-#define IPI05_IRQ			VIC_INT_VEC(5)
-#define IPI06_IRQ			VIC_INT_VEC(6)
-#define TIMER1_IRQ			VIC_INT_VEC(7)
-#define TIMER2_IRQ			VIC_INT_VEC(8)
-#define TIMER3_IRQ			VIC_INT_VEC(9)
-#define TIMER4_IRQ			VIC_INT_VEC(10)
-#define TIMER5_IRQ			VIC_INT_VEC(11)
-#define TIMER6_IRQ			VIC_INT_VEC(12)
-#define TIMER7_IRQ			VIC_INT_VEC(13)
-#define TIMER8_IRQ			VIC_INT_VEC(14)
-#define PMU_IRQ				VIC_INT_VEC(15)
-#define IPI10_IRQ			VIC_INT_VEC(16)
-#define IPI11_IRQ			VIC_INT_VEC(17)
-#define IPI12_IRQ			VIC_INT_VEC(18)
-#define IPI13_IRQ			VIC_INT_VEC(19)
-#define IPI14_IRQ			VIC_INT_VEC(20)
-#define IPI15_IRQ			VIC_INT_VEC(21)
-#define IPI16_IRQ			VIC_INT_VEC(22)
-#define TIMER11_IRQ			VIC_INT_VEC(23)
-#define TIMER12_IRQ			VIC_INT_VEC(24)
-#define TIMER13_IRQ			VIC_INT_VEC(25)
-#define TIMER14_IRQ			VIC_INT_VEC(26)
-#define TIMER15_IRQ			VIC_INT_VEC(27)
-#define TIMER16_IRQ			VIC_INT_VEC(28)
-#define TIMER17_IRQ			VIC_INT_VEC(29)
-#define TIMER18_IRQ			VIC_INT_VEC(30)
-#define PMU1_IRQ			VIC_INT_VEC(31)
-
-#define IDSP_VIN_STAT_IRQ		VIC2_INT_VEC(0)
-#define IDSP_VIN_MVSYNC_IRQ		VIC2_INT_VEC(1)
-#define IDSP_VIN_VSYNC_IRQ		VIC2_INT_VEC(2)
-#define IDSP_VIN_SOF_IRQ		VIC2_INT_VEC(3)
-#define IDSP_VIN_DVSYNC_IRQ		VIC2_INT_VEC(4)
-#define IDSP_VIN_LAST_PIXEL_IRQ		VIC2_INT_VEC(5)
-#define IDSP_PIP_STAT_IRQ		VIC2_INT_VEC(6)
-#define IDSP_PIP_MVSYNC_IRQ		VIC2_INT_VEC(7)
-#define IDSP_PIP_VSYNC_IRQ		VIC2_INT_VEC(8)
-#define IDSP_PIP_SOF_IRQ		VIC2_INT_VEC(9)
-#define IDSP_PIP_DVSYNC_IRQ		VIC2_INT_VEC(10)
-#define IDSP_PIP_LAST_PIXEL_IRQ		VIC2_INT_VEC(11)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(12)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(13)
-#define CODE_VDSP_0_IRQ			VIC2_INT_VEC(14)
-#define CODE_VDSP_1_IRQ			VIC2_INT_VEC(15)
-#define CODE_VDSP_2_IRQ			VIC2_INT_VEC(16)
-#define CODE_VDSP_3_IRQ			VIC2_INT_VEC(17)
-#define CODE_VDSP_4_IRQ			VIC2_INT_VEC(18)
-#define CODE_VDSP_5_IRQ			VIC2_INT_VEC(19)
-#define CODE_VDSP_6_IRQ			VIC2_INT_VEC(20)
-#define CODE_VDSP_7_IRQ			VIC2_INT_VEC(21)
-#define VIN_IRQ				VIC2_INT_VEC(22)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(23)
-#define VOUT_IRQ			VIC2_INT_VEC(24)
-#define VDSP_ORC_BKPT_IRQ		VIC2_INT_VEC(25)
-#define VDSP_EORC0_BKPT_IRQ		VIC2_INT_VEC(26)
-#define VDSP_DORC_BRPT_IRQ		VIC2_INT_VEC(27)
-#define VDSP_PIP_CODING_IRQ		VIC2_INT_VEC(28)
-#define FDET_IRQ			VIC2_INT_VEC(29)
-#define TIMER10_IRQ			VIC2_INT_VEC(30)
-#define TIMER9_IRQ			VIC2_INT_VEC(31)
-
-#define CANC_IRQ			VIC3_INT_VEC(0)
-#define ETH_IRQ				VIC3_INT_VEC(1)
-#define USB_EHCI_IRQ			VIC3_INT_VEC(2)
-#define USB_OHCI_IRQ			VIC3_INT_VEC(3)
-#define USBC_IRQ			VIC3_INT_VEC(4)
-#define DMA_IRQ				VIC3_INT_VEC(5)
-#define DMA_FIOS_IRQ			VIC3_INT_VEC(6)
-#define FIOS_ECC_IRQ			VIC3_INT_VEC(7)
-#define FIOCMD_IRQ			VIC3_INT_VEC(8)
-#define FIODMA_IRQ			VIC3_INT_VEC(9)
-#define GDMA_IRQ			VIC3_INT_VEC(10)
-#define SD3_IRQ				VIC3_INT_VEC(11)
-#define SD2_IRQ				VIC3_INT_VEC(12)
-#define SD_IRQ				VIC3_INT_VEC(13)
-#define NOR_SPI				VIC3_INT_VEC(14)
-#define SSI_MASTER1_IRQ			VIC3_INT_VEC(15)
-#define SSI_MASTER0_IRQ			VIC3_INT_VEC(16)
-#define SSI_SLAVE_IRQ			VIC3_INT_VEC(17)
-#define UART1_IRQ			VIC3_INT_VEC(18)
-#define IDC3_IRQ			VIC3_INT_VEC(19)
-#define IDC2_IRQ			VIC3_INT_VEC(20)
-#define IDC_IRQ				VIC3_INT_VEC(21)
-#define IRIF_IRQ			VIC3_INT_VEC(22)
-#define I2STX_IRQ			VIC3_INT_VEC(23)
-#define I2SRX_IRQ			VIC3_INT_VEC(24)
-#define IDC_SLAVE_IRQ			VIC3_INT_VEC(25)
-#define HIF_ARM2_IRQ			VIC3_INT_VEC(26)
-#define HIF_ARM1_IRQ			VIC3_INT_VEC(27)
-#define TS_CH1_RX_IRQ			VIC3_INT_VEC(28)
-#define TS_CH0_RX_IRQ			VIC3_INT_VEC(29)
-#define TS_CH1_TX_IRQ			VIC3_INT_VEC(30)
-#define TS_CH0_TX_IRQ			VIC3_INT_VEC(31)
-
-#define USBVBUS_IRQ			VIC4_INT_VEC(0)
-#define USB_DIGITAL_ID_CHANGE_IRQ	VIC4_INT_VEC(1)
-#define USB_CONNECT_CHANGE_IRQ		VIC4_INT_VEC(2)
-#define USB_CHARGE_IRQ			VIC4_INT_VEC(3)
-#define SD2CD_IRQ			VIC4_INT_VEC(4)
-#define SD1CD_IRQ			VIC4_INT_VEC(5)
-#define SD0CD_IRQ			VIC4_INT_VEC(6)
-#define ADC_LEVEL_IRQ			VIC4_INT_VEC(7)
-#define HDMI_IRQ			VIC4_INT_VEC(8)
-#define WDT_IRQ				VIC4_INT_VEC(9)
-#define SLIM_IRQ			VIC4_INT_VEC(10)
-#define ETH_PMT_IRQ			VIC4_INT_VEC(11)
-#define UART0_IRQ			VIC4_INT_VEC(12)
-#define MOTOR_IRQ			VIC4_INT_VEC(13)
-#define SHA1_IRQ			VIC4_INT_VEC(14)
-#define AES_IRQ				VIC4_INT_VEC(15)
-#define DES_IRQ				VIC4_INT_VEC(16)
-#define MD5_IRQ				VIC4_INT_VEC(17)
-#define L2CC_INTR_IRQ			VIC4_INT_VEC(18)
-#define L2CC_INTR1_IRQ			VIC4_INT_VEC(19)
-#define AXI_SWI_IRQ			VIC4_INT_VEC(20)
-#define AXI_SWI1_IRQ			VIC4_INT_VEC(21)
-#define GPIO6_IRQ			VIC4_INT_VEC(22)
-#define GPIO5_IRQ			VIC4_INT_VEC(23)
-#define GPIO4_IRQ			VIC4_INT_VEC(24)
-#define GPIO3_IRQ			VIC4_INT_VEC(25)
-#define GPIO2_IRQ			VIC4_INT_VEC(26)
-#define GPIO1_IRQ			VIC4_INT_VEC(27)
-#define GPIO0_IRQ			VIC4_INT_VEC(28)
-#define DMIC_IRQ			VIC4_INT_VEC(29)
-#define TIMER20_IRQ			VIC4_INT_VEC(30)
-#define TIMER19_IRQ			VIC4_INT_VEC(31)
-
-/* ==========================================================================*/
-#elif (CHIP_REV == S3L)
-#define TIMER1_IRQ			VIC_INT_VEC(0)
-#define TIMER2_IRQ			VIC_INT_VEC(1)
-#define TIMER3_IRQ			VIC_INT_VEC(2)
-#define TIMER4_IRQ			VIC_INT_VEC(3)
-#define TIMER5_IRQ			VIC_INT_VEC(4)
-#define TIMER6_IRQ			VIC_INT_VEC(5)
-#define TIMER7_IRQ			VIC_INT_VEC(6)
-#define AXI_SOFT_IRQ(x)			VIC_INT_VEC((x) + 7)	/* 0 <= x <= 13 */
-#define AXI_SW_IRQ0			VIC_INT_VEC(21)
-#define AXI_SW_IRQ1			VIC_INT_VEC(22)
-#define PMU_IRQ				VIC_INT_VEC(23)
-#define L2CC_INTR_IRQ			VIC_INT_VEC(24)
-#define L2CC_DECERR_IRQ			VIC_INT_VEC(25)
-#define L2CC_SLVERR_IRQ			VIC_INT_VEC(26)
-#define L2CC_ECNTR_IRQ			VIC_INT_VEC(27)
-#define MD5_IRQ				VIC_INT_VEC(28)
-#define DES_IRQ				VIC_INT_VEC(29)
-#define AES_IRQ				VIC_INT_VEC(30)
-#define SHA1_IRQ			VIC_INT_VEC(31)
+#if (CHIP_REV == S2L)
+#define USBVBUS_IRQ			VIC0_INT_VEC(0)
+#define VOUT_IRQ			VIC0_INT_VEC(1)
+#define VIN_IRQ				VIC0_INT_VEC(2)
+#define CODE_VDSP_0_IRQ			VIC0_INT_VEC(3)
+#define USBC_IRQ			VIC0_INT_VEC(4)
+#define USB_CHARGE_IRQ			VIC0_INT_VEC(5)
+#define SD2CD_IRQ			VIC0_INT_VEC(6)
+#define I2STX_IRQ			VIC0_INT_VEC(7)
+#define I2SRX_IRQ			VIC0_INT_VEC(8)
+#define UART0_IRQ			VIC0_INT_VEC(9)
+#define GPIO0_IRQ			VIC0_INT_VEC(10)
+#define GPIO1_IRQ			VIC0_INT_VEC(11)
+#define TIMER1_IRQ			VIC0_INT_VEC(12)
+#define TIMER2_IRQ			VIC0_INT_VEC(13)
+#define TIMER3_IRQ			VIC0_INT_VEC(14)
+#define DMA_IRQ				VIC0_INT_VEC(15)
+#define FIOCMD_IRQ			VIC0_INT_VEC(16)
+#define FIODMA_IRQ			VIC0_INT_VEC(17)
+#define SD_IRQ				VIC0_INT_VEC(18)
+#define IDC_IRQ				VIC0_INT_VEC(19)
+#define SD3_IRQ				VIC0_INT_VEC(20)
+#define WDT_IRQ				VIC0_INT_VEC(21)
+#define IRIF_IRQ			VIC0_INT_VEC(22)
+#define SD1CD_IRQ			VIC0_INT_VEC(23)
+#define SD0CD_IRQ			VIC0_INT_VEC(24)
+#define UART1_IRQ			VIC0_INT_VEC(25)
+#define MOTOR_IRQ			VIC0_INT_VEC(26)
+#define ETH_IRQ				VIC0_INT_VEC(27)
+#define USB_CONNECT_CHANGE_IRQ		VIC0_INT_VEC(28)
+#define GPIO3_IRQ			VIC0_INT_VEC(29)
+#define GPIO2_IRQ			VIC0_INT_VEC(30)
+
+#define ETH_PMT_IRQ			VIC1_INT_VEC(0)
+#define DMA_FIOS_IRQ			VIC1_INT_VEC(1)
+#define ADC_LEVEL_IRQ			VIC1_INT_VEC(2)
+#define SSI_MASTER0_IRQ			VIC1_INT_VEC(3)
+#define IDC3_IRQ			VIC1_INT_VEC(4)
+#define SSI_MASTER1_IRQ			VIC1_INT_VEC(5)
+#define SSI_SLAVE_IRQ			VIC1_INT_VEC(6)
+#define USB_EHCI_IRQ			VIC1_INT_VEC(7)
+#define HDMI_IRQ			VIC1_INT_VEC(8)
+#define FIOS_ECC_IRQ			VIC1_INT_VEC(9)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(10)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(11)
+#define USB_OHCI_IRQ			VIC1_INT_VEC(12)
+#define NOR_SPI				VIC1_INT_VEC(13)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(14)
+#define GDMA_IRQ			VIC1_INT_VEC(18)
+#define IDC2_IRQ			VIC1_INT_VEC(19)
+#define SD2_IRQ				VIC1_INT_VEC(20)
+#define IDSP_PIP_VSYNC_IRQ		VIC1_INT_VEC(21)
+#define IDSP_PIP_SOF_IRQ		VIC1_INT_VEC(22)
+#define IDSP_PIP_MVSYNC_IRQ		VIC1_INT_VEC(23)
+#define IDSP_PIP_LAST_PIXEL_IRQ		VIC1_INT_VEC(24)
+#define IDSP_PIP_DVSYNC_IRQ		VIC1_INT_VEC(25)
+#define VDSP_PIP_CODING_IRQ		VIC1_INT_VEC(26)
+#define TIMER4_IRQ			VIC1_INT_VEC(27)
+#define TIMER5_IRQ			VIC1_INT_VEC(28)
+#define TIMER6_IRQ			VIC1_INT_VEC(29)
+#define TIMER7_IRQ			VIC1_INT_VEC(30)
+#define TIMER8_IRQ			VIC1_INT_VEC(31)
 
 #define IDSP_VIN_MVSYNC_IRQ		VIC2_INT_VEC(0)
 #define IDSP_VIN_VSYNC_IRQ		VIC2_INT_VEC(1)
 #define IDSP_VIN_SOF_IRQ		VIC2_INT_VEC(2)
 #define IDSP_VIN_DVSYNC_IRQ		VIC2_INT_VEC(3)
 #define IDSP_VIN_LAST_PIXEL_IRQ		VIC2_INT_VEC(4)
-#define GDMA_IRQ			VIC2_INT_VEC(5)
-#define IDSP_PIP_MVSYNC_IRQ		VIC2_INT_VEC(6)
-#define IDSP_PIP_VSYNC_IRQ		VIC2_INT_VEC(7)
-#define IDSP_PIP_SOF_IRQ		VIC2_INT_VEC(8)
-#define IDSP_PIP_DVSYNC_IRQ		VIC2_INT_VEC(9)
-#define IDSP_PIP_LAST_PIXEL_IRQ		VIC2_INT_VEC(10)
-#define VOUT_TV_SYNC_IRQ		VIC2_INT_VEC(11)
-#define VOUT_LCD_SYNC_IRQ		VIC2_INT_VEC(12)
-#define CODE_VDSP_0_IRQ			VIC2_INT_VEC(13)
-#define CODE_VDSP_1_IRQ			VIC2_INT_VEC(14)
-#define CODE_VDSP_2_IRQ			VIC2_INT_VEC(15)
-#define CODE_VDSP_3_IRQ			VIC2_INT_VEC(16)
-#define GPIO3_IRQ			VIC2_INT_VEC(17)
-#define GPIO2_IRQ			VIC2_INT_VEC(18)
-#define GPIO1_IRQ			VIC2_INT_VEC(19)
-#define GPIO0_IRQ			VIC2_INT_VEC(20)
-#define VIN_IRQ				VIC2_INT_VEC(21)
-#define VOUT_IRQ			VIC2_INT_VEC(22)
-#define ORC_VOUT0_IRQ			VIC2_INT_VEC(23)
-#define VDSP_PIP_CODING_IRQ		VIC2_INT_VEC(24)
-#define ADC_LEVEL_IRQ			VIC2_INT_VEC(25)
-#define HDMI_IRQ			VIC2_INT_VEC(26)
-#define WDT_IRQ				VIC2_INT_VEC(27)
-#define ETH_PMT_IRQ			VIC2_INT_VEC(28)
-#define UART0_IRQ			VIC2_INT_VEC(29)
-#define MOTOR_IRQ			VIC2_INT_VEC(30)
-#define TIMER8_IRQ			VIC2_INT_VEC(31)
+#define L2CC_INTR_IRQ			VIC2_INT_VEC(21)
+#define MD5_IRQ				VIC2_INT_VEC(22)
+#define DES_IRQ				VIC2_INT_VEC(23)
+#define AES_IRQ				VIC2_INT_VEC(24)
+#define SHA1_IRQ			VIC2_INT_VEC(25)
+#define USB_DIGITAL_ID_CHANGE_IRQ	VIC2_INT_VEC(27)
+#define PMU_IRQ				VIC2_INT_VEC(28)
+#define L2CC_DECERR_IRQ			VIC2_INT_VEC(29)
+#define L2CC_SLVERR_IRQ			VIC2_INT_VEC(30)
+#define L2CC_ECNTR_IRQ			VIC2_INT_VEC(31)
+
+#define NR_IRQS				VIC2_INT_VEC(32)
 
-#define PWC_ALRAM			VIC3_INT_VEC(0)
-#define ETH_IRQ				VIC3_INT_VEC(1)
-#define USB_EHCI_IRQ			VIC3_INT_VEC(2)
-#define USB_OHCI_IRQ			VIC3_INT_VEC(3)
-#define USBC_IRQ			VIC3_INT_VEC(4)
-#define DMA_IRQ				VIC3_INT_VEC(5)
-#define DMA_FIOS_IRQ			VIC3_INT_VEC(6)
-#define FIOS_ECC_IRQ			VIC3_INT_VEC(7)
-#define FIOCMD_IRQ			VIC3_INT_VEC(8)
-#define FIODMA_IRQ			VIC3_INT_VEC(9)
-#define SD2_IRQ				VIC3_INT_VEC(10) /* SDXC rather than SDIO */
-#define SD_IRQ				VIC3_INT_VEC(11)
-#define NOR_SPI				VIC3_INT_VEC(12)
-#define SSI_MASTER1_IRQ			VIC3_INT_VEC(13)
-#define SSI_MASTER0_IRQ			VIC3_INT_VEC(14)
-#define SSI_SLAVE_IRQ			VIC3_INT_VEC(15)
-#define UART1_IRQ			VIC3_INT_VEC(16)
-#define IDC3_IRQ			VIC3_INT_VEC(17)
-#define IDC2_IRQ			VIC3_INT_VEC(18)
-#define IDC_IRQ				VIC3_INT_VEC(19)
-#define IRIF_IRQ			VIC3_INT_VEC(20)
-#define I2STX_IRQ			VIC3_INT_VEC(21)
-#define I2SRX_IRQ			VIC3_INT_VEC(22)
-#define USBVBUS_IRQ			VIC3_INT_VEC(23)
-#define USB_DIGITAL_ID_CHANGE_IRQ	VIC3_INT_VEC(24)
-#define USB_CONNECT_CHANGE_IRQ		VIC3_INT_VEC(25)
-#define USB_CHARGE_IRQ			VIC3_INT_VEC(26)
-#define SD2CD_IRQ			VIC3_INT_VEC(27) /* SDXC rather than SDIO */
-#define SD0CD_IRQ			VIC3_INT_VEC(28)
+/* ==========================================================================*/
+#elif (CHIP_REV == S3)
+#define IPI00_IRQ			VIC0_INT_VEC(0)
+#define IPI01_IRQ			VIC0_INT_VEC(1)
+#define IPI02_IRQ			VIC0_INT_VEC(2)
+#define IPI03_IRQ			VIC0_INT_VEC(3)
+#define IPI04_IRQ			VIC0_INT_VEC(4)
+#define IPI05_IRQ			VIC0_INT_VEC(5)
+#define IPI06_IRQ			VIC0_INT_VEC(6)
+#define TIMER1_IRQ			VIC0_INT_VEC(7)
+#define TIMER2_IRQ			VIC0_INT_VEC(8)
+#define TIMER3_IRQ			VIC0_INT_VEC(9)
+#define TIMER4_IRQ			VIC0_INT_VEC(10)
+#define TIMER5_IRQ			VIC0_INT_VEC(11)
+#define TIMER6_IRQ			VIC0_INT_VEC(12)
+#define TIMER7_IRQ			VIC0_INT_VEC(13)
+#define TIMER8_IRQ			VIC0_INT_VEC(14)
+#define PMU_IRQ				VIC0_INT_VEC(15)
+#define IPI10_IRQ			VIC0_INT_VEC(16)
+#define IPI11_IRQ			VIC0_INT_VEC(17)
+#define IPI12_IRQ			VIC0_INT_VEC(18)
+#define IPI13_IRQ			VIC0_INT_VEC(19)
+#define IPI14_IRQ			VIC0_INT_VEC(20)
+#define IPI15_IRQ			VIC0_INT_VEC(21)
+#define IPI16_IRQ			VIC0_INT_VEC(22)
+#define TIMER11_IRQ			VIC0_INT_VEC(23)
+#define TIMER12_IRQ			VIC0_INT_VEC(24)
+#define TIMER13_IRQ			VIC0_INT_VEC(25)
+#define TIMER14_IRQ			VIC0_INT_VEC(26)
+#define TIMER15_IRQ			VIC0_INT_VEC(27)
+#define TIMER16_IRQ			VIC0_INT_VEC(28)
+#define TIMER17_IRQ			VIC0_INT_VEC(29)
+#define TIMER18_IRQ			VIC0_INT_VEC(30)
+#define PMU1_IRQ			VIC0_INT_VEC(31)
+
+#define IDSP_VIN_STAT_IRQ		VIC1_INT_VEC(0)
+#define IDSP_VIN_MVSYNC_IRQ		VIC1_INT_VEC(1)
+#define IDSP_VIN_VSYNC_IRQ		VIC1_INT_VEC(2)
+#define IDSP_VIN_SOF_IRQ		VIC1_INT_VEC(3)
+#define IDSP_VIN_DVSYNC_IRQ		VIC1_INT_VEC(4)
+#define IDSP_VIN_LAST_PIXEL_IRQ		VIC1_INT_VEC(5)
+#define IDSP_PIP_STAT_IRQ		VIC1_INT_VEC(6)
+#define IDSP_PIP_MVSYNC_IRQ		VIC1_INT_VEC(7)
+#define IDSP_PIP_VSYNC_IRQ		VIC1_INT_VEC(8)
+#define IDSP_PIP_SOF_IRQ		VIC1_INT_VEC(9)
+#define IDSP_PIP_DVSYNC_IRQ		VIC1_INT_VEC(10)
+#define IDSP_PIP_LAST_PIXEL_IRQ		VIC1_INT_VEC(11)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(12)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(13)
+#define CODE_VDSP_0_IRQ			VIC1_INT_VEC(14)
+#define CODE_VDSP_1_IRQ			VIC1_INT_VEC(15)
+#define CODE_VDSP_2_IRQ			VIC1_INT_VEC(16)
+#define CODE_VDSP_3_IRQ			VIC1_INT_VEC(17)
+#define CODE_VDSP_4_IRQ			VIC1_INT_VEC(18)
+#define CODE_VDSP_5_IRQ			VIC1_INT_VEC(19)
+#define CODE_VDSP_6_IRQ			VIC1_INT_VEC(20)
+#define CODE_VDSP_7_IRQ			VIC1_INT_VEC(21)
+#define VIN_IRQ				VIC1_INT_VEC(22)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(23)
+#define VOUT_IRQ			VIC1_INT_VEC(24)
+#define VDSP_ORC_BKPT_IRQ		VIC1_INT_VEC(25)
+#define VDSP_EORC0_BKPT_IRQ		VIC1_INT_VEC(26)
+#define VDSP_DORC_BRPT_IRQ		VIC1_INT_VEC(27)
+#define VDSP_PIP_CODING_IRQ		VIC1_INT_VEC(28)
+#define FDET_IRQ			VIC1_INT_VEC(29)
+#define TIMER10_IRQ			VIC1_INT_VEC(30)
+#define TIMER9_IRQ			VIC1_INT_VEC(31)
+
+#define CANC_IRQ			VIC2_INT_VEC(0)
+#define ETH_IRQ				VIC2_INT_VEC(1)
+#define USB_EHCI_IRQ			VIC2_INT_VEC(2)
+#define USB_OHCI_IRQ			VIC2_INT_VEC(3)
+#define USBC_IRQ			VIC2_INT_VEC(4)
+#define DMA_IRQ				VIC2_INT_VEC(5)
+#define DMA_FIOS_IRQ			VIC2_INT_VEC(6)
+#define FIOS_ECC_IRQ			VIC2_INT_VEC(7)
+#define FIOCMD_IRQ			VIC2_INT_VEC(8)
+#define FIODMA_IRQ			VIC2_INT_VEC(9)
+#define GDMA_IRQ			VIC2_INT_VEC(10)
+#define SD3_IRQ				VIC2_INT_VEC(11)
+#define SD2_IRQ				VIC2_INT_VEC(12)
+#define SD_IRQ				VIC2_INT_VEC(13)
+#define NOR_SPI				VIC2_INT_VEC(14)
+#define SSI_MASTER1_IRQ			VIC2_INT_VEC(15)
+#define SSI_MASTER0_IRQ			VIC2_INT_VEC(16)
+#define SSI_SLAVE_IRQ			VIC2_INT_VEC(17)
+#define UART1_IRQ			VIC2_INT_VEC(18)
+#define IDC3_IRQ			VIC2_INT_VEC(19)
+#define IDC2_IRQ			VIC2_INT_VEC(20)
+#define IDC_IRQ				VIC2_INT_VEC(21)
+#define IRIF_IRQ			VIC2_INT_VEC(22)
+#define I2STX_IRQ			VIC2_INT_VEC(23)
+#define I2SRX_IRQ			VIC2_INT_VEC(24)
+#define IDC_SLAVE_IRQ			VIC2_INT_VEC(25)
+#define HIF_ARM2_IRQ			VIC2_INT_VEC(26)
+#define HIF_ARM1_IRQ			VIC2_INT_VEC(27)
+#define TS_CH1_RX_IRQ			VIC2_INT_VEC(28)
+#define TS_CH0_RX_IRQ			VIC2_INT_VEC(29)
+#define TS_CH1_TX_IRQ			VIC2_INT_VEC(30)
+#define TS_CH0_TX_IRQ			VIC2_INT_VEC(31)
+
+#define USBVBUS_IRQ			VIC3_INT_VEC(0)
+#define USB_DIGITAL_ID_CHANGE_IRQ	VIC3_INT_VEC(1)
+#define USB_CONNECT_CHANGE_IRQ		VIC3_INT_VEC(2)
+#define USB_CHARGE_IRQ			VIC3_INT_VEC(3)
+#define SD2CD_IRQ			VIC3_INT_VEC(4)
+#define SD1CD_IRQ			VIC3_INT_VEC(5)
+#define SD0CD_IRQ			VIC3_INT_VEC(6)
+#define ADC_LEVEL_IRQ			VIC3_INT_VEC(7)
+#define HDMI_IRQ			VIC3_INT_VEC(8)
+#define WDT_IRQ				VIC3_INT_VEC(9)
+#define SLIM_IRQ			VIC3_INT_VEC(10)
+#define ETH_PMT_IRQ			VIC3_INT_VEC(11)
+#define UART0_IRQ			VIC3_INT_VEC(12)
+#define MOTOR_IRQ			VIC3_INT_VEC(13)
+#define SHA1_IRQ			VIC3_INT_VEC(14)
+#define AES_IRQ				VIC3_INT_VEC(15)
+#define DES_IRQ				VIC3_INT_VEC(16)
+#define MD5_IRQ				VIC3_INT_VEC(17)
+#define L2CC_INTR_IRQ			VIC3_INT_VEC(18)
+#define L2CC_INTR1_IRQ			VIC3_INT_VEC(19)
+#define AXI_SWI_IRQ			VIC3_INT_VEC(20)
+#define AXI_SWI1_IRQ			VIC3_INT_VEC(21)
+#define GPIO6_IRQ			VIC3_INT_VEC(22)
+#define GPIO5_IRQ			VIC3_INT_VEC(23)
+#define GPIO4_IRQ			VIC3_INT_VEC(24)
+#define GPIO3_IRQ			VIC3_INT_VEC(25)
+#define GPIO2_IRQ			VIC3_INT_VEC(26)
+#define GPIO1_IRQ			VIC3_INT_VEC(27)
+#define GPIO0_IRQ			VIC3_INT_VEC(28)
+#define DMIC_IRQ			VIC3_INT_VEC(29)
+#define TIMER20_IRQ			VIC3_INT_VEC(30)
+#define TIMER19_IRQ			VIC3_INT_VEC(31)
+
+#define NR_IRQS				VIC3_INT_VEC(32)
+
+/* ==========================================================================*/
+#elif (CHIP_REV == S3L)
+#define TIMER1_IRQ			VIC0_INT_VEC(0)
+#define TIMER2_IRQ			VIC0_INT_VEC(1)
+#define TIMER3_IRQ			VIC0_INT_VEC(2)
+#define TIMER4_IRQ			VIC0_INT_VEC(3)
+#define TIMER5_IRQ			VIC0_INT_VEC(4)
+#define TIMER6_IRQ			VIC0_INT_VEC(5)
+#define TIMER7_IRQ			VIC0_INT_VEC(6)
+#define AXI_SOFT_IRQ(x)			VIC0_INT_VEC((x) + 7)	/* 0 <= x <= 13 */
+#define AXI_SW_IRQ0			VIC0_INT_VEC(21)
+#define AXI_SW_IRQ1			VIC0_INT_VEC(22)
+#define PMU_IRQ				VIC0_INT_VEC(23)
+#define L2CC_INTR_IRQ			VIC0_INT_VEC(24)
+#define L2CC_DECERR_IRQ			VIC0_INT_VEC(25)
+#define L2CC_SLVERR_IRQ			VIC0_INT_VEC(26)
+#define L2CC_ECNTR_IRQ			VIC0_INT_VEC(27)
+#define MD5_IRQ				VIC0_INT_VEC(28)
+#define DES_IRQ				VIC0_INT_VEC(29)
+#define AES_IRQ				VIC0_INT_VEC(30)
+#define SHA1_IRQ			VIC0_INT_VEC(31)
+
+#define IDSP_VIN_MVSYNC_IRQ		VIC1_INT_VEC(0)
+#define IDSP_VIN_VSYNC_IRQ		VIC1_INT_VEC(1)
+#define IDSP_VIN_SOF_IRQ		VIC1_INT_VEC(2)
+#define IDSP_VIN_DVSYNC_IRQ		VIC1_INT_VEC(3)
+#define IDSP_VIN_LAST_PIXEL_IRQ		VIC1_INT_VEC(4)
+#define GDMA_IRQ			VIC1_INT_VEC(5)
+#define IDSP_PIP_MVSYNC_IRQ		VIC1_INT_VEC(6)
+#define IDSP_PIP_VSYNC_IRQ		VIC1_INT_VEC(7)
+#define IDSP_PIP_SOF_IRQ		VIC1_INT_VEC(8)
+#define IDSP_PIP_DVSYNC_IRQ		VIC1_INT_VEC(9)
+#define IDSP_PIP_LAST_PIXEL_IRQ		VIC1_INT_VEC(10)
+#define VOUT_TV_SYNC_IRQ		VIC1_INT_VEC(11)
+#define VOUT_LCD_SYNC_IRQ		VIC1_INT_VEC(12)
+#define CODE_VDSP_0_IRQ			VIC1_INT_VEC(13)
+#define CODE_VDSP_1_IRQ			VIC1_INT_VEC(14)
+#define CODE_VDSP_2_IRQ			VIC1_INT_VEC(15)
+#define CODE_VDSP_3_IRQ			VIC1_INT_VEC(16)
+#define GPIO3_IRQ			VIC1_INT_VEC(17)
+#define GPIO2_IRQ			VIC1_INT_VEC(18)
+#define GPIO1_IRQ			VIC1_INT_VEC(19)
+#define GPIO0_IRQ			VIC1_INT_VEC(20)
+#define VIN_IRQ				VIC1_INT_VEC(21)
+#define VOUT_IRQ			VIC1_INT_VEC(22)
+#define ORC_VOUT0_IRQ			VIC1_INT_VEC(23)
+#define VDSP_PIP_CODING_IRQ		VIC1_INT_VEC(24)
+#define ADC_LEVEL_IRQ			VIC1_INT_VEC(25)
+#define HDMI_IRQ			VIC1_INT_VEC(26)
+#define WDT_IRQ				VIC1_INT_VEC(27)
+#define ETH_PMT_IRQ			VIC1_INT_VEC(28)
+#define UART0_IRQ			VIC1_INT_VEC(29)
+#define MOTOR_IRQ			VIC1_INT_VEC(30)
+#define TIMER8_IRQ			VIC1_INT_VEC(31)
+
+#define PWC_ALRAM			VIC2_INT_VEC(0)
+#define ETH_IRQ				VIC2_INT_VEC(1)
+#define USB_EHCI_IRQ			VIC2_INT_VEC(2)
+#define USB_OHCI_IRQ			VIC2_INT_VEC(3)
+#define USBC_IRQ			VIC2_INT_VEC(4)
+#define DMA_IRQ				VIC2_INT_VEC(5)
+#define DMA_FIOS_IRQ			VIC2_INT_VEC(6)
+#define FIOS_ECC_IRQ			VIC2_INT_VEC(7)
+#define FIOCMD_IRQ			VIC2_INT_VEC(8)
+#define FIODMA_IRQ			VIC2_INT_VEC(9)
+#define SD2_IRQ				VIC2_INT_VEC(10) /* SDXC rather than SDIO */
+#define SD_IRQ				VIC2_INT_VEC(11)
+#define NOR_SPI				VIC2_INT_VEC(12)
+#define SSI_MASTER1_IRQ			VIC2_INT_VEC(13)
+#define SSI_MASTER0_IRQ			VIC2_INT_VEC(14)
+#define SSI_SLAVE_IRQ			VIC2_INT_VEC(15)
+#define UART1_IRQ			VIC2_INT_VEC(16)
+#define IDC3_IRQ			VIC2_INT_VEC(17)
+#define IDC2_IRQ			VIC2_INT_VEC(18)
+#define IDC_IRQ				VIC2_INT_VEC(19)
+#define IRIF_IRQ			VIC2_INT_VEC(20)
+#define I2STX_IRQ			VIC2_INT_VEC(21)
+#define I2SRX_IRQ			VIC2_INT_VEC(22)
+#define USBVBUS_IRQ			VIC2_INT_VEC(23)
+#define USB_DIGITAL_ID_CHANGE_IRQ	VIC2_INT_VEC(24)
+#define USB_CONNECT_CHANGE_IRQ		VIC2_INT_VEC(25)
+#define USB_CHARGE_IRQ			VIC2_INT_VEC(26)
+#define SD2CD_IRQ			VIC2_INT_VEC(27) /* SDXC rather than SDIO */
+#define SD0CD_IRQ			VIC2_INT_VEC(28)
+
+#define NR_IRQS				VIC2_INT_VEC(29)
 
 /* ==========================================================================*/
 #else
 #error "Not supported!"
 #endif
 
-/* ==========================================================================*/
-#define VIRQ_RISING_EDGE	0
-#define VIRQ_FALLING_EDGE	1
-#define VIRQ_BOTH_EDGES		2
-#define VIRQ_LEVEL_LOW		3
-#define VIRQ_LEVEL_HIGH		4
 
 /* ==========================================================================*/
 #ifndef __ASM__
 /* ==========================================================================*/
-
-extern void enable_interrupts(void);
-extern void disable_interrupts(void);
-extern void vic_init(void);
-extern void vic_set_type(u32 line, u32 type);
-extern void vic_enable(u32 line);
-extern void vic_disable(u32 line);
-extern void vic_ackint(u32 line);
-extern void vic_sw_set(u32 line);
-extern void vic_sw_clr(u32 line);
-
 /* ==========================================================================*/
 #endif
 /* ==========================================================================*/
diff --git a/include/amboot.h b/include/amboot.h
index 9a4f170..198fc27 100644
--- a/include/amboot.h
+++ b/include/amboot.h
@@ -3,12 +3,30 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __AMBOOT_H__
@@ -18,6 +36,18 @@
 #include <config.h>
 #include <basedef.h>
 
+/*
+ * bit [32 - 16]: unused, should be 0
+ * bit [15 - 8]: major version
+ * bit [ 7 - 0]: minor version
+ */
+#define AMBOOT_MAJOR_VER			0x3
+#define AMBOOT_MINOR_VER			0x5
+#define amboot_show_version()			printf("Version: %d.%d - %s\n",	\
+							AMBOOT_MAJOR_VER,	\
+							AMBOOT_MINOR_VER,	\
+							__BUILD_TIME__)
+
 /*===========================================================================*/
 #define AMBARELLA_BOARD_TYPE_AUTO		(0)
 #define AMBARELLA_BOARD_TYPE_BUB		(1)
@@ -44,7 +74,7 @@
 
 /* ==========================================================================*/
 #ifndef __ASM__
-
+#include <vsprintf.h>
 #endif
 /* ==========================================================================*/
 
diff --git a/include/basedef.h b/include/basedef.h
index 5ba763b..39a434d 100644
--- a/include/basedef.h
+++ b/include/basedef.h
@@ -4,12 +4,30 @@
  * History:
  *    2004/10/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __BASEDEF_H__
@@ -27,6 +45,12 @@ typedef signed int		s32;	/**< SIGNED 32-bit data type */
 typedef signed long long	s64;	/**< SIGNED 64-bit data type */
 typedef unsigned long		uintptr_t;
 
+#ifdef CONFIG_ARMV8_AARCH32
+typedef unsigned int		size_t;
+#else
+typedef unsigned long		size_t;
+#endif
+
 #ifndef NULL
 #define NULL ((void *) 0x0)
 #endif
diff --git a/include/debug.h b/include/debug.h
index e6758fb..347420e 100644
--- a/include/debug.h
+++ b/include/debug.h
@@ -3,12 +3,30 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __DEBUG_H__
@@ -17,17 +35,12 @@
 /*===========================================================================*/
 #ifndef __ASM__
 
-#ifdef __DEBUG_BUILD__
-#define K_ASSERT(x) {							\
-		if (!(x)) {						\
-			putstr("Assertion failed!(");			\
-			putstr(__FILE__);				\
-			putstr(":");					\
-			putdec(__LINE__);				\
-			putstr(")");					\
+#define ASSERT(x, format...)						\
+		if ((x)) {						\
+			printf("%s(%d): ", __func__, __LINE__);		\
+			printf("Assertion: "format);			\
 			for (;;);					\
-		}							\
-	}
+		}
 
 #define BUG_ON(x) {							\
 		if (x) {						\
@@ -40,19 +53,7 @@
 		}							\
 	}
 
-#else
-#define K_ASSERT(x) {							\
-		if (!(x)) {						\
-			for (;;);					\
-		}							\
-	}
-
-#define BUG_ON(x) {							\
-		if (x) {						\
-			for (;;);					\
-		}							\
-	}
-#endif
+#define DIE()
 
 /* ==========================================================================*/
 #ifdef __RELEASE_NOPUT_BUILD__
@@ -77,19 +78,6 @@
 #define putstrhex(str, h) {putstr(str); puthex(h); putstr("\r\n");}
 #define putstrstr(str, s) {putstr(str); putstr(s); putstr("\r\n");}
 
-#define AMBOOT_IAV_STR_DEBUG
-#undef AMBOOT_IAV_STR_DEBUG
-
-#ifdef AMBOOT_IAV_STR_DEBUG
-#define putstr_debug(msg)	\
-	do {						\
-		putstr(msg);		\
-		putstr("\r\n");		\
-	} while (0)
-#else
-#define putstr_debug(debug_msg)
-#endif
-
 #endif /* __ASM__ */
 
 /*===========================================================================*/
diff --git a/include/dsp/dsp.h b/include/dsp/dsp.h
index c2ce149..18c31af 100644
--- a/include/dsp/dsp.h
+++ b/include/dsp/dsp.h
@@ -3,62 +3,61 @@
  *
  * Author: Cao Rongrong <rrcao@ambarella.com>
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __IAV_DSP_H__
 #define __IAV_DSP_H__
 
+#include <dsp/dspfw.h>
+
 #if (CHIP_REV == S2L)
 #include "s2l_cmd_msg.h"
+#include "s2l_mem.h"
+#define CODE_VCAP_IRQ (CODE_VDSP_0_IRQ)
+#elif (CHIP_REV == S3L)
+#include "s3l_cmd_msg.h"
+#include "s3l_mem.h"
+#define CODE_VCAP_IRQ (CODE_VDSP_1_IRQ)
+#elif (CHIP_REV == S5L)
+#include "s5l_cmd_msg.h"
+#include "s5l_mem.h"
+#define CODE_VCAP_IRQ (CODE_VDSP_1_IRQ)
+#else
+/* S2E still need this file, even if no fast boot feature now. */
 #endif
 
-/**
- *
- * DSP Buffer Layout:
- *
- *       +--------------------+ <--- IDSP_RAM_START
- *       | DSP_BSB_SIZE       |
- *       +--------------------+
- *       | DSP_IAVRSVD_SIZE   |
- *       +--------------------+
- *       | DSP_FASTDATA_SIZE  |
- *       +--------------------+
- *       | DSP_FASTAUDIO_SIZE |
- *       +--------------------+
- *       | DSP_BUFFER_SIZE    |
- *       +--------------------+
- *       | DSP_CMD_BUF_SIZE   |
- *       +--------------------+
- *       | DSP_MSG_BUF_SIZE   |
- *       +--------------------+
- *       | DSP_BSH_SIZE       |
- *       +--------------------+
- *       | DSP_LOG_SIZE       |
- *       +--------------------+
- *       | DSP_UCODE_SIZE     |
- *       +--------------------+
- *
- */
-
-/*
- * Note:
- *   1. "start" means the first byte of physical address.
- *   2. "base" means the first byte of virtual address.
- *   3. DSP_BSB_SIZE ,DSP_IAVRSVD_SIZE, DSP_FASTAUDIO_SIZE are specified by menuconfig.
- *   4. DSP_IAVRSVD_SIZE is the size of memory reserved for IAV drivers.
- *   5. DSP_FASTDATA_SIZE is the size of memory reserved for Fastboot data.
- *      If FastData is disabled, DSP_FASTDATA_SIZE should be set zero, or not defined.
- *      It's used for store dsp_status/vin_video_format in amboot.
- *   6. DSP_FASTAUDIO_SIZE is the size of memory reserved for FastAudio.
- *      If FastAudio is disabled, DSP_FASTAUDIO_SIZE should be set zero, or not defined.
- *   7. DSP_BSH_SIZE is the size of memory for storing BIT_STREAM_HDR.
- */
+#if defined(CONFIG_PANDORA_RTOS)
+#include <pandora.h>
+typedef struct dsp_context_s {
+	completion_t dsp_comp;
+	completion_t vcap_comp;
+	unsigned int dsp_state;
+} dsp_context_t;
+#endif
 
 /* Interface type sync from kernel/private/include/vin_sensors.h */
 typedef enum {
@@ -81,93 +80,13 @@ enum iav_state {
 	IAV_STATE_INIT = 0xFF,
 };
 
-#define DSP_UCODE_SIZE			(4 << 20)
-#define DSP_LOG_SIZE			(128 << 10)
-#define DSP_BSH_SIZE			(16 << 10)
-#define DSP_MSG_BUF_SIZE		(4 << 10)	/* MSG size is 256 bytes */
-#define DSP_CMD_BUF_SIZE		(4 << 10)	/* CMD size is 128 bytes */
-
-#define DSP_BUFFER_SIZE			(DRAM_SIZE - (IDSP_RAM_START - DRAM_START_ADDR) - \
-						DSP_UCODE_SIZE - \
-						DSP_LOG_SIZE - \
-						DSP_BSH_SIZE - \
-						DSP_MSG_BUF_SIZE - \
-						DSP_CMD_BUF_SIZE - \
-						DSP_FASTDATA_SIZE - \
-						DSP_FASTAUDIO_SIZE - \
-						DSP_IAVRSVD_SIZE - \
-						DSP_BSB_SIZE)
-
-#define DSP_BSB_START			(IDSP_RAM_START)
-#define DSP_IAVRSVD_START		(DSP_BSB_START + DSP_BSB_SIZE)
-#define DSP_FASTDATA_START		(DSP_IAVRSVD_START + DSP_IAVRSVD_SIZE)
-#define DSP_FASTAUDIO_START		(DSP_FASTDATA_START + DSP_FASTDATA_SIZE)
-#define DSP_BUFFER_START		(DSP_FASTAUDIO_START + DSP_FASTAUDIO_SIZE)
-#define DSP_CMD_BUF_START		(DSP_BUFFER_START + DSP_BUFFER_SIZE)
-#define DSP_MSG_BUF_START		(DSP_CMD_BUF_START + DSP_CMD_BUF_SIZE)
-#define DSP_BSH_START			(DSP_MSG_BUF_START + DSP_MSG_BUF_SIZE)
-#define DSP_LOG_START			(DSP_BSH_START + DSP_BSH_SIZE)
-#define DSP_UCODE_START			(DSP_LOG_START + DSP_LOG_SIZE)
-
-/*
- * layout for ucode in memory:
- *
- *       +----------------------+ <--- DSP_UCODE_START
- *       | ORCCODE       (3 MB) |
- *       +----------------------+
- *       | ORCME       (640 KB) |
- *       +----------------------+
- *       | DEFAULT BIN (320 KB) |
- *       +----------------------+ <--- Optional for fast boot
- *       | DEFAULT MCTF (16 KB) |
- *       +----------------------+ <--- Chip ID
- *       | CHIP ID        (4 B) |
- *       +----------------------+ <--- vdsp_info structure
- *       | VDSP_INFO BIN (1 KB) |
- *       +----------------------+
- */
-
-#define UCODE_ORCCODE_START		(DSP_UCODE_START)
-#define UCODE_ORCME_START		(UCODE_ORCCODE_START + (3 << 20))
-#define UCODE_DEFAULT_BINARY_START	(UCODE_ORCME_START + (640 << 10))
-#define UCODE_DEFAULT_MCTF_START	(UCODE_DEFAULT_BINARY_START + (320 << 10))
-#define UCODE_CHIP_ID_START		(UCODE_DEFAULT_MCTF_START + (16 << 10))
-
-#define DSP_INIT_DATA_START		(DRAM_START_ADDR + 0x000F0000)
-
-/* layout for fastosd(overlay) in memory */
-#define DSP_OVERLAY_START 		(DSP_BSB_START + DSP_BSB_SIZE)
-/* 0x1000 = 4 KB */
-#define DSP_OVERLAY_FONT_INDEX_START	(DSP_OVERLAY_START + 0)
-#define DSP_OVERLAY_FONT_MAP_START	(DSP_OVERLAY_FONT_INDEX_START + 0x1000)
-#define DSP_OVERLAY_CLUT_START		(DSP_OVERLAY_FONT_MAP_START + 0x4000)
-#define DSP_OVERLAY_STRING_START	(DSP_OVERLAY_CLUT_START + 0x1000)
-#define DSP_OVERLAY_STRING_OUT_START	(DSP_OVERLAY_STRING_START + 0x1000)
-
-/*
- * layout for DSP_FASTDATA in memory:
- *
- *       +-------------------------+ <--- DSP_FASTDATA_START
- *       | DSP_STATUS       (4 B)  |
- *       +-------------------------+ <--- vin_video_format structure
- *       | VIN_VIDEO_FORMAT (128 B)|
- *       +-------------------------+ <--- vin_dsp_config structure
- *       | VIN_DSP_CONFIG  (128 B) |
- *       +-------------------------+
- */
-
-/* store DSP_FASTDATA in amboot, restore it after enter Linux IAV */
-#define DSP_STATUS_STORE_SIZE	(4)
-#define DSP_VIN_VIDEO_FORMAT_STORE_SIZE	(128)
-#define DSP_STATUS_STORE_START		(DSP_FASTDATA_START)
-#define DSP_VIN_VIDEO_FORMAT_STORE_START	(DSP_STATUS_STORE_START + DSP_STATUS_STORE_SIZE)
-#define DSP_VIN_CONFIG_STORE_START	(DSP_VIN_VIDEO_FORMAT_STORE_START + DSP_VIN_VIDEO_FORMAT_STORE_SIZE)
-#define DSP_FASTDATA_INVALID		(0xFF)
-
-#define AUDIO_PLAY_MAX_SIZE			(0x80000)
+struct ucode_name_addr
+{
+	char name[UCODE_FILE_NAME_SIZE];
+	u32 addr; // Physical memory address
+};
 
 /* ==========================================================================*/
-
 /* Used for dump dsp cmd with Hex format */
 #define AMBOOT_IAV_DEBUG_DSP_CMD
 #undef AMBOOT_IAV_DEBUG_DSP_CMD
@@ -197,50 +116,57 @@ enum iav_state {
 #define dsp_print_cmd(cmd, cmd_size)
 #endif
 
-/* ==========================================================================*/
+#define AMBOOT_IAV_STR_DEBUG
+#undef AMBOOT_IAV_STR_DEBUG
 
-#define UCODE_FILE_NAME_SIZE		(24)
-#define DSPFW_IMG_MAGIC			(0x43525231)
-#define MAX_UCODE_FILE_NUM		(8)
-#define MAX_LOGO_FILE_NUM		(4)
-#define SPLASH_CLUT_SIZE		(256)
-
-struct ucode_file_info { /* 4 + 4 + 24 = 32 */
-	unsigned int			offset;
-	unsigned int			size;
-	char				name[UCODE_FILE_NAME_SIZE];
-}__attribute__((packed));
-
-struct splash_file_info { /* 32 */
-	unsigned int			offset;
-	unsigned int			size;
-	short				width;
-	short				height;
-	char				rev[32- (4 * 2) - (2 * 2)];
-}__attribute__((packed));
-
-struct dspfw_header { /* 4 + 4 + 4 + 4 + (32 * 8) + (32 * 4) + 112 = 512 */
-	unsigned int			magic;
-	unsigned int			size; /* totally size including the header */
-	unsigned short			total_dsp;
-	unsigned short			total_logo;
-	struct ucode_file_info		ucode[MAX_UCODE_FILE_NUM];
-	struct splash_file_info		logo[MAX_LOGO_FILE_NUM];
-	unsigned char			rev[112];
-}__attribute__((packed));
+#ifdef AMBOOT_IAV_STR_DEBUG
+#define putstr_debug(msg)	\
+	do {						\
+		putstr(msg);		\
+		putstr("\r\n");		\
+	} while (0)
+#else
+#define putstr_debug(debug_msg)
+#endif
 
 /* ==========================================================================*/
 extern void vin_phy_init(int interface_type);
-extern int dsp_init(void);
+extern void vin_phy_init_pre(int interface_type);
+extern void vin_phy_init_post(int interface_type);
+
+extern int dsp_init_pre(flpart_table_t *pptb);
+extern int dsp_init_post(flpart_table_t *pptb);
 extern int dsp_boot(void);
+extern int dsp_boot_pre(void);
+extern int dsp_boot_post(void);
 extern int add_dsp_cmd(void *cmd, unsigned int size);
+extern void dsp_halt(void);
+#if (CHIP_REV == S3L) || (CHIP_REV == S5L)
+extern int add_dsp_cmd_port(void *cmd, unsigned int size,
+	DSP_CMD_PORT_PARAM port, unsigned int seq_num);
+extern void flush_cache_dsp_msg_port(DSP_CMD_PORT_PARAM port);
+extern void clean_cache_dsp_cmd_port(DSP_CMD_PORT_PARAM port);
+extern void clear_dsp_cmd_port_num(DSP_CMD_PORT_PARAM port);
+#elif (CHIP_REV == S2L)
+extern int add_dsp_cmd_seq(void *cmd, unsigned int size,
+	unsigned int seq_num);
+extern void flush_cache_dsp_msg(void);
+extern void clean_cache_dsp_cmd(void);
+#endif
 
 extern void audio_set_play_size(unsigned int addr, unsigned int size);
 extern void audio_init(void);
 extern void audio_start(void);
 
-extern int dsp_get_ucode_by_name(struct dspfw_header *hdr, const char *name,
+extern int dsp_get_bin_by_name(struct dspfw_header *hdr, const char *name,
 		unsigned int *addr, unsigned int *size);
+extern int dsp_get_ucode_mem_by_name(const struct ucode_name_addr *map,
+	int num, const struct ucode_file_info *ucode, unsigned int *mem);
 
+#if defined(CONFIG_PANDORA_RTOS)
+extern void dsp_pandora_aaa(void);
+extern void wait_dsp_vcap(void);
+extern void set_dsp_state(unsigned int dsp_state);
 #endif
 
+#endif
diff --git a/include/dsp/dspfw.h b/include/dsp/dspfw.h
new file mode 100644
index 0000000..1426e85
--- /dev/null
+++ b/include/dsp/dspfw.h
@@ -0,0 +1,75 @@
+/**
+ * dspfw.h
+ *
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/* ==========================================================================*/
+#define DSPFW_IMG_MAGIC			(0x43525231)
+#define UCODE_FILE_NAME_SIZE	(20)
+#define BIN_FILE_NAME_SIZE		(24)
+#define MAX_UCODE_FILE_NUM		(6)
+#define MAX_LOGO_FILE_NUM		(4)
+#define MAX_BIN_FILE_NUM		(5)
+
+#define SPLASH_CLUT_SIZE		(256)
+
+struct ucode_file_info { /* 4 + 4 + 20 + 4 = 32 */
+	unsigned int			offset;
+	unsigned int			size;
+	char					name[UCODE_FILE_NAME_SIZE];
+	unsigned int			post:1; 			// Post Load ucode, set 0 by default
+	unsigned int			bin_split_offset:31;// split load default_binary.bin
+}__attribute__((packed));
+
+struct splash_file_info { /* 32 */
+	unsigned int			offset;
+	unsigned int			size;
+	short				width;
+	short				height;
+	char				rev[32- (4 * 2) - (2 * 2)];
+}__attribute__((packed));
+
+struct bin_file_info { /* 4 + 4 + 24 = 32 */
+	unsigned int			offset;
+	unsigned int			size;
+	char				name[BIN_FILE_NAME_SIZE];
+}__attribute__((packed));
+
+struct dspfw_header { /* 4 + 4 + 2 + 2 + 2 + 2 + (32 * 6) + (32 * 4) + (32 * 5) + 16 = 512 */
+	unsigned int			magic;
+	unsigned int			size; /* totally size including the header */
+	unsigned short			total_dsp;
+	unsigned short			total_logo;
+	unsigned short			total_bin;
+	unsigned short			reserved0;
+	struct ucode_file_info		ucode[MAX_UCODE_FILE_NUM];
+	struct splash_file_info		logo[MAX_LOGO_FILE_NUM];
+	struct bin_file_info		bin[MAX_BIN_FILE_NUM];
+	unsigned char			rev[16];
+}__attribute__((packed));
diff --git a/include/dsp/fb_aaa_ctrl.h b/include/dsp/fb_aaa_ctrl.h
new file mode 100644
index 0000000..8bb8d3a
--- /dev/null
+++ b/include/dsp/fb_aaa_ctrl.h
@@ -0,0 +1,306 @@
+
+/**
+ * fb_aaa_ctl.h
+ *
+ * History:
+ *    2017/03/27 - [Teng Huang] created file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef	__FB_AAA_CTRL_H__
+#define	__FB_AAA_CTRL_H__
+
+#include <amboot.h>
+
+#ifndef MAX
+#define MAX(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+
+//stats
+typedef struct awb_data_s {
+	u32 r_avg;
+	u32 g_avg;
+	u32 b_avg;
+	u32 lin_y;
+	u32 cr_avg;
+	u32 cb_avg;
+	u32 non_lin_y;
+}awb_data_t;
+
+typedef struct ae_data_s {
+	u32 lin_y;
+	u32 non_lin_y;
+}ae_data_t;
+
+typedef struct af_data_s {
+	u16 sum_fy;
+	u16 sum_fv1;
+	u16 sum_fv2;
+}af_data_t;
+
+typedef struct aaa_data_header_info_s
+{
+    // 1 u32
+	u16 awb_tile_col_start;
+	u16 awb_tile_row_start;
+    // 2 u32
+	u16 awb_tile_width;
+	u16 awb_tile_height;
+    // 3 u32
+	u16 awb_tile_active_width;
+	u16 awb_tile_active_height;
+    // 4 u32
+	u16 awb_rgb_shift;
+	u16 awb_y_shift;
+    //5 u32
+	u16 awb_min_max_shift;
+	u16 ae_tile_col_start;
+    //6 u32
+	u16 ae_tile_row_start;
+	u16 ae_tile_width;
+    //7 u32
+	u16 ae_tile_height;
+	u16 ae_y_shift;
+    //8 u32
+	u16 ae_linear_y_shift;
+	u16 ae_min_max_shift;
+
+    //9 u32
+	u16 af_tile_col_start;
+	u16 af_tile_row_start;
+
+    //10 u32
+	u16 af_tile_width;
+	u16 af_tile_height;
+
+    //11 u32
+	u16 af_tile_active_width;
+	u16 af_tile_active_height;
+
+    //12 u32
+	u16 af_y_shift;
+	u16 af_cfa_y_shift;
+
+    //13 u32
+	u8  awb_tile_num_col;
+	u8  awb_tile_num_row;
+	u8  ae_tile_num_col;
+	u8  ae_tile_num_row;
+
+    //14 u32
+	u8  af_tile_num_col;
+	u8  af_tile_num_row;
+	u8 total_slices_x;
+	u8 total_slices_y;
+
+   //15 u32
+	u8 slice_index_x;
+	u8 slice_index_y;
+	u16 slice_width;
+
+   //16 u32
+	u16 slice_height;
+	u16 slice_start_x;
+
+   //17 u32
+	u16 slice_start_y;
+	u16 exposure_index;
+
+	//18 u32
+	u16 total_exposures;
+	u16 black_red;
+
+	//19 u32
+	u16 black_green;
+	u16 black_blue;
+
+	//20 u32
+	u32 raw_pic_seq_num;
+
+	//21 u32
+	u32 iso_config_tag;
+
+	//22 u32
+	u32 is_rgbir_aaa : 1;
+	u32 chan_index : 3;
+	u32 reserved0 : 28;
+
+	u16 reserved1[20];
+}aaa_data_header_info_t;
+
+typedef struct aaa_data_s
+{
+	awb_data_t awb_info[1024];
+	ae_data_t ae_info[96];
+	af_data_t af_info[96];
+}aaa_data_t;
+
+struct cfa_awb_stat {
+	u16	sum_r;
+	u16	sum_g;
+	u16	sum_b;
+	u16	count_min;
+	u16	count_max;
+};
+
+struct cfa_ae_stat {
+	u16	lin_y;
+	u16	count_min;
+	u16	count_max;
+};
+
+struct cfa_af_stat {
+	u16	sum_fy;
+	u16	sum_fv1;
+	u16	sum_fv2;
+};
+
+typedef struct cfa_aaa_stat_s {
+	aaa_data_header_info_t	header_info;
+	u16       frame_id;
+	struct cfa_awb_stat	awb_stat[1024];
+	struct cfa_ae_stat		ae_stat[96];
+	struct cfa_af_stat		af_stat[96];
+//	struct cfa_histogram_stat	histogram_stat;
+	u8			reserved[121];
+}cfa_aaa_stat_t;
+
+//awb
+#define AWB_UNIT_GAIN (1024)
+typedef	struct wb_gain_s {
+	u32	r_gain;
+	u32	g_gain;
+	u32	b_gain;
+} wb_gain_t;
+
+typedef struct awb_lut_unit_s {
+	u16 gr_min;
+	u16 gr_max;
+	u16 gb_min;
+	u16 gb_max;
+	s16 y_a_min_slope;
+	s16 y_a_min;
+	s16 y_a_max_slope;
+	s16 y_a_max;
+	s16 y_b_min_slope;
+	s16 y_b_min;
+	s16 y_b_max_slope;
+	s16 y_b_max;
+	s8  weight;
+} awb_lut_unit_t;
+
+typedef struct awb_lut_s {
+	u8		lut_no;
+	awb_lut_unit_t	awb_lut[20];
+} awb_lut_t;
+
+typedef struct awb_lut_idx_s{
+	u8 start;
+	u8 num;
+}awb_lut_idx_t;
+
+typedef struct img_awb_param_s {
+	wb_gain_t	menu_gain[12];
+	awb_lut_t		wr_table;
+	awb_lut_idx_t awb_lut_idx[20];
+}img_awb_param_t;
+
+//ae
+#define AE_GAIN_PRECISION		(12)
+#define AE_GAIN_UNIT			(1<<12)
+enum {
+	CHG_SHUTTER = 0,
+	CHG_GAIN,
+	CHG_APERTURE,
+	CHG_FACTOR_NUM,
+};
+
+typedef struct joint_s {
+/*	s16	shutter;		// shall be values in ae_shutter_mode
+	s16	gain;		//shall be values in ae_iso_mode
+	s16	aperture;	//shall be values in ae_aperture_mode
+*/
+	s32	factor[3];	//0-shutter, 1-gain, 2-iris
+}joint_t;
+
+typedef struct line_s {
+	joint_t	start;
+	joint_t	end;
+}line_t;
+
+typedef struct aaa_config_info_s
+{
+	u32* p_ae_gain_table;
+	line_t* p_ae_lines;
+	img_awb_param_t* p_awb_param;
+	u32 max_agc_index;
+}aaa_config_info_t;
+
+typedef struct aaa_output_s{
+	u32 shutter_row;
+	u32 agc_index;
+	u32 dgain;
+	u32 ae_output_update;
+	wb_gain_t wb_gain;
+	u32 awb_output_update;
+}aaa_output_t;
+
+typedef struct aaa_fb_aeb_s {
+	/* AWB */
+	unsigned int	r_gain;
+	unsigned int	b_gain;
+	/* AE */
+	unsigned int	d_gain;
+	unsigned int	shutter;
+	unsigned int	agc;
+}aaa_fb_aeb_t;
+
+int fb_aaa_algo(u8* p_cfa_stats_addr_a,
+				u8* p_cfa_stats_addr_b,
+				u8* p_cfa_stats_addr_c,
+				u8* p_lisocfg,aaa_config_info_t* p_aaa_cfg,aaa_output_t* p_aaa_output);
+void fb_aaa_set_log_level(u8 log_level);
+void fb_aaa_get_version(u32 version);
+
+/* defined in amboot/src/bld/dsp/<arch>/dsp_aaa.c */
+extern int clamp(int x, int min, int max);
+extern void convert_dot_12_2_hardware_gain_A7(int mul_dot_12,
+	int *gain, int *shift);
+
+/* defined in boards/bsp/iav/sensor_xxx_aaa.c */
+#if (CHIP_REV == S5L)
+extern void dsp_issue_liso_cfg_batch_cmd(unsigned int seq_num, u8 is_first);
+#else
+extern void dsp_issue_liso_cfg_cmd(unsigned int seq_num);
+#endif
+extern void dsp_issue_force_idr_cmd(unsigned int seq_num, u32 pts);
+extern void init_iso_cfg_addr(u32 *p_iso_cfg_addr);
+extern void init_sensor_aaa_param(aaa_config_info_t *p_aaa_cfg_info);
+extern void fb_sensor_ctrl(aaa_output_t* p_aaa_output);
+extern u8 get_force_idr_cnt(void);
+#endif	// __FB_AAA_CTRL_H__
+
diff --git a/include/dsp/fb_aaa_imx322_param.c b/include/dsp/fb_aaa_imx322_param.c
new file mode 100644
index 0000000..ce94de7
--- /dev/null
+++ b/include/dsp/fb_aaa_imx322_param.c
@@ -0,0 +1,116 @@
+/*******************************************************************************
+ * fb_aaa_imx322_param.c
+ *
+ * History:
+ *   2017/05/23 - [Tao Wu] created file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+line_t fb_imx322_60hz_lines[] = {
+	{
+	{{2, 0, 0}}, {{281, 0,0}}
+	},
+
+	{
+	{{281, 0, 0}}, {{281, 29, 0}}
+	},
+
+	{
+	{{562, 0, 0}}, {{562, 59,0}}
+	},
+
+	{
+	{{1125, 0, 0}}, {{1125, 139,0}}
+	}
+};
+
+u32 fb_imx322_aeb_gain_table[] = {
+	//42db, step =0.3db
+	4096,	4240,	4389,	4543,	4703,	4868,	5039,	5216,
+	5400,	5589,	5786,	5989,	6200,	6417,	6643,	6876,
+	7118,	7368,	7627,	7895,	8173,	8460,	8757,	9065,
+	9383,	9713,	10054,	10408,	10774,	11152,	11544,	11950,
+	12370,	12804,	13254,	13720,	14202,	14701,	15218,	15753,
+	16306,	16880,	17473,	18087,	18722,	19380,	20061,	20766,
+	21496,	22252,	23034,	23843,	24681,	25548,	26446,	27375,
+	28337,	29333,	30364,	31431,	32536,	33679,	34863,	36088,
+	37356,	38669,	40028,	41434,	42890,	44398,	45958,	47573,
+	49245,	50975,	52767,	54621,	56541,	58527,	60584,	62713,
+	64917,	67199,	69560,	72005,	74535,	77154,	79866,	82672,
+	85578,	88585,	91698,	94920,	98256,	101709, 105283, 108983,
+	112813, 116778, 120882, 125130, 129527, 134079, 138791, 143668,
+	148717, 153943, 159353, 164953, 170750, 176750, 182962, 189391,
+	196047, 202936, 210068, 217450, 225092, 233002, 241190, 249666,
+	258440, 267522, 276924, 286655, 296729, 307157, 317951, 329124,
+	340690, 352663, 365056, 377885, 391165, 404911, 419141, 433870,
+	449117, 464900, 481238, 498150, 515656,
+};
+
+img_awb_param_t fb_imx322_awb_param = {
+	{
+		{1756, 1024, 1946},	//AUTOMATIC
+		{1135, 1024, 3435},	//INCANDESCENT
+		{1736, 1024, 2956},	//D4000
+		{1756, 1024, 1946},	//D5000
+		{2013, 1024, 1754},	//SUNNY
+		{2292, 1024, 1619},	//CLOUDY
+		{1598, 1024, 1875},	//FLASH
+		{1024, 1024, 1024},	//FLUORESCENT
+		{1024, 1024, 1024},	//FLUORESCENT_H
+		{1024, 1024, 1024},	//UNDER WATER
+		{1024, 1024, 1024},	//CUSTOM
+		{2013, 1024, 1754},	//AUTOMATIC OUTDOOR
+	},
+	{
+		12,
+		{{806,1497,2865,3892,-2627,5397,-1929,6246,854,1994,1101,2847,1},	// 0	INCANDESCENT
+		 {1002,2009,2256,3316,-2309,5014,-1932,6607,721,1157,770,2195,2},	// 1    D4000
+		 {1261,2222,1585,2707,-1661,4188,-1110,4517,1338,-707,478,1664,4},	// 2	 D5000
+		 {1635,2486,1263,2245,-1245,3587,-1284,4913,1092,-581,1144,-89,8},	// 3    SUNNY
+		 {1894,2676,1218,1912,-681,2601,-693,3563,1276,-1709,1307,-843,4},	// 4    CLOUDY
+		 {   0,    0,    0,    0,     0,    0,     0,    0,   0,   0,    0,    0, 0 },					// 5    ...
+		 {1405,2146,2538,3384,-1104,4412,-1339,6055,921,851,878,1891,0},		// 6	GREEN REGION
+		 {   0,    0,    0,    0,     0,    0,     0,    0,   0,   0,    0,    0, 0 },	// 7    FLASH
+		 {   0,    0,    0,    0,     0,    0,     0,    0,   0,   0,    0,    0, 0 },	// 8	FLUORESCENT
+		 {   0,    0,    0,    0,     0,    0,     0,    0,   0,   0,    0,    0, 0 },	// 9    FLUORESCENT_2
+		 {   0,    0,    0,    0,     0,    0,     0,    0,   0,   0,    0,    0, 0 },	// 10	FLUORESCENT_3
+		 {   0,    0,    0,    0,     0,    0,     0,    0,   0,   0,    0,    0, 0 }},
+	},
+	{	{ 0 ,6},	//LUT num. AUTOMATIC  INDOOR
+		{ 0, 1},	//LUT num. INCANDESCENT
+		{ 1, 1},	//LUT num. D4000
+		{ 2, 1},	//LUT num. D5000
+		{ 2, 5},	//LUT num. SUNNY
+		{ 4, 3},	//LUT num. CLOUDY
+		{ 7, 1},	//LUT num. FLASH
+		{ 8, 1},	//LUT num. FLUORESCENT
+		{ 9, 1},	//LUT num. FLUORESCENT_H
+		{11, 1},	//LUT num. UNDER WATER
+		{11, 1},	//LUT num. CUSTOM
+		{ 0, 7},	//LUT num. AUTOMATIC  OUTDOOR
+	 }
+};
diff --git a/include/dsp/s2l_cmd_msg.h b/include/dsp/s2l_cmd_msg.h
index 14f46a0..1803109 100644
--- a/include/dsp/s2l_cmd_msg.h
+++ b/include/dsp/s2l_cmd_msg.h
@@ -5,12 +5,30 @@
  * History:
  *	2012/07/05 - [Jian Tang] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef	__CMD__MSG_H__
@@ -18,7 +36,8 @@
 
 #include  <basedef.h>
 
-/* Check struct vin_video_format in private/include/vin_api.h */
+#if defined CONFIG_S2LMELEKTRA_DSP_BOOT
+/* FixMe: For special BPI project */
 struct vin_video_format {
 	u32 video_mode;
 	u32 device_mode;
@@ -34,10 +53,12 @@ struct vin_video_format {
 	u8 type;
 	u8 bits;
 	u8 ratio;
+	u8 mirror_pattern;
 	u8 bayer_pattern;
 	u8 hdr_mode;
 	u8 readout_mode;
-	u16 sync_start;
+	u32 line_time;
+	u32 vb_time;
 
 	u32 max_fps;
 	int default_fps;
@@ -58,6 +79,55 @@ struct vin_video_format {
 	u16 hdr_short3_offset;
 	u16 dual_gain_mode;
 };
+#else
+struct vin_video_format {
+	u32 video_mode;
+	u32 device_mode;
+	u32 pll_idx;	/* clock index */
+	u16 width;	/* image horizontal size in unit of pixel */
+	u16 height;	/* image vertical size in unit of line */
+
+	u16 def_start_x;
+	u16 def_start_y;
+	u16 def_width;
+	u16 def_height;
+	u8 format;
+	u8 type;
+	u8 bits;
+	u8 ratio;
+	u8 mirror_pattern;
+	u8 bayer_pattern;
+	u8 hdr_mode;
+	u8 readout_mode;
+	u32 line_time;
+	u32 vb_time;
+
+	u32 max_fps;
+	int default_fps;
+	int default_agc;
+	int default_shutter_time;
+	int default_bayer_pattern;
+
+	/* hdr mode related */
+	u16 act_start_x;
+	u16 act_start_y;
+	u16 act_width;
+	u16 act_height;
+	u16 hdr_long_offset;
+	u16 hdr_short1_offset;
+	u16 hdr_short2_offset;
+	u16 hdr_short3_offset;
+	u16 dual_gain_mode;
+	u8 gp_ctrl_used;
+
+	/* bridge mode related */
+	u16 brg_start_x;
+	u16 brg_start_y;
+	u16 brg_width;
+	u16 brg_height;
+	u8 brg_compress_ratio;
+};
+#endif
 
 #define DSP_CMD_SIZE 	128	// need to decouple if used by ARM
 #define DSP_MSG_SIZE	256	// need to decouple if used by ARM
@@ -405,6 +475,7 @@ typedef enum{
 	AMBA_CHIP_ID_S2L_88 = 6,
 	AMBA_CHIP_ID_S2L_99 = 7,
 	AMBA_CHIP_ID_S2L_TEST = 8,
+	AMBA_CHIP_ID_S2L_22 = 9,
 } amba_chip_id_t;
 
 /* DSP CMD/MSG protocol version */
@@ -440,7 +511,9 @@ typedef struct dsp_init_data
 	u32 dsp_log_buf_ptr;
 	u32 prev_cmd_seq_num;
 	u32 cmdmsg_protocol_version;
-	u32 reserved_2[11];
+	u32 vout_profile : 3;
+	u32 dsp_log_size : 29;
+	u32 reserved_2[10];
 }dsp_init_data_t;
 
 // Structure that indicate the vdsp interrupt status
@@ -826,6 +899,11 @@ typedef	enum {
 	MAX_PREVIEW_TYPE = 4,
 } preview_type_t;
 
+typedef enum {
+	NORMAL_BOOT = 0, /* Normal boot case */
+	FAST_BOOT = 1, /* Fast boot case */
+} boot_mode_t;
+
 typedef struct system_setup_info_s
 {
 	u32 cmd_code;
@@ -848,7 +926,8 @@ typedef struct system_setup_info_s
 	u32 padding : 5;
 
 	applicaton_mode_t  sub_mode_sel; //0: Camcorder mode (single-stream encoder) 1: DVR mode (multiple-stream encoder)
-	u8  reserved1;     // number of input YUV sources muxed together.
+	boot_mode_t boot_mode : 2; /* boot_mode_t */
+	u8  reserved1 : 6;     // number of input YUV sources muxed together.
 	u8  lcd_3d;                      // need to support LCD 3D rotation
 	u8  iv_360;       // need to support 360 degree image/video playback.
 	u8  mode_flags; /* determines the IDSP pipeline to run */
@@ -873,6 +952,7 @@ typedef struct dsp_debug_level_setup_s{
 	u8 debug_level;
 	u8 coding_thread_printf_disable_mask;
 	u8 padding;
+	u32 num_dsplog_delay_stop_plus1;
 }dsp_debug_level_setup_t;
 
 /**
@@ -2758,11 +2838,7 @@ typedef struct h264_encode_s
 
 	// SPS
 	u8 frame_cropping_flag;
-	/* 0 -- Main Profile with CABAC;
-	 * 1 -- High Profile;
-	 * 2 -- Main Profile with CAVLC;
-	 * 3 -- Baseline Profile
-	 */
+
 	u8 profile   :2;
 	u8 reserved2 :6;
 	u16 frame_crop_left_offset;
@@ -4710,17 +4786,18 @@ typedef struct real_time_cbr_modify_s
 typedef struct ipcam_capture_preview_size_setup_s
 {
 	u32 cmd_code;
-    u32 preview_id : 2 ;
-    u32 output_scan_format : 1 ;
-    u32 deinterlace_mode : 2 ;
-    u32 disabled : 1 ;
-    u32 Reserved1 : 26 ;
-    u16 cap_width ;
-    u16 cap_height ;
-    u16 input_win_offset_x ;
-    u16 input_win_offset_y ;
-    u16 input_win_width ;
-    u16 input_win_height ;
+	u32 preview_id : 2 ;
+	u32 output_scan_format : 1 ;
+	u32 deinterlace_mode : 2 ;
+	u32 disabled : 1 ;
+	u32 skip_interval : 8;
+	u32 Reserved1 : 18 ;
+	u16 cap_width ;
+	u16 cap_height ;
+	u16 input_win_offset_x ;
+	u16 input_win_offset_y ;
+	u16 input_win_width ;
+	u16 input_win_height ;
 } ipcam_capture_preview_size_setup_t ;
 
 /* for capture_source in ipcam_video_encode_size_setup_t */
@@ -4795,9 +4872,15 @@ typedef struct ipcam_video_system_setup_s
 	u16 stream_1_LT_enable : 1;
 	u16 stream_2_LT_enable : 1;
 	u16 stream_3_LT_enable : 1;
-	u16 reserved1 : 4;
+	u16 B_frame_enable_in_LT_gop : 1;
+	u16 prev_A_extra_line_at_top : 1;
+	u16 vca_preview_id : 2 ;
 	u16 max_warp_region_input_height;
-	u16 reserved2;
+	u16 vca_frame_num;
+	u32 vca_daddr_base;
+	u32 vca_daddr_size;
+	u32 enc_buf_extra_MB_row_at_top : 1;
+	u32 reserved : 31;
 }ipcam_video_system_setup_t ;
 
 /* 0x6004 */
@@ -4849,7 +4932,15 @@ typedef struct ipcam_real_time_encode_param_setup_s
 	u8 user2_direct_bias;
 	u8 user3_intra_bias;
 	u8 user3_direct_bias;
-	u8 reserved1[2];
+	u8 force_pskip_num_plus1; /* 0: force one frame encode as pskip frame;
+								>= 1: (force_pskip_num_plus1-1) frames will encodes
+									as pskip between every two normal P frames */
+	u8 reserved1[1];
+	u32 set_I_size;
+	u8 q_qp_reduce;
+	u8 qp_min_on_Q;
+	u8 qp_max_on_Q;
+	u8 log_q_num_per_gop_plus_1;
 } ipcam_real_time_encode_param_setup_t ;
 
 /* 0x6007 */
diff --git a/include/dsp/s2l_mem.h b/include/dsp/s2l_mem.h
new file mode 100644
index 0000000..893ff87
--- /dev/null
+++ b/include/dsp/s2l_mem.h
@@ -0,0 +1,332 @@
+/**
+ * amboot/include/dsp/s2l_mem_arch.h
+ * should be consistent with kernel/private/include/arch_s2l/amba_arch_mem.h
+ *
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __AMBA_S2L_MEM_ARCH_H__
+#define __AMBA_S2L_MEM_ARCH_H__
+/**
+ *
+ * DSP Buffer Layout:
+ *
+ *       +--------------------+ <--- IDSP_RAM_START
+ *       | DSP_BSB_SIZE       |
+ *       +--------------------+
+ *       | DSP_IAVRSVD_SIZE   |
+ *       +--------------------+
+ *       | DSP_FASTDATA_SIZE  |
+ *       +--------------------+
+ *       | DSP_FASTAUDIO_SIZE |
+ *       +--------------------+
+ *       | DSP_BUFFER_SIZE    |
+ *       +--------------------+
+ *       | DSP_CMD_BUF_SIZE   |
+ *       +--------------------+
+ *       | DSP_MSG_BUF_SIZE   |
+ *       +--------------------+
+ *       | DSP_BSH_SIZE       |
+ *       +--------------------+
+ *       | DSP_LOG_SIZE       |
+ *       +--------------------+
+ *       | DSP_UCODE_SIZE     |
+ *       +--------------------+
+ *
+ */
+
+/*
+ * Note:
+ *   1. "start" means the first byte of physical address.
+ *   2. "base" means the first byte of virtual address.
+ *   3. DSP_BSB_SIZE ,DSP_IAVRSVD_SIZE, DSP_FASTAUDIO_SIZE are specified by menuconfig.
+ *   4. DSP_IAVRSVD_SIZE is the size of memory reserved for IAV drivers.
+ *   5. DSP_FASTDATA_SIZE is the size of memory reserved for Fastboot data.
+ *      If FastData is disabled, DSP_FASTDATA_SIZE should be set zero, or not defined.
+ *      It's used for store dsp_status/vin_video_format in amboot.
+ *   6. DSP_FASTAUDIO_SIZE is the size of memory reserved for FastAudio.
+ *      If FastAudio is disabled, DSP_FASTAUDIO_SIZE should be set zero, or not defined.
+ *   7. DSP_BSH_SIZE is the size of memory for storing BIT_STREAM_HDR.
+ */
+
+#include "config.h"
+
+#define PAGE_SHIFT	12
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE - 1))
+#define PAGE_ALIGN(size)	(((size) + PAGE_SIZE - 1) & PAGE_MASK)
+#define ALIGN(size, align) ((size + align - 1) & (~(align - 1)))
+
+#define	IAV_MAX_ENCODE_STREAMS_NUM	4
+
+typedef enum {
+	DSP_ENC_CMD_SIZE = (128),
+	ENC_CMD_TOGGLED_NUM = (8),
+	CMD_SYNC_SIZE = (DSP_ENC_CMD_SIZE * IAV_MAX_ENCODE_STREAMS_NUM),
+	CMD_SYNC_TOTAL_SIZE = (CMD_SYNC_SIZE * ENC_CMD_TOGGLED_NUM),
+} IAV_CMD_SYNC_PARAMS;
+
+/*
+ * QP matrix memory configuration
+ */
+typedef enum {
+#ifdef IAV_MEM_QPM_SIZE
+	SINGLE_QP_MATRIX_SIZE = PAGE_ALIGN(IAV_MEM_QPM_SIZE),
+#else
+	SINGLE_QP_MATRIX_SIZE = 0,
+#endif
+#ifndef CONFIG_AMBARELLA_IAV_ROI_IPB
+	STREAM_QP_MATRIX_NUM = (1),
+#else
+	STREAM_QP_MATRIX_NUM = (3),
+#endif
+	STREAM_QP_MATRIX_SIZE = (SINGLE_QP_MATRIX_SIZE * STREAM_QP_MATRIX_NUM),
+	QP_MATRIX_SIZE = (STREAM_QP_MATRIX_SIZE * IAV_MAX_ENCODE_STREAMS_NUM),
+	QP_MATRIX_TOGGLED_NUM = (4),
+	/* 96KB * 4 * (1 + 4) = 1920 KB for 1 qp matrix per stream*/
+	/* 96KB * 3 * 4 * (1 + 4) = 5760 KB for 3 qp matrixes per stream*/
+	QP_MATRIX_TOTAL_SIZE = (QP_MATRIX_SIZE * (1 + QP_MATRIX_TOGGLED_NUM)),
+}IAV_QPMATRIX_PARAMS;
+
+/*
+ * WARP configuration
+ */
+typedef enum {
+	VWARP_BLOCK_HEIGHT_MAX = 64,
+	VWARP_BLOCK_HEIGHT_MAX_LDC = 32,
+	VWARP_BLOCK_HEIGHT_MIN = 28,
+	LDC_PADDING_WIDTH_MAX = 256,
+
+	WARP_TABLE_AREA_MAX_NUM = 8,
+	WARP_TABLE_AREA_MAX_WIDTH = 32,
+	WARP_TABLE_AREA_MAX_HEIGHT = 48,
+	WARP_TABLE_AREA_MAX_SIZE = (WARP_TABLE_AREA_MAX_WIDTH
+	    * WARP_TABLE_AREA_MAX_HEIGHT),
+	/* User Warp Partition */
+	UWARP_NUM = 1,
+	WARP_CMD_SIZE = 128,
+	WARP_VECT_PART_SIZE = (WARP_TABLE_AREA_MAX_NUM * \
+		WARP_TABLE_AREA_MAX_SIZE * sizeof(s16) * 3),  // 3 tables per one area(H-warp, V-warp, ME1-Vwarp)
+	IAV_PARTITION_TOGGLE_NUM = 4,
+	WARP_VECT_TOTAL_SIZE = WARP_VECT_PART_SIZE * (IAV_PARTITION_TOGGLE_NUM + UWARP_NUM),
+	WARP_BATCH_PART_SIZE = WARP_TABLE_AREA_MAX_NUM * WARP_CMD_SIZE,
+	WARP_BATCH_CMDS_OFFSET = WARP_VECT_TOTAL_SIZE,
+	WARP_BATCH_CMDS_SIZE = WARP_BATCH_PART_SIZE * IAV_PARTITION_TOGGLE_NUM,
+
+	/* 8 * 3KB * 3 * (4 + 1) + 4 = 364 KB */
+	WARP_BUFFER_TOTAL_SIZE = WARP_VECT_TOTAL_SIZE + WARP_BATCH_CMDS_SIZE,
+} IAV_WARP_PARAMS;
+
+typedef enum {
+	JPEG_QT_SIZE = 128,
+	JPEG_QT_BUFFER_NUM = 4,
+	JPEG_QT_TOTAL_SIZE = (IAV_MAX_ENCODE_STREAMS_NUM * JPEG_QT_SIZE * JPEG_QT_BUFFER_NUM),
+} IAV_JPEG_QT_PARAMS;
+
+/*
+ * Privacymask memory configuration
+ */
+typedef enum {
+	/*
+	 * BPC memory configuration
+	 */
+	PM_BPC_WIDTH_MAX = 3072,
+	PM_BPC_HEIGHT_MAX = 2048,
+	PM_BPC_PARTITION_SIZE = ALIGN(PM_BPC_WIDTH_MAX / 8, 32) * PM_BPC_HEIGHT_MAX,
+} IAV_PM_PARAMS;
+
+#define DSP_USR_SIZE		PAGE_ALIGN(IAV_MEM_USR_SIZE)
+#define DSP_MV_SIZE			PAGE_ALIGN(IAV_MEM_MV_SIZE)
+#define DSP_OVERLAY_SIZE	PAGE_ALIGN(IAV_MEM_OVERLAY_SIZE)
+#define DSP_QPM_SIZE		PAGE_ALIGN(QP_MATRIX_TOTAL_SIZE)
+#ifndef CONFIG_AMBARELLA_IAV_DRAM_WARP_MEM
+	#define DSP_WARP_SIZE	0
+#else
+	#define DSP_WARP_SIZE	PAGE_ALIGN(WARP_BUFFER_TOTAL_SIZE)
+#endif
+#define DSP_QUANT_SIZE		PAGE_ALIGN(JPEG_QT_TOTAL_SIZE)
+#define DSP_PM_SIZE			PAGE_ALIGN(IAV_MEM_PM_SIZE_S2L)
+#define DSP_BPC_SIZE		(PAGE_SIZE + PAGE_ALIGN(PM_BPC_PARTITION_SIZE))
+#define DSP_CMD_SYNC_SIZE	PAGE_ALIGN(CMD_SYNC_TOTAL_SIZE)
+#define DSP_VCA_SIZE		PAGE_ALIGN(IAV_MEM_VCA_SIZE)
+
+#ifdef CONFIG_AMBARELLA_IAV_ROI_IPB
+	#define IAV_MARGIN_SIZE		((18 << 20) + DSP_USR_SIZE + DSP_MV_SIZE + DSP_VCA_SIZE)
+#else
+	#define IAV_MARGIN_SIZE		((11 << 20) + DSP_USR_SIZE + DSP_MV_SIZE + DSP_VCA_SIZE)
+#endif
+
+#define DSP_IMGRSVD_SIZE		(5 << 20)
+#if (DSP_IAVRSVD_SIZE < (DSP_IMGRSVD_SIZE + IAV_MARGIN_SIZE))
+	#undef DSP_IAVRSVD_SIZE
+	#define DSP_IAVRSVD_SIZE	(DSP_IMGRSVD_SIZE + IAV_MARGIN_SIZE)
+#endif
+
+#define DSP_UCODE_SIZE			(4 << 20)
+
+#ifdef CONFIG_AMBARELLA_DSP_LOG_SIZE
+#define DSP_LOG_SIZE 	CONFIG_AMBARELLA_DSP_LOG_SIZE
+#else
+#define DSP_LOG_SIZE			(128 << 10)
+#endif
+
+#define DSP_BS_UNIT_SIZE		(64)
+#define DSP_BS_NUM				(256)	/* User can modify this */
+#define DSP_BSH_SIZE			(DSP_BS_UNIT_SIZE * DSP_BS_NUM)
+
+#define DSP_MSG_BUF_SIZE		(4 << 10)	/* MSG size is 256 bytes */
+#define DSP_CMD_BUF_SIZE		(4 << 10)	/* CMD size is 128 bytes */
+#define DSP_DEF_CMD_BUF_SIZE	(4 << 10)	/* Default CMD size is 128 bytes */
+#define DSP_IMAGE_CONFIG_SIZE		(4 << 20)
+#define DSP_ISOCFG_RSVED_SIZE		(512 << 10)
+
+#define DSP_BUFFER_SIZE			(DRAM_SIZE - (IDSP_RAM_START - DRAM_START_ADDR) - \
+						DSP_UCODE_SIZE - \
+						DSP_LOG_SIZE - \
+						DSP_BSH_SIZE - \
+						DSP_MSG_BUF_SIZE - \
+						DSP_CMD_BUF_SIZE - \
+						DSP_DEF_CMD_BUF_SIZE - \
+						DSP_FASTDATA_SIZE - \
+						DSP_FASTAUDIO_SIZE - \
+						DSP_IAVRSVD_SIZE - \
+						DSP_BSB_SIZE)
+
+#define DSP_BSB_START			(IDSP_RAM_START)
+#define DSP_IAVRSVD_START		(DSP_BSB_START + DSP_BSB_SIZE)
+#define DSP_OVERLAY_START 		(DSP_IAVRSVD_START + DSP_USR_SIZE + DSP_MV_SIZE)
+#define DSP_IMGPROC_START		(DSP_OVERLAY_START + DSP_OVERLAY_SIZE + DSP_QPM_SIZE + \
+						DSP_WARP_SIZE + DSP_QUANT_SIZE)
+#define DSP_IMAGE_CONFIG_START		(DSP_IMGPROC_START)
+#define DSP_STILL_ISO_CONFIG_START	(DSP_IMAGE_CONFIG_START + DSP_IMAGE_CONFIG_SIZE)
+#define DSP_FASTBOOT_IDSPCFG_START	(DSP_STILL_ISO_CONFIG_START + DSP_ISOCFG_RSVED_SIZE)
+#define DSP_VCA_START			(DSP_IMGPROC_START + DSP_IMGRSVD_SIZE + DSP_PM_SIZE + \
+						DSP_BPC_SIZE + DSP_CMD_SYNC_SIZE)
+#define DSP_FASTDATA_START		(DSP_IAVRSVD_START + DSP_IAVRSVD_SIZE)
+#define DSP_FASTAUDIO_START		(DSP_FASTDATA_START + DSP_FASTDATA_SIZE)
+#define DSP_BUFFER_START		(DSP_FASTAUDIO_START + DSP_FASTAUDIO_SIZE)
+#define DSP_DEF_CMD_BUF_START		(DSP_BUFFER_START + DSP_BUFFER_SIZE)
+#define DSP_CMD_BUF_START		(DSP_DEF_CMD_BUF_START + DSP_DEF_CMD_BUF_SIZE)
+#define DSP_MSG_BUF_START		(DSP_CMD_BUF_START + DSP_CMD_BUF_SIZE)
+#define DSP_BSH_START			(DSP_MSG_BUF_START + DSP_MSG_BUF_SIZE)
+#define DSP_LOG_START			(DSP_BSH_START + DSP_BSH_SIZE)
+#define DSP_UCODE_START			(DSP_LOG_START + DSP_LOG_SIZE)
+
+/*
+ * layout for ucode in memory:
+ *
+ *       +----------------------+ <--- DSP_UCODE_START
+ *       | ORCCODE    (2816 KB) |
+ *       +----------------------+ <--- Use RAM for fast boot 3A which
+ *       | AAA STATS   (256 KB) |	   is not used in ORCCODE
+ *       | (For Pandora 3A)     |
+ *       +----------------------+ <--- (3 << 20)
+ *       | ORCME       (640 KB) |
+ *       +----------------------+
+ *       | DEFAULT BIN (320 KB) |
+ *       +----------------------+ <--- Optional for fast boot
+ *       | DEFAULT MCTF (16 KB) |
+ *       +----------------------+ <--- Chip ID
+ *       | CHIP ID        (4 B) |
+ *       +----------------------+ <--- vdsp_info structure
+ *       | VDSP_INFO BIN (1 KB) |
+ *       +----------------------+ <--- dsp init data
+ *       | DSP INIT DATA (128 B)|
+ *       +----------------------+
+ *       | RESERVED      (4 B)  |
+ *       +----------------------+
+ */
+
+#define UCODE_ORCCODE_START		(DSP_UCODE_START)
+#define UCODE_DSP_INIT_DATA_PTR		(UCODE_ORCCODE_START + 0x30)
+#define UCODE_ORCME_START		(UCODE_ORCCODE_START + (3 << 20))
+#define UCODE_DEFAULT_BINARY_START	(UCODE_ORCME_START + (640 << 10))
+#define UCODE_DEFAULT_MCTF_START	(UCODE_DEFAULT_BINARY_START + (320 << 10))
+#define UCODE_CHIP_ID_START		(UCODE_DEFAULT_MCTF_START + (16 << 10))
+#define DSP_INIT_DATA_START		(UCODE_CHIP_ID_START + 4 + (1 << 10))
+
+/* AAA STATS For Pandora 3A (256 KB): belong to DSP_MEMD_MEMORY_OFFSET,
+ * start from DSP_AAA_STATS_START, it should be sync with amba_arch_mem.h.
+ *
+ *       +--------------------------+ <--- DSP_AAA_STATS_RGB_START (256 KB)
+ *       | RGB AAA STATS            |
+ *       | RGB_AAA_DATA_BLOCK_ARRAY |
+ *       +--------------------------+ <--- DSP_AAA_STATS_CFA_START
+ *       | CFA AAA STATS            |
+ *       | CFA_AAA_DATA_BLOCK_ARRAY |
+ *       +--------------------------+ <--- Others
+ *       | Others                   |
+ *       | Not used in Pandora 3A   |
+ *       +--------------------------+
+ */
+
+#define DSP_AAA_STATS_OFFSET		((3 << 20) - (256 << 10))
+#define DSP_AAA_STATS_START 		(DSP_UCODE_START + DSP_AAA_STATS_OFFSET)
+#define MAX_AAA_DATA_NUM			(10)
+#define RGB_AAA_DATA_BLOCK			(2176)
+#define CFA_AAA_DATA_BLOCK			(12672)
+#define RGB_AAA_DATA_BLOCK_ARRAY	(RGB_AAA_DATA_BLOCK * MAX_AAA_DATA_NUM)
+#define CFA_AAA_DATA_BLOCK_ARRAY	(CFA_AAA_DATA_BLOCK * MAX_AAA_DATA_NUM)
+#define DSP_AAA_STATS_RGB_START		(DSP_AAA_STATS_START)
+#define DSP_AAA_STATS_CFA_START		(DSP_AAA_STATS_START + RGB_AAA_DATA_BLOCK_ARRAY)
+
+#define FB_ISO_CFG_DATA_SIZE		(1024)
+
+/* layout for fastosd(overlay) in memory */
+/* 0x1000 = 4 KB */
+#define DSP_OVERLAY_FONT_INDEX_START	(DSP_OVERLAY_START + 0)
+#define DSP_OVERLAY_FONT_MAP_START	(DSP_OVERLAY_FONT_INDEX_START + 0x1000)
+#define DSP_OVERLAY_CLUT_START		(DSP_OVERLAY_FONT_MAP_START + 0x4000)
+#define DSP_OVERLAY_STRING_START	(DSP_OVERLAY_CLUT_START + 0x1000)
+#define DSP_OVERLAY_STRING_OUT_START	(DSP_OVERLAY_STRING_START + 0x1000)
+
+/*
+ * layout for DSP_FASTDATA in memory:
+ *
+ *       +-------------------------+ <--- DSP_FASTDATA_START
+ *       | struct iav_fb_hdr(128 B)|
+ *       +-------------------------+ <--- vin_video_format structure
+ *       | VIN_VIDEO_FORMAT (128 B)|
+ *       +-------------------------+ <--- vin_dsp_config structure
+ *       | VIN_DSP_CONFIG   (114 B)|
+ *       +-------------------------+ <--- Reserved
+ *       | Reserved        (16*8 B)|
+ *       +-------------------------+ <--- Preload AAA tone curve, not used now.
+ *       | AAA_TONE_CURVE  (1536 B)|
+ *       +-------------------------+ <--- Preload AAA rgb2yuv, not used now.
+ *       | AAA_RGB2YUV_MAT   (24 B)|
+ *       +-------------------------+ <--- Preload AAA local_expo, not used now.
+ *       | AAA_LOCAL_EXPO   (518 B)|
+ *       +-------------------------+
+ */
+
+#define DSP_FASTDATA_INVALID		(0xFF)
+
+#define AUDIO_PLAY_MAX_SIZE			(0x80000)
+
+#endif //__AMBA_S2L_MEM_ARCH_H__
diff --git a/include/eth/network.h b/include/eth/network.h
index bbc3874..dd5656e 100644
--- a/include/eth/network.h
+++ b/include/eth/network.h
@@ -7,12 +7,30 @@
  *    2006/06/19 - [Charles Chiou] created file
  *    2008/02/19 - [Allen Wang] changed to use capabilities and chip ID
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __NETWORK_H__
@@ -181,7 +199,7 @@ typedef struct bld_eth_dev_s
 		unsigned int fbi;
 	} isr;
 
-	unsigned char *regbase;
+	uintptr_t regbase;
 	unsigned int irq;
 	void *(*get_tx_frame_buf)(struct bld_eth_dev_s *);
 	int (*send_frame)(struct bld_eth_dev_s *, int);
@@ -262,6 +280,7 @@ extern int bld_netprogram(const char *pfile_name,
 
 /*===========================================================================*/
 extern void eth_init(bld_net_if_t *, bld_eth_dev_t *, u8 *);
+extern void eth_phy_clock_init(void);
 extern void eth_filter_source_address(struct bld_eth_dev_s *dev, u8 *hwaddr);
 extern void eth_pass_source_address(struct bld_eth_dev_s *dev);
 /*===========================================================================*/
diff --git a/include/eth/tftp.h b/include/eth/tftp.h
index 226f79f..30ba1da 100644
--- a/include/eth/tftp.h
+++ b/include/eth/tftp.h
@@ -4,12 +4,30 @@
  * History:
  *    2006/06/07 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __NETDEV__TFTP_H__
diff --git a/include/fio/firmfl.h b/include/fio/firmfl.h
index 2e78be3..3db84b1 100644
--- a/include/fio/firmfl.h
+++ b/include/fio/firmfl.h
@@ -6,12 +6,30 @@
  * History:
  *    2005/01/25 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __FIRMFL_H__
@@ -202,6 +220,7 @@
 #define PTB_HEADER_PAD_SIZE	(PTB_HEADER_SIZE - sizeof(u32) * 4)
 #define PTB_HEADER_MAGIC	0x524f4e47
 #define PTB_HEADER_VERSION	0x20140417
+#define BOOT_COMMAND_MAX	256
 
 typedef struct ptb_header_s
 {
@@ -280,13 +299,13 @@ typedef struct fldev_s
 	/* This section contains update by network  related settings */
 	u32	auto_dl;	/**< Automatic download? */
 	u32	tftpd;		/**< Boot loader's TFTP server */
-	u32	pri_addr;	/**< RTOS download address */
+	uintptr_t	pri_addr;	/**< RTOS download address */
 	char	pri_file[32];	/**< RTOS file name */
 	u32	pri_comp;	/**< RTOS compressed? */
-	u32	rmd_addr;	/**< Ramdisk download address */
+	uintptr_t	rmd_addr;	/**< Ramdisk download address */
 	char	rmd_file[32];	/**< Ramdisk file name */
 	u32	rmd_comp;	/**< Ramdisk compressed? */
-	u32	dsp_addr;	/**< DSP download address */
+	uintptr_t	dsp_addr;	/**< DSP download address */
 	char	dsp_file[32];	/**< DSP file name */
 	u32	dsp_comp;	/**< DSP compressed? */
 
@@ -300,6 +319,7 @@ typedef struct fldev_s
 	u8	rsa_key_e[16];
 	//u8	cryptochip_sn[12];
 	u8	sn_signature[128];
+	char	bootcmd[BOOT_COMMAND_MAX];
 } __attribute__((packed)) fldev_t;
 
 /**
@@ -375,7 +395,7 @@ typedef struct partimg_header_s
 } __attribute__((packed)) partimg_header_t;
 
 
-#if defined(CONFIG_NAND_USE_FLASH_BBT)
+#if defined(CONFIG_NAND_USE_FLASH_BBT) || defined(CONFIG_SPINAND_USE_FLASH_BBT)
 /**
  * struct nand_bbt_descr - bad block table descriptor
  *
@@ -422,7 +442,7 @@ typedef struct fwprog_result_s
 	u32	bad_blk_info;
 #define BST_BAD_BLK_OVER	0x00000001
 #define BLD_BAD_BLK_OVER	0x00000002
-#define SPL_BAD_BLK_OVER	0x00000004
+#define ATF_BAD_BLK_OVER	0x00000004
 #define PBA_BAD_BLK_OVER	0x00000008
 #define PRI_BAD_BLK_OVER	0x00000010
 #define SEC_BAD_BLK_OVER	0x00000020
@@ -458,24 +478,18 @@ typedef struct fwprog_cmd_s
 typedef struct flnand_s
 {
 	u32	control;		/**< Control parameter */
-	u32	timing0;		/**< Timing param. */
-	u32	timing1;		/**< Timing param. */
-	u32	timing2;		/**< Timing param. */
-	u32	timing3;		/**< Timing param. */
-	u32	timing4;		/**< Timing param. */
-	u32	timing5;		/**< Timing param. */
 	u32	nandtiming0;		/**<nand Timing param. */
 	u32	nandtiming1;		/**<nand Timing param. */
 	u32	nandtiming2;		/**<nand Timing param. */
 	u32	nandtiming3;		/**<nand Timing param. */
 	u32	nandtiming4;		/**<nand Timing param. */
 	u32	nandtiming5;		/**<nand Timing param. */
-	u32	banks;			/**< Total banks */
-	u32	blocks_per_bank;	/**< blocks_per_bank */
+	u32	nandtiming6;		/**<nand Timing param. */
 	u32	main_size;		/**< Main size */
 	u32	spare_size;		/**< Spare size */
-	u32	pages_per_block;	/**< Pages per block */
 	u32	block_size;		/**< Block size */
+	u32	pages_per_block;	/**< Pages per block */
+	u32	blocks_per_bank;	/**< blocks_per_bank */
 	u32	sblk[PART_MAX]; 	/**< Starting block */
 	u32	nblk[PART_MAX]; 	/**< Number of blocks */
 	u32	ecc_bits;		/**< ECC bits for new controller. */
@@ -495,10 +509,32 @@ typedef struct flspinor_s
 	u32	sectors_per_chip;
 	u32	ssec[TOTAL_FW_PARTS]; 	/**< Starting sectors */
 	u32	nsec[TOTAL_FW_PARTS]; 	/**< Number of sectors */
+	u32	jedec;
+	u8	addr_width;
+	u8	erase_opcode;
+	u8	reserved[2];
+	int   (*read)(u32 address, void *buf, int len);
 } flspinor_t;
 
 extern flspinor_t flspinor;
 
+/**
+ * Compile info. of SPI NAND
+ */
+typedef struct flspinand_s
+{
+	u32	chip_sel;
+	u32	main_size;		/**< Main size */
+	u32	spare_size;		/**< Spare size */
+	u32	pages_per_block;	/**< Pages per block */
+	u32	block_size;		/**< Block size */
+	u32	chip_size;
+	u32	sblk[PART_MAX]; 	/**< Starting block */
+	u32	nblk[PART_MAX]; 	/**< Number of blocks */
+} flspinand_t;
+
+extern flspinand_t flspinand;
+
 typedef struct sdmmc_s {
 	u8 verbose;
 	u8 slot;
@@ -517,7 +553,7 @@ typedef struct sdmmc_s {
 	u32 supported_mode;		/* Card supported mode */
 	u32 current_mode;
 	u32 bus_width;			/* Card supported bus width */
-	u64 capacity;			/* Card capacity */
+	u64 capacity;			/* Card capacity, unit is bytes: (capacity = sectors * sector_size) */
 	u32 ssec[PART_MAX]; 		/**< Starting sectors */
 	u32 nsec[PART_MAX];	 	/**< Number of sectors */
 } sdmmc_t;
@@ -537,6 +573,9 @@ extern void output_failure(int errcode);
 extern void output_report(const char *name, u32 flag);
 extern void flprog_show_meta(void);
 
+extern void flprog_bootcmd_disable(flpart_table_t *pptb);
+extern void flprog_bootcmd_enable(flpart_table_t *pptb, char *bootcmd);
+
 #endif  /* !__ASM__ */
 
 /*@}*/
diff --git a/include/fio/ftl_const.h b/include/fio/ftl_const.h
index d9a8cad..74c02bf 100644
--- a/include/fio/ftl_const.h
+++ b/include/fio/ftl_const.h
@@ -5,12 +5,30 @@
  *    2005/11/03 - [Chien Yang Chen] created file
  *    2006/05/08 - [Charles Chiou] moved to system/include/fio
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __FTL_CONST_H__
diff --git a/include/fio/partition.h b/include/fio/partition.h
index 6cf1367..cb12d39 100644
--- a/include/fio/partition.h
+++ b/include/fio/partition.h
@@ -7,25 +7,42 @@
  *    2009/10/06 - [Chien-Yang Chen] created file
  *    2014/02/13 - [Anthony Ginger] Amboot V2
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __FIRMWARE_PARTITION_H__
 #define __FIRMWARE_PARTITION_H__
 
-#include <basedef.h>
 #include <config.h>
 
 /*===========================================================================*/
 #define PART_BST		(0x00)
 #define PART_BLD		(0x01)
 #define PART_PTB		(0x02)
-#define PART_SPL		(0x03)
+#define PART_ATF		(0x03)
 #define PART_PBA		(0x04)
 #define PART_PRI		(0x05)
 #define PART_SEC		(0x06)
@@ -47,6 +64,7 @@
 #define PART_DEV_NAND		(0x01)
 #define PART_DEV_EMMC		(0x02)
 #define PART_DEV_SPINOR		(0x04)
+#define PART_DEV_SPINAND	(0x08)
 
 #define PART_MAX		20
 #define PART_MAX_WITH_RSV	32
@@ -74,8 +92,8 @@
 #ifndef AMBOOT_BLD_SIZE
 #define AMBOOT_BLD_SIZE		0
 #endif
-#ifndef AMBOOT_SPL_SIZE
-#define AMBOOT_SPL_SIZE		0
+#ifndef AMBOOT_ATF_SIZE
+#define AMBOOT_ATF_SIZE		0
 #endif
 #ifndef AMBOOT_PBA_SIZE
 #define AMBOOT_PBA_SIZE		0
@@ -126,8 +144,8 @@
 #ifndef PART_BLD_DEV
 #define PART_BLD_DEV		PART_DEV_AUTO
 #endif
-#ifndef PART_SPL_DEV
-#define PART_SPL_DEV		PART_DEV_AUTO
+#ifndef PART_ATF_DEV
+#define PART_ATF_DEV		PART_DEV_AUTO
 #endif
 #ifndef PART_PBA_DEV
 #define PART_PBA_DEV		PART_DEV_AUTO
@@ -172,8 +190,8 @@
 
 extern void get_part_size(int * part_size);
 extern const char *get_part_str(int part_id);
-extern u32 set_part_dev(u32 boot_from);
-extern u32 get_part_dev(u32 part_id);
+extern unsigned int set_part_dev(unsigned int boot_from);
+extern unsigned int get_part_dev(unsigned int part_id);
 
 /* ==========================================================================*/
 #endif
diff --git a/include/flash/nanddb.h b/include/flash/nanddb.h
index e5a92aa..9822bf8 100644
--- a/include/flash/nanddb.h
+++ b/include/flash/nanddb.h
@@ -6,233 +6,105 @@
  *    2007/12/18 - [Charles Chiou] changed the header to be compatible with
  *			AMBoot
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __FLASH__SLCNANDDB_H__
 #define __FLASH__SLCNANDDB_H__
 
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-#ifndef NULL
-#define NULL 0x0
-#endif
-
-#ifndef NAND_ID3
-#define NAND_ID3	0x00
-#endif
-
-#ifndef NAND_ID4
-#define NAND_ID4	0x00
-#endif
+#include <basedef.h>
+#include <ambhw/nand.h>
 
 #ifndef NAND_ID5
 #define NAND_ID5	0x00
 #endif
 
-#ifndef NAND_ECC_BIT
-#define NAND_ECC_BIT	1
+#ifndef NAND_TRHW
+#define NAND_TRHW	0
 #endif
 
-/* From AHB */
-
-/* FLASH_CTR_REG (NAND mode) */
-#if !defined(NAND_CTR_REG)
-#define NAND_CTR_A(x)			((x) << 28)
-#define NAND_CTR_SA			0x08000000
-#define NAND_CTR_SE			0x04000000
-#define NAND_CTR_C2			0x02000000
-#define NAND_CTR_P3			0x01000000
-#define NAND_CTR_I4			0x00800000
-#define NAND_CTR_RC			0x00400000
-#define NAND_CTR_CC			0x00200000
-#define NAND_CTR_CE			0x00100000
-#define NAND_CTR_EC_MAIN		0x00080000
-#define NAND_CTR_EC_SPARE		0x00040000
-#define NAND_CTR_EG_MAIN		0x00020000
-#define NAND_CTR_EG_SPARE		0x00010000
-#define NAND_CTR_WAS			0x00000400
-#define NAND_CTR_WP			0x00000200
-#define NAND_CTR_IE			0x00000100
-#define NAND_CTR_XS			0x00000080
-#define NAND_CTR_SZ_8G			0x00000070
-#define NAND_CTR_SZ_4G			0x00000060
-#define NAND_CTR_SZ_1G			0x00000040
-#define NAND_CTR_SZ_2G			0x00000050
-#define NAND_CTR_SZ_512M		0x00000030
-#define NAND_CTR_SZ_256M		0x00000020
-#define NAND_CTR_SZ_128M		0x00000010
-#define NAND_CTR_SZ_64M			0x00000000
-#define NAND_CTR_4BANK			0x00000008
-#define NAND_CTR_2BANK			0x00000004
-#define NAND_CTR_1BANK			0x00000000
-#define NAND_CTR_WD_64BIT		0x00000003
-#define NAND_CTR_WD_32BIT		0x00000002
-#define NAND_CTR_WD_16BIT		0x00000001
-#define NAND_CTR_WD_8BIT		0x00000000
+#ifndef NAND_TADL
+#define NAND_TADL	0
 #endif
 
-/* Define for plane mapping */
-
-/* Device does not support copyback command */
-#ifndef NAND_PLANE_MAP_0
-#define NAND_PLANE_MAP_0	0
-#endif
-/* plane address is according the lowest block address */
-#ifndef NAND_PLANE_MAP_1
-#define NAND_PLANE_MAP_1	1
-#endif
-/* plane address is according the highest block address */
-#ifndef NAND_PLANE_MAP_2
-#define NAND_PLANE_MAP_2	2
-#endif
-/* plane address is according the lowest and highest block address */
-#ifndef NAND_PLANE_MAP_3
-#define NAND_PLANE_MAP_3	3
+#ifndef NAND_TCRL
+#define NAND_TCRL	0
 #endif
 
-#define NAND_ID_K9K8_SERIAL	0xecd35195
-#define NAND_ID_K9K4_SERIAL	0xecdcc115
-
-struct nand_db_s {
-	const char *name;	/**< Name */
-	int	devices;	/**< Number of devices(chips) */
-	int	total_banks;	/**< Totals banks in system */
-
-	int	control;	/**< Control register setting */
-	int	manid;		/**< Manufacturer ID */
-	int	devid;		/**< Device ID */
-	int	id3;		/**< ID code from 3rd cycle */
-	int	id4;		/**< ID code from 4th cycle */
-	int	id5;		/**< ID code from 5th cycle */
-
-	/** Device info */
-	struct {
-		int	main_size;		/**< Main area size */
-		int	spare_size;		/**< Spare area size */
-		int	page_size;		/**< Page size */
-		int	pages_per_block;	/**< Pages per block */
-		int	blocks_per_plane;	/**< Blocks per plane */
-		int	blocks_per_zone;	/**< Blocks per zone */
-		int	blocks_per_bank;	/**< Blocks per bank */
-		int	planes_per_bank;	/**< Planes per bank */
-		int	total_blocks;		/**< Total blocks */
-		int	total_zones;		/**< Total zones */
-		int	total_planes;		/**< Total planes */
-		int	plane_mask;		/**< Plane address mask */
-		int	plane_map;		/**< Plane map */
-		int	column_cycles;		/**< Column access cycles */
-		int	page_cycles;		/**< Page access cycles */
-		int	id_cycles;		/**< ID access cycles */
-		int	chip_width;		/**< Chip data bus width */
-		int	chip_size;		/**< Chip size (MB) */
-		int	bus_width;		/**< Data bus width of ctrl. */
-		int	banks;			/**< Banks in device */
-		int	ecc_bits;		/**< ECC bits of device */
-	} devinfo;
+typedef struct nand_db_s {
+	const char *name;		/**< Name */
+	u32	id;			/**< ID code */
+	u32	id5;			/**< ID code from 5th cycle */
+	u16	main_size;		/**< Main area size */
+	u16	spare_size;		/**< Spare area size */
+	u32	pages_per_block;	/**< Pages per block */
+	u32	blocks_per_bank;	/**< Blocks per bank */
 
 	/** Chip(s) timing parameters */
-	struct {
-		int	tcls;
-		int	tals;
-		int	tcs;
-		int	tds;
-		int	tclh;
-		int	talh;
-		int	tch;
-		int	tdh;
-		int	twp;
-		int	twh;
-		int	twb;
-		int	trr;
-		int	trp;
-		int	treh;
-  		int	trb;
-		int	tceh;
-		int	trdelay;
-		int	tclr;
-		int	twhr;
-		int	tir;
-		int	tww;
-		int	trhz;
-		int	tar;
-	} timing;
-};
-
-extern const struct nand_db_s *G_nand_db[];
-
-#if defined(__cplusplus)
-}
-#endif
+	u32	timing0;
+	u32	timing1;
+	u32	timing2;
+	u32	timing3;
+	u32	timing4;
+	u32	timing5;
+	u32	timing6;
+} nand_db_t;
+
+#define __NANDDB_SECTION __attribute__((unused, __section__(".nanddb")))
+
+extern nand_db_t __nanddb_start[];
+extern nand_db_t __nanddb_end[];
 
 #define IMPLEMENT_NAND_DB_DEV(x)		\
-	const struct nand_db_s x = {		\
+	const nand_db_t x __NANDDB_SECTION = {		\
 		NAND_NAME,			\
-		NAND_DEVICES,			\
-		NAND_TOTAL_BANKS,		\
-		\
-		__NAND_CONTROL,			\
-		NAND_MANID,			\
-		NAND_DEVID,			\
-		NAND_ID3,			\
-		NAND_ID4,			\
+		NAND_MANID << 24 | NAND_DEVID << 16 | NAND_ID3 << 8 | NAND_ID4, \
 		NAND_ID5,			\
-		\
-		{	/* devinfo */		\
-			NAND_MAIN_SIZE,		\
-			NAND_SPARE_SIZE,	\
-			NAND_PAGE_SIZE,		\
-			NAND_PAGES_PER_BLOCK,	\
-			NAND_BLOCKS_PER_PLANE,	\
-			NAND_BLOCKS_PER_ZONE,	\
-			NAND_BLOCKS_PER_BANK,	\
-			NAND_PLANES_PER_BANK,	\
-			NAND_TOTAL_BLOCKS,	\
-			NAND_TOTAL_ZONES,	\
-			NAND_TOTAL_PLANES,	\
-			NAND_PLANE_ADDR_MASK,	\
-			NAND_PLANE_MAP,		\
-			NAND_COLUMN_CYCLES,	\
-			NAND_PAGE_CYCLES,	\
-			NAND_ID_CYCLES,		\
-			NAND_CHIP_WIDTH,	\
-			NAND_CHIP_SIZE_MB,	\
-			NAND_BUS_WIDTH,		\
-			NAND_BANKS_PER_DEVICE,	\
-			NAND_ECC_BIT,		\
-		},				\
-		{	/* timing */		\
-			NAND_TCLS,		\
-			NAND_TALS,		\
-			NAND_TCS,		\
-			NAND_TDS,		\
-			NAND_TCLH,		\
-			NAND_TALH,		\
-			NAND_TCH,		\
-			NAND_TDH,		\
-			NAND_TWP,		\
-			NAND_TWH,		\
-			NAND_TWB,		\
-			NAND_TRR,		\
-			NAND_TRP,		\
-			NAND_TREH,		\
-			NAND_TRB,		\
-			NAND_TCEH,		\
-			NAND_TRDELAY,		\
-			NAND_TCLR,		\
-			NAND_TWHR,		\
-			NAND_TIR,		\
-			NAND_TWW,		\
-			NAND_TRHZ,		\
-			NAND_TAR,		\
-		},				\
+		NAND_MAIN_SIZE,			\
+		NAND_SPARE_SIZE,		\
+		NAND_PAGES_PER_BLOCK,		\
+		NAND_BLOCKS_PER_BANK,		\
+		/* timing */			\
+		NAND_TCLS << 24 | NAND_TALS << 16 | NAND_TCS << 8 | NAND_TDS, \
+		NAND_TCLH << 24 | NAND_TALH << 16 | NAND_TCH << 8 | NAND_TDH, \
+		NAND_TWP << 24 | NAND_TWH << 16 | NAND_TWB << 8 | NAND_TRR, \
+		NAND_TRP << 24 | NAND_TREH << 16 | NAND_TRB << 8 | NAND_TCEH, \
+		(NAND_TRP + NAND_TREH) << 24 | NAND_TCLR << 16 | NAND_TWHR << 8 | NAND_TIR, \
+		NAND_TWW << 16 | NAND_TRHZ << 8 | NAND_TAR, \
+		NAND_TRHW << 16 | NAND_TADL << 8 | NAND_TCRL, \
 	}
 
+/* ==========================================================================*/
+
+#define NAND_BLACKLIST_ID	0xabcdefabcd
+
+#if (NAND_ID5 << 32 | NAND_MANID << 24 | NAND_DEVID << 16 | NAND_ID3 << 8 | NAND_ID4)	\
+	== NAND_BLACKLIST_ID
+#error "This NAND is in blacklist!"
 #endif
+
+#endif
+
diff --git a/include/flash/slcnand/asu1ga30ht.h b/include/flash/slcnand/asu1ga30ht.h
index 25e5467..1253111 100644
--- a/include/flash/slcnand/asu1ga30ht.h
+++ b/include/flash/slcnand/asu1ga30ht.h
@@ -4,25 +4,36 @@
  * History:
  *    2007/12/26 - [Geng-Ken Wu] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __ASU1GA30HT_H__
 #define __ASU1GA30HT_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Power_flash_asu1ga30ht_128MB_PG2K"
 
 #define NAND_MANID		0x92
 #define NAND_DEVID		0xf1
@@ -36,62 +47,8 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-/* Devcie has only one plane and the plane address should be set */
-/* outside of device. */
-#define NAND_PLANE_ADDR_BIT	28
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Power_flash_asu1ga30ht_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
 
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24	
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/ct48248ns486g1.h b/include/flash/slcnand/ct48248ns486g1.h
index d898a30..2f95992 100644
--- a/include/flash/slcnand/ct48248ns486g1.h
+++ b/include/flash/slcnand/ct48248ns486g1.h
@@ -4,25 +4,36 @@
  * History:
  *    2010/08/12 - [Geng Ken Wu] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __CT48248NS486G1_H__
 #define __CT48248NS486G1_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Chipsip CT48248NS486G1_64MB_PG2K"
 
 #define NAND_MANID		0xec /* spec define ech or 20h or adh is pass */
 #define NAND_DEVID		0xf1
@@ -36,62 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Chipsip CT48248NS486G1_64MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_DEVICES		1
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
@@ -117,7 +73,7 @@
 #define NAND_TWHR		60
 #define NAND_TIR		0
 #define NAND_TWW		100 /* not define in spec */
-#define NAND_TRHZ		50 
+#define NAND_TRHZ		50
 #define NAND_TAR		15
 
 #endif
diff --git a/include/flash/slcnand/f59l1g81a.h b/include/flash/slcnand/f59l1g81a.h
index d95651b..63e4b19 100644
--- a/include/flash/slcnand/f59l1g81a.h
+++ b/include/flash/slcnand/f59l1g81a.h
@@ -4,28 +4,36 @@
  * History:
  *    2012/05/22 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __F59L1G81A_H__
 #define __F59L1G81A_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"ESMT F59L1G81A_128MB_PG2K"
 
 #define NAND_MANID		0x92
 #define NAND_DEVID		0xf1
@@ -39,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"ESMT F59L1G81A_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/f59l1g81la.h b/include/flash/slcnand/f59l1g81la.h
index 5ec017e..301c7c7 100644
--- a/include/flash/slcnand/f59l1g81la.h
+++ b/include/flash/slcnand/f59l1g81la.h
@@ -4,28 +4,36 @@
  * History:
  *    2014/12/15 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __F59L1G81LA_H__
 #define __F59L1G81LA_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"ESMT F59L1G81LA_128MB_PG2K"
 
 #define NAND_MANID		0xC8
 #define NAND_DEVID		0xD1
@@ -40,59 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"ESMT F59L1G81LA_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/f59l1g81ma.h b/include/flash/slcnand/f59l1g81ma.h
index d0ada90..af95c6c 100644
--- a/include/flash/slcnand/f59l1g81ma.h
+++ b/include/flash/slcnand/f59l1g81ma.h
@@ -4,28 +4,36 @@
  * History:
  *    2014/12/15 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __F59L1G81MA_H__
 #define __F59L1G81MA_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"ESMT F59L1G81MA_128MB_PG2K"
 
 #define NAND_MANID		0xC8
 #define NAND_DEVID		0xD1
@@ -40,59 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"ESMT F59L1G81MA_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/f59l2g81a.h b/include/flash/slcnand/f59l2g81a.h
index 504ac04..0d6b4f8 100644
--- a/include/flash/slcnand/f59l2g81a.h
+++ b/include/flash/slcnand/f59l2g81a.h
@@ -4,29 +4,36 @@
  * History:
  *    2012/12/18 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __F59L2G81A_H__
 #define __F59L2G81A_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"ESMT F59L2G81A_256MB_PG2K"
 
 #define NAND_MANID		0xC8
 #define NAND_DEVID		0xDA
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"ESMT F59L2G81A_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/f59l4g81a.h b/include/flash/slcnand/f59l4g81a.h
index a23ea25..1adfeba 100644
--- a/include/flash/slcnand/f59l4g81a.h
+++ b/include/flash/slcnand/f59l4g81a.h
@@ -4,29 +4,36 @@
  * History:
  *    2012/12/18 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __F59L4G81A_H__
 #define __F59L4G81A_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"ESMT F59L4G81A_512MB_PG2K"
 
 #define NAND_MANID		0xC8
 #define NAND_DEVID		0xDC
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"ESMT F59L4G81A_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/h27u2g8f2c.h b/include/flash/slcnand/h27u2g8f2c.h
new file mode 100644
index 0000000..c472b3f
--- /dev/null
+++ b/include/flash/slcnand/h27u2g8f2c.h
@@ -0,0 +1,81 @@
+/**
+ * @file system/include/flash/slcnand/h27u2g8f2c.h
+ *
+ * History:
+ *    2016/01/26 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __H27U2G8F2C_H__
+#define __H27U2G8F2C_H__
+
+#define NAND_NAME		"Hynix H27U2G8F2C_256MB_PG2K"
+
+#define NAND_MANID		0xAD
+#define NAND_DEVID		0xDA
+#define NAND_ID3		0x90
+#define NAND_ID4		0x95
+#define NAND_ID5		0x44
+
+/**
+ * define for device info
+ */
+#define NAND_MAIN_SIZE		2048
+#define NAND_SPARE_SIZE		64
+#define NAND_PAGE_SIZE		2112
+#define NAND_PAGES_PER_BLOCK	64
+#define NAND_BLOCKS_PER_BANK	2048
+
+/**
+ * timing parameter in ns
+ */
+#define NAND_TCLS		12
+#define NAND_TALS		12
+#define NAND_TCS		20
+#define NAND_TDS		12
+#define NAND_TCLH		5
+#define NAND_TALH		5
+#define NAND_TCH		5
+#define NAND_TDH		5
+#define NAND_TWP		12
+#define NAND_TWH		10
+#define NAND_TWB		100
+#define NAND_TRR		20
+#define NAND_TRP		12
+#define NAND_TREH		10
+#define NAND_TRB		100	/* not in spec, use the same as TWB */
+#define NAND_TCEH		70	/* TRHZ - TCHZ =  */
+#define NAND_TRDELAY		20	/* tREA */
+#define NAND_TCLR		10
+#define NAND_TWHR		60
+#define NAND_TIR		0
+#define NAND_TWW		100
+#define NAND_TRHZ		100
+#define NAND_TAR		10
+
+#endif
+
diff --git a/include/flash/slcnand/h27u2g8f2d.h b/include/flash/slcnand/h27u2g8f2d.h
index 0eeb5e9..e523775 100644
--- a/include/flash/slcnand/h27u2g8f2d.h
+++ b/include/flash/slcnand/h27u2g8f2d.h
@@ -4,29 +4,36 @@
  * History:
  *    2015/05/13 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __H27U2G8F2D_H__
 #define __H27U2G8F2D_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Hynix H27U2G8F2D_256MB_PG2K"
 
 #define NAND_MANID		0xAD
 #define NAND_DEVID		0xDA
@@ -41,59 +48,7 @@
 #define NAND_SPARE_SIZE		128
 #define NAND_PAGE_SIZE		2176
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18 /* A18 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Hynix H27U2G8F2D_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/h27u518s2c.h b/include/flash/slcnand/h27u518s2c.h
index b275fdd..4819b48 100644
--- a/include/flash/slcnand/h27u518s2c.h
+++ b/include/flash/slcnand/h27u518s2c.h
@@ -4,23 +4,36 @@
  * History:
  *    2010/09/15 - [Evan Chen] created file
  *
- * Copyright (C) 2010-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __H27U518S2C_H__
 #define __H27U518S2C_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_512M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX H27U518S2C_64MB_PG512"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0x76
@@ -34,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	25
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	64
-#define NAND_BUS_WIDTH		8
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_NAME	"HYNIX H27U518S2C_64MB_PG512"
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27u1g8f2b.h b/include/flash/slcnand/hy27u1g8f2b.h
index da48e9c..3c2e93c 100644
--- a/include/flash/slcnand/hy27u1g8f2b.h
+++ b/include/flash/slcnand/hy27u1g8f2b.h
@@ -4,26 +4,37 @@
  * History:
  *    2009/02/21 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 
 #ifndef __HY27U1G8F2B_H__
 #define __HY27U1G8F2B_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME	"HYNIX HY27U1G8F2B_128MB_PG2K"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0xf1
@@ -37,62 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	27
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"HYNIX HY27U1G8F2B_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_DEVICES		1
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27ua081g1m.h b/include/flash/slcnand/hy27ua081g1m.h
index 45db2f9..e8e6804 100644
--- a/include/flash/slcnand/hy27ua081g1m.h
+++ b/include/flash/slcnand/hy27ua081g1m.h
@@ -4,23 +4,36 @@
  * History:
  *    2007/12/05 - [Dragon Chiang] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27UA081G1M_H__
 #define __HY27UA081G1M_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27UA081G1M_128MB_PG512"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0x79
@@ -34,60 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	8192
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-/* A26 and A25 are the plane address, so set A25 as plane start address. */
-#define NAND_PLANE_ADDR_BIT	(26 - 1)
-#define NAND_PLANE_MASK		0x3
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"HYNIX HY27UA081G1M_128MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27uf081g2a.h b/include/flash/slcnand/hy27uf081g2a.h
index be1ed3b..629bcb8 100644
--- a/include/flash/slcnand/hy27uf081g2a.h
+++ b/include/flash/slcnand/hy27uf081g2a.h
@@ -4,25 +4,36 @@
  * History:
  *    2007/12/26 - [Louvre Tseng] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27UF081G2A_H__
 #define __HY27UF081G2A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27UF081G2A_128MB_PG2K"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0xf1
@@ -36,62 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-/* Devcie has only one plane and the plane address should be set */
-/* outside of device. */
-#define NAND_PLANE_ADDR_BIT	28
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"HYNIX HY27UF081G2A_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24	
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27uf082g2a.h b/include/flash/slcnand/hy27uf082g2a.h
index 82ae071..1bdf04e 100644
--- a/include/flash/slcnand/hy27uf082g2a.h
+++ b/include/flash/slcnand/hy27uf082g2a.h
@@ -4,26 +4,36 @@
  * History:
  *    2009/08/05 - [Anthony Ginger] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27UF082G2A_H__
 #define __HY27UF082G2A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27UF082G2A_256MB_PG2K"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0xda
@@ -37,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"HYNIX HY27UF082G2A_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27uf082g2b.h b/include/flash/slcnand/hy27uf082g2b.h
index 6057e23..f1b0fa7 100644
--- a/include/flash/slcnand/hy27uf082g2b.h
+++ b/include/flash/slcnand/hy27uf082g2b.h
@@ -4,26 +4,36 @@
  * History:
  *    2009/05/26 - [Evan Chen] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27UF082G2B_H__
 #define __HY27UF082G2B_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27UF082G2B_256MB_PG2K"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0xda
@@ -37,60 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"HYNIX HY27UF082G2B_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27uf084g2b.h b/include/flash/slcnand/hy27uf084g2b.h
index bdbdb97..ab29e46 100644
--- a/include/flash/slcnand/hy27uf084g2b.h
+++ b/include/flash/slcnand/hy27uf084g2b.h
@@ -4,26 +4,36 @@
  * History:
  *    2009/11/10 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27UF084G2B_H__
 #define __HY27UF084G2B_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27UF084G2B_512MB_PG2K"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0xdc
@@ -37,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"HYNIX HY27UF084G2B_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27uf084g2m.h b/include/flash/slcnand/hy27uf084g2m.h
index ba642c5..3cff281 100644
--- a/include/flash/slcnand/hy27uf084g2m.h
+++ b/include/flash/slcnand/hy27uf084g2m.h
@@ -4,26 +4,36 @@
  * History:
  *    2009/04/01 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27UF084G2M_H__
 #define __HY27UF084G2M_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27UF084G2M_512MB_PG2K"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0xdc
@@ -37,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	29
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"HYNIX HY27UF084G2M_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27us08121a.h b/include/flash/slcnand/hy27us08121a.h
index 6a2183b..89b5122 100644
--- a/include/flash/slcnand/hy27us08121a.h
+++ b/include/flash/slcnand/hy27us08121a.h
@@ -4,23 +4,36 @@
  * History:
  *    2008/06/23 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27US08121A_H__
 #define __HY27US08121A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_512M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27US08121A_64MB_PG512"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0x76
@@ -34,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	25
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	64
-#define NAND_BUS_WIDTH		8
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_NAME	"HYNIX HY27US08121A_64MB_PG512"
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27us08121m.h b/include/flash/slcnand/hy27us08121m.h
index 260a4d2..8dea6cb 100644
--- a/include/flash/slcnand/hy27us08121m.h
+++ b/include/flash/slcnand/hy27us08121m.h
@@ -4,23 +4,36 @@
  * History:
  *    2005/11/8 - [Chien Yang] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27US08121M_H__
 #define __HY27US08121M_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_512M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27US08121M_64MB_PG512"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0x76
@@ -34,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	25
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	64
-#define NAND_BUS_WIDTH		8
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_NAME	"HYNIX HY27US08121M_64MB_PG512"
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27us08281a.h b/include/flash/slcnand/hy27us08281a.h
index 6dd8f37..f03c1c5 100644
--- a/include/flash/slcnand/hy27us08281a.h
+++ b/include/flash/slcnand/hy27us08281a.h
@@ -4,22 +4,36 @@
  * History:
  *    2007/02/08 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27US08281A_H__
 #define __HY27US08281A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_128M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27US08281A_16MB_PG512"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0x73
@@ -33,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	23
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	16
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"HYNIX HY27US08281A_16MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27us08561a.h b/include/flash/slcnand/hy27us08561a.h
index f0720bf..3bbf654 100644
--- a/include/flash/slcnand/hy27us08561a.h
+++ b/include/flash/slcnand/hy27us08561a.h
@@ -4,22 +4,36 @@
  * History:
  *    2007/08/15 - [Dragon Chiang] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27US08561A_H__
 #define __HY27US08561A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_256M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27US08561A_32MB_PG512"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0x75
@@ -33,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	24
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	32
-#define NAND_BUS_WIDTH		8
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_NAME	"HYNIX HY27US08561A_32MB_PG512"
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27us08561m.h b/include/flash/slcnand/hy27us08561m.h
index 9b57f70..d8dbadc 100644
--- a/include/flash/slcnand/hy27us08561m.h
+++ b/include/flash/slcnand/hy27us08561m.h
@@ -4,22 +4,36 @@
  * History:
  *    2005/11/8 - [Chien Yang] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27US08561M_H__
 #define __HY27US08561M_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_256M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27US08561M_32MB_PG512"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0x75
@@ -33,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	24
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	32
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"HYNIX HY27US08561M_32MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/hy27us4g86f2d.h b/include/flash/slcnand/hy27us4g86f2d.h
index e29aa28..40683fb 100644
--- a/include/flash/slcnand/hy27us4g86f2d.h
+++ b/include/flash/slcnand/hy27us4g86f2d.h
@@ -4,26 +4,36 @@
  * History:
  *    2011/06/09 - [Geng Ken Wu] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HY27US4G86f2D_H__
 #define __HY27US4G86f2D_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"HYNIX HY27US4G86F2D_512MB_PG2K"
 
 #define NAND_MANID		0xad
 #define NAND_DEVID		0xdc
@@ -37,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"HYNIX HY27US4G86F2D_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9f1208.h b/include/flash/slcnand/k9f1208.h
index 42b006a..1a047c6 100644
--- a/include/flash/slcnand/k9f1208.h
+++ b/include/flash/slcnand/k9f1208.h
@@ -4,24 +4,36 @@
  * History:
  *    2005/04/13 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9F1208_H__
 #define __K9F1208_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_I4 		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_512M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9F1208_64MB_PG512"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0x76
@@ -35,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	14
-#define NAND_PLANE_MASK		0x3
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	64
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9F1208_64MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9f1208x0c.h b/include/flash/slcnand/k9f1208x0c.h
index bb57333..63114d8 100644
--- a/include/flash/slcnand/k9f1208x0c.h
+++ b/include/flash/slcnand/k9f1208x0c.h
@@ -4,24 +4,36 @@
  * History:
  *    2007/04/13 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9F1208X0C_H__
 #define __K9F1208X0C_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_I4 		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_512M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9F1208X0C_64MB_PG512"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0x76
@@ -35,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	14
-#define NAND_PLANE_MASK		0x3
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	64
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9F1208X0C_64MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9f1g08.h b/include/flash/slcnand/k9f1g08.h
index 82def81..278f988 100644
--- a/include/flash/slcnand/k9f1g08.h
+++ b/include/flash/slcnand/k9f1g08.h
@@ -4,28 +4,36 @@
  * History:
  *    2005/06/23 - [Chien Yang Chen] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9F1G08_H__
 #define __K9F1G08_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9F1G08_128MB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xf1
@@ -39,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9F1G08_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9f1g08u0b.h b/include/flash/slcnand/k9f1g08u0b.h
index d2d6a85..fc68aaa 100644
--- a/include/flash/slcnand/k9f1g08u0b.h
+++ b/include/flash/slcnand/k9f1g08u0b.h
@@ -4,28 +4,36 @@
  * History:
  *    2010/05/26 - [Evan Chen] created file
  *
- * Copyright (C) 2010-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9F1G08U0B_H__
 #define __K9F1G08U0B_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9F1G08U0B_128MB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xf1
@@ -39,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9F1G08U0B_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9f1g08u0e.h b/include/flash/slcnand/k9f1g08u0e.h
index a9e03c3..09701d4 100644
--- a/include/flash/slcnand/k9f1g08u0e.h
+++ b/include/flash/slcnand/k9f1g08u0e.h
@@ -4,34 +4,43 @@
  * History:
  *    2013/10/24 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9F1G08U0E_H__
 #define __K9F1G08U0E_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9F1G08U0E_128MB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xf1
 #define NAND_ID3		0x00
 #define NAND_ID4		0x95
 #define NAND_ID5		0x41
+
 /**
  * define for device info
  */
@@ -39,59 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4//5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9F1G08U0E_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9f2808.h b/include/flash/slcnand/k9f2808.h
index a79dc74..f98ca90 100644
--- a/include/flash/slcnand/k9f2808.h
+++ b/include/flash/slcnand/k9f2808.h
@@ -4,21 +4,36 @@
  * History:
  *    2005/10/20 - [Chien Yang] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9F2808_H__
 #define __K9F2808_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_128M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9F2808_16MB_PG512"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0x73
@@ -32,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	14
-#define NAND_PLANE_MASK		0	/* 0 means no copyback support */
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	16
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9F2808_16MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9f2g08.h b/include/flash/slcnand/k9f2g08.h
index 4f8608c..485317b 100644
--- a/include/flash/slcnand/k9f2g08.h
+++ b/include/flash/slcnand/k9f2g08.h
@@ -4,29 +4,36 @@
  * History:
  *    2007/05/08 - [Dragon Chiang] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9F2G08_H__
 #define __K9F2G08_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9F2G08_256MB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xda
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18 /* A18 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9F2G08_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9f2g08u0c.h b/include/flash/slcnand/k9f2g08u0c.h
index 99734cf..9bef6a5 100644
--- a/include/flash/slcnand/k9f2g08u0c.h
+++ b/include/flash/slcnand/k9f2g08u0c.h
@@ -4,29 +4,36 @@
  * History:
  *    2011/02/09 - [Geng Ken Wu] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9F2G08u0c_H__
 #define __K9F2G08u0c_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9F2G08u0c_256MB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xda
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A18 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9F2G08u0c_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9f4g08u0a.h b/include/flash/slcnand/k9f4g08u0a.h
index ebad264..882b88c 100644
--- a/include/flash/slcnand/k9f4g08u0a.h
+++ b/include/flash/slcnand/k9f4g08u0a.h
@@ -4,29 +4,36 @@
  * History:
  *    2011/02/11 - [Geng Ken Wu] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9f4G08u0a_H__
 #define __K9f4G08u0a_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9f4G08U0A_512MB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xdc
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18 /* A18 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9f4G08U0A_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
@@ -113,11 +68,11 @@
 #define NAND_TREH		10
 #define NAND_TRB		100    /* not in spec, use the same as TWB */
 #define NAND_TCEH		70     /* TRHZ - TCHZ = 100 - 30 = 70 */
-#define NAND_TRDELAY		24     /* tREA */ 
+#define NAND_TRDELAY		24     /* tREA */
 #define NAND_TCLR		10
 #define NAND_TWHR		60
 #define NAND_TIR		0
-#define NAND_TWW		20	/* not in spec, use the same as TRR */	
+#define NAND_TWW		20	/* not in spec, use the same as TRR */
 #define NAND_TRHZ		100
 #define NAND_TAR		10
 
diff --git a/include/flash/slcnand/k9f4g08u0e.h b/include/flash/slcnand/k9f4g08u0e.h
index 0daeac8..0a304de 100644
--- a/include/flash/slcnand/k9f4g08u0e.h
+++ b/include/flash/slcnand/k9f4g08u0e.h
@@ -4,29 +4,36 @@
  * History:
  *    2014/03/06 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9F4G08U0E_H__
 #define __K9F4G08U0E_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9F4G08U0E_512MB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xdc
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9F4G08U0E_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9f5608.h b/include/flash/slcnand/k9f5608.h
index de0da4a..a16bf31 100644
--- a/include/flash/slcnand/k9f5608.h
+++ b/include/flash/slcnand/k9f5608.h
@@ -4,21 +4,36 @@
  * History:
  *    2005/10/18 - [Chien Yang] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9F5608_H__
 #define __K9F5608_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_256M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9F5608_32MB_PG512"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0x75
@@ -32,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	14
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	32
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9F5608_32MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9k4g08.h b/include/flash/slcnand/k9k4g08.h
index 7cd2d52..c1f8a39 100644
--- a/include/flash/slcnand/k9k4g08.h
+++ b/include/flash/slcnand/k9k4g08.h
@@ -4,29 +4,36 @@
  * History:
  *    2005/06/23 - [Chien Yang Chen] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9K4G08_H__
 #define __K9K4G08_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9K4G08_512MB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xdc
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	29 /* A29 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9K4G08_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9k8g08.h b/include/flash/slcnand/k9k8g08.h
index 4d3b551..897f4d7 100644
--- a/include/flash/slcnand/k9k8g08.h
+++ b/include/flash/slcnand/k9k8g08.h
@@ -4,29 +4,36 @@
  * History:
  *    2005/11/8 - [Chien Yang Chen] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9K8G08_H__
 #define __K9K8G08_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_8G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9K8G08_1GB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xd3
@@ -40,63 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	8192
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR1_BIT	18
-#define NAND_PLANE_ADDR2_BIT	30
-#define NAND_PLANE_MASK		(0x1 << (NAND_PLANE_ADDR1_BIT - 	\
-					 NAND_BLOCK_ADDR_BIT)	|	\
-				 0x1 << (NAND_PLANE_ADDR2_BIT - 	\
-					 NAND_BLOCK_ADDR_BIT))
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	NAND_PLANE_MASK
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	1024
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9K8G08_1GB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9nbg08.h b/include/flash/slcnand/k9nbg08.h
index 6f1b5b3..e7a6c97 100644
--- a/include/flash/slcnand/k9nbg08.h
+++ b/include/flash/slcnand/k9nbg08.h
@@ -4,29 +4,36 @@
  * History:
  *    2005/11/8 - [Chien Yang Chen] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9NBG08_H__
 #define __K9NBG08_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_8G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9NBG08_4GB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xd3
@@ -40,63 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	8192
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	4
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR1_BIT	18
-#define NAND_PLANE_ADDR2_BIT	30
-#define NAND_PLANE_MASK		(0x1 << (NAND_PLANE_ADDR1_BIT - 	\
-				 	 NAND_BLOCK_ADDR_BIT)	|	\
-				 0x1 << (NAND_PLANE_ADDR2_BIT - 	\
-					 NAND_BLOCK_ADDR_BIT))
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	NAND_PLANE_MASK
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_3
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	4096
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9NBG08_4GB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9w8g08.h b/include/flash/slcnand/k9w8g08.h
index 3b0e0bd..8fadd18 100644
--- a/include/flash/slcnand/k9w8g08.h
+++ b/include/flash/slcnand/k9w8g08.h
@@ -4,29 +4,36 @@
  * History:
  *    2005/06/23 - [Chien Yang Chen] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9W8G08_H__
 #define __K9W8G08_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9W8G08_1GB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xdc
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	2
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	29
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	1024
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9W8G08_1GB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/k9wag08.h b/include/flash/slcnand/k9wag08.h
index 2a771b8..2b45c64 100644
--- a/include/flash/slcnand/k9wag08.h
+++ b/include/flash/slcnand/k9wag08.h
@@ -4,29 +4,36 @@
  * History:
  *    2005/11/8 - [Chien Yang Chen] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __K9WAG08_H__
 #define __K9WAG08_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_8G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SAMSUNG K9WAG08_2GB_PG2K"
 
 #define NAND_MANID		0xec
 #define NAND_DEVID		0xd3
@@ -40,63 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	8192
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	2
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR1_BIT	18
-#define NAND_PLANE_ADDR2_BIT	30
-#define NAND_PLANE_MASK		(0x1 << (NAND_PLANE_ADDR1_BIT - 	\
-					 NAND_BLOCK_ADDR_BIT)	|	\
-				 0x1 << (NAND_PLANE_ADDR2_BIT - 	\
-					 NAND_BLOCK_ADDR_BIT))
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	NAND_PLANE_MASK
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_3
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	2048
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SAMSUNG K9WAG08_2GB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/mt29f1g08abaea.h b/include/flash/slcnand/mt29f1g08abaea.h
index 58df69c..507ba1c 100644
--- a/include/flash/slcnand/mt29f1g08abaea.h
+++ b/include/flash/slcnand/mt29f1g08abaea.h
@@ -4,28 +4,36 @@
  * History:
  *    2015/04/07 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __MT29F1G08ABAEA_H__
 #define __MT29F1G08ABAEA_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Micron MT29F1G08ABAEA_128MB_PG2K"
 
 #define NAND_MANID		0x2c
 #define NAND_DEVID		0xF1
@@ -40,59 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18 /* A18 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Micron MT29F1G08ABAEA_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/mt29f2g08aac.h b/include/flash/slcnand/mt29f2g08aac.h
index c1f9c1f..e0605ad 100644
--- a/include/flash/slcnand/mt29f2g08aac.h
+++ b/include/flash/slcnand/mt29f2g08aac.h
@@ -4,29 +4,36 @@
  * History:
  *    2007/05/08 - [Dragon Chiang] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __MT29F2G08_H__
 #define __MT29F2G08_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Micron MT29F2G08"
 
 #define NAND_MANID		0x2c
 #define NAND_DEVID		0xda
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	2048
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	16
-#define NAND_PLANE_ADDR_BIT	16 /* A16 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		1
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Micron MT29F2G08"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/mt29f2g08aba.h b/include/flash/slcnand/mt29f2g08aba.h
index 853f3a0..c83da91 100644
--- a/include/flash/slcnand/mt29f2g08aba.h
+++ b/include/flash/slcnand/mt29f2g08aba.h
@@ -4,29 +4,36 @@
  * History:
  *    2010/06/28 - [Evan Chen] created file
  *
- * Copyright (C) 2010-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __MT29F2G08ABA_H__
 #define __MT29F2G08ABA_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Micron MT29F2G08ABA_256MB_PG2K"
 
 #define NAND_MANID		0x2c
 #define NAND_DEVID		0xda
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18 /* A18 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Micron MT29F2G08ABA_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/mt29f2g08abafa.h b/include/flash/slcnand/mt29f2g08abafa.h
index 89a318f..f9ce3da 100644
--- a/include/flash/slcnand/mt29f2g08abafa.h
+++ b/include/flash/slcnand/mt29f2g08abafa.h
@@ -4,29 +4,36 @@
  * History:
  *    2015/03/24 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __MT29F2G08ABAFA_H__
 #define __MT29F2G08ABAFA_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Micron MT29F2G08ABAFA_256MB_PG2K"
 
 #define NAND_MANID		0x2c
 #define NAND_DEVID		0xda
@@ -41,59 +48,7 @@
 #define NAND_SPARE_SIZE		128
 #define NAND_PAGE_SIZE		2176
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18 /* A18 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Micron MT29F2G08ABAFA_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/mt29f2g08abaga.h b/include/flash/slcnand/mt29f2g08abaga.h
new file mode 100644
index 0000000..a9aa100
--- /dev/null
+++ b/include/flash/slcnand/mt29f2g08abaga.h
@@ -0,0 +1,81 @@
+/**
+ * @file system/include/flash/slcnand/mt29f2g08abaga.h
+ *
+ * History:
+ *    2017/09/14 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MT29F2G08ABAGA_H__
+#define __MT29F2G08ABAGA_H__
+
+#define NAND_NAME		"Micron MT29F2G08ABAGA_256MB_PG2K"
+
+#define NAND_MANID		0x2c
+#define NAND_DEVID		0xda
+#define NAND_ID3		0x90
+#define NAND_ID4		0x95
+#define NAND_ID5		0x06
+
+/**
+ * define for device info
+ */
+#define NAND_MAIN_SIZE		2048
+#define NAND_SPARE_SIZE		128
+#define NAND_PAGE_SIZE		2176
+#define NAND_PAGES_PER_BLOCK	64
+#define NAND_BLOCKS_PER_BANK	2048
+
+/**
+ * timing parameter in ns
+ */
+#define NAND_TCLS		10
+#define NAND_TALS		10
+#define NAND_TCS		15
+#define NAND_TDS		7
+#define NAND_TCLH		5
+#define NAND_TALH		5
+#define NAND_TCH		5
+#define NAND_TDH		5
+#define NAND_TWP		10
+#define NAND_TWH		7
+#define NAND_TWB		100
+#define NAND_TRR		20
+#define NAND_TRP		10
+#define NAND_TREH		7
+#define NAND_TRB		100	/* not in spec, use the same as TWB */
+#define NAND_TCEH		70	/* TRHZ - TCHZ =  */
+#define NAND_TRDELAY		16	/* tREA */
+#define NAND_TCLR		10
+#define NAND_TWHR		60
+#define NAND_TIR		0
+#define NAND_TWW		100
+#define NAND_TRHZ		100
+#define NAND_TAR		10
+
+#endif
+
diff --git a/include/flash/slcnand/mt29f2g08abbea.h b/include/flash/slcnand/mt29f2g08abbea.h
new file mode 100644
index 0000000..34f9c6e
--- /dev/null
+++ b/include/flash/slcnand/mt29f2g08abbea.h
@@ -0,0 +1,81 @@
+/**
+ * @file system/include/flash/slcnand/mt29f2g08abbea.h
+ *
+ * History:
+ *    2016/11/09 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MT29F2G08ABBEA_H__
+#define __MT29F2G08ABBEA_H__
+
+#define NAND_NAME		"Micron MT29F2G08ABBEA_256MB_PG2K"
+
+#define NAND_MANID		0x2C
+#define NAND_DEVID		0xAA
+#define NAND_ID3		0x90
+#define NAND_ID4		0x15
+#define NAND_ID5		0x06
+
+/**
+ * define for device info
+ */
+#define NAND_MAIN_SIZE		2048
+#define NAND_SPARE_SIZE		64
+#define NAND_PAGE_SIZE		2112
+#define NAND_PAGES_PER_BLOCK	64
+#define NAND_BLOCKS_PER_BANK	2048
+
+/**
+ * timing parameter in ns
+ */
+#define NAND_TCLS		10
+#define NAND_TALS		10
+#define NAND_TCS		20
+#define NAND_TDS		10
+#define NAND_TCLH		5
+#define NAND_TALH		5
+#define NAND_TCH		5
+#define NAND_TDH		5
+#define NAND_TWP		12
+#define NAND_TWH		10
+#define NAND_TWB		100
+#define NAND_TRR		20
+#define NAND_TRP		12
+#define NAND_TREH		10
+#define NAND_TRB		100	/* not in spec, use the same as TWB */
+#define NAND_TCEH		15	/* TRHZ - TCHZ =  65 - 50*/
+#define NAND_TRDELAY		22	/* tREA */
+#define NAND_TCLR		10
+#define NAND_TWHR		80
+#define NAND_TIR		0
+#define NAND_TWW		100
+#define NAND_TRHZ		65
+#define NAND_TAR		10
+
+#endif
+
diff --git a/include/flash/slcnand/mt29f4g08abada.h b/include/flash/slcnand/mt29f4g08abada.h
index 0ab55d0..d18fb6a 100644
--- a/include/flash/slcnand/mt29f4g08abada.h
+++ b/include/flash/slcnand/mt29f4g08abada.h
@@ -4,34 +4,42 @@
  * History:
  *    2007/05/08 - [Dragon Chiang] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __MT29F4G08ABADA_H__
 #define __MT29F4G08ABADA_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Micron MT29F4G08ABADA_512MB_PG2K"
 
 #define NAND_MANID		0x2c
 #define NAND_DEVID		0xdc
-#define NAND_ID3		0x95
-#define NAND_ID4		0x56
+#define NAND_ID3		0x90
+#define NAND_ID4		0x95
+#define NAND_ID5		0x56
 
 /**
  * define for device info
@@ -40,59 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Micron MT29F4G08ABADA_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
@@ -113,11 +69,11 @@
 #define NAND_TREH		7
 #define NAND_TRB		100	/* not in spec, use the same as TWB */
 #define NAND_TCEH		50	/* TRHZ - TCHZ =  */
-#define NAND_TRDELAY		18	/* tREA */
+#define NAND_TRDELAY		16	/* tREA */
 #define NAND_TCLR		10
 #define NAND_TWHR		60
 #define NAND_TIR		0
-#define NAND_TWW		30	/* not in spec, use the same as TRR */
+#define NAND_TWW		100	/* not in spec, use the same as TRR */
 #define NAND_TRHZ		100
 #define NAND_TAR		10
 
diff --git a/include/flash/slcnand/mt29f4g08abbda.h b/include/flash/slcnand/mt29f4g08abbda.h
new file mode 100644
index 0000000..97d4208
--- /dev/null
+++ b/include/flash/slcnand/mt29f4g08abbda.h
@@ -0,0 +1,81 @@
+/**
+ * @file system/include/flash/slcnand/mt29f4g08abbda.h
+ *
+ * History:
+ *    2016/08/08 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MT29F4G08ABBDA_H__
+#define __MT29F4G08ABBDA_H__
+
+#define NAND_NAME		"Micron MT29F4G08ABBDA_512MB_PG2K"
+
+#define NAND_MANID		0x2c
+#define NAND_DEVID		0xac
+#define NAND_ID3		0x90
+#define NAND_ID4		0x15
+#define NAND_ID5		0x56
+
+/**
+ * define for device info
+ */
+#define NAND_MAIN_SIZE		2048
+#define NAND_SPARE_SIZE		64
+#define NAND_PAGE_SIZE		2112
+#define NAND_PAGES_PER_BLOCK	64
+#define NAND_BLOCKS_PER_BANK	4096
+
+/**
+ * timing parameter in ns
+ */
+#define NAND_TCLS		10
+#define NAND_TALS		10
+#define NAND_TCS		20
+#define NAND_TDS		10
+#define NAND_TCLH		5
+#define NAND_TALH		5
+#define NAND_TCH		5
+#define NAND_TDH		5
+#define NAND_TWP		12
+#define NAND_TWH		10
+#define NAND_TWB		100
+#define NAND_TRR		20
+#define NAND_TRP		12
+#define NAND_TREH		10
+#define NAND_TRB		100	/* not in spec, use the same as TWB */
+#define NAND_TCEH		15	/* TRHZ - TCHZ =  65 - 50*/
+#define NAND_TRDELAY		22	/* tREA */
+#define NAND_TCLR		10
+#define NAND_TWHR		80
+#define NAND_TIR		0
+#define NAND_TWW		100	/* not in spec, use the same as TRR */
+#define NAND_TRHZ		65
+#define NAND_TAR		10
+
+#endif
+
diff --git a/include/flash/slcnand/mt29f8g08daa.h b/include/flash/slcnand/mt29f8g08daa.h
index 0254d7e..9a96ed2 100644
--- a/include/flash/slcnand/mt29f8g08daa.h
+++ b/include/flash/slcnand/mt29f8g08daa.h
@@ -4,29 +4,36 @@
  * History:
  *    2007/05/08 - [Dragon Chiang] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __MT29F8G08DAA_H__
 #define __MT29F8G08DAA_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Micron MT29F8G08DAA_1GB_PG2K"
 
 #define NAND_MANID		0x2c
 #define NAND_DEVID		0xdc
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
-#define NAND_BLOCKS_PER_BANK	4096	
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	2
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		1
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	1024
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Micron MT29F8G08DAA_1GB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
+#define NAND_BLOCKS_PER_BANK	4096
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/mx30lf1g08aa.h b/include/flash/slcnand/mx30lf1g08aa.h
index 145ca34..33c2a1f 100644
--- a/include/flash/slcnand/mx30lf1g08aa.h
+++ b/include/flash/slcnand/mx30lf1g08aa.h
@@ -4,28 +4,36 @@
  * History:
  *    2014/03/27 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __MX30LF1G08AA_H__
 #define __MX30LF1G08AA_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Macronix MX30LF1G08AA_128MB_PG2K"
 
 #define NAND_MANID		0xC2
 #define NAND_DEVID		0xF1
@@ -39,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Macronix MX30LF1G08AA_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/mx30lf1ge8ab.h b/include/flash/slcnand/mx30lf1ge8ab.h
index fae62af..2844043 100644
--- a/include/flash/slcnand/mx30lf1ge8ab.h
+++ b/include/flash/slcnand/mx30lf1ge8ab.h
@@ -4,28 +4,36 @@
  * History:
  *    2015/07/30 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __MX30LF1GE8AB_H__
 #define __MX30LF1GE8AB_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Macronix MX30LF1GE8AB_128MB_PG2K"
 
 #define NAND_MANID		0xC2
 #define NAND_DEVID		0xF1
@@ -39,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Macronix MX30LF1GE8AB_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/mx30lf2ge8ab.h b/include/flash/slcnand/mx30lf2ge8ab.h
index c48611a..cadf8be 100644
--- a/include/flash/slcnand/mx30lf2ge8ab.h
+++ b/include/flash/slcnand/mx30lf2ge8ab.h
@@ -4,35 +4,43 @@
  * History:
  *    2015/04/08 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __MX30LF2GE8AB_H__
 #define __MX30LF2GE8AB_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"Macronix MX30LF2GE8AB_256MB_PG2K"
 
 #define NAND_MANID		0xC2
 #define NAND_DEVID		0xDA
 #define NAND_ID3		0x90
 #define NAND_ID4		0x95
 #define NAND_ID5		0x86
+
 /**
  * define for device info
  */
@@ -40,59 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"Macronix MX30LF2GE8AB_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/mx30lf4ge8ab.h b/include/flash/slcnand/mx30lf4ge8ab.h
new file mode 100644
index 0000000..6711a5d
--- /dev/null
+++ b/include/flash/slcnand/mx30lf4ge8ab.h
@@ -0,0 +1,79 @@
+/**
+ * @file system/include/flash/slcnand/mx30lf4ge8ab.h
+ *
+ * History:
+ *    2015/12/24 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MX30LF4GE8AB_H__
+#define __MX30LF4GE8AB_H__
+
+#define NAND_NAME		"Macronix MX30LF4GE8AB_512MB_PG2K"
+
+#define NAND_MANID		0xC2
+#define NAND_DEVID		0xDC
+#define NAND_ID3		0x90
+#define NAND_ID4		0x95
+#define NAND_ID5		0xD6
+
+/**
+ * define for device info
+ */
+#define NAND_MAIN_SIZE		2048
+#define NAND_SPARE_SIZE		64
+#define NAND_PAGE_SIZE		2112
+#define NAND_PAGES_PER_BLOCK	64
+#define NAND_BLOCKS_PER_BANK	4096
+
+/**
+ * timing parameter in ns
+ */
+#define NAND_TCLS		15
+#define NAND_TALS		15
+#define NAND_TCS		20
+#define NAND_TDS		10
+#define NAND_TCLH		5
+#define NAND_TALH		5
+#define NAND_TCH		5
+#define NAND_TDH		5
+#define NAND_TWP		15
+#define NAND_TWH		10
+#define NAND_TWB		100
+#define NAND_TRR		20
+#define NAND_TRP		15
+#define NAND_TREH		10
+#define NAND_TRB		100 /* not define in spec, use the same twb */
+#define NAND_TCEH		0  /* trhz - tchz = 50 - 50 = 0 */
+#define NAND_TRDELAY		25  /* trea */
+#define NAND_TCLR		15
+#define NAND_TWHR		60
+#define NAND_TIR		0
+#define NAND_TWW		100  /* not defined in datasheet */
+#define NAND_TRHZ		50
+#define NAND_TAR		15
+#endif
diff --git a/include/flash/slcnand/numonyx02gw3b2d.h b/include/flash/slcnand/numonyx02gw3b2d.h
index bbeda79..f7315bf 100644
--- a/include/flash/slcnand/numonyx02gw3b2d.h
+++ b/include/flash/slcnand/numonyx02gw3b2d.h
@@ -4,29 +4,36 @@
  * History:
  *    2009/08/05 - [Evan Chen] created file
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __NUMONYX02GW3B2D_H__
 #define __NUMONYX02GW3B2D_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"NUMONYX NAND02GW3B2D_256MB_PG2K"
 
 #define NAND_MANID		0x20
 #define NAND_DEVID		0xda
@@ -40,60 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	18
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_1
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"NUMONYX NAND02GW3B2D_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/s34ml01g1.h b/include/flash/slcnand/s34ml01g1.h
index 6a8a5c1..c936599 100644
--- a/include/flash/slcnand/s34ml01g1.h
+++ b/include/flash/slcnand/s34ml01g1.h
@@ -4,28 +4,36 @@
  * History:
  *    2012/12/27 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __S34ML01G1_H__
 #define __S34ML01G1_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SPANSION S34ML01G1_128MB_PG2K"
 
 #define NAND_MANID		0x01
 #define NAND_DEVID		0xF1
@@ -39,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SPANSION S34ML01G1_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/s34ml01g2.h b/include/flash/slcnand/s34ml01g2.h
index 594e0f9..953a7a6 100644
--- a/include/flash/slcnand/s34ml01g2.h
+++ b/include/flash/slcnand/s34ml01g2.h
@@ -4,28 +4,36 @@
  * History:
  *    2012/12/27 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __S34ML01G2_H__
 #define __S34ML01G2_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SPANSION S34ML01G2_128MB_PG2K"
 
 #define NAND_MANID		0x01
 #define NAND_DEVID		0xF1
@@ -39,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SPANSION S34ML01G2_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/s34ml02g1.h b/include/flash/slcnand/s34ml02g1.h
index a93e54e..f2a3c6c 100644
--- a/include/flash/slcnand/s34ml02g1.h
+++ b/include/flash/slcnand/s34ml02g1.h
@@ -4,29 +4,36 @@
  * History:
  *    2012/12/27 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __S34ML02G1_H__
 #define __S34ML02G1_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SPANSION S34ML02G1_256MB_PG2K"
 
 #define NAND_MANID		0x01
 #define NAND_DEVID		0xDA
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SPANSION S34ML02G1_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/s34ml02g2.h b/include/flash/slcnand/s34ml02g2.h
index 8abf25d..0978043 100644
--- a/include/flash/slcnand/s34ml02g2.h
+++ b/include/flash/slcnand/s34ml02g2.h
@@ -4,29 +4,36 @@
  * History:
  *    2014/02/14 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __S34ML02G2_H__
 #define __S34ML02G2_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SPANSION S34ML02G2_256MB_PG2K"
 
 #define NAND_MANID		0x01
 #define NAND_DEVID		0xDA
@@ -41,59 +48,7 @@
 #define NAND_SPARE_SIZE		128
 #define NAND_PAGE_SIZE		2176
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SPANSION S34ML02G2_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/s34ml04g1.h b/include/flash/slcnand/s34ml04g1.h
index 39e63ee..1d6fa0b 100644
--- a/include/flash/slcnand/s34ml04g1.h
+++ b/include/flash/slcnand/s34ml04g1.h
@@ -4,29 +4,36 @@
  * History:
  *    2012/12/27 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __S34ML04G1_H__
 #define __S34ML04G1_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SPANSION S34ML04G1_512MB_PG2K"
 
 #define NAND_MANID		0x01
 #define NAND_DEVID		0xDC
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SPANSION S34ML04G1_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/s34ml04g2.h b/include/flash/slcnand/s34ml04g2.h
index 1237e24..60378b3 100644
--- a/include/flash/slcnand/s34ml04g2.h
+++ b/include/flash/slcnand/s34ml04g2.h
@@ -4,29 +4,36 @@
  * History:
  *    2014/01/24 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __S34ML04G2_H__
 #define __S34ML04G2_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"SPANSION S34ML04G2_512MB_PG2K"
 
 #define NAND_MANID		0x01
 #define NAND_DEVID		0xDC
@@ -41,59 +48,7 @@
 #define NAND_SPARE_SIZE		128
 #define NAND_PAGE_SIZE		2176
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"SPANSION S34ML04G2_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/s34ml08g1.h b/include/flash/slcnand/s34ml08g1.h
new file mode 100644
index 0000000..37ccaaa
--- /dev/null
+++ b/include/flash/slcnand/s34ml08g1.h
@@ -0,0 +1,80 @@
+/**
+ * @file system/include/flash/slcnand/s34ml08g1.h
+ *
+ * History:
+ *    2017/05/10 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __S34ML08G1_H__
+#define __S34ML08G1_H__
+
+#define NAND_NAME		"SPANSION S34ML08G1_1GB_PG2K"
+
+#define NAND_MANID		0x01
+#define NAND_DEVID		0xD3
+#define NAND_ID3		0xD1
+#define NAND_ID4		0x95
+#define NAND_ID5		0x58
+
+/**
+ * define for device info
+ */
+#define NAND_MAIN_SIZE		2048
+#define NAND_SPARE_SIZE		64
+#define NAND_PAGE_SIZE		2112
+#define NAND_PAGES_PER_BLOCK	64
+#define NAND_BLOCKS_PER_BANK	8192
+
+/**
+ * timing parameter in ns
+ */
+#define NAND_TCLS		12
+#define NAND_TALS		10
+#define NAND_TCS		20
+#define NAND_TDS		10
+#define NAND_TCLH		5
+#define NAND_TALH		5
+#define NAND_TCH		5
+#define NAND_TDH		5
+#define NAND_TWP		12
+#define NAND_TWH		10
+#define NAND_TWB		100
+#define NAND_TRR		20
+#define NAND_TRP		12
+#define NAND_TREH		10
+#define NAND_TRB		100 /* not defined in datasheet */
+#define NAND_TCEH		70  /* trhz - tchz = 100 - 30 = 70 */
+#define NAND_TRDELAY		20  /* trea */
+#define NAND_TCLR		10
+#define NAND_TWHR		60
+#define NAND_TIR		0
+#define NAND_TWW		100  /* not defined in datasheet */
+#define NAND_TRHZ		100
+#define NAND_TAR		10
+
+#endif
diff --git a/include/flash/slcnand/s34ms02g1.h b/include/flash/slcnand/s34ms02g1.h
new file mode 100644
index 0000000..650255f
--- /dev/null
+++ b/include/flash/slcnand/s34ms02g1.h
@@ -0,0 +1,79 @@
+/**
+ * @file system/include/flash/slcnand/s34ms02g1.h
+ *
+ * History:
+ *    2017/07/06 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __S34MS02G1_H__
+#define __S34MS02G1_H__
+
+#define NAND_NAME		"SPANSION S34MS02G1_256MB_PG2K"
+
+#define NAND_MANID		0x01
+#define NAND_DEVID		0xAA
+#define NAND_ID3		0x90
+#define NAND_ID4		0x15
+#define NAND_ID5		0x44
+/**
+ * define for device info
+ */
+#define NAND_MAIN_SIZE		2048
+#define NAND_SPARE_SIZE		64
+#define NAND_PAGE_SIZE		2112
+#define NAND_PAGES_PER_BLOCK	64
+#define NAND_BLOCKS_PER_BANK	2048
+
+/**
+ * timing parameter in ns
+ */
+#define NAND_TCLS		25
+#define NAND_TALS		25
+#define NAND_TCS		35
+#define NAND_TDS		20
+#define NAND_TCLH		10
+#define NAND_TALH		10
+#define NAND_TCH		10
+#define NAND_TDH		10
+#define NAND_TWP		25
+#define NAND_TWH		15
+#define NAND_TWB		100
+#define NAND_TRR		20
+#define NAND_TRP		12
+#define NAND_TREH		10
+#define NAND_TRB		100 /* not defined in datasheet */
+#define NAND_TCEH		70  /* trhz - tchz = 100 - 30 = 70 */
+#define NAND_TRDELAY		20  /* trea */
+#define NAND_TCLR		10
+#define NAND_TWHR		60
+#define NAND_TIR		0
+#define NAND_TWW		100  /* not defined in datasheet */
+#define NAND_TRHZ		100
+#define NAND_TAR		10
+
+#endif
diff --git a/include/flash/slcnand/s34ms04g1.h b/include/flash/slcnand/s34ms04g1.h
new file mode 100644
index 0000000..11c2c3a
--- /dev/null
+++ b/include/flash/slcnand/s34ms04g1.h
@@ -0,0 +1,79 @@
+/**
+ * @file system/include/flash/slcnand/s34ms04g1.h
+ *
+ * History:
+ *    2017/05/19 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __S34MS04G1_H__
+#define __S34MS04G1_H__
+
+#define NAND_NAME		"SPANSION S34MS04G1_512MB_PG2K"
+
+#define NAND_MANID		0x01
+#define NAND_DEVID		0xAC
+#define NAND_ID3		0x90
+#define NAND_ID4		0x15
+#define NAND_ID5		0x54
+/**
+ * define for device info
+ */
+#define NAND_MAIN_SIZE		2048
+#define NAND_SPARE_SIZE		64
+#define NAND_PAGE_SIZE		2112
+#define NAND_PAGES_PER_BLOCK	64
+#define NAND_BLOCKS_PER_BANK	4096
+
+/**
+ * timing parameter in ns
+ */
+#define NAND_TCLS		25
+#define NAND_TALS		25
+#define NAND_TCS		35
+#define NAND_TDS		20
+#define NAND_TCLH		10
+#define NAND_TALH		10
+#define NAND_TCH		10
+#define NAND_TDH		10
+#define NAND_TWP		25
+#define NAND_TWH		15
+#define NAND_TWB		100
+#define NAND_TRR		20
+#define NAND_TRP		25
+#define NAND_TREH		15
+#define NAND_TRB		100 /* not defined in datasheet */
+#define NAND_TCEH		70  /* trhz - tchz = 100 - 30 = 70 */
+#define NAND_TRDELAY		30  /* trea */
+#define NAND_TCLR		10
+#define NAND_TWHR		60
+#define NAND_TIR		0
+#define NAND_TWW		100  /* not defined in datasheet */
+#define NAND_TRHZ		100
+#define NAND_TAR		10
+
+#endif
diff --git a/include/flash/slcnand/st01gw3a.h b/include/flash/slcnand/st01gw3a.h
index 1679ce1..2b1ec6d 100644
--- a/include/flash/slcnand/st01gw3a.h
+++ b/include/flash/slcnand/st01gw3a.h
@@ -4,23 +4,36 @@
  * History:
  *    2006/05/30 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __ST01GW3A_H__
 #define __ST01GW3A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"STMicroelectronics ST01GW3A_128MB_PG512"
 
 #define NAND_MANID		0x20
 #define NAND_DEVID		0x79
@@ -34,66 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	8192
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR1_BIT	14
-#define NAND_PLANE_ADDR2_BIT	25
-#define NAND_PLANE_ADDR3_BIT	26
-#define NAND_PLANE_MASK		(0x1 << (NAND_PLANE_ADDR1_BIT - 	\
-				 	 NAND_BLOCK_ADDR_BIT)	|	\
-				 0x1 << (NAND_PLANE_ADDR2_BIT - 	\
-					 NAND_BLOCK_ADDR_BIT)	|	\
-				 0x1 << (NAND_PLANE_ADDR3_BIT - 	\
-					 NAND_BLOCK_ADDR_BIT))
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	NAND_PLANE_MASK
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_3
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"STMicroelectronics ST01GW3A_128MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/st01gw3b.h b/include/flash/slcnand/st01gw3b.h
index ae1a0d0..941f85b 100644
--- a/include/flash/slcnand/st01gw3b.h
+++ b/include/flash/slcnand/st01gw3b.h
@@ -4,26 +4,37 @@
  * History:
  *    2009/02/21 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 
 #ifndef __ST01GW3B_H__
 #define __ST01GW3B_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"STMicroelectronics ST01GW3B_128MB_PG2K"
 
 #define NAND_MANID		0x20
 #define NAND_DEVID		0xf1
@@ -37,62 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	27
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"STMicroelectronics ST01GW3B_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_DEVICES		1
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/st02gw3b.h b/include/flash/slcnand/st02gw3b.h
index 305fe34..d74bff4 100644
--- a/include/flash/slcnand/st02gw3b.h
+++ b/include/flash/slcnand/st02gw3b.h
@@ -4,29 +4,36 @@
  * History:
  *    2007/08/07 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __ST02GW3B_H__
 #define __ST02GW3B_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"STMicroelectronics ST02GW3B2C_256MB_PG2K"
 
 #define NAND_MANID		0x20
 #define NAND_DEVID		0xda
@@ -40,60 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_3
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"STMicroelectronics ST02GW3B2C_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/st128w3a.h b/include/flash/slcnand/st128w3a.h
index 668e275..efaf6bc 100644
--- a/include/flash/slcnand/st128w3a.h
+++ b/include/flash/slcnand/st128w3a.h
@@ -4,22 +4,36 @@
  * History:
  *    2005/12/02 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __ST128W3A_H__
 #define __ST128W3A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_128M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"STMicroelectronics ST128W3A_16MB_PG512"
 
 #define NAND_MANID		0x20
 #define NAND_DEVID		0x73
@@ -33,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	23
-#define NAND_PLANE_MASK		1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	16
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"STMicroelectronics ST128W3A_16MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/st256w3a.h b/include/flash/slcnand/st256w3a.h
index 1c890fd..8fdad05 100644
--- a/include/flash/slcnand/st256w3a.h
+++ b/include/flash/slcnand/st256w3a.h
@@ -4,22 +4,36 @@
  * History:
  *    2006/05/30 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __ST256W3A_H__
 #define __ST256W3A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_256M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"STMicroelectronics ST256W3A_32MB_PG512"
 
 #define NAND_MANID		0x20
 #define NAND_DEVID		0x75
@@ -33,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	24
-#define NAND_PLANE_MASK		1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	32
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"STMicroelectronics ST256W3A_32MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/st512w3a.h b/include/flash/slcnand/st512w3a.h
index 260f871..26fdf34 100644
--- a/include/flash/slcnand/st512w3a.h
+++ b/include/flash/slcnand/st512w3a.h
@@ -4,23 +4,36 @@
  * History:
  *    2006/05/30 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __ST512W3A_H__
 #define __ST512W3A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_512M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"STMicroelectronics ST512W3A_64MB_PG512"
 
 #define NAND_MANID		0x20
 #define NAND_DEVID		0x76
@@ -34,62 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR1_BIT	14
-#define NAND_PLANE_ADDR2_BIT	25
-#define NAND_PLANE_MASK		(0x1 << (NAND_PLANE_ADDR1_BIT - 	\
-				 	 NAND_BLOCK_ADDR_BIT)	|	\
-				 0x1 << (NAND_PLANE_ADDR2_BIT - 	\
-					 NAND_BLOCK_ADDR_BIT))
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	NAND_PLANE_MASK
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_3
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	64
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"STMicroelectronics ST512W3A_64MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/tc58bvg0s3h.h b/include/flash/slcnand/tc58bvg0s3h.h
index 13ac51c..7fff8de 100644
--- a/include/flash/slcnand/tc58bvg0s3h.h
+++ b/include/flash/slcnand/tc58bvg0s3h.h
@@ -4,28 +4,36 @@
  * History:
  *    2014/03/11 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __TC58BVG0S3H_H__
 #define __TC58BVG0S3H_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"TOSHIBA TC58BVG0S3H_128MB_PG2K"
 
 #define NAND_MANID		0x98
 #define NAND_DEVID		0xF1
@@ -40,59 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58BVG0S3H_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
@@ -120,5 +76,8 @@
 #define NAND_TWW		100
 #define NAND_TRHZ		60
 #define NAND_TAR		10
+#define NAND_TRHW		30
+#define NAND_TADL		100 /* not defined in datasheet */
+#define NAND_TCRL		5   /* tcea - trea = 25 - 20 = 5 */
 
 #endif
diff --git a/include/flash/slcnand/tc58bvg1s3h.h b/include/flash/slcnand/tc58bvg1s3h.h
index d3fb1d7..66e9dc0 100644
--- a/include/flash/slcnand/tc58bvg1s3h.h
+++ b/include/flash/slcnand/tc58bvg1s3h.h
@@ -4,29 +4,36 @@
  * History:
  *    2014/05/14 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __TC58BVG1S3H_H__
 #define __TC58BVG1S3H_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"TOSHIBA TC58BVG1S3H_256MB_PG2K"
 
 #define NAND_MANID		0x98
 #define NAND_DEVID		0xDA
@@ -41,59 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58BVG1S3H_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/tc58dvm72a.h b/include/flash/slcnand/tc58dvm72a.h
index f46cb30..4e71c65 100644
--- a/include/flash/slcnand/tc58dvm72a.h
+++ b/include/flash/slcnand/tc58dvm72a.h
@@ -4,22 +4,36 @@
  * History:
  *    2006/08/30 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __TC58DVM72A_H__
 #define __TC58DVM72A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_128M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"TOSHIBA TC58DVM72A_16MB_PG512"
 
 #define NAND_MANID		0x98
 #define NAND_DEVID		0x73
@@ -33,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	23
-#define NAND_PLANE_MASK		1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	16
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58DVM72A_16MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
@@ -105,7 +67,7 @@
 #define NAND_TRP		35
 #define NAND_TREH		15
 #define NAND_TRB		200 /* not define in spec, use the same twb */
-#define NAND_TCEH		100	
+#define NAND_TCEH		100
 #define NAND_TRDELAY		35 /* tREA */
 #define NAND_TCLR		10 /* FIXME: command latch low to read */
 				   /* enable low */
diff --git a/include/flash/slcnand/tc58dvm82a.h b/include/flash/slcnand/tc58dvm82a.h
index d88fae1..59f156a 100644
--- a/include/flash/slcnand/tc58dvm82a.h
+++ b/include/flash/slcnand/tc58dvm82a.h
@@ -4,22 +4,36 @@
  * History:
  *    2006/08/30 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __TC58DVM82A_H__
 #define __TC58DVM82A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_256M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"TOSHIBA TC58DVM82A_32MB_PG512"
 
 #define NAND_MANID		0x98
 #define NAND_DEVID		0x75
@@ -33,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
-#define NAND_BLOCKS_PER_BANK	2048	
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	24
-#define NAND_PLANE_MASK		1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	32	
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58DVM82A_32MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
+#define NAND_BLOCKS_PER_BANK	2048
 
 /**
  * timing parameter in ns
@@ -105,7 +67,7 @@
 #define NAND_TRP		35
 #define NAND_TREH		15
 #define NAND_TRB		200 /* not define in spec, use the same twb */
-#define NAND_TCEH		100	
+#define NAND_TCEH		100
 #define NAND_TRDELAY		35 /* tREA */
 #define NAND_TCLR		10 /* FIXME: command latch low to read */
 				   /* enable low */
diff --git a/include/flash/slcnand/tc58dvm92a.h b/include/flash/slcnand/tc58dvm92a.h
index bdba002..0d957ff 100644
--- a/include/flash/slcnand/tc58dvm92a.h
+++ b/include/flash/slcnand/tc58dvm92a.h
@@ -4,23 +4,36 @@
  * History:
  *    2006/08/30 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __TC58DVM92A_H__
 #define __TC58DVM92A_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_P3		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_SZ_512M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"TOSHIBA TC58DVM92A_64MB_PG512"
 
 #define NAND_MANID		0x98
 #define NAND_DEVID		0x76
@@ -34,59 +47,7 @@
 #define NAND_SPARE_SIZE		16
 #define NAND_PAGE_SIZE		528
 #define NAND_PAGES_PER_BLOCK	32
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	14
-#define NAND_PLANE_ADDR_BIT	25
-#define NAND_PLANE_MASK		1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	1
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		2
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	64
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58DVM92A_64MB_PG512"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	5	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/tc58nvg0s3c.h b/include/flash/slcnand/tc58nvg0s3c.h
index decc877..01f2a5a 100644
--- a/include/flash/slcnand/tc58nvg0s3c.h
+++ b/include/flash/slcnand/tc58nvg0s3c.h
@@ -4,26 +4,37 @@
  * History:
  *    2009/02/21 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 
 #ifndef __TC58NVG0S3C_H__
 #define __TC58NVG0S3C_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"TOSHIBA TC58NVG0S3C_128MB_PG2K"
 
 #define NAND_MANID		0x98
 #define NAND_DEVID		0xf1
@@ -37,64 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-/* Devcie has only one plane and the plane address should be set */
-/* outside of device. */
-#define NAND_PLANE_ADDR_BIT	28
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58NVG0S3C_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_DEVICES		1
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/tc58nvg0s3e.h b/include/flash/slcnand/tc58nvg0s3e.h
index 3ee5998..2dba55c 100644
--- a/include/flash/slcnand/tc58nvg0s3e.h
+++ b/include/flash/slcnand/tc58nvg0s3e.h
@@ -4,26 +4,37 @@
  * History:
  *    2009/02/21 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 
 #ifndef __TC58NVG0S3E_H__
 #define __TC58NVG0S3E_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"TOSHIBA TC58NVG0S3E_128MB_PG2K"
 
 #define NAND_MANID		0x98
 #define NAND_DEVID		0xd1
@@ -37,69 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-/* Devcie has only one plane and the plane address should be set */
-/* outside of device. */
-#define NAND_PLANE_ADDR_BIT	28
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58NVG0S3E_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_DEVICES		1
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#if 0
-#define NAND_CAPABILITY		(NAND_CAP_CACHE_CB | NAND_CAP_CACHE_PROG);
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
-
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/tc58nvg0s3h.h b/include/flash/slcnand/tc58nvg0s3h.h
index ef1da93..92b10ee 100644
--- a/include/flash/slcnand/tc58nvg0s3h.h
+++ b/include/flash/slcnand/tc58nvg0s3h.h
@@ -4,28 +4,36 @@
  * History:
  *    2014/02/21 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __TC58NVG0S3H_H__
 #define __TC58NVG0S3H_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"TOSHIBA TC58NVG0S3H_128MB_PG2K"
 
 #define NAND_MANID		0x98
 #define NAND_DEVID		0xF1
@@ -40,59 +48,7 @@
 #define NAND_SPARE_SIZE		128
 #define NAND_PAGE_SIZE		2176
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58NVG0S3H_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/tc58nvg1s3e.h b/include/flash/slcnand/tc58nvg1s3e.h
index 6aebf7e..33f7c7b 100644
--- a/include/flash/slcnand/tc58nvg1s3e.h
+++ b/include/flash/slcnand/tc58nvg1s3e.h
@@ -4,34 +4,45 @@
  * History:
  *    2010/05/18 - [Evan Chen] created file
  *
- * Copyright (C) 2010-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __TC58NVG1S3E_H__
 #define __TC58NVG1S3E_H__
 
+#define NAND_NAME		"TOSHIBA TC58NVG1S3E_256MB_PG2K"
+
 /**
- * nand control register initial setting
+ * TC58NVG1S3E has same id as TC58NVG1S3H
  */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
-
 #define NAND_MANID		0x98
-#define NAND_DEVID		0xda
-#define NAND_ID3		0x95
+#define NAND_DEVID		0xDA
+#define NAND_ID3		0x90
 #define NAND_ID4		0x15
+#define NAND_ID5		0x76
 
 /**
  * define for device info
@@ -40,64 +51,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58NVG1S3E_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#if 0
-#define NAND_CAPABILITY		(NAND_CAP_CACHE_CB | NAND_CAP_CACHE_PROG);
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
@@ -117,8 +71,8 @@
 #define NAND_TRP		12
 #define NAND_TREH		10
 #define NAND_TRB		100 /* not define in spec, use the same twb */
-#define NAND_TCEH		60  /* tRHZ: Read Enable High to Output Hi-z */
-#define NAND_TRDELAY		22  /* tREA */
+#define NAND_TCEH		40  /* tRHZ: Read Enable High to Output Hi-z */
+#define NAND_TRDELAY		20  /* tREA */
 #define NAND_TCLR		10
 #define NAND_TWHR		60
 #define NAND_TIR		0
diff --git a/include/flash/slcnand/tc58nvg1s3h.h b/include/flash/slcnand/tc58nvg1s3h.h
index 6711ebc..2b9590a 100644
--- a/include/flash/slcnand/tc58nvg1s3h.h
+++ b/include/flash/slcnand/tc58nvg1s3h.h
@@ -4,30 +4,40 @@
  * History:
  *    2015/03/24 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __TC58NVG1S3H_H__
 #define __TC58NVG1S3H_H__
 
+#define NAND_NAME		"TOSHIBA TC58NVG1S3H_256MB_PG2K"
+
 /**
- * nand control register initial setting
+ * TC58NVG1S3H has same id as TC58NVG1S3E
  */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
-
 #define NAND_MANID		0x98
 #define NAND_DEVID		0xDA
 #define NAND_ID3		0x90
@@ -41,60 +51,7 @@
 #define NAND_SPARE_SIZE		128
 #define NAND_PAGE_SIZE		2176
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58NVG1S3H_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/tc58nvg2s3e.h b/include/flash/slcnand/tc58nvg2s3e.h
index cf1b712..19dac5b 100644
--- a/include/flash/slcnand/tc58nvg2s3e.h
+++ b/include/flash/slcnand/tc58nvg2s3e.h
@@ -4,29 +4,36 @@
  * History:
  *    2010/05/20 - [Evan Chen] created file
  *
- * Copyright (C) 2010-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __TC58NVG2S3E_H__
 #define __TC58NVG2S3E_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_4G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"TOSHIBA TC58NVG2S3E_512MB_PG2K"
 
 #define NAND_MANID		0x98
 #define NAND_DEVID		0xdc
@@ -40,64 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	2048
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	4096
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	512
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58NVG2S3E_512MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#if 0
-#define NAND_CAPABILITY		(NAND_CAP_CACHE_CB | NAND_CAP_CACHE_PROG);
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/tc58nvm9s3c.h b/include/flash/slcnand/tc58nvm9s3c.h
index f6783ea..f4ac163 100644
--- a/include/flash/slcnand/tc58nvm9s3c.h
+++ b/include/flash/slcnand/tc58nvm9s3c.h
@@ -4,25 +4,36 @@
  * History:
  *    2009/05/15 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __TC58NVM9S3C_H__
 #define __TC58NVM9S3C_H__
 
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_512M	|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"TOSHIBA TC58NVM9S3C_64MB_PG2K"
 
 #define NAND_MANID		0x98
 #define NAND_DEVID		0xf0
@@ -36,62 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	512
-#define NAND_BLOCKS_PER_ZONE	512
 #define NAND_BLOCKS_PER_BANK	512
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	17
-#define NAND_PLANE_ADDR_BIT	27
-#define NAND_PLANE_MASK		0x1
-
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_0
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		4
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	64
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"TOSHIBA TC58NVM9S3C_64MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_DEVICES		1
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/w29n01gvscaa.h b/include/flash/slcnand/w29n01gvscaa.h
index 5be487d..66426ad 100644
--- a/include/flash/slcnand/w29n01gvscaa.h
+++ b/include/flash/slcnand/w29n01gvscaa.h
@@ -4,28 +4,36 @@
  * History:
  *    2014/03/27 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __W29N01GVSCAA_H__
 #define __W29N01GVSCAA_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_1G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"WINBOND W29N01GVSCAA_128MB_PG2K"
 
 #define NAND_MANID		0xEF
 #define NAND_DEVID		0xF1
@@ -40,59 +48,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	1024
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	2
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	128
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"WINBOND W29N01GVSCAA_128MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/slcnand/w29n01hvxinf.h b/include/flash/slcnand/w29n01hvxinf.h
new file mode 100644
index 0000000..46facd4
--- /dev/null
+++ b/include/flash/slcnand/w29n01hvxinf.h
@@ -0,0 +1,80 @@
+/**
+ * @file system/include/flash/slcnand/w29n01hvxinf.h
+ *
+ * History:
+ *    2016/04/22 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __W29N01HVXINF_H__
+#define __W29N01HVXINF_H__
+
+#define NAND_NAME		"WINBOND W29N01HVXINF_128MB_PG2K"
+
+#define NAND_MANID		0xEF
+#define NAND_DEVID		0xF1
+#define NAND_ID3		0x00
+#define NAND_ID4		0x95
+#define NAND_ID5		0x00
+
+/**
+ * define for device info
+ */
+#define NAND_MAIN_SIZE		2048
+#define NAND_SPARE_SIZE		64
+#define NAND_PAGE_SIZE		2112
+#define NAND_PAGES_PER_BLOCK	64
+#define NAND_BLOCKS_PER_BANK	1024
+
+/**
+ * timing parameter in ns
+ */
+#define NAND_TCLS		10
+#define NAND_TALS		10
+#define NAND_TCS		15
+#define NAND_TDS		10
+#define NAND_TCLH		5
+#define NAND_TALH		5
+#define NAND_TCH		5
+#define NAND_TDH		5
+#define NAND_TWP		12
+#define NAND_TWH		10
+#define NAND_TWB		100
+#define NAND_TRR		20
+#define NAND_TRP		12
+#define NAND_TREH		10
+#define NAND_TRB		100 /* not define in spec, use the same twb */
+#define NAND_TCEH		70  /* trhz - tchz = 100 - 30 = 70 */
+#define NAND_TRDELAY		20  /* trea */
+#define NAND_TCLR		10
+#define NAND_TWHR		60
+#define NAND_TIR		0
+#define NAND_TWW		100
+#define NAND_TRHZ		100
+#define NAND_TAR		10
+
+#endif
diff --git a/include/flash/slcnand/w29n02gvsiaa.h b/include/flash/slcnand/w29n02gvsiaa.h
index b275a0e..54a26ec 100644
--- a/include/flash/slcnand/w29n02gvsiaa.h
+++ b/include/flash/slcnand/w29n02gvsiaa.h
@@ -4,29 +4,36 @@
  * History:
  *    2015/03/13 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __W29N02GVSIAA_H__
 #define __W29N02GVSIAA_H__
 
-/**
- * nand control register initial setting
- */
-#define __NAND_CONTROL						  \
-	(NAND_CTR_C2		|				  \
-	 NAND_CTR_P3		|				  \
-	 NAND_CTR_I4		|				  \
-	 NAND_CTR_RC		|				  \
-	 NAND_CTR_CC		|				  \
-	 NAND_CTR_IE		|				  \
-	 NAND_CTR_SZ_2G		|				  \
-	 NAND_CTR_WD_8BIT)
+#define NAND_NAME		"WINBOND W29N02GVSIAA_256MB_PG2K"
 
 #define NAND_MANID		0xEF
 #define NAND_DEVID		0xDA
@@ -40,59 +47,7 @@
 #define NAND_SPARE_SIZE		64
 #define NAND_PAGE_SIZE		2112
 #define NAND_PAGES_PER_BLOCK	64
-#define NAND_BLOCKS_PER_PLANE	1024
-#define NAND_BLOCKS_PER_ZONE	1024
 #define NAND_BLOCKS_PER_BANK	2048
-#define NAND_PLANES_PER_BANK	(NAND_BLOCKS_PER_BANK / NAND_BLOCKS_PER_PLANE)
-#define NAND_BANKS_PER_DEVICE	1
-#define NAND_TOTAL_BLOCKS	(NAND_BLOCKS_PER_BANK * NAND_BANKS_PER_DEVICE)
-#define NAND_TOTAL_ZONES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_ZONE)
-#define NAND_TOTAL_PLANES	(NAND_TOTAL_BLOCKS / NAND_BLOCKS_PER_PLANE)
-
-/* Copyback must be in the same plane, so we have to know the plane address */
-#define NAND_BLOCK_ADDR_BIT	18
-#define NAND_PLANE_ADDR_BIT	28 /* A28 must be the same for copyback */
-#define NAND_PLANE_MASK		0x1
-/* Used to mask the plane address according to block address in the same bank */
-#define NAND_PLANE_ADDR_MASK	(NAND_PLANE_MASK << (NAND_PLANE_ADDR_BIT - \
-						     NAND_BLOCK_ADDR_BIT))
-
-#define NAND_PLANE_MAP		NAND_PLANE_MAP_2
-#define NAND_COLUMN_CYCLES	2
-#define NAND_PAGE_CYCLES	3
-#define NAND_ID_CYCLES		5
-#define NAND_CHIP_WIDTH		8
-#define NAND_CHIP_SIZE_MB	256
-#define NAND_BUS_WIDTH		8
-
-#define NAND_NAME	"WINBOND W29N02GVSIAA_256MB_PG2K"
-
-#if defined(CONFIG_NAND_1DEVICE)
-#define NAND_DEVICES		1
-#elif defined(CONFIG_NAND_2DEVICE)
-#define NAND_DEVICES		2
-#elif defined(CONFIG_NAND_4DEVICE)
-#define NAND_DEVICES		4
-#endif
-
-#define NAND_TOTAL_BANKS	(NAND_DEVICES * NAND_BANKS_PER_DEVICE)
-
-#if (NAND_TOTAL_BANKS == 1)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_1BANK)
-#elif (NAND_TOTAL_BANKS == 2)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_2BANK)
-#elif (NAND_TOTAL_BANKS == 4)
-#define NAND_CONTROL		(__NAND_CONTROL | NAND_CTR_4BANK)
-#elif (NAND_TOTAL_BANKS > 4)
-#error Unsupport nand flash banks
-#endif
-
-#define NAND_BB_MARKER_OFFSET	0	/* bad block information */
-
-/**
- * define for partition info
- */
-#define NAND_RSV_BLKS_PER_ZONE	24
 
 /**
  * timing parameter in ns
diff --git a/include/flash/spinand/gd5f1gq4uc.h b/include/flash/spinand/gd5f1gq4uc.h
new file mode 100644
index 0000000..7043dea
--- /dev/null
+++ b/include/flash/spinand/gd5f1gq4uc.h
@@ -0,0 +1,58 @@
+/**
+ * @file system/include/flash/spinand/gd5f1gq4uc.h
+ *
+ * History:
+ *    2015/10/26 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __GD5F1GQ4UC_H__
+#define __GD5F1GQ4UC_H__
+#include <fio/firmfl.h>
+
+#define SPI_NOR_NAME "GigaDevice SPI Nand GD5F1GQ4UC flash"
+
+/* GD5F2GQ4UC specific command */
+
+
+/* following must be defined for each spinor flash */
+#define SPINOR_SPI_CLOCK		50000000
+#define SPINAND_CHIP_SIZE		(128 * 1024 * 1024)
+
+#define SPINAND_MAIN_SIZE		2048
+ //we could only use 64 bytes, the other 64 bytes internel ecc
+#define SPINAND_SPARE_SIZE		128//64
+#define SPINAND_PAGE_SIZE		2176
+#define SPINAND_PAGES_PER_BLOCK	64
+
+/* support dtr read mode in the dual io or not*/
+#define SUPPORT_DTR_DUAL		0
+
+/* Adjust Reception Sampling Data Phase */
+#define SPINOR_RX_SAMPDLY		0
+#endif
+
diff --git a/include/flash/spinand/gd5f2gq4uc.h b/include/flash/spinand/gd5f2gq4uc.h
new file mode 100644
index 0000000..88a0a72
--- /dev/null
+++ b/include/flash/spinand/gd5f2gq4uc.h
@@ -0,0 +1,58 @@
+/**
+ * @file system/include/flash/spinand/gd5f2gq4uc.h
+ *
+ * History:
+ *    2015/10/26 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __GD5F2GQ4UC_H__
+#define __GD5F2GQ4UC_H__
+#include <fio/firmfl.h>
+
+#define SPI_NOR_NAME "GigaDevice SPI Nand GD5F2GQ4UC flash"
+
+/* GD5F2GQ4UC specific command */
+
+
+/* following must be defined for each spinor flash */
+#define SPINOR_SPI_CLOCK		50000000
+#define SPINAND_CHIP_SIZE		(256 * 1024 * 1024)
+
+#define SPINAND_MAIN_SIZE		2048
+ //we could only use 64 bytes, the other 64 bytes internel ecc
+#define SPINAND_SPARE_SIZE		64//128
+#define SPINAND_PAGE_SIZE		2176
+#define SPINAND_PAGES_PER_BLOCK	64
+
+/* support dtr read mode in the dual io or not*/
+#define SUPPORT_DTR_DUAL		0
+
+/* Adjust Reception Sampling Data Phase */
+#define SPINOR_RX_SAMPDLY		0
+#endif
+
diff --git a/include/flash/spinor/fl01gs.h b/include/flash/spinor/fl01gs.h
index 216c83e..fbb29e2 100644
--- a/include/flash/spinor/fl01gs.h
+++ b/include/flash/spinor/fl01gs.h
@@ -4,12 +4,30 @@
  * History:
  *    2014/05/05 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __FL01GS_H__
diff --git a/include/flash/spinor/gd25q512.h b/include/flash/spinor/gd25q512.h
index db51d56..d296438 100644
--- a/include/flash/spinor/gd25q512.h
+++ b/include/flash/spinor/gd25q512.h
@@ -4,12 +4,30 @@
  * History:
  *    2015/06/25 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __GD25Q512_H__
diff --git a/include/flash/spinor/mx25l25645g.h b/include/flash/spinor/mx25l25645g.h
index e197b04..b2275c4 100644
--- a/include/flash/spinor/mx25l25645g.h
+++ b/include/flash/spinor/mx25l25645g.h
@@ -4,12 +4,30 @@
  * History:
  *    2015/06/10 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __MX25L25645G_H__
diff --git a/include/flash/spinor/mx66l51235f.h b/include/flash/spinor/mx66l51235f.h
new file mode 100644
index 0000000..f2ee9f6
--- /dev/null
+++ b/include/flash/spinor/mx66l51235f.h
@@ -0,0 +1,57 @@
+/**
+ * @file system/include/flash/spi_nor/mx66l51235f.h
+ *
+ * History:
+ *    2016/03/14 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MX66L51235F_H__
+#define __MX66L51235F_H__
+#include <fio/firmfl.h>
+
+#define SPI_NOR_NAME "Macronix SPI Nor MX66L51235F flash"
+
+/* MX25L25645G specific command */
+#define FLASH_RESET_ENABLE		0x66
+#define FLASH_RESET_MEMORY		0x99
+#define FLASH_ENTER_4BYTES		0xB7
+#define FLASH_EXIT_4BYTES		0xE9
+
+/* following must be defined for each spinor flash */
+#define SPINOR_SPI_CLOCK		50000000
+#define SPINOR_CHIP_SIZE		(64 * 1024 * 1024)
+#define SPINOR_SECTOR_SIZE		(64 * 1024)
+#define SPINOR_PAGE_SIZE		256
+
+/* support dtr read mode in the dual io or not*/
+#define SUPPORT_DTR_DUAL		0
+
+/* Adjust Reception Sampling Data Phase */
+#define SPINOR_RX_SAMPDLY		0
+#endif
+
diff --git a/include/flash/spinor/n25q256.h b/include/flash/spinor/n25q256.h
index 1642403..da78e55 100644
--- a/include/flash/spinor/n25q256.h
+++ b/include/flash/spinor/n25q256.h
@@ -4,12 +4,30 @@
  * History:
  *    2013/10/15 - [Johnson Diao] created file
  *
- * Copyright (C) 2013-2017, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __N25Q256_H__
diff --git a/include/flash/spinor/n25q256a.h b/include/flash/spinor/n25q256a.h
index 58648f3..32973d8 100644
--- a/include/flash/spinor/n25q256a.h
+++ b/include/flash/spinor/n25q256a.h
@@ -4,12 +4,30 @@
  * History:
  *    2014/08/15 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __N25Q256A_H__
diff --git a/include/flash/spinor/spinor_flash.h b/include/flash/spinor/spinor_flash.h
index 0d8abda..8c196ac 100644
--- a/include/flash/spinor/spinor_flash.h
+++ b/include/flash/spinor/spinor_flash.h
@@ -4,12 +4,30 @@
  * History:
  *    2013/10/15 - [Johnson Diao] created file
  *
- * Copyright (C) 2013-2017, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __FLASH_SPI_NOR_PARTS_H__
@@ -34,10 +52,67 @@
 #define SPINOR_CMD_SE_4K		0x20
 #define SPINOR_CMD_CE			0xc7
 
+/* Used for Macronix flashes only. */
+#define OPCODE_EN4B			0xb7    /* Enter 4-byte mode */
+#define OPCODE_EX4B			0xe9    /* Exit 4-byte mode */
+
+#define FLASH_RESET_ENABLE	0x66
+#define FLASH_RESET_MEMORY	0x99
+
+/* Used for Spansion flashes only. */
+#define OPCODE_BRWR			0x17    /* Bank register write */
+#define FLASH_RESET				0xF0
+
+/* ---COMMON SPI NAND FLASH COMMAND--- */
+#define SPINAND_CMD_WRDI		0x04
+#define SPINAND_CMD_WREN		0x06
+
+/* Read to cache */
+#define SPINAND_CMD_READ		0x13
+/* Read from cache to memory */
+#define SPINAND_CMD_RFC			0x03
+/* Fast read from cache to memory */
+#define SPINAND_CMD_FRFC		0x0B
+/* Read from cache X2 to memory */
+#define SPINAND_CMD_RDIO		0x3B
+#define SPINAND_CMD_ERASE_BLK	0xD8
+/* Program to cache */
+#define SPINAND_CMD_PRG_LOAD	0x02
+
+/* Program to SPI NAND */
+#define SPINAND_CMD_PRG_EXC		0x10
+/* SPI NAND get features */
+#define SPINAND_CMD_GET_REG		0x0F
+/* SPI NAND set features */
+#define SPINAND_CMD_SET_REG		0x1F
+#define SPINAND_CMD_READID		0x9F
+#define SPINAND_CMD_RESET		0xFF
+/* ---END of SPI NAND CMD--- */
+
+/* SPI NAND REG */
+#define REG_PROTECTION			0xA0
+#define REG_FEATURE				0xB0
+#define REG_STATUS				0xC0
+#define REG_FEATURE_2			0xD0
+
+/* STATUS */
+#define STATUS_OIP_MASK			0x01
+#define STATUS_READY			(0 << 0)
+#define STATUS_BUSY				(1 << 0)
+#define STATUS_WEL_MASK			0x02
+#define STATUS_WEL				(1 << 1)
+#define STATUS_E_FAIL_MASK		0x04
+#define STATUS_E_FAIL			(1 << 2)
+#define STATUS_P_FAIL_MASK		0x08
+#define STATUS_P_FAIL			(1 << 3)
+#define STATUS_ECC				0x70
+
+#define SPI_NAND_ECC_EN		0x10
 
 #define CFI_MFR_MACRONIX	0x000000C2
 #define CFI_MFR_MICRON		0x00000020
 #define CFI_MFR_WINBOND		0x000000EF
+#define CFI_MFR_GD			0x000000C8
 
 /* The boot image header is a128-byte block and only first 24 bytes are used.
  * Each 4 bytes is corresponding to the layout (register definition) of
@@ -82,22 +157,41 @@ struct spinor_boot_header {
 	u32 rsvd[26];
 } __attribute__((packed));
 
+/* ====================================== */
+#define SPI_NOR_MAX_ID_LEN	6
+#define SPINOR_SPI_CLOCK		50000000
+/* Adjust Reception Sampling Data Phase */
+#define SPINOR_RX_SAMPDLY		0
+/* ====================================== */
+
+struct spi_flash_info {
+	const char *name;
+	u32 jedec;
+	u16 ext_jedec;
+	u32 sector_size;
+	u32 nr_sectors;
+	u32 page_size;
+	u16 rx_sample_delay;
+
+	u16 flags;
+#define	SECT_4K			0x01	/* SPINOR_OP_BE_4K works uniformly */
+#define	SPI_NOR_NO_ERASE	0x02	/* No erase command needed */
+#define	SST_WRITE		0x04	/* use SST byte programming */
+#define	SPI_NOR_NO_FR		0x08	/* Can't do fastread */
+#define	SPI_NOR_DTR_DUAL_READ		0x10	/* DTR_DUAL_READ*/
+#define	SPI_NOR_DUAL_READ	0x20    /* Flash supports Dual Read */
+#define	SPI_NOR_QUAD_READ	0x40    /* Flash supports Quad Read */
+#define	USE_FSR			0x80	/* use flag status register */
+};
 
+#define JEDEC_MFR(_jedec_id)    ((_jedec_id) >> 16)
 /******************************************************************************/
 /* SPI NOR                                                                        */
 /******************************************************************************/
-#if defined(CONFIG_SPI_NOR_N25Q256A)
-#include <flash/spinor/n25q256a.h>
-#elif defined(CONFIG_SPI_NOR_FL01GS)
-#include <flash/spinor/fl01gs.h>
-#elif defined(CONFIG_SPI_NOR_MX25L25645G)
-#include <flash/spinor/mx25l25645g.h>
-#elif defined(CONFIG_SPI_NOR_W25Q64FV)
-#include <flash/spinor/w25q64fv.h>
-#elif defined(CONFIG_SPI_NOR_W25Q128FV)
-#include <flash/spinor/w25q128fv.h>
-#elif defined(CONFIG_SPI_NOR_GD25Q512)
-#include <flash/spinor/gd25q512.h>
+#if defined(CONFIG_SPI_NAND_GD5F2GQ4UC)
+#include <flash/spinand/gd5f2gq4uc.h>
+#elif defined(CONFIG_SPI_NAND_GD5F1GQ4UC)
+#include <flash/spinand/gd5f1gq4uc.h>
 #endif
 
 #endif
diff --git a/include/flash/spinor/w25q128fv.h b/include/flash/spinor/w25q128fv.h
index 4e3aff6..14d2817 100644
--- a/include/flash/spinor/w25q128fv.h
+++ b/include/flash/spinor/w25q128fv.h
@@ -4,12 +4,30 @@
  * History:
  *    2014/09/18 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __W25Q128FV_H__
diff --git a/include/flash/spinor/w25q64fv.h b/include/flash/spinor/w25q64fv.h
index 5688929..88768b7 100644
--- a/include/flash/spinor/w25q64fv.h
+++ b/include/flash/spinor/w25q64fv.h
@@ -4,12 +4,30 @@
  * History:
  *    2014/07/25 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __W25Q64FV_H__
diff --git a/include/hwio.h b/include/hwio.h
index 1e710ea..cad6edd 100644
--- a/include/hwio.h
+++ b/include/hwio.h
@@ -8,12 +8,30 @@
  * provide it (such as PrKERNELv4). In fact, even if it did, we'd like to
  * ideally use the following ones to be more uniform/portable.
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HWIO_H__
@@ -22,13 +40,13 @@
 /*===========================================================================*/
 #ifndef __ASM__
 
-#define __raw_writeb(v, a)	(*(volatile unsigned char  *)(a) = (v))
-#define __raw_writew(v, a)	(*(volatile unsigned short *)(a) = (v))
-#define __raw_writel(v, a)	(*(volatile unsigned int   *)(a) = (v))
+#define __raw_writeb(v, a)	(*(volatile unsigned char *)(unsigned long)(a) = (v))
+#define __raw_writew(v, a)	(*(volatile unsigned short *)(unsigned long)(a) = (v))
+#define __raw_writel(v, a)	(*(volatile unsigned int *)(unsigned long)(a) = (v))
 
-#define __raw_readb(a)		(*(volatile unsigned char  *)(a))
-#define __raw_readw(a)		(*(volatile unsigned short *)(a))
-#define __raw_readl(a)		(*(volatile unsigned int   *)(a))
+#define __raw_readb(a)		(*(volatile unsigned char *)(unsigned long)(a))
+#define __raw_readw(a)		(*(volatile unsigned short *)(unsigned long)(a))
+#define __raw_readl(a)		(*(volatile unsigned int *)(unsigned long)(a))
 
 #define writeb(p, v)		__raw_writeb(v, p)
 #define writew(p, v)		__raw_writew(v, p)
@@ -45,6 +63,8 @@
 #define setbitsl(p, mask)	writel((p),(readl(p) | (mask)))
 #define clrbitsl(p, mask)	writel((p),(readl(p) & ~(mask)))
 
+#include <smccc.h>
+
 #endif /* !__ASM__ */
 
 /*===========================================================================*/
diff --git a/include/irq.h b/include/irq.h
new file mode 100644
index 0000000..5ec342b
--- /dev/null
+++ b/include/irq.h
@@ -0,0 +1,102 @@
+
+/**
+ * irq.h
+ *
+ * History:
+ *    2015/12/1 - Jorney(qtu@ambarella.com) created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _AMBOOT_IRQ_H_
+#define _AMBOOT_IRQ_H_
+
+#if defined(__aarch64__)
+#include <ambhw/gic.h>
+#else
+#include <ambhw/vic.h>
+#endif
+
+/* ==========================================================================*/
+/* irq type */
+#define IRQ_RISING_EDGE			0
+#define IRQ_FALLING_EDGE		1
+#define IRQ_BOTH_EDGES			2
+#define IRQ_LEVEL_LOW			3
+#define IRQ_LEVEL_HIGH			4
+
+/* ==========================================================================*/
+#ifndef __ASM__
+
+typedef void (*irq_handler_t)(void *);
+
+typedef struct irq_manager_s
+{
+	u32 irq;
+	irq_handler_t handler;
+	void *data;
+} irq_manager_t;
+
+extern void request_irq(u32 irq, u32 type, irq_handler_t handler, void *data);
+extern void irq_init(void);
+extern void irq_enable(u32 line);
+extern void irq_disable(u32 line);
+extern void irq_set_type(u32 irq, u32 type);
+extern void irq_handler(void);
+
+#if defined(__aarch64__)
+
+static inline void enable_interrupts(void)
+{
+	__asm__ __volatile__("msr daifclr, #0x3":::"memory");
+}
+
+static inline void disable_interrupts(void)
+{
+	__asm__ __volatile__("msr daifset, #0x3":::"memory");
+}
+
+#else
+
+static inline void enable_interrupts(void)
+{
+	__asm__ volatile("cpsie i");
+	__asm__ volatile("dsb");
+	__asm__ volatile("isb");
+}
+
+static inline void disable_interrupts(void)
+{
+	__asm__ volatile("cpsid i");
+	__asm__ volatile("dsb");
+	__asm__ volatile("isb");
+}
+
+#endif
+
+/* ==========================================================================*/
+#endif
+
+#endif
diff --git a/include/macro.S b/include/macro.S
index 813ab3a..c5333dc 100644
--- a/include/macro.S
+++ b/include/macro.S
@@ -3,22 +3,204 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2013, Ambarella, Inc.
+ * History:
+ *    2015/11/26 - [Cao Rongrong] Add ARMv8 supported
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#if defined(__CORTEXA53__)
+
+/*
+ * CLIDR_EL1: Identifies the type of caches, Read Only
+ *
+ * 31 30   27  24 23 21 20  18 17  15 14  12 11   9 8    6 5    3 2    0
+ * ^----^----^---^-----^------^------^------^------^------^------^------^
+ * |RES0|LoUU|LoC|LoUIS|Ctype7|Ctype6|Ctype5|Ctype4|Ctype3|Ctype2|Ctype1|
+ *  ---------------------------------------------------------------------
+ *
+ *
+ *
+ * CSSELR_EL1: Select the current Cache Size ID Register
+ *
+ * 31                                                    4 3     1    0
+ * ^------------------------------------------------------^--------^-----^
+ * |                              RES0                    |  Level | InD |
+ *  ---------------------------------------------------------------------
+ *
+ *
+ * CCSIDR_EL1: Provide information of currently selected cache, Read Only
+ *
+ * 31   30   29   28	27            13 12                   3 2         0
+ * ^----^----^----^----^----------------^----------------------^----------^
+ * | WT | WB | RA | WA |     NumSets    |     Associativity    | Linesize |
+ *  ---- ---- ---- ---- ---------------- ---------------------- ----------
+ *
+ * Linesize = log2(line size in bytes) - 4
+ * Associativity = ways - 1
+ * NumSets = sets - 1
+ *
+ *
+ * DC ISW or DC CISW:
+ *
+ *  63         32 31   32-A  32-A-1    B B-1    L L-1     4 3    1   0
+ * ^-------------^----------^-----------^--------^---------^------^-----^
+ * |     RES0    |    Way   |    RES0   |   Set  |   RES0  | Level| RES0|
+ *  --------------------------------------------------------------------
+ *
+ * A = log2(Associativity)
+ * L = log2(Linesize)
+ * S = log2(Set)
+ * B = L + S
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
-	.macro	invalidate_all_tlb, tmp0
+.macro	operate_all_cache, op, lvl, type, line, way, set, \
+				wayp, wayv, cp_val, dc_val, tmp
+	dsb	sy
+
+	mov	\lvl, #0		/* lvl = level variable */
+
+/* loop_level */
+1:
+	mrs	\cp_val, clidr_el1	/* read clidr_el1 to check Ctype */
+	lsl	\tmp, \lvl, #1
+	add	\tmp, \tmp, \lvl	/* tmp = lvl << 1 + lvl = lvl * 3 */
+	lsr	\type, \cp_val, \tmp
+	and	\type, \type, #7	/* Cache type */
+	cbz	\type, 5f		/* return if no cache, no need to check upper layer */
+	cmp	\type, #2
+	b.lt	4f			/* skip if icache */
+
+	/*---------- START Specified Level Operation -----------*/
+
+	lsl	\tmp, \lvl, #1
+	msr	csselr_el1, \tmp	/* Selects the current Cache level */
+	isb				/* make sure csselr_el1 has taken effect */
+
+	mrs	\cp_val, ccsidr_el1
+	and	\line, \cp_val, #7
+	add	\line, \line, #4	/* line = log2(cache line size) */
+	lsr	\way, \cp_val, #3
+	and	\way, \way, #0x3ff	/* way = ways - 1 */
+	clz	\wayp, \way		/* wayp = way position in DC ISW/CSW/CISW */
+	sub	\wayp, \wayp, #32	/* wayp = 64 - 32 - A = 32 - log2(ways) */
+	lsr	\set, \cp_val, #13
+	and	\set, \set, #0x7fff	/* set = sets - 1 */
+
+/* loop_set */
+2:
+	mov	\wayv, \way		/* wayv = way variable */
+
+/* loop_way */
+3:
+	lsl	\dc_val, \wayv, \wayp
+	orr	\dc_val, \dc_val, \lvl, lsl #1
+	lsl	\tmp, \set, \line
+	orr	\dc_val, \dc_val, \tmp
+	dc	\op, \dc_val
+
+	subs	\wayv, \wayv, #1
+	b.ge	3b			/* back to loop_way */
+	subs	\set, \set, #1
+	b.ge	2b			/* back to loop_set */
+
+	/*---------- END Specified Level Operation -----------*/
+4:
+	add	\lvl, \lvl, #1		/* increment cache level */
+	b	1b			/* back to loop_level */
+
+5:
+	mov	\tmp, #0
+	msr	csselr_el1, \tmp	/* restore csselr_el1 */
+	dsb	sy
+	isb
+.endm
+
+.macro	invalidate_all_cache, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, \
+				tmp7, tmp8, tmp9
+	operate_all_cache isw, \tmp0, \tmp1, \tmp2, \tmp3, \tmp4, \
+				 \tmp5, \tmp6, \tmp7, \tmp8, \tmp9
+.endm
+
+.macro	clean_all_cache, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, \
+				tmp7, tmp8, tmp9
+	operate_all_cache csw, \tmp0, \tmp1, \tmp2, \tmp3, \tmp4, \
+				\tmp5, \tmp6, \tmp7, \tmp8, \tmp9
+.endm
+
+.macro	invcln_all_cache, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, \
+				tmp7, tmp8, tmp9
+	operate_all_cache cisw, \tmp0, \tmp1, \tmp2, \tmp3, \tmp4, \
+				\tmp5, \tmp6, \tmp7, \tmp8, \tmp9
+.endm
+
+.macro	invalidate_all_tlb
+	tlbi	alle3
+	dsb	sy
+.endm
+
+.macro  clean_invalidate_dcache, ops, addr, end, tmp0, tmp1
+
+	mrs	\tmp1, ctr_el0
+	lsr	\tmp1, \tmp1, #16
+	and	\tmp1, \tmp1, #0xf
+	mov	\tmp0, #4
+	lsl	\tmp0, \tmp0, \tmp1		/* cache line size */
+
+	sub	\tmp1, \tmp0, #1
+	bic	\addr, \addr, \tmp1
+1: 	dc	\ops, \addr
+	add	\addr, \addr, \tmp0
+	cmp	\addr, \end
+	b.lo	1b
+	dsb	sy
+.endm
+
+.macro armv8_switch_el, reg, el1_label, el2_label, el3_label
+	mrs		\reg, CurrentEL
+	cmp		\reg, #0x4
+	b.eq	\el1_label
+	cmp		\reg, #0x8
+	b.eq	\el2_label
+	cmp		\reg, #0xc
+	b.eq	\el3_label
+	b		.
+.endm
+
+#else
+
+.macro	invalidate_all_tlb, tmp0
 	mov		\tmp0, #0x00
 	mcr		p15, 0, \tmp0, c8, c7, 0		/* Invalidate entire unified TLB */
 	mcr		p15, 0, \tmp0, c8, c6, 0		/* Invalidate entire data TLB */
 	mcr		p15, 0, \tmp0, c8, c5, 0		/* Invalidate entire instruction TLB */
-	.endm
+.endm
 
-	.macro	operate_all_cache, cr, tmp0, tmp1, tmp2, tmp3, tmp4
+.macro	operate_all_cache, cr, tmp0, tmp1, tmp2, tmp3, tmp4
 	mov		\tmp0, #0
 	mcr		p15, 0, \tmp0, c7, c5, 6		/* Invalidate entire branch prediction array */
 	mcr		p15, 0, \tmp0, c7, c5, 0		/* Invalidate entire icache */
@@ -49,16 +231,19 @@
 	add		\tmp4, \tmp4, #0x20
 	cmp		\tmp1, \tmp0
 	bne		2b
-	.endm
+.endm
 
-	.macro	invalidate_all_cache, tmp0, tmp1, tmp2, tmp3, tmp4
+.macro	invalidate_all_cache, tmp0, tmp1, tmp2, tmp3, tmp4
 	operate_all_cache c6, \tmp0, \tmp1, \tmp2, \tmp3, \tmp4
-	.endm
+.endm
 
-	.macro	clean_all_cache, tmp0, tmp1, tmp2, tmp3, tmp4
+.macro	clean_all_cache, tmp0, tmp1, tmp2, tmp3, tmp4
 	operate_all_cache c10, \tmp0, \tmp1, \tmp2, \tmp3, \tmp4
-	.endm
+.endm
 
-	.macro	invcln_all_cache, tmp0, tmp1, tmp2, tmp3, tmp4
+.macro	invcln_all_cache, tmp0, tmp1, tmp2, tmp3, tmp4
 	operate_all_cache c14, \tmp0, \tmp1, \tmp2, \tmp3, \tmp4
-	.endm
+.endm
+
+#endif
+
diff --git a/include/peripheral.h b/include/peripheral.h
new file mode 100644
index 0000000..ef90d10
--- /dev/null
+++ b/include/peripheral.h
@@ -0,0 +1,40 @@
+/**
+ * peripheral.h
+ *
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __PERIPHERAL_H__
+#define __PERIPHERAL_H__
+
+#define PCA9539_NUM	16
+extern void pca9539_set_gpio(int i2c_id, u32 id, u32 set);
+extern void pca9539_direction_input(int i2c_id, u32 id);
+extern void micrel_phy_init(void *dev);
+#endif
+
diff --git a/include/sdmmc.h b/include/sdmmc.h
index ceda16c..61d01f1 100644
--- a/include/sdmmc.h
+++ b/include/sdmmc.h
@@ -7,12 +7,30 @@
  *    2004/11/04 - [Charles Chiou] created file
  *    2007/01/24 - [Charles Chiou] merged from multiple headers into one
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __SDMMC_H__
@@ -69,6 +87,7 @@
 #define cmd_16	0x101a	/* SET_BLOCKLEN		expect 48 bit response (R1) */
 #define cmd_17	0x113a	/* READ_SINGLE_BLOCK	expect 48 bit response (R1) */
 #define cmd_18	0x123a	/* READ_MULTIPLE_BLOCK	expect 48 bit response (R1) */
+#define cmd_19  0x133a  /* SEND_TUNING			expect 48 bit response (R1) */
 #define cmd_24	0x183a	/* WRITE_BLOCK		expect 48 bit response (R1) */
 #define cmd_25	0x193a	/* WRITE_MULTIPLE_BLOCK	expect 48 bit response (R1) */
 #define cmd_32	0x201a	/* ERASE_WR_BLK_START	expect 48 bit response (R1) */
@@ -116,9 +135,9 @@
 	})
 
 /*===========================================================================*/
-
+extern int sdmmc_command(int command, int argument);
 extern int sdmmc_init_sd(int slot, int mode, int clock, int verbose);
-extern int sdmmc_init_mmc(int slot, int mode, int clock, int verbose);
+extern int sdmmc_init_mmc(int slot, int mode, int clock, int verbose, int emmc_boot);
 extern int sdmmc_show_card_info(void);
 extern int sdmmc_read_sector(int sector, int sectors, u8 *target);
 extern int sdmmc_write_sector(int sector, int sectors, u8 *image);
@@ -128,6 +147,7 @@ extern u32 sdmmc_get_total_sectors(void);
 extern int sdmmc_set_emmc_boot_info(void);
 extern int sdmmc_set_emmc_normal(void);
 
+extern int sdmmc_send_tuning(void);
 /*===========================================================================*/
 
 #endif
diff --git a/include/smccc.h b/include/smccc.h
new file mode 100644
index 0000000..1f40843
--- /dev/null
+++ b/include/smccc.h
@@ -0,0 +1,161 @@
+/**
+ *
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __SMCCC_H__
+#define __SMCCC_H__
+
+#if defined(CONFIG_AARCH64_TRUSTZONE)
+/*
+ * SMC Calling Convention definition per ARM_DEN0028B_SMC_Calling_Convention.pdf
+ *
+ * Terms:
+ *    SMCCC: SMC Calling Convention
+ *    OEN: Owning Entity Number
+ *    SIP: Silicib Partner
+ *    SVC: Service
+ */
+
+#define SMCCC_TYPE_FAST			(1)
+#define SMCCC_TYPE_YIELD		(0)
+#define SMCCC_FUNCID_TYPE_SHIFT		(31)
+#define SMCCC_FUNCID_TYPE_MASK		(0x1)
+
+#define SMCCC_64			(1)
+#define SMCCC_32			(0)
+#define SMCCC_FUNCID_CC_SHIFT		(30)
+#define SMCCC_FUNCID_CC_MASK		(0x1)
+
+#define SMCCC_OEN_SIP			(2)
+#define SMCCC_FUNCID_OEN_SHIFT		(24)
+#define SMCCC_FUNCID_OEN_MASK		(0x3f)
+
+#define SMCCC_FUNCID_NUM_SHIFT		(0)
+#define SMCCC_FUNCID_NUM_MASK		(0xffff)
+
+#define SMCCC_CALL_VAL(type, smc64, oen, func_num) \
+	((((type) & SMCCC_FUNCID_TYPE_MASK) << SMCCC_FUNCID_TYPE_SHIFT) | \
+	(((smc64) & SMCCC_FUNCID_CC_MASK) << SMCCC_FUNCID_CC_SHIFT) | \
+	(((oen) & SMCCC_FUNCID_OEN_MASK) << SMCCC_FUNCID_OEN_SHIFT) | \
+	(((func_num) & SMCCC_FUNCID_NUM_MASK) << SMCCC_FUNCID_NUM_SHIFT))
+
+#define SMC_OK				(0)
+#define SMC_UNK				(0xffffffff)
+
+
+/* Ambarella Private Definition */
+
+#define AMBA_SIP_ACCESS_REG		0x3
+#define AMBA_SIP_ACCESS_REG_READ	0x1
+#define AMBA_SIP_ACCESS_REG_WRITE	0x2
+#define AMBA_SIP_ACCESS_REG_SETBIT	0x3
+#define AMBA_SIP_ACCESS_REG_CLRBIT	0x4
+
+#define	SVC_SMCCC_FN(s, f)		((((s) & 0xff) << 8) | ((f) & 0xff))
+
+#define SMCCC_SIP_CALL(s, f)		SMCCC_CALL_VAL(		\
+					SMCCC_TYPE_FAST,	\
+					SMCCC_64,		\
+					SMCCC_OEN_SIP,		\
+					SVC_SMCCC_FN(s, f))
+
+struct smccc_result {
+	unsigned long a0;
+	unsigned long a1;
+	unsigned long a2;
+	unsigned long a3;
+};
+
+extern void __arm_smccc_smc(unsigned long a0, unsigned long a1,
+			unsigned long a2, unsigned long a3, unsigned long a4,
+			unsigned long a5, unsigned long a6, unsigned long a7,
+			struct smccc_result *res);
+
+static inline u32 smc_readl(uintptr_t addr)
+{
+	struct smccc_result res;
+	u32 el, func;
+
+	__asm__ __volatile__("mrs %0, CurrentEL" : "=r" (el));
+	if (el == 0xc) { /* EL3 */
+		return readl(addr);
+	} else {
+		func = SMCCC_SIP_CALL(AMBA_SIP_ACCESS_REG, AMBA_SIP_ACCESS_REG_READ);
+		__arm_smccc_smc(func, addr, 0, 0, 0, 0, 0, 0, &res);
+
+		return res.a0;
+	}
+}
+
+static inline void smc_writel(uintptr_t addr, u32 val)
+{
+	u32 el, func;
+
+	__asm__ __volatile__("mrs %0, CurrentEL" : "=r" (el));
+	if (el == 0xc) { /* EL3 */
+		writel(addr, val);
+	} else{
+		func = SMCCC_SIP_CALL(AMBA_SIP_ACCESS_REG, AMBA_SIP_ACCESS_REG_WRITE);
+		__arm_smccc_smc(func, addr, val, 0, 0, 0, 0, 0, NULL);
+	}
+}
+
+static inline void smc_setbitsl(uintptr_t addr, u32 val)
+{
+	u32 el, func;
+
+	__asm__ __volatile__("mrs %0, CurrentEL" : "=r" (el));
+	if (el == 0xc) { /* EL3 */
+		setbitsl(addr, val);
+	} else {
+		func = SMCCC_SIP_CALL(AMBA_SIP_ACCESS_REG, AMBA_SIP_ACCESS_REG_SETBIT);
+		__arm_smccc_smc(func, addr, val, 0, 0, 0, 0, 0, NULL);
+	}
+}
+
+static inline void smc_clrbitsl(uintptr_t addr, u32 val)
+{
+	u32 el, func;
+
+	__asm__ __volatile__("mrs %0, CurrentEL" : "=r" (el));
+	if (el == 0xc) { /* EL3 */
+		clrbitsl(addr, val);
+	} else {
+		func = SMCCC_SIP_CALL(AMBA_SIP_ACCESS_REG, AMBA_SIP_ACCESS_REG_CLRBIT);
+		__arm_smccc_smc(func, addr, val, 0, 0, 0, 0, 0, NULL);
+	}
+}
+#else
+static inline u32 smc_readl(uintptr_t addr) {return readl(addr);}
+static inline void smc_writel(uintptr_t addr, u32 val) {writel(addr, val);}
+static inline void smc_setbitsl(uintptr_t addr, u32 val) {setbitsl(addr, val);}
+static inline void smc_clrbitsl(uintptr_t addr, u32 val) {clrbitsl(addr, val);}
+#endif
+
+#endif /* __SMCC_H__ */
diff --git a/include/vsprintf.h b/include/vsprintf.h
index cd799b1..429cd3e 100644
--- a/include/vsprintf.h
+++ b/include/vsprintf.h
@@ -1,6 +1,42 @@
+/**
+ * include/vsprintf.h
+ *
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 #ifndef __AMBA_VSPRINTF__
 #define __AMBA_VSPRINTF__
 
+#define __COL_RED	"\033[0;31m"
+#define __COL_GREEN	"\033[0;32m"
+#define __COL_YELLOW	"\033[0;33m"
+#define __COL_BLUE	"\033[0;34m"
+#define __COL_PURPLE	"\033[0;35m"
+#define __COL_END__	"\033[0;39m"
+
 # define do_div(n,base) ({				\
 	int __base = (base);			\
 	int __rem;					\
@@ -16,6 +52,7 @@
 
 int sprintf(char *buf, const char *fmt, ...);
 int printf(const char *fmt, ...);
+#define pr_color(c, fmt, ...)	printf(__COL_##c fmt __COL_END__, ##__VA_ARGS__)
 
 
 #endif /* __AMBA_VSPRINTF__ */
diff --git a/make.inc b/make.inc
index d82632f..39c79de 100644
--- a/make.inc
+++ b/make.inc
@@ -4,12 +4,29 @@
 ## History:
 ##    2012/06/07 - [Cao Rongrong] Create
 ##
-## Copyright (C) 2011-2015, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
 
 LOCAL_PATH:=$(call my-dir)
@@ -17,12 +34,16 @@ LOCAL_PATH:=$(call my-dir)
 ### Device Tree Complier
 DTC := $(AMB_TOPDIR)/build/dtc/dtc
 DTC_INCLUDES := -i $(LINUX_SRC_DIR)/arch/arm/boot/dts
+DTC_INCLUDES += -i $(LINUX_SRC_DIR)/arch/arm64/boot/dts/ambarella
+
+DTC_CFLAG_INCLUDES := -I $(LINUX_SRC_DIR)/include
+DTC_CFLAG_INCLUDES += -I $(AMB_BOARD_DIR)
 
 $(DTC): $(AMB_TOPDIR)/build/dtc/Makefile
 	@$(MAKE) $(AMBA_MAKE_PARA) -C $(AMB_TOPDIR)/build/dtc dtc
 
 export DTC
-export DTC_INCLUDES
+export DTC_INCLUDES DTC_CFLAG_INCLUDES
 
 ###
 
@@ -37,5 +58,6 @@ amboot: $(DOT_CONFIG) $(DTC)
 	$(AMBA_MAKEFILE_V)$(MAKE) $(AMBA_MAKE_PARA) -C $(AMB_BOARD_OUT)/amboot clean
 	$(AMBA_MAKEFILE_V)$(MAKE) $(AMBA_MAKE_PARA) -C $(AMB_BOARD_OUT)/amboot
 	@mkdir -p $(IMAGES_OUT_DIR)/
-	@mv -f $(AMB_BOARD_OUT)/amboot/memfwprog/* $(IMAGES_OUT_DIR)/
+	@mv -f $(AMB_BOARD_OUT)/amboot/memfwprog/*.elf $(IMAGES_OUT_DIR)/
+	@mv -f $(AMB_BOARD_OUT)/amboot/memfwprog/*.bin $(IMAGES_OUT_DIR)/
 
diff --git a/pandora/arm/context_macro.S b/pandora/arm/context_macro.S
new file mode 100644
index 0000000..8df8958
--- /dev/null
+++ b/pandora/arm/context_macro.S
@@ -0,0 +1,63 @@
+/**
+ * pandora/arm/context_macro.S
+
+ * Copyright (c) 2020 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __CONTEXT_ASM__
+#define __CONTEXT_ASM__
+
+
+.macro	PANDORA_SAVE_CONTEXT
+	stmdb	sp!, {r0}
+	stmdb	sp, {sp}^
+	sub	sp, sp, #4
+	ldmia	sp!, {r0}
+	stmdb	r0!, {lr}
+
+	mov	lr, r0
+	ldmia	sp!, {r0}
+	stmdb	lr, {r0-r14}^
+	sub	lr, lr, #60
+	mrs	r0, spsr
+	stmdb	lr!, {r0}
+	ldr	r0, =current_task
+	ldr	r0, [r0]
+	str	lr, [r0]
+.endm
+
+.macro	PANDORA_RESTORE_CONTEXT
+	ldr	r0, =current_task
+	ldr	r0, [r0]
+	ldr	lr, [r0]
+	ldmfd	lr!, {r0}
+	msr	spsr_cxsf, r0
+	ldmfd	lr, {r0-r14}^
+	ldr	lr, [lr, #60]
+	subs	pc, lr, #0x4
+.endm
+
+#endif
diff --git a/pandora/arm/pandora.S b/pandora/arm/pandora.S
new file mode 100644
index 0000000..d0d20fb
--- /dev/null
+++ b/pandora/arm/pandora.S
@@ -0,0 +1,94 @@
+/**
+ * pandora/arm/pandora.S
+ *
+ * Copyright (c) 2020 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <arm/context_macro.S>
+
+.global __pandora_sche_start
+__pandora_sche_start:
+	PANDORA_RESTORE_CONTEXT
+
+.global __pandora_yield
+__pandora_yield:
+	mov	r1, #0
+	str	r1, [r0]
+	ldmia	sp, {r0 - lr}^
+	nop
+	ldr	lr, [sp, #60]
+	add	sp, sp, #72
+
+	PANDORA_SAVE_CONTEXT
+	bl pandora_task_switch
+	PANDORA_RESTORE_CONTEXT
+	b	.
+
+.global __pandora_swi
+__pandora_swi:
+	/*
+	 * FIXME: when 'PC = SWI 0', it will trigger an Software exception,
+	 * and the 'LR = PC + 4'. So the return addr should be LR. However,
+	 * it's not the same to irq exception which 'LR = PC + 4', and the
+	 * PC is not finish being excuted, so the return address is the LR - 4,
+	 * points to not excuted PC.
+	 *
+	 * 'add lr, lr, #4' is a workround over here, just for compatibility
+	 * with 'subs pc, lr, #4'.
+	 *
+	 */
+	add	lr, lr, #4
+
+	PANDORA_SAVE_CONTEXT
+	bl pandora_task_switch
+	PANDORA_RESTORE_CONTEXT
+
+.global __mutex_atomic_set
+__mutex_atomic_set:
+	push	{r0-r2}
+	mov	r1, #1
+1:	ldr	r2, [r0]
+	cmp	r2, r1
+	bne	__lock
+	swi	#0
+	b	1b
+__lock:
+	cpsid	i
+	str	r1, [r0]
+	cpsie	i
+	pop	{r0-r2}
+	mov	pc, lr
+
+.global __mutex_atomic_clr
+__mutex_atomic_clr:
+	push	{r0-r1}
+	mov	r1, #0
+	cpsid	i
+	str	r1, [r0]
+	cpsie	i
+	pop	{r0-r1}
+	mov	pc, lr
+
diff --git a/pandora/arm/processor.c b/pandora/arm/processor.c
new file mode 100644
index 0000000..9a9e264
--- /dev/null
+++ b/pandora/arm/processor.c
@@ -0,0 +1,84 @@
+/**
+ * pandora/arm/processor.c
+ *
+ * Copyright (c) 2020 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+#include <irq.h>
+#include <ambhw/timer.h>
+#include <pandora.h>
+
+unsigned long pandora_initialise_stack(struct pandora_task *t)
+{
+	unsigned long *stack = (unsigned long *)t->stack;
+
+	*stack = (unsigned long)t->entry + 4;			/* R15 / PC */
+	stack--;
+	*stack = 0xeeeeeeee;						/* R14 / LR */
+	stack--;
+	*stack = (unsigned long)t->stack;			/* R13 / SP */
+	stack--;
+	*stack = 0xcccccccc;			/* R12 */
+	stack--;
+	*stack = 0xbbbbbbbb;			/* R11 */
+	stack--;
+	*stack = 0xaaaaaaaa;			/* R10 */
+	stack--;
+	*stack = 0x99999999;			/* R9 */
+	stack--;
+	*stack = 0x88888888;			/* R8 */
+	stack--;
+	*stack = 0x77777777;			/* R7 */
+	stack--;
+	*stack = 0x66666666;			/* R6 */
+	stack--;
+	*stack = 0x55555555;			/* R5 */
+	stack--;
+	*stack = 0x44444444;			/* R4 */
+	stack--;
+	*stack = 0x33333333;			/* R3 */
+	stack--;
+	*stack = 0x22222222;			/* R2 */
+	stack--;
+	*stack = 0x11111111;			/* R1 */
+	stack--;
+	*stack = (unsigned long)t->parameter;			/* R0 */
+	stack--;
+
+	*stack = 0x1f;					/* SPSR */
+
+	return (unsigned long)stack;
+}
+
+void arm_cpu_relax(void)
+{
+	__asm__ volatile("swi 0":::);
+	__asm__ volatile("dsb");
+	__asm__ volatile("isb");
+}
+
+
diff --git a/pandora/arm64/context_macro.S b/pandora/arm64/context_macro.S
new file mode 100644
index 0000000..25d96e1
--- /dev/null
+++ b/pandora/arm64/context_macro.S
@@ -0,0 +1,129 @@
+/**
+ * pandora/arm64/context_macro.S
+
+ * Copyright (c) 2020 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __CONTEXT_ASM__
+#define __CONTEXT_ASM__
+
+#include <macro.S>
+
+/*
+ *	^ ------ ^
+ *	| sp_el0 |
+ *	* ------ *
+ *	|  spsr  |
+ *	* ------ *
+ *	| elr_elx|
+ *	* ------ *
+ *	|   x0   |
+ *	* ------ *
+ *	|   x1   |
+ *	* ------ *
+ *	|  ....  |
+ *	* ------ *
+ *	|   x30  |
+ *	* ------ *
+ */
+
+.macro	PANDORA_SAVE_CONTEXT
+
+	stp	x27, x28, [sp, #-16]!
+	mrs	x28, sp_el0
+	stp	x29, x30, [x28, #-16]!
+	mov	x30, x28
+	ldp	x27, x28, [sp], #16
+
+	stp	x27, x28, [x30, #-16]!
+	stp	x25, x26, [x30, #-16]!
+	stp	x23, x24, [x30, #-16]!
+	stp	x21, x22, [x30, #-16]!
+	stp	x19, x20, [x30, #-16]!
+	stp	x17, x18, [x30, #-16]!
+	stp	x15, x16, [x30, #-16]!
+	stp	x13, x14, [x30, #-16]!
+	stp	x11, x12, [x30, #-16]!
+	stp	x9, x10, [x30, #-16]!
+	stp	x7, x8, [x30, #-16]!
+	stp	x5, x6, [x30, #-16]!
+	stp	x3, x4, [x30, #-16]!
+	stp	x1, x2, [x30, #-16]!
+
+	armv8_switch_el x1, 1f, 2f, 3f
+1:	mrs	x1, elr_el1
+	mrs	x2, spsr_el1
+	mrs	x3, sp_el0
+	b	0f
+2:	b	.
+3:	mrs	x1, elr_el3
+	mrs	x2, spsr_el3
+	mrs	x3, sp_el0
+0:	stp	x1, x0, [x30, #-16]!
+	stp	x3, x2, [x30, #-16]!
+
+	ldr	x0, current_task
+	str	x30, [x0]
+.endm
+
+.macro	PANDORA_RESTORE_CONTEXT
+	ldr	x0, current_task
+	ldr	x30, [x0]
+
+	ldp	x3, x2, [x30], #16
+	ldp	x4, x0, [x30], #16
+	armv8_switch_el x1, 1f, 2f, 3f
+1:	msr	elr_el1, x4
+	msr	spsr_el1, x2
+	msr	sp_el0, x3
+	b	0f
+2:	b	.
+3:	msr	elr_el3, x4
+	msr	spsr_el3, x2
+	msr	sp_el0, x3
+0:	ldp	x1, x2, [x30], #16
+	ldp	x3, x4, [x30], #16
+	ldp	x5, x6, [x30], #16
+	ldp	x7, x8, [x30], #16
+	ldp	x9, x10, [x30], #16
+	ldp	x11, x12, [x30], #16
+	ldp	x13, x14, [x30], #16
+	ldp	x15, x16, [x30], #16
+	ldp	x17, x18, [x30], #16
+	ldp	x19, x20, [x30], #16
+	ldp	x21, x22, [x30], #16
+	ldp	x23, x24, [x30], #16
+	ldp	x25, x26, [x30], #16
+	ldp	x27, x28, [x30], #16
+
+	stp	x27, x28, [sp, #-16]!
+	mov	x28, x30
+	ldp	x29, x30, [x28], #16
+	ldp	x27, x28, [sp], #16
+
+.endm
+
+#endif
diff --git a/pandora/arm64/pandora.S b/pandora/arm64/pandora.S
new file mode 100644
index 0000000..2176af6
--- /dev/null
+++ b/pandora/arm64/pandora.S
@@ -0,0 +1,71 @@
+/**
+ * pandora/arm64/pandora.S
+ *
+ * Copyright (c) 2020 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <arm64/context_macro.S>
+
+.global __pandora_sche_start
+__pandora_sche_start:
+	PANDORA_RESTORE_CONTEXT
+	eret
+
+.global __pandora_yield
+__pandora_yield:
+	PANDORA_SAVE_CONTEXT
+	bl pandora_task_switch
+	PANDORA_RESTORE_CONTEXT
+	eret
+
+.global __pandora_svc
+__pandora_svc:
+	PANDORA_SAVE_CONTEXT
+	bl pandora_task_switch
+	PANDORA_RESTORE_CONTEXT
+	eret
+
+.global __mutex_atomic_set
+__mutex_atomic_set:
+1:	ldr	w1, [x0]
+	cbz	w1, __lock
+	svc	#0
+	b	1b
+__lock:
+	msr	daifset, #3
+	mov	w1, #1
+	str	w1, [x0]
+	msr	daifclr, #3
+	ret
+
+.global __mutex_atomic_clr
+__mutex_atomic_clr:
+	msr	daifset, #3
+	mov	w1, #0
+	str	w1, [x0]
+	msr	daifclr, #3
+	ret
+
diff --git a/pandora/arm64/processor.c b/pandora/arm64/processor.c
new file mode 100644
index 0000000..8c364b0
--- /dev/null
+++ b/pandora/arm64/processor.c
@@ -0,0 +1,68 @@
+/**
+ * pandora/arm/processor.c
+ *
+ * Copyright (c) 2020 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+#include <bldfunc.h>
+#include <irq.h>
+#include <ambhw/timer.h>
+#include <pandora.h>
+
+unsigned long pandora_initialise_stack(struct pandora_task *t)
+{
+	int i;
+	unsigned long *stack = (unsigned long *)t->stack;
+	unsigned long bayonetta = 0x5a5a5a5a5a5a5a00;
+
+	for (i = 30; i >= 0; i--){
+		if (i == 0) {
+			*stack = (unsigned long)t->parameter;	/* X0 */
+		} else {
+			*stack = bayonetta | i;			/* X1 ~ X30 */
+		}
+		stack--;
+	}
+	*stack = (unsigned long)t->entry;			/* ELR	*/
+	stack --;
+#ifdef CONFIG_AARCH64_TRUSTZONE
+	*stack = 0x20000304;					/* SPSR	*/
+#else
+	*stack = 0x2000030C;					/* SPSR	*/
+#endif
+	stack--;
+	*stack = (unsigned long)t->stack;			/* SP_EL0 */
+
+	return (unsigned long)stack;
+}
+
+void arm_cpu_relax(void)
+{
+	__asm__ volatile("svc 0":::);
+}
+
+
diff --git a/pandora/init.c b/pandora/init.c
new file mode 100644
index 0000000..cf55cd5
--- /dev/null
+++ b/pandora/init.c
@@ -0,0 +1,71 @@
+/**
+ * pandora/init.c
+ *
+ * 2017-03-06	Create file by Jorney
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+#include <irq.h>
+#include <bldfunc.h>
+#include <ambhw/gpio.h>
+#include <ambhw/timer.h>
+#include <pandora.h>
+
+void pandora(void)
+{
+	malloc_init();
+	rct_pll_init();
+	enable_fio_dma();
+	rct_reset_fio();
+	dma_channel_select();
+
+#if defined(CONFIG_AMBOOT_ENABLE_GPIO)
+	gpio_init();
+#else
+	gpio_mini_init(main_boot_from);
+#endif
+	/* Initialize various peripherals used in AMBoot */
+	if (amboot_bsp_early_init != NULL) {
+		amboot_bsp_early_init();
+	}
+
+	uart_init();
+	putstr("\x1b[4l");	/* Set terminal to replacement mode */
+	putstr("\r\n");		/* First, output a blank line to UART */
+	irq_init();
+
+	pandora_thread_init();
+	pandora_thread_create("main", TSKIDLE_PRIORITY + 2, main, NULL);
+	pandora_schedule_start();
+
+	for(;;);
+}
+void pandora_fingerprint(void)
+{
+	pr_color(RED, "Pandora: multithreading built-in\n");
+}
diff --git a/pandora/nand_pandora.c b/pandora/nand_pandora.c
new file mode 100644
index 0000000..c6399df
--- /dev/null
+++ b/pandora/nand_pandora.c
@@ -0,0 +1,1587 @@
+/**
+ * bld/nand.c
+ *
+ * Flash controller functions with NAND chips.
+ *
+ * History:
+ *    2005/02/15 - [Charles Chiou] created file
+ *    2006/07/26 - [Charles Chiou] converted to DMA descriptor-mode
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <ambhw/nand.h>
+#include <ambhw/dma.h>
+#include <ambhw/cache.h>
+#include <fio/ftl_const.h>
+#include <flash/nanddb.h>
+#include <pandora.h>
+#include <irq.h>
+
+/* ==========================================================================*/
+#define NAND_CMD_NOP			0x0
+#define NAND_CMD_DMA			0x1
+#define NAND_CMD_RESET			0x2
+#define NAND_CMD_NOP2			0x3
+#define NAND_CMD_NOP3			0x4
+#define NAND_CMD_NOP4			0x5
+#define NAND_CMD_NOP5			0x6
+#define NAND_CMD_COPYBACK		0x7
+#define NAND_CMD_NOP6			0x8
+#define NAND_CMD_ERASE			0x9
+#define NAND_CMD_READID			0xa
+#define NAND_CMD_NOP7			0xb
+#define NAND_CMD_READSTATUS		0xc
+#define NAND_CMD_NOP8			0xd
+#define NAND_CMD_READ			0xe
+#define NAND_CMD_PROGRAM		0xf
+
+#define NAND_CMD_TIMEOUT		1000
+#define NAND_DMA_TIMEOUT		1000
+
+/* ==========================================================================*/
+extern flnand_t flnand;
+
+/**
+ * DMA descriptor.
+ */
+struct fio_dmadesc_s
+{
+	u32	src_addr;	/**< Source address */
+	u32	dst_addr;	/**< Destination address */
+	u32	next;		/**< Next descriptor */
+	u32	rpt_addr;	/**< Report address */
+	u32	xfrcnt;		/**< Transfer count */
+	u32	ctrl;		/**< Control */
+	u32	rsv0;		/**< Reserved */
+	u32	rsv1;		/**< Reserved */
+	u32	rpt;		/**< Report */
+	u32	rsv2;		/**< Reserved */
+	u32	rsv3;		/**< Reserved */
+	u32	rsv4;		/**< Reserved */
+} __attribute__((packed));
+
+static struct fio_dmadesc_s G_fio_dmadesc __attribute__((aligned(32)));
+static struct fio_dmadesc_s G_fio_dma_spr_desc __attribute__((aligned(32)));
+
+#define PAGE_SIZE_512		512
+#define PAGE_SIZE_2K		2048
+#define MAX_SPARE_SIZE_BLK	8192
+
+#define ECC_STEPS			4
+static u8 buffer[PAGE_SIZE_2K] __attribute__ ((aligned(32)));
+static u8 dummy_buffer_bch[MAX_SPARE_SIZE_BLK] __attribute__ ((aligned(32)));
+
+static pandora_mutex_t nand_read_mutex;
+static completion_t dma_completion;
+
+/* ==========================================================================*/
+
+static void nand_wait_cmd_done(u32 cmd)
+{
+	writel(NAND_CMD_REG, cmd);
+
+	rct_timer2_reset_count();
+
+	while(1) {
+		if (readl(NAND_INT_REG) & NAND_INT_DI)
+			break;
+
+		if (rct_timer2_get_count() >= NAND_CMD_TIMEOUT) {
+			putstr("nand cmd timeout: ");
+			puthex(cmd);
+			putstr("\r\n");
+			while(1);
+		}
+	}
+
+	writel(NAND_INT_REG, 0x0);
+}
+
+#if 0
+static void nand_wait_dma_done(void)
+{
+	rct_timer2_reset_count();
+
+	while(1) {
+		if ((readl(NAND_INT_REG) & NAND_INT_DI) &&
+			(readl(FDMA_REG(DMA_INT_OFFSET)) & 0x1) &&
+			(readl(FIO_DMASTA_REG) & FIO_DMASTA_DN) &&
+			!(readl(FDMA_CHAN_CTR_REG) & FDMA_CHAN_CTR_EN) &&
+			!(readl(FIO_DMACTR_REG) & FIO_DMACTR_EN))
+			break;
+
+		if (rct_timer2_get_count() >= NAND_DMA_TIMEOUT) {
+			putstr("nand dma timeout\r\n");
+			while(1);
+		}
+	}
+}
+#else
+static void nand_wait_dma_done(void)
+{
+	wait_for_completion_timeout(&dma_completion, 1000);
+}
+#endif
+
+static void fio_dma_handler(void *data)
+{
+	writel(FIO_DMASTA_REG, 0x0);
+	writel(FIO_ECC_RPT_STA_REG, 0x0);
+	complete_isr(&dma_completion);
+}
+
+#if 0
+static void nand_wait_desc_dma_done(void)
+{
+	rct_timer2_reset_count();
+
+	while(1) {
+		_clean_flush_d_cache();
+
+		if ((readl(NAND_INT_REG) & NAND_INT_DI) &&
+			(readl(FDMA_REG(DMA_INT_OFFSET)) & 0x1) &&
+			(readl(FIO_DMASTA_REG) & FIO_DMASTA_DN) &&
+			(G_fio_dmadesc.rpt & FDMA_CHAN_STA_DN))
+			break;
+
+		if (rct_timer2_get_count() >= NAND_DMA_TIMEOUT) {
+			putstr("nand desc dma timeout\r\n");
+			while(1);
+		}
+	}
+}
+#else
+
+static void nand_wait_desc_dma_done(void)
+{
+	wait_for_completion_timeout(&dma_completion, 1000);
+}
+#endif
+
+/* ==========================================================================*/
+
+/**
+ * Calculate address from the (block, page) pair.
+ */
+u32 addr_from_block_page(u32 block, u32 page)
+{
+	u32 rval = ((block * flnand.pages_per_block) + page);
+
+	if (flnand.main_size == PAGE_SIZE_512)
+		return (rval << 9);
+	else if (flnand.main_size == PAGE_SIZE_2K)
+		return (rval << 11);
+
+	return -1;
+}
+
+#define hweight8(w)		\
+      (	(!!((w) & (0x01 << 0))) +	\
+	(!!((w) & (0x01 << 1))) +	\
+	(!!((w) & (0x01 << 2))) +	\
+	(!!((w) & (0x01 << 3))) +	\
+	(!!((w) & (0x01 << 4))) +	\
+	(!!((w) & (0x01 << 5))) +	\
+	(!!((w) & (0x01 << 6))) +	\
+	(!!((w) & (0x01 << 7)))	)
+
+static int count_zero_bits(u8 *buf, int size, int max_bits)
+{
+	int i, zero_bits = 0;
+
+	for (i = 0; i < size; i++) {
+		zero_bits += hweight8(~buf[i]);
+		if (zero_bits > max_bits)
+			break;
+	}
+	return zero_bits;
+}
+
+
+/*
+	This func maybe not have effect when read (>1)pages data
+	and we do not memset the erased page to 0xFF, if error bit < ecc_bits
+*/
+static int nand_bch_check_blank_pages(u32 pages, u8 *main, u8 *spare)
+{
+	u32 i, j;
+	int zeroflip = 0;
+	int oob_subset, main_subset;
+	int zero_bits = 0;
+	u8 *bsp;
+	u8 *bufpos;
+
+	bsp = spare;
+	bufpos = main;
+	main_subset = flnand.main_size / ECC_STEPS;
+	oob_subset  = flnand.spare_size / ECC_STEPS;
+	if (flnand.ecc_bits > 0x1) {
+		for (i = 0; i < pages; i++) {
+			zeroflip = 0;
+			for (j = 0; j < ECC_STEPS; j++) {
+				zero_bits = count_zero_bits(bufpos, main_subset,
+								flnand.ecc_bits);
+				if (zero_bits > flnand.ecc_bits)
+					return -1;
+
+				if (zero_bits)
+					zeroflip = 1;
+
+				zero_bits += count_zero_bits(bsp, oob_subset,
+								flnand.ecc_bits);
+				if (zero_bits > flnand.ecc_bits)
+					return -1;
+
+				bufpos += main_subset;
+				bsp += oob_subset;
+			}
+			/* use zeroflip for declaring blank page status */
+			if (zeroflip)
+				printf("Erased blank page has bitflip \n");
+		}
+	}
+	return 0;
+}
+
+static void nand_corrected_recovery(void)
+{
+	u32 fio_ctr_reg;
+
+	/* FIO reset will just reset FIO registers, but will not affect
+	 * Nand controller. */
+	fio_ctr_reg = readl(FIO_CTR_REG);
+
+	writel(FIO_RESET_REG, FIO_RESET_FIO_RST);
+	rct_timer_dly_ms(1);
+	writel(FIO_RESET_REG, 0x0);
+	rct_timer_dly_ms(1);
+
+	writel(FIO_CTR_REG, fio_ctr_reg);
+}
+
+/*
+ * Set Flash_IO_dsm_control Register
+ */
+static void nand_en_bch()
+{
+	u32 fio_dsm_ctr = 0, fio_ctr_reg = 0, dma_dsm_ctr = 0;
+
+	fio_ctr_reg = readl(FIO_CTR_REG);
+	/* Setup FIO Dual Space Mode Control Register */
+	if (flnand.ecc_bits > 0x1) {
+		/* Using BCH */
+		fio_dsm_ctr |= (FIO_DSM_EN | FIO_DSM_MAJP_2KB);
+		dma_dsm_ctr |= (DMA_DSM_EN | DMA_DSM_MAJP_2KB);
+		fio_ctr_reg |= (FIO_CTR_RS | FIO_CTR_CO);
+
+		if (flnand.ecc_bits == 0x6) {
+			fio_dsm_ctr |= FIO_DSM_SPJP_64B;
+			dma_dsm_ctr |= DMA_DSM_SPJP_64B;
+			fio_ctr_reg |=	FIO_CTR_ECC_6BIT;
+		} else {
+			fio_dsm_ctr |= FIO_DSM_SPJP_128B;
+			dma_dsm_ctr |= DMA_DSM_SPJP_128B;
+			fio_ctr_reg |=	FIO_CTR_ECC_8BIT;
+			writel(NAND_EXT_CTR_REG, readl(NAND_EXT_CTR_REG) | NAND_EXT_CTR_SP_2X);
+		}
+	} else {
+		/* Should not be here! */
+		putstr("ECC bit is 0 or 1,Do not need to enable BCH,so it can not be here!\n\r");
+	}
+
+	if (FIO_SUPPORT_SKIP_BLANK_ECC)
+		fio_ctr_reg |= FIO_CTR_SKIP_BLANK;
+
+	writel(FIO_DSM_CTR_REG, fio_dsm_ctr);
+	writel(FIO_CTR_REG, fio_ctr_reg);
+	writel(FDMA_CHAN_DSM_CTR_REG, dma_dsm_ctr);
+}
+
+/*
+ * Disable Flash_IO_dsm_control and Flash_IO_control Register
+ */
+static void nand_dis_bch()
+{
+	u32 fio_ctr_reg = 0;
+
+	fio_ctr_reg = readl(FIO_CTR_REG);
+	/* Setup FIO Dual Space Mode Control Register */
+	fio_ctr_reg |= FIO_CTR_RS;
+	fio_ctr_reg &= ~(FIO_CTR_CO |
+			 FIO_CTR_ECC_6BIT |
+			 FIO_CTR_ECC_8BIT);
+
+	writel(FIO_CTR_REG, fio_ctr_reg);
+}
+
+/**
+ * Check for bad block.
+ */
+int nand_is_bad_block(u32 block)
+{
+	int ret_val = -1, i;
+	u8 sbuf[1024], *sbuf_ptr;
+	u8 bi;
+
+	/* make sure 32 bytes aligned */
+	sbuf_ptr = (u8 *)(((uintptr_t)sbuf + 31) & (~31));
+
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+	if(nand_has_bbt())
+		return nand_isbad_bbt(block);
+#endif
+
+	ret_val = nand_read_spare(block, 0, BAD_BLOCK_PAGES, sbuf_ptr);
+	if (ret_val < 0) {
+		putstr("check bad block failed >> "
+				"read spare data error.\r\n");
+		/* Treat as factory bad block */
+		return NAND_INITIAL_BAD_BLOCK;
+	}
+
+	for (i = 0; i < INIT_BAD_BLOCK_PAGES; i++) {
+		if (flnand.main_size == 512)
+			bi = *(sbuf_ptr + i * flnand.spare_size + 5);
+		else
+			bi = *(sbuf_ptr + i * flnand.spare_size);
+
+		if (bi != 0xff)
+			break;
+	}
+
+
+	/* Good block */
+	if (i == INIT_BAD_BLOCK_PAGES)
+		return NAND_GOOD_BLOCK;
+
+	for (i = INIT_BAD_BLOCK_PAGES; i < BAD_BLOCK_PAGES; i++) {
+		if (flnand.main_size == 512)
+			bi = *(sbuf_ptr + i * flnand.spare_size + 5);
+		else
+			bi = *(sbuf_ptr + i * flnand.spare_size);
+
+		if (bi != 0xff)
+			break;
+	}
+
+	if (i < BAD_BLOCK_PAGES) {
+		/* Late developed bad blocks. */
+		return NAND_LATE_DEVEL_BAD_BLOCK;
+	} else {
+		/* Initial invalid blocks. */
+		return NAND_INITIAL_BAD_BLOCK;
+	}
+}
+
+int nand_correct_offset(u32 start_blk, u32 offset, u32 *c_offset)
+{
+	int i = 0;
+	u32 bad_blk = 0, valid_blk = 0;
+	u32 blk_size = flnand.block_size;
+	u32 offset_blk = ROUND_DOWN(offset, blk_size)/blk_size;
+
+	for (i = 0, valid_blk = 0; valid_blk < offset_blk; i++) {
+		if (nand_is_bad_block(start_blk + i) == NAND_GOOD_BLOCK) {
+			valid_blk++;
+		} else {
+			bad_blk++;
+		}
+	}
+	if (c_offset) {
+		*c_offset = (bad_blk * blk_size) + offset;
+	}
+
+	return 0;
+}
+
+void nand_output_bad_block(u32 block, int bb_type)
+{
+	if (bb_type & NAND_INITIAL_BAD_BLOCK) {
+		putstr("initial bad block. <block ");
+	} else if (bb_type & NAND_LATE_DEVEL_BAD_BLOCK) {
+		putstr("late developed bad block. <block ");
+	} else {
+		putstr("other bad block. <block ");
+	}
+	putdec(block);
+	putstr(">\r\n");
+	putstr("Try next block...\r\n");
+}
+
+/**
+ * Mark a bad block.
+ */
+int nand_mark_bad_block(u32 block)
+{
+	int ret_val = -1, i;
+	u8 sbuf[256], *sbuf_ptr;
+	u8 bi;
+
+	/* make sure 32 bytes aligned */
+	sbuf_ptr = (u8 *)(((uintptr_t)sbuf + 31) & (~31));
+
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+	nand_update_bbt(block, 0);
+#endif
+
+	for (i = AMB_BB_START_PAGE; i < BAD_BLOCK_PAGES; i++) {
+		memset(sbuf_ptr, 0xff, flnand.spare_size);
+		if (flnand.main_size == 512) {
+			*(sbuf_ptr + 5) = AMB_BAD_BLOCK_MARKER;
+		} else {
+			*sbuf_ptr = AMB_BAD_BLOCK_MARKER;
+		}
+
+		ret_val = nand_prog_spare(block, i, 1, sbuf_ptr);
+		if (ret_val < 0) {
+			putstr("mark bad block failed >> "
+				"write spare data error.\r\n");
+			return ret_val;
+		}
+
+		ret_val = nand_read_spare(block, i, 1, sbuf_ptr);
+		if (ret_val < 0) {
+			putstr("mark bad block failed >> "
+				"read spare data error.\r\n");
+			return ret_val;
+		}
+
+		if (flnand.main_size == 512)
+			bi = *(sbuf_ptr + 5);
+		else
+			bi = *sbuf_ptr;
+
+		if (bi == 0xff) {
+			putstr("mark bad block failed >> "
+				"verify failed at block ");
+			putdec(block);
+			putstr("\r\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * Initialize NAND parameters.
+ */
+int nand_init(void)
+{
+	nand_db_t *nand_db;
+	u32 id, id5, sys_config_val;
+	int i, match = 0;
+	flnand_t *fn = &flnand;
+	int sblk, nblk, part_size[HAS_IMG_PARTS];
+
+	mutex_init(&nand_read_mutex);
+	init_completion(&dma_completion);
+
+	request_irq(FIODMA_IRQ, IRQ_LEVEL_HIGH, fio_dma_handler, NULL);
+
+	writel(FIO_DMACTR_REG,
+	       (readl(FIO_DMACTR_REG) & 0xcfffffff) | FIO_DMACTR_FL);
+
+	/* Force ReadID with 4-cycles */
+	writel(NAND_CTR_REG, readl(NAND_CTR_REG) | NAND_CTR_I4);
+
+	/* Reset chip */
+	nand_wait_cmd_done(NAND_CMD_RESET);
+
+	/* Read ID with maximun 5 times if id is 0. */
+	for (i = 0; i < 5; i++) {
+		nand_wait_cmd_done(NAND_CMD_READID);
+		id = readl(NAND_ID_REG);
+		if (id)
+			break;
+	}
+
+	ASSERT(id == 0, "NAND chip absence?\n");
+
+	/* Read ID5 with maximun 5 times if id is 0. */
+	/* Disable NAND_CTR_I4 */
+	writel(NAND_CTR_REG, readl(NAND_CTR_REG) & ~(NAND_CTR_I4));
+	writel(NAND_EXT_CTR_REG, readl(NAND_EXT_CTR_REG) | NAND_EXT_CTR_I5);
+	for (i = 0; i < 5; i++) {
+		nand_wait_cmd_done(NAND_CMD_READID);
+		id5 = readl(NAND_EXT_ID5_REG) & 0xff;
+		if (id5)
+			break;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ns_nand_ids); i++) {
+		ASSERT((id == ns_nand_ids[i].nand_id && id5 == ns_nand_ids[i].id5),
+				"Unsupport NAND flash\r\n");
+	}
+
+	/* Search the NAND-DB for an exact match */
+	for (nand_db = __nanddb_start; nand_db < __nanddb_end; nand_db++) {
+		if ((nand_db->id == id && nand_db->id5 == id5) ||
+			(id == 0x01F1801D && nand_db->id == id)) {
+			match = 1;
+			break;
+		}
+	}
+
+	ASSERT(!match, "Non-matched NAND: 0x%x, 0x%x\n", id, id5);
+
+	fn->nandtiming0 = nand_db->timing0;
+	fn->nandtiming1 = nand_db->timing1;
+	fn->nandtiming2 = nand_db->timing2;
+	fn->nandtiming3 = nand_db->timing3;
+	fn->nandtiming4 = nand_db->timing4;
+	fn->nandtiming5 = nand_db->timing5;
+	fn->nandtiming6 = nand_db->timing6;
+
+	/* Setup flash timing register */
+	writel(NAND_TIMING0_REG, FLASH_TIMING_MIN(nand_db->timing0, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing0, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing0, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing0, 0));
+
+	writel(NAND_TIMING1_REG, FLASH_TIMING_MIN(nand_db->timing1, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing1, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing1, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing1, 0));
+
+	writel(NAND_TIMING2_REG, FLASH_TIMING_MIN(nand_db->timing2, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing2, 16)	|
+			 FLASH_TIMING_MAX(nand_db->timing2, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing2, 0));
+
+	writel(NAND_TIMING3_REG, FLASH_TIMING_MIN(nand_db->timing3, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing3, 16)	|
+			 FLASH_TIMING_MAX(nand_db->timing3, 8)	|
+			 FLASH_TIMING_MAX(nand_db->timing3, 0));
+
+	writel(NAND_TIMING4_REG, FLASH_TIMING_MIN(nand_db->timing4, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing4, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing4, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing4, 0));
+
+	writel(NAND_TIMING5_REG, FLASH_TIMING_MIN(nand_db->timing5, 16)	|
+			 FLASH_TIMING_MAX(nand_db->timing5, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing5, 0));
+
+#if (NAND_CUSTOM_CMD_SUPPORT == 1)
+	writel(NAND_TIMING6_REG, FLASH_TIMING_MIN(nand_db->timing6, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing6, 8)	|
+			 FLASH_TIMING_MAX(nand_db->timing6, 0));
+#endif
+
+	fn->main_size = nand_db->main_size;
+	fn->spare_size = nand_db->spare_size;
+	fn->blocks_per_bank = nand_db->blocks_per_bank;
+	fn->pages_per_block = nand_db->pages_per_block;
+	fn->block_size = nand_db->main_size * nand_db->pages_per_block;
+
+	fn->control = NAND_CTR_IE;
+
+	if (fn->blocks_per_bank * fn->pages_per_block > 65536)
+		fn->control |= NAND_CTR_P3;
+
+	if (fn->main_size == 2048)
+		fn->control |= NAND_CTR_C2 | NAND_CTR_RC;
+
+	switch (fn->block_size * fn->blocks_per_bank) {
+	case 8 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_64M;
+		break;
+	case 16 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_128M;
+		break;
+	case 32 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_256M;
+		break;
+	case 64 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_512M;
+		break;
+	case 128 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_1G;
+		break;
+	case 256 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_2G;
+		break;
+	case 512 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_4G;
+		break;
+	case 1024 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_8G;
+		break;
+	default:
+		ASSERT(1, "Unexpected NAND flash chipsize\r\n");
+		break;
+	}
+
+	sys_config_val = rct_get_nand_poc();
+	if ((sys_config_val & RCT_BOOT_NAND_ECC_BCH_EN) ==
+		RCT_BOOT_NAND_ECC_BCH_EN) {
+		if ((sys_config_val & RCT_BOOT_NAND_ECC_SPARE_2X) ==
+			RCT_BOOT_NAND_ECC_SPARE_2X) {
+			fn->ecc_bits = 8;
+		} else {
+			fn->ecc_bits = 6;
+		}
+	} else {
+		fn->ecc_bits = 1;
+	}
+
+	ASSERT((fn->ecc_bits != 1) && (fn->main_size == 512),
+		"Small page does not support multi-bits ECC!\r\n");
+
+	ASSERT((fn->ecc_bits == 8) && (fn->spare_size != 128),
+		"Spare size must be 2x for 8-bits ECC!\r\n");
+
+	if (fn->ecc_bits > 1)
+		nand_en_bch();
+
+	get_part_size(part_size);
+
+	sblk = nblk = 0;
+	for (i = 0; i < HAS_IMG_PARTS; i++) {
+		if ((get_part_dev(i) & PART_DEV_NAND) != PART_DEV_NAND) {
+			continue;
+		}
+
+		sblk += nblk;
+		nblk = part_size[i] / fn->block_size;
+		if ((part_size[i] % fn->block_size) != 0x0)
+			nblk++;
+		fn->sblk[i] = (nblk == 0) ? 0 : sblk;
+		fn->nblk[i] = nblk;
+	}
+	for (; i < PART_MAX; i++) {
+		fn->sblk[i] = 0;
+		fn->nblk[i] = 0;
+	}
+
+	nblk = (fn->blocks_per_bank > sblk) ? (fn->blocks_per_bank - sblk) : 0;
+	//Raw part include BBT, take care!
+	fn->sblk[PART_RAW] = (nblk == 0) ? 0 : sblk;
+	fn->nblk[PART_RAW] = nblk;
+	ASSERT(fn->sblk[PART_RAW] < 2, "No Space for BBT!\r\n");
+
+	/* Reset FIO FIFO, and Exit random read mode */
+	setbitsl(FIO_CTR_REG, FIO_CTR_RR);
+	rct_timer2_dly_ms(1); /* delay is must have */
+	clrbitsl(FIO_CTR_REG, FIO_CTR_RR);
+
+	/* Clear the FIO DMA Status Register */
+	writel(FIO_DMASTA_REG, 0x0);
+
+	/* Setup FIO DMA Control Register */
+	writel(FIO_DMACTR_REG, FIO_DMACTR_FL | FIO_DMACTR_TS4B);
+
+	/* Setup NAND Flash Control Register */
+	writel(NAND_CTR_REG, flnand.control);
+	writel(NAND_INT_REG, 0x0);
+
+	return 0;
+}
+
+/**
+ * Read multiple pages from NAND flash with ecc check.
+ */
+int nand_read_pages(u32 block, u32 page, u32 pages,
+		u8 *main_buf, u8 *spare_buf, u32 enable_ecc)
+{
+	u32 status, addr, mlen, slen;
+	u32 spare_buf_addr = 0, fio_ctr_reg = 0;
+	u32 nand_ctr_reg = flnand.control, i;
+	int ret = 0;
+
+	/* check parameters */
+	if ((page + pages) > flnand.pages_per_block || !main_buf) {
+		putstr("ERR: parameter error in nand_read_pages()");
+		return -1;
+	}
+
+	mutex_lock(&nand_read_mutex);
+
+	mlen = pages * flnand.main_size;
+	clean_flush_d_cache((void *)main_buf, mlen);
+
+	/* Setup Flash Control Register */
+#if (NAND_XD_SUPPORT_WAS == 0) && (NAND_SUPPORT_INTLVE == 0)
+	nand_ctr_reg = flnand.control;
+#elif (NAND_XD_SUPPORT_WAS >= 1) && (NAND_SUPPORT_INTLVE == 0)
+	nand_ctr_reg = flnand.control | NAND_CTR_WAS;
+#elif (NAND_XD_SUPPORT_WAS >= 1) && (NAND_SUPPORT_INTLVE == 1)
+	nand_ctr_reg = flnand.control | NAND_CTR_WAS;
+
+#if defined(NAND_K9K8_INTLVE)
+	nand_ctr_reg = flnand.control | NAND_CTR_K9;
+#endif
+#endif
+
+	spare_buf = spare_buf ? : dummy_buffer_bch;
+	spare_buf_addr = (uintptr_t)spare_buf;
+
+	/* Setup Flash IO Control Register */
+	if (enable_ecc) {
+		if (flnand.ecc_bits > 1) {
+			slen = pages * flnand.spare_size;
+			clean_flush_d_cache(spare_buf, slen);
+
+			nand_en_bch();
+			/* Setup Flash Control Register*/
+			/* Don't set NAND_CTR_EC_MAIN, because we use BCH */
+			writel(NAND_CTR_REG, nand_ctr_reg | NAND_CTR_SE);
+			/* Clean Flash_IO_ecc_rpt_status Register */
+			writel(FIO_ECC_RPT_STA_REG, 0x0);
+		} else {
+			slen = 0;
+			/* Setup Flash IO Control Register */
+			writel(FIO_CTR_REG, FIO_CTR_XD | FIO_CTR_RS | FIO_CTR_CO);
+
+			/* Setup Flash Control Register*/
+			writel(NAND_CTR_REG, nand_ctr_reg | NAND_CTR_SE | NAND_CTR_EC_MAIN);
+		}
+	} else {
+		if (flnand.ecc_bits > 1) {
+			slen = pages * flnand.spare_size;
+			clean_flush_d_cache(spare_buf, slen);
+
+			nand_dis_bch();
+			fio_ctr_reg = FIO_CTR_XD | FIO_CTR_RS;
+		} else {
+			slen = 0;
+			fio_ctr_reg = FIO_CTR_XD;
+		}
+
+		/* NO ECC */
+		writel(FIO_CTR_REG, fio_ctr_reg);
+		writel(NAND_CTR_REG, nand_ctr_reg);
+	}
+
+	/* Setup main external DMA engine transfer */
+	writel(FDMA_CHAN_STA_REG, 0x0);
+	writel(FDMA_CHAN_SRC_REG, (uintptr_t)FIO_FIFO_BASE);
+	writel(FDMA_CHAN_DST_REG, (uintptr_t)main_buf);
+
+	if (flnand.ecc_bits > 1) {
+		/* Setup spare external DMA engine transfer */
+		writel(FDMA_CHAN_SPR_STA_REG, 0x0);
+		writel(FDMA_CHAN_SPR_SRC_REG, (uintptr_t)FIO_FIFO_BASE);
+		writel(FDMA_CHAN_SPR_DST_REG, spare_buf_addr);
+		writel(FDMA_CHAN_SPR_CNT_REG, slen);
+	}
+
+	writel(FDMA_CHAN_CTR_REG,
+	       FDMA_CHAN_CTR_EN		|
+	       FDMA_CHAN_CTR_WM		|
+	       FDMA_CHAN_CTR_NI		|
+	       FDMA_NODC_MN_BURST_SIZE	|
+	       mlen);
+
+	/* Write start address for memory target to */
+	/* FIO DMA Address Register. */
+	addr = addr_from_block_page(block, page);
+	writel(FIO_DMAADR_REG, addr);
+
+	/* Setup the Flash IO DMA Control Register */
+	writel(FIO_DMACTR_REG,
+	       FIO_DMACTR_EN		|
+	       FIO_DMACTR_FL		|
+	       FIO_DMACTR_BLK_512B |
+	       FIO_DMACTR_TS8B	|
+	       (mlen + slen));
+
+	/* Wait for interrupt for DMA done */
+	nand_wait_dma_done();
+	status = readl(FIO_DMASTA_REG);
+
+	writel(NAND_INT_REG, 0x0);
+	writel(FIO_DMASTA_REG, 0x0);	/* clear */
+	writel(FDMA_REG(DMA_INT_OFFSET), 0x0);	/* clear */
+	writel(FDMA_CHAN_STA_REG, 0);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE)) {
+		ret = -1;
+		goto nand_read_pages_err;
+	}
+
+	if (flnand.ecc_bits > 1 && enable_ecc) {
+		status = readl(FIO_ECC_RPT_STA_REG);
+		if (status & FIO_ECC_RPT_FAIL) {
+			if (FIO_SUPPORT_SKIP_BLANK_ECC) {
+				if ((readl(FIO_CTR_REG) & FIO_CTR_SKIP_BLANK)) {
+					putstr("BCH real corrected failed (0x");
+					puthex(status);
+					putstr(")!\n\r");
+				} else {
+					putstr("Should not be here, error path");
+				}
+			} else {
+				/* Workaround for page never used, BCH will failed */
+				i = nand_bch_check_blank_pages(pages, (u8 *)main_buf,
+						(u8 *)(uintptr_t)spare_buf_addr);
+
+				if (i < 0) {
+					putstr("BCH corrected failed (0x");
+					puthex(status);
+					putstr(")!\n\r");
+				}
+			}
+		} else if (status & FIO_ECC_RPT_ERR) {
+#if 0
+			putstr("BCH code corrected (0x");
+			puthex(status);
+			putstr(")!\n\r");
+#endif
+			/* once bitflip and data corrected happened, BCH will keep
+			 * on to report bitflip in next read operation, even though
+			 * there is no bitflip happened really. So this is a workaround
+			 * to get it back. */
+			nand_corrected_recovery();
+			ret = 1;
+		}
+	}
+nand_read_pages_err:
+	mutex_unlock(&nand_read_mutex);
+	return ret;
+}
+
+static int nand_read(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	int rval = 0;
+	u32 first_blk_pages, blocks, last_blk_pages;
+	u32 bad_blks = 0;
+
+	first_blk_pages = flnand.pages_per_block - page;
+	if (pages > first_blk_pages) {
+		pages -= first_blk_pages;
+		blocks = pages / flnand.pages_per_block;
+		last_blk_pages = pages % flnand.pages_per_block;
+	} else {
+		first_blk_pages = pages;
+		blocks = 0;
+		last_blk_pages = 0;
+	}
+
+	if (first_blk_pages) {
+		while (nand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = nand_read_pages(block, page, first_blk_pages, buf, NULL, 1);
+		if (rval < 0)
+			return -1;
+		block++;
+		buf += first_blk_pages * flnand.main_size;
+	}
+
+	while (blocks > 0) {
+		while (nand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = nand_read_pages(block, 0, flnand.pages_per_block, buf, NULL, 1);
+		if (rval < 0)
+			return -1;
+		block++;
+		blocks--;
+		buf += flnand.block_size;
+	}
+
+	if (last_blk_pages) {
+		while (nand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = nand_read_pages(block, 0, last_blk_pages, buf, NULL, 1);
+		if (rval < 0)
+			return -1;
+	}
+
+	return bad_blks;
+}
+
+static void nand_get_offset_adr(u32 *block, u32 *page, u32 pages, u32 bad_blks)
+{
+	u32 blocks;
+
+	blocks = pages / flnand.pages_per_block;
+	pages  = pages % flnand.pages_per_block;
+
+	*block =  *block + blocks;
+	*page += pages;
+
+	if (*page >= flnand.pages_per_block) {
+		*page -= flnand.pages_per_block;
+		*block += 1;
+	}
+
+	*block += bad_blks;
+}
+
+/**
+ * Read data from NAND flash to memory.
+ * dst - address in dram.
+ * src - address in nand device.
+ * len - length to be read from nand.
+ * return - length of read data.
+ */
+int nand_read_data(u8 *dst, u8 *src, int len)
+{
+	u32 block, page, pages, pos;
+	u32 first_ppage_size, last_ppage_size;
+	uintptr_t val, rval = -1;
+
+	/* translate address to block, page, address */
+	val = (uintptr_t) src;
+	block = val / flnand.block_size;
+	val  -= block * flnand.block_size;
+	page  = val / flnand.main_size;
+	pos   = val % flnand.main_size;
+	pages = len / flnand.main_size;
+
+	if (pos == 0)
+		first_ppage_size = 0;
+	else
+		first_ppage_size = flnand.main_size - pos;
+
+	if (len >= first_ppage_size) {
+		pages = (len - first_ppage_size) / flnand.main_size;
+
+		last_ppage_size = (len - first_ppage_size) % flnand.main_size;
+	} else {
+		first_ppage_size = len;
+		pages = 0;
+		last_ppage_size = 0;
+	}
+
+	if (len !=
+	    (first_ppage_size + pages * flnand.main_size + last_ppage_size)) {
+		return -1;
+	}
+
+	len = 0;
+	if (first_ppage_size) {
+		rval = nand_read(block, page, 1, buffer);
+		if (rval < 0)
+			return len;
+
+		memcpy(dst, (void *) (buffer + pos), first_ppage_size);
+		dst += first_ppage_size;
+		len += first_ppage_size;
+		nand_get_offset_adr(&block, &page, 1, rval);
+	}
+
+	if (pages > 0) {
+		rval = nand_read(block, page, pages, dst);
+		if (rval < 0)
+			return len;
+
+		dst += pages * flnand.main_size;
+		len += pages * flnand.main_size;
+		nand_get_offset_adr(&block, &page, pages, rval);
+	}
+
+	if (last_ppage_size > 0) {
+		rval = nand_read(block, page, 1, buffer);
+		if (rval < 0)
+			return len;
+
+		memcpy(dst, (void *) buffer, last_ppage_size);
+		len += last_ppage_size;
+	}
+
+	return len;
+}
+
+/**
+ * Program a page to NAND flash.
+ */
+int nand_prog_pages(u32 block, u32 page, u32 pages, u8 *main_buf, u8 *spare_buf)
+{
+	int i;
+	u32 status;
+	u32 addr;
+	u32 mlen = 0, slen = 0;
+	u32 nand_ctr_reg = 0;
+	u32 spare_buf_addr = 0;
+	u32 dma_burst_ctrl, fio_burst_ctrl;
+
+	/* check parameters */
+	if ((page < 0 || page >= flnand.pages_per_block)	||
+	    (pages <= 0 || pages > flnand.pages_per_block)	||
+	    ((page + pages) > flnand.pages_per_block)		||
+	    (main_buf == NULL)) {
+		putstr("ERR: parameter error in nand_prog_pages()");
+		return -1;
+	}
+
+	for (i = 0; i < pages; i++)
+		mlen += flnand.main_size;
+
+	/* Setup FIO DMA Control Register */
+	writel(FIO_DMACTR_REG, FIO_DMACTR_FL | FIO_DMACTR_TS4B);
+
+	clean_d_cache((void *) main_buf, mlen);
+
+	/* diable write protect */
+	//gpio_set(FL_WP);
+
+	/* Always enable ECC */
+	if (flnand.ecc_bits > 1) {
+		/* Don't set NAND_CTR_EC_MAIN, because we use BCH */
+		nand_ctr_reg = flnand.control | NAND_CTR_SE;
+
+		slen = pages * flnand.spare_size;
+
+		if (spare_buf == NULL) {
+			memset(dummy_buffer_bch, 0xff, slen);
+			spare_buf_addr = (uintptr_t)dummy_buffer_bch;
+			clean_d_cache((void *) dummy_buffer_bch, slen);
+		} else {
+			spare_buf_addr = (uintptr_t)spare_buf;
+			clean_d_cache((void *) spare_buf, slen);
+		}
+		nand_en_bch();
+
+		/* Setup Flash Control Register*/
+		writel(NAND_CTR_REG, nand_ctr_reg);
+		/* Clean Flash_IO_ecc_rpt_status Register */
+		writel(FIO_ECC_RPT_STA_REG, 0x0);
+	} else {
+		/* Setup Flash IO Control Register */
+		writel(FIO_CTR_REG, FIO_CTR_RS | FIO_CTR_XD);
+
+		/* Setup Flash Control Register */
+		writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE | NAND_CTR_EG_MAIN);
+	}
+
+	/* Setup main external DMA engine transfer */
+	writel(FDMA_CHAN_STA_REG, 0x0);
+	writel(FDMA_CHAN_SRC_REG, (uintptr_t)main_buf);
+	writel(FDMA_CHAN_DST_REG, (uintptr_t)FIO_FIFO_BASE);
+
+	dma_burst_ctrl = FDMA_NODC_MN_BURST_SIZE;
+	fio_burst_ctrl = FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B;
+
+	if ((flnand.ecc_bits > 1)) {
+		/* Setup spare external DMA engine transfer */
+		writel(FDMA_CHAN_SPR_STA_REG, 0x0);
+		writel(FDMA_CHAN_SPR_SRC_REG, spare_buf_addr);
+		writel(FDMA_CHAN_SPR_DST_REG, (uintptr_t)FIO_FIFO_BASE);
+		writel(FDMA_CHAN_SPR_CNT_REG, slen);
+
+		dma_burst_ctrl = FDMA_CHAN_CTR_BLK_512B | FDMA_CHAN_CTR_TS_8B;
+		fio_burst_ctrl = FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B;
+	}
+
+	writel(FDMA_CHAN_CTR_REG,
+	       FDMA_CHAN_CTR_EN		|
+	       FDMA_CHAN_CTR_RM		|
+	       FDMA_CHAN_CTR_NI		|
+	       dma_burst_ctrl	|
+	       mlen);
+
+	/* Write start address for memory target to */
+	/* FIO DMA Address Register. */
+	addr =  addr_from_block_page(block, page);
+	writel(FIO_DMAADR_REG, addr);
+
+	/* Setup the Flash IO DMA Control Register */
+	writel(FIO_DMACTR_REG,
+	       FIO_DMACTR_EN		|
+	       FIO_DMACTR_RM		|
+	       FIO_DMACTR_FL		|
+	       fio_burst_ctrl	|
+			(mlen + slen));
+
+	/* Wait for interrupt for NAND operation done and DMA done */
+	nand_wait_dma_done();
+	status = readl(FIO_DMASTA_REG);
+
+	writel(NAND_INT_REG, 0x0);
+	writel(FIO_DMASTA_REG, 0x0);
+	writel(FDMA_REG(DMA_INT_OFFSET), 0x0);
+	writel(FDMA_CHAN_STA_REG, 0);
+
+	/* Enable write protect */
+	//gpio_clr(FL_WP);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	if (flnand.ecc_bits > 1) {
+		status = readl(FIO_ECC_RPT_STA_REG);
+		if (status & FIO_ECC_RPT_FAIL) {
+				putstr("BCH corrected failed (0x");
+				puthex(status);
+				putstr(")!\n\r");
+		} else if (status & FIO_ECC_RPT_ERR) {
+			putstr("BCH code corrected (0x");
+			puthex(status);
+			putstr(")!\n\r");
+		}
+	}
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STA_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+int nand_prog_pages_noecc(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	int i;
+	u32 status;
+	u32 addr;
+	u32 mlen = 0, slen = 0;
+	u32 spare_buf_addr = 0;
+	u32 dma_burst_ctrl, fio_burst_ctrl;
+
+	/* check parameters */
+	if ((page < 0 || page >= flnand.pages_per_block)	||
+	    (pages <= 0 || pages > flnand.pages_per_block)	||
+	    ((page + pages) > flnand.pages_per_block)		||
+	    (buf == NULL)) {
+		putstr("ERR: parameter error in nand_prog_pages()");
+		return -1;
+	}
+
+	for (i = 0; i < pages; i++)
+		mlen += flnand.main_size;
+
+	/* Setup FIO DMA Control Register */
+	writel(FIO_DMACTR_REG, FIO_DMACTR_FL | FIO_DMACTR_TS4B);
+
+	clean_d_cache((void *)buf, mlen);
+
+	if (flnand.ecc_bits > 1) {
+		slen = pages * flnand.spare_size;
+
+		memset(dummy_buffer_bch, 0xff, slen);
+		spare_buf_addr = (uintptr_t)dummy_buffer_bch;
+		clean_d_cache((void *)dummy_buffer_bch, slen);
+
+		nand_dis_bch();
+
+		/* Clean Flash_IO_ecc_rpt_status Register */
+		writel(FIO_ECC_RPT_STA_REG, 0x0);
+	} else {
+		putstr("ERR: Not implemented for 1-bit ECC yet!\r\n");
+		return -1;
+	}
+
+	/* Setup Flash IO Control Register */
+	writel(FIO_CTR_REG, FIO_CTR_RS | FIO_CTR_XD);
+	/* Setup Flash Control Register */
+	writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE);
+
+	/* Setup main external DMA engine transfer */
+	writel(FDMA_CHAN_STA_REG, 0x0);
+	writel(FDMA_CHAN_SRC_REG, (uintptr_t)buf);
+	writel(FDMA_CHAN_DST_REG, (uintptr_t)FIO_FIFO_BASE);
+
+	dma_burst_ctrl = FDMA_NODC_MN_BURST_SIZE;
+	fio_burst_ctrl = FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B;
+
+	if ((flnand.ecc_bits > 1)) {
+		/* Setup spare external DMA engine transfer */
+		writel(FDMA_CHAN_SPR_STA_REG, 0x0);
+		writel(FDMA_CHAN_SPR_SRC_REG, spare_buf_addr);
+		writel(FDMA_CHAN_SPR_DST_REG, (uintptr_t)FIO_FIFO_BASE);
+		writel(FDMA_CHAN_SPR_CNT_REG, slen);
+
+		dma_burst_ctrl = FDMA_CHAN_CTR_BLK_512B | FDMA_CHAN_CTR_TS_8B;
+		fio_burst_ctrl = FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B;
+	}
+
+	writel(FDMA_CHAN_CTR_REG,
+	       FDMA_CHAN_CTR_EN		|
+	       FDMA_CHAN_CTR_RM		|
+	       FDMA_CHAN_CTR_NI		|
+	       dma_burst_ctrl	|
+	       mlen);
+
+	/* Write start address for memory target to */
+	/* FIO DMA Address Register. */
+	addr =  addr_from_block_page(block, page);
+	writel(FIO_DMAADR_REG, addr);
+
+	/* Setup the Flash IO DMA Control Register */
+	writel(FIO_DMACTR_REG,
+	       FIO_DMACTR_EN		|
+	       FIO_DMACTR_RM		|
+	       FIO_DMACTR_FL		|
+	       fio_burst_ctrl		|
+	       (mlen + slen));
+
+	/* Wait for interrupt for NAND operation done and DMA done */
+	nand_wait_dma_done();
+	status = readl(FIO_DMASTA_REG);
+
+	writel(NAND_INT_REG, 0x0);
+	writel(FIO_DMASTA_REG, 0x0);
+	writel(FDMA_REG(DMA_INT_OFFSET), 0x0);
+	writel(FDMA_CHAN_STA_REG, 0);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STA_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+/**
+ * Read spare area from NAND flash.
+ * Always disable ECC.
+ */
+int nand_read_spare(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	int i;
+	u32 status;
+	u32 addr, size = 0, mlen = 0;
+	u32 desc_burst_ctrl = 0, fio_burst_ctrl;
+
+	/* check parameters */
+	if ((page < 0 || page >= flnand.pages_per_block)	||
+	    (pages <= 0 || pages > flnand.pages_per_block)	||
+	    ((page + pages) > flnand.pages_per_block)		||
+	    (buf == NULL)) {
+		putstr("ERR: parameter error in nand_read_spare()");
+		return -1;
+	}
+
+	for (i = 0; i < pages; i++) {
+		mlen += flnand.main_size;
+		size += flnand.spare_size;
+	}
+
+	if (flnand.ecc_bits > 1) {
+		if (mlen > MAX_SPARE_SIZE_BLK) {
+			putstr("ERR: too many pages at one time\n");
+		}
+		/* Always disable ECC */
+		/* Setup DMA main descriptor */
+		G_fio_dmadesc.src_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dmadesc.dst_addr = (uintptr_t)dummy_buffer_bch;
+		G_fio_dmadesc.next= 0x0;
+		G_fio_dmadesc.rpt_addr = (uintptr_t)&G_fio_dmadesc.rpt;
+		G_fio_dmadesc.xfrcnt = mlen;
+
+		/* Setup DMA spare descriptor */
+		G_fio_dma_spr_desc.src_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dma_spr_desc.dst_addr = (uintptr_t)buf;
+		G_fio_dma_spr_desc.next= 0x0;
+		G_fio_dma_spr_desc.rpt_addr = (uintptr_t)&G_fio_dma_spr_desc.rpt;
+		G_fio_dma_spr_desc.xfrcnt = size;
+		G_fio_dma_spr_desc.rpt = 0x0;
+
+		desc_burst_ctrl = FDMA_DESC_MN_BURST_SIZE;
+		fio_burst_ctrl 	= FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B;
+	} else {
+		/* Setup DMA descriptor */
+		G_fio_dmadesc.src_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dmadesc.dst_addr = (uintptr_t)buf;
+		G_fio_dmadesc.next= 0x0;
+		G_fio_dmadesc.rpt_addr = (uintptr_t)&G_fio_dmadesc.rpt;
+		G_fio_dmadesc.xfrcnt = size;
+
+		desc_burst_ctrl = FDMA_DESC_SP_BURST_SIZE;
+		fio_burst_ctrl 	= FIO_DMACTR_BLK_16B | FIO_DMACTR_TS8B;
+		mlen = 0;
+	}
+
+	G_fio_dmadesc.ctrl =
+		FDMA_DESC_WM |
+		FDMA_DESC_EOC |
+		FDMA_DESC_NI |
+		FDMA_DESC_IE |
+		FDMA_DESC_ST |
+		desc_burst_ctrl;
+	G_fio_dmadesc.rpt = 0x0;
+
+	_clean_flush_d_cache();
+
+	if (flnand.ecc_bits > 1) {
+		nand_dis_bch();
+
+		/* Setup Flash IO Control Register */
+		writel(FIO_CTR_REG, FIO_CTR_RS | FIO_CTR_XD);
+		/* Setup Flash Control Register*/
+		writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE);
+		/* Clean Flash_IO_ecc_rpt_status Register */
+		writel(FIO_ECC_RPT_STA_REG, 0x0);
+	} else {
+		/* Setup Flash IO Control Register */
+		writel(FIO_CTR_REG, FIO_CTR_RS | FIO_CTR_XD);
+		/* Setup Flash Control Register */
+		writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE  | NAND_CTR_SA);
+	}
+
+	/* Setup external DMA engine transfer */
+	writel(FDMA_CHAN_DA_REG, (uintptr_t)&G_fio_dmadesc);
+	writel(FDMA_CHAN_STA_REG, 0x0);
+
+	if (flnand.ecc_bits > 1) {
+		/* Setup spare external DMA engine descriptor address */
+		writel(FDMA_CHAN_SPR_DA_REG, (uintptr_t)&G_fio_dma_spr_desc);
+		writel(FDMA_CHAN_SPR_STA_REG, 0);
+	}
+
+	writel(FDMA_CHAN_CTR_REG,   FDMA_CHAN_CTR_D |   FDMA_CHAN_CTR_EN);
+
+	/* Write start address for memory target to */
+	/* FIO DMA Address Register. */
+	addr = addr_from_block_page(block, page);
+	writel(FIO_DMAADR_REG, addr);
+
+	/* Setup the Flash IO DMA Control Register */
+	writel(FIO_DMACTR_REG,
+	       FIO_DMACTR_EN		|
+	       FIO_DMACTR_FL		|
+	       fio_burst_ctrl		|
+	       (mlen + size));
+
+	/* Wait for interrupt for NAND operation done and DMA done */
+	nand_wait_desc_dma_done();
+	status = readl(FIO_DMASTA_REG);
+
+	writel(NAND_INT_REG, 0x0);
+	writel(FIO_DMASTA_REG, 0x0);
+	writel(FDMA_REG(DMA_INT_OFFSET), 0x0);
+	writel(FDMA_CHAN_STA_REG, 0x0);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STA_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+/**
+ * Program spare area to NAND flash.
+ * Only for mark bad block, disable ECC.
+ */
+int nand_prog_spare(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	int i;
+	u32 status;
+	u32 addr, size = 0, mlen = 0;
+
+	/* check parameters */
+	if ((page < 0 || page >= flnand.pages_per_block)	||
+	    (pages <= 0 || pages > flnand.pages_per_block)	||
+	    ((page + pages) > flnand.pages_per_block)		||
+	    (buf == NULL)) {
+		putstr("ERR: parameter error in nand_prog_spare()");
+		return -1;
+	}
+
+	for (i = 0; i < pages; i++) {
+		mlen += flnand.main_size;
+		size += flnand.spare_size;
+	}
+
+	if (flnand.ecc_bits > 1) {
+		if (mlen > MAX_SPARE_SIZE_BLK) {
+			putstr("ERR: too many pages at one time\n");
+		} else {
+			memset(dummy_buffer_bch, 0xff, mlen);
+		}
+
+		/* Always disable ECC */
+		/* Setup DMA main descriptor */
+		G_fio_dmadesc.src_addr = (uintptr_t)dummy_buffer_bch;
+		G_fio_dmadesc.dst_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dmadesc.next= 0x0;
+		G_fio_dmadesc.rpt_addr = (uintptr_t)&G_fio_dmadesc.rpt;
+		G_fio_dmadesc.xfrcnt = mlen;
+
+		/* Setup DMA spare descriptor */
+		G_fio_dma_spr_desc.src_addr = (uintptr_t)buf;
+		G_fio_dma_spr_desc.dst_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dma_spr_desc.next= 0x0;
+		G_fio_dma_spr_desc.rpt_addr = (uintptr_t)&G_fio_dma_spr_desc.rpt;
+		G_fio_dma_spr_desc.xfrcnt = size;
+		G_fio_dma_spr_desc.rpt = 0x0;
+	} else {
+		/* Setup DMA descriptor */
+		G_fio_dmadesc.src_addr = (uintptr_t)buf;
+		G_fio_dmadesc.dst_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dmadesc.next= 0x0;
+		G_fio_dmadesc.rpt_addr = (uintptr_t)&G_fio_dmadesc.rpt;
+		G_fio_dmadesc.xfrcnt = size;
+		mlen = 0;
+	}
+
+	G_fio_dmadesc.ctrl =
+		FDMA_DESC_RM	|
+		FDMA_DESC_EOC	|
+		FDMA_DESC_NI	|
+		FDMA_DESC_IE	|
+		FDMA_DESC_ST	|
+		FDMA_DESC_SP_BURST_SIZE;
+	G_fio_dmadesc.rpt = 0x0;
+
+	_clean_d_cache();
+
+	/* Diable write protect */
+	//gpio_set(FL_WP);
+
+	if (flnand.ecc_bits > 1) {
+		nand_dis_bch();
+
+		/* Setup Flash IO Control Register */
+		writel(FIO_CTR_REG, FIO_CTR_RS);
+		/* Setup Flash Control Register*/
+		writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE);
+		/* Clean Flash_IO_ecc_rpt_status Register */
+		writel(FIO_ECC_RPT_STA_REG, 0x0);
+	} else {
+		/* Setup Flash IO Control Register */
+		writel(FIO_CTR_REG, FIO_CTR_RS);
+		/* Setup Flash Control Register */
+		writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE  | NAND_CTR_SA);
+	}
+
+	/* Setup main external DMA engine descriptor address */
+	writel(FDMA_CHAN_DA_REG, (uintptr_t)&G_fio_dmadesc);
+	writel(FDMA_CHAN_STA_REG, 0);
+
+	if (flnand.ecc_bits > 1) {
+		writel(FDMA_CHAN_SPR_STA_REG, 0);
+		/* Setup spare external DMA engine descriptor address */
+		writel(FDMA_CHAN_SPR_DA_REG, (uintptr_t)&G_fio_dma_spr_desc);
+	}
+	writel(FDMA_CHAN_CTR_REG,   FDMA_CHAN_CTR_D |   FDMA_CHAN_CTR_EN);
+
+	/* Write start address for memory target to */
+	/* FIO DMA Address Register. */
+	addr =  addr_from_block_page(block, page);
+	writel(FIO_DMAADR_REG, addr);
+
+	/* Setup the Flash IO DMA Control Register */
+	writel(FIO_DMACTR_REG,
+	       FIO_DMACTR_EN		|
+	       FIO_DMACTR_RM		|
+	       FIO_DMACTR_FL		|
+	       FIO_DMACTR_BLK_16B |
+	       FIO_DMACTR_TS8B	|
+	       (mlen + size));
+
+	/* Wait for interrupt for NAND operation done and DMA done */
+	nand_wait_desc_dma_done();
+	status = readl(FIO_DMASTA_REG);
+
+	writel(NAND_INT_REG, 0x0);
+	writel(FIO_DMASTA_REG, 0x0);
+	writel(FDMA_REG(DMA_INT_OFFSET), 0x0);
+	writel(FDMA_CHAN_STA_REG, 0x0);
+
+	/* Enable write protect */
+	//gpio_clr(FL_WP);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STA_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+/**
+ * Erase a NAND flash block.
+ */
+int nand_erase_block(u32 block)
+{
+	u32 status;
+	u32 addr;
+
+#if defined(DEBUG)
+	putstr("nand_erase_block( ");
+	putdec(block);
+	putstr(" )\r\n");
+#endif
+
+	/* Disable write protect */
+	//gpio_set(FL_WP);
+
+	/* Setup FIO DMA Control Register */
+	writel(FIO_DMACTR_REG, FIO_DMACTR_FL | FIO_DMACTR_TS4B);
+
+	/* Setup Flash IO Control Register */
+	writel(FIO_CTR_REG, FIO_CTR_XD);
+
+	/* Setup Flash Control Register */
+	writel(NAND_CTR_REG, flnand.control);
+
+	/* Erase block */
+	addr = addr_from_block_page(block, 0);
+
+	/* Workround for DSM bug!*/
+	writel(FIO_DMAADR_REG, addr);
+
+	writel(NAND_INT_REG, 0x0);
+	nand_wait_cmd_done(NAND_CMD_ERASE | addr);
+
+	status = readl(FIO_DMASTA_REG);
+	writel(FIO_DMASTA_REG, 0x0);
+
+	/* Enable write protect */
+	//gpio_clr(FL_WP);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STA_REG);
+
+	if ((status & 0x1)) {
+		/* Reset chip */
+		nand_wait_cmd_done(NAND_CMD_RESET);
+		return -1;
+	} else {
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+		/* If erase success and block is marked as bad in BBT */
+		/* then update BBT. */
+		if (nand_is_bad_block(block))
+			nand_update_bbt(0, block);
+#endif
+		return 0;
+	}
+}
+
diff --git a/pandora/pandora.h b/pandora/pandora.h
new file mode 100644
index 0000000..e4d65ca
--- /dev/null
+++ b/pandora/pandora.h
@@ -0,0 +1,119 @@
+/**
+ * pandora/pandora.h
+ *
+ * 2017-03-06	Create file by Jorney
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __OSPLUS__
+#define __OSPLUS__
+
+#ifdef CONFIG_PANDORA_RTOS
+
+#define	HZ							1000
+#define OS_ERR						-1
+#define TSKIDLE_PRIORITY			0
+#define DEFAULT_THREAD_STACK_SIZE	0x8000
+
+static inline void local_irq_disable(void)
+{
+#if defined(__aarch64__)
+	__asm__ volatile("msr daifset, #3");
+#else
+	__asm__ volatile("cpsid i");
+	__asm__ volatile("dsb");
+	__asm__ volatile("isb");
+#endif
+}
+
+static inline void local_irq_enable(void)
+{
+#if defined(__aarch64__)
+	__asm__ volatile("msr daifclr, #3");
+#else
+	__asm__ volatile("cpsie i");
+	__asm__ volatile("dsb");
+	__asm__ volatile("isb");
+#endif
+}
+
+struct pandora_task {
+	unsigned long offset;
+	unsigned long stack;
+	int prior;
+	int block;
+	char freeze;
+	char name[32];
+	void *parameter;
+	void *entry;
+	struct pandora_task *next;
+	unsigned long timeout;
+};
+
+struct pandora_completion {
+	unsigned long done;
+	void *owner;
+};
+
+typedef	unsigned long pandora_mutex_t;
+typedef	struct pandora_completion completion_t;
+
+
+void timer_init(void);
+void schedule_disable(void);
+
+void pandora_schedule_start(void);
+int pandora_thread_init(void);
+int pandora_thread_create(const char *name, int prior,
+		void *call, void *arg);
+void local_irq_disable(void);
+void local_irq_enable(void);
+void cpu_relax(void);
+void yield(void);
+void mutex_init(pandora_mutex_t *mutex);
+void mutex_lock(pandora_mutex_t *mutex);
+void mutex_unlock(pandora_mutex_t *mutex);
+
+void __pandora_sche_start(void);
+void __mutex_atomic_clr(void *);
+void __mutex_atomic_set(void *);
+
+void init_completion(completion_t *event);
+void complete(completion_t *event);
+void complete_isr(completion_t *event);
+int wait_for_completion_timeout(completion_t *event, unsigned int msc);
+void wait_for_completion(completion_t *x);
+int pandora_thread_freeze(const char *name);
+void pandora_fingerprint(void);
+
+unsigned long pandora_initialise_stack(struct pandora_task *t);
+void arm_cpu_relax(void);
+void timer_irq_disable(void);
+
+extern volatile struct pandora_task *current_task;
+#endif
+#endif
diff --git a/pandora/schedule.c b/pandora/schedule.c
new file mode 100644
index 0000000..b9a455a
--- /dev/null
+++ b/pandora/schedule.c
@@ -0,0 +1,395 @@
+/**
+ * pandora/schedule.c
+ *
+ * Copyright (c) 2020 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+#include <irq.h>
+#include <bldfunc.h>
+#include <ambhw/gpio.h>
+#include <ambhw/timer.h>
+#include <pandora.h>
+
+unsigned long long jiffies = 0;
+
+volatile struct pandora_task *current_task = NULL;
+volatile struct pandora_task *highest_priority_task = NULL;
+volatile int pandorayield = 0;
+
+void mutex_init(pandora_mutex_t *mutex)
+{
+	__mutex_atomic_clr(mutex);
+}
+void mutex_lock(pandora_mutex_t *mutex)
+{
+	__mutex_atomic_set(mutex);
+}
+void mutex_unlock(pandora_mutex_t *mutex)
+{
+	__mutex_atomic_clr(mutex);
+	cpu_relax();
+}
+void init_completion(completion_t *x)
+{
+	x->owner = NULL;
+	x->done = 0;
+}
+void complete_isr(completion_t *x)
+{
+	highest_priority_task = (struct pandora_task *)x->owner;
+	x->owner = NULL;
+	x->done = 1;
+	yield();
+}
+void complete(completion_t *x)
+{
+	highest_priority_task = (struct pandora_task *)x->owner;
+	x->owner = NULL;
+	x->done = 1;
+}
+
+void wait_for_completion(completion_t *x)
+{
+	struct pandora_task *task;
+
+	local_irq_disable();
+
+	task = (struct pandora_task *)current_task;
+	x->owner = (void *)task;
+	task->timeout = ~0;
+	task->block = 1;
+
+	local_irq_enable();
+
+	if (!x->done) {
+		do {
+			/* generate a software interrupt to relax cpu */
+			cpu_relax();
+		} while(!x->done);
+	}
+
+	local_irq_disable();
+
+	x->done = 0;
+	task->block = 0;
+
+	local_irq_enable();
+}
+/**
+ * wait_for_completion_timeout - wait event with timeout.
+ * @ x: wait event.
+ * @ msec: timeout to return after waitting envent.
+ * @ return: 0 - timeout return, > 0 - woke up by event.
+ *
+ * Setting timeout as 0 will block the task without timeout.
+ */
+int wait_for_completion_timeout(completion_t *x, unsigned int msec)
+{
+
+	unsigned int tmo;
+	struct pandora_task *task;
+
+	local_irq_disable();
+
+	task = (struct pandora_task *)current_task;
+	x->owner = (void *)task;
+	if (msec) {
+		task->timeout = jiffies + msec;
+		tmo = 0;
+	} else {
+		task->timeout = ~0;
+		tmo = 1;
+	}
+
+	task->block = 1;
+
+	local_irq_enable();
+
+	if (!x->done) {
+		do {
+			/* generate a software interrupt to relax cpu */
+			cpu_relax();
+			tmo = (task->timeout > jiffies ? 1 : 0);
+		} while((!x->done) && tmo);
+	} else {
+		tmo = 1;
+	}
+
+	local_irq_disable();
+
+	x->done = 0;
+	task->block = 0;
+
+	local_irq_enable();
+
+	return tmo;
+}
+static struct pandora_task *pandora_task_alloc(const char *name, int prior, void *func, void *arg)
+{
+	struct pandora_task *new;
+	void *stack_top;
+
+	new = (struct pandora_task *)malloc(sizeof(struct pandora_task));
+	if (!new) {
+		printf("%s %d\n", __func__,__LINE__);
+		goto pandora_task_alloc_exit;
+	}
+
+	memset(new, 0, sizeof(struct pandora_task));
+
+	new->prior = prior;
+	new->parameter = arg;
+	new->entry = func;
+	new->next = new;
+	new->freeze = 0;
+	new->block = 0;
+	new->timeout = ~0;
+	strcpy(new->name, name);
+
+	stack_top = malloc(DEFAULT_THREAD_STACK_SIZE);
+	if (!stack_top) {
+		printf("%s %d\n", __func__,__LINE__);
+		goto pandora_task_alloc_stack_err;
+	}
+	/* Stack end address being 8 alignment */
+	new->stack = ((unsigned long)stack_top +
+				DEFAULT_THREAD_STACK_SIZE - 1) & (~0xf);
+
+	new->offset = pandora_initialise_stack(new);
+#if 0
+	printf("[%08x]task: %s prior: %d stack: %08x entry: %08x next: %08x\n",
+			new, new->name, new->prior, new->stack, new->entry, new->next);
+#endif
+
+	return new;
+
+pandora_task_alloc_stack_err:
+	free(new);
+pandora_task_alloc_exit:
+	return NULL;
+
+}
+static int task_insert(struct pandora_task *new)
+{
+	struct pandora_task *tmp = current_task->next;
+	current_task->next = new;
+	new->next = tmp;
+
+	return 0;
+}
+int pandora_thread_freeze(const char *name)
+{
+	struct pandora_task *t;
+
+	local_irq_disable();
+	if (!name) {
+		current_task->freeze = 1;
+	} else {
+		t = current_task->next;
+		while (t != current_task) {
+			if (!memcmp(name, t->name, strlen(name))) {
+				t->freeze = 1;
+				break;
+			}
+		}
+
+		if (t == current_task) {
+			printf("%s %d NOT FOUND!\n", __func__,__LINE__);
+		}
+	}
+	local_irq_enable();
+	return 0;
+}
+
+int pandora_thread_create(const char *name, int prior, void *call, void *arg)
+{
+	struct pandora_task *task;
+	int ret = 0;
+
+	if (prior <= 0) {
+		printf("%s %d\n", __func__,__LINE__);
+		return OS_ERR;
+	}
+
+	local_irq_disable();
+
+	task = pandora_task_alloc(name, prior, call, arg);
+	if (!task) {
+		printf("%s %d\n", __func__,__LINE__);
+		ret = OS_ERR;
+		goto pandora_thread_create_err;
+	}
+
+	task_insert(task);
+
+pandora_thread_create_err:
+	local_irq_enable();
+	return ret;
+}
+static void pandora_idle(void *arg)
+{
+	/* FIXME: all other tasks can be scheduled after idle task is
+	 * in the process. Or the timer tick is ignored */
+	for (;;) {
+	}
+}
+
+int pandora_thread_init(void)
+{
+	struct pandora_task *task;
+	int ret = 0;
+
+	local_irq_disable();
+
+	task = pandora_task_alloc("idle", TSKIDLE_PRIORITY , pandora_idle, NULL);
+	if (!task) {
+		printf("%s %d\n", __func__,__LINE__);
+		ret = OS_ERR;
+		goto pandora_thread_init_err;
+	}
+
+	current_task = task;
+
+pandora_thread_init_err:
+	local_irq_enable();
+	return ret;
+}
+void pandora_schedule_start(void)
+{
+	/* FIXME: the first task is idle, which has the lowest priority.
+	 * Switching the higher task at the next timer tick, if the higher
+	 * task is ready */
+
+	BUG_ON(!current_task);
+
+	/* the first task should be scheduled in 1HZ. */
+	timer_init();
+	__pandora_sche_start();
+
+}
+static struct pandora_task *pandora_task_pick(int prior)
+{
+	struct pandora_task *p = current_task->next;
+
+	while (p != current_task) {
+
+		if ((p->prior < prior) || (p->freeze)) {
+			p = p->next;
+			continue;
+		}
+		current_task = p;
+		return p;
+	}
+	return NULL;
+}
+
+static struct pandora_task *pandora_task_pick_lower(int prior)
+{
+	int i;
+	struct pandora_task *p = current_task->next;
+
+	for (i = prior - 1; i > TSKIDLE_PRIORITY; i--)
+	{
+		while (p != current_task) {
+
+			if ((p->prior < i)
+					|| (p->freeze)
+					|| (p->prior == TSKIDLE_PRIORITY)) {
+				p = p->next;
+				continue;
+			}
+			current_task = p;
+			return p;
+		}
+	}
+	return NULL;
+}
+void pandora_task_switch(void)
+{
+	struct pandora_task *p = NULL;
+	int prior = current_task->prior;
+
+	if (!current_task)
+		return ;
+
+	/* Wake up the blocked task . highest_priority_task is token when wake_up
+	 * or wake_up_from_isr */
+	if (highest_priority_task){
+		current_task = highest_priority_task;
+		highest_priority_task = NULL;
+		goto __switch_return;
+	}
+	p = pandora_task_pick(prior);
+
+	/* if it can't pick a task which has higher or equal priority,
+	 * and the current task is blocked, then the lower priority tasks
+	 * have the chance to be scheduled */
+	if (!p && (current_task->block || current_task->freeze)) {
+		pandora_task_pick_lower(prior);
+	}
+
+__switch_return:
+	return ;
+}
+
+void cpu_relax(void)
+{
+	arm_cpu_relax();
+}
+void schedule_disable(void)
+{
+	timer_irq_disable();
+}
+void yield(void)
+{
+	pandorayield = 1;
+}
+
+static void timer8_handler(void *data)
+{
+	jiffies++;
+	yield();
+}
+
+void timer_irq_disable(void)
+{
+	irq_disable(TIMER8_IRQ);
+}
+
+void timer_init(void)
+{
+	int tick = get_apb_bus_freq_hz() / HZ;
+
+	writel(TIMER8_STATUS_REG, tick);
+	writel(TIMER8_RELOAD_REG, tick);
+	writel(TIMER8_MATCH1_REG, 0x00000000);
+	writel(TIMER8_MATCH2_REG, 0x00000000);
+	setbitsl(TIMER_CTR_REG, 0x5 << 28);
+
+	request_irq(TIMER8_IRQ, IRQ_RISING_EDGE, timer8_handler, NULL);
+}
+
diff --git a/src/bld/arm/armcache.S b/src/bld/arm/armcache.S
new file mode 100644
index 0000000..8ae5396
--- /dev/null
+++ b/src/bld/arm/armcache.S
@@ -0,0 +1,120 @@
+/**
+ * bld/armcache.S
+ *
+ * History:
+ *    2005/08/15 - [Charles Chiou] created file by consolidating the
+ *			old files icache.c and dcache.c
+ *    2014/02/13 - [Anthony Ginger] Amboot V2
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+.globl	_enable_icache
+_enable_icache:
+	mrc	p15, 0, r0, c1, c0, 0
+	orr	r0, r0, #0x1000
+	mcr	p15, 0, r0, c1, c0, 0
+	mov	pc, lr
+	nop
+	nop
+
+.globl	_disable_icache
+_disable_icache:
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x1000
+	mcr	p15, 0, r0, c1, c0, 0
+	mov	pc, lr
+	nop
+	nop
+
+.globl	_flush_i_cache
+_flush_i_cache:
+	mov	r0, #0x0
+	mcr	p15, 0, r0, c7, c5, 0
+	mov	pc, lr
+	nop
+	nop
+
+.globl	_enable_dcache
+_enable_dcache:
+	mrc	p15, 0, r0, c1, c0, 0
+	orr	r0, r0, #0xc
+	mcr	p15, 0, r0, c1, c0, 0
+	mov	pc, lr
+	nop
+	nop
+
+.globl	_drain_write_buffer
+_drain_write_buffer:
+	mov	r0, #0x0
+	mcr	p15, 0, r0, c7, c10, 4
+	mov	pc, lr
+
+#include <macro.S>
+
+.globl	_disable_dcache
+_disable_dcache:
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x4
+	mcr	p15, 0, r0, c1, c0, 0
+	mov	pc, lr
+	nop
+	nop
+
+.globl	_flush_d_cache
+_flush_d_cache:
+	stmfd	sp!, {r0-r4, lr}
+	invalidate_all_cache r0, r1, r2, r3, r4
+	ldmfd	sp!, {r0-r4, lr}
+	mov	pc, lr
+
+
+.globl	_clean_d_cache
+_clean_d_cache:
+	stmfd	sp!, {r0-r4, lr}
+	clean_all_cache r0, r1, r2, r3, r4
+	ldmfd	sp!, {r0-r4, lr}
+	mov	pc, lr
+
+.globl	_clean_flush_d_cache
+_clean_flush_d_cache:
+	stmfd	sp!, {r0-r4, lr}
+	invcln_all_cache r0, r1, r2, r3, r4
+	ldmfd	sp!, {r0-r4, lr}
+	mov	pc, lr
+
+.globl	_clean_flush_all_cache
+_clean_flush_all_cache:
+	stmfd	sp!, {r0-r4, lr}
+	invcln_all_cache r0, r1, r2, r3, r4
+	mov	r0, #0x0
+	mcr	p15, 0, r0, c7, c5, 6		/* Invalidate entire branch prediction array */
+	mcr	p15, 0, r0, c7, c5, 0		/* Invalidate entire icache */
+	ldmfd	sp!, {r0-r4, lr}
+	mov	pc, lr
+	nop
+	nop
+
diff --git a/src/bld/arm/bld.lds.cpp b/src/bld/arm/bld.lds.cpp
new file mode 100644
index 0000000..f90abf2
--- /dev/null
+++ b/src/bld/arm/bld.lds.cpp
@@ -0,0 +1,156 @@
+/**
+ * bld/bld.lds.cpp
+ *
+ * History:
+ *    2005/01/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(bld_start)
+SECTIONS
+{
+	. = AMBOOT_BLD_RAM_START;
+
+	.text : {
+		trampoline*.o (.text)
+
+		* (.text*)
+		* (.rodata*)
+
+		. = ALIGN(4);
+		__cmdlist_start = .;
+		* (.cmdlist)
+		__cmdlist_end = .;
+	}
+
+	. = ALIGN(4);
+	.data : {
+		__nanddb_start = .;
+		* (.nanddb)
+		__nanddb_end = .;
+
+		. = ALIGN(4);
+		* (.data*)
+	}
+
+	. = ALIGN(4);
+	.bss : {
+		__bss_start = .;
+
+		* (.bss)
+
+		__bss_end = .;
+
+		. = ALIGN(4);
+		/* Stack for UND mode */
+		__und_stack_start = .;
+		. = __und_stack_start + 0x100;
+		__und_stack_end = .;
+
+		/* Stack for ABT mode */
+		__abt_stack_start = .;
+		. = __abt_stack_start + 0x100;
+		__abt_stack_end = .;
+
+		/* Stack for IRQ mode */
+		__irq_stack_start = .;
+		. = __irq_stack_start + 0x2000;
+		__irq_stack_end = .;
+
+		/* Stack for FIQ mode */
+		__fiq_stack_start = .;
+		. = __fiq_stack_start + 0x100;
+		__fiq_stack_end = .;
+
+		/* Stack for SVC mode */
+		__svc_stack_start = .;
+		. = __svc_stack_start + 0x100;
+		__svc_stack_end = .;
+
+		/* Stack for SYS mode */
+		__sys_stack_start = .;
+		. = __sys_stack_start + AMBOOT_BLD_STACK_SIZE;
+		__sys_stack_end = .;
+
+		/* Heap for BLD */
+		__heap_start = .;
+		. = __heap_start +  AMBOOT_BLD_HEAP_SIZE;
+		__heap_end = .;
+	}
+
+	. = ALIGN(4);
+	.bss.noinit : {
+		* (.bss.noinit*)
+	}
+
+	. = ALIGN(0x4000);
+	.pagetable (NOLOAD) : {
+		/* MMU page table */
+		__pagetable_main = .;
+		. = __pagetable_main + (4096 * 4);	/* 16 KB of L1 */
+		__pagetable_hv = .;
+		. = __pagetable_hv + (256 * 4);		/* 1KB of L2 */
+		__pagetable_cry = .;
+		. = __pagetable_cry + (256 * 4);
+		__pagetable_end = .;
+	}
+
+	. = ALIGN(0x400);						/* must be 1024B align */
+	.bldbuf . (NOLOAD) : {
+		bld_buf_addr = .;
+		. = bld_buf_addr + (384 * SIZE_1KB);
+		bld_buf_end = .;
+	}
+
+	. = ASSERT((. <= AMBOOT_BLD_RAM_START + AMBOOT_BLD_RAM_MAX_SIZE),
+		"We limit BLD size to avoid across DSP region, Check Point!");
+
+	. = (AMBOOT_BLD_RAM_START + SIZE_1MB);
+	.splashbuf . (NOLOAD) : {
+		splash_buf_addr = .;
+		. = splash_buf_addr + (1 * SIZE_1MB);
+		splash_buf_end = .;
+	}
+
+	/* In most case, it is DSP space and assume DRAM_SIZE >= 128MB */
+	/* bld_hugebuf_addr will be used in:
+	   1. amboot command
+	   2. usd download
+	   3. memfwprog
+	   only */
+	. = (DRAM_START_ADDR + DRAM_SIZE - (64 * SIZE_1MB));
+	.hugebuf . (NOLOAD) : {
+		. = ALIGN(0x100000);
+		bld_hugebuf_addr = .;
+		. = bld_hugebuf_addr + (48 * SIZE_1MB);
+	}
+}
+
diff --git a/src/bld/arm/cache.c b/src/bld/arm/cache.c
new file mode 100644
index 0000000..cc43006
--- /dev/null
+++ b/src/bld/arm/cache.c
@@ -0,0 +1,202 @@
+/**
+ * system/src/comsvc/cache.c
+ *
+ * History:
+ *    2005/05/26 - [Charles Chiou] created file
+ *    2005/08/29 - [Chien-Yang Chien] assumed maintenance of this module
+ *    2014/02/13 - [Anthony Ginger] Amboot V2
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+#include <ambhw/cache.h>
+
+#define ENABLE_DRAIN_WRITE_BUF
+
+/*===========================================================================*/
+void flush_all_cache_region(void *addr, unsigned int size)
+{
+	u32 addr_start;
+
+	BUG_ON(((u32) addr) & ((0x1 << CLINE) - 1));
+	BUG_ON(size & ((0x1 << CLINE) - 1));
+
+	addr_start = (u32) addr;
+	size = size >> CLINE;
+
+	while ((int) size > 0) {
+		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c5, 1" :
+				      "=r " (addr_start));
+		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c6, 1" :
+				      "=r " (addr_start));
+		addr_start += (0x1 << CLINE);
+		size--;
+	}
+}
+
+void clean_flush_all_cache_region(void *addr, unsigned int size)
+{
+	u32 addr_start, addr_end;
+	u32 misalign;
+
+	addr_start = ((u32) addr) & ~((0x1 << CLINE) - 1);
+	addr_end = ((u32) addr + size) & ~((0x1 << CLINE) - 1);
+
+	misalign = ((u32) addr + size) & ((0x1 << CLINE) - 1);
+	if (misalign)
+		addr_end += (0x1 << CLINE);
+
+	size = (addr_end - addr_start) >> CLINE;
+
+	do {
+		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c14, 1" : :
+				      "r" (addr_start));
+		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c5, 1" : :
+				      "r" (addr_start));
+		addr_start += (0x1 << CLINE);
+		size--;
+	} while ((int) size > 0);
+}
+
+void flush_i_cache_region(void *addr, unsigned int size)
+{
+	u32 addr_start;
+
+	BUG_ON(((u32) addr) & ((0x1 << CLINE) - 1));
+	BUG_ON(size & ((0x1 << CLINE) - 1));
+
+	addr_start = (u32) addr;
+	size = size >> CLINE;
+
+	while ((int) size > 0) {
+		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c5, 1" : :
+				      "r" (addr_start));
+		addr_start += (0x1 << CLINE);
+		size--;
+	}
+}
+
+void flush_d_cache_region(void *addr, unsigned int size)
+{
+	u32 addr_start;
+
+	BUG_ON(((u32) addr) & ((0x1 << CLINE) - 1));
+	BUG_ON(size & ((0x1 << CLINE) - 1));
+
+	addr_start = (u32) addr;
+	size = size >> CLINE;
+
+	while ((int) size > 0) {
+		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c6, 1" : :
+				      "r" (addr_start));
+		addr_start += (0x1 << CLINE);
+		size--;
+	}
+}
+
+void clean_d_cache_region(void *addr, unsigned int size)
+{
+	u32 addr_start, addr_end;
+	u32 misalign;
+
+	addr_start = ((u32) addr) & ~((0x1 << CLINE) - 1);
+	addr_end = ((u32) addr + size) & ~((0x1 << CLINE) - 1);
+
+	misalign = ((u32) addr + size) & ((0x1 << CLINE) - 1);
+	if (misalign)
+		addr_end += (0x1 << CLINE);
+
+	size = (addr_end - addr_start) >> CLINE;
+
+	do {
+		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 1" : :
+				      "r" (addr_start));
+		addr_start += (0x1 << CLINE);
+		size--;
+	} while ((int) size > 0);
+}
+
+void clean_flush_d_cache_region(void *addr, unsigned int size)
+{
+	u32 addr_start, addr_end;
+	u32 misalign;
+
+	addr_start = ((u32) addr) & ~((0x1 << CLINE) - 1);
+	addr_end = ((u32) addr + size) & ~((0x1 << CLINE) - 1);
+
+	misalign = ((u32) addr + size) & ((0x1 << CLINE) - 1);
+	if (misalign)
+		addr_end += (0x1 << CLINE);
+
+	size = (addr_end - addr_start) >> CLINE;
+
+	do {
+		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c14, 1" : :
+				      "r" (addr_start));
+		addr_start += (0x1 << CLINE);
+		size--;
+	} while ((int) size > 0);
+}
+
+void drain_write_buffer(u32 addr)
+{
+	addr = addr & ~((0x1 << CLINE) - 1);
+
+	__asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr));
+}
+
+void clean_d_cache(void *addr, unsigned int size)
+{
+	if (size >= (0x1 << CSIZE) * NCSIZE) {
+		_clean_d_cache();
+	} else {
+		clean_d_cache_region(addr, size);
+	}
+
+#if defined(ENABLE_DRAIN_WRITE_BUF)
+	drain_write_buffer((u32)addr);
+#endif
+}
+
+void flush_d_cache(void *addr, unsigned int size)
+{
+	flush_d_cache_region(addr, size);
+}
+
+void clean_flush_d_cache(void *addr, unsigned int size)
+{
+	if (size >= (0x1 << CSIZE) * NCSIZE) {
+		_clean_flush_d_cache();
+	} else {
+		clean_flush_d_cache_region(addr, size);
+	}
+
+#if defined(ENABLE_DRAIN_WRITE_BUF)
+	drain_write_buffer((u32)addr);
+#endif
+}
+
diff --git a/src/bld/arm/div64.S b/src/bld/arm/div64.S
new file mode 100644
index 0000000..b4ed2d3
--- /dev/null
+++ b/src/bld/arm/div64.S
@@ -0,0 +1,298 @@
+ /*
+ * History:
+ *	2016/12/30 - [JianTang] Created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+.global __aeabi_ldivmod
+__aeabi_ldivmod:
+ 	cmp		r3, #0
+ 	cmpeq	r2, #0
+ 	bne		L0
+ 	cmp		r1, #0
+ 	cmpeq	r0, #0
+ 	movlt	r1, #-2147483648
+ 	movlt	r0, #0
+ 	mvngt	r1, #-2147483648
+ 	mvngt	r0, #0
+ 	b		__aeabi_idiv0
+L0:
+ 	sub		sp, sp, #8
+ 	push	{sp, lr}
+ 	bl		__gnu_ldivmod_helper
+ 	ldr		lr, [sp, #4]
+ 	add		sp, sp, #8
+ 	pop		{r2, r3}
+ 	bx		lr
+
+
+.global __aeabi_uldivmod
+__aeabi_uldivmod:
+ 	cmp		r3, #0
+ 	cmpeq	r2, #0
+ 	bne		L1
+ 	cmp		r1, #0
+ 	cmpeq	r0, #0
+ 	mvnne	r1, #0
+ 	mvnne	r0, #0
+ 	b		__aeabi_idiv0
+L1:
+ 	sub		sp, sp, #8
+ 	push	{sp, lr}
+ 	bl		__gnu_uldivmod_helper
+ 	ldr		lr, [sp, #4]
+ 	add		sp, sp, #8
+ 	pop		{r2, r3}
+ 	bx		lr
+
+__aeabi_idiv0:
+ 	push	{r1, lr}
+ 	mov		r0, #8
+ 	b		.
+ 	pop		{r1, pc}
+
+__gnu_ldivmod_helper:
+ 	push	{r4, r5, r6, r7, r8, lr}
+ 	mov		r8, r2
+ 	mov		r4, r0
+ 	mov		r5, r1
+ 	mov		r6, r3
+ 	ldr		r7, [sp, #24]
+ 	bl		__divdi3
+ 	mul		lr, r8, r1
+ 	umull	r2, r3, r8, r0
+ 	mla		r6, r0, r6, lr
+ 	subs	r2, r4, r2
+ 	add		r3, r6, r3
+ 	sbc		r3, r5, r3
+ 	strd	r2, [r7]
+ 	pop		{r4, r5, r6, r7, r8, pc}
+
+__gnu_uldivmod_helper:
+ 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
+ 	mov		r5, r3
+ 	mov		r6, r2
+ 	mov		r8, r0
+ 	mov		r9, r1
+ 	ldr		r7, [sp, #32]
+ 	bl		__udivdi3
+ 	mul		r3, r0, r5
+ 	umull	r4, r5, r0, r6
+ 	mla		r6, r6, r1, r3
+ 	subs	r4, r8, r4
+ 	add		r5, r6, r5
+ 	sbc		r5, r9, r5
+ 	strd	r4, [r7]
+ 	pop		{r4, r5, r6, r7, r8, r9, sl, pc}
+
+__divdi3:
+ 	cmp		r1, #0
+ 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
+ 	movge	ip, #0
+ 	blt		L10
+L2:
+ 	cmp		r3, #0
+ 	movge	r8, r2
+ 	movge	r9, r3
+ 	blt		L9
+L3:
+ 	cmp		r1, r9
+ 	mov		r4, r0
+ 	cmpeq	r0, r8
+ 	mov		r5, r1
+ 	movcc	r8, #0
+ 	movcc	r9, #0
+ 	bcc		L8
+ 	cmp		r9, #0
+ 	clzeq	r3, r8
+ 	clzne	r2, r9
+ 	addeq	r2, r3, #32
+ 	cmp		r1, #0
+ 	clzeq	r3, r0
+ 	clzne	r3, r1
+ 	addeq	r3, r3, #32
+ 	rsb		r3, r3, r2
+ 	lsl		r7, r9, r3
+ 	sub		sl, r3, #32
+ 	rsb		lr, r3, #32
+ 	lsl		r6, r8, r3
+ 	orr		r7, r7, r8, lsl sl
+ 	mov		r2, r3
+ 	orr		r7, r7, r8, lsr lr
+ 	cmp		r1, r7
+ 	cmpeq	r0, r6
+ 	movcc	r8, #0
+ 	movcc	r9, #0
+ 	bcc		L4
+ 	mov		fp, #1
+ 	subs	r0, r0, r6
+ 	lsl		r9, fp, sl
+ 	sbc		r1, r1, r7
+ 	lsl		r8, fp, r3
+ 	mov		r4, r0
+ 	orr		r9, r9, fp, lsr lr
+ 	mov		r5, r1
+L4:
+ 	cmp		r3, #0
+ 	beq		L8
+ 	lsrs	r7, r7, #1
+ 	rrx		r6, r6
+ 	b		L6
+L5:
+ 	subs	r4, r4, r6
+ 	sbc		r5, r5, r7
+ 	adds	r4, r4, r4
+ 	adc		r5, r5, r5
+ 	adds	r4, r4, #1
+ 	adc		r5, r5, #0
+ 	subs	r3, r3, #1
+ 	beq		L7
+L6:
+ 	cmp		r7, r5
+ 	cmpeq	r6, r4
+ 	bls		L5
+ 	adds	r4, r4, r4
+ 	adc		r5, r5, r5
+ 	subs	r3, r3, #1
+ 	bne		L6
+L7:
+ 	lsr		r3, r4, r2
+ 	rsb		r1, r2, #32
+ 	lsr		lr, r5, r2
+ 	sub		r0, r2, #32
+ 	orr		r3, r3, r5, lsl r1
+ 	adds	r8, r8, r4
+ 	lsl		r7, lr, r2
+ 	adc		r9, r9, r5
+ 	orr		r3, r3, r5, lsr r0
+ 	orr		r7, r7, r3, lsl r0
+ 	lsl		r6, r3, r2
+ 	orr		r7, r7, r3, lsr r1
+ 	subs	r8, r8, r6
+ 	sbc		r9, r9, r7
+L8:
+ 	adds	r0, ip, #0
+ 	mov		r1, #0
+ 	movne	r0, #1
+ 	rsbs	r2, r0, #0
+ 	rsc		r3, r1, #0
+ 	eor		r8, r8, r2
+ 	eor		r9, r9, r3
+ 	adds	r0, r0, r8
+ 	adc		r1, r1, r9
+ 	pop		{r4, r5, r6, r7, r8, r9, sl, fp, pc}
+L9:
+ 	rsbs	r8, r2, #0
+ 	mvn		ip, ip
+ 	rsc		r9, r3, #0
+ 	b		L3
+L10:
+ 	rsbs	r0, r0, #0
+ 	mvn		ip, #0
+ 	rsc		r1, r1, #0
+ 	b		L2
+
+__udivdi3:
+ 	push	{r4, r5, r6, r7, r8, lr}
+ 	mov		r5, r1
+ 	mov		r4, r0
+ 	cmp		r5, r3
+ 	cmpeq	r4, r2
+ 	mov		r0, r2
+ 	mov		r1, r3
+ 	bcc		L15
+ 	cmp		r3, #0
+ 	clzeq	r3, r0
+ 	clzne	r2, r3
+ 	addeq	r2, r3, #32
+ 	cmp		r5, #0
+ 	clzeq	r3, r4
+ 	clzne	r3, r5
+ 	addeq	r3, r3, #32
+ 	rsb		r3, r3, r2
+ 	lsl		r7, r1, r3
+ 	sub		lr, r3, #32
+ 	rsb		r2, r3, #32
+ 	lsl		r6, r0, r3
+ 	orr		r7, r7, r0, lsl lr
+ 	mov		ip, r3
+ 	orr		r7, r7, r0, lsr r2
+ 	cmp		r5, r7
+ 	cmpeq	r4, r6
+ 	movcc	r0, #0
+ 	movcc	r1, #0
+ 	bcc		L11
+ 	mov		r8, #1
+ 	subs	r4, r4, r6
+ 	lsl		r1, r8, lr
+ 	lsl		r0, r8, r3
+ 	orr		r1, r1, r8, lsr r2
+ 	sbc		r5, r5, r7
+L11:
+ 	cmp		r3, #0
+ 	popeq	{r4, r5, r6, r7, r8, pc}
+ 	lsrs	r7, r7, #1
+ 	rrx		r6, r6
+ 	b		L13
+L12:
+ 	subs	r4, r4, r6
+ 	sbc		r5, r5, r7
+ 	adds	r4, r4, r4
+ 	adc		r5, r5, r5
+ 	adds	r4, r4, #1
+ 	adc		r5, r5, #0
+ 	subs	r3, r3, #1
+ 	beq		L14
+L13:
+ 	cmp		r7, r5
+ 	cmpeq	r6, r4
+ 	bls		L12
+ 	adds	r4, r4, r4
+ 	adc		r5, r5, r5
+ 	subs	r3, r3, #1
+ 	bne		L13
+L14:
+ 	lsr		lr, r4, ip
+ 	rsb		r6, ip, #32
+ 	lsr		r8, r5, ip
+ 	sub		r7, ip, #32
+ 	orr		lr, lr, r5, lsl r6
+ 	adds	r0, r0, r4
+ 	lsl		r3, r8, ip
+ 	adc		r1, r1, r5
+ 	orr		lr, lr, r5, lsr r7
+ 	orr		r3, r3, lr, lsl r7
+ 	lsl		r2, lr, ip
+ 	orr		r3, r3, lr, lsr r6
+ 	subs	r0, r0, r2
+ 	sbc		r1, r1, r3
+ 	pop		{r4, r5, r6, r7, r8, pc}
+L15:
+ 	mov		r0, #0
+ 	mov		r1, #0
+ 	pop		{r4, r5, r6, r7, r8, pc}
+
diff --git a/src/bld/arm/jump.S b/src/bld/arm/jump.S
new file mode 100644
index 0000000..4868f41
--- /dev/null
+++ b/src/bld/arm/jump.S
@@ -0,0 +1,80 @@
+/**
+ * bld/jump.S
+ *
+ * History:
+ *    2006/12/29 - [Charles Chiou] created file
+ *    2014/02/13 - [Anthony Ginger] Amboot V2
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+
+.text
+
+/*
+ * Jump to the kernel
+ * r0 - jump address
+ * r1 - dtb address
+ */
+.globl	jump_to_kernel
+jump_to_kernel:
+	mov	r4, r0
+	mov	r5, r1
+	ldr	r6, =AMBARELLA_LINUX_MACHINE_ID
+
+	cpsid i				@ disable interrupt
+	dsb
+	isb
+	bl	_clean_flush_all_cache
+	bl	_disable_icache
+	bl	_disable_dcache
+
+	mrc	p15, 0, r0, c1, c0, 0	@ Read control register
+	orr	r0, r0, #0x1000		@ Turn on bit 12
+	bic	r0, r0, #0x1		@ Turn off bit 0
+	bic	r0, r0, #0x2000		@ Turn off bit 13
+	mcr	p15, 0, r0, c1, c0, 0	@ Write control register
+
+	mrs	r1, cpsr	@ read-modify-write to get to SVC mode
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x13	@ set supervisor mode
+	msr	cpsr, r1	@ now we should be in supervisor mode
+
+	mov	r0, #0x0
+	mov	r1, r6
+	mov	r2, r5
+	mov	pc, r4
+
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
diff --git a/src/bld/arm/memfwprog.lds.cpp b/src/bld/arm/memfwprog.lds.cpp
new file mode 100644
index 0000000..fa93ccd
--- /dev/null
+++ b/src/bld/arm/memfwprog.lds.cpp
@@ -0,0 +1,308 @@
+/**
+ * bld/memfwprog.lds.cpp
+ *
+ * Note: This linker script should be preprocessed before used against a
+ *	 specific configuration of 'memfwprog' code.
+ *
+ * History:
+ *    2005/02/27 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(run_once)
+SECTIONS
+{
+	. = MEMFWPROG_RAM_START;
+
+	.text : {
+		__BEGIN_FIRMWARE_IMAGE__ = ABSOLUTE(.);
+
+		run_once*.o (.text)
+		*.o (.text*)
+		* (.rodata*)
+	}
+
+	. = ALIGN(4);
+	.data : {
+		__nanddb_start = .;
+		* (.nanddb)
+		__nanddb_end = .;
+
+		. = ALIGN(4);
+		* (.data*)
+	}
+
+	.rel.plt : {
+		. = ALIGN(0x4000);
+		*(.rel.plt)
+	}
+
+	.bss : {
+		. = ALIGN(4);
+		__bss_start = .;
+
+		* (.bss)
+
+		__bss_end = .;
+
+		/* Stack for UND mode */
+		. = ALIGN(32);
+		__und_stack_start = .;
+		. = __und_stack_start + 0x100;
+		__und_stack_end = .;
+
+		/* Stack for ABT mode */
+		. = ALIGN(32);
+		__abt_stack_start = .;
+		. = __abt_stack_start + 0x100;
+		__abt_stack_end = .;
+
+		/* Stack for IRQ mode */
+		. = ALIGN(32);
+		__irq_stack_start = .;
+		. = __irq_stack_start + 0x2000;
+		__irq_stack_end = .;
+
+		/* Stack for FIQ mode */
+		. = ALIGN(32);
+		__fiq_stack_start = .;
+		. = __fiq_stack_start + 0x100;
+		__fiq_stack_end = .;
+
+		/* Stack for SVC mode */
+		. = ALIGN(32);
+		__svc_stack_start = .;
+		. = __svc_stack_start + 0x100;
+		__svc_stack_end = .;
+
+		/* Stack for SYS mode */
+		. = ALIGN(32);
+		__sys_stack_start = .;
+		. = __sys_stack_start + AMBOOT_BLD_STACK_SIZE;
+		__sys_stack_end = .;
+
+	}
+
+	.pagetable (NOLOAD) : {
+		/* MMU page table */
+		. = ALIGN(0x4000);
+		__pagetable_main = .;
+		. = __pagetable_main + (4096 * 4);	/* 16 KB of L1 */
+		__pagetable_hv = .;
+		. = __pagetable_hv + (256 * 4);
+	}
+
+	. = ALIGN(0x400);						/* must be 1024B align */
+	.bldbuf . (NOLOAD) : {
+		bld_buf_addr = .;
+		. = bld_buf_addr + (384 * SIZE_1KB);
+		bld_buf_end = .;
+	}
+
+	/DISCARD/ : {
+#if !defined(__LINK_BST__)
+		.temp/bst*.fw (.text)
+#endif
+#if !defined(__LINK_BLD__)
+		.temp/bld*.fw (.text)
+#endif
+#if !defined(__LINK_ATF__)
+		.temp/atf.fw (.text)
+#endif
+#if !defined(__LINK_PBA__)
+		.temp/pba.fw (.text)
+#endif
+#if !defined(__LINK_KERNEL__)
+		.temp/kernel.fw (.text)
+#endif
+#if !defined(__LINK_SECONDARY__)
+		.temp/secondary.fw (.text)
+#endif
+#if !defined(__LINK_BACKUP__)
+		.temp/backup.fw (.text)
+#endif
+#if !defined(__LINK_RAMDISK__)
+		.temp/ramdisk.fw (.text)
+#endif
+#if !defined(__LINK_ROMFS__)
+		.temp/romfs.fw (.text)
+#endif
+#if !defined(__LINK_DSP__)
+		.temp/dsp.fw (.text)
+#endif
+#if !defined(__LINK_LNX__)
+		.temp/lnx.fw (.text)
+#endif
+#if !defined(__LINK_SWP__)
+		.temp/swp.fw (.text)
+#endif
+#if !defined(__LINK_ADD__)
+		.temp/add.fw (.text)
+#endif
+#if !defined(__LINK_ADC__)
+		.temp/adc.fw (.text)
+#endif
+	}
+
+	.text : {
+
+#if defined(__LINK_BST__)
+		/* Payload of BST */
+		. = ALIGN(2048);
+		__BEGIN_AMBOOT_BST_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/bst*.fw (.text)
+		__END_AMBOOT_BST_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_BLD__)
+		/* Payload of BLD */
+		. = ALIGN(2048);
+		__BEGIN_AMBOOT_BLD_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/bld*.fw (.text)
+		__END_AMBOOT_BLD_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_ATF__)
+		/* Payload of ATF */
+		. = ALIGN(2048);
+		__BEGIN_ATF_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/atf.fw (.text)
+		__END_ATF_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_PBA__)
+		/* Payload of PBA */
+		. = ALIGN(2048);
+		__BEGIN_PBA_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/pba.fw (.text)
+		__END_PBA_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_KERNEL__)
+		/* Payload of Kernel */
+		. = ALIGN(2048);
+		__BEGIN_KERNEL_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/kernel.fw (.text)
+		__END_KERNEL_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_SECONDARY__)
+		/* Payload of Secondary */
+		. = ALIGN(2048);
+		__BEGIN_SECONDARY_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/secondary.fw (.text)
+		__END_SECONDARY_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_BACKUP__)
+		/* Payload of Backup */
+		. = ALIGN(2048);
+		__BEGIN_BACKUP_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/backup.fw (.text)
+		__END_BACKUP_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_RAMDISK__)
+		/* Payload of RAMDISK */
+		. = ALIGN(2048);
+		__BEGIN_RAMDISK_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/ramdisk.fw (.text)
+		__END_RAMDISK_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_ROMFS__)
+		/* Payload of ROMFS */
+		. = ALIGN(2048);
+		__BEGIN_ROMFS_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/romfs.fw (.text)
+		__END_ROMFS_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_DSP__)
+		/* Payload of DSP */
+		. = ALIGN(2048);
+		__BEGIN_DSP_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/dsp.fw (.text)
+		__END_DSP_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_LNX__)
+		/* Payload of LNX */
+		. = ALIGN(2048);
+		__BEGIN_LNX_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/lnx.fw (.text)
+		__END_LNX_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_SWP__)
+		/* Payload of SWP */
+		. = ALIGN(2048);
+		__BEGIN_SWP_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/swp.fw (.text)
+		__END_SWP_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_ADD__)
+		/* Payload of ADD */
+		. = ALIGN(2048);
+		__BEGIN_ADD_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/add.fw (.text)
+		__END_ADD_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+#if defined(__LINK_ADC__)
+		/* Payload of ADC */
+		. = ALIGN(2048);
+		__BEGIN_ADC_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/adc.fw (.text)
+		__END_ADC_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+#endif
+
+		. = ALIGN(2048);
+		__END_FIRMWARE_IMAGE__ = ABSOLUTE(.);
+	}
+
+	.memfwprog . (NOLOAD) : {
+		. = ALIGN(0x10000);
+		__memfwprog_result = .;
+		. = __memfwprog_result  + (0x10000);
+		. = ALIGN(0x10000);
+		__memfwprog_command = .;
+		. = __memfwprog_command + (0x10000);
+	}
+
+	.hugebuf . (NOLOAD) : {
+		. = ALIGN(0x100000);
+		bld_hugebuf_addr = .;
+	}
+
+}
+
diff --git a/src/bld/arm/mmu.S b/src/bld/arm/mmu.S
new file mode 100644
index 0000000..9cbadb0
--- /dev/null
+++ b/src/bld/arm/mmu.S
@@ -0,0 +1,198 @@
+/**
+ * bld/mmu.S
+ *
+ * History:
+ *    2005/03/10 - [Charles Chiou] created file
+ *    2009/01/12 - [Charles Chiou] merged mmu.c & pagetable.c into mmu.S
+ *    2014/02/13 - [Anthony Ginger] Amboot V2
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+
+.globl mmu_init
+mmu_init:
+	mov	r10, lr
+
+	/* Set the interrupt vectors address to 0xffff0000 - 0xffff001c
+	 * and disable subpage AP bits (it's safe for CortexA9 to set bit23) */
+	mrc	p15, 0, r0, c1, c0, 0
+	orr	r0, r0, #0x2000		/* Turn on bit 13 - HV */
+	orr	r0, r0, #0x800000	/* Turn on bit 23 - XP */
+	mcr	p15, 0, r0, c1, c0, 0
+
+	/********************/
+	/* Setup page table */
+	/********************/
+	ldr	r0, pagetable_main
+	mov	r1, #0x000
+
+	/* Map DRAM up to the range specified by the configuration */
+	bl	mmu_dram_tbl
+
+	/* Clear from dram end to 0xdff (~ 0xdfefffff) */
+	ldr	r2, =0xdff
+	bl	mmu_clear_tbl
+
+	/* Map 0xdff - 0xf01 (0xdff00000 - 0xf00fffff) as peripheral address */
+	ldr	r2, =0xf01
+	bl	mmu_peripheral_tbl
+
+	/* Clear 0xf01 - 0xfff (0xf0100000 - 0xffefffff) */
+	ldr	r2, =0xfff
+	bl	mmu_clear_tbl
+
+	/* Setup 0xfff00000 to point to a corse page table */
+	ldr	r3, pagetable_hv
+	orr	r3, r3, #0x01
+	str	r3, [r0]
+
+	/* Now setup the 2nd-level pagetable for the 0xfff00000 section */
+	ldr	r0, pagetable_hv
+
+	/* Clear 0x00 - 0xef (0xfff00000 - 0xfffeffff) */
+	mov	r1, #0x0
+	mov	r2, #0xf0
+	bl	mmu_clear_tbl
+
+	/* Map 0xffff0000 to DRAM_START_ADDR */
+	mov	r3, #AMBOOT_BLD_RAM_START
+	orr	r3, r3, #0x3e
+	str	r3, [r0]
+	add	r0, r0, #0x4
+	add	r1, r1, #0x1
+
+	/* Clear 0xf1 - 0xff */
+	mov	r2, #0x100
+	bl	mmu_clear_tbl
+
+	/* Make sure MMU is in disabled state first */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #0x1
+	mcr	p15, 0, r0, c1, c0, 0
+
+	/* Set the page table */
+	ldr	r0, pagetable_main;
+	mcr	p15, 0, r0, c2, c0, 0
+
+	/* Flush all cache */
+	bl	_flush_d_cache
+
+	/* Flush all TLB */
+	mcr	p15, 0, r0, c8, c6, 0
+
+	/* Set domain 0 as client and access permission controlled by */
+	/* descriptor. Other domains have no access permission */
+	mov	r0, #0x1
+	mcr	p15, 0, r0, c3, c0, 0
+
+	/* Enable MMU */
+	mrc	p15, 0, r0, c1, c0, 0
+	orr	r0, r0, #0x1
+	mcr	p15, 0, r0, c1, c0, 0
+
+	mov	pc, r10
+
+/**
+ * Clear page table:
+ * r0 - page table entry
+ * r1 - start address
+ * r2 - end address
+ */
+mmu_clear_tbl:
+	teq	r1, r2
+	moveq	pc, lr
+
+	mov	r3, #0x0
+1:
+	str	r3, [r0]
+	add	r0, r0, #0x4
+	add	r1, r1, #0x1
+	teq	r1, r2
+	bne	1b
+	mov	pc, lr
+
+/**
+ * Initialize page table for DRAM:
+ * r0 - page table entry
+ * r1 - virtual address start
+ */
+mmu_dram_tbl:
+#if	(DRAM_SIZE == 0x02000000)
+	add	r2, r1, #0x020	/* 256 Mbit (32 MB) */
+#elif	(DRAM_SIZE == 0x04000000)
+	add	r2, r1, #0x040	/* 512 Mbit (64 MB) */
+#elif	(DRAM_SIZE == 0x08000000)
+	add	r2, r1, #0x080	/* 1 Gbit (128 MB) */
+#elif	(DRAM_SIZE == 0x10000000)
+	add	r2, r1, #0x100	/* 2 Gbit (256 MB) */
+#elif	(DRAM_SIZE == 0x20000000)
+	add	r2, r1, #0x200	/* 4 Gbit (512 MB) */
+#elif	(DRAM_SIZE == 0x40000000)
+	add	r2, r1, #0x400	/* 8 Gbit (1024 MB) */
+#elif	(DRAM_SIZE == 0x60000000)
+	add	r2, r1, #0x600	/* 12 Gbit (1536 MB) */
+#elif	(DRAM_SIZE == 0x80000000)
+	add	r2, r1, #0x800	/* 16 Gbit (2048 MB) */
+#else
+	add	r2, r1, #0x020	/* 256 Mbit (32 MB) */
+#endif
+	ldr	r3, =0xfff	/* 0xfff00000 must be reserved for exception */
+	cmp	r2, r3
+	ldrhi	r2, =0xfff
+2:
+	mov	r3, r1, lsl #20		/* Address */
+	orr	r3, r3, #0xc00		/* Access = R/W */
+	orr	r3, r3, #0x0e
+	str	r3, [r0]
+	add	r0, r0, #0x4
+	add	r1, r1, #0x1
+	teq	r1, r2
+	bne	2b
+	mov	pc, lr
+
+/**
+ * Initialize page table for Peripheral:
+ * r0 - page table entry
+ * r1 - start address
+ * r2 - end address
+ */
+mmu_peripheral_tbl:
+3:
+	mov	r3, r1, lsl #20		/* Address */
+	orr	r3, r3, #0xc00		/* Access = R/W */
+	orr	r3, r3, #0x02
+	str	r3, [r0]
+	add	r0, r0, #0x4
+	add	r1, r1, #0x1
+	teq	r1, r2
+	bne	3b
+	mov	pc, lr
+
+pagetable_main:		.word	__pagetable_main
+pagetable_hv:		.word	__pagetable_hv
+
diff --git a/src/bld/arm/run_once.S b/src/bld/arm/run_once.S
new file mode 100644
index 0000000..5bad7e8
--- /dev/null
+++ b/src/bld/arm/run_once.S
@@ -0,0 +1,235 @@
+/**
+ * bld/run_once.S
+ *
+ * History:
+ *    2005/02/27 - [Charles Chiou] created file
+ *
+ * Setup the run-time environment and jump to function 'main()' once; when
+ * it returns, the execute a break-point instruction. This is mainly useful
+ * for loading a progream from JTAG into memory and executing that program
+ * once and have the ICE debugger stop upon code execution completion.
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+#include <macro.S>
+
+.text
+
+.globl run_once
+run_once:
+	ldr	pc, =reset
+	ldr	pc, =undefined_instruction
+	ldr	pc, =software_interrupt
+	ldr	pc, =prefetch_abort
+	ldr	pc, =data_abort
+	ldr	pc, =not_used
+	ldr	pc, =irq
+	ldr	pc, =fiq
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+amboot_version:			.word (AMBOOT_MAJOR_VER << 8 | AMBOOT_MINOR_VER)
+
+memfwprog_result_address:	.word	__memfwprog_result
+	nop
+	nop
+	nop
+memfwprog_command_address:	.word	__memfwprog_command
+	nop
+	nop
+	nop
+
+reset:
+	invalidate_all_tlb	r3
+	invalidate_all_cache	r3, r4, r5, r6, r7
+
+	/* First read in some misc registers */
+	mrc	p15, 0, r0, c0, c0, 0	/* Read ID value */
+	mrc	p15, 0, r1, c0, c0, 1	/* Read cache type */
+	mrc	p15, 0, r2, c0, c0, 2	/* Read TCM status */
+
+	/* Turn on instrucion cache and disable MMU */
+	mrc	p15, 0, r0, c1, c0, 0	/* Read control register */
+	orr	r0, r0, #0x1000		/* Turn on bit 12 */
+	bic	r0, r0, #0x1		/* Turn off bit 1 */
+	mcr	p15, 0, r0, c1, c0, 0	/* Write control register */
+
+	/* Give manager access permissions to all domains */
+	mov	r0, #0x1
+	mcr	p15, 0, r0, c3, c0, 0	/* Write domain access control reg */
+
+	/* Disabale IRQ/FIQ interrupts */
+	mrs	r0, cpsr
+	orr	r0, r0, #0xc0
+	msr	cpsr_c, r0
+
+	/* Clear regs. */
+	mov	r0, #0
+	mov	r1, #0
+	mov	r2, #0
+	mov	r3, #0
+	mov	r4, #0
+	mov	r5, #0
+	mov	r6, #0
+	mov	r7, #0
+	mov	r8, #0
+	mov	r9, #0
+	mov	r10, #0
+	mov	r11, #0
+	mov	r12, #0
+
+	/* undef mode */
+	mrs	r1, cpsr
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x1b	@ set UNDEF mode
+	msr	cpsr, r1	@ now we should be in UNDEF mode
+	msr	spsr, r1	@ spsr_irq
+	ldr	sp, und_stack_end	@ r13_und
+	mov	lr, #0x0		@ r14_und
+
+	/* abort mode */
+	mrs	r1, cpsr
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x17	@ set ABORT mode
+	msr	cpsr, r1	@ now we should be in ABORT mode
+	msr	spsr, r1	@ spsr_irq
+	ldr	sp, abt_stack_end	@ r13_abort
+	mov	lr, #0x0		@ r14_abort
+
+	/* irq mode */
+	mrs	r1, cpsr	@ read-modify-write to get to IRQ mode
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x12	@ set IRQ mode
+	msr	cpsr, r1	@ now we should be in IRQ mode
+	msr	spsr, r1	@ spsr_irq
+	ldr	sp, irq_stack_end	@ r13_irq
+	mov	lr, #0x0		@ r14_irq
+
+	/* fiq mode */
+	mrs	r1, cpsr	@ read-modify-write to get to FIQ mode
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x11	@ set FIQ mode
+	msr	cpsr, r1	@ now we should be in FIQ mode
+	msr	spsr, r1	@ spsr_fiq
+	mov	r8,  #0x0
+	mov	r9,  #0x0
+	mov	r10, #0x0
+	mov	r11, #0x0
+	mov	r12, #0x0
+	ldr	sp, fiq_stack_end	@ r13_fiq
+	mov	lr, #0x0		@ r14_fiq
+
+	/* svc mode */
+	mrs	r1, cpsr	@ read-modify-write to get to supervisor mode
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x13	@ set supervisor mode
+	msr	cpsr, r1	@ now we should be in supervisor mode
+	msr	spsr, r1	@ spsr_svc
+	mov	r8,  #0x0
+	mov	r9,  #0x0
+	mov	r10, #0x0
+	mov	r11, #0x0
+	mov	r12, #0x0
+	ldr	sp, svc_stack_end	@ r13_svc
+	mov	lr, #0x0		@ r14_svc
+
+	/* system mode */
+	mrs	r1, cpsr	@ read-modify-write to get to system mode
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x1f	@ set system mode
+	msr	cpsr, r1	@ now we should be in system mode
+	msr	spsr, r1	@ spsr_sys
+	mov	r8,  #0x0
+	mov	r9,  #0x0
+	mov	r10, #0x0
+	mov	r11, #0x0
+	mov	r12, #0x0
+	ldr	sp, sys_stack_end	@ r13
+	mov	lr, #0x0		@ r14
+
+	/* Set up the page tables and enable MMU */
+	bl	mmu_init
+	bl	_enable_dcache
+
+	/* Zero out the BSS section */
+	/* r1 = start address */
+	/* r2 = end address */
+	ldr	r1, bss_start
+	ldr	r2, bss_end
+
+	mov	r0, #0
+1:
+	stmia	r1!, {r0}
+	cmp	r1, r2
+	blo	1b
+
+	/* Jump to C code */
+	bl	main
+
+done:
+	/* We are here when the process has finished! */
+	bkpt
+
+undefined_instruction:
+	bkpt
+
+software_interrupt:
+	bkpt
+
+prefetch_abort:
+	bkpt
+
+data_abort:
+	bkpt
+
+not_used:
+	bkpt
+
+irq:
+	bkpt
+
+fiq:
+	bkpt
+
+.globl firmware_start
+firmware_start:	.word	__BEGIN_FIRMWARE_IMAGE__
+
+bss_start:	.word	__bss_start
+bss_end:	.word	__bss_end
+und_stack_end:	.word	__und_stack_end
+abt_stack_end:	.word	__abt_stack_end
+irq_stack_end:	.word	__irq_stack_end
+fiq_stack_end:	.word	__fiq_stack_end
+svc_stack_end:	.word	__svc_stack_end
+sys_stack_end:	.word	__sys_stack_end
+
diff --git a/src/bld/arm/trampoline.S b/src/bld/arm/trampoline.S
new file mode 100644
index 0000000..f652111
--- /dev/null
+++ b/src/bld/arm/trampoline.S
@@ -0,0 +1,355 @@
+/**
+ * bld/trampoline.S
+ *
+ * History:
+ *    2005/01/27 - [Charles Chiou] created file
+ *    2014/02/13 - [Anthony Ginger] Amboot V2
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+#include <macro.S>
+#include <irq.h>
+
+@
+@ IRQ stack frame.
+@
+#define S_FRAME_SIZE	72
+
+#define S_OLD_R0	68
+#define S_PSR		64
+#define S_PC		60
+#define S_LR		56
+#define S_SP		52
+
+#define S_IP		48
+#define S_FP		44
+#define S_R10		40
+#define S_R9		36
+#define S_R8		32
+#define S_R7		28
+#define S_R6		24
+#define S_R5		20
+#define S_R4		16
+#define S_R3		12
+#define S_R2		8
+#define S_R1		4
+#define S_R0		0
+
+.text
+
+/* Start of the BLD code */
+.globl bld_start
+bld_start:
+	b	bld_reset
+	ldr	pc, =undefined_instruction
+	ldr	pc, =software_interrupt
+	ldr	pc, =prefetch_abort
+	ldr	pc, =data_abort
+	ldr	pc, =not_used
+	ldr	pc, =irq
+	ldr	pc, =fiq
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	.org	56, 0x0
+
+amboot_version:
+	.word (AMBOOT_MAJOR_VER << 8 | AMBOOT_MINOR_VER)
+
+/* set by AmbaUsb for usb hardware boot mode, to specify the real boot media */
+.global	ambausb_boot_from
+ambausb_boot_from:
+	.word	0x00000000
+
+/* set by AmbaUsb to enable usb boot */
+.global	ambausb_boot_usb
+ambausb_boot_usb:
+	.word	0x00000000
+
+.align 5
+bld_reset:
+	invalidate_all_tlb	r3
+	invalidate_all_cache	r3, r4, r5, r6, r7
+
+	mrc	p15, 0, r0, c0, c0, 0	/* Read ID value */
+	mrc	p15, 0, r1, c0, c0, 1	/* Read cache type */
+	mrc	p15, 0, r2, c0, c0, 2	/* Read TCM status */
+#if defined(AMBOOT_BOOT_SECONDARY_CORTEX)
+	mrc	p15, 0, r3, c0, c0, 5	/* Read processor id */
+	and	r3, r3, #0x03
+	cmp	r3, #0			/* if (id ==0) */
+	beq	bld_normal_start
+
+secondary_cortex_wait:
+	wfi
+	ldr	r4, =0xdeadbeaf
+	adr	r1, secondary_cortex_jump
+	ldr	r0, [r1, r3, LSL #2]
+	cmp	r0, r4
+	beq	secondary_cortex_wait
+	str	r4, [r1, r3, LSL #2]
+	bx	r0
+	/* never run here */
+	b	.
+#else
+	ldr	r0, =bld_normal_start
+#endif
+	bx	r0
+	b	bld_start
+	b	.
+	nop
+	nop
+	nop
+
+.align 5
+bld_normal_start:
+	/* Turn on instrucion cache and disable MMU */
+	mrc	p15, 0, r0, c1, c0, 0	/* Read control register */
+	orr	r0, r0, #0x1000		@ Turn on bit 12 - I-cache
+	bic	r0, r0, #0x2000		@ Turn off bit 13 - HV
+	bic	r0, r0, #0x1		@ Turn off bit 0 - MMU
+	bic	r0, r0, #0x2		@ Turn off bit 1 - Alignment fault
+	orr	r0, r0, #0x400000	@ Turn on bit 22 - Unainged support
+	orr	r0, r0, #0x800000	@ Turn on bit 23 - XP to disable subpage
+	mcr	p15, 0, r0, c1, c0, 0	/* Write control register */
+
+	/* Give client access to domain 0 */
+	mov	r0, #0x1
+	mcr	p15, 0, r0, c3, c0, 0
+
+	/* Enabling Advanced SIMD and floating-point support */
+	mrc p15, 0, r0, c1, c0, 2 	@Read CPACR into r0
+	orr r0, r0, #(3<<20)   		@OR in User and Privileged access for CP10
+	orr r0, r0, #(3<<22)   		@OR in User and Privileged access for CP11
+	bic r0, r0, #(3<<30) 		@Store new access permissions into CPACR
+	mcr p15, 0, r0, c1, c0, 2 	@Ensure side-effect of CPACR is visible
+	isb
+	mov r0, #(1<<30)			@Create value with FPEXC (bit 30) set in r0
+	vmsr fpexc, r0     			@Enable VFP and SIMD extensions
+
+	/* Disabale IRQ/FIQ interrupts */
+	mrs	r0, cpsr
+	orr	r0, r0, #0xc0
+	msr	cpsr_c, r0
+
+	/* Clear regs. */
+	mov	r0, #0
+	mov	r1, #0
+	mov	r2, #0
+	mov	r3, #0
+	mov	r4, #0
+	mov	r5, #0
+	mov	r6, #0
+	mov	r7, #0
+	mov	r8, #0
+	mov	r9, #0
+	mov	r10, #0
+	mov	r11, #0
+	mov	r12, #0
+
+	/* undef mode */
+	mrs	r1, cpsr
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x1b	@ set UNDEF mode
+	msr	cpsr, r1	@ now we should be in UNDEF mode
+	msr	spsr, r1	@ spsr_irq
+	ldr	sp, und_stack_end	@ r13_und
+	mov	lr, #0x0		@ r14_und
+
+	/* abort mode */
+	mrs	r1, cpsr
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x17	@ set ABORT mode
+	msr	cpsr, r1	@ now we should be in ABORT mode
+	msr	spsr, r1	@ spsr_irq
+	ldr	sp, abt_stack_end	@ r13_abort
+	mov	lr, #0x0		@ r14_abort
+
+	/* irq mode */
+	mrs	r1, cpsr	@ read-modify-write to get to IRQ mode
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x12	@ set IRQ mode
+	msr	cpsr, r1	@ now we should be in IRQ mode
+	msr	spsr, r1	@ spsr_irq
+	ldr	sp, irq_stack_end	@ r13_irq
+	mov	lr, #0x0		@ r14_irq
+
+	/* fiq mode */
+	mrs	r1, cpsr	@ read-modify-write to get to FIQ mode
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x11	@ set FIQ mode
+	msr	cpsr, r1	@ now we should be in FIQ mode
+	msr	spsr, r1	@ spsr_fiq
+	mov	r8,  #0x0
+	mov	r9,  #0x0
+	mov	r10, #0x0
+	mov	r11, #0x0
+	mov	r12, #0x0
+	ldr	sp, fiq_stack_end	@ r13_fiq
+	mov	lr, #0x0		@ r14_fiq
+
+	/* svc mode */
+	mrs	r1, cpsr	@ read-modify-write to get to supervisor mode
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x13	@ set supervisor mode
+	msr	cpsr, r1	@ now we should be in supervisor mode
+	msr	spsr, r1	@ spsr_svc
+	mov	r8,  #0x0
+	mov	r9,  #0x0
+	mov	r10, #0x0
+	mov	r11, #0x0
+	mov	r12, #0x0
+	ldr	sp, svc_stack_end	@ r13_svc
+	mov	lr, #0x0		@ r14_svc
+
+	/* system mode */
+	mrs	r1, cpsr	@ read-modify-write to get to system mode
+	bic	r1, r1, #0x1f	@ clear current mode
+	orr	r1, r1, #0x1f	@ set system mode
+	msr	cpsr, r1	@ now we should be in system mode
+	msr	spsr, r1	@ spsr_sys
+	mov	r8,  #0x0
+	mov	r9,  #0x0
+	mov	r10, #0x0
+	mov	r11, #0x0
+	mov	r12, #0x0
+	ldr	sp, sys_stack_end	@ r13
+	mov	lr, #0x0		@ r14
+
+
+#if defined(CONFIG_PANDORA_RTOS)
+	/* Boot Pandora RTOS in basic svc mode */
+	mrs	r1, cpsr
+	bic	r1, r1, #0x1f
+	orr	r1, r1, #0x13
+	msr	cpsr, r1
+	msr	spsr, r1
+#endif
+
+	/* Set up the page tables and enable MMU */
+	bl	mmu_init
+	bl	_enable_dcache
+
+	/* Zero out the BSS section */
+	/* r1 = start address */
+	/* r2 = end address */
+	ldr	r1, bss_start
+	ldr	r2, bss_end
+
+	mov	r0, #0
+1:
+	stmia	r1!, {r0}
+	cmp	r1, r2
+	blo	1b
+
+	/* Jump to C code */
+#if defined(CONFIG_PANDORA_RTOS)
+	bl	pandora
+#else
+	bl	main
+#endif
+
+	/* If main ever returns we just call it again */
+	b	bld_start
+	b	.
+
+undefined_instruction:
+	b	.
+
+software_interrupt:
+#if defined(CONFIG_PANDORA_RTOS)
+	b	__pandora_swi
+#else
+	b	.
+#endif
+
+prefetch_abort:
+	b	.
+
+data_abort:
+	b	.
+
+not_used:
+	b	.
+
+irq:
+	sub	sp, sp, #S_FRAME_SIZE
+	stmia	sp, {r0 - r12}		@ Calling r0-r12
+					@ !!!! R8 NEEDS to be saved !!!!
+					@ a reserved stack spot would be good.
+	add	r8, sp, #S_PC
+	stmdb	r8, {sp, lr}^		@ Calling SP, LR
+	str	lr, [r8, #0]		@ Save calling PC
+	mrs	r6, spsr
+	str	r6, [r8, #4]		@ Save CPSR
+	str	r0, [r8, #8]		@ Save OLD_R0
+	mov	r0, sp
+
+	bl	irq_handler
+
+#if defined(CONFIG_PANDORA_RTOS)
+	ldr	r0, =pandorayield
+	ldr	r1, [r0]
+	cmp	r1, #0
+	bne	__pandora_yield
+#endif
+	b	irq_done
+	b	.
+
+.globl irq_done
+irq_done:
+	ldmia	sp, {r0 - lr}^		@ Calling r0 - lr
+	mov	r0, r0
+	ldr	lr, [sp, #S_PC]		@ Get PC
+	add	sp, sp, #S_FRAME_SIZE
+	subs	pc, lr, #4		@ return & move spsr_svc into cpsr
+
+fiq:
+	b	.
+
+bss_start:	.word	__bss_start
+bss_end:	.word	__bss_end
+und_stack_end:	.word	__und_stack_end
+abt_stack_end:	.word	__abt_stack_end
+irq_stack_end:	.word	__irq_stack_end
+fiq_stack_end:	.word	__fiq_stack_end
+svc_stack_end:	.word	__svc_stack_end
+sys_stack_end:	.word	__sys_stack_end
+
+#if defined(AMBOOT_BOOT_SECONDARY_CORTEX)
+.globl secondary_cortex_jump
+secondary_cortex_jump:
+.rept 4
+			.word	0xdeadbeaf
+.endr
+#endif
+
diff --git a/src/bld/arm/udivsi3.S b/src/bld/arm/udivsi3.S
new file mode 100644
index 0000000..c996281
--- /dev/null
+++ b/src/bld/arm/udivsi3.S
@@ -0,0 +1,245 @@
+
+/**
+ * bld/arm/_udivsi3.S
+ *
+ * History:
+ *    2016/3/4 - [Jorney] porting from u-boot. Thanks Richard Earnshaw.
+ *
+ * Copyright (c) 2020 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+dividend	.req	r0
+divisor		.req	r1
+result		.req	r2
+curbit		.req	r3
+	.text
+	.globl	 __udivsi3
+	.type	__udivsi3 ,function
+	.globl	__aeabi_uidiv
+	.type	__aeabi_uidiv ,function
+	.align	0
+ __udivsi3:
+ __aeabi_uidiv:
+	cmp	divisor, #0
+	beq	Ldiv0
+	mov	curbit, #1
+	mov	result, #0
+	cmp	dividend, divisor
+	bcc	Lgot_result
+Loop1:
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is
+	@ larger than the dividend.
+	cmp	divisor, #0x10000000
+	cmpcc	divisor, dividend
+	movcc	divisor, divisor, lsl #4
+	movcc	curbit, curbit, lsl #4
+	bcc	Loop1
+Lbignum:
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+	cmp	divisor, #0x80000000
+	cmpcc	divisor, dividend
+	movcc	divisor, divisor, lsl #1
+	movcc	curbit, curbit, lsl #1
+	bcc	Lbignum
+Loop3:
+	@ Test for possible subtractions, and note which bits
+	@ are done in the result.  On the final pass, this may subtract
+	@ too much from the dividend, but the result will be ok, since the
+	@ "bit" will have been shifted out at the bottom.
+	cmp	dividend, divisor
+	subcs	dividend, dividend, divisor
+	orrcs	result, result, curbit
+	cmp	dividend, divisor, lsr #1
+	subcs	dividend, dividend, divisor, lsr #1
+	orrcs	result, result, curbit, lsr #1
+	cmp	dividend, divisor, lsr #2
+	subcs	dividend, dividend, divisor, lsr #2
+	orrcs	result, result, curbit, lsr #2
+	cmp	dividend, divisor, lsr #3
+	subcs	dividend, dividend, divisor, lsr #3
+	orrcs	result, result, curbit, lsr #3
+	cmp	dividend, #0			@ Early termination?
+	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
+	movne	divisor, divisor, lsr #4
+	bne	Loop3
+Lgot_result:
+	mov	r0, result
+	mov	pc, lr
+Ldiv0:
+	str	lr, [sp, #-4]!
+	bl	 __div0       (PLT)
+	mov	r0, #0			@ about as wrong as it could be
+	ldmia	sp!, {pc}
+	.size  __udivsi3       , . -  __udivsi3
+
+.globl __aeabi_uidivmod
+__aeabi_uidivmod:
+
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_uidiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+.globl __aeabi_idivmod
+__aeabi_idivmod:
+
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_idiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+
+.macro ARM_DIV_BODY dividend, divisor, result, curbit
+
+
+	@ Initially shift the divisor left 3 bits if possible,
+	@ set curbit accordingly.  This allows for curbit to be located
+	@ at the left end of each 4 bit nibbles in the division loop
+	@ to save one loop in most cases.
+	tst	\divisor, #0xe0000000
+	moveq	\divisor, \divisor, lsl #3
+	moveq	\curbit, #8
+	movne	\curbit, #1
+
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is
+	@ larger than the dividend.
+1:	cmp	\divisor, #0x10000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #4
+	movlo	\curbit, \curbit, lsl #4
+	blo	1b
+
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+1:	cmp	\divisor, #0x80000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #1
+	movlo	\curbit, \curbit, lsl #1
+	blo	1b
+
+	mov	\result, #0
+
+
+	@ Division loop
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	orrhs	\result,   \result,   \curbit
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	orrhs	\result,   \result,   \curbit,  lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	orrhs	\result,   \result,   \curbit,  lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	orrhs	\result,   \result,   \curbit,  lsr #3
+	cmp	\dividend, #0			@ Early termination?
+	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
+	movne	\divisor,  \divisor, lsr #4
+	bne	1b
+
+.endm
+
+.macro ARM_DIV2_ORDER divisor, order
+
+
+	cmp	\divisor, #(1 << 16)
+	movhs	\divisor, \divisor, lsr #16
+	movhs	\order, #16
+	movlo	\order, #0
+
+	cmp	\divisor, #(1 << 8)
+	movhs	\divisor, \divisor, lsr #8
+	addhs	\order, \order, #8
+
+	cmp	\divisor, #(1 << 4)
+	movhs	\divisor, \divisor, lsr #4
+	addhs	\order, \order, #4
+
+	cmp	\divisor, #(1 << 2)
+	addhi	\order, \order, #3
+	addls	\order, \order, \divisor, lsr #1
+
+
+.endm
+
+	.align	5
+.globl __divsi3
+.globl __aeabi_idiv
+__divsi3:
+__aeabi_idiv:
+	cmp	r1, #0
+	eor	ip, r0, r1			@ save the sign of the result.
+	beq	_Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	subs	r2, r1, #1			@ division by 1 or -1 ?
+	beq	10f
+	movs	r3, r0
+	rsbmi	r3, r0, #0			@ positive dividend value
+	cmp	r3, r1
+	bls	11f
+	tst	r1, r2				@ divisor is power of 2 ?
+	beq	12f
+
+	ARM_DIV_BODY r3, r1, r0, r2
+
+	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+10:	teq	ip, r0				@ same sign ?
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+11:	movlo	r0, #0
+	moveq	r0, ip, asr #31
+	orreq	r0, r0, #1
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	cmp	ip, #0
+	mov	r0, r3, lsr r2
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+_Ldiv0:
+
+	str	lr, [sp, #-4]!
+	bl	__div0
+	mov	r0, #0			@ About as wrong as it could be.
+	ldr	pc, [sp], #4
+
+__div0:
+	b .
diff --git a/src/bld/audio.c b/src/bld/audio.c
index 01e6d05..801ef1c 100644
--- a/src/bld/audio.c
+++ b/src/bld/audio.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/11/17 - [Cao Rongrong] creat
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -17,6 +35,7 @@
 #include <ambhw/dma.h>
 #include <ambhw/i2s.h>
 #include <ambhw/cache.h>
+#include <ambhw/timer.h>
 
 /* 4 desc for record, and 1 desc for playback */
 #define DMA_DESC_NUM		4
@@ -25,26 +44,64 @@ static struct dma_desc pcm_dma_desc[DMA_DESC_NUM + 1] __attribute__((aligned(32)
 static u32 audio_play_size = 0;
 static u32 audio_play_addr = 0;
 
-/* i2s format: 12.288MHz, 48KHz, 16bit, stereo, master mode */
+/* i2s format: 12.288MHz, 48KHz, 16bit&32bit, stereo, master mode */
 static void i2s_init(void)
 {
+	u32 rate, bclk, clk_div, clk_reg;
+
+	rate = AUDIO_SAMPLE_RATE;
+#if defined(AMBOOT_AUDIO_16BIT)
+	bclk = 2 * 16 * rate;
+#elif defined(AMBOOT_AUDIO_32BIT)
+	bclk = 2 * 32 * rate;
+#endif
+	clk_div = ((12288000 / ( 2 * bclk)) - 1) & 0x1f;
+
+#if defined(AMBOOT_AUDIO_MODE_SLAVE)
+	clk_reg = 0x040 | clk_div;
+#else
+	clk_reg = 0x3c0 | clk_div;
+#endif
+
 	rct_set_audio_pll();		/* 12.288MHz */
-	writel(I2S_CLOCK_REG, 0x3c3);	/* 48KHz */
+	writel(I2S_CLOCK_REG, clk_reg); /* set bclk for i2s */
 	setbitsl(I2S_INIT_REG, 0x1);	/* i2s fifo reset */
 	clrbitsl(I2S_INIT_REG, 0x4);	/* i2s tx fifo disable */
 	clrbitsl(I2S_INIT_REG, 0x2);	/* i2s rx fifo disable */
 
+#if defined(AMBOOT_AUDIO_MODE_SLAVE)
+	writel(I2S_RX_CTRL_REG, 0x00);
+	writel(I2S_TX_CTRL_REG, 0x00);
+#else
+	writel(I2S_RX_CTRL_REG, 0x02);
+#if defined(AMBOOT_AUDIO_16BIT)
 	writel(I2S_TX_CTRL_REG, 0x28);
+#else
+	writel(I2S_TX_CTRL_REG, 0x20);
+#endif
+#endif
+
+#if defined(AMBOOT_AUDIO_16BIT)
 	writel(I2S_TX_FIFO_LTH_REG, 0x10);
-	writel(I2S_RX_CTRL_REG, 0x02);
+#elif defined(AMBOOT_AUDIO_32BIT)
+	writel(I2S_TX_FIFO_LTH_REG, 0x20);
+#endif
 	writel(I2S_RX_FIFO_GTH_REG, 0x20);
 
 	writel(I2S_CHANNEL_SELECT_REG, I2S_2CHANNELS_ENB);
 	writel(I2S_MODE_REG, 0x4);
+#if defined(AMBOOT_AUDIO_16BIT)
 	writel(I2S_WLEN_REG, 0x0f);
+#elif defined(AMBOOT_AUDIO_32BIT)
+	writel(I2S_WLEN_REG, 0x1f);
+#endif
 	writel(I2S_WPOS_REG, 0x0);
 	writel(I2S_SLOT_REG, 0x0);
+#if defined(AMBOOT_AUDIO_16BIT)
 	writel(I2S_24BITMUX_MODE_REG, 0x0);
+#elif defined(AMBOOT_AUDIO_32BIT)
+	writel(I2S_24BITMUX_MODE_REG, 0x1);
+#endif
 }
 
 static void pcm_dma_init(void)
@@ -64,37 +121,47 @@ static void pcm_dma_init(void)
 
 		desc->attr = DMA_DESC_WM | DMA_DESC_NI |
 				DMA_DESC_IE | DMA_DESC_ST |
-				DMA_DESC_TS_2B | DMA_DESC_BLK_32B |
-				DMA_DESC_ID;
+				DMA_DESC_ID | DMA_DESC_BLK_32B;
+#if defined(AMBOOT_AUDIO_16BIT)
+		desc->attr |= DMA_DESC_TS_2B;
+#elif defined(AMBOOT_AUDIO_32BIT)
+		desc->attr |= DMA_DESC_TS_4B;
+#endif
+
 		desc->xfr_count = DSP_FASTAUDIO_SIZE / DMA_DESC_NUM;
 		desc->src = I2S_RX_DATA_DMA_REG;
 		desc->dst = DSP_FASTAUDIO_START + i * desc->xfr_count;
 		/* rpt_addr points to desc->rpt field */
-		desc->rpt_addr = (u32)desc + sizeof(struct dma_desc) - 4;
-		desc->next_desc = (u32)next_desc;
+		desc->rpt_addr = (uintptr_t)desc + sizeof(struct dma_desc) - 4;
+		desc->next_desc = (uintptr_t)next_desc;
 	}
 
 	clean_d_cache(pcm_dma_desc, sizeof(pcm_dma_desc));
-	writel(DMA_CHAN_STA_REG(I2S_RX_DMA_CHAN), 0x0);
-	writel(DMA_CHAN_DA_REG(I2S_RX_DMA_CHAN), (u32)pcm_dma_desc);
+	writel(DMA0_CHAN_STA_REG(I2S_RX_DMA_CHAN), 0x0);
+	writel(DMA0_CHAN_DA_REG(I2S_RX_DMA_CHAN), (uintptr_t)pcm_dma_desc);
 
 	/* dma desc init for playback */
 	desc = &pcm_dma_desc[DMA_DESC_NUM];
 	desc->attr = DMA_DESC_RM | DMA_DESC_NI |
 			DMA_DESC_IE | DMA_DESC_ST |
-			DMA_DESC_TS_4B | DMA_DESC_BLK_32B |
+			DMA_DESC_BLK_32B |
 			DMA_DESC_ID | DMA_DESC_EOC;
+#if defined(AMBOOT_AUDIO_16BIT)
+	desc->attr |= DMA_DESC_TS_2B;
+#elif defined(AMBOOT_AUDIO_32BIT)
+	desc->attr |= DMA_DESC_TS_4B;
+#endif
 	desc->src = audio_play_addr;
 	desc->dst = I2S_TX_LEFT_DATA_DMA_REG;
 	BUG_ON(audio_play_size >= 0x00400000);
 	desc->xfr_count = audio_play_size;
 	/* rpt_addr points to desc->rpt field */
-	desc->rpt_addr = (u32)desc + sizeof(struct dma_desc) - 4;
-	desc->next_desc = (u32)desc;
+	desc->rpt_addr = (uintptr_t)desc + sizeof(struct dma_desc) - 4;
+	desc->next_desc = (uintptr_t)desc;
 
 	clean_d_cache(desc, sizeof(*desc));
-	writel(DMA_CHAN_STA_REG(I2S_TX_DMA_CHAN), 0x0);
-	writel(DMA_CHAN_DA_REG(I2S_TX_DMA_CHAN), (u32)desc);
+	writel(DMA0_CHAN_STA_REG(I2S_TX_DMA_CHAN), 0x0);
+	writel(DMA0_CHAN_DA_REG(I2S_TX_DMA_CHAN), (uintptr_t)desc);
 }
 
 void audio_set_play_size(u32 addr, u32 size)
@@ -103,6 +170,17 @@ void audio_set_play_size(u32 addr, u32 size)
 	audio_play_addr = addr;
 }
 
+static void timer4_reset(void)
+{
+	writel(TIMER_CTR_REG, (readl(TIMER_CTR_REG) & (~0xF000)));
+	writel(TIMER4_STATUS_REG, 0xFFFFFFFF);
+	writel(TIMER4_RELOAD_REG, 0x00000000);
+	writel(TIMER4_MATCH1_REG, 0x00000000);
+	writel(TIMER4_MATCH2_REG, 0x00000000);
+
+	writel(TIMER_CTR_REG, (readl(TIMER_CTR_REG) | 0x1000));
+}
+
 void audio_init(void)
 {
 	i2s_init();
@@ -114,8 +192,10 @@ void audio_start(void)
 	setbitsl(I2S_INIT_REG, 0x4);	/* i2s tx fifo enable */
 	setbitsl(I2S_INIT_REG, 0x2);	/* i2s rx fifo enable */
 
-	writel(DMA_CHAN_CTR_REG(I2S_TX_DMA_CHAN), DMA_CHANX_CTR_EN | DMA_CHANX_CTR_D);
-	writel(DMA_CHAN_CTR_REG(I2S_RX_DMA_CHAN), DMA_CHANX_CTR_EN | DMA_CHANX_CTR_D);
+	writel(DMA0_CHAN_CTR_REG(I2S_TX_DMA_CHAN), DMA_CHANX_CTR_EN | DMA_CHANX_CTR_D);
+	writel(DMA0_CHAN_CTR_REG(I2S_RX_DMA_CHAN), DMA_CHANX_CTR_EN | DMA_CHANX_CTR_D);
+
+	timer4_reset();
 
 	putstr("DSP_FASTAUDIO_START = 0x");
 	puthex(DSP_FASTAUDIO_START);
diff --git a/src/bld/bld_usb_descriptors.c b/src/bld/bld_usb_descriptors.c
index 672e6bf..8a0494a 100644
--- a/src/bld/bld_usb_descriptors.c
+++ b/src/bld/bld_usb_descriptors.c
@@ -4,19 +4,35 @@
  * History:
  *    2005/09/07 - [Arthur Yang] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef _DESCRIPTOR_C_
 #define _DESCRIPTOR_C_
 
-#include "descriptor.h"
-
 /* get lower byte with 8bit for 16bit data */
 #define LB16(data)  ((u8)((data) & 0x00ff))
 /* get upper byte with 8bit for 16bit data */
@@ -34,7 +50,7 @@
 #if !defined (BLD_MSC)
 
 /**********************
-   Device descriptor 
+   Device descriptor
  **********************/
 
 
@@ -59,7 +75,7 @@ ALIGN8 static USB_DEVICE_DESC uds_device_desc_bld =
 /********************
    Device qualifier
  ********************/
-ALIGN8 static USB_DEVICE_QUALIFIER_DESC uds_device_qualifier =	
+ALIGN8 static USB_DEVICE_QUALIFIER_DESC uds_device_qualifier =
 {
     USB_DEV_QUALIFIER_LENGTH,     /* descriptor size            */
     USB_DEVICE_QUALIFIER,         /* descriptor type            */
@@ -80,13 +96,13 @@ ALIGN8 static USB_DEVICE_QUALIFIER_DESC uds_device_qualifier =
             endpoint descriptor
             .
             .
-            
+
         class specific descriptors
         .
         .
  ***********************************/
 /* for bootloader class */
-ALIGN8 static u8 uds_bld_configuration1_hs[] =	
+ALIGN8 static u8 uds_bld_configuration1_hs[] =
 {
     /* configuration1 */
     USB_CFG_LENGTH,                 /* descriptor size           */
@@ -145,7 +161,7 @@ ALIGN8 static u8 uds_bld_configuration1_hs[] =
 
 };
 
-ALIGN8 static u8 uds_bld_configuration1_fs[] = 	
+ALIGN8 static u8 uds_bld_configuration1_fs[] =
 {
     /* configuration1 */
     USB_CFG_LENGTH,                  /* descriptor size          */
@@ -158,7 +174,7 @@ ALIGN8 static u8 uds_bld_configuration1_fs[] =
     USB_CFG_CFG_ATTRIBUES,           /* characteristics          */
     USB_CFG_MAX_POWER,               /* maximum power in 2mA     */
         /* interface0 alt0 */
-        
+
         USB_IF_LENGTH,               /* descriptor size          */
         USB_INTERFACE_DESCRIPTOR,    /* descriptor type          */
         USB_IF_IF0_NUMBER,           /* interface number         */
@@ -208,14 +224,14 @@ ALIGN8 static u8 uds_bld_configuration1_fs[] =
 /*********************
    String descriptors
  *********************/
-ALIGN8 static u8 uds_string_desc0[] = 
+ALIGN8 static u8 uds_string_desc0[] =
 {
     4,                                  /* size of String Descriptor        */
     USB_STRING_DESCRIPTOR,              /* String Descriptor type           */
     0x09, 0x04                          /*  Primary/Sub LANGID              */
 };
 
-ALIGN8 static u8 uds_string_desc1[] =	
+ALIGN8 static u8 uds_string_desc1[] =
 {
     10,                                 /* size of String Descriptor        */
     USB_STRING_DESCRIPTOR,              /* String Descriptor type           */
@@ -241,7 +257,7 @@ ALIGN8 static u8 uds_bld_string_desc2[] =
 
 };
 
-ALIGN8 static u8 uds_string_desc3[] = 	
+ALIGN8 static u8 uds_string_desc3[] =
 {
     26,                                 /* size of String Descriptor        */
     USB_STRING_DESCRIPTOR,              /* String Descriptor type           */
@@ -259,7 +275,7 @@ ALIGN8 static u8 uds_string_desc3[] =
 */
 
 /* bootloader Class Descriptor */
-static u8 *uds_bld_descriptors[] = 
+static u8 *uds_bld_descriptors[] =
 {
     /* device descriptor */
     (u8 *)&uds_device_desc_bld,		/* device descriptor */
@@ -305,7 +321,7 @@ ALIGN8 static USB_DEVICE_DESC uds_device_desc_bld_msc =
 /********************
    Device qualifier
  ********************/
-ALIGN8 static USB_DEVICE_QUALIFIER_DESC uds_msc_device_qualifier =	
+ALIGN8 static USB_DEVICE_QUALIFIER_DESC uds_msc_device_qualifier =
 {
     USB_DEV_QUALIFIER_LENGTH,     /* descriptor size            */
     USB_DEVICE_QUALIFIER,         /* descriptor type            */
@@ -326,13 +342,13 @@ ALIGN8 static USB_DEVICE_QUALIFIER_DESC uds_msc_device_qualifier =
             endpoint descriptor
             .
             .
-            
+
         class specific descriptors
         .
         .
  ***********************************/
 /* for bootloader class */
-ALIGN8 static u8 uds_bld_msc_configuration1_hs[] =	
+ALIGN8 static u8 uds_bld_msc_configuration1_hs[] =
 {
     /* configuration1 */
     USB_CFG_LENGTH,                 /* descriptor size           */
@@ -391,7 +407,7 @@ ALIGN8 static u8 uds_bld_msc_configuration1_hs[] =
 #endif
 };
 
-ALIGN8 static u8 uds_bld_msc_configuration1_fs[] = 	
+ALIGN8 static u8 uds_bld_msc_configuration1_fs[] =
 {
     /* configuration1 */
     USB_CFG_LENGTH,                  /* descriptor size          */
@@ -404,7 +420,7 @@ ALIGN8 static u8 uds_bld_msc_configuration1_fs[] =
     USB_CFG_CFG_ATTRIBUES,           /* characteristics          */
     USB_CFG_MAX_POWER,               /* maximum power in 2mA     */
         /* interface0 alt0 */
-        
+
         USB_IF_LENGTH,               /* descriptor size          */
         USB_INTERFACE_DESCRIPTOR,    /* descriptor type          */
         USB_IF_IF0_NUMBER,           /* interface number         */
@@ -454,14 +470,14 @@ ALIGN8 static u8 uds_bld_msc_configuration1_fs[] =
 /*********************
    String descriptors
  *********************/
-ALIGN8 static u8 uds_msc_string_desc0[] = 	 
+ALIGN8 static u8 uds_msc_string_desc0[] =
 {
     4,                                  /* size of String Descriptor        */
     USB_STRING_DESCRIPTOR,              /* String Descriptor type           */
     0x09, 0x04                          /*  Primary/Sub LANGID              */
 };
 
-ALIGN8 static u8 uds_msc_string_desc1[] =	
+ALIGN8 static u8 uds_msc_string_desc1[] =
 {
     10,                                 /* size of String Descriptor        */
     USB_STRING_DESCRIPTOR,              /* String Descriptor type           */
@@ -471,7 +487,7 @@ ALIGN8 static u8 uds_msc_string_desc1[] =
 };
 
 /* for bootloader Mass Storage Class */
-ALIGN8 static u8 uds_bld_msc_string_desc2[] =	
+ALIGN8 static u8 uds_bld_msc_string_desc2[] =
 {
     50,                                 /* size of String Descriptor        */
     USB_STRING_DESCRIPTOR,              /* String Descriptor type           */
@@ -485,7 +501,7 @@ ALIGN8 static u8 uds_bld_msc_string_desc2[] =
     'a', 0x00, 's', 0x00, 's', 0x00,
 };
 
-ALIGN8 static u8 uds_msc_string_desc3[] = 	
+ALIGN8 static u8 uds_msc_string_desc3[] =
 {
     26,                                 /* size of String Descriptor        */
     USB_STRING_DESCRIPTOR,              /* String Descriptor type           */
@@ -497,7 +513,7 @@ ALIGN8 static u8 uds_msc_string_desc3[] =
 };
 
 /* bootloader Class Descriptor */
-static u8 *uds_bld_msc_descriptors[] = 
+static u8 *uds_bld_msc_descriptors[] =
 {
     /* device descriptor */
     (u8 *)&uds_device_desc_bld_msc,	/* device descriptor */
diff --git a/src/bld/bldfunc.h b/src/bld/bldfunc.h
index 008bc2b..fb71963 100644
--- a/src/bld/bldfunc.h
+++ b/src/bld/bldfunc.h
@@ -7,12 +7,30 @@
  *    2005/01/27 - [Charles Chiou] created file
  *    2008/02/19 - [Allen Wang] changed to use capabilities and chip ID
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __BLDFUNC_H__
@@ -30,22 +48,32 @@
 
 /*===========================================================================*/
 #ifndef __ASM__
+
+#include <vsprintf.h>
+
 /*===========================================================================*/
-int thaw_hibernation(void);
-int thaw_info(void);
+
+int thaw_hibernation(int, int);
+int thaw_hibernation_info(void);
+
+/*===========================================================================*/
+extern int secure_boot_main(int ret_val, flpart_table_t *pptb);
 
 /*===========================================================================*/
-int mem_malloc_init(void);
+int malloc_init(void);
 void *malloc(int size);
 void free(void *ptr);
 
 /*===========================================================================*/
 extern int rand(void);
+extern int bopt_sync(void *arg0, void *arg1, void *arg2, void *arg3);
 
 /*===========================================================================*/
 extern int bld_loader_load_partition(int part_id,
-	const flpart_table_t *pptb, int verbose);
+		const flpart_table_t *pptb, u32 size, int verbose);
 extern void bld_loader_display_part(const char *s, const flpart_t *part);
+extern int bld_loader_load_partition_partial(int part_id, unsigned int offset,
+		unsigned int size, uintptr_t mem_addr, int verbose);
 extern void bld_loader_display_ptb_content(const flpart_table_t *ptb);
 
 /*===========================================================================*/
@@ -55,9 +83,9 @@ extern void memzero(void *dst, unsigned int n);
 extern int  memcmp(const void *dst, const void *src, unsigned int n);
 extern void *memset(void *s, int c, unsigned int n);
 extern unsigned int crc32(const void *buf, unsigned int size);
+extern unsigned int __crc32(unsigned int crc, const void *buf, unsigned int size);
 
 /*===========================================================================*/
-extern void fio_exit_random_mode(void);
 extern void enable_fio_dma(void);
 
 /*===========================================================================*/
@@ -79,6 +107,7 @@ extern int str_to_hwaddr(const char *, u8 *);
 extern char *strcat(register char *src, register const char *append);
 extern char *strcpy(char *dst, const char *src);
 extern char *strstr(const char *s1, const char *s2, int n);
+extern void hex_to_str(const u32 hex, char *dest);
 
 /*===========================================================================*/
 #define COMMAND_MAGIC	0x436d6420
@@ -105,9 +134,10 @@ typedef struct cmdlist_s
 	}
 
 extern void commands_init(void);
-extern int  parse_command(char *cmdline);
+extern int parse_command(char *cmdline);
+extern int boot_command_program(void *cmdline);
 
-#define MAX_CMDLINE_LEN	1024	/* atag cmdling */
+#define MAX_CMDLINE_LEN	1024
 #define MAX_CMD_ARGS	32
 #define MAX_ARG_LEN	64
 
@@ -121,13 +151,10 @@ extern int netprogram(const char *, int);
 extern void jump_to_kernel(void *, int);
 
 /*===========================================================================*/
-void fdt_print_error(const char *str, int err);
+extern void fdt_print_error(const char *str, int err);
 extern int fdt_update_cmdline(void *fdt, const char *cmdline);
-
 extern u32 fdt_update_tags(void *jump_addr, const char *cmdline, u32 cpux_jump,
 	u32 initrd2_start, u32 initrd2_size, int verbose);
-extern u32 setup_tags(void *jump_addr, const char *cmdline, u32 cpux_jump,
-	u32 initrd2_start, u32 initrd2_size, int verbose);
 
 /*===========================================================================*/
 extern int amboot_bsp_early_init(void)
@@ -146,7 +173,21 @@ extern int amboot_bsp_self_refresh_exit(void)
 extern int amboot_bsp_self_refresh_check_valid(void)
 	__attribute__ ((weak));
 
+#if defined(CONFIG_PANDORA_RTOS)
+extern int amboot_init_pandora_aaa(void* init_aeb)
+	__attribute__ ((weak));
+extern int amboot_update_pandora_aaa(void* pre_aeb)
+	__attribute__ ((weak));
+#endif
+
 /*===========================================================================*/
+
+extern int main(void);
+int dsp_pandora_init(flpart_table_t *ptb);
+void wait_dsp_done(void);
+
+extern void get_permission(void);
+
 #endif
 /*===========================================================================*/
 
diff --git a/src/bld/cmd_adc.c b/src/bld/cmd_adc.c
index 17be2c2..53689e7 100644
--- a/src/bld/cmd_adc.c
+++ b/src/bld/cmd_adc.c
@@ -3,12 +3,30 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -16,7 +34,6 @@
 #include <ambhw/uart.h>
 
 /*===========================================================================*/
-#if (ADC_SUPPORT_SLOT == 1)
 static void diag_adc_set_slot_ctrl(u8 slot_id, u32 slot_value)
 {
 	switch (slot_id) {
@@ -52,16 +69,15 @@ static void diag_adc_set_config(void)
 	int i = 0;
 	int slot_num_reg = 0;
 
-	writel(ADC_CONTROL_REG, (readl(ADC_CONTROL_REG) | ADC_CONTROL_ENABLE));
+	writel(ADC_CONTROL_REG, (readl(ADC_CONTROL_REG) |(ADC_CONTROL_MODE | ADC_CONTROL_ENABLE)));
 	rct_timer_dly_ms(200);
 
 	writel(ADC_SLOT_NUM_REG, 0);//set slot number=1
-	writel(ADC_SLOT_PERIOD_REG, 60);//set slot period 60
 	for (i = 0; i <= slot_num_reg; i++) {
-		diag_adc_set_slot_ctrl(i, 0xfff);//set slot 0 ctrl 0xfff
+		diag_adc_set_slot_ctrl(i, (1 << ADC_NUM_CHANNELS) - 1);//set slot 0 ctrl 0xfff
 	}
+	writel(ADC_SLOT_PERIOD_REG, ADC_NUM_CHANNELS * ADC_PERIOD_CYCLE - 1);//set slot period
 }
-#endif
 
 static void diag_adc(void)
 {
@@ -78,41 +94,40 @@ static void diag_adc(void)
 	writel(SCALER_ADC_REG, ADC_SOFT_RESET | 0x2);
 	writel(SCALER_ADC_REG, 0x2);
 
-#if (ADC_SUPPORT_SLOT == 1)
-	writel(ADC_CONTROL_REG, (readl(ADC_CONTROL_REG) | ADC_CONTROL_RESET));
+	writel(ADC_CONTROL_REG, (readl(ADC_CONTROL_REG) | ADC_CONTROL_CLEAR));
 	diag_adc_set_config();
-#else
-	writel(ADC_ENABLE_REG, 0x1);
-#endif
-
-#if (ADC_CONTROL_TYPE == 0)
-	writel(ADC_CONTROL_REG, 0x0);
-#endif
 
 	writel(ADC_DATA0_REG, 0x0);
 	writel(ADC_DATA1_REG, 0x0);
 	writel(ADC_DATA2_REG, 0x0);
+#if (ADC_NUM_CHANNELS > 3)
 	writel(ADC_DATA3_REG, 0x0);
+#endif
 #if (ADC_NUM_CHANNELS > 4)
 	writel(ADC_DATA4_REG, 0x0);
 #endif
 #if (ADC_NUM_CHANNELS > 5)
 	writel(ADC_DATA5_REG, 0x0);
 #endif
-#if (ADC_NUM_CHANNELS >= 8)
+#if (ADC_NUM_CHANNELS > 6)
 	writel(ADC_DATA6_REG, 0x0);
+#endif
+#if (ADC_NUM_CHANNELS > 7)
 	writel(ADC_DATA7_REG, 0x0);
 #endif
-#if (ADC_NUM_CHANNELS >= 10)
+#if (ADC_NUM_CHANNELS > 8)
 	writel(ADC_DATA8_REG, 0x0);
+#endif
+#if (ADC_NUM_CHANNELS > 9)
 	writel(ADC_DATA9_REG, 0x0);
 #endif
-#if (ADC_NUM_CHANNELS >= 12)
+#if (ADC_NUM_CHANNELS > 10)
 	writel(ADC_DATA10_REG, 0x0);
+#endif
+#if (ADC_NUM_CHANNELS > 11)
 	writel(ADC_DATA11_REG, 0x0);
 #endif
 
-	writel(ADC_CONTROL_REG, (readl(ADC_CONTROL_REG) & (~ADC_CONTROL_MODE)));
 	for (;;) {
 		if (uart_poll()) {
 			c = uart_read();
@@ -123,11 +138,8 @@ static void diag_adc(void)
 		/* ADC control mode, single, start conversion */
 		writel(ADC_CONTROL_REG,
 			(readl(ADC_CONTROL_REG) | ADC_CONTROL_START));
-#if (ADC_CONTROL_TYPE == 1)
-		while ((readl(ADC_STATUS_REG) & ADC_CONTROL_STATUS) == 0x0);
-#else
-		while ((readl(ADC_CONTROL_REG) & ADC_CONTROL_STATUS) == 0x0);
-#endif
+
+		while ((readl(ADC_STATUS_REG) & ADC_STATUS_STATUS) == 0x0);
 
 		rct_timer_dly_ms(200);
 		for (i = 0; i < ADC_NUM_CHANNELS; i++) {
@@ -135,38 +147,36 @@ static void diag_adc(void)
 		}
 
 		/* ADC interface Read from Channel 0, 1, 2, 3 */
-#if (ADC_NUM_CHANNELS == 8)
-		data[0] = (readl(ADC_DATA0_REG) + 0x8000) & 0xffff;
-		data[1] = (readl(ADC_DATA1_REG) + 0x8000) & 0xffff;
-		data[2] = (readl(ADC_DATA2_REG) + 0x8000) & 0xffff;
-		data[3] = (readl(ADC_DATA3_REG) + 0x8000) & 0xffff;
-		data[4] = (readl(ADC_DATA4_REG) + 0x8000) & 0xffff;
-		data[5] = (readl(ADC_DATA5_REG) + 0x8000) & 0xffff;
-		data[6] = (readl(ADC_DATA6_REG) + 0x8000) & 0xffff;
-		data[7] = (readl(ADC_DATA7_REG) + 0x8000) & 0xffff;
-#else
 		data[0] = readl(ADC_DATA0_REG);
 		data[1] = readl(ADC_DATA1_REG);
 		data[2] = readl(ADC_DATA2_REG);
+#if (ADC_NUM_CHANNELS > 3)
 		data[3] = readl(ADC_DATA3_REG);
+#endif
 #if (ADC_NUM_CHANNELS > 4)
 		data[4] = readl(ADC_DATA4_REG);
 #endif
 #if (ADC_NUM_CHANNELS > 5)
 		data[5] = readl(ADC_DATA5_REG);
 #endif
-#if (ADC_NUM_CHANNELS >= 10)
+#if (ADC_NUM_CHANNELS > 6)
 		data[6] = readl(ADC_DATA6_REG);
+#endif
+#if (ADC_NUM_CHANNELS > 7)
 		data[7] = readl(ADC_DATA7_REG);
+#endif
+#if (ADC_NUM_CHANNELS > 8)
 		data[8] = readl(ADC_DATA8_REG);
+#endif
+#if (ADC_NUM_CHANNELS > 9)
 		data[9] = readl(ADC_DATA9_REG);
 #endif
-#if (ADC_NUM_CHANNELS >= 12)
+#if (ADC_NUM_CHANNELS >= 10)
 		data[10] = readl(ADC_DATA10_REG);
-		data[11] = readl(ADC_DATA11_REG);
 #endif
+#if (ADC_NUM_CHANNELS > 11)
+		data[11] = readl(ADC_DATA11_REG);
 #endif
-
 		equal = 1;
 		for (i = 0; i < ADC_NUM_CHANNELS; i++) {
 			if (data[i] != old[i]) {
@@ -179,22 +189,14 @@ static void diag_adc(void)
 			continue;
 		}
 
-		putstr("[");
-		for (i = 0; i < ADC_NUM_CHANNELS; i++) {
-			putdec(data[i]);
-			putstr("] [");
-		}
-		putdec(i);
-		putstr("]          \r");
+		for (i = 0; i < ADC_NUM_CHANNELS; i++)
+			printf("ADC[%d] = 0x%x \n", i, data[i]);
+		printf("---ADC sampling done---\n");
 	}
 
 	writel(ADC_CONTROL_REG, 0x0);
-#if (ADC_CONTROL_TYPE == 1)
 	writel(ADC_CONTROL_REG,
 		(readl(ADC_CONTROL_REG) & (~ADC_CONTROL_ENABLE)));
-#else
-	writel(ADC_ENABLE_REG, 0x0);
-#endif
 	writel(ADC16_CTRL_REG, 0x2);
 
 	putstr("\r\ndone!\r\n");
diff --git a/src/bld/cmd_boot.c b/src/bld/cmd_boot.c
index f28bee8..413d7bb 100644
--- a/src/bld/cmd_boot.c
+++ b/src/bld/cmd_boot.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/08/18 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
diff --git a/src/bld/cmd_erase.c b/src/bld/cmd_erase.c
index c22832c..700d2ab 100644
--- a/src/bld/cmd_erase.c
+++ b/src/bld/cmd_erase.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/08/18 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
diff --git a/src/bld/cmd_fdt.c b/src/bld/cmd_fdt.c
index f89efe9..3f56fec 100644
--- a/src/bld/cmd_fdt.c
+++ b/src/bld/cmd_fdt.c
@@ -4,12 +4,30 @@
  * History:
  *    2013/08/15 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
diff --git a/src/bld/cmd_fs.c b/src/bld/cmd_fs.c
index 63b4a94..75eda1b 100644
--- a/src/bld/cmd_fs.c
+++ b/src/bld/cmd_fs.c
@@ -1,31 +1,61 @@
+/**
+ * bld/cmd_fs.c
+ *
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <bldfunc.h>
 #include "fs/fs.h"
 
 #define AMBARELLA_INTERNAL_CMD 0
 
+static int cmd_fsinit(void)
+{
+	do_fsinit(FS_TYPE_FAT);
+	return 0;
+}
 static int cmd_ls(int argc , char *argv[])
 {
 	do_ls(argc, argv, FS_TYPE_FAT);
-
 	return 0;
 }
 
 static int cmd_cd(int argc , char *argv[])
 {
-
 	if(argc < 2){
 		uart_putstr("Type 'help cd' for help\r\n");
 		return -3;
 	}
-
 	do_chdir(argc, argv, FS_TYPE_FAT);
-
 	return 0;
 }
 
 static int cmd_fsread(int argc , char *argv[])
 {
-
 	u32 addr;
 	u32 exec = 0;
 
@@ -34,13 +64,11 @@ static int cmd_fsread(int argc , char *argv[])
 		return -3;
 	}
 
-
 	if (strtou32(argv[2], &addr) == -1) {
 		uart_putstr("invalid address!\r\n");
 		return -1;
 	}
 
-
 	if(argc == 4){
 		if (strtou32(argv[3], &exec) == -1) {
 			uart_putstr("invalid exec!\r\n");
@@ -52,13 +80,11 @@ static int cmd_fsread(int argc , char *argv[])
 		exec = 0;
 
 	do_fsread(argv[1], addr, FS_TYPE_FAT, (int)exec);
-
 	return 0;
 }
 
 static int cmd_fswrite(int argc , char *argv[])
 {
-
 	u32 addr;
 	u32 size;
 
@@ -67,19 +93,16 @@ static int cmd_fswrite(int argc , char *argv[])
 		return -3;
 	}
 
-
 	if (strtou32(argv[2], &addr) == -1) {
 		uart_putstr("invalid address!\r\n");
 		return -1;
 	}
 
-
 	if (strtou32(argv[3], &size) == -1) {
 		uart_putstr("invalid size!\r\n");
 		return -1;
 	}
 
-
 	do_fswrite(argv[1], addr, FS_TYPE_FAT, size);
 
 	return 0;
@@ -123,14 +146,16 @@ static int cmd_fs(int argc, char *argv[])
 
 	if (strcmp(argv[1], "ls") == 0){
 		ret_val = cmd_ls(argc - 1, &argv[1]);
-	}else if(strcmp(argv[1], "info") == 0){
+	} else if (strcmp(argv[1], "info") == 0) {
 		ret_val = cmd_fsinfo(argc - 1, &argv[1]);
-	}else if(strcmp(argv[1], "cd") == 0){
+	} else if (strcmp(argv[1], "cd") == 0) {
 		ret_val = cmd_cd(argc - 1, &argv[1]);
-	}else if(strcmp(argv[1], "read") == 0){
+	} else if (strcmp(argv[1], "read") == 0) {
 		ret_val = cmd_fsread(argc - 1, &argv[1]);
-	}else if(strcmp(argv[1], "write") == 0){
+	} else if (strcmp(argv[1], "write") == 0) {
 		ret_val = cmd_fswrite(argc - 1, &argv[1]);
+	} else if (strcmp(argv[1], "init") == 0) {
+		ret_val = cmd_fsinit();
 	}
 
 	return ret_val;
@@ -138,7 +163,7 @@ static int cmd_fs(int argc, char *argv[])
 
 static char help_fs[] =
 "\t fs ls\r\n"
-"\t fs info\r\n"
+"\t fs init\r\n"
 "\t fs cd [dir]\r\n"
 "\t fs read [file] [addr] [exec]\r\n"
 "\t fs write [file] [addr] [size]\r\n";
diff --git a/src/bld/cmd_gpio.c b/src/bld/cmd_gpio.c
index 8d52dc3..3589552 100644
--- a/src/bld/cmd_gpio.c
+++ b/src/bld/cmd_gpio.c
@@ -3,12 +3,30 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -56,7 +74,6 @@ static void diag_gpio_diag_pull(int gpio, int val)
 	u32 gpio_pull_en;
 	u32 gpio_pull_dir;
 
-#if (GPIO_PAD_PULL_CTRL_SUPPORT == 1)
 	if ((gpio >= 0) && (gpio < 32)) {
 		gpio_pull_en_base = GPIO_PAD_PULL_REG(GPIO_PAD_PULL_EN_0_OFFSET);
 		gpio_pull_dir_base = GPIO_PAD_PULL_REG(GPIO_PAD_PULL_DIR_0_OFFSET);
@@ -79,7 +96,7 @@ static void diag_gpio_diag_pull(int gpio, int val)
 		gpio_pull_en_base = GPIO_PAD_PULL_REG(GPIO_PAD_PULL_EN_6_OFFSET);
 		gpio_pull_dir_base = GPIO_PAD_PULL_REG(GPIO_PAD_PULL_DIR_6_OFFSET);
 	}
-#endif
+
 	gpio_offset = gpio % 32;
 	switch(val & 0x02) {
 	case 0x02:
diff --git a/src/bld/cmd_help.c b/src/bld/cmd_help.c
index b8df6f2..2590a30 100644
--- a/src/bld/cmd_help.c
+++ b/src/bld/cmd_help.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/08/18 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
diff --git a/src/bld/cmd_hexdump.c b/src/bld/cmd_hexdump.c
new file mode 100644
index 0000000..f4ea2f3
--- /dev/null
+++ b/src/bld/cmd_hexdump.c
@@ -0,0 +1,95 @@
+/**
+ * bld/cmd_hexdump.c
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <bldfunc.h>
+#include <ambhw/drctl.h>
+static void hexdump(unsigned char *p, int len)
+{
+	int i, j;
+
+	for (i = 0; i < len; ) {
+		if (i % 16 == 0) {
+			printf("%08x  ", &p[i]);
+			for (j = 0; j < 16; j++) {
+				printf("%02x ", p[i + j]);
+				if (j == 7)
+					printf(" ");
+			}
+
+			printf(" |");
+
+			for (j = 0; j < 16; j++) {
+				if ((p[i + j] < 127)&&(p[i + j] > 32))
+					printf("%c", p[i + j]);
+				else
+					printf(".");
+			}
+
+			i += j;
+			printf("|\n");
+		}
+	}
+}
+
+static int cmd_hexdump(int argc, char *argv[])
+{
+	u32	addr;
+	u32 len = 16;
+
+	if (argc == 3) {
+		if (strtou32(argv[1], &addr) == -1) {
+			printf("invalid address!\n");
+			return -1;
+		}
+
+		if (strtou32(argv[2], &len) == -1) {
+			printf("invalid len!\n");
+			return -1;
+		}
+		hexdump((unsigned char *)(uintptr_t)addr, len);
+
+	} else if (argc == 2) {
+		if (strtou32(argv[1], &addr) == -1) {
+			printf("invalid address!\n");
+			return -1;
+		}
+		hexdump((unsigned char *)(uintptr_t)addr, len);
+
+	} else {
+		printf("'help hexdump' for show command help\n");
+		return -2;
+	}
+	return 0;
+}
+
+
+static char help_hexdump[] =
+	"hexdump [address] [len]\r\n"
+	"dump data from an address\r\n";
+
+__CMDLIST(cmd_hexdump, "hexdump", help_hexdump);
diff --git a/src/bld/cmd_ir.c b/src/bld/cmd_ir.c
index 54fe9c5..90f998a 100644
--- a/src/bld/cmd_ir.c
+++ b/src/bld/cmd_ir.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/09/25 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
diff --git a/src/bld/cmd_nand.c b/src/bld/cmd_nand.c
index 2a500bd..bc264eb 100644
--- a/src/bld/cmd_nand.c
+++ b/src/bld/cmd_nand.c
@@ -4,12 +4,30 @@
  * History:
  *    2008/11/19 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -27,7 +45,7 @@ static int cmd_nand_show_bb(void)
 	u32 block, blocks, i;
 	u32 init_bad = 0, late_bad = 0, other_bad = 0, total_bad = 0;
 
-	blocks = flnand.blocks_per_bank * flnand.banks;
+	blocks = flnand.blocks_per_bank;
 
 	for (block = 0; block < blocks; block++) {
 		ret_val = nand_is_bad_block(block);
@@ -107,6 +125,83 @@ static int cmd_nand_verify_data(u8* origin, u8* data, u32 len)
 	return err_cnt;
 }
 
+int cmd_nand_test_spare(int argc, char *argv[])
+{
+	u8 bi;
+
+	u32 page_addr, pages, total_pages;
+	u32 block, page, i, j;
+	u8 *wbuf, *srbuf;
+	int rval = 0;
+
+	total_pages = flnand.pages_per_block * flnand.blocks_per_bank;
+
+	if (strtou32(argv[0], &page_addr) < 0) {
+		putstr("invalid page address!\r\n");
+		rval = -1;
+		goto done;
+	}
+
+	if (argc == 1 || strtou32(argv[1], &pages) < 0)
+		pages = 1;
+
+	if (page_addr + pages > total_pages) {
+		putstr("page_addr = 0x");
+		puthex(page_addr);
+		putstr(", pages = 0x");
+		puthex(pages);
+		putstr(", Overflow!\r\n");
+		rval = -1;
+		goto done;
+	}
+
+	wbuf = (u8*)bld_hugebuf_addr;
+	srbuf = (u8*)(bld_hugebuf_addr + flnand.spare_size * pages);
+	memset(wbuf, 0xff, flnand.spare_size * pages);
+
+	putstr("===start to prog spare test=== \r\n");
+	for (i = 0; i < pages; i++) {
+		if (i <= 2){
+			wbuf[0] = AMB_BAD_BLOCK_MARKER;
+		} else {
+			wbuf[0] = 0x3F;
+			wbuf[1] = 0x3F;
+			wbuf[2] = 0x5A;
+			wbuf[3] = 0x5A;
+			wbuf[4] = 0x33;
+			wbuf[5] = 0xAA;
+		}
+		block = (page_addr + i) / flnand.pages_per_block;
+		page = (page_addr + i) % flnand.pages_per_block;
+		rval = nand_prog_spare(block, page, 1, wbuf);
+		printf("ret value is %x \n", rval);
+		putstr("ret value is ");
+			puthex(rval);
+			putstr("\r\n");
+		if (rval < 0) {
+			putstr("write spare area failed \r\n");
+			return rval;
+		}
+
+		rval = nand_read_spare(block, page, 1, srbuf);
+		if (rval < 0) {
+			putstr("read spare data error.\r\n");
+			return rval;
+		}
+
+		printf("===page[%x] ===\n",page_addr + i);
+		for (j = 0; j < 6; j++) {
+			bi = srbuf[j];
+			printf("oob[%8x] = 0x%8x \n", j, bi);
+		}
+		printf("===end page[%x] ===\n", page_addr + i);
+	}
+
+done:
+	putstr("done!\r\n");
+	return rval;
+}
+
 /*===========================================================================*/
 static int cmd_nand_rclm(int argc, char *argv[])
 {
@@ -116,7 +211,7 @@ static int cmd_nand_rclm(int argc, char *argv[])
 	u8 *wbuf, *rbuf, *swbuf, *srbuf;
 	int i, bb_type, c = 0;
 
-	blocks = flnand.blocks_per_bank * flnand.banks;
+	blocks = flnand.blocks_per_bank;
 	block_size = flnand.pages_per_block * flnand.main_size;
 	spa_size = flnand.pages_per_block * flnand.spare_size;
 
@@ -300,13 +395,13 @@ static int cmd_nand_verify(int argc, char *argv[])
 
 	if (strcmp(argv[0], "all") == 0) {
 		start_block = 0;
-		blocks = flnand.blocks_per_bank * flnand.banks;
+		blocks = flnand.blocks_per_bank;
 	} else if (strcmp(argv[0], "free") == 0) {
 		start_block = 0;
 		for (i = 0; i < HAS_IMG_PARTS; i++)
 			start_block += flnand.nblk[i];
 
-		blocks = flnand.blocks_per_bank * flnand.banks - start_block;
+		blocks = flnand.blocks_per_bank - start_block;
 	} else if (strtou32(argv[0], &start_block) == 0) {
 		blocks = 1;
 	} else {
@@ -459,7 +554,7 @@ static int cmd_nand_dump(int argc, char *argv[])
 	u8 *rbuf, *srbuf;
 	int rval = 0;
 
-	total_pages = flnand.pages_per_block * flnand.blocks_per_bank * flnand.banks;
+	total_pages = flnand.pages_per_block * flnand.blocks_per_bank;
 
 	if (strtou32(argv[0], &page_addr) < 0) {
 		putstr("invalid page address!\r\n");
@@ -553,7 +648,7 @@ static int cmd_nand_prog(int argc, char *argv[])
 	u8 *wbuf;
 	int rval = 0;
 
-	total_pages = flnand.pages_per_block * flnand.blocks_per_bank * flnand.banks;
+	total_pages = flnand.pages_per_block * flnand.blocks_per_bank;
 
 	if (strtou32(argv[0], &page_addr) < 0) {
 		putstr("invalid page address!\r\n");
@@ -647,7 +742,7 @@ static int cmd_nand_speed(int argc, char *argv[])
 		for (i = 0; i < HAS_IMG_PARTS; i++)
 			start_block += flnand.nblk[i];
 
-		blocks = flnand.blocks_per_bank * flnand.banks - start_block;
+		blocks = flnand.blocks_per_bank - start_block;
 	} else {
 		if (strtou32(argv[0], &start_block) < 0)
 			return -1;
@@ -689,8 +784,8 @@ static int cmd_nand_speed(int argc, char *argv[])
 	putstr(" Bytes, time = ");
 	putdec(time);
 	putstr("ms, speed = ");
-	putdec((u64)size * 1000/ time);
-	putstr(" Byte/s\r\n");
+	putdec(size / time);
+	putstr(" KB/s\r\n");
 
 	putstr("write...");
 	size = 0;
@@ -721,8 +816,8 @@ static int cmd_nand_speed(int argc, char *argv[])
 	putstr(" Bytes, time = ");
 	putdec(time);
 	putstr("ms, speed = ");
-	putdec((u64)size * 1000/ time);
-	putstr(" Byte/s\r\n");
+	putdec(size / time);
+	putstr(" KB/s\r\n");
 
 	putstr("read...");
 	size = 0;
@@ -754,8 +849,8 @@ static int cmd_nand_speed(int argc, char *argv[])
 	putstr(" Bytes, time = ");
 	putdec(time);
 	putstr("ms, speed = ");
-	putdec((u64)size * 1000/ time);
-	putstr(" Byte/s\r\n");
+	putdec(size / time);
+	putstr(" KB/s\r\n");
 
 	for (i = start_block; i < start_block + blocks; i++) {
 		rval = nand_erase_block(i);
@@ -769,13 +864,88 @@ static int cmd_nand_speed(int argc, char *argv[])
 	return rval;
 }
 
+#if (NAND_CUSTOM_CMD_SUPPORT == 1)
+static int cmd_nand_custom_cmd(int argc, char *argv[])
+{
+	u32 custom_cmd_ctr = 0;
+	u32 cc_rw = 0, cc_wait = 0;
+	u32 cmd_value = 0, cc_addr = 0, cc_bytes = 0;
+	u32 cmd_data = 0;
+	int i;
+
+	cc_wait = NAND_CC_WAIT_RB;
+	if (strcmp(argv[0], "read") == 0) {
+		cc_rw= NAND_CC_RW_RE;
+	} else if (strcmp(argv[0], "write") == 0) {
+		cc_rw= NAND_CC_RW_WE;
+	} else
+		cc_rw = 0;
+
+	if (argc > 1 && strtou32(argv[1], &cmd_value) < 0) {
+		printf("no command value \n");
+		return -1;
+	}
+	if (argc > 2 && strtou32(argv[2], &cc_addr) < 0) {
+		printf("no command address \n");
+		return -1;
+	}
+
+	if (argc > 3 && strtou32(argv[3], &cc_bytes) < 0) {
+		printf("no command data number \n");
+		return -1;
+	}
+
+	if (cc_rw == NAND_CC_RW_WE) {
+		if (argc < 5)
+			return -1;
+		else if (strtou32(argv[4], &cmd_data) < 0)
+			return -1;
+		else
+			writel(NAND_CC_DATA0_REG, cmd_data);
+	}
+
+	if (argc > 2)
+		writel(NAND_COPY_ADDR_REG, cc_addr);  /* reuse copy address register for cc addr */
+
+	writel(NAND_CC_WORD_REG, cmd_value);
+
+	custom_cmd_ctr |= NAND_CC_TERM_CE_HIGH | NAND_CC_CMD1_VAL0 | (1 << 11);
+	custom_cmd_ctr |= cc_rw | cc_wait | (cc_bytes - 1);
+
+	writel(NAND_CC_REG, custom_cmd_ctr);
+
+	{
+		rct_timer2_reset_count();
+
+		while(1) {
+			if (readl(NAND_INT_REG) & NAND_INT_DI)
+				break;
+
+			if (rct_timer2_get_count() >= 1000) {
+				printf("nand cmd timeout \n ");
+				while(1);
+			}
+		}
+
+		writel(NAND_INT_REG, 0x0);
+	}
+
+	if (cc_rw == NAND_CC_RW_RE) {
+		for (i = 0; i <(cc_bytes + 3)/4; i++) {
+			cmd_data = readl(NAND_CC_DATA0_REG + i * 4);
+			printf("custom cmd data is 0x%x \n", cmd_data);
+		}
+	}
+	return 0;
+}
+#endif
 /*===========================================================================*/
 static int cmd_nand(int argc, char *argv[])
 {
 	u32 start_block, block, blocks, total_blocks;
 	int i, ret_val;
 
-	total_blocks = flnand.blocks_per_bank * flnand.banks;
+	total_blocks = flnand.blocks_per_bank;
 
 	if (strcmp(argv[1], "show") == 0) {
 		if (strcmp(argv[2], "bb") == 0) {
@@ -814,12 +984,18 @@ static int cmd_nand(int argc, char *argv[])
 		return cmd_nand_dump(argc - 2, &argv[2]);
 	} else if (strcmp(argv[1], "prog") == 0) {
 		return cmd_nand_prog(argc - 2, &argv[2]);
-	} else if (strcmp(argv[1], "speed") == 0) {
+	} else if (strcmp(argv[1], "progspare") == 0) {
+		return cmd_nand_test_spare(argc - 2, &argv[2]);
+	}	else if (strcmp(argv[1], "speed") == 0) {
 		return cmd_nand_speed(argc - 2, &argv[2]);
 #if defined(CONFIG_NAND_USE_FLASH_BBT)
 	} else if ((strcmp(argv[1], "erase") == 0) && (strcmp(argv[2], "bbt") == 0)) {
 		return nand_erase_bbt();
 #endif
+#if (NAND_CUSTOM_CMD_SUPPORT == 1)
+	} else if (strcmp(argv[1], "ccmd") == 0) {
+		return cmd_nand_custom_cmd(argc - 2, &argv[2]);
+#endif
 	}
 
 	if (argc < 4) {
@@ -881,6 +1057,10 @@ static char help_nand[] =
 	"nand verify free|all|BLOCK [no_ecc]\r\n"
 	"nand dump PAGE [PAGES] [no_ecc]\r\n"
 	"nand prog PAGE [PAGES] [no_ecc] [BITFLIP]\r\n"
+	"nand progspare PAGE [PAGES]\r\n"
+#if (NAND_CUSTOM_CMD_SUPPORT == 1)
+	"nand ccmd read|write [CMD] [ADDR] [BYTES] [DATA]\r\n"
+#endif
 	"nand speed [free]|[BLOCK BLOCKS]\r\n";
 __CMDLIST(cmd_nand, "nand", help_nand);
 
diff --git a/src/bld/cmd_ping.c b/src/bld/cmd_ping.c
index bfd500f..a8abc79 100644
--- a/src/bld/cmd_ping.c
+++ b/src/bld/cmd_ping.c
@@ -4,12 +4,30 @@
  * History:
  *    2006/10/16 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/cmd_poweroff.c b/src/bld/cmd_poweroff.c
new file mode 100644
index 0000000..1d5fda9
--- /dev/null
+++ b/src/bld/cmd_poweroff.c
@@ -0,0 +1,48 @@
+/**
+ * bld/cmd_poweroff.c
+ *
+ * History:
+ *    2016/11/08 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+
+/*===========================================================================*/
+static int cmd_poweroff(int argc, char *argv[])
+{
+	rct_power_off();
+
+	return 0;
+}
+
+/*===========================================================================*/
+static char help_poweroff[] =
+	"poweroff\r\n"
+	"Power off the chip\r\n";
+__CMDLIST(cmd_poweroff, "poweroff", help_poweroff);
+
diff --git a/src/bld/cmd_r32.c b/src/bld/cmd_r32.c
index 5d3fc2f..1926047 100644
--- a/src/bld/cmd_r32.c
+++ b/src/bld/cmd_r32.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/08/18 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -30,8 +48,10 @@ static int cmd_r32(int argc, char *argv[])
 
 		/* Check memory range */
 		_taddr = addr & 0xf0000000;
-		if (_taddr != AHB_BASE &&
-		    _taddr != APB_BASE &&
+		if (_taddr != AHB_S_BASE &&
+		    _taddr != AHB_N_BASE &&
+		    _taddr != APB_S_BASE &&
+		    _taddr != APB_N_BASE &&
 		    _taddr != (DRAM_PHYS_BASE & 0xf0000000) &&
 		    _taddr != DRAM_START_ADDR &&
 		    (addr < DRAM_START_ADDR || addr > DRAM_START_ADDR + DRAM_SIZE-1)) {
diff --git a/src/bld/cmd_reboot.c b/src/bld/cmd_reboot.c
index 792b003..013db5e 100644
--- a/src/bld/cmd_reboot.c
+++ b/src/bld/cmd_reboot.c
@@ -4,18 +4,38 @@
  * History:
  *    2005/10/08 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
 #include <bldfunc.h>
-#if defined(CONFIG_AMBOOT_ENABLE_SPINOR)
+#if defined(CONFIG_AMBOOT_ENABLE_SPINOR) || defined(CONFIG_AMBOOT_ENABLE_SPINAND)
 #include <ambhw/spinor.h>
+#elif defined(CONFIG_BOOT_MEDIA_EMMC)
+#include <sdmmc.h>
 #endif
 /*===========================================================================*/
 static int cmd_reboot(int argc, char *argv[])
@@ -23,6 +43,16 @@ static int cmd_reboot(int argc, char *argv[])
 #if defined(CONFIG_AMBOOT_ENABLE_SPINOR)
 	spinor_flash_reset();
 #endif
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+	spinand_flash_reset();
+#endif
+
+#if defined(CONFIG_BOOT_MEDIA_EMMC)
+	int val;
+	val = sdmmc_command(cmd_0, 0xf0f0f0f0);
+	if(val < 0)
+		putstr("CMD0 is error, can not reboot from EMMC\r\n");
+#endif
 	rct_reset_chip();
 
 	return 0;
diff --git a/src/bld/cmd_sd.c b/src/bld/cmd_sd.c
index 3ad8790..31914fa 100644
--- a/src/bld/cmd_sd.c
+++ b/src/bld/cmd_sd.c
@@ -3,12 +3,30 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -19,7 +37,9 @@
 #define DIAG_SD_BUF_START	bld_hugebuf_addr
 #define SECTORS_PER_OP		128
 #define SECTORS_PER_SHMOO	4096
-
+#if defined(CONFIG_SD_SHMOO_SD_CTL) || defined(CONFIG_SD_SHMOO_PHY_TURNING)
+static u32 send_tuning = 0;
+#endif
 /*===========================================================================*/
 static int cmd_sd_init(int argc, char *argv[], int verbose)
 {
@@ -74,7 +94,7 @@ static int cmd_sd_init(int argc, char *argv[], int verbose)
 
 	ret_val = sdmmc_init_sd(slot, mode, clock, verbose);
 	if (ret_val < 0)
-		ret_val = sdmmc_init_mmc(slot, mode, clock, verbose);
+		ret_val = sdmmc_init_mmc(slot, mode, clock, verbose, 0);
 
 	if (verbose) {
 		putstr("total_secs: ");
@@ -417,7 +437,225 @@ static int cmd_sd_erase(int argc, char *argv[])
 	return ret_val;
 }
 
-#if (SD_SOFT_PHY_SUPPORT == 1)
+#if defined(CONFIG_SD_SHMOO_SD_CTL) || defined(CONFIG_SD_SHMOO_PHY_TURNING)
+static int cmd_sd_tuning(int argc, char *argv[])
+{
+	int ret_val;
+	ret_val = strtou32(argv[0], &send_tuning);
+	if (ret_val < 0) {
+		putstr("Unknown tuning switch!\r\n");
+		return -1;
+	}
+
+	send_tuning = !!send_tuning;
+	if (send_tuning)
+		printf("send-tuning opened\n");
+	else
+		printf("send-tuning closed\n");
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_SD_SHMOO_SD_CTL)
+struct sd_timing_reg {
+	u32 clk_output_mode : 2;
+	u32 clk_output_delay : 3;
+	u32 data_output_delay : 3;
+	u32 sd_delay_sel0;
+	u32 sd_delay_sel1;
+};
+
+struct sd_timing_count {
+	u32 value;
+	int count;
+};
+
+static u32 sd_shmoo_find_best_value(struct sd_timing_count *timing_count, int num)
+{
+	int i;
+	u32 best_value, best_count;
+
+	best_count = timing_count[0].count;
+	best_value = timing_count[0].value;
+	for(i = 0; i < num; i++) {
+		if(timing_count[i].count > best_count) {
+			best_count = timing_count[i].count;
+			best_value = timing_count[i].value;
+		}
+	}
+
+	return best_value;
+}
+
+static int cmd_sd_shmoo(int argc, char *argv[])
+{
+	struct sd_timing_reg timing[256];
+	struct sd_timing_count data_output[8];
+	u32 slot, i, j, num, total_num, sd_delay_sel0, sd_delay_sel1;
+	const char *mode[] = {"ddr50", "sdr104", "sdr50", "sdr25", "sdr12", "hs", "ds"};
+	int ret_val, d0_out, d0_in, cmd_out, cmd_in, clk_mode, clk_delay;
+
+	ret_val = strtou32(argv[0], &slot);
+	if (ret_val < 0) {
+		putstr("Invalid slot id!\r\n");
+		return -1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(mode); i++) {
+		if (strcmp(argv[1], mode[i]) == 0)
+			break;
+	}
+
+	if (i >= ARRAY_SIZE(mode)) {
+		putstr("Unknown mode!\r\n");
+		return -1;
+	}
+
+	putstr("\r\nRunning SD Shmoo for ");
+	putstr(mode[i]);
+	putstr(" ...\r\n");
+
+	i = num = 0;
+	cmd_out = cmd_in = d0_in = 0;
+	total_num = 4 * 8 * 8;
+	memset(timing, 0, sizeof(struct sd_timing_reg) * total_num);
+	memset(data_output, 0, sizeof(struct sd_timing_count) * 8);
+
+	for(clk_mode = 0; clk_mode < 4; clk_mode++) {
+		for(clk_delay = 0; clk_delay < 8; clk_delay++) {
+			for(d0_out = 0; d0_out < 8; d0_out++) {
+				/*user abort*/
+				if (uart_poll()) {
+					putstr("\r\n!!! Abort by User !!!\r\n");
+					goto __done;
+				}
+
+				ret_val = cmd_sd_init(argc, argv, 0);
+				if(ret_val < 0) {
+					break;
+				}
+				sd_delay_sel0 = cmd_in | (cmd_out << 3) | (d0_out << 9) |
+						(d0_out << 15) | (d0_out << 21) |
+						(d0_out << 27) | (d0_in << 6) |
+						(d0_in << 12) | (d0_in << 18) |
+						(d0_in << 24) | ((d0_in & 0x3) << 30);
+				sd_delay_sel1 = (clk_mode << 25) | (clk_delay << 22) |
+						(d0_out << 1) | (d0_out << 7) |
+						(d0_out << 13) | (d0_out << 19) |
+						(d0_in >> 2) | (d0_in << 4) |
+						(d0_in << 10) | (d0_in << 16);
+				writel(SD_BASE(slot) + SD_DELAY_SEL_L, sd_delay_sel0);
+				writel(SD_BASE(slot) + SD_DELAY_SEL_H, sd_delay_sel1);
+
+				if (send_tuning)
+					ret_val = sdmmc_send_tuning();
+				/* Except DDR50, SDR50 and SDR104, all other modes are using
+				 * write-and-read to verify the device */
+				if(!send_tuning || ret_val == 1)
+					ret_val = cmd_sd_verify(argc, argv, 1, 0);
+
+				if(ret_val == 0) {
+					/* Shmoo successfully */
+					timing[num].data_output_delay = d0_out;
+					timing[num].clk_output_delay = clk_delay;
+					timing[num].clk_output_mode = clk_mode;
+					timing[num].sd_delay_sel0 = sd_delay_sel0;
+					timing[num].sd_delay_sel1 = sd_delay_sel1;
+					num++;
+				}
+
+				putchar('.');
+
+				if ((i++ & 0xf) == 0xf) {
+					putchar(' ');
+					putdec(i);
+					putchar('/');
+					putdec(total_num);
+					putstr(" (");
+					putdec(i * 100 / total_num);
+					putstr("%) [");
+					putdec(num);
+					putstr("]\r");
+				}
+
+			}
+		}
+	}
+__done:
+
+	putstr("\r\nValid delay timing: \r\n");
+	for(i =0; i < num; i++) {
+		putstr("\r\nclk_mode:");
+		putdec(timing[i].clk_output_mode);
+		putstr(" clk_delay:");
+		putdec(timing[i].clk_output_delay);
+		putstr(" data_out:");
+		putdec(timing[i].data_output_delay);
+	}
+
+	putstr("\r\n\r\nValid value for SD Controller 0xD8 and 0xDC:\r\n");
+	for(i =0; i < num; i++) {
+		putstr("CTRL_L: 0x");
+		puthex(timing[i].sd_delay_sel0);
+		putstrhex(" CTRL_H: 0x", timing[i].sd_delay_sel1);
+	}
+
+	putstrdec("\r\nThe num of sucessful: ", num);
+
+	if(num) {
+		/*Try to find the best value for every timing*/
+		for (i = 0; i < 4; i++) {
+			data_output[i].value = i;
+			data_output[i].count = 0;
+			for (j = 0; j < num; j++) {
+				if (timing[j].clk_output_mode == i)
+					data_output[i].count++;
+			}
+		}
+
+		clk_mode = sd_shmoo_find_best_value(data_output, 4);
+
+		for (i = 0; i < 8; i++) {
+			data_output[i].value = i;
+			data_output[i].count = 0;
+			for (j = 0; j < num; j++) {
+				if (timing[j].clk_output_delay == i)
+					data_output[i].count++;
+			}
+		}
+
+		clk_delay = sd_shmoo_find_best_value(data_output, 8);
+
+		for (i = 0; i < 8; i++) {
+			data_output[i].value = i;
+			data_output[i].count = 0;
+			for (j = 0; j < num; j++) {
+				if (timing[j].data_output_delay == i)
+					data_output[i].count++;
+			}
+		}
+
+		d0_out = sd_shmoo_find_best_value(data_output, 8);
+
+		/*Calculate the best value*/
+		sd_delay_sel0 = cmd_in | (cmd_out << 3) | (d0_out << 9) | (d0_out << 15) |
+				(d0_out << 21) | (d0_out << 27) | (d0_in << 6) | (d0_in << 12) |
+				(d0_in << 18) | (d0_in << 24) | ((d0_in & 0x3) << 30);
+		sd_delay_sel1 = (clk_mode << 25) | (clk_delay << 22) | (d0_out << 1) |
+				(d0_out << 7) | (d0_out << 13) | (d0_out << 19) | (d0_in >> 2) |
+				(d0_in << 4) | (d0_in << 10) | (d0_in << 16);
+
+
+		putstr("\r\nThe best timing:");
+		putstr("\r\nCTRL_L: 0x");
+		puthex(sd_delay_sel0);
+		putstrhex(" CTRL_H: 0x", sd_delay_sel1);
+	}
+
+	return 0;
+}
+
+#elif defined(CONFIG_SD_SHMOO_PHY_TURNING)
 
 struct sd_timing_reg {
 	u32 sd_phy0_reg;
@@ -428,7 +666,7 @@ struct sd_timing_reg {
 static int cmd_sd_shmoo(int argc, char *argv[])
 {
 	u32 phy0, phy1, ncr_reg, reg;
-	u32 slot, i, num;
+	u32 slot, i, num, phy_ctrl_0_reg, phy_ctrl_1_reg;
 	const char *mode[] = {"ddr50", "sdr104", "sdr50", "sdr25", "sdr12", "hs", "ds"};
 	int ret_val;
 
@@ -448,16 +686,31 @@ static int cmd_sd_shmoo(int argc, char *argv[])
 		return -1;
 	}
 
+	/*select the timing contorller based on different slot*/
+	if(slot == 2) {
+#if (SDXC_SOFT_PHY_SUPPORT == 1)
+		phy_ctrl_0_reg = SDXC_PHY_CTRL_0_REG;
+		phy_ctrl_1_reg = SDXC_PHY_CTRL_1_REG;
+#else
+		putstr("Now our chip can not support slot[2] timing tuning.");
+		putstr("\r\n");
+
+		return -1;
+#endif
+	} else if(slot == 1) {
+		/*reserved*/
+		putstr("Now our chip can not support slot[1] timing tuning.");
+		putstr("\r\n");
+		return -1;
+	} else {
+		phy_ctrl_0_reg = SD_PHY_CTRL_0_REG;
+		phy_ctrl_1_reg = SD_PHY_CTRL_1_REG;
+	}
+
 	putstr("\r\nRunning SD Shmoo for ");
 	putstr(mode[i]);
 	putstr(" ...\r\n");
 
-	ret_val = cmd_sd_init(argc, argv, 0);
-	if(ret_val < 0) {
-		putstr("Shmoo: init sd card is fail\r\n");
-		return 0;
-	}
-
 	memset(timing, 0, sizeof(timing));
 	i = num = 0;
 
@@ -466,27 +719,36 @@ static int cmd_sd_shmoo(int argc, char *argv[])
 	for(phy0 = 0; phy0 < 32; phy0++) {
 		for (phy1 = 0x00000000; phy1 < 0x20202020; phy1 += 0x0f0f0f0f) {
 			for (ncr_reg = 0x0000; ncr_reg < 0x3333; ncr_reg += 0x1111) {
+				ret_val = cmd_sd_init(argc, argv, 0);
+				if(ret_val < 0) {
+					break;
+				}
 				reg = 0x1;
 				reg |= ((phy0 >> 0) & 0x3) << 1;   /* sbc */
 				reg |= ((phy0 >> 2) & 0x1) << 18; /* sd_data_cmd_bypass */
 				reg |= ((phy0 >> 3) & 0x1) << 19; /* sd_rx_clk_pol */
 				reg |= ((phy0 >> 4) & 0x1) << 26; /* sd_clkout_bypass */
 
-				writel(SD_PHY_CTRL_0_REG, reg | 0x02000000);
+				writel(phy_ctrl_0_reg, reg | 0x02000000);
 				rct_timer_dly_ms(2);
-				writel(SD_PHY_CTRL_0_REG, reg);
+				writel(phy_ctrl_0_reg, reg);
 				rct_timer_dly_ms(2);
-				writel(SD_PHY_CTRL_1_REG, phy1);
+				writel(phy_ctrl_1_reg, phy1);
 
 				writel(SD_BASE(slot) + SD_LAT_CTRL_OFFSET, ncr_reg);
 
-				/*begin to verify data*/
-				ret_val = cmd_sd_verify(argc, argv, 1, 0);
+				if (send_tuning)
+					ret_val = sdmmc_send_tuning();
+				/* Except DDR50, SDR50 and SDR104, all other modes are using
+				 * write-and-read to verify the device */
+				if(!send_tuning || ret_val == 1)
+					ret_val = cmd_sd_verify(argc, argv, 1, 0);
+
 				if(ret_val == 0) {
 					timing[num].sd_phy0_reg =
-						readl(SD_PHY_CTRL_0_REG);
+						readl(phy_ctrl_0_reg);
 					timing[num].sd_phy1_reg =
-						readl(SD_PHY_CTRL_1_REG);
+						readl(phy_ctrl_1_reg);
 					timing[num].sd_ncr_reg =
 						readl(SD_BASE(slot) + SD_LAT_CTRL_OFFSET);
 					num++;
@@ -535,7 +797,6 @@ __done:
 
 	return 0;
 }
-
 #endif
 /*===========================================================================*/
 static int cmd_sd(int argc, char *argv[])
@@ -555,9 +816,11 @@ static int cmd_sd(int argc, char *argv[])
 		ret_val = cmd_sd_verify(argc - 2, &argv[2], 0, 1);
 	} else if (strcmp(argv[1], "erase") == 0) {
 		ret_val = cmd_sd_erase(argc - 2, &argv[2]);
-#if (SD_SOFT_PHY_SUPPORT == 1)
+#if defined(CONFIG_SD_SHMOO_SD_CTL) || defined(CONFIG_SD_SHMOO_PHY_TURNING)
 	} else if (strcmp(argv[1], "shmoo") == 0) {
 		ret_val = cmd_sd_shmoo(argc - 2, &argv[2]);
+	} else if (strcmp(argv[1], "tuning") == 0) {
+		ret_val = cmd_sd_tuning(argc - 2, &argv[2]);
 #endif
 	} else if (strcmp(argv[1], "show") == 0) {
 		ret_val = cmd_sd_show(argc - 2, &argv[2]);
@@ -576,8 +839,9 @@ static char help_sd[] =
 	"\tsd write slot [mode] [clock]\r\n"
 	"\tsd verify slot [mode] [clock]\r\n"
 	"\tsd erase slot [ssec] [nsec]\r\n"
-#if (SD_SOFT_PHY_SUPPORT == 1)
-	"\tsd shmoo slot [mode] [clock]\r\n"
+#if defined(CONFIG_SD_SHMOO_SD_CTL) || defined(CONFIG_SD_SHMOO_PHY_TURNING)
+	"\tsd tuning [mode] ; # shmoo test with send-tuning\r\n"
+	"\tsd shmoo slot [mode] [clock] \r\n"
 #endif
 	"\tsd show partition/info\r\n"
 	"Test SD.\r\n";
diff --git a/src/bld/cmd_setenv.c b/src/bld/cmd_setenv.c
index abc33a3..44a1983 100644
--- a/src/bld/cmd_setenv.c
+++ b/src/bld/cmd_setenv.c
@@ -4,12 +4,30 @@
  * History:
  *    2006/10/16 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2006, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -297,11 +315,11 @@ static int cmd_setenv(int argc, char *argv[])
 	} else if (strcmp(argv[1], "boot_opt") == 0) {
 		int yes = 0;
 
-		if (strcmp(argv[2], "1") == 0)
+		if (strcmp(argv[2], "1") == 0) {
 			yes = 1;
-
-		else if (strcmp(argv[2], "2") == 0)
+		} else if (strcmp(argv[2], "2") == 0) {
 			yes = 2;
+		}
 
 		/* Read the partition table */
 		rval = flprog_get_part_table(&ptb);
@@ -318,6 +336,23 @@ static int cmd_setenv(int argc, char *argv[])
 			putstr("PTB save error!\r\n");
 			return rval;
 		}
+
+	} else if (strcmp(argv[1], "bootcmd") == 0) {
+
+		char bootcmd[BOOT_COMMAND_MAX];
+		rval = flprog_get_part_table(&ptb);
+		if (rval < 0) {
+			putstr("PTB load error!\r\n");
+			return rval;
+		}
+
+		if (argc > 2)
+			strfromargv(bootcmd, sizeof(bootcmd), argc - 2, &argv[2]);
+		else
+			return rval;
+
+		flprog_bootcmd_enable(&ptb, bootcmd);
+
 	} else if ((strcmp(argv[1], "eth") == 0) ||
 			(strcmp(argv[1], "wifi") == 0) ||
 			(strcmp(argv[1], "usb") == 0)) {
@@ -616,7 +651,8 @@ static char help_setenv[] =
 	"setenv [param] [val]\r\n"
 	"sn        - Serial number\r\n"
 	"auto_boot - Automatic boot\r\n"
-	"boot_opt - boot option for bios\r\n"
+	"boot_opt  - boot option for bios\r\n"
+	"bootcmd   - boot command for bios\r\n"
 	"splash_id - splash logo id\r\n"
 	"[eth|wifi|usb] [0|1] [mac|ip|mask|gw]\r\n"
 	"\t - [device] [instances] [mac addr|IP addr|network mask|gateway]\r\n"
diff --git a/src/bld/cmd_setmem.c b/src/bld/cmd_setmem.c
index fdad031..7bb847b 100644
--- a/src/bld/cmd_setmem.c
+++ b/src/bld/cmd_setmem.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/08/18 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -20,29 +38,23 @@ typedef unsigned long volatile ulv;
 typedef unsigned char volatile u8v;
 typedef unsigned short volatile u16v;
 
-static int check_address(u32 start, u32 end)
+static int check_address(uintptr_t start, uintptr_t end)
 {
         int rval = -1;
 
         if ((start < DRAM_START_ADDR) ||
             (end > DRAM_END_ADDR)) {
-        	uart_putstr("address out of range\r\n");
-                uart_putstr("DRAM start from 0x");
-                uart_puthex(DRAM_START_ADDR);
-                uart_putstr(" to 0x");
-                uart_puthex(DRAM_END_ADDR);
-                uart_putstr("\r\n");
+                printf("address out of range: 0x%08x - 0x%08x\n", start, end);
+                printf("DRAM start from 0x%08x to 0x%08x\n",
+				DRAM_START_ADDR, DRAM_END_ADDR);
         	return rval;
         }else if (((start >= AMBOOT_BLD_RAM_START) &&
                   (end <= AMBOOT_BLD_RAM_MAX_END)) ||
                   ((start <= AMBOOT_BLD_RAM_START) &&
                   (end >= AMBOOT_BLD_RAM_MAX_END))){
-                uart_putstr("test DRAM include bld \r\n");
-                uart_putstr("bld start from 0x");
-                uart_puthex(AMBOOT_BLD_RAM_START);
-                uart_putstr(" to 0x");
-                uart_puthex(AMBOOT_BLD_RAM_MAX_END);
-                uart_putstr("\r\n");
+                printf("test DRAM include bld: 0x%08x - 0x%08x\n", start, end);
+                printf("bld start from 0x%08x to 0x%08x\n",
+				AMBOOT_BLD_RAM_START, AMBOOT_BLD_RAM_MAX_END);
                 return rval;
         }
 
@@ -50,7 +62,7 @@ static int check_address(u32 start, u32 end)
         return rval;
 }
 
-static int memtest_setmem(u32 saddr, u32 eaddr, u32 val)
+static int memtest_setmem(uintptr_t saddr, uintptr_t eaddr, u32 val)
 {
 	u32	caddr;
 	u32	verify_data;
@@ -169,8 +181,8 @@ int test_bitflip(ulv *bufa, ulv *bufb, ul count) {
 static int cmd_memtest(int argc, char *argv[])
 {
 	u32	val;
-	u32	_saddr;
-	u32	_eaddr;
+	uintptr_t _saddr;
+	uintptr_t _eaddr;
         u32     _size;
         int     rval = -1;
 
@@ -180,13 +192,13 @@ static int cmd_memtest(int argc, char *argv[])
         }
 
 	/* Get starting address */
-	if (strtou32(argv[1], &_saddr) < 0) {
+	if (strtou32(argv[1],(u32 *)&_saddr) < 0) {
 		uart_putstr("invalid start address!\r\n");
 		return rval;
 	}
 
 	/* Get end address */
-	if (strtou32(argv[2], &_size) < 0) {
+	if (strtou32(argv[2], (u32 *)&_size) < 0) {
 		uart_putstr("incorrect ending address\r\n");
 		return rval;
 	}
diff --git a/src/bld/cmd_show.c b/src/bld/cmd_show.c
index e325dab..eeb7ed1 100644
--- a/src/bld/cmd_show.c
+++ b/src/bld/cmd_show.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/08/18 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -89,6 +107,7 @@ static int cmd_show(int argc, char *argv[])
 		putstr("\r\nauto_boot: ");
 		putdec(ptb.dev.auto_boot);
 		putstr("\r\n");
+		printf("bootcmd: %s\n", ptb.dev.bootcmd);
 	} else if (strcmp(argv[1], "meta") == 0) {
 		flprog_show_meta();
 	} else if (strcmp(argv[1], "poc") == 0) {
diff --git a/src/bld/cmd_spinand.c b/src/bld/cmd_spinand.c
new file mode 100644
index 0000000..a11a896
--- /dev/null
+++ b/src/bld/cmd_spinand.c
@@ -0,0 +1,499 @@
+/**
+ * bld/cmd_spinand.c
+ *
+ * History:
+ *    2015/10/26 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <ambhw/uart.h>
+#include <fio/ftl_const.h>
+#include <ambhw/spinor.h>
+
+
+static int cmd_spinand_dump(int argc, char *argv[])
+{
+
+	u32 block, page, i, j, total_pages, page_addr, pages;
+	u8 *rbuf;
+	int rval = 0;
+
+	total_pages = flspinand.chip_size/flspinand.main_size;
+	if (strtou32(argv[0], &page_addr) < 0) {
+		putstr("invalid page address!\r\n");
+		rval = -1;
+		goto done;
+	}
+
+	if (argc == 1 || strtou32(argv[1], &pages) < 0)
+		pages = 1;
+
+	if (page_addr + pages > total_pages) {
+		putstr("page_addr = 0x");
+		puthex(page_addr);
+		putstr(", pages = 0x");
+		puthex(pages);
+		putstr(", Overflow!\r\n");
+		rval = -1;
+		goto done;
+	}
+
+	rbuf = (u8*)bld_hugebuf_addr;
+
+	for (i = 0; i < pages; i++) {
+		block = (page_addr + i) / flspinand.pages_per_block;
+		page = (page_addr + i) % flspinand.pages_per_block;
+
+		if (spinand_is_bad_block(block)) {
+			putstr("block ");
+			putdec(block);
+			putstr(" is a bad block\r\n");
+			continue;
+		}
+
+		rval = spinand_read_pages(block, page, 1, rbuf, 1);
+		if (rval < 0) {
+			putstr("nand_read_pages failed\r\n");
+			goto done;
+		}
+
+		putstr("PAGE[");
+		putdec(page_addr + i);
+		putstr("] main data:\r\n");
+		for (j = 0; j < flspinand.main_size; j++) {
+			putstr(" ");
+			putbyte(rbuf[j]);
+			if ((j+1) % 32 == 0)
+				putstr("\r\n");
+		}
+		putstr("\r\n");
+		rval = spinand_read_spare(block, page, 1, rbuf);
+		if (rval < 0) {
+			putstr("nand_read_pages failed\r\n");
+			goto done;
+		}
+		putstr("PAGE[");
+		putdec(page_addr + i);
+		putstr("] spare data:\r\n");
+		for (j = 0; j < flspinand.spare_size; j++) {
+			putstr(" ");
+			putbyte(rbuf[j]);
+			if ((j+1) % 32 == 0)
+				putstr("\r\n");
+		}
+	}
+
+done:
+	putstr("done!\r\n");
+	return rval;
+}
+
+static int cmd_spinand_verify_data(u8 *origin, u8 *data, u32 len)
+{
+	int err_cnt = 0;
+	u32 i;
+
+	for (i = 0; i < len; i++) {
+		if (origin[i] != data[i]){
+			err_cnt++;
+		}
+	}
+
+	return err_cnt;
+}
+
+static int cmd_spinand_erase(int argc, char *argv[])
+{
+	u32 start_block, block, blocks, total_blocks;;
+	int ret_val = -1;
+	int i = 0;
+
+	if (argc < 2 )
+		return -1;
+
+	total_blocks = flspinand.chip_size/flspinand.block_size;
+	strtou32(argv[0], &start_block);
+	strtou32(argv[1], &blocks);
+	for (i = 0, block = start_block; i < blocks; i++, block++) {
+		if (uart_poll())
+			break;
+		if (block >= total_blocks)
+			break;
+
+		ret_val = spinand_erase_block(block);
+		putchar('.');
+		if ((i & 0xf) == 0xf) {
+			putchar(' ');
+			putdec(i);
+			putchar('/');
+			putdec(blocks);
+			putstr(" (");
+			putdec(i * 100 / blocks);
+			putstr("%)\t\t\r");
+		}
+		if (ret_val < 0) {
+			putstr("\r\nfailed at block ");
+			putdec(block);
+			putstr("\r\n");
+		}
+	}
+
+	putstr("\r\ndone!\r\n");
+
+	return ret_val;
+}
+
+static int cmd_spinand_verify(int argc, char *argv[])
+{
+	int ret_val = -1;
+	u32 start_block, block, blocks;
+	u32 block_size;
+	u32 enable_ecc;
+	u32 bb_num = 0;
+	u8 *wbuf, *rbuf;
+	int i;
+
+	if (argc == 0)
+		return -1;
+
+	putstr("running spinand stress test ...\r\n");
+	putstr("press any key to terminate!\r\n");
+
+	block_size = flspinand.block_size;
+
+	wbuf = (u8 *)bld_hugebuf_addr;
+	rbuf = (u8 *)(bld_hugebuf_addr + flspinand.block_size);
+
+	for (i = 0; i < block_size; i++) {
+		wbuf[i] = rand() / 256;
+	}
+
+	if (strcmp(argv[0], "all") == 0) {
+		start_block = 0;
+		blocks = flspinand.chip_size / flspinand.block_size;
+	} else if (strcmp(argv[0], "free") == 0) {
+		start_block = 0;
+		for (i = 0; i < HAS_IMG_PARTS; i++)
+			start_block += flspinand.nblk[i];
+
+		blocks = flspinand.chip_size / flspinand.block_size - start_block;
+	} else if (strtou32(argv[0], &start_block) == 0) {
+		blocks = 1;
+	} else {
+		return -1;
+	}
+
+	putstr("\r\nstart_block = ");
+	putdec(start_block);
+	putstr(", blocks = ");
+	putdec(blocks);
+	putstr("\r\n\r\n");
+
+	if ((argc >= 2) && (strcmp(argv[1], "no_ecc") == 0))
+		enable_ecc = 0;
+	else
+		enable_ecc = 1;
+
+	for (i = 0, block = start_block; i < blocks; i++, block++) {
+		if (uart_poll())
+			break;
+
+		ret_val = spinand_is_bad_block(block);
+		if (ret_val & NAND_FW_BAD_BLOCK_FLAGS) {
+			spinand_output_bad_block(block, ret_val);
+			bb_num ++;
+			continue;
+		}
+
+		ret_val = spinand_erase_block(block);
+		if (ret_val < 0) {
+			spinand_mark_bad_block(block);
+			putstr("\r\nspinand_erase_block failed\r\n");
+			bb_num ++;
+			goto done;
+		}
+
+		ret_val = spinand_prog_pages(block, 0,
+			flspinand.pages_per_block, wbuf);
+		if (ret_val < 0) {
+			spinand_mark_bad_block(block);
+			putstr("\r\nspinand_prog_pages failed\r\n");
+			bb_num ++;
+			goto done;
+		}
+
+		ret_val = spinand_read_pages(block, 0,
+			flspinand.pages_per_block, rbuf, enable_ecc);
+		if (ret_val < 0) {
+			spinand_mark_bad_block(block);
+			putstr("\r\nspinand_read_pages failed\r\n");
+			bb_num ++;
+			goto done;
+		}
+
+		ret_val = spinand_erase_block(block);
+		if (ret_val < 0) {
+			spinand_mark_bad_block(block);
+			putstr("\r\nnand_erase_block failed\r\n");
+			bb_num ++;
+			goto done;
+		}
+
+		ret_val = cmd_spinand_verify_data(wbuf, rbuf, block_size);
+		if (ret_val != 0) {
+			spinand_mark_bad_block(block);
+			putstr("\r\nnand verify data error count ");
+			putdec(ret_val);
+			ret_val = -1;
+			bb_num ++;
+			goto done;
+		}
+
+		putchar('.');
+
+		if ((i & 0xf) == 0xf) {
+			putchar(' ');
+			putdec(i);
+			putchar('/');
+			putdec(blocks);
+			putstr(" (");
+			putdec(i * 100 / blocks);
+			putstr("%)\t\t\r");
+		}
+
+done:
+		if (ret_val < 0) {
+			putstr("\r\nfailed at block ");
+			putdec(block);
+			putstr("\r\n");
+		}
+	}
+
+	putstr("\r\ntotal bad blocks: ");
+	putdec(bb_num);
+	putstr("\r\n");
+
+	putstr("\r\ndone!\r\n");
+	ret_val = 0;
+
+	return ret_val;
+}
+
+static int cmd_spinand_speed(int argc, char *argv[])
+{
+	u32 start_block, blocks, size, time, i;
+	u8 *buf;
+	int rval = 0;
+
+	if (argc == 0 || !strcmp(argv[0], "free")) {
+		start_block = 0;
+		for (i = 0; i < HAS_IMG_PARTS; i++)
+			start_block += flspinand.nblk[i];
+
+		blocks = flspinand.chip_size / flspinand.block_size- start_block;
+	} else {
+		if (strtou32(argv[0], &start_block) < 0)
+			return -1;
+		if (strtou32(argv[1], &blocks) < 0)
+			return -1;
+	}
+
+	if (start_block == 0 || blocks == 0) {
+		putstr("invalid block!\r\n");
+		return -1;
+	}
+
+	putstr("test nand speed, start_block = ");
+	putdec(start_block);
+	putstr(", blocks = ");
+	putdec(blocks);
+	putstr("\r\n");
+
+	buf = (u8 *)bld_hugebuf_addr;
+
+	putstr("erase...");
+	size = 0;
+	rct_timer_reset_count();
+	for (i = start_block; i < start_block + blocks; i++) {
+		rval = spinand_erase_block(i);
+		if (rval < 0) {
+			spinand_mark_bad_block(i);
+			putstr("nand_erase_block failed\r\n");
+			continue;
+		}
+		size += flspinand.block_size;
+	}
+
+	time = rct_timer_get_count();
+
+	putstr(" done!\r\n");
+	putstr("    size = ");
+	putdec(size);
+	putstr(" Bytes, time = ");
+	putdec(time);
+	putstr("ms, speed = ");
+	putdec(size / time);
+	putstr(" KByte/s\r\n");
+
+	putstr("write...");
+	size = 0;
+	rct_timer_reset_count();
+	for (i = start_block; i < start_block + blocks; i++) {
+		if (spinand_is_bad_block(i)) {
+			putstr("block ");
+			putdec(i);
+			putstr(" is a bad block\r\n");
+			continue;
+		}
+
+		rval = spinand_prog_pages(i, 0, flspinand.pages_per_block, buf);
+		if (rval < 0) {
+			spinand_mark_bad_block(i);
+			putstr("spinand_prog_pages failed\r\n");
+			break;
+		}
+
+		size += flspinand.block_size;
+	}
+
+	time = rct_timer_get_count();
+
+	putstr(" done!\r\n");
+	putstr("    size = ");
+	putdec(size);
+	putstr(" Bytes, time = ");
+	putdec(time);
+	putstr("ms, speed = ");
+	putdec(size / time);
+	putstr(" KByte/s\r\n");
+
+	putstr("read...");
+	size = 0;
+	rct_timer_reset_count();
+	for (i = start_block; i < start_block + blocks; i++) {
+		if (spinand_is_bad_block(i)) {
+			putstr("block ");
+			putdec(i);
+			putstr(" is a bad block\r\n");
+			continue;
+		}
+
+		rval = spinand_read_pages(i, 0,
+			flspinand.pages_per_block, buf, 1);
+		if (rval < 0) {
+			spinand_mark_bad_block(i);
+			putstr("nand_read_pages failed\r\n");
+			break;
+		}
+
+		size += flspinand.block_size;
+	}
+
+	time = rct_timer_get_count();
+
+	putstr(" done!\r\n");
+	putstr("    size = ");
+	putdec(size);
+	putstr(" Bytes, time = ");
+	putdec(time);
+	putstr("ms, speed = ");
+	putdec(size / time);
+	putstr(" KByte/s\r\n");
+
+	for (i = start_block; i < start_block + blocks; i++) {
+		rval = spinand_erase_block(i);
+		if (rval < 0) {
+			spinand_mark_bad_block(i);
+			putstr("nand_erase_block failed\r\n");
+			continue;
+		}
+	}
+
+	return rval;
+}
+
+/*===========================================================================*/
+static int cmd_spinand(int argc, char *argv[])
+{
+	int i;
+
+	if (!strcmp(argv[1], "show")) {
+		if (strcmp(argv[2], "partition") == 0) {
+		putstr("chip size: ");
+		putdec(flspinand.chip_size);
+		putstr(", block size: ");
+		putdec(flspinand.block_size);
+		putstr(", page size: ");
+		putdec(flspinand.main_size);
+		putstr("\r\n");
+		putstr("page per chip: ");
+		putdec(flspinand.pages_per_block);
+		putstr("\r\n");
+		for (i = 0; i < HAS_IMG_PARTS; i++) {
+			putstr(get_part_str(i));
+			putstr(" partition block: ");
+			putdec(flspinand.sblk[i]);
+			putstr(" - ");
+			putdec(flspinand.sblk[i] + flspinand.nblk[i]);
+			putstr("\r\n");
+		}
+		return 0;
+#if defined(CONFIG_SPINAND_USE_FLASH_BBT)
+		} else if (strcmp(argv[2], "bbt") == 0) {
+			return spinand_show_bbt();
+#endif
+		}
+	} else if (!strcmp(argv[1], "dump")) {
+		return cmd_spinand_dump(argc - 2, &argv[2]);
+	} else if (!strcmp(argv[1], "verify")) {
+		return cmd_spinand_verify(argc - 2, &argv[2]);
+	} else if (!strcmp(argv[1], "speed")) {
+		return cmd_spinand_speed(argc - 2, &argv[2]);
+#if defined(CONFIG_SPINAND_USE_FLASH_BBT)
+	} else if ((strcmp(argv[1], "erase") == 0) && (strcmp(argv[2], "bbt") == 0)) {
+		return spinand_erase_bbt();
+#endif
+	} else if ((strcmp(argv[1], "erase") == 0) && (argc == 4)) {
+		return cmd_spinand_erase(argc - 2, &argv[2]);
+	} else {
+		return -2;
+	}
+	return 0;
+}
+
+/*===========================================================================*/
+static char help_spinand[] =
+	"spinand show partition|bbt\r\n"
+	"spinand erase bbt\r\n"
+	"spinand dump PAGE [PAGES]\r\n"
+	"spinand verify free|all|BLOCK \r\n"
+	"spinand erase BLOCK [BLOCKS]\r\n"
+	"spinand speed [free]|[BLOCK BLOCKS]\r\n";
+
+__CMDLIST(cmd_spinand, "spinand", help_spinand);
+
diff --git a/src/bld/cmd_spinor.c b/src/bld/cmd_spinor.c
index 06d7dfc..14ee98b 100644
--- a/src/bld/cmd_spinor.c
+++ b/src/bld/cmd_spinor.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/05/14 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -41,7 +59,7 @@ static int cmd_spinor_dump(int argc, char *argv[])
 
 	rbuf = (u8*)bld_hugebuf_addr;
 
-	if (spinor_read_data(address, rbuf, size) < 0)
+	if (flspinor.read(address, rbuf, size) < 0)
 		return -1;
 
 	for (i = 0; i < size; i++) {
@@ -137,7 +155,7 @@ static int cmd_spinor_verify(int argc, char *argv[])
 			goto done;
 		}
 
-		rval = spinor_read_data(i * flspinor.sector_size,
+		rval = flspinor.read(i * flspinor.sector_size,
 					rbuf, flspinor.sector_size);
 		if (rval < 0) {
 			putstr("read failed. <sector ");
@@ -197,7 +215,7 @@ static int cmd_spinor_speed(int argc, char *argv[])
 {
 	u8 *buf;
 	u32 ssec, nsec, i, time;
-	u64 size;
+	u32 size;
 	int rval = -1;
 
 	ssec = flspinor.ssec[PART_BLD] + flspinor.nsec[PART_BLD];
@@ -232,7 +250,7 @@ static int cmd_spinor_speed(int argc, char *argv[])
 	putstr(" Bytes, time = ");
 	putdec(time);
 	putstr("ms, speed = ");
-	putdec(size * 1000/ time);
+	putdec(size * 1000 / time);
 	putstr(" Byte/s\r\n");
 
 	putstr("write...");
@@ -256,13 +274,13 @@ static int cmd_spinor_speed(int argc, char *argv[])
 	putstr(" Bytes, time = ");
 	putdec(time);
 	putstr("ms, speed = ");
-	putdec(size * 1000/ time);
+	putdec(size * 1000 / time);
 	putstr(" Byte/s\r\n");
 
 	putstr("read...");
 	rct_timer_reset_count();
 	for (i = ssec; i < ssec + nsec; i++) {
-		rval = spinor_read_data(i * flspinor.sector_size,
+		rval = flspinor.read(i * flspinor.sector_size,
 					buf, flspinor.sector_size);
 		if (rval < 0) {
 			putstr("read failed. <sector ");
@@ -280,7 +298,7 @@ static int cmd_spinor_speed(int argc, char *argv[])
 	putstr(" Bytes, time = ");
 	putdec(time);
 	putstr("ms, speed = ");
-	putdec(size * 1000/ time);
+	putdec(size * 1000 / time);
 	putstr(" Byte/s\r\n");
 
 	return 0;
diff --git a/src/bld/cmd_tftp.c b/src/bld/cmd_tftp.c
index 11953fb..bd4d5ec 100644
--- a/src/bld/cmd_tftp.c
+++ b/src/bld/cmd_tftp.c
@@ -3,12 +3,30 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/cmd_thaw.c b/src/bld/cmd_thaw.c
index fdf4312..89ab7da 100644
--- a/src/bld/cmd_thaw.c
+++ b/src/bld/cmd_thaw.c
@@ -1,3 +1,35 @@
+/**
+ * bld/cmd_thaw.c
+ *
+ * History:
+ *    2005/09/27 - [Arthur Yang] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <bldfunc.h>
 
 static int cmd_thaw(int argc, char *argv[])
@@ -6,12 +38,12 @@ static int cmd_thaw(int argc, char *argv[])
 		return -1;
 
 	if(!strcmp(argv[1], "info")){
-		thaw_info();
+		thaw_hibernation_info();
 		return 0;
 	}
 
 	if(!strcmp(argv[1], "load")){
-		thaw_hibernation();
+		thaw_hibernation(0, 1);
 		return 0;
 	}
 	return -1;
diff --git a/src/bld/cmd_usbdl.c b/src/bld/cmd_usbdl.c
index 06592f3..6ec089e 100644
--- a/src/bld/cmd_usbdl.c
+++ b/src/bld/cmd_usbdl.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/09/27 - [Arthur Yang] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -18,7 +36,7 @@
 /*===========================================================================*/
 static int cmd_usbdl(int argc, char *argv[])
 {
-	u32 addr = MEMFWPROG_RAM_START;
+	uintptr_t addr = MEMFWPROG_RAM_START;
 	int len;
 	int flag = 0;
 	int exec = 0;
@@ -50,7 +68,7 @@ static int cmd_usbdl(int argc, char *argv[])
 				}
 			}
 		} else {
-			if ((strtou32(argv[1], &addr) < 0) ||
+			if ((strtou32(argv[1], (u32 *)&addr) < 0) ||
 			    ((addr < DRAM_START_ADDR) ||
 			    (addr > DRAM_START_ADDR + DRAM_SIZE - 1))) {
 				putstr ("Invalid hex address\r\n");
diff --git a/src/bld/cmd_w32.c b/src/bld/cmd_w32.c
index 27c5e53..1e4a54d 100644
--- a/src/bld/cmd_w32.c
+++ b/src/bld/cmd_w32.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/08/18 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -30,10 +48,13 @@ static int cmd_w32(int argc, char *argv[])
 
 		/* Check memory range */
 		_taddr = addr & 0xf0000000;
-		if (_taddr != AHB_BASE &&
-		    _taddr != APB_BASE &&
+		if (_taddr != AHB_S_BASE &&
+		    _taddr != AHB_N_BASE &&
+		    _taddr != APB_S_BASE &&
+		    _taddr != APB_N_BASE &&
 		    _taddr != (DRAM_PHYS_BASE & 0xf0000000) &&
-		    _taddr != DRAM_START_ADDR) {
+		    _taddr != DRAM_START_ADDR &&
+		    (addr < DRAM_START_ADDR || addr > DRAM_START_ADDR + DRAM_SIZE-1)) {
 			uart_putstr("address out of range!\r\n");
 			return -2;
 		}
diff --git a/src/bld/command.c b/src/bld/command.c
index ba9b80c..60cbb4d 100644
--- a/src/bld/command.c
+++ b/src/bld/command.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/07/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -151,4 +169,47 @@ int parse_command(char *cmdline)
 
 	return -3;
 }
+void parse_bootcmd_and_execute(char *bootcmd)
+{
+	int l;
+	char cmdline[BOOT_COMMAND_MAX + 1];
+	char *s0, *s1;
+
+	memset(cmdline , 0 , BOOT_COMMAND_MAX + 1);
+	s0 = s1 = cmdline;
+	l = strlen(bootcmd);
+	if (l <= 0)
+		return ;
+
+	l = l > BOOT_COMMAND_MAX ? BOOT_COMMAND_MAX : l;
+
+	memcpy(cmdline, bootcmd, l);
+
+	while(*s1) {
+		if (*s1 == ';') {
+			*s1 = '\0';
+			if (*s0) {
+				printf("Boot command: %s\n", s0);
+				if (parse_command(s0) != -3) {
+					return;
+				}
+			}
+			s0 = s1 + 1;
+		}
+		s1++;
+	}
+	/* execute last command */
+	if (*s0) {
+		printf("Boot command: %s\n", s0);
+		parse_command(s0);
+	}
+
+}
 
+int boot_command_program(void *bootcmd)
+{
+	commands_init();
+	parse_bootcmd_and_execute(bootcmd);
+
+	return 0;
+}
diff --git a/src/bld/cortex_bld.c b/src/bld/cortex_bld.c
index 63cb7df..fcf7f5c 100644
--- a/src/bld/cortex_bld.c
+++ b/src/bld/cortex_bld.c
@@ -3,258 +3,70 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
-#include <ambhw/vic.h>
+#include <irq.h>
 #include <ambhw/cache.h>
 #include <ambhw/cortex.h>
-#include <ambhw/fio.h>
+#include <ambhw/nand.h>
 #include <eth/network.h>
 
-#if defined(AMBOOT_DEV_BOOT_CORTEX)
-
-/*===========================================================================*/
-#define BOOT_BACKUP_SIZE	(4)
-
-#define CORTEX_BAPI_IRQ		AXI_SOFT_IRQ(0)
-
-/*===========================================================================*/
-static u32 boot_backuped = 0;
-static u32 boot_backup[BOOT_BACKUP_SIZE];
-static u32 *pcortex_start_add = NULL;
-
-/*===========================================================================*/
-static int bld_cortex_load_bootstrap(u32 start_address, int verbose,
-	u32 jump_addr, u32 r0)
+#if defined(__aarch64__)
+void get_permission(void)
 {
-	int ret_val = 0;
-	int i;
-	u32 *pcortex_bsp_add;
-	u32 *psys_bsp_add;
-
-	pcortex_start_add = (u32 *)CORTEX_TO_ARM11(start_address);
-	pcortex_bsp_add = (u32 *)cortex_bst_entry;
-	pcortex_bsp_add = (u32 *)ARM11_TO_CORTEX((u32)pcortex_bsp_add);
-	psys_bsp_add = (u32 *)bld_start;
-
-	if (psys_bsp_add == pcortex_start_add) {
-	} else {
-		if (boot_backuped == 0) {
-			for (i = 0; i < BOOT_BACKUP_SIZE; i++) {
-				boot_backup[i] = pcortex_start_add[i];
-			}
-			boot_backuped = 1;
-		}
-		pcortex_start_add[0] = 0xE59F0000;	//ldr	r0, [pc, #0]
-		pcortex_start_add[1] = 0xE12FFF10;	//bx	r0
-		pcortex_start_add[2] = (u32)pcortex_bsp_add;
-		pcortex_start_add[3] = 0xEAFFFFFB;	//b	start
-		clean_d_cache(pcortex_start_add,
-			(BOOT_BACKUP_SIZE * sizeof(u32)));
-	}
-
-	cortex_processor_start[0] = ARM11_TO_CORTEX(jump_addr);
-	cortex_processor_status[0] = CORTEX_BST_START_COUNTER;
-	*cortex_machine_id = AMBARELLA_LINUX_MACHINE_ID;
-	if (verbose) {
-		putstr("loading jmp: 0x");
-		puthex(start_address);
-		putstr(" size: 0x");
-		puthex(BOOT_BACKUP_SIZE);
-		putstr("\r\n");
-		putstr("BST: 0x");
-		puthex((u32)pcortex_bsp_add);
-		putstr(" size: 0x");
-		puthex((u32)(cortex_bst_end - cortex_bst_entry));
-		putstr("\r\n");
-		putstr("HEAD: 0x");
-		puthex(ARM11_TO_CORTEX((u32)cortex_bst_head));
-		putstr(" size: 0x");
-		puthex((u32)(cortex_bst_end - cortex_bst_head));
-		putstr("\r\n");
-	}
-
-	if (r0) {
-		*cortex_processor0_r0 = r0;
-	}
-
-	if (verbose) {
-		putstr("PROCESSOR_START_0: 0x");
-		puthex(cortex_processor_start[0]);
-		putstr("\r\nMACHINE_ID: 0x");
-		puthex(*cortex_machine_id);
-		putstr("\r\nATAG_DATA: 0x");
-		puthex(*cortex_atag_data);
-		putstr("\r\nPROCESSOR0_R0: 0x");
-		puthex(*cortex_processor0_r0);
-		putstr("\r\n");
-	}
-	clean_d_cache(cortex_bst_head,
-		(u32)(cortex_bst_end - cortex_bst_head));
-
-	return ret_val;
+    writel(0xf000000c, 1);
+    writel(0xf1000008, 3);
+    writel(0xf100000c, 3);
+    writel(0xf1000010, 3);
+    writel(0xf1000014, 3);
 }
-
-static void bld_cortex_pre_init(int verbose,
-	u32 ctrl, u32 ctrl2, u32 ctrl3, u32 frac)
-{
-	u32 cortex_ctl;
-
-	cortex_ctl = readl(AHB_SECURE_REG(0x04));
-	cortex_ctl |= AXI_CORTEX_RESET(0x3);
-	writel(AHB_SECURE_REG(0x04), cortex_ctl);
-	rct_timer_dly_ms(1);
-	cortex_ctl = readl(AHB_SECURE_REG(0x04));
-	cortex_ctl |= AXI_CORTEX_CLOCK(0x3);
-	writel(AHB_SECURE_REG(0x04), cortex_ctl);
-	rct_timer_dly_ms(1);
-	if (ctrl) {
-		ctrl &= ~(0x00200000);
-		writel(PLL_CORTEX_FRAC_REG, frac);
-		rct_timer_dly_ms(1);
-		writel(PLL_CORTEX_CTRL_REG, ctrl);
-		rct_timer_dly_ms(1);
-		writel(PLL_CORTEX_CTRL2_REG, ctrl2);
-		rct_timer_dly_ms(1);
-		writel(PLL_CORTEX_CTRL3_REG, ctrl3);
-		rct_timer_dly_ms(1);
-		writel(PLL_CORTEX_CTRL_REG, (ctrl | 0x01));
-		rct_timer_dly_ms(1);
-		writel(PLL_CORTEX_CTRL_REG, ctrl);
-		rct_timer_dly_ms(1);
-	} else {
-		ctrl = readl(PLL_CORTEX_CTRL_REG);
-		if (ctrl & (0x00200000)) {
-			ctrl &= ~(0x00200000);
-			writel(PLL_CORTEX_CTRL_REG, ctrl);
-			rct_timer_dly_ms(1);
-			writel(PLL_CORTEX_CTRL_REG, (ctrl | 0x01));
-			rct_timer_dly_ms(1);
-			writel(PLL_CORTEX_CTRL_REG, ctrl);
-			rct_timer_dly_ms(1);
-		}
-	}
-	cortex_ctl = readl(AHB_SECURE_REG(0x04));
-	cortex_ctl &= ~(AXI_CORTEX_RESET(0x3));
-	writel(AHB_SECURE_REG(0x04), cortex_ctl);
-	rct_timer_dly_ms(1);
-}
-
-static int bld_cortex_init(int verbose)
+int bld_boot_secondary_cortex(void)
 {
-	u32 cortex_ctl;
-	int i, j;
+#ifndef CONFIG_AARCH64_TRUSTZONE
+	int cpuboot = 0;
 
-	vic_init();
-	vic_sw_clr(CORTEX_BAPI_IRQ);
-	disable_interrupts();
+	cpuboot = readl(CORTEX_RESET_REG);
 
-	if (amboot_bsp_cortex_init_pre != NULL) {
-		amboot_bsp_cortex_init_pre();
-	} else {
-		bld_cortex_pre_init(verbose, 0x00000000,
-			0x00000000, 0x00000000, 0x00000000);
-	}
-	_drain_write_buffer();
-	_clean_flush_all_cache();
+	/* core 1: clear bit 6 */
+	cpuboot &= (~(1 << 6));
 
-	cortex_ctl = readl(AHB_SECURE_REG(0x04));
-	cortex_ctl &= ~(AXI_CORTEX_CLOCK(0x3));
-	writel(AHB_SECURE_REG(0x04), cortex_ctl);
+	/* core 2: clear bit 18 */
+	cpuboot &= (~(1 << 18));
 
-	i = 0;
-	while (1) {
-		if (i > CORTEX_BST_WAIT_LIMIT) {
-			i = 0;
-			cortex_ctl = readl(AHB_SECURE_REG(0x04));
-			if (verbose) {
-				putstr("Timeout: Reset Core0 [0x");
-				puthex(cortex_ctl);
-				putstr("]...\r\n");
-			}
-			cortex_ctl |= AXI_CORTEX_RESET(0x3);
-			writel(AHB_SECURE_REG(0x04), cortex_ctl);
-			for (j = 0; j < 100; j++) {
-				cortex_ctl = readl(AHB_SECURE_REG(0x04));
-			}
-			cortex_ctl |= AXI_CORTEX_CLOCK(0x3);
-			writel(AHB_SECURE_REG(0x04), cortex_ctl);
-			for (j = 0; j < 100; j++) {
-				cortex_ctl = readl(AHB_SECURE_REG(0x04));
-			}
-			cortex_ctl &= ~(AXI_CORTEX_RESET(0x3));
-			writel(AHB_SECURE_REG(0x04), cortex_ctl);
-			for (j = 0; j < 100; j++) {
-				cortex_ctl = readl(AHB_SECURE_REG(0x04));
-			}
-			cortex_ctl &= ~(AXI_CORTEX_CLOCK(0x3));
-			writel(AHB_SECURE_REG(0x04), cortex_ctl);
-		}
-		flush_d_cache(cortex_bst_head,
-			(u32)(cortex_bst_end - cortex_bst_head));
-		if (cortex_processor_status[0] == 0)
-			break;
-		i++;
-	}
+	/* core 3: clear bit 19 */
+	cpuboot &= (~(1 << 19));
 
-#if defined(CONFIG_AMBOOT_BAPI_SUPPORT)
-	vic_set_type(CORTEX_BAPI_IRQ, VIRQ_LEVEL_HIGH);
-	vic_enable(CORTEX_BAPI_IRQ);
-	if (amboot_bsp_cortex_init_post != NULL) {
-		amboot_bsp_cortex_init_post();
-	}
-	_drain_write_buffer();
-	__asm__ __volatile__ ("mov r0, #0" : : : "r0");
-	__asm__ __volatile__ ("mcr p15, 0, r0, c7, c0, 4" : : : "r0"); // wfi
-	vic_sw_clr(CORTEX_BAPI_IRQ);
-	vic_disable(CORTEX_BAPI_IRQ);
-	_flush_d_cache();
-#else
-	__asm__ __volatile__ ("bkpt");
-	__asm__ __volatile__ ("nop");
-	__asm__ __volatile__ ("nop");
-	__asm__ __volatile__ ("nop");
+	writel(CORTEX_RESET_REG, cpuboot);
 #endif
-
-	if (boot_backuped == 1) {
-		for (i = 0; i < BOOT_BACKUP_SIZE; i++) {
-			pcortex_start_add[i] = boot_backup[i];
-		}
-		clean_d_cache(pcortex_start_add,
-			(BOOT_BACKUP_SIZE * sizeof(u32)));
-		_flush_i_cache();
-	}
-
-	enable_interrupts();
-
 	return 0;
 }
 
-/*===========================================================================*/
-int bld_cortex_boot(int verbose, u32 jump_addr)
-{
-	int ret_val;
-
-	ret_val = bld_cortex_load_bootstrap(CORTEX_BOOT_ADDRESS, verbose,
-		jump_addr, 0);
-	if (ret_val) {
-		goto bld_cortex_boot_exit;
-	}
-
-	ret_val = bld_cortex_init(verbose);
-
-bld_cortex_boot_exit:
-	return ret_val;
-}
-
-#elif defined(AMBOOT_BOOT_SECONDARY_CORTEX)
+#else
 
 int bld_boot_secondary_cortex(void)
 {
@@ -320,5 +132,5 @@ int bld_boot_secondary_cortex(void)
 	return 0;
 }
 
-#endif
+#endif /* __aarch64__ */
 
diff --git a/src/bld/crc32.c b/src/bld/crc32.c
index f3f5bfd..dd93522 100644
--- a/src/bld/crc32.c
+++ b/src/bld/crc32.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/01/31 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 /*-
  *  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
@@ -117,3 +135,18 @@ unsigned int crc32(const void *buf, unsigned int size)
         return crc ^ ~0U;
 }
 
+unsigned int __crc32(unsigned int crc, const void *buf, unsigned int size)
+{
+        const unsigned char *p;
+	unsigned int __crc = crc;
+
+        p = buf;
+
+        while (size > 0) {
+                __crc = crc32_tab[(__crc ^ *p++) & 0xff] ^ (__crc >> 8);
+		size--;
+	}
+
+        return __crc ^ ~0U;
+}
+
diff --git a/src/bld/descriptor.h b/src/bld/descriptor.h
index be0abbc..8ae5899 100644
--- a/src/bld/descriptor.h
+++ b/src/bld/descriptor.h
@@ -4,12 +4,30 @@
  * History:
  *    2005/09/07 - [Arthur Yang] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __DESCRIPTOR_H__
diff --git a/src/bld/devfw.lds.cpp b/src/bld/devfw.lds.cpp
index 34172dc..089eb1b 100644
--- a/src/bld/devfw.lds.cpp
+++ b/src/bld/devfw.lds.cpp
@@ -7,12 +7,30 @@
  * History:
  *    2005/02/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
@@ -44,12 +62,12 @@ SECTIONS
 		__END_AMBOOT_BLD_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
 #endif
 
-#if defined(__LINK_SPL__)
-		/* Payload of SPL */
+#if defined(__LINK_ATF__)
+		/* Payload of ATF */
 		. = ALIGN(2048);
-		__BEGIN_SPL_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
-		.temp/splash.fw (.text)
-		__END_SPL_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		__BEGIN_ATF_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
+		.temp/atf.fw (.text)
+		__END_ATF_IMAGE__ = . - __BEGIN_FIRMWARE_IMAGE__;
 #endif
 
 #if defined(__LINK_PBA__)
diff --git a/src/bld/dsp/dsp.c b/src/bld/dsp/dsp.c
index d772bc4..7aaa00e 100644
--- a/src/bld/dsp/dsp.c
+++ b/src/bld/dsp/dsp.c
@@ -4,68 +4,88 @@
  * History:
  *    2014/08/04 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
-#include <basedef.h>
 #include <bldfunc.h>
 #include <ambhw/rct.h>
 #include <dsp/dsp.h>
 
 #if (CHIP_REV == S2L)
 #include "s2l/dsp_arch.c"
+#elif (CHIP_REV == S3L)
+#include "s3l/dsp_arch.c"
+#elif (CHIP_REV == S5L)
+#include "s5l/dsp_arch.c"
 #else
 #error "Not implemented yet"
 #endif
 
-int add_dsp_cmd(void *cmd, u32 size)
-{
-	DSP_HEADER_CMD *cmd_hdr;
-	u32 cmd_ptr;
-
-	dsp_print_cmd(cmd, size);
-
-	cmd_hdr = (DSP_HEADER_CMD *)DSP_CMD_BUF_START;
-
-	cmd_ptr = DSP_CMD_BUF_START + sizeof(DSP_HEADER_CMD) +
-			cmd_hdr->num_cmds * DSP_CMD_SIZE;
-	if ((cmd_ptr + DSP_CMD_SIZE) >= (DSP_CMD_BUF_START + DSP_CMD_BUF_SIZE)) {
-		putstr("cmd buffer is too small!!!\n");
-		BUG_ON(1);
-		return -1;
-	}
-
-	memcpy((u8 *)cmd_ptr, cmd, size);
-	memset((u8 *)cmd_ptr + size, 0, DSP_CMD_SIZE - size);
-
-	cmd_hdr->num_cmds++;
-
-	return 0;
-}
+#if defined(CONFIG_PANDORA_RTOS)
+#include "dsp_pandora.c"
+#endif
 
-int dsp_get_ucode_by_name(struct dspfw_header *hdr, const char *name,
+int dsp_get_bin_by_name(struct dspfw_header *hdr, const char *name,
 		unsigned int *addr, unsigned int *size)
 {
 	int i;
 
-	for (i = 0; i < hdr->total_dsp; i++) {
-		if (strcmp(name, hdr->ucode[i].name))
+	for (i = 0; i < hdr->total_bin; i++) {
+		if (strcmp(name, hdr->bin[i].name))
 			continue;
 
 		if (addr)
-			*addr = (u32)hdr + hdr->ucode[i].offset;
+			*addr = hdr->bin[i].offset;
 		if (size)
-			*size = hdr->ucode[i].size;
+			*size = hdr->bin[i].size;
 		return 0;
 	}
 
 	return -1;
 }
 
+int dsp_get_ucode_mem_by_name(const struct ucode_name_addr *map,
+	int num, const struct ucode_file_info *ucode, unsigned int *mem)
+{
+	int i = 0;
+
+	for (i = 0; i < num; i++) {
+		if (!strcmp(ucode->name, map[i].name)) {
+			if (ucode->post) {
+				*mem = (map[i].addr + ucode->bin_split_offset);
+			} else {
+				*mem = map[i].addr;
+			}
+			return 0;
+		}
+	}
+
+	putstrstr("Unknown ucode name: ", ucode->name);
+	return -1;
+}
+
 static int dsp_get_logo_by_id(struct dspfw_header *hdr, int id,
 		unsigned int *addr, unsigned int *size)
 {
@@ -86,20 +106,54 @@ static int dsp_get_logo_by_id(struct dspfw_header *hdr, int id,
 	}
 
 	if (addr)
-		*addr = (u32)hdr + hdr->logo[id].offset;
+		*addr = hdr->logo[id].offset;
 	if (size)
 		*size = hdr->logo[id].size;
 
 	return 0;
 }
 
-int dsp_init(void)
+static int dsp_load_splash_logo(flpart_table_t *pptb, struct dspfw_header *hdr)
+{
+	int rval = -1;
+	u32 offset = 0, size = 0;
+
+	rval = dsp_get_logo_by_id(hdr, pptb->dev.splash_id, &offset, &size);
+	if (rval >= 0) {
+		memcpy(splash_buf_addr, &hdr->logo[pptb->dev.splash_id],
+				sizeof(struct splash_file_info));
+		bld_loader_load_partition_partial(PART_DSP, offset, size,
+			(uintptr_t)(splash_buf_addr + sizeof(struct splash_file_info)), 0);
+	}
+
+	return rval;
+}
+
+static int dsp_load_audio(struct dspfw_header *hdr)
 {
-	struct dspfw_header *hdr;
-	flpart_table_t ptb;
-	u32 addr, size = 0;
+	int rval = -1;
+	u32 offset = 0, size = 0;
 	u8 *audio_play;
-	int rval;
+
+	rval = dsp_get_bin_by_name(hdr, "start.bin", &offset, &size);
+	if (rval >= 0) {
+		size = min(size, AUDIO_PLAY_MAX_SIZE);
+		audio_play = malloc(size);
+		if (audio_play == NULL) {
+			putstr("audio_play malloc failed!\r\n");
+			return -1;
+		}
+		bld_loader_load_partition_partial(PART_DSP, offset, size, (uintptr_t) audio_play, 0);
+		audio_set_play_size((uintptr_t)audio_play, size);
+	}
+
+	return rval;
+}
+
+int dsp_init_pre(flpart_table_t *pptb)
+{
+	struct dspfw_header *hdr = NULL;
+	int rval = -1;
 
 	/* sanity check */
 	if (IDSP_RAM_START + DSP_BSB_SIZE + DSP_IAVRSVD_SIZE
@@ -110,66 +164,44 @@ int dsp_init(void)
 		return -1;
 	}
 
-	rval = flprog_get_part_table(&ptb);
-	if (rval < 0) {
-		putstr("dsp_init: PTB load error!\r\n");
-		return rval;
-	}
-
-	rval = bld_loader_load_partition(PART_DSP, &ptb, 0);
+	rval = bld_loader_load_partition(PART_DSP, pptb, sizeof(struct dspfw_header), 0);
 	if (rval < 0) {
 		putstr("DSP: Load(PART_DSP) fail!\r\n");
 		return rval;
 	}
 
-	hdr = (struct dspfw_header *)ptb.part[PART_DSP].mem_addr;
+	hdr = (struct dspfw_header *)(unsigned long)pptb->part[PART_DSP].mem_addr;
 	if (hdr->magic != DSPFW_IMG_MAGIC
-		|| hdr->size != ptb.part[PART_DSP].img_len) {
+		|| hdr->size != pptb->part[PART_DSP].img_len) {
 		putstr("DSP: Invalid(PART_DSP)!\r\n");
 		return -1;
 	}
 
-	rval = dsp_get_ucode_by_name(hdr, "orccode.bin", &addr, &size);
-	if (rval >= 0)
-		memcpy((void *)UCODE_ORCCODE_START, (void *)addr, size);
-
-	rval = dsp_get_ucode_by_name(hdr, "orcme.bin", &addr, &size);
-	if (rval >= 0)
-		memcpy((void *)UCODE_ORCME_START, (void *)addr, size);
+	rval = dsp_ucode_pre_load(hdr);
+	rval = dsp_load_splash_logo(pptb, hdr);
+	rval = dsp_load_audio(hdr);
+	rval = dsp_init_data();
 
-	rval = dsp_get_ucode_by_name(hdr, "default_binary.bin", &addr, &size);
-	if (rval >= 0)
-		memcpy((void *)UCODE_DEFAULT_BINARY_START, (void *)addr, size);
+	return rval;
+}
 
-	/* TODO: In fastboot case, load "default_mctf.bin" will cause the first h264 frame corrupt
-	rval = dsp_get_ucode_by_name(hdr, "default_mctf.bin", &addr, &size);
-	if (rval >= 0)
-		memcpy((void *)UCODE_DEFAULT_MCTF_START, (void *)addr, size);
-	*/
+int dsp_init_post(flpart_table_t *pptb)
+{
+	struct dspfw_header *hdr = NULL;
+	int rval = -1;
 
-	rval = dsp_get_logo_by_id(hdr, ptb.dev.splash_id, &addr, &size);
-	if (rval >= 0) {
-		memcpy(splash_buf_addr, &hdr->logo[ptb.dev.splash_id],
-				sizeof(struct splash_file_info));
-		memcpy(splash_buf_addr + sizeof(struct splash_file_info),
-				(void *)addr, size);
+	hdr = (struct dspfw_header *)(unsigned long)pptb->part[PART_DSP].mem_addr;
+	if (hdr->magic != DSPFW_IMG_MAGIC
+		|| hdr->size != pptb->part[PART_DSP].img_len) {
+		putstr("DSP: Invalid(PART_DSP)!\r\n");
+		return -1;
 	}
 
-	rval = dsp_get_ucode_by_name(hdr, "start.bin", &addr, &size);
-	if (rval >= 0) {
-		size = min(size, AUDIO_PLAY_MAX_SIZE);
-
-		audio_play = malloc(size);
-		if (audio_play == NULL) {
-			putstr("audio_play malloc failed!\n");
-			return -1;
-		}
-		memcpy(audio_play, (void *)addr, size);
-		audio_set_play_size((u32)audio_play, size);
+	rval = dsp_ucode_post_load(hdr);
+	if (rval < 0) {
+		putstr("Load ucode me failed\r\n");
 	}
 
-	rval = dsp_init_data();
-
-	return 0;
+	return rval;
 }
 
diff --git a/src/bld/dsp/dsp_pandora.c b/src/bld/dsp/dsp_pandora.c
new file mode 100644
index 0000000..5dd1559
--- /dev/null
+++ b/src/bld/dsp/dsp_pandora.c
@@ -0,0 +1,114 @@
+/**
+ * bld/dsp/dsp_pandora.c
+ *
+ * History:
+ *    2017/03/27 - [Tao Wu] created file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <irq.h>
+#include <pandora.h>
+#include <dsp/dsp.h>
+
+#if (CHIP_REV == S5L)
+#include "s5l/dsp_aaa.c"
+#elif (CHIP_REV == S3L)
+#include "s3l/dsp_aaa.c"
+#elif (CHIP_REV == S2L)
+#include "s2l/dsp_aaa.c"
+#else
+#error "Not implemented yet"
+#endif
+
+static dsp_context_t dsp_cnxt;
+
+static void dsp_vcap_handler(void *data)
+{
+	/* TODO: wake up events */
+	complete_isr(&dsp_cnxt.vcap_comp);
+}
+
+static void dsp_pandora_task(void *arg)
+{
+	request_irq(CODE_VCAP_IRQ, IRQ_RISING_EDGE, dsp_vcap_handler, NULL);
+
+	dsp_pandora_aaa();
+
+	complete(&dsp_cnxt.dsp_comp);
+	pandora_thread_freeze(NULL);
+	for(;;);
+}
+
+static unsigned int is_dsp_work(void)
+{
+	if ((dsp_cnxt.dsp_state == IAV_STATE_PREVIEW) ||
+		(dsp_cnxt.dsp_state == IAV_STATE_ENCODING)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void set_dsp_state(unsigned int dsp_state)
+{
+	dsp_cnxt.dsp_state = dsp_state;
+}
+
+int dsp_pandora_init(flpart_table_t *ptb)
+{
+	int ret = 0;
+	set_dsp_state(IAV_STATE_INIT);
+
+	if (amboot_bsp_entry != NULL) {
+		ret = amboot_bsp_entry(ptb);
+	}
+
+	init_completion(&dsp_cnxt.dsp_comp);
+	init_completion(&dsp_cnxt.vcap_comp);
+
+	if (is_dsp_work()) {
+		pandora_thread_create("dsp", TSKIDLE_PRIORITY + 1, dsp_pandora_task, ptb);
+	} else {
+		/* Other place wait_dsp_done */
+		complete(&dsp_cnxt.dsp_comp);
+	}
+	return ret;
+}
+
+void wait_dsp_vcap(void)
+{
+	if (!wait_for_completion_timeout(&dsp_cnxt.vcap_comp, 1000)) {
+		printf("pandora: wait_dsp_vcap timeout\n");
+	}
+}
+
+void wait_dsp_done(void)
+{
+	if (!wait_for_completion_timeout(&dsp_cnxt.dsp_comp, 2000)) {
+		printf("pandora: wait_dsp_done timeout\n");
+	}
+}
diff --git a/src/bld/dsp/host_dspfw.c b/src/bld/dsp/host_dspfw.c
index fa398d5..1ed7d0c 100644
--- a/src/bld/dsp/host_dspfw.c
+++ b/src/bld/dsp/host_dspfw.c
@@ -1,22 +1,41 @@
 /**
- * prebuild/sys_data/preload_idsp/host_dspfw.c
+ * src/bld/dsp/host_dspfw.c
  *
  * Author: Cao Rongrong <rrcao@ambarella.com>
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <errno.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#include <ctype.h>
 #include <libgen.h>
-#include <dsp/dsp.h>
+#include <dsp/dspfw.h>
 
 #if 0
 #define DSP_HOST_DBG(format, arg...)	fprintf(stdout, format , ## arg)
@@ -26,7 +45,7 @@
 #define DSP_HOST_ERR(format, arg...)	fprintf(stderr, format , ## arg)
 
 #define ARRAY_SIZE(x)		(sizeof(x) / sizeof((x)[0]))
-#define	BIN_ALIAN(x)		(((x) + 3) & ~3);
+#define	BIN_ALIAN(x)		(((x) + 7) & ~7); /* Change to 8 byte align for S2Lm */
 
 struct bmp_file_header
 {
@@ -55,8 +74,6 @@ struct bmp_info_header
 /* ==========================================================================*/
 static int parse_file_type(const char *line, char *filetype)
 {
-	int n = 0;
-
 	*filetype = '\0';
 
 	/* Skip white spaces */
@@ -87,7 +104,7 @@ static int parse_file_type(const char *line, char *filetype)
 static int parse_line(const char *line, char *binname,
 		int bin_argc, char bin_argv[][512])
 {
-	int i, j;
+	int i = 0, j = 0;
 
 	*binname = '\0';
 
@@ -129,8 +146,9 @@ static int parse_line(const char *line, char *binname,
 			line++;
 		}
 
-		if ((*line == '#' || *line == '\0') && i < bin_argc)
-			return -1;
+		if ((*line == '#' || *line == '\0') && i < bin_argc) {
+			return 3;	/* Line has less than allowed # of args */
+		}
 	}
 
 	/* Consume rest of line */
@@ -139,24 +157,24 @@ static int parse_line(const char *line, char *binname,
 	}
 
 	if (*line != '\0' && *line != '#') {
-		return -1;	/* Line has more than allowed # of args */
+		return 4;	/* Line has more than allowed # of args */
 	}
 
 	return 2;
 }
 
 static int fill_bin_file(FILE *foutput, FILE *fbin,
-		struct ucode_file_info *ucode_info, char *binname)
+		struct bin_file_info *bin_info, char *binname)
 {
 	int rval = 0;
-	size_t tmp_size;
+	size_t tmp_size = 0;
 	unsigned char buf[1024];
 
-	snprintf(ucode_info->name, sizeof(ucode_info->name), "%s", binname);
-	ucode_info->size = 0;
-	ucode_info->offset = ftell(foutput);
-	ucode_info->offset = BIN_ALIAN(ucode_info->offset);
-	rval = fseek(foutput, ucode_info->offset, SEEK_SET);
+	snprintf(bin_info->name, sizeof(bin_info->name), "%s", binname);
+	bin_info->size = 0;
+	bin_info->offset = ftell(foutput);
+	bin_info->offset = BIN_ALIAN(bin_info->offset);
+	rval = fseek(foutput, bin_info->offset, SEEK_SET);
 	if (rval < 0) {
 		goto fill_bin_file_exit;
 	}
@@ -169,13 +187,13 @@ static int fill_bin_file(FILE *foutput, FILE *fbin,
 		}
 		rval = fwrite(buf, 1, tmp_size, foutput);
 		if (rval == tmp_size)
-			ucode_info->size += tmp_size;
+			bin_info->size += tmp_size;
 		else
 			rval = -1;
 	} while (rval > 0);
 
-	DSP_HOST_DBG("%s[%d @ 0x%08X]\n", ucode_info->name,
-		ucode_info->size, ucode_info->offset);
+	DSP_HOST_DBG("%s[%d @ 0x%08X]\n", bin_info->name,
+		bin_info->size, bin_info->offset);
 
 fill_bin_file_exit:
 	return rval;
@@ -207,8 +225,8 @@ static int fill_bmp_file(FILE *foutput, FILE *fbin,
 	struct bmp_file_header filehdr;
 	struct bmp_info_header infohdr;
 	unsigned int yuv_clut[SPLASH_CLUT_SIZE];
-	unsigned char *buf, *out_buf;
-	int size, i, flip, rval = 0;
+	unsigned char *buf = NULL, *out_buf = NULL;
+	int size = 0, i = 0, flip = 0, rval = 0;
 
 	splash_info->size = 0;
 	splash_info->offset = ftell(foutput);
@@ -347,9 +365,9 @@ bmp_exit0:
 static int process_bin_file(FILE *fp, FILE *foutput, struct dspfw_header *hdr,
 		char *path, int lineno)
 {
-	FILE *fp_bin;
+	FILE *fp_bin = NULL;
 	char buf[512], binfile[512], binname[512];
-	int rval;
+	int rval = 0;
 
 	for (; fgets(buf, sizeof(buf), fp) != NULL; lineno++) {
 		rval = parse_line(buf, binname, 0, NULL);
@@ -362,10 +380,75 @@ static int process_bin_file(FILE *fp, FILE *foutput, struct dspfw_header *hdr,
 			/* Line is pure comment */
 			continue;
 		}
+		if (hdr->total_bin >= ARRAY_SIZE(hdr->bin)) {
+			DSP_HOST_ERR("Too many bin files! ignore[%s]\n", binname);
+			continue;
+		}
+
+		sprintf(binfile, "%s/%s", path, binname);
+		fp_bin = fopen(binfile, "rb");
+		if (fp_bin == NULL) {
+			DSP_HOST_ERR("Error: unable to open '%s'\n", binfile);
+			return -ENOENT;
+		}
+
+		DSP_HOST_DBG("BIN: process[%s]\n", binfile);
+		rval = fill_bin_file(foutput, fp_bin, &hdr->bin[hdr->total_bin], binname);
+		if (rval < 0) {
+			DSP_HOST_ERR("Error: fill_bin_file(%s) = %d\n",
+				binfile, rval);
+			return -1;
+		}
+
+		hdr->total_bin++;
+		fclose(fp_bin);
+	}
+
+	return 0;
+}
+
+static int process_ucode_file(FILE *fp, FILE *foutput, struct dspfw_header *hdr,
+		char *path, int lineno)
+{
+	FILE *fp_bin = NULL;
+	char buf[512], binfile[512], binname[512], binargv[2][512];
+	int rval = 0;
+	int post = 0;
+	int split = 0;
+	struct ucode_file_info *ucode = NULL;
+	struct ucode_file_info *next_ucode = NULL;
+
+	for (; fgets(buf, sizeof(buf), fp) != NULL; lineno++) {
+		memset(binargv, 0, sizeof(binargv));
+		rval = parse_line(buf, binname, 2, binargv);
+		if (rval < 0) {
+			DSP_HOST_ERR("line %d looks suspicious! ignored...\n",
+				lineno);
+			continue;
+		}
+		if (rval == 0) {
+			/* Line is pure comment */
+			continue;
+		}
 		if (hdr->total_dsp >= ARRAY_SIZE(hdr->ucode)) {
 			DSP_HOST_ERR("Too many ucode files! ignore[%s]\n", binname);
 			continue;
 		}
+		ucode = &hdr->ucode[hdr->total_dsp];
+
+		post = strtoul(binargv[0], NULL, 0);
+		if (post) {
+			ucode->post = 1;
+		} else {
+			ucode->post = 0;
+		}
+
+		split = strtoul(binargv[1], NULL, 0);
+		if (split) {
+			ucode->bin_split_offset = split;
+		} else {
+			ucode->bin_split_offset = 0;
+		}
 
 		sprintf(binfile, "%s/%s", path, binname);
 		fp_bin = fopen(binfile, "rb");
@@ -375,15 +458,39 @@ static int process_bin_file(FILE *fp, FILE *foutput, struct dspfw_header *hdr,
 		}
 
 		DSP_HOST_DBG("UCODE: process[%s]\n", binfile);
-		rval = fill_bin_file(foutput, fp_bin, &hdr->ucode[hdr->total_dsp], binname);
+		rval = fill_bin_file(foutput, fp_bin, (struct bin_file_info *)ucode, binname);
 		if (rval < 0) {
-			DSP_HOST_ERR("Error: fill_bin_file(%s) = %d\n",
+			DSP_HOST_ERR("Error: fill_ucode_file(%s) = %d\n",
 				binfile, rval);
 			return -1;
 		}
 
 		hdr->total_dsp++;
 		fclose(fp_bin);
+
+		/* Splite one ucode into two */
+		if ((!ucode->post) && (ucode->bin_split_offset)) {
+			next_ucode = &hdr->ucode[hdr->total_dsp];
+			memcpy(next_ucode, ucode, sizeof(struct ucode_file_info));
+
+			ucode->size = ucode->bin_split_offset;
+
+			next_ucode->offset = next_ucode->offset + next_ucode->bin_split_offset;
+			next_ucode->size = next_ucode->size - next_ucode->bin_split_offset;
+			next_ucode->post = 1;
+
+			hdr->total_dsp++;
+
+			DSP_HOST_DBG("Filename: %s, offset: %d, size: %d, post: %d, split offset: %d\n",
+				ucode->name, ucode->offset, ucode->size,
+				ucode->post, ucode->bin_split_offset);
+			DSP_HOST_DBG("Filename: %s, offset: %d, size: %d, post: %d, split offset: %d\n",
+				next_ucode->name, next_ucode->offset, next_ucode->size,
+				next_ucode->post, next_ucode->bin_split_offset);
+		} else {
+			DSP_HOST_DBG("Filename: %s, offset: %d, size: %d, post: %d, split offset: %d\n",
+				ucode->name, ucode->offset, ucode->size, ucode->post, ucode->bin_split_offset);
+		}
 	}
 
 	return 0;
@@ -392,10 +499,10 @@ static int process_bin_file(FILE *fp, FILE *foutput, struct dspfw_header *hdr,
 static int process_idspcfg_file(FILE *fp, FILE *foutput, struct dspfw_header *hdr,
 		char *path, int lineno)
 {
-	FILE *fp_bin;
+	FILE *fp_bin = NULL;
 	char buf[512], binfile[512], binname[512], binargv[2][512];
-	int tmp_size, idspcfg_header, idspcfg_offset;
-	int n ,rval;
+	int tmp_size = 0, idspcfg_header = 0, idspcfg_offset = 0;
+	int n = 0, rval = 0;
 
 	for (n = 0; n < hdr->total_dsp; n++) {
 		if (!strcmp(hdr->ucode[n].name, "default_binary.bin"))
@@ -408,6 +515,7 @@ static int process_idspcfg_file(FILE *fp, FILE *foutput, struct dspfw_header *hd
 	}
 
 	for (; fgets(buf, sizeof(buf), fp) != NULL; lineno++) {
+		memset(binargv, 0, sizeof(binargv));
 		rval = parse_line(buf, binname, 2, binargv);
 		if (rval < 0) {
 			DSP_HOST_ERR("Error on IDSPCFG line %d!\n", lineno);
@@ -479,9 +587,9 @@ idspcfg_exit:
 static int process_splash_file(FILE *fp, FILE *foutput, struct dspfw_header *hdr,
 		char *path, int lineno)
 {
-	FILE *fp_bin;
+	FILE *fp_bin = NULL;
 	char buf[512], binfile[512], binname[512];
-	int rval;
+	int rval = 0;
 
 	for (; fgets(buf, sizeof(buf), fp) != NULL; lineno++) {
 		rval = parse_line(buf, binname, 0, NULL);
@@ -525,9 +633,9 @@ static int process_splash_file(FILE *fp, FILE *foutput, struct dspfw_header *hdr
 int main(int argc, char **argv)
 {
 	struct dspfw_header hdr;
-	FILE *fp, *foutput;
-	char *p, path[512], buf[512], filetype[512];
-	int lineno, n, rval = 0;
+	FILE *fp = NULL, *foutput = NULL;
+	char *p = NULL, path[512], buf[512], filetype[512];
+	int lineno = 0, n = 0, rval = 0;
 
 	if (argc < 3) {
 		DSP_HOST_ERR("Usage: %s [dsp.bin] [file list ...]\n", argv[0]);
@@ -578,9 +686,10 @@ int main(int argc, char **argv)
 				break;
 		}
 
-		if (!strncmp(filetype, "bin", 3) || !strncmp(filetype, "ucode", 5)
-			|| !strncmp(filetype, "fastosd", 7)) {
+		if (!strncmp(filetype, "bin", 3) || !strncmp(filetype, "fastosd", 7)) {
 			rval = process_bin_file(fp, foutput, &hdr, path, lineno);
+		} else if (!strncmp(filetype, "ucode", 5)) {
+			rval = process_ucode_file(fp, foutput, &hdr, path, lineno);
 		} else if (!strncmp(filetype, "idspcfg", 7)) {
 			rval = process_idspcfg_file(fp, foutput, &hdr, path, lineno);
 		} else if (!strncmp(filetype, "splash", 6)) {
diff --git a/src/bld/dsp/s2l/dsp_aaa.c b/src/bld/dsp/s2l/dsp_aaa.c
new file mode 100644
index 0000000..132e876
--- /dev/null
+++ b/src/bld/dsp/s2l/dsp_aaa.c
@@ -0,0 +1,247 @@
+/**
+ * bld/dsp/s2l/dsp_aaa.c
+ *
+ * History:
+ *    2017/06/05 - [Hao Qian] created file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <dsp/fb_aaa_ctrl.h>
+
+typedef struct aaa_context_s
+{
+	aaa_output_t aaa_output;
+	unsigned int iso_cfg_addr;
+	unsigned int cmd_seq_num;
+} aaa_context_t;
+
+int clamp(int x, int min, int max)
+{
+	if (x < min) { return min; }
+	if (x > max) { return max; }
+
+	return x;
+}
+
+void convert_dot_12_2_hardware_gain_A7(int mul_dot_12,
+	int *gain, int *shift)
+{
+	*shift = 12;
+	while ((*gain = mul_dot_12 >> (12 - *shift)) > 4095)  { (*shift)--; }
+}
+
+static void fb_aaa_issue_dsp_cmd(aaa_context_t *p_aaa_ctx)
+{
+	video_hiso_config_update_t vcap_set_video_iso_proc_ctrl_cmd;
+
+	memset(&vcap_set_video_iso_proc_ctrl_cmd, 0,sizeof(video_hiso_config_update_t));
+	vcap_set_video_iso_proc_ctrl_cmd.cmd_code = VIDEO_HISO_CONFIG_UPDATE;
+	vcap_set_video_iso_proc_ctrl_cmd.hiso_param_daddr = p_aaa_ctx->iso_cfg_addr;
+	vcap_set_video_iso_proc_ctrl_cmd.loadcfg_type.flag.hiso_config_color_update = 1;
+
+	add_dsp_cmd_seq(&vcap_set_video_iso_proc_ctrl_cmd,
+		sizeof(video_hiso_config_update_t), p_aaa_ctx->cmd_seq_num);
+	clean_cache_dsp_cmd();
+}
+
+static void fb_awb_ctrl(aaa_context_t *p_aaa_ctx)
+{
+	aaa_output_t *p_aaa_output = &p_aaa_ctx->aaa_output;
+	u8 *p_lisocfg = (u8 *)p_aaa_ctx->iso_cfg_addr;
+
+	int gain = 0, shift = 0;
+	u32 wb_gain_r_offset = 192+40+4;
+	u32 wb_gain_ge_offset = 192+40+8;
+	u32 wb_gain_go_offset = 192+40+12;
+	u32 wb_gain_b_offset = 192+40+16;
+	u32 flag_offset = 192+156;
+	u32 dgain = p_aaa_output->dgain;
+	u32 gain_r = (p_aaa_output->wb_gain.r_gain * dgain) >> (12-2);
+	u32 gain_g = (p_aaa_output->wb_gain.g_gain * dgain) >> (12-2);
+	u32 gain_b = (p_aaa_output->wb_gain.b_gain * dgain) >> (12-2);
+
+	convert_dot_12_2_hardware_gain_A7((int)gain_r, &gain, &shift);
+	gain_r = gain << (16 - shift);
+	convert_dot_12_2_hardware_gain_A7((int)gain_g, &gain, &shift);
+	gain_g = gain << (16 - shift);
+	convert_dot_12_2_hardware_gain_A7((int)gain_b, &gain, &shift);
+	gain_b = gain << (16 - shift);
+
+	memcpy((p_lisocfg+wb_gain_r_offset), &gain_r, sizeof(u32));
+	memcpy((p_lisocfg+wb_gain_ge_offset), &gain_g, sizeof(u32));
+	memcpy((p_lisocfg+wb_gain_go_offset), &gain_g, sizeof(u32));
+	memcpy((p_lisocfg+wb_gain_b_offset), &gain_b, sizeof(u32));
+	*(p_lisocfg + flag_offset) |= (1<<1); //wb_gain_update =1
+}
+
+static void fb_ae_ctrl(aaa_context_t *p_aaa_ctx)
+{
+	if (p_aaa_ctx->aaa_output.ae_output_update) {
+		/* defined in boards/bsp/iav/sensor_xxx.c */
+		fb_sensor_ctrl(&p_aaa_ctx->aaa_output);
+		p_aaa_ctx->aaa_output.ae_output_update = 0;
+	}
+}
+
+static void fb_aaa_ctrl(aaa_context_t *p_aaa_ctx)
+{
+	if (p_aaa_ctx->aaa_output.awb_output_update ||
+		p_aaa_ctx->aaa_output.ae_output_update) {
+		fb_awb_ctrl(p_aaa_ctx);
+		fb_aaa_issue_dsp_cmd(p_aaa_ctx);
+	}
+	if (p_aaa_ctx->aaa_output.ae_output_update) {
+		fb_ae_ctrl(p_aaa_ctx);
+	}
+	p_aaa_ctx->aaa_output.awb_output_update = 0;
+	p_aaa_ctx->aaa_output.ae_output_update = 0;
+}
+
+static void fb_aaa_save(aaa_context_t *p_aaa_ctx)
+{
+	aaa_fb_aeb_t pre_aeb;
+	aaa_output_t *p_aaa_output = &p_aaa_ctx->aaa_output;
+
+	pre_aeb.agc = p_aaa_output->agc_index;
+	pre_aeb.b_gain = p_aaa_output->wb_gain.b_gain << 2;
+	pre_aeb.d_gain = p_aaa_output->dgain;
+	pre_aeb.r_gain = p_aaa_output->wb_gain.r_gain << 2;
+	pre_aeb.shutter = p_aaa_output->shutter_row;
+
+	amboot_update_pandora_aaa((void*)&pre_aeb);
+}
+
+static void fb_stream_force_idr(aaa_context_t *p_aaa_ctx, u32 pts)
+{
+	dsp_issue_force_idr_cmd(p_aaa_ctx->cmd_seq_num, pts);
+	clean_cache_dsp_cmd();
+}
+
+void dsp_pandora_aaa(void)
+{
+	/* Change it according to your requirment. More count
+	 * mean more stable aaa, but the time can not longer wait_dsp_event */
+#define MAX_VCAP_COUNT	(30)
+#define PIPE_DEPTH_CNT_DOWN	(2 + 3)
+
+	u8 i, j;
+	u8 force_idr_cnt = 0;
+	u8 force_idr_flag = 0;
+	u8 is_first_frame = 1;
+	int is_aaa_stable = 0;
+	DSP_MSG *msg = NULL;
+	DSP_MSG *curr_msg = NULL;
+	encode_msg_t *encode_msg = NULL;
+	vdsp_info_t *vdsp_info = NULL;
+	aaa_config_info_t aaa_cfg_info;
+	aaa_context_t aaa_ctx;
+	memset(&aaa_cfg_info, 0, sizeof(aaa_config_info_t));
+	memset(&aaa_ctx, 0, sizeof(aaa_context_t));
+
+	/* Call this after prepare_vcap_setup_cmd() */
+	init_iso_cfg_addr(&aaa_ctx.iso_cfg_addr);
+	init_sensor_aaa_param(&aaa_cfg_info);
+	amboot_init_pandora_aaa((void*)&aaa_ctx.aaa_output);
+	//fb_aaa_set_log_level(1);
+
+	for (i = 0; i < MAX_VCAP_COUNT; i++) {
+		wait_dsp_vcap();
+		flush_cache_dsp_msg();
+
+		msg = (DSP_MSG *)(DSP_MSG_BUF_START);
+
+		encode_msg = (encode_msg_t *)msg;
+		curr_msg = msg;
+		aaa_ctx.cmd_seq_num = encode_msg->prev_cmd_seq + 1;
+		vdsp_info = (vdsp_info_t *)(UCODE_CHIP_ID_START + sizeof(u32));
+
+		/* Need clear cmd_num in every vcap interrupt */
+		clear_dsp_cmd_num();
+
+		if (i == 0) {
+			/* issue aaa statis setup dsp cmd after the first vcap interrupt */
+			dsp_issue_liso_cfg_cmd(aaa_ctx.cmd_seq_num);
+			clean_cache_dsp_cmd();
+		}
+		if (force_idr_flag && force_idr_cnt > 0) {
+			force_idr_cnt --;
+		}
+
+		for (j = 0; j < vdsp_info->num_dsp_msgs; ++j, ++curr_msg) {
+			if (curr_msg->msg_code == DSP_STATUS_MSG_ENCODE) {
+				encode_msg = (encode_msg_t *)curr_msg;
+				//printf("yuv_aaa_data_fifo_next 0x%x\n", encode_msg->yuv_aaa_data_fifo_next);
+				//printf("aaa_data_fifo_next 0x%x\n", encode_msg->aaa_data_fifo_next);
+				if (encode_msg->aaa_data_fifo_next && (is_aaa_stable <= 0)) {
+					if (encode_msg->main_y_addr && is_first_frame) {
+						is_first_frame = 0;
+						force_idr_flag = 1;
+						force_idr_cnt = PIPE_DEPTH_CNT_DOWN;
+					}
+					flush_d_cache((void *)encode_msg->aaa_data_fifo_next,
+						CFA_AAA_DATA_BLOCK);
+					is_aaa_stable = fb_aaa_algo((u8 *)encode_msg->aaa_data_fifo_next,NULL,NULL,
+						(u8 *)aaa_ctx.iso_cfg_addr, &aaa_cfg_info, &aaa_ctx.aaa_output);
+					clean_d_cache((void *)aaa_ctx.iso_cfg_addr,
+						FB_ISO_CFG_DATA_SIZE);
+					if (is_aaa_stable < 0) {
+						putstr("dsp aaa algo failed\r\n");
+						break;
+					} else if (is_aaa_stable == 0) {
+						fb_aaa_ctrl(&aaa_ctx);
+					} else if (is_aaa_stable > 0) {
+						fb_aaa_save(&aaa_ctx);
+						printf("dsp aaa algo done at frame [%d]\n", (i+1));
+						if (force_idr_flag) {
+							break;
+						} else {
+							return;
+						}
+					}
+					if (force_idr_flag && force_idr_cnt == 0) {
+						fb_stream_force_idr(&aaa_ctx, encode_msg->sw_pts);
+						force_idr_flag = 0;
+						printf("fb force idr at frame [%d]\n", (i+1));
+					}
+				}
+			}
+		}
+
+		if (force_idr_flag && force_idr_cnt == 0) {
+			fb_stream_force_idr(&aaa_ctx, encode_msg->sw_pts);
+			force_idr_flag = 0;
+			printf("fb delay force idr at frame [%d]\n", (i+1));
+			return;
+		}
+	}
+
+	/* Save context if 3A algo still cannot get stable after N frames. */
+	if (!is_aaa_stable && (i == MAX_VCAP_COUNT)) {
+		fb_aaa_save(&aaa_ctx);
+	}
+}
+
diff --git a/src/bld/dsp/s2l/dsp_arch.c b/src/bld/dsp/s2l/dsp_arch.c
index be777b9..129335a 100644
--- a/src/bld/dsp/s2l/dsp_arch.c
+++ b/src/bld/dsp/s2l/dsp_arch.c
@@ -1,18 +1,37 @@
 /**
- * bld/splash/s2l/dsp.c
+ * bld/dsp/s2l/dsp_arch.c
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <ambhw/cache.h>
 #include <dsp/dsp.h>
+#include <bldfunc.h>
 
 #define S2L_MEMD_OFFSET			(0x150000)
 #define S2L_CODE_OFFSET			(0x160000)
@@ -28,10 +47,12 @@
 #define S2L_DSP_CONFIG_MAIN_REG		(S2L_CODE_BASE + S2L_DSP_CONFIG_MAIN_OFFSET)
 #define S2L_DSP_CONFIG_SUB0_REG		(S2L_MEMD_BASE + S2L_DSP_CONFIG_SUB0_OFFSET)
 
-/*===========================================================================*/
-
-/* defined in dsp_bo.o_shipped */
-extern int bopt_sync(void *arg0, void *arg1, void *arg2, void *arg3);
+/* DO NOT change ucode name */
+struct ucode_name_addr ucode_mem[] = {
+	{"orccode.bin", UCODE_ORCCODE_START},
+	{"orcme.bin", UCODE_ORCME_START},
+	{"default_binary.bin", UCODE_DEFAULT_BINARY_START},
+};
 
 /*===========================================================================*/
 void vin_phy_init(int interface_type)
@@ -62,13 +83,72 @@ void vin_phy_init(int interface_type)
 	}
 }
 
+void vin_phy_init_pre(int interface_type)
+{
+	switch (interface_type) {
+	case SENSOR_PARALLEL_LVCMOS:
+		writel(RCT_REG(0x474), 0x3FFFFFF);
+		putstr_debug("SENSOR_PARALLEL_LVCMOS");
+		break;
+	case SENSOR_MIPI:
+		writel(RCT_REG(0x478), 0x14403);
+		putstr_debug("SENSOR_MIPI");
+		break;
+	case SENSOR_SERIAL_LVDS:
+		writel(RCT_REG(0x474), 0x0);
+		writel(RCT_REG(0x478), 0x145C1);
+		putstr_debug("SENSOR_SERIAL_LVDS");
+		break;
+	default:
+		putstr_debug("Unkown sensor interface type");
+		break;
+	}
+}
+
+void vin_phy_init_post(int interface_type)
+{
+	switch (interface_type) {
+	case SENSOR_PARALLEL_LVCMOS:
+		break;
+	case SENSOR_MIPI:
+		/* add other code to generate 5 ms delay */
+		writel(RCT_REG(0x478), 0x14402);
+		writel(RCT_REG(0x47C), 0x12B4B22F);
+		writel(RCT_REG(0x480), 0x101F); // clk_term_ctrl: 7
+		break;
+	case SENSOR_SERIAL_LVDS:
+		/* add other code to generate 10 ms delay */
+		writel(RCT_REG(0x478), 0x145C0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void show_dram_layout_info(void)
+{
+#ifdef AMBOOT_IAV_STR_DEBUG
+	/* The following info should be exactly same as output by "test_encode --show-dram" */
+	printf("[DRAM Layout info]:\n");
+	printf("     [BSB] Base Address: [0x%08X], Size [0x%08X]\n", DSP_BSB_START, DSP_BSB_SIZE);
+	printf(" [OVERLAY] Base Address: [0x%08X], Size [0x%08X]\n", DSP_OVERLAY_START, DSP_OVERLAY_SIZE);
+	printf(" [IMGPROC] Base Address: [0x%08X]\n", DSP_IMGPROC_START);
+	printf(" [IAVRSVD] Base Address: [0x%08X], Size [0x%08X]\n", DSP_IAVRSVD_START, DSP_IAVRSVD_SIZE);
+	printf(" [FB_DATA] Base Address: [0x%08X], Size [0x%08X]\n", DSP_FASTDATA_START, DSP_FASTDATA_SIZE);
+	printf("[FB_AUDIO] Base Address: [0x%08X], Size [0x%08X]\n", DSP_FASTAUDIO_START, DSP_FASTAUDIO_SIZE);
+	printf("     [DSP] Base Address: [0x%08X], Size [0x%08X]\n", DSP_BUFFER_START, DSP_BUFFER_SIZE);
+	printf("  [DSPLOG] Base Address: [0x%08X], Size [0x%08X]\n", DSP_LOG_START, DSP_LOG_SIZE);
+	printf(" [CMD_BUF] Base Address: [0x%08X], Size [0x%08X]\n", DSP_CMD_BUF_START, DSP_CMD_BUF_START);
+#endif
+}
+
 static int dsp_init_data(void)
 {
 	dsp_init_data_t *init_data = NULL;
 	vdsp_info_t *vdsp_info = NULL;
-	default_enc_binary_data_t *enc_binary_data;
-	DSP_HEADER_CMD *cmd_hdr;
-	u32 *default_cmd;
+	default_enc_binary_data_t *enc_binary_data = NULL;
+	DSP_HEADER_CMD *cmd_hdr = NULL;
+	u32 *ucode_init_data_ptr = NULL;
 
 	/* initialize struct dsp_init_data */
 	init_data = (dsp_init_data_t *)DSP_INIT_DATA_START;
@@ -81,16 +161,12 @@ static int dsp_init_data(void)
 	init_data->cmd_data_size = DSP_CMD_BUF_SIZE;
 	init_data->result_queue_ptr = (u32 *)DSP_MSG_BUF_START;
 	init_data->result_queue_size = DSP_MSG_BUF_SIZE;
-	/* although no default cmd is used, we must assign a non-zero value
-	 * to default_config_ptr, and init the memory to 0, otherwise ucode
-	 * may crash. Stupid ucode.*/
-	default_cmd = (u32 *)(DSP_IAVRSVD_START + DSP_IAVRSVD_SIZE - 128);
-	memset(default_cmd, 0, 128);
-	init_data->default_config_ptr = default_cmd;
-	init_data->default_config_size = 128;
+	init_data->default_config_ptr = (u32 *)DSP_DEF_CMD_BUF_START;
+	init_data->default_config_size = DSP_DEF_CMD_BUF_SIZE;
 	/* setup buffer for dsp running */
 	init_data->DSP_buf_ptr = (u32 *)DSP_BUFFER_START;
 	init_data->DSP_buf_size = DSP_BUFFER_SIZE;
+	init_data->dsp_log_size = DSP_LOG_SIZE;
 	/* misc info */
 	init_data->chip_id_ptr = (u32 *)UCODE_CHIP_ID_START;
 	vdsp_info = (vdsp_info_t *)(UCODE_CHIP_ID_START + sizeof(u32));
@@ -124,14 +200,24 @@ static int dsp_init_data(void)
 	cmd_hdr->cmd_seq_num = 1;
 	cmd_hdr->num_cmds = 0;
 
+	cmd_hdr = (DSP_HEADER_CMD *)DSP_DEF_CMD_BUF_START;
+	cmd_hdr->cmd_seq_num = 1;
+	cmd_hdr->num_cmds = 0;
+
+	ucode_init_data_ptr = (u32 *)UCODE_DSP_INIT_DATA_PTR;
+	*ucode_init_data_ptr = DSP_INIT_DATA_START;
+#ifdef AMBOOT_DSP_LOG_CAPTURE
+	memset((void *)DSP_LOG_START, 0, DSP_LOG_SIZE);
+#endif
 	bopt_sync(init_data, enc_binary_data, NULL, NULL);
 
+	show_dram_layout_info();
+
 	return 0;
 }
 
 int dsp_boot(void)
 {
-
 	/* reset analog/digital mipi phy */
 	writel(DBGBUS_BASE + 0x11801c, 0x30000);
 	// rct_timer_dly_ms(5);
@@ -154,3 +240,185 @@ int dsp_boot(void)
 	return 0;
 }
 
+int dsp_boot_pre(void)
+{
+	/* reset analog/digital mipi phy */
+	writel(DBGBUS_BASE + 0x11801c, 0x30000);
+	// rct_timer_dly_ms(5);
+	writel(DBGBUS_BASE + 0x11801c, 0x0);
+	/* Reset setion 1 */
+	writel(DBGBUS_BASE + 0x11801c, 0x2);
+	// rct_timer_dly_ms(5);
+	writel(DBGBUS_BASE + 0x11801c, 0x0);
+
+	_drain_write_buffer();
+	_clean_flush_all_cache();
+
+	writel(S2L_DSP_DRAM_MAIN_REG, UCODE_ORCCODE_START);
+	writel(S2L_DSP_CONFIG_MAIN_REG, 0xF);
+
+	putstr_debug("dsp_boot_code\r\n");
+	return 0;
+}
+
+int dsp_boot_post(void)
+{
+	_drain_write_buffer();
+	_clean_flush_all_cache();
+
+	writel(S2L_DSP_DRAM_SUB0_REG, UCODE_ORCME_START);
+	writel(S2L_DSP_CONFIG_SUB0_REG, 0xF);
+
+	putstr_debug("dsp_boot_me\r\n");
+	return 0;
+}
+
+int dsp_ucode_pre_load(struct dspfw_header *hdr)
+{
+	int i = 0;
+	int rval = 0;
+	unsigned int mem = 0;
+	struct ucode_file_info *ucode = NULL;
+
+	for (i = 0; i < hdr->total_dsp; i++) {
+		ucode = &hdr->ucode[i];
+		if (!ucode->post) {
+			rval = dsp_get_ucode_mem_by_name(ucode_mem,
+				ARRAY_SIZE(ucode_mem), ucode, &mem);
+			if (rval >= 0) {
+				rval = bld_loader_load_partition_partial(PART_DSP,
+					ucode->offset, ucode->size, mem, 0);
+			}
+		}
+	}
+
+	return rval;
+}
+
+int dsp_ucode_post_load(struct dspfw_header *hdr)
+{
+	int i = 0;
+	int rval = 0;
+	unsigned int mem = 0;
+	struct ucode_file_info *ucode = NULL;
+
+	for (i = (hdr->total_dsp - 1); i >= 0; i--) {
+		ucode = &hdr->ucode[i];
+		if (ucode->post) {
+			rval = dsp_get_ucode_mem_by_name(ucode_mem,
+				ARRAY_SIZE(ucode_mem), ucode, &mem);
+			if (rval >= 0) {
+				rval = bld_loader_load_partition_partial(PART_DSP,
+					ucode->offset, ucode->size, mem, 0);
+			}
+		}
+	}
+	dsp_boot_post();
+
+	return rval;
+}
+
+int add_dsp_cmd(void *cmd, unsigned int size)
+{
+	DSP_HEADER_CMD *cmd_hdr;
+	u32 cmd_ptr;
+
+	dsp_print_cmd(cmd, size);
+
+	cmd_hdr = (DSP_HEADER_CMD *)DSP_DEF_CMD_BUF_START;
+
+	cmd_ptr = DSP_DEF_CMD_BUF_START + sizeof(DSP_HEADER_CMD) +
+			cmd_hdr->num_cmds * DSP_CMD_SIZE;
+	if ((cmd_ptr + DSP_CMD_SIZE) >=
+		(DSP_DEF_CMD_BUF_START + DSP_DEF_CMD_BUF_SIZE)) {
+		putstr("cmd buffer is too small!!!\n");
+		BUG_ON(1);
+		return -1;
+	}
+
+	memcpy((u8 *)cmd_ptr, cmd, size);
+	memset((u8 *)cmd_ptr + size, 0, DSP_CMD_SIZE - size);
+
+	cmd_hdr->num_cmds++;
+
+	return 0;
+}
+
+int add_dsp_cmd_seq(void *cmd, unsigned int size, unsigned int seq_num)
+{
+	DSP_HEADER_CMD *cmd_hdr;
+	u32 cmd_ptr;
+
+	dsp_print_cmd(cmd, size);
+
+	cmd_hdr = (DSP_HEADER_CMD *)DSP_CMD_BUF_START;
+
+	cmd_ptr = DSP_CMD_BUF_START + sizeof(DSP_HEADER_CMD) +
+			cmd_hdr->num_cmds * DSP_CMD_SIZE;
+	if ((cmd_ptr + DSP_CMD_SIZE) >=
+		(DSP_CMD_BUF_START + DSP_CMD_BUF_SIZE)) {
+		putstr("cmd buffer is too small!!!\n");
+		BUG_ON(1);
+		return -1;
+	}
+
+	memcpy((u8 *)cmd_ptr, cmd, size);
+	memset((u8 *)cmd_ptr + size, 0, DSP_CMD_SIZE - size);
+
+	cmd_hdr->cmd_seq_num = seq_num;
+	cmd_hdr->num_cmds++;
+
+	return 0;
+}
+
+void clear_dsp_cmd_num()
+{
+	DSP_HEADER_CMD *cmd_hdr = NULL;
+
+	cmd_hdr = (DSP_HEADER_CMD *)DSP_CMD_BUF_START;
+	cmd_hdr->num_cmds = 0;
+}
+
+/* sync memory to cache before read dsp message */
+void flush_cache_dsp_msg(void)
+{
+	flush_d_cache((void *)DSP_MSG_BUF_START, DSP_MSG_BUF_SIZE);
+}
+
+/* sync cache to memory after issue dsp cmd */
+void clean_cache_dsp_cmd(void)
+{
+	clean_d_cache((void *)DSP_CMD_BUF_START, DSP_CMD_BUF_SIZE);
+}
+
+void dsp_halt(void)
+{
+#define DSP_RESET_OFFSET (0x4)
+#define DSP_SYNC_START_OFFSET (0x101c00)
+#define DSP_SYNC_END_OFFSET (0x101c80)
+
+#define DSP_SYNC_START_REG (DBGBUS_BASE + DSP_SYNC_START_OFFSET)
+#define DSP_SYNC_END_REG (DBGBUS_BASE + DSP_SYNC_END_OFFSET)
+
+	u32 addr = 0;
+
+	/* Suspend all code orc threads */
+	writel(S2L_CODE_BASE, 0xf0);
+	/* Suspend all md orc threads */
+	writel(S2L_MEMD_BASE, 0xf0);
+
+	/* Assuming all the orc threads are now waiting to receive on some sync.
+	 * counter, debug port writes to all result in wakes to all sync */
+	for (addr = DSP_SYNC_START_REG; addr < DSP_SYNC_END_REG; addr += 0x4) {
+		writel(addr, 0x108);
+	}
+	/* Now, reset sync counters */
+	for (addr = DSP_SYNC_START_REG; addr < DSP_SYNC_END_REG; addr += 0x4) {
+		writel(addr, 0x0);
+	}
+
+	/* Reset code */
+	writel((S2L_CODE_BASE + DSP_RESET_OFFSET), 0x1);
+	/* Reset me */
+	writel((S2L_MEMD_BASE + DSP_RESET_OFFSET), 0x1);
+}
diff --git a/src/bld/dsp/s3l/dsp_aaa.c b/src/bld/dsp/s3l/dsp_aaa.c
new file mode 100644
index 0000000..409f2b0
--- /dev/null
+++ b/src/bld/dsp/s3l/dsp_aaa.c
@@ -0,0 +1,319 @@
+/**
+ * bld/dsp/s3l/dsp_aaa.c
+ *
+ * History:
+ *    2017/03/27 - [Tao Wu] created file
+ *
+ * Copyright (c) 2017 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <dsp/fb_aaa_ctrl.h>
+
+#define ROUND_UP(size, align) (((size) + ((align) - 1)) & ~((align) - 1))
+#define MAX_SLICE_NUM 3
+#define MIN_SLICE_NUM 1
+
+typedef struct aaa_parse_info_s
+{
+	u8 is_first_cfa : 1;
+	u8 index : 7;
+	u8 reserved[3];
+	u8 *cfa_slice_addr[MAX_SLICE_NUM];
+	u32 cfa_data_size;
+	u32 cur_entry_addr;
+	u32 next_entry_addr;
+} aaa_parse_info_t;
+
+typedef struct aaa_context_s
+{
+	aaa_output_t aaa_output;
+	u32 iso_cfg_addr;
+	u32 gen_cmd_seq_num;
+	u32 vcap_cmd_seq_num;
+	aaa_config_info_t aaa_cfg_info;
+	aaa_parse_info_t aaa_parse_info;
+} aaa_context_t;
+
+int clamp(int x, int min, int max)
+{
+	if (x < min) { return min; }
+	if (x > max) { return max; }
+
+	return x;
+}
+
+void convert_dot_12_2_hardware_gain_A7(int mul_dot_12,
+	int *gain, int *shift)
+{
+	*shift = 12;
+	while ((*gain = mul_dot_12 >> (12 - *shift)) > 4095)  { (*shift)--; }
+}
+
+static void fb_aaa_issue_dsp_cmd(aaa_context_t *p_aaa_ctx)
+{
+	VCAP_SET_VIDEO_ISO_PROC_CONTROL_CMD vcap_set_video_iso_proc_ctrl_cmd;
+
+	memset(&vcap_set_video_iso_proc_ctrl_cmd, 0,
+		sizeof(VCAP_SET_VIDEO_ISO_PROC_CONTROL_CMD));
+	vcap_set_video_iso_proc_ctrl_cmd.cmd_code = CMD_VCAP_SET_VIDEO_ISO_PROC_CONTROL;
+	vcap_set_video_iso_proc_ctrl_cmd.iso_cfg_daddr = p_aaa_ctx->iso_cfg_addr;
+	vcap_set_video_iso_proc_ctrl_cmd.flag.iso_config_color_update = 1;
+
+	/* Need clear cmd_num in every vcap interrupt */
+	clear_dsp_cmd_port_num(CMD_PORT_VCAP);
+	add_dsp_cmd_port(&vcap_set_video_iso_proc_ctrl_cmd,
+		sizeof(VCAP_SET_VIDEO_ISO_PROC_CONTROL_CMD), CMD_PORT_VCAP,
+		p_aaa_ctx->vcap_cmd_seq_num);
+	clean_cache_dsp_cmd_port(CMD_PORT_VCAP);
+}
+
+static void fb_awb_ctrl(aaa_context_t *p_aaa_ctx)
+{
+	aaa_output_t *p_aaa_output = &p_aaa_ctx->aaa_output;
+	u8 *p_lisocfg = (u8 *)p_aaa_ctx->iso_cfg_addr;
+
+	int gain = 0, shift = 0;
+	u32 wb_gain_r_offset = 184+40+4;
+	u32 wb_gain_ge_offset = 184+40+8;
+	u32 wb_gain_go_offset = 184+40+12;
+	u32 wb_gain_b_offset = 184+40+16;
+	u32 flag_offset = 184+164;
+	u32 dgain = p_aaa_output->dgain;
+	u32 gain_r = (p_aaa_output->wb_gain.r_gain * dgain) >> (12-2);
+	u32 gain_g = (p_aaa_output->wb_gain.g_gain * dgain) >> (12-2);
+	u32 gain_b = (p_aaa_output->wb_gain.b_gain * dgain) >> (12-2);
+
+	convert_dot_12_2_hardware_gain_A7((int)gain_r, &gain, &shift);
+	gain_r = gain << (16 - shift);
+	convert_dot_12_2_hardware_gain_A7((int)gain_g, &gain, &shift);
+	gain_g = gain << (16 - shift);
+	convert_dot_12_2_hardware_gain_A7((int)gain_b, &gain, &shift);
+	gain_b = gain << (16 - shift);
+
+	memcpy((p_lisocfg+wb_gain_r_offset), &gain_r, sizeof(u32));
+	memcpy((p_lisocfg+wb_gain_ge_offset), &gain_g, sizeof(u32));
+	memcpy((p_lisocfg+wb_gain_go_offset), &gain_g, sizeof(u32));
+	memcpy((p_lisocfg+wb_gain_b_offset), &gain_b, sizeof(u32));
+	*(p_lisocfg + flag_offset) |= (1<<1); //wb_gain_update =1
+}
+
+static void fb_ae_ctrl(aaa_context_t *p_aaa_ctx)
+{
+	if (p_aaa_ctx->aaa_output.ae_output_update) {
+		/* defined in boards/bsp/iav/sensor_xxx.c */
+		fb_sensor_ctrl(&p_aaa_ctx->aaa_output);
+		p_aaa_ctx->aaa_output.ae_output_update = 0;
+	}
+}
+
+static void fb_aaa_ctrl(aaa_context_t *p_aaa_ctx)
+{
+	if (p_aaa_ctx->aaa_output.awb_output_update ||
+		p_aaa_ctx->aaa_output.ae_output_update) {
+		fb_awb_ctrl(p_aaa_ctx);
+		fb_aaa_issue_dsp_cmd(p_aaa_ctx);
+	}
+	if (p_aaa_ctx->aaa_output.ae_output_update) {
+		fb_ae_ctrl(p_aaa_ctx);
+	}
+	p_aaa_ctx->aaa_output.awb_output_update = 0;
+	p_aaa_ctx->aaa_output.ae_output_update = 0;
+}
+
+static void fb_aaa_save(aaa_context_t *p_aaa_ctx)
+{
+	aaa_fb_aeb_t pre_aeb;
+	aaa_output_t *p_aaa_output = &p_aaa_ctx->aaa_output;
+
+	pre_aeb.agc = p_aaa_output->agc_index;
+	pre_aeb.b_gain = p_aaa_output->wb_gain.b_gain << 2;
+	pre_aeb.d_gain = p_aaa_output->dgain;
+	pre_aeb.r_gain = p_aaa_output->wb_gain.r_gain << 2;
+	pre_aeb.shutter = p_aaa_output->shutter_row;
+
+	amboot_update_pandora_aaa((void*)&pre_aeb);
+}
+
+static void fb_stream_force_idr(aaa_context_t *p_aaa_ctx, u32 pts)
+{
+	dsp_issue_force_idr_cmd(p_aaa_ctx->vcap_cmd_seq_num, pts);
+	clean_cache_dsp_cmd_port(CMD_PORT_VCAP);
+}
+
+
+static int pandora_aaa_ctrl( VCAP_STRM_REPORT *stm_rpt, aaa_context_t *aaa_ctx)
+{
+	u8 i = 0;
+	u8 slice_num_cur_vcap = 0;
+	u32 cur_cfa_addr = 0;
+	int is_aaa_stable = 0;
+	aaa_parse_info_t *aaa_parse_info = &aaa_ctx->aaa_parse_info;
+	u32 cfa_base_addr = stm_rpt->cfa_3a_stat_dram_base_addr;
+	u32 cfa_base_limit_addr = stm_rpt->cfa_3a_stat_dram_limit_addr;
+	u8 slice_num = ((aaa_data_header_info_t *)cfa_base_addr)->total_slices_x;
+	u32 cfa_data_size = aaa_parse_info->cfa_data_size;
+
+	if ((slice_num < MIN_SLICE_NUM) || (slice_num > MAX_SLICE_NUM)) {
+		putstr("The slice num: ");
+		putdec(slice_num);
+		putstr("is out of range!\r\n");
+		return -1;
+	}
+
+	aaa_parse_info->next_entry_addr = (stm_rpt->cfa_3a_stat_dram_addr + cfa_data_size);
+	if (aaa_parse_info->next_entry_addr >= cfa_base_limit_addr) {
+		aaa_parse_info->next_entry_addr = cfa_base_addr;
+	}
+
+	if (aaa_parse_info->is_first_cfa) {
+		aaa_parse_info->is_first_cfa = 0;
+		aaa_parse_info->cur_entry_addr = cfa_base_addr;
+		slice_num_cur_vcap = (aaa_parse_info->next_entry_addr -
+			aaa_parse_info->cur_entry_addr) / cfa_data_size;
+	} else {
+		slice_num_cur_vcap = slice_num;
+	}
+
+	for (i = 0; i < slice_num_cur_vcap; i++) {
+		cur_cfa_addr = aaa_parse_info->cur_entry_addr + i * cfa_data_size;
+		if (cur_cfa_addr >= cfa_base_limit_addr) {
+			cur_cfa_addr = cur_cfa_addr - (cfa_base_limit_addr - cfa_base_addr);
+		}
+		flush_d_cache((void *)cur_cfa_addr, CFA_AAA_DATA_BLOCK);
+		aaa_parse_info->cfa_slice_addr[aaa_parse_info->index] = (u8 *)cur_cfa_addr;
+		if (++aaa_parse_info->index >= slice_num) {
+			aaa_parse_info->index = 0;
+			is_aaa_stable = fb_aaa_algo(aaa_parse_info->cfa_slice_addr[0],
+				aaa_parse_info->cfa_slice_addr[1],
+				aaa_parse_info->cfa_slice_addr[2], (u8 *)aaa_ctx->iso_cfg_addr,
+				&aaa_ctx->aaa_cfg_info, &aaa_ctx->aaa_output);
+			clean_d_cache((void *)aaa_ctx->iso_cfg_addr, FB_ISO_CFG_DATA_SIZE);
+		}
+	}
+
+	aaa_parse_info->cur_entry_addr = aaa_parse_info->next_entry_addr;
+
+	return is_aaa_stable;
+}
+
+void dsp_pandora_aaa(void)
+{
+	/* Change it according to your requirment. More count
+	 * mean more stable aaa, but the time can not longer wait_dsp_event */
+#define MAX_VCAP_COUNT	(30)
+#define PIPE_DEPTH_CNT_DOWN	(2 + 3)
+
+	u8 i, j;
+	u8 force_idr_cnt = 0;
+	u8 force_idr_flag = 0;
+	u8 is_first_frame = 1;
+	int is_aaa_stable = 0;
+	DSP_STATUS_MSG * gen_msg_hdr = NULL;
+	DSP_STATUS_MSG * vcap_msg_hdr = NULL;
+	DSP_MSG *vcap_curr_msg = NULL;
+	VCAP_STATUS_MSG * vcap_msg = NULL;
+	VCAP_STRM_REPORT * stm_rpt =  NULL;
+	aaa_context_t aaa_ctx;
+	aaa_config_info_t *aaa_cfg_info = &aaa_ctx.aaa_cfg_info;
+	aaa_parse_info_t *aaa_parse_info = &aaa_ctx.aaa_parse_info;
+
+	memset(&aaa_ctx, 0, sizeof(aaa_context_t));
+	aaa_parse_info->cfa_data_size = ROUND_UP(CFA_AAA_DATA_BLOCK, 256);
+	aaa_parse_info->is_first_cfa = 1;
+
+	/* Call this after prepare_vcap_setup_cmd() */
+	init_iso_cfg_addr(&aaa_ctx.iso_cfg_addr);
+	init_sensor_aaa_param(aaa_cfg_info);
+	amboot_init_pandora_aaa((void*)&aaa_ctx.aaa_output);
+
+	for (i = 0; i < MAX_VCAP_COUNT; ++i) {
+		wait_dsp_vcap();
+		flush_cache_dsp_msg_port(CMD_PORT_VCAP);
+
+		gen_msg_hdr = (DSP_STATUS_MSG *)(DSP_MSG_BUF_START);
+		vcap_msg_hdr = (DSP_STATUS_MSG *)(DSP_MSG_BUF_START + DSP_PORT_MSG_SIZE);
+		vcap_curr_msg = (DSP_MSG *)vcap_msg_hdr + 1;
+
+		aaa_ctx.vcap_cmd_seq_num = vcap_msg_hdr->prev_cmd_seq + 1;
+		aaa_ctx.gen_cmd_seq_num = gen_msg_hdr->prev_cmd_seq + 1;
+		if (i == 0) {
+			/* issue aaa statis setup dsp cmd after the first vcap interrupt */
+			dsp_issue_liso_cfg_cmd(aaa_ctx.vcap_cmd_seq_num);
+			clean_cache_dsp_cmd_port(CMD_PORT_VCAP);
+		}
+		if (force_idr_flag && force_idr_cnt > 0) {
+			force_idr_cnt --;
+		}
+		for (j = 0; j < vcap_msg_hdr->num_msgs; ++j, ++vcap_curr_msg) {
+			if (vcap_curr_msg->msg_code == MSG_VCAP_STATUS) {
+				vcap_msg = (VCAP_STATUS_MSG *) vcap_curr_msg;
+				stm_rpt = &vcap_msg->strm_reports;
+				if (stm_rpt->cfa_3a_stat_dram_addr && (is_aaa_stable <= 0)) {
+					if (stm_rpt->main_pic_luma_addr && is_first_frame) {
+						is_first_frame = 0;
+						force_idr_flag = 1;
+						force_idr_cnt = PIPE_DEPTH_CNT_DOWN;
+					}
+
+					is_aaa_stable = pandora_aaa_ctrl(stm_rpt, &aaa_ctx);
+
+					if (is_aaa_stable < 0) {
+						putstr("dsp aaa algo failed\r\n");
+						break;
+					} else if (is_aaa_stable == 0) {
+						fb_aaa_ctrl(&aaa_ctx);
+					} else if (is_aaa_stable > 0) {
+						fb_aaa_save(&aaa_ctx);
+						printf("dsp aaa algo done at frame [%d]\n", (i+1));
+						if (force_idr_flag) {
+							break;
+						} else {
+							return;
+						}
+					}
+					if (force_idr_flag && force_idr_cnt == 0) {
+						fb_stream_force_idr(&aaa_ctx, stm_rpt->main_pic_sw_pts);
+						force_idr_flag = 0;
+						printf("fb force idr at frame [%d]\n", (i+1));
+					}
+				}
+			}
+		}
+
+		if (force_idr_flag && force_idr_cnt == 0) {
+			fb_stream_force_idr(&aaa_ctx, stm_rpt->main_pic_sw_pts);
+			force_idr_flag = 0;
+			printf("fb delay force idr at frame [%d]\n", (i+1));
+			return;
+		}
+	}
+
+	/* Save context if 3A algo still cannot get stable after N frames. */
+	if (!is_aaa_stable && (i == MAX_VCAP_COUNT)) {
+		fb_aaa_save(&aaa_ctx);
+	}
+}
+
diff --git a/src/bld/dsp/s3l/dsp_arch.c b/src/bld/dsp/s3l/dsp_arch.c
new file mode 100644
index 0000000..8ff30a3
--- /dev/null
+++ b/src/bld/dsp/s3l/dsp_arch.c
@@ -0,0 +1,474 @@
+/**
+ * bld/dsp/s3l/dsp_arch.c
+ *
+ * Author: Xu Liang <xliang@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <ambhw/cache.h>
+#include <dsp/dsp.h>
+#include <bldfunc.h>
+
+#define S3L_MEMD_OFFSET			(0x150000)
+#define S3L_CODE_OFFSET			(0x160000)
+#define S3L_MEMD_BASE			(DBGBUS_BASE + S3L_MEMD_OFFSET)
+#define S3L_CODE_BASE			(DBGBUS_BASE + S3L_CODE_OFFSET)
+
+#define S3L_DSP_DRAM_MAIN_OFFSET	(0x0008)
+#define S3L_DSP_DRAM_SUB0_OFFSET	(0x0008)
+#define S3L_DSP_DRAM_SUB1_OFFSET	(0x8008)
+#define S3L_DSP_CONFIG_MAIN_OFFSET	(0x0000)
+#define S3L_DSP_CONFIG_SUB0_OFFSET	(0x0000)
+#define S3L_DSP_CONFIG_SUB1_OFFSET	(0x8000)
+
+#define S3L_DSP_DRAM_MAIN_REG		(S3L_CODE_BASE + S3L_DSP_DRAM_MAIN_OFFSET)
+#define S3L_DSP_DRAM_SUB0_REG		(S3L_MEMD_BASE + S3L_DSP_DRAM_SUB0_OFFSET)
+#define S3L_DSP_DRAM_SUB1_REG		(S3L_MEMD_BASE + S3L_DSP_DRAM_SUB1_OFFSET)
+#define S3L_DSP_CONFIG_MAIN_REG		(S3L_CODE_BASE + S3L_DSP_CONFIG_MAIN_OFFSET)
+#define S3L_DSP_CONFIG_SUB0_REG		(S3L_MEMD_BASE + S3L_DSP_CONFIG_SUB0_OFFSET)
+#define S3L_DSP_CONFIG_SUB1_REG		(S3L_MEMD_BASE + S3L_DSP_CONFIG_SUB1_OFFSET)
+
+/* DO NOT change ucode name */
+struct ucode_name_addr ucode_mem[] = {
+	{"orccode.bin", UCODE_ORCCODE_START},
+	{"orcme.bin", UCODE_ORCME_START},
+	{"default_binary.bin", UCODE_DEFAULT_BINARY_START},
+};
+
+/*===========================================================================*/
+void vin_phy_init(int interface_type)
+{
+	switch (interface_type) {
+	case SENSOR_PARALLEL_LVCMOS:
+		writel(RCT_REG(0x474), 0x3FFFFFF);
+		putstr_debug("SENSOR_PARALLEL_LVCMOS");
+		break;
+	case SENSOR_MIPI:
+		writel(RCT_REG(0x474), 0x0);
+		writel(RCT_REG(0x478), 0x14403);
+		rct_timer_dly_ms(5);
+		writel(RCT_REG(0x478), 0x14402);
+		writel(RCT_REG(0x47C), 0x1FDD9326);
+		writel(RCT_REG(0x480), 0x3C1F | (1 << 9)); //force mipi clk to be HS mode
+		putstr_debug("SENSOR_MIPI");
+		break;
+	case SENSOR_SERIAL_LVDS:
+		writel(RCT_REG(0x474), 0x0);
+		writel(RCT_REG(0x478), 0x145C1);
+		rct_timer_dly_ms(10);
+		writel(RCT_REG(0x478), 0x145C0);
+		putstr_debug("SENSOR_SERIAL_LVDS");
+		break;
+	default:
+		putstr_debug("Unkown sensor interface type");
+		break;
+	}
+}
+
+void vin_phy_init_pre(int interface_type)
+{
+	switch (interface_type) {
+	case SENSOR_PARALLEL_LVCMOS:
+		writel(RCT_REG(0x474), 0x3FFFFFF);
+		putstr_debug("SENSOR_PARALLEL_LVCMOS");
+		break;
+	case SENSOR_MIPI:
+		writel(RCT_REG(0x474), 0x0);
+		writel(RCT_REG(0x478), 0x14403);
+		putstr_debug("SENSOR_MIPI");
+		break;
+	case SENSOR_SERIAL_LVDS:
+		writel(RCT_REG(0x474), 0x0);
+		writel(RCT_REG(0x478), 0x145C1);
+		putstr_debug("SENSOR_SERIAL_LVDS");
+		break;
+	default:
+		putstr_debug("Unkown sensor interface type");
+		break;
+	}
+}
+
+void vin_phy_init_post(int interface_type)
+{
+	switch (interface_type) {
+	case SENSOR_PARALLEL_LVCMOS:
+		break;
+	case SENSOR_MIPI:
+		/* add other code to generate 5 ms delay */
+		writel(RCT_REG(0x478), 0x14402);
+		writel(RCT_REG(0x47C), 0x1FDD9326);
+		writel(RCT_REG(0x480), 0x3C1F | (1 << 9)); //force mipi clk to be HS mode
+		break;
+	case SENSOR_SERIAL_LVDS:
+		/* add other code to generate 10 ms delay */
+		writel(RCT_REG(0x478), 0x145C0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void show_dram_layout_info(void)
+{
+#ifdef AMBOOT_IAV_STR_DEBUG
+	/* The following info should be exactly same as output by "test_encode --show-dram" */
+	printf("[DRAM Layout info]:\n");
+	printf("     [BSB] Base Address: [0x%08X], Size [0x%08X]\n", DSP_BSB_START, DSP_BSB_SIZE);
+	printf(" [OVERLAY] Base Address: [0x%08X], Size [0x%08X]\n", DSP_OVERLAY_START, DSP_OVERLAY_SIZE);
+	printf("    [WARP] Base Address: [0x%08X], Size [0x%08X]\n", DSP_WARP_START, DSP_WARP_TAB_MAX_SIZE);
+	printf(" [IMGPROC] Base Address: [0x%08X], Size [0x%08X]\n", DSP_IMGPROC_START, DSP_IMGPROC_SIZE);
+	printf(" [IAVRSVD] Base Address: [0x%08X], Size [0x%08X]\n", DSP_IAVRSVD_START, DSP_IAVRSVD_SIZE);
+	printf(" [FB_DATA] Base Address: [0x%08X], Size [0x%08X]\n", DSP_FASTDATA_START, DSP_FASTDATA_SIZE);
+	printf("[FB_AUDIO] Base Address: [0x%08X], Size [0x%08X]\n", DSP_FASTAUDIO_START, DSP_FASTAUDIO_SIZE);
+	printf("     [DSP] Base Address: [0x%08X], Size [0x%08X]\n", DSP_BUFFER_START, DSP_BUFFER_SIZE);
+	printf("  [DSPLOG] Base Address: [0x%08X], Size [0x%08X]\n", DSP_LOG_START, DSP_LOG_SIZE);
+#endif
+}
+
+static int dsp_init_data(void)
+{
+	dsp_init_data_t *extended_init_data = NULL;
+	dsp_init_data_common_t *init_data = NULL;
+	vdsp_info_t *vdsp_info = NULL;
+	DSP_HEADER_CMD *cmd_hdr = NULL;
+	u32 *ucode_init_data_ptr = NULL;
+
+	/* initialize struct dsp_init_data */
+	extended_init_data = (dsp_init_data_t *)DSP_INIT_DATA_START;
+	memset(extended_init_data, 0, sizeof(dsp_init_data_t));
+	init_data = &extended_init_data->common_init_data;
+
+	/* setup default binary data pointer */
+	init_data->default_binary_data_addr = UCODE_DEFAULT_BINARY_START;
+	init_data->default_binary_data_size = UCODE_DEFAULT_BINARY_SIZE;
+
+	/* setup cmd/msg memory for DSP-ARM */
+	init_data->cmd_data_gen_daddr = DSP_CMD_BUF_START;
+	init_data->cmd_data_gen_size = DSP_PORT_CMD_SIZE;
+	init_data->msg_queue_gen_daddr = DSP_MSG_BUF_START;
+	init_data->msg_queue_gen_size = DSP_PORT_MSG_SIZE;
+
+	init_data->cmd_data_vcap_daddr = init_data->cmd_data_gen_daddr +
+		init_data->cmd_data_gen_size;
+	init_data->cmd_data_vcap_size = DSP_PORT_CMD_SIZE;
+	init_data->msg_queue_vcap_daddr = init_data->msg_queue_gen_daddr +
+		init_data->msg_queue_gen_size;
+	init_data->msg_queue_vcap_size = DSP_PORT_MSG_SIZE;
+
+	memset((void *)init_data->cmd_data_gen_daddr, 0, init_data->cmd_data_gen_size);
+	memset((void *)init_data->cmd_data_vcap_daddr, 0, init_data->cmd_data_vcap_size);
+	memset((void *)init_data->msg_queue_gen_daddr, 0, init_data->msg_queue_gen_size);
+	memset((void *)init_data->msg_queue_vcap_daddr, 0, init_data->msg_queue_vcap_size);
+
+	init_data->cmd_data_3rd_daddr = 0;
+	init_data->cmd_data_3rd_size = 0;
+	init_data->msg_queue_3rd_daddr = 0;
+	init_data->msg_queue_3rd_size = 0;
+
+	init_data->cmd_data_4th_daddr = 0;
+	init_data->cmd_data_4th_size = 0;
+	init_data->msg_queue_4th_daddr = 0;
+	init_data->msg_queue_4th_size = 0;
+
+	init_data->default_config_daddr = DSP_DEF_CMD_BUF_START;
+	init_data->default_config_size = DSP_DEF_CMD_BUF_SIZE;
+
+	/* setup buffer for dsp running */
+	init_data->dsp_buffer_daddr = DSP_BUFFER_START;
+	init_data->dsp_buffer_size = DSP_BUFFER_SIZE;
+	init_data->dsp_log_buf_daddr = DSP_LOG_START;
+	init_data->product_id = AMBA_PRODUCT_ID_IPCAM;
+	extended_init_data->ipcam_init_data.dsp_log_size = DSP_LOG_SIZE;
+
+	/* misc info */
+	init_data->chip_id_daddr = UCODE_CHIP_ID_START;
+	vdsp_info = (vdsp_info_t *)(UCODE_CHIP_ID_START + sizeof(u32));
+	vdsp_info->dsp_cmd_rx = 1;
+	vdsp_info->dsp_msg_tx = 1;
+	init_data->vdsp_info_daddr = (u32) vdsp_info;
+
+	/* used for valid bsh data check */
+	memset((void *)DSP_BSH_START, 0, DSP_BSH_SIZE);
+
+	/* reset IMGPROC buffer in case wild pointers are used by idsp */
+	memset((void *)DSP_FASTBOOT_IDSPCFG_START, 0, DSP_ISOCFG_RSVED_SIZE);
+
+	/* used for sync fastboot data from amboot to linux/iav */
+	memset((void *)DSP_FASTDATA_START, DSP_FASTDATA_INVALID, DSP_FASTDATA_SIZE);
+
+	/* Default CMD Queue */
+	cmd_hdr = (DSP_HEADER_CMD *)DSP_DEF_CMD_BUF_START;
+	cmd_hdr->cmd_code = CMD_DSP_HEADER;
+	cmd_hdr->cmd_seq_num = 1;
+	cmd_hdr->num_cmds = 0;
+
+	/* Gen Port CMD Queue */
+	cmd_hdr = (DSP_HEADER_CMD *)DSP_CMD_BUF_START;
+	cmd_hdr->cmd_code = CMD_DSP_HEADER;
+	cmd_hdr->cmd_seq_num = 1;
+	cmd_hdr->num_cmds = 0;
+
+	/* Vcap Port CMD Queue */
+	cmd_hdr = (DSP_HEADER_CMD *)(DSP_CMD_BUF_START + DSP_PORT_CMD_SIZE);
+	cmd_hdr->cmd_code = CMD_DSP_HEADER;
+	cmd_hdr->cmd_seq_num = 1;
+	cmd_hdr->num_cmds = 0;
+
+	ucode_init_data_ptr = (u32 *)UCODE_DSP_INIT_DATA_PTR;
+	*ucode_init_data_ptr = DSP_INIT_DATA_START;
+
+	bopt_sync(init_data, (u32*)UCODE_DEFAULT_BINARY_START, (u32*)UCODE_ORCCODE_START, NULL);
+#ifdef AMBOOT_DSP_LOG_CAPTURE
+	memset((void *)DSP_LOG_START, 0, DSP_LOG_SIZE);
+#endif
+
+	show_dram_layout_info();
+
+	putstr_debug("dsp_init_data done\r\n");
+	return 0;
+}
+
+int dsp_boot(void)
+{
+	/* reset analog/digital mipi phy */
+	writel(DBGBUS_BASE + 0x11801c, 0x30002);
+	// rct_timer_dly_ms(5);
+	writel(DBGBUS_BASE + 0x11801c, 0x0);
+
+	_drain_write_buffer();
+	_clean_flush_all_cache();
+
+	writel(S3L_DSP_DRAM_MAIN_REG, UCODE_ORCCODE_START);
+	writel(S3L_DSP_DRAM_SUB0_REG, UCODE_ORCME_START);
+
+	writel(S3L_DSP_CONFIG_SUB0_REG, 0xF);
+	writel(S3L_DSP_CONFIG_MAIN_REG, 0xFF);
+
+	putstr_debug("dsp_boot\r\n");
+	return 0;
+}
+
+int dsp_boot_pre(void)
+{
+	/* reset analog/digital mipi phy */
+	writel(DBGBUS_BASE + 0x11801c, 0x30002);
+	// rct_timer_dly_ms(5);
+	writel(DBGBUS_BASE + 0x11801c, 0x0);
+
+	_drain_write_buffer();
+	_clean_flush_all_cache();
+
+	writel(S3L_DSP_DRAM_MAIN_REG, UCODE_ORCCODE_START);
+	writel(S3L_DSP_CONFIG_MAIN_REG, 0xFF);
+
+	putstr_debug("dsp_boot_code\r\n");
+	return 0;
+}
+
+int dsp_boot_post(void)
+{
+	_drain_write_buffer();
+	_clean_flush_all_cache();
+
+	writel(S3L_DSP_DRAM_SUB0_REG, UCODE_ORCME_START);
+	writel(S3L_DSP_CONFIG_SUB0_REG, 0xF);
+
+	putstr_debug("dsp_boot_me\r\n");
+	return 0;
+}
+
+int dsp_ucode_pre_load(struct dspfw_header *hdr)
+{
+	int i = 0;
+	int rval = 0;
+	unsigned int mem = 0;
+	struct ucode_file_info *ucode = NULL;
+
+	for (i = 0; i < hdr->total_dsp; i++) {
+		ucode = &hdr->ucode[i];
+		if (!ucode->post) {
+			rval = dsp_get_ucode_mem_by_name(ucode_mem,
+				ARRAY_SIZE(ucode_mem), ucode, &mem);
+			if (rval >= 0) {
+				rval = bld_loader_load_partition_partial(PART_DSP,
+					ucode->offset, ucode->size, mem, 0);
+			}
+		}
+	}
+
+	return rval;
+}
+
+int dsp_ucode_post_load(struct dspfw_header *hdr)
+{
+	int i = 0;
+	int rval = 0;
+	unsigned int mem = 0;
+	struct ucode_file_info *ucode = NULL;
+
+	for (i = (hdr->total_dsp - 1); i >= 0; i--) {
+		ucode = &hdr->ucode[i];
+		if (ucode->post) {
+			rval = dsp_get_ucode_mem_by_name(ucode_mem,
+				ARRAY_SIZE(ucode_mem), ucode, &mem);
+			if (rval >= 0) {
+				rval = bld_loader_load_partition_partial(PART_DSP,
+					ucode->offset, ucode->size, mem, 0);
+			}
+		}
+	}
+	dsp_boot_post();
+
+	return rval;
+}
+
+int add_dsp_cmd(void *cmd, unsigned int size)
+{
+	DSP_HEADER_CMD *cmd_hdr;
+	u32 cmd_ptr;
+
+	dsp_print_cmd(cmd, size);
+
+	cmd_hdr = (DSP_HEADER_CMD *)DSP_DEF_CMD_BUF_START;
+
+	cmd_ptr = DSP_DEF_CMD_BUF_START + sizeof(DSP_HEADER_CMD) +
+			cmd_hdr->num_cmds * DSP_CMD_SIZE;
+	if ((cmd_ptr + DSP_CMD_SIZE) >=
+		(DSP_DEF_CMD_BUF_START + DSP_DEF_CMD_BUF_SIZE)) {
+		putstr("cmd buffer is too small!!!\n");
+		BUG_ON(1);
+		return -1;
+	}
+
+	memcpy((u8 *)cmd_ptr, cmd, size);
+	memset((u8 *)cmd_ptr + size, 0, DSP_CMD_SIZE - size);
+
+	cmd_hdr->num_cmds++;
+
+	return 0;
+}
+
+/* The value of port:  0: CMD_PORT_GEN;  1: CMD_PORT_VCAP. */
+int add_dsp_cmd_port(void *cmd, unsigned int size, DSP_CMD_PORT_PARAM port,
+	unsigned int seq_num)
+{
+	DSP_HEADER_CMD *cmd_hdr;
+	u32 cmd_ptr;
+	u32 base;
+
+	if ((port < CMD_PORT_GEN) || (port >= CMD_PORT_TOTAL_NUM)) {
+		putstr("Invalid cmd port\r\n");
+		return -1;
+	}
+	dsp_print_cmd(cmd, size);
+
+	base = DSP_CMD_BUF_START + DSP_PORT_CMD_SIZE * port;
+	cmd_hdr = (DSP_HEADER_CMD *)(base);
+
+	cmd_ptr = base + sizeof(DSP_HEADER_CMD) +
+			cmd_hdr->num_cmds * DSP_CMD_SIZE;
+	if ((cmd_ptr + DSP_CMD_SIZE) >=
+		(DSP_CMD_BUF_START + DSP_CMD_BUF_SIZE)) {
+		putstr("cmd buffer is too small!!!\n");
+		BUG_ON(1);
+		return -1;
+	}
+
+	memcpy((u8 *)cmd_ptr, cmd, size);
+	memset((u8 *)cmd_ptr + size, 0, DSP_CMD_SIZE - size);
+
+	cmd_hdr->num_cmds++;
+	cmd_hdr->cmd_seq_num = seq_num;
+
+	return 0;
+}
+
+void clear_dsp_cmd_port_num(DSP_CMD_PORT_PARAM port)
+{
+	DSP_HEADER_CMD *cmd_hdr = NULL;
+
+	if ((port < CMD_PORT_GEN) || (port >= CMD_PORT_TOTAL_NUM)) {
+		putstr("Clear invalid cmd port\r\n");
+		return;
+	}
+	cmd_hdr = (DSP_HEADER_CMD *)(DSP_CMD_BUF_START + DSP_PORT_CMD_SIZE * port);
+	cmd_hdr->num_cmds = 0;
+}
+
+/* sync memory to cache before read dsp message */
+void flush_cache_dsp_msg_port(DSP_CMD_PORT_PARAM port)
+{
+	if ((port < CMD_PORT_GEN) || (port >= CMD_PORT_TOTAL_NUM)) {
+		putstr("Flush invalid msg port\r\n");
+		return;
+	}
+	flush_d_cache((void *)(DSP_MSG_BUF_START + DSP_PORT_MSG_SIZE * port),
+		DSP_PORT_MSG_SIZE);
+}
+
+/* sync cache to memory after issue dsp cmd */
+void clean_cache_dsp_cmd_port(DSP_CMD_PORT_PARAM port)
+{
+	if ((port < CMD_PORT_GEN) || (port >= CMD_PORT_TOTAL_NUM)) {
+		putstr("Clean invalid cmd port\r\n");
+		return;
+	}
+	clean_d_cache((void *)(DSP_CMD_BUF_START + DSP_PORT_CMD_SIZE * port),
+		DSP_PORT_CMD_SIZE);
+}
+
+void dsp_halt(void)
+{
+#define DSP_RESET_OFFSET (0x4)
+#define DSP_SYNC_START_OFFSET (0x101c00)
+#define DSP_SYNC_END_OFFSET (0x101d00)
+
+#define DSP_SYNC_START_REG (DBGBUS_BASE + DSP_SYNC_START_OFFSET)
+#define DSP_SYNC_END_REG (DBGBUS_BASE + DSP_SYNC_END_OFFSET)
+
+	u32 addr = 0;
+
+	/* Suspend all code orc threads */
+	writel(S3L_CODE_BASE, 0xff00);
+	/* Suspend all md orc threads */
+	writel(S3L_MEMD_BASE, 0xf0);
+
+	/* Assuming all the orc threads are now waiting to receive on some sync.
+	 * counter, debug port writes to all result in wakes to all sync */
+	for (addr = DSP_SYNC_START_REG; addr < DSP_SYNC_END_REG; addr += 0x4) {
+		writel(addr, 0x1008);
+	}
+	/* Now, reset sync counters */
+	for (addr = DSP_SYNC_START_REG; addr < DSP_SYNC_END_REG; addr += 0x4) {
+		writel(addr, 0x0);
+	}
+
+	/* Reset code */
+	writel((S3L_CODE_BASE + DSP_RESET_OFFSET), 0x1);
+	/* Reset me */
+	writel((S3L_MEMD_BASE + DSP_RESET_OFFSET), 0x1);
+}
diff --git a/src/bld/dsp/s5l/dsp_arch.c b/src/bld/dsp/s5l/dsp_arch.c
new file mode 100644
index 0000000..aa0afae
--- /dev/null
+++ b/src/bld/dsp/s5l/dsp_arch.c
@@ -0,0 +1,489 @@
+/**
+ * bld/dsp/s5l/dsp_arch.c
+ *
+ * Author: Xu Liang <xliang@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <ambhw/cache.h>
+#include <dsp/dsp.h>
+#include <bldfunc.h>
+
+#define S5L_MEMD_OFFSET			(0x150000)
+#define S5L_CODE_OFFSET			(0x160000)
+#define S5L_MEMD_BASE			(DBGBUS_BASE + S5L_MEMD_OFFSET)
+#define S5L_CODE_BASE			(DBGBUS_BASE + S5L_CODE_OFFSET)
+
+#define S5L_DSP_DRAM_MAIN_OFFSET	(0x0008)
+#define S5L_DSP_DRAM_SUB0_OFFSET	(0x0008)
+#define S5L_DSP_DRAM_SUB1_OFFSET	(0x8008)
+#define S5L_DSP_CONFIG_MAIN_OFFSET	(0x0000)
+#define S5L_DSP_CONFIG_SUB0_OFFSET	(0x0000)
+#define S5L_DSP_CONFIG_SUB1_OFFSET	(0x8000)
+
+#define S5L_DSP_DRAM_MAIN_REG		(S5L_CODE_BASE + S5L_DSP_DRAM_MAIN_OFFSET)
+#define S5L_DSP_DRAM_SUB0_REG		(S5L_MEMD_BASE + S5L_DSP_DRAM_SUB0_OFFSET)
+#define S5L_DSP_DRAM_SUB1_REG		(S5L_MEMD_BASE + S5L_DSP_DRAM_SUB1_OFFSET)
+#define S5L_DSP_CONFIG_MAIN_REG		(S5L_CODE_BASE + S5L_DSP_CONFIG_MAIN_OFFSET)
+#define S5L_DSP_CONFIG_SUB0_REG		(S5L_MEMD_BASE + S5L_DSP_CONFIG_SUB0_OFFSET)
+#define S5L_DSP_CONFIG_SUB1_REG		(S5L_MEMD_BASE + S5L_DSP_CONFIG_SUB1_OFFSET)
+
+/* DO NOT change ucode name */
+struct ucode_name_addr ucode_mem[] = {
+	{"orccode.bin", UCODE_ORCCODE_START},
+	{"orcme.bin", UCODE_ORCME_START},
+	{"default_binary.bin", UCODE_DEFAULT_BINARY_START},
+};
+
+/*===========================================================================*/
+void vin_phy_init(int interface_type)
+{
+	switch (interface_type) {
+	case SENSOR_PARALLEL_LVCMOS:
+		writel(RCT_REG(0x578), 0x600800FF);
+		writel(RCT_REG(0x594), 0x300FF);
+		writel(RCT_REG(0x57c), 0x5);
+		putstr_debug("SENSOR_PARALLEL_LVCMOS");
+		break;
+	case SENSOR_MIPI:
+		writel(RCT_REG(0x578), 0x60000000);
+		writel(RCT_REG(0x57c), 0x3801);
+		rct_timer_dly_ms(5);
+		writel(RCT_REG(0x57c), 0x1);
+		writel(RCT_REG(0x580), 0x300);
+		writel(RCT_REG(0x594), 0x3300FF); //force mipi clk to be HS mode
+		writel(RCT_REG(0x5a0), 0x1D300E05);
+		writel(RCT_REG(0x5a4), 0x123F);
+		putstr_debug("SENSOR_MIPI");
+		break;
+	case SENSOR_SERIAL_LVDS:
+		writel(RCT_REG(0x578), 0x60300000);
+		writel(RCT_REG(0x57c), 0x801);
+		rct_timer_dly_ms(10);
+		writel(RCT_REG(0x57c), 0x1);
+		writel(RCT_REG(0x594), 0x0);
+		putstr_debug("SENSOR_SERIAL_LVDS");
+		break;
+	default:
+		putstr_debug("Unkown sensor interface type");
+		break;
+	}
+}
+
+void vin_phy_init_pre(int interface_type)
+{
+	switch (interface_type) {
+	case SENSOR_PARALLEL_LVCMOS:
+		writel(RCT_REG(0x578), 0x600800FF);
+		writel(RCT_REG(0x594), 0x300FF);
+		writel(RCT_REG(0x57c), 0x5);
+		putstr_debug("SENSOR_PARALLEL_LVCMOS");
+		break;
+	case SENSOR_MIPI:
+		writel(RCT_REG(0x578), 0x60000000);
+		writel(RCT_REG(0x57c), 0x3801);
+		putstr_debug("SENSOR_MIPI");
+		break;
+	case SENSOR_SERIAL_LVDS:
+		writel(RCT_REG(0x578), 0x60300000);
+		writel(RCT_REG(0x57c), 0x801);
+		putstr_debug("SENSOR_SERIAL_LVDS");
+		break;
+	default:
+		putstr_debug("Unkown sensor interface type");
+		break;
+	}
+}
+
+void vin_phy_init_post(int interface_type)
+{
+	switch (interface_type) {
+	case SENSOR_PARALLEL_LVCMOS:
+		break;
+	case SENSOR_MIPI:
+//		/* add other code to generate 5 ms delay */
+		writel(RCT_REG(0x57c), 0x1);
+		writel(RCT_REG(0x580), 0x300);
+		writel(RCT_REG(0x594), 0x3300FF); //force mipi clk to be HS mode
+		writel(RCT_REG(0x5a0), 0x1D300E05);
+		writel(RCT_REG(0x5a4), 0x123F);
+		break;
+	case SENSOR_SERIAL_LVDS:
+		/* add other code to generate 10 ms delay */
+		writel(RCT_REG(0x57c), 0x1);
+		writel(RCT_REG(0x594), 0x0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void show_dram_layout_info(void)
+{
+#ifdef AMBOOT_IAV_STR_DEBUG
+	/* The following info should be exactly same as output by "test_encode --show-dram" */
+	printf("[DRAM Layout info]:\n");
+	printf("     [BSB] Base Address: [0x%08X], Size [0x%08X]\n", DSP_BSB_START, DSP_BSB_SIZE);
+	printf(" [OVERLAY] Base Address: [0x%08X], Size [0x%08X]\n", DSP_OVERLAY_START, DSP_OVERLAY_SIZE);
+	printf("    [WARP] Base Address: [0x%08X], Size [0x%08X]\n", DSP_WARP_START, DSP_WARP_TAB_MAX_SIZE);
+	printf(" [IMGPROC] Base Address: [0x%08X], Size [0x%08X]\n", DSP_IMGPROC_START, DSP_IMGPROC_SIZE);
+	printf(" [IAVRSVD] Base Address: [0x%08X], Size [0x%08X]\n", DSP_IAVRSVD_START, DSP_IAVRSVD_SIZE);
+	printf(" [FB_DATA] Base Address: [0x%08X], Size [0x%08X]\n", DSP_FASTDATA_START, DSP_FASTDATA_SIZE);
+	printf("[FB_AUDIO] Base Address: [0x%08X], Size [0x%08X]\n", DSP_FASTAUDIO_START, DSP_FASTAUDIO_SIZE);
+	printf("     [DSP] Base Address: [0x%08X], Size [0x%08X]\n", DSP_BUFFER_START, DSP_BUFFER_SIZE);
+	printf("  [DSPLOG] Base Address: [0x%08X], Size [0x%08X]\n", DSP_LOG_START, DSP_LOG_SIZE);
+#endif
+}
+
+static int dsp_init_data(void)
+{
+	dsp_init_data_t *extended_init_data = NULL;
+	dsp_init_data_common_t *init_data = NULL;
+	vdsp_info_t *vdsp_info = NULL;
+	DSP_HEADER_CMD *cmd_hdr = NULL;
+	u32 *ucode_init_data_ptr = NULL;
+
+	/* initialize struct dsp_init_data */
+	extended_init_data = (dsp_init_data_t *)DSP_INIT_DATA_START;
+	memset(extended_init_data, 0, sizeof(dsp_init_data_t));
+	init_data = &extended_init_data->common_init_data;
+
+	/* setup default binary data pointer */
+	init_data->default_binary_data_addr = UCODE_DEFAULT_BINARY_START;
+	init_data->default_binary_data_size = UCODE_DEFAULT_BINARY_SIZE;
+
+	/* setup cmd/msg memory for DSP-ARM */
+	init_data->cmd_data_gen_daddr = DSP_CMD_BUF_START;
+	init_data->cmd_data_gen_size = DSP_PORT_CMD_SIZE;
+	init_data->msg_queue_gen_daddr = DSP_MSG_BUF_START;
+	init_data->msg_queue_gen_size = DSP_PORT_MSG_SIZE;
+
+	init_data->cmd_data_vcap_daddr = init_data->cmd_data_gen_daddr +
+		init_data->cmd_data_gen_size;
+	init_data->cmd_data_vcap_size = DSP_PORT_CMD_SIZE;
+	init_data->msg_queue_vcap_daddr = init_data->msg_queue_gen_daddr +
+		init_data->msg_queue_gen_size;
+	init_data->msg_queue_vcap_size = DSP_PORT_MSG_SIZE;
+
+	memset((void *)(u64)init_data->cmd_data_gen_daddr, 0, init_data->cmd_data_gen_size);
+	memset((void *)(u64)init_data->cmd_data_vcap_daddr, 0, init_data->cmd_data_vcap_size);
+	memset((void *)(u64)init_data->msg_queue_gen_daddr, 0, init_data->msg_queue_gen_size);
+	memset((void *)(u64)init_data->msg_queue_vcap_daddr, 0, init_data->msg_queue_vcap_size);
+
+	init_data->cmd_data_3rd_daddr = 0;
+	init_data->cmd_data_3rd_size = 0;
+	init_data->msg_queue_3rd_daddr = 0;
+	init_data->msg_queue_3rd_size = 0;
+
+	init_data->cmd_data_4th_daddr = 0;
+	init_data->cmd_data_4th_size = 0;
+	init_data->msg_queue_4th_daddr = 0;
+	init_data->msg_queue_4th_size = 0;
+
+	init_data->default_config_daddr = DSP_DEF_CMD_BUF_START;
+	init_data->default_config_size = DSP_DEF_CMD_BUF_SIZE;
+
+	/* setup buffer for dsp running */
+	init_data->dsp_buffer_daddr = DSP_BUFFER_START;
+	init_data->dsp_buffer_size = DSP_BUFFER_SIZE;
+	init_data->dsp_log_buf_daddr = DSP_LOG_START;
+	init_data->product_id = AMBA_PRODUCT_ID_IPCAM;
+	extended_init_data->ipcam_init_data.dsp_log_size = DSP_LOG_SIZE;
+
+	/* misc info */
+	init_data->chip_id_daddr = (u32)UCODE_CHIP_ID_START;
+	vdsp_info = (vdsp_info_t *)(u64)(UCODE_CHIP_ID_START + sizeof(u32));
+	vdsp_info->dsp_cmd_rx = 1;
+	vdsp_info->dsp_msg_tx = 1;
+	init_data->vdsp_info_daddr = (uintptr_t)vdsp_info;
+
+	/* used for valid bsh data check */
+	memset((void *)DSP_BSH_START, 0, DSP_BSH_SIZE);
+
+	/* reset IMGPROC buffer in case wild pointers are used by idsp */
+	memset((void *)DSP_FASTBOOT_IDSPCFG_START, 0, DSP_ISOCFG_RSVED_SIZE);
+
+	/* used for sync fastboot data from amboot to linux/iav */
+	memset((void *)DSP_FASTDATA_START, DSP_FASTDATA_INVALID, DSP_FASTDATA_SIZE);
+
+	/* Default CMD Queue */
+	cmd_hdr = (DSP_HEADER_CMD *)DSP_DEF_CMD_BUF_START;
+	cmd_hdr->cmd_code = CMD_DSP_HEADER;
+	cmd_hdr->cmd_seq_num = 1;
+	cmd_hdr->num_cmds = 0;
+
+	/* Gen Port CMD Queue */
+	cmd_hdr = (DSP_HEADER_CMD *)DSP_CMD_BUF_START;
+	cmd_hdr->cmd_code = CMD_DSP_HEADER;
+	cmd_hdr->cmd_seq_num = 1;
+	cmd_hdr->num_cmds = 0;
+
+	/* Vcap Port CMD Queue */
+	cmd_hdr = (DSP_HEADER_CMD *)(DSP_CMD_BUF_START + DSP_PORT_CMD_SIZE);
+	cmd_hdr->cmd_code = CMD_DSP_HEADER;
+	cmd_hdr->cmd_seq_num = 1;
+	cmd_hdr->num_cmds = 0;
+
+	ucode_init_data_ptr = (u32 *)(u64)UCODE_DSP_INIT_DATA_PTR;
+	*ucode_init_data_ptr = DSP_INIT_DATA_START;
+
+	bopt_sync(init_data, (u32*)UCODE_DEFAULT_BINARY_START, (u32*)UCODE_ORCCODE_START, NULL);
+#ifdef AMBOOT_DSP_LOG_CAPTURE
+	memset((void *)DSP_LOG_START, 0, DSP_LOG_SIZE);
+#endif
+
+	show_dram_layout_info();
+
+	putstr_debug("dsp_init_data done\r\n");
+	return 0;
+}
+
+int dsp_boot(void)
+{
+	/* reset analog/digital mipi phy */
+	writel(DBGBUS_BASE + 0x11801c, 0x30002);
+	// rct_timer_dly_ms(5);
+	writel(DBGBUS_BASE + 0x11801c, 0x0);
+
+	_drain_write_buffer();
+	_clean_flush_all_cache();
+
+	writel(S5L_DSP_DRAM_MAIN_REG, UCODE_ORCCODE_START);
+	writel(S5L_DSP_DRAM_SUB0_REG, UCODE_ORCME_START);
+
+	writel(S5L_DSP_CONFIG_SUB0_REG, 0xF);
+	writel(S5L_DSP_CONFIG_MAIN_REG, 0xFF);
+
+	putstr_debug("dsp_boot\r\n");
+	return 0;
+}
+
+int dsp_boot_pre(void)
+{
+	/* reset analog/digital mipi phy */
+	writel(DBGBUS_BASE + 0x11801c, 0x30002);
+	// rct_timer_dly_ms(5);
+	writel(DBGBUS_BASE + 0x11801c, 0x0);
+
+	_drain_write_buffer();
+	_clean_flush_all_cache();
+
+	writel(S5L_DSP_DRAM_MAIN_REG, UCODE_ORCCODE_START);
+	writel(S5L_DSP_CONFIG_MAIN_REG, 0xFF);
+
+	putstr_debug("dsp_boot_code\r\n");
+	return 0;
+}
+
+int dsp_boot_post(void)
+{
+	_drain_write_buffer();
+	_clean_flush_all_cache();
+
+	writel(S5L_DSP_DRAM_SUB0_REG, UCODE_ORCME_START);
+	writel(S5L_DSP_CONFIG_SUB0_REG, 0xF);
+
+	putstr_debug("dsp_boot_me\r\n");
+	return 0;
+}
+
+int dsp_ucode_pre_load(struct dspfw_header *hdr)
+{
+	int i = 0;
+	int rval = 0;
+	unsigned int mem = 0;
+	struct ucode_file_info *ucode = NULL;
+
+	for (i = 0; i < hdr->total_dsp; i++) {
+		ucode = &hdr->ucode[i];
+		if (!ucode->post) {
+			rval = dsp_get_ucode_mem_by_name(ucode_mem,
+				ARRAY_SIZE(ucode_mem), ucode, &mem);
+			if (rval >= 0) {
+				rval = bld_loader_load_partition_partial(PART_DSP,
+					ucode->offset, ucode->size, mem, 0);
+			}
+		}
+	}
+
+	return rval;
+}
+
+int dsp_ucode_post_load(struct dspfw_header *hdr)
+{
+	int i = 0;
+	int rval = 0;
+	unsigned int mem = 0;
+	struct ucode_file_info *ucode = NULL;
+
+	for (i = (hdr->total_dsp - 1); i >= 0; i--) {
+		ucode = &hdr->ucode[i];
+		if (ucode->post) {
+			rval = dsp_get_ucode_mem_by_name(ucode_mem,
+				ARRAY_SIZE(ucode_mem), ucode, &mem);
+			if (rval >= 0) {
+				rval = bld_loader_load_partition_partial(PART_DSP,
+					ucode->offset, ucode->size, mem, 0);
+			}
+		}
+	}
+	dsp_boot_post();
+
+	return rval;
+}
+
+int add_dsp_cmd(void *cmd, unsigned int size)
+{
+	DSP_HEADER_CMD *cmd_hdr;
+	u32 cmd_ptr;
+
+	dsp_print_cmd(cmd, size);
+
+	cmd_hdr = (DSP_HEADER_CMD *)DSP_DEF_CMD_BUF_START;
+
+	cmd_ptr = DSP_DEF_CMD_BUF_START + sizeof(DSP_HEADER_CMD) +
+		cmd_hdr->num_cmds * DSP_CMD_SIZE;
+	if ((cmd_ptr + DSP_CMD_SIZE) >=
+		(DSP_DEF_CMD_BUF_START + DSP_DEF_CMD_BUF_SIZE)) {
+		putstr("cmd buffer is too small!!!\n");
+		BUG_ON(1);
+		return -1;
+	}
+
+	memcpy((u8 *)(u64)cmd_ptr, cmd, size);
+	memset((u8 *)(u64)(cmd_ptr + size), 0, DSP_CMD_SIZE - size);
+
+	cmd_hdr->num_cmds++;
+
+	return 0;
+}
+
+/* The value of port:  0: CMD_PORT_GEN;  1: CMD_PORT_VCAP. */
+int add_dsp_cmd_port(void *cmd, unsigned int size, DSP_CMD_PORT_PARAM port,
+	unsigned int seq_num)
+{
+	DSP_HEADER_CMD *cmd_hdr;
+	u32 cmd_ptr;
+	u32 base;
+
+	if ((port < CMD_PORT_GEN) || (port >= CMD_PORT_TOTAL_NUM)) {
+		putstr("Invalid cmd port\r\n");
+		return -1;
+	}
+	dsp_print_cmd(cmd, size);
+
+	base = DSP_CMD_BUF_START + DSP_PORT_CMD_SIZE * port;
+	cmd_hdr = (DSP_HEADER_CMD *)(u64)base;
+
+	cmd_ptr = base + sizeof(DSP_HEADER_CMD) +
+			cmd_hdr->num_cmds * DSP_CMD_SIZE;
+	if ((cmd_ptr + DSP_CMD_SIZE) >=
+		(DSP_CMD_BUF_START + DSP_CMD_BUF_SIZE)) {
+		putstr("cmd buffer is too small!!!\n");
+		BUG_ON(1);
+		return -1;
+	}
+
+	memcpy((u8 *)(u64)cmd_ptr, cmd, size);
+	memset((u8 *)(u64)(cmd_ptr + size), 0, DSP_CMD_SIZE - size);
+
+	cmd_hdr->num_cmds++;
+	cmd_hdr->cmd_seq_num = seq_num;
+
+	return 0;
+}
+
+void clear_dsp_cmd_port_num(DSP_CMD_PORT_PARAM port)
+{
+	DSP_HEADER_CMD *cmd_hdr = NULL;
+
+	if ((port < CMD_PORT_GEN) || (port >= CMD_PORT_TOTAL_NUM)) {
+		putstr("Clear invalid cmd port\r\n");
+		return;
+	}
+	cmd_hdr = (DSP_HEADER_CMD *)(u64)(DSP_CMD_BUF_START + DSP_PORT_CMD_SIZE * port);
+	cmd_hdr->num_cmds = 0;
+}
+
+void flush_cache_dsp_chan_fifo(void)
+{
+	flush_d_cache((void *)(u64)(DSP_CHAN_INFO_FIFO_START), DSP_CHAN_INFO_FIFO_SIZE);
+}
+
+/* sync memory to cache before read dsp message */
+void flush_cache_dsp_msg_port(DSP_CMD_PORT_PARAM port)
+{
+	if ((port < CMD_PORT_GEN) || (port >= CMD_PORT_TOTAL_NUM)) {
+		putstr("Flush invalid msg port\r\n");
+		return;
+	}
+	flush_d_cache((void *)(u64)(DSP_MSG_BUF_START + DSP_PORT_MSG_SIZE * port),
+		DSP_PORT_MSG_SIZE);
+}
+
+/* sync cache to memory after issue dsp cmd */
+void clean_cache_dsp_cmd_port(DSP_CMD_PORT_PARAM port)
+{
+	if ((port < CMD_PORT_GEN) || (port >= CMD_PORT_TOTAL_NUM)) {
+		putstr("Clean invalid cmd port\r\n");
+		return;
+	}
+	clean_d_cache((void *)(u64)(DSP_CMD_BUF_START + DSP_PORT_CMD_SIZE * port),
+		DSP_PORT_CMD_SIZE);
+}
+
+void dsp_halt(void)
+{
+#define DSP_RESET_OFFSET (0x4)
+#define DSP_SYNC_START_OFFSET (0x101c00)
+#define DSP_SYNC_END_OFFSET (0x101d00)
+
+#define DSP_SYNC_START_REG (DBGBUS_BASE + DSP_SYNC_START_OFFSET)
+#define DSP_SYNC_END_REG (DBGBUS_BASE + DSP_SYNC_END_OFFSET)
+
+	u32 addr = 0;
+
+	/* Suspend all code orc threads */
+	writel(S5L_CODE_BASE, 0xff00);
+	/* Suspend all md orc threads */
+	writel(S5L_MEMD_BASE, 0xf0);
+
+	/* Assuming all the orc threads are now waiting to receive on some sync.
+	 * counter, debug port writes to all result in wakes to all sync */
+	for (addr = DSP_SYNC_START_REG; addr < DSP_SYNC_END_REG; addr += 0x4) {
+		writel(addr, 0x1008);
+	}
+	/* Now, reset sync counters */
+	for (addr = DSP_SYNC_START_REG; addr < DSP_SYNC_END_REG; addr += 0x4) {
+		writel(addr, 0x0);
+	}
+
+	/* Reset code */
+	writel((S5L_CODE_BASE + DSP_RESET_OFFSET), 0x1);
+	/* Reset me */
+	writel((S5L_MEMD_BASE + DSP_RESET_OFFSET), 0x1);
+}
diff --git a/src/bld/eabi_compat.c b/src/bld/eabi_compat.c
new file mode 100644
index 0000000..97bd3c7
--- /dev/null
+++ b/src/bld/eabi_compat.c
@@ -0,0 +1,41 @@
+/**
+ * bld/eabi_compat.c
+ *
+ *
+ * History:
+ *    2016/3/4 - [Jorney] created file
+ *
+ * Copyright (c) 2020 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*XXX: Compatible with toolchain 4.6.1 (A5s) */
+void __aeabi_unwind_cpp_pr0(void)
+{
+}
+
+void __aeabi_unwind_cpp_pr1(void)
+{
+}
diff --git a/src/bld/eth_bld.c b/src/bld/eth_bld.c
index c81029f..b3e68fd 100644
--- a/src/bld/eth_bld.c
+++ b/src/bld/eth_bld.c
@@ -7,23 +7,43 @@
  *    2006/10/18 - [Charles Chiou] created file
  *    2008/02/19 - [Allen Wang] changed to use capabilities and chip ID
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
 #include <ambhw/eth.h>
-#include <ambhw/vic.h>
+#include <ambhw/cache.h>
+#include <irq.h>
 #include <ambhw/cortex.h>
 
 #include <eth/network.h>
 
 /*===========================================================================*/
-bld_net_if_t net_if __attribute__ ((aligned(32)));
+/* FIXME: 64 bit alignment is necessary over here, WHY ?(20170629) */
+bld_net_if_t net_if __attribute__ ((aligned(64)));
 
 /*===========================================================================*/
 u16 htons(u16 n)
@@ -410,6 +430,12 @@ int bld_net_init(int verbose, void *pptb_table)
 	flpart_table_t *pptb = (flpart_table_t *)pptb_table;
 	netdev_t *active_eth;
 
+	/* config the clock for ethernet phy, it is not only valid for amboot,
+	 * but also for kernel, because sometime the clock should be inverted
+	 * or selected as internal or external, so we must keep the function
+	 * can be called. */
+	eth_phy_clock_init();
+
 	if (nif->dev.nif != NULL) {
 		return 0;
 	}
@@ -448,7 +474,7 @@ int bld_net_init(int verbose, void *pptb_table)
 	memzero(&nif->dev, sizeof(nif->dev));
 	nif->dev.link_speed = SPEED_100;
 	nif->dev.link_duplex = DUPLEX_FULL;
-	nif->dev.regbase = (unsigned char *)ETH_BASE;
+	nif->dev.regbase = (uintptr_t)ETH_BASE;
 	nif->dev.irq = ETH_IRQ;
 
 	eth_init(nif, &nif->dev, nif->hwaddr);
@@ -713,7 +739,7 @@ int bld_udp_recv(u16 *src_port, void *packet, int packetlen, int tmo)
 int bld_tftp_load(u32 address, const char *filename, int verbose)
 {
 	int ret_val = -99999999;
-	u32 dladdr = address;
+	uintptr_t dladdr = address;
 	int transferred = 0;
 	int filenamelen;
 	tftp_header_t *tftphdr;
@@ -805,7 +831,7 @@ tftp_load_exit:
 }
 
 /*===========================================================================*/
-static int bld_netload(int verbose, u32 *jump_addr, u32 *rmd_start, u32 *rmd_size)
+static int bld_netload(int verbose, uintptr_t *jump_addr, uintptr_t *rmd_start, uintptr_t *rmd_size)
 {
 	int ret_val = 0;
 	flpart_table_t ptb;
@@ -870,8 +896,8 @@ bld_netload_exit:
 
 int bld_netboot(const char *cmdline, int verbose)
 {
-	u32 jump_addr = 0, rmd_start = 0, rmd_size = 0;
-	u32 cortex_jump, cortex_atag;
+	uintptr_t jump_addr = 0, rmd_start = 0, rmd_size = 0;
+	u32 cortex_jump, dtb_addr;
 	int ret_val;
 
 	ret_val = bld_netload(verbose, &jump_addr, &rmd_start, &rmd_size);
@@ -889,32 +915,19 @@ int bld_netboot(const char *cmdline, int verbose)
 	}
 	bld_net_down();
 
-#if defined(AMBOOT_DEV_BOOT_CORTEX)
-	cortex_jump = ARM11_TO_CORTEX((u32)cortex_processor_start);
-#elif defined(AMBOOT_BOOT_SECONDARY_CORTEX)
-	cortex_jump = (u32)secondary_cortex_jump;
+#if defined(AMBOOT_BOOT_SECONDARY_CORTEX)
+	cortex_jump = (uintptr_t)secondary_cortex_jump;
 #else
 	cortex_jump = 0;
 #endif
-
-#if defined(CONFIG_AMBOOT_BD_FDT_SUPPORT)
-	cortex_atag = fdt_update_tags((void *)jump_addr,
-		cmdline, cortex_jump, rmd_start, rmd_size, verbose);
-#elif defined(CONFIG_AMBOOT_BD_ATAG_SUPPORT)
-	cortex_atag = setup_tags((void *)jump_addr,
+	dtb_addr = fdt_update_tags((void *)jump_addr,
 		cmdline, cortex_jump, rmd_start, rmd_size, verbose);
-#endif
 
 #if defined(AMBOOT_BOOT_SECONDARY_CORTEX)
 	bld_boot_secondary_cortex();
 #endif
 
-#if defined(AMBOOT_DEV_BOOT_CORTEX)
-	*cortex_atag_data = cortex_atag;
-	ret_val = bld_cortex_boot(verbose, jump_addr);
-#else
-	jump_to_kernel((void *)jump_addr, cortex_atag);
-#endif
+	jump_to_kernel((void *)jump_addr, dtb_addr);
 
 	return ret_val;
 }
@@ -923,6 +936,7 @@ int bld_netprogram(const char *pfile_name, u32 addr, u32 exec, int verbose)
 {
 	int ret_val = 0;
 	flpart_table_t ptb;
+	void (*jump)(void) = (void *)(unsigned long)addr;
 
 	ret_val = flprog_get_part_table(&ptb);
 	if (ret_val < 0) {
@@ -973,12 +987,19 @@ int bld_netprogram(const char *pfile_name, u32 addr, u32 exec, int verbose)
 	bld_udp_close();
 	ret_val = 0;
 	if (exec) {
+
+		_clean_flush_all_cache();
+		_disable_icache();
+		_disable_dcache();
+		disable_interrupts();
+
 		if (verbose) {
 			putstr("Jumping to 0x");
 			puthex(addr);
 			putstr("\r\n");
 		}
-		jump_to_kernel((void *)addr, 0);
+
+		jump();
 	}
 
 bld_netload_exit:
diff --git a/src/bld/eth_drv.c b/src/bld/eth_drv.c
index 5d84b04..bbea90a 100644
--- a/src/bld/eth_drv.c
+++ b/src/bld/eth_drv.c
@@ -6,17 +6,35 @@
  * History:
  *    2006/10/18 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
 #include <ambhw/eth.h>
-#include <ambhw/vic.h>
+#include <irq.h>
 #include <ambhw/cache.h>
 #include <eth/network.h>
 
@@ -28,7 +46,7 @@
 /*===========================================================================*/
 static bld_eth_dev_t *G_eth_dev = NULL;
 /*===========================================================================*/
-void eth_handler(void)
+static void eth_irq(void *data)
 {
 	bld_eth_dev_t *dev = G_eth_dev;
 	u32 status;
@@ -36,8 +54,7 @@ void eth_handler(void)
 	if (dev == NULL)
 		return;
 
-	vic_disable(dev->irq);
-	status = readl(dev->regbase + ETH_DMA_STATUS_OFFSET);
+	status = readl((uintptr_t)(dev->regbase + ETH_DMA_STATUS_OFFSET));
 
 	if (status & ETH_DMA_STATUS_FBI) {
 		/* Fatal bus error */
@@ -69,7 +86,7 @@ void eth_handler(void)
 			}
 
 			if ((dev->rxd[i].status & ETH_RDES0_ES) != ETH_RDES0_ES) {
-				ethhdr = (ethhdr_t *) dev->rxd[i].buffer1;
+				ethhdr = (ethhdr_t *)(uintptr_t)dev->rxd[i].buffer1;
 				ep_len = ETH_RDES0_FL(dev->rxd[i].status);
 				 /* Strip the 4 byte CRC */
 				ep_len -= 4;
@@ -135,9 +152,10 @@ void eth_handler(void)
 		/* Transmit stopped */
 	}
 
+	if (status & ETH_DMA_STATUS_GLI)
+		readl((uintptr_t)(dev->regbase + ETH_MAC_RGMII_CS_OFFSET));
+
 	writel(dev->regbase + ETH_DMA_STATUS_OFFSET, status);
-	vic_ackint(dev->irq);
-	vic_enable(dev->irq);
 }
 
 static void *eth_get_tx_frame_buf(struct bld_eth_dev_s *dev)
@@ -284,9 +302,6 @@ static int eth_is_link_up(struct bld_eth_dev_s *dev)
 	if (bmsr == 0xFFFF)
 		goto eth_is_link_up_exit;
 
-	bmsr = eth_mii_read(dev, phy_id, 0x01);
-	if (bmsr == 0xFFFF)
-		goto eth_is_link_up_exit;
 
 	if ((bmsr &= 0x0004) != 0x0004)
 		goto eth_is_link_up_exit;
@@ -403,17 +418,11 @@ void eth_init(bld_net_if_t *nif, bld_eth_dev_t *dev, u8 *hwaddr)
 {
 	int i;
 
-#if defined(CONFIG_AMBOOT_ETH_PHY_CLK_INTERNAL)
-	writel(ENET_GTXCLK_SRC_REG, 0x01);
-#elif defined(CONFIG_AMBOOT_ETH_PHY_CLK_EXTERNAL)
-	writel(ENET_GTXCLK_SRC_REG, 0x00);
-#endif
-
 	if (amboot_bsp_eth_init_pre != NULL) {
 		amboot_bsp_eth_init_pre(dev);
 	}
 
-	vic_disable(dev->irq);
+	irq_disable(dev->irq);
 	eth_reset_dma(dev);
 
 	for (i = 0; i < BOARD_ETH_TX_FRAMES; i++) {
@@ -426,8 +435,8 @@ void eth_init(bld_net_if_t *nif, bld_eth_dev_t *dev, u8 *hwaddr)
 		dev->txd[i].length = ETH_TDES1_IC | ETH_TDES1_LS |
 			ETH_TDES1_FS | ETH_TDES1_TCH;
 #endif
-		dev->txd[i].buffer1 = (u32) dev->tx[i].buf;
-		dev->txd[i].buffer2 = (u32) &dev->txd[(i + 1) % BOARD_ETH_TX_FRAMES];
+		dev->txd[i].buffer1 = (uintptr_t)dev->tx[i].buf;
+		dev->txd[i].buffer2 = (uintptr_t)(&dev->txd[(i + 1) % BOARD_ETH_TX_FRAMES]);
 	}
 
 	for (i = 0; i < BOARD_ETH_RX_FRAMES; i++) {
@@ -439,8 +448,8 @@ void eth_init(bld_net_if_t *nif, bld_eth_dev_t *dev, u8 *hwaddr)
 		dev->rxd[i].length = ETH_RDES1_RCH |
 			ETH_RDES1_RBS1x(BOARD_ETH_FRAMES_SIZE);
 #endif
-		dev->rxd[i].buffer1 = (u32) dev->rx[i].buf;
-		dev->rxd[i].buffer2 = (u32) &dev->rxd[(i + 1) % BOARD_ETH_RX_FRAMES];
+		dev->rxd[i].buffer1 = (uintptr_t)dev->rx[i].buf;
+		dev->rxd[i].buffer2 = (uintptr_t)(&dev->rxd[(i + 1) % BOARD_ETH_RX_FRAMES]);
 	}
 
 	_clean_flush_d_cache();
@@ -459,8 +468,8 @@ void eth_init(bld_net_if_t *nif, bld_eth_dev_t *dev, u8 *hwaddr)
 		(hwaddr[1] <<  8) | hwaddr[0]);
 
 	/*set dest for dma transmission*/
-	writel(dev->regbase + ETH_DMA_TX_DESC_LIST_OFFSET, (u32)dev->txd);
-	writel(dev->regbase + ETH_DMA_RX_DESC_LIST_OFFSET, (u32)dev->rxd);
+	writel(dev->regbase + ETH_DMA_TX_DESC_LIST_OFFSET, (uintptr_t)dev->txd);
+	writel(dev->regbase + ETH_DMA_RX_DESC_LIST_OFFSET, (uintptr_t)dev->rxd);
 
 	writel(dev->regbase + ETH_MAC_FRAME_FILTER_OFFSET, 0x00000000);
 
@@ -478,8 +487,10 @@ void eth_init(bld_net_if_t *nif, bld_eth_dev_t *dev, u8 *hwaddr)
 	writel(dev->regbase + ETH_DMA_OPMODE_OFFSET, ETH_DMA_OPMODE_TTC_256 |
 		ETH_DMA_OPMODE_RTC_64 | ETH_DMA_OPMODE_SR | ETH_DMA_OPMODE_ST);
 
+	writel(dev->regbase + ETH_MAC_INTERRUPT_MASK_OFFSET, 0xffffffff);
+
 	disable_interrupts();
-	vic_set_type(dev->irq, VIRQ_LEVEL_HIGH);
+
 	G_eth_dev = dev;
 	writel(dev->regbase + ETH_MAC_CFG_OFFSET, ETH_MAC_CFG_TE | ETH_MAC_CFG_RE
 		| ETH_MAC_CFG_DM | ETH_MAC_CFG_PS | ETH_MAC_CFG_FES);
@@ -491,7 +502,8 @@ void eth_init(bld_net_if_t *nif, bld_eth_dev_t *dev, u8 *hwaddr)
 		amboot_bsp_eth_init_post(dev);
 	}
 
-	vic_enable(dev->irq);
+	request_irq(dev->irq, IRQ_LEVEL_HIGH, eth_irq, NULL);
+
 	enable_interrupts();
 
 	writel(dev->regbase + ETH_DMA_RX_POLL_DMD_OFFSET, 0x1);
@@ -516,3 +528,18 @@ void eth_pass_source_address(struct bld_eth_dev_s *dev)
 	writel(dev->regbase + ETH_MAC_FRAME_FILTER_OFFSET, 0x00000000);
 }
 
+void eth_phy_clock_init(void)
+{
+#if defined(CONFIG_AMBOOT_ETH_PHY_CLK_INTERNAL)
+        writel(ENET_GTXCLK_SRC_REG, 0x01);
+#elif defined(CONFIG_AMBOOT_ETH_PHY_CLK_EXTERNAL)
+        writel(ENET_GTXCLK_SRC_REG, 0x00);
+#endif
+
+#if defined(CONFIG_AMBOOT_ETH_PHY_CLK_INVERT)
+        /*Invert Ethernet Output Clock*/
+	setbitsl(AHB_SCRATCHPAD_REG(0xc), 0x80000000);
+#endif
+
+}
+
diff --git a/src/bld/fdt_boot.c b/src/bld/fdt_boot.c
index 675099f..8fa0e32 100644
--- a/src/bld/fdt_boot.c
+++ b/src/bld/fdt_boot.c
@@ -4,25 +4,35 @@
  * History:
  *    2013/08/15 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 #include <bldfunc.h>
 #include <libfdt.h>
 #include <ambhw/cortex.h>
 
-static int isnum(char s)
-{
-	if (s <= '9' && s >= '0')
-		return 1;
-	else
-		return 0;
-}
-
 static unsigned int strtonum(char *str)
 {
 	char *s;
@@ -34,13 +44,12 @@ static unsigned int strtonum(char *str)
 
 	s = str;
 
-	while (isnum(*str))
+	while (isdigit_c(*str))
 		str++;
 
 	len = str - s;
 
-	if ((*str != 'M' && *str != 'm')
-			|| !len)
+	if ((*str != 'M' && *str != 'm') || !len)
 		return 0;
 
 	while (len--){
@@ -109,6 +118,52 @@ void fdt_print_error(const char *str, int err)
 	putstr("\r\n");
 }
 
+static int fdt_update_cpux(void *fdt, int chosen_offset, u32 cpux_jump)
+{
+	int ret_val = 0;
+
+#if defined(__aarch64__)
+#ifndef CONFIG_AARCH64_TRUSTZONE
+	int offset;
+
+	offset = fdt_path_offset(fdt, "/psci");
+	if (offset >= 0 && (ret_val = fdt_del_node(fdt, offset)) < 0)
+		return ret_val;
+
+#if CONFIG_ARMV8_AARCH32
+	ret_val = fdt_setprop_u32(fdt, chosen_offset, "ambarella,cpux_jump", cpux_jump);
+#else
+	int cpu;
+
+	offset = fdt_path_offset(fdt, "/cpus");
+	if (offset < 0)
+		return offset;
+
+	for (cpu = 0, offset = fdt_first_subnode(fdt, offset); offset >= 0;
+				offset = fdt_next_subnode(fdt, offset), cpu++) {
+		const char *device_type = fdt_getprop(fdt, offset, "device_type", NULL);
+		if (!device_type || strncmp(device_type, "cpu", 3))
+			continue;
+
+		ret_val = fdt_setprop_u64(fdt, offset, "cpu-release-addr",
+				cpux_jump + cpu * sizeof(unsigned long));
+		if (ret_val < 0)
+			break;
+
+		ret_val = fdt_setprop_string(fdt, offset,
+					"enable-method", "spin-table");
+		if (ret_val < 0)
+			break;
+	}
+#endif	/* CONFIG_ARMV8_AARCH32 */
+#endif	/* CONFIG_AARCH64_TRUSTZONE */
+
+#else
+	ret_val = fdt_setprop_u32(fdt, chosen_offset, "ambarella,cpux_jump", cpux_jump);
+#endif	/* __aarch64__ */
+	return ret_val;
+}
+
 static int fdt_update_chosen(void *fdt, const char *cmdline, u32 cpux_jump,
 	u32 initrd2_start, u32 initrd2_size)
 {
@@ -129,21 +184,21 @@ static int fdt_update_chosen(void *fdt, const char *cmdline, u32 cpux_jump,
 	}
 
 	if (cpux_jump) {
-		ret_val = fdt_setprop_u32(fdt, offset,
-			"ambarella,cpux_jump", cpux_jump);
+		ret_val = fdt_update_cpux(fdt, offset, cpux_jump);
 		if (ret_val < 0) {
+			printf("%s: faild to update cpux\n", __func__);
 			goto fdt_update_chosen_exit;
 		}
 	}
 
 	if ((initrd2_start != 0x0) && (initrd2_size != 0x0)) {
 		ret_val = fdt_setprop_u32(fdt, offset, "linux,initrd-start",
-				ARM11_TO_CORTEX(initrd2_start));
+					initrd2_start);
 		if (ret_val < 0) {
 			goto fdt_update_chosen_exit;
 		}
 		ret_val = fdt_setprop_u32(fdt, offset, "linux,initrd-end",
-				ARM11_TO_CORTEX(initrd2_start) + initrd2_size);
+					initrd2_start + initrd2_size);
 		if (ret_val < 0) {
 			goto fdt_update_chosen_exit;
 		}
@@ -153,23 +208,6 @@ fdt_update_chosen_exit:
 	return ret_val;
 }
 
-#if defined(CONFIG_AMBOOT_ENABLE_NAND) || defined(CONFIG_AMBOOT_ENABLE_SPINOR)
-static void __hex_to_str(const u32 hex, char *dest)
-{
-	char i, c;
-
-	for (i = 0; i < 32; i += 4) {
-		c = (hex >> (28 - i)) & 0xf;
-		if (c >= 10)
-			dest[i/4] = 'a' + c - 10;
-		else
-			dest[i/4] = '0' + c;
-	}
-
-	dest[8] = '\0';
-}
-#endif
-
 #if defined(CONFIG_AMBOOT_ENABLE_NAND)
 static int fdt_update_nand(void *fdt)
 {
@@ -213,7 +251,7 @@ static int fdt_update_nand(void *fdt)
 		size = flnand.nblk[i] * flnand.block_size;
 
 		strcpy(name, "partition@");
-		__hex_to_str(addr, addr_str);
+		hex_to_str(addr, addr_str);
 		strcat(name, addr_str);
 
 		suboffset = fdt_add_subnode(fdt, offset, name);
@@ -262,7 +300,7 @@ static int fdt_update_spinor(void *fdt)
 
 	offset = fdt_path_offset (fdt, pathp);
 	if (offset < 0) {
-		fdt_print_error("fdt_path_offset(nand) error:", offset);
+		fdt_print_error("fdt_path_offset(spi) error:", offset);
 		return ret_val;
 	}
 
@@ -283,7 +321,7 @@ static int fdt_update_spinor(void *fdt)
 		putstr("\r\n");
 
 		strcpy(name, "partition@");
-		__hex_to_str(addr, addr_str);
+		hex_to_str(addr, addr_str);
 		strcat(name, addr_str);
 
 		suboffset = fdt_add_subnode(fdt, offset, name);
@@ -316,70 +354,188 @@ static int fdt_update_spinor(void *fdt)
 }
 #endif
 
-static int fdt_update_memory(void *fdt,
-	u32 kernel_start, u32 kernel_size,
-	u32 iav_start, u32 iav_size,
-	u32 frame_buf_start, u32 frame_buf_size)
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+static int fdt_update_spinand(void *fdt)
 {
-	int ret_val = -1;
-	int offset;
-	u32 val[2];
+	int i, ret_val = -1;
+	const char *pathp;
+	int offset, suboffset;
+	u32 val[6];
 
-	if (fdt == NULL)
-		goto fdt_update_memory_exit;
+	pathp = fdt_get_alias(fdt, "spinand");
+	if (pathp == NULL) {
+		putstr("libfdt fdt_get_alias() failed\r\n");
+		return ret_val;
+	}
 
-	offset = fdt_node_offset_by_prop_value(fdt, -1,
-			"device_type", "memory", 7);
+	offset = fdt_path_offset (fdt, pathp);
 	if (offset < 0) {
-		ret_val = offset;
-		goto fdt_update_memory_exit;
+		fdt_print_error("fdt_path_offset(spinand) error:", offset);
+		return ret_val;
 	}
 
-	val[0] = cpu_to_fdt32(kernel_start);
-	val[1] = cpu_to_fdt32(kernel_size);
-	ret_val = fdt_setprop(fdt, offset, "reg", &val, (sizeof(u32) * 2));
-	if (ret_val < 0)
-		goto fdt_update_memory_exit;
+	for (i = HAS_IMG_PARTS - 1; i >= 0; i--) {
+		char name[32], addr_str[16];
+		u32 addr, size;
 
-	/* create a new node "/iavmem" (offset 0 is root level) */
-	offset = fdt_add_subnode(fdt, 0, "iavmem");
-	if (offset < 0)
-		goto fdt_update_memory_exit;
+		if (flspinand.nblk[i] == 0)
+			continue;
 
-	ret_val = fdt_setprop_string(fdt, offset, "device_type", "iavmem");
-	if (ret_val < 0)
-		goto fdt_update_memory_exit;
+		addr = flspinand.sblk[i] * flspinand.block_size;
+		size = flspinand.nblk[i] * flspinand.block_size;
+#if 0
+		putstr("flspinand addr = 0x");
+		puthex(addr);
+		putstr(", size = 0x");
+		puthex(size);
+		putstr("\r\n");
+#endif
+		strcpy(name, "partition@");
+		hex_to_str(addr, addr_str);
+		strcat(name, addr_str);
 
-	val[0] = cpu_to_fdt32(iav_start);
-	val[1] = cpu_to_fdt32(iav_size);
-	ret_val = fdt_setprop(fdt, offset, "reg", &val, (sizeof(u32) * 2));
-	if (ret_val < 0)
-		goto fdt_update_memory_exit;
+		suboffset = fdt_add_subnode(fdt, offset, name);
+		if (suboffset < 0) {
+			fdt_print_error("fdt_add_subnode(partition) error:",
+						ret_val);
+			return ret_val;
+		}
 
-	/* create a new node "/fbmem" (offset 0 is root level) */
-	offset = fdt_add_subnode(fdt, 0, "fbmem");
-	if (offset < 0)
-		goto fdt_update_memory_exit;
+		ret_val = fdt_setprop_string(fdt, suboffset,
+					"label", get_part_str(i));
+		if (ret_val < 0) {
+			fdt_print_error("fdt_setprop_string(label) error:",
+						ret_val);
+			return ret_val;
+		}
 
-	ret_val = fdt_setprop_string(fdt, offset, "device_type", "fbmem");
-	if (ret_val < 0)
-		goto fdt_update_memory_exit;
+		val[0] = cpu_to_fdt32(addr);
+		val[1] = cpu_to_fdt32(size);
+		ret_val = fdt_setprop(fdt, suboffset, "reg",
+						&val, (sizeof(u32) * 2));
+		if (ret_val < 0){
+			fdt_print_error("fdt_setprop(reg) error:",
+						ret_val);
+			return ret_val;
+		}
+	}
 
-	val[0] = cpu_to_fdt32(frame_buf_start);
-	val[1] = cpu_to_fdt32(frame_buf_size);
-	ret_val = fdt_setprop(fdt, offset, "reg", &val, (sizeof(u32) * 2));
-	if (ret_val < 0)
-		goto fdt_update_memory_exit;
+	return ret_val;
+}
+#endif
+
+#if defined(CONFIG_BOOT_MEDIA_EMMC)
+static int fdt_update_emmc(void *fdt)
+{
+	int ret_val = -1, offset, suboffset;
+	const char *pathp;
+	u32 val, ptb_address;
+
+	pathp = fdt_get_alias(fdt, CONFIG_EMMC_BOOT_INTERFACE);
+	if (pathp == NULL) {
+		putstr("libfdt fdt_get_alias() failed\r\n");
+		return ret_val;
+	}
+
+	offset = fdt_path_offset (fdt, pathp);
+	if (offset < 0) {
+		fdt_print_error("fdt_path_offset(emmc) error:", offset);
+		return ret_val;
+	}
+
+	ptb_address = sdmmc.ssec[PART_PTB];
+	val = cpu_to_fdt32(ptb_address);
+	ret_val = fdt_setprop(fdt, offset, "amb,ptb_address",
+				&val, sizeof(u32));
+	if (ret_val < 0){
+		fdt_print_error("fdt_setprop(ptb_address) error:",
+					ret_val);
+		return ret_val;
+	}
+
+	suboffset = fdt_subnode_offset(fdt, offset, "slot@0");
+	fdt_delprop(fdt, suboffset, "amb,caps-ddr");
+
+	return ret_val;
+}
+
+#endif
+
+#if defined(CONFIG_AMBOOT_ENABLE_MULTI_VIN)
+static int fdt_update_multi_vin(void *fdt)
+{
+	const char *pathp;
+	int offset, ret_val = -1;
+
+	/* enable mulit-vin */
+	pathp = fdt_get_alias(fdt, "multi-vin");
+	if (pathp == NULL) {
+		putstr("fdt_get_alias(multi-vin) failed\r\n");
+		return ret_val;
+	}
+
+	offset = fdt_path_offset (fdt, pathp);
+	if (offset < 0) {
+		fdt_print_error("fdt_path_offset(multi-vin) error:", offset);
+		return ret_val;
+	}
+
+	ret_val = fdt_setprop(fdt, offset, "status", "ok", 3);
+	if (ret_val < 0) {
+		fdt_print_error("fdt_setprop(multi-vin) error:", ret_val);
+		return ret_val;
+	}
+
+	/* disable single-vin */
+	pathp = fdt_get_alias(fdt, "single-vin");
+	if (pathp == NULL) {
+		putstr("fdt_get_alias(single-vin) failed\r\n");
+		return ret_val;
+	}
+
+	offset = fdt_path_offset (fdt, pathp);
+	if (offset < 0) {
+		fdt_print_error("fdt_path_offset(single-vin) error:", offset);
+		return ret_val;
+	}
+
+	ret_val = fdt_setprop(fdt, offset, "status", "disabled", 9);
+	if (ret_val < 0) {
+		fdt_print_error("fdt_setprop(single-vin) error:", ret_val);
+		return ret_val;
+	}
 
-fdt_update_memory_exit:
 	return ret_val;
 }
+#endif
+
+#if defined(AMBOOT_DEV_FAST_BOOT)
+static int fdt_update_vin_clock(void *fdt)
+{
+	int offset, ret_val = -1;
+
+	/* find gclk_so */
+	offset = fdt_path_offset (fdt, "/clocks/gclk-so");
+	if (offset < 0) {
+		fdt_print_error("fdt_path_offset(/clocks/gclk-so) error:", offset);
+		return ret_val;
+	}
+
+	/* delete the clock rate so that sensor clock that sets in fastboot won't be covered */
+	ret_val = fdt_delprop(fdt, offset, "assigned-clock-rates");
+
+	return ret_val;
+}
+#endif
 
 static int fdt_update_misc(void *fdt)
 {
+	int ret_val;
+#if defined(CONFIG_AMBOOT_ENABLE_ETH)
 	flpart_table_t ptb;
 	const char *pathp;
-	int offset, ret_val;
+	int offset;
+#endif
 
 	if (fdt == NULL)
 		return -1;
@@ -400,6 +556,22 @@ static int fdt_update_misc(void *fdt)
 	}
 #endif
 
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+	ret_val = fdt_update_spinand((void *)fdt);
+	if (ret_val < 0) {
+		fdt_print_error("fdt_update_spinand:", ret_val);
+		return ret_val;
+	}
+#endif
+
+#if defined(CONFIG_BOOT_MEDIA_EMMC)
+	ret_val = fdt_update_emmc((void *)fdt);
+	if (ret_val < 0) {
+		fdt_print_error("fdt_update_emmc:", ret_val);
+		return ret_val;
+	}
+#endif
+
 #if defined(CONFIG_AMBOOT_ENABLE_ETH)
 	ret_val = flprog_get_part_table(&ptb);
 	if (ret_val < 0) {
@@ -429,22 +601,100 @@ static int fdt_update_misc(void *fdt)
 	}
 #endif
 
+#if defined(CONFIG_AMBOOT_ENABLE_MULTI_VIN)
+	ret_val = fdt_update_multi_vin((void *)fdt);
+	if (ret_val < 0) {
+		fdt_print_error("fdt_update_multi_vin:", ret_val);
+		return ret_val;
+	}
+#endif
+
+#if defined(AMBOOT_DEV_FAST_BOOT)
+	ret_val = fdt_update_vin_clock((void *)fdt);
+	if (ret_val < 0) {
+		fdt_print_error("fdt_update_vin_clock:", ret_val);
+		return ret_val;
+	}
+#endif
+
 	return 0;
 }
 
+static int fdt_update_memory(void *fdt,
+	u32 kernel_start, u32 kernel_size,
+	u32 iav_start, u32 iav_size,
+	u32 frame_buf_start, u32 frame_buf_size)
+{
+	int ret_val = -1;
+	int offset;
+	u32 val[2];
+
+	if (fdt == NULL)
+		goto fdt_update_memory_exit;
+
+	offset = fdt_node_offset_by_prop_value(fdt, -1,
+			"device_type", "memory", 7);
+	if (offset < 0) {
+		ret_val = offset;
+		goto fdt_update_memory_exit;
+	}
+
+	val[0] = cpu_to_fdt32(kernel_start);
+	val[1] = cpu_to_fdt32(kernel_size);
+	ret_val = fdt_setprop(fdt, offset, "reg", &val, (sizeof(u32) * 2));
+	if (ret_val < 0)
+		goto fdt_update_memory_exit;
+
+	/* create a new node "/iavmem" (offset 0 is root level) */
+	offset = fdt_add_subnode(fdt, 0, "iavmem");
+	if (offset < 0)
+		goto fdt_update_memory_exit;
+
+	ret_val = fdt_setprop_string(fdt, offset, "device_type", "iavmem");
+	if (ret_val < 0)
+		goto fdt_update_memory_exit;
+
+	val[0] = cpu_to_fdt32(iav_start);
+	val[1] = cpu_to_fdt32(iav_size);
+	ret_val = fdt_setprop(fdt, offset, "reg", &val, (sizeof(u32) * 2));
+	if (ret_val < 0)
+		goto fdt_update_memory_exit;
+
+	/* create a new node "/fbmem" (offset 0 is root level) */
+	offset = fdt_add_subnode(fdt, 0, "fbmem");
+	if (offset < 0)
+		goto fdt_update_memory_exit;
+
+	ret_val = fdt_setprop_string(fdt, offset, "device_type", "fbmem");
+	if (ret_val < 0)
+		goto fdt_update_memory_exit;
+
+	val[0] = cpu_to_fdt32(frame_buf_start);
+	val[1] = cpu_to_fdt32(frame_buf_size);
+	ret_val = fdt_setprop(fdt, offset, "reg", &val, (sizeof(u32) * 2));
+	if (ret_val < 0)
+		goto fdt_update_memory_exit;
+
+fdt_update_memory_exit:
+	return ret_val;
+}
+
 u32 fdt_update_tags(void *jump_addr, const char *cmdline, u32 cpux_jump,
 	u32 initrd2_start, u32 initrd2_size, int verbose)
 {
-	u32 mem_base, mem_size, dtb_addr, cmdline_mem_size;
+	uintptr_t mem_base, mem_size, dtb_addr, cmdline_mem_size;
 	u32 kernelp, kernels;
 	u32 idspp, idsps;
 	u32 fbp, fbs;
 	int ret_val;
 
-	mem_base = (((u32)jump_addr) & (~SIZE_1MB_MASK));
+	mem_base = (((uintptr_t)jump_addr) & (~SIZE_1MB_MASK));
 	mem_size = (IDSP_RAM_START - mem_base - FRAMEBUFFER_SIZE);
-	K_ASSERT(mem_base >= DRAM_START_ADDR);
-	K_ASSERT(mem_size <= DRAM_SIZE);
+#ifdef AMBOOT_LZO_RESERVE_SIZE
+	mem_size -= AMBOOT_LZO_RESERVE_SIZE;
+#endif
+	BUG_ON(mem_base < DRAM_START_ADDR);
+	BUG_ON(mem_size > DRAM_SIZE);
 
 #ifdef CONFIG_AMBOOT_FDT_LOW_ADDR
 	dtb_addr = mem_base;
@@ -485,11 +735,11 @@ u32 fdt_update_tags(void *jump_addr, const char *cmdline, u32 cpux_jump,
 		putstr("\r\n");
 	}
 
-	kernelp = ARM11_TO_CORTEX(mem_base);
+	kernelp = mem_base;
 	kernels = mem_size;
-	idspp = ARM11_TO_CORTEX(IDSP_RAM_START);
+	idspp = IDSP_RAM_START;
 	idsps = (DRAM_SIZE - (IDSP_RAM_START - DRAM_START_ADDR));
-        fbp = ARM11_TO_CORTEX(IDSP_RAM_START - FRAMEBUFFER_SIZE);
+        fbp = IDSP_RAM_START - FRAMEBUFFER_SIZE;
         fbs = FRAMEBUFFER_SIZE;
 	if (verbose) {
 		putstr("kernelp: 0x");
@@ -521,7 +771,7 @@ u32 fdt_update_tags(void *jump_addr, const char *cmdline, u32 cpux_jump,
 	ret_val = fdt_update_misc((void *)dtb_addr);
 
 fdt_update_tags_exit:
-	return ARM11_TO_CORTEX(dtb_addr);
+	return dtb_addr;
 }
 
 int fdt_update_cmdline(void *fdt, const char *cmdline)
diff --git a/src/bld/firmfl.c b/src/bld/firmfl.c
index cd30405..1d47bdf 100644
--- a/src/bld/firmfl.c
+++ b/src/bld/firmfl.c
@@ -7,12 +7,30 @@
  *    2005/01/31 - [Charles Chiou] created file
  *    2014/02/13 - [Anthony Ginger] Amboot V2
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
@@ -20,13 +38,17 @@
 #include <ambhw/spinor.h>
 #include <bldfunc.h>
 #include <libfdt.h>
-#include <flash/flash.h>
 #include <flash/spinor/spinor_flash.h>
 #include <fio/ftl_const.h>
 #include <sdmmc.h>
 
+struct nand_oobfree {
+	u32 offset;
+	u32 length;
+};
+
 /*===========================================================================*/
-#define FWPROG_BUF_SIZE		(4096) /* should be multiple of 2048 */
+#define FWPROG_BUF_SIZE		0x10000/* should be multiple of 2048 */
 
 /*===========================================================================*/
 static const char *FLPROG_ERR_STR[] = {
@@ -46,13 +68,11 @@ static const char *FLPROG_ERR_STR[] = {
 static u32 bld_ptb_buf_filled = 0;
 static u8 bld_ptb_buf[AMBOOT_PTB_BUF_SIZE]
 	__attribute__ ((aligned(32), section(".bss.noinit")));
-#if defined(CONFIG_AMBOOT_BD_FDT_SUPPORT)
 static void *fdt_root = PTB_DTB(bld_ptb_buf);
-#endif
 
 /*===========================================================================*/
-#if defined(CONFIG_AMBOOT_ENABLE_NAND) || \
-	defined(CONFIG_AMBOOT_ENABLE_SD) || defined(CONFIG_AMBOOT_ENABLE_SPINOR)
+#if defined(CONFIG_AMBOOT_ENABLE_NAND) || defined(CONFIG_AMBOOT_ENABLE_SD) || \
+	defined(CONFIG_AMBOOT_ENABLE_SPINOR) || defined(CONFIG_AMBOOT_ENABLE_SPINAND)
 static u8 check_buf[FWPROG_BUF_SIZE]
 	__attribute__ ((aligned(32), section(".bss.noinit")));
 #endif
@@ -73,6 +93,10 @@ flnand_t flnand;
 flspinor_t flspinor;
 #endif
 
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+flspinand_t flspinand;
+#endif
+
 /*===========================================================================*/
 static int flprog_output_progress(int percentage, void *arg)
 {
@@ -336,7 +360,7 @@ static int flprog_ptb_nand_write(u8 *pptb_buf)
 #endif
 
 #if defined(CONFIG_AMBOOT_ENABLE_SD)
-int flprog_sm_prog_sector_loop(u8 *raw_image, unsigned int raw_size,
+static int flprog_sm_prog_sector_loop(u8 *raw_image, unsigned int raw_size,
 	u32 ssec, u32 nsec, int (*output_progress)(int, void *), void *arg)
 {
 	int ret_val = 0;
@@ -593,7 +617,7 @@ static int flprog_ptb_spinor_read(u8 *pptb_buf)
 
 	address = flspinor.ssec[PART_PTB] * flspinor.sector_size;
 
-	ret_val = spinor_read_data(address, pptb_buf, AMBOOT_PTB_BUF_SIZE);
+	ret_val = flspinor.read(address, pptb_buf, AMBOOT_PTB_BUF_SIZE);
 	if (ret_val < 0)
 		return ret_val;
 
@@ -607,6 +631,270 @@ static int flprog_ptb_spinor_read(u8 *pptb_buf)
 }
 #endif
 
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+static int flprog_spinand_prog_block_loop(u8 *raw_image, u32 raw_size,
+	u32 sblk, u32 nblk, int (*output_progress)(int, void *), void *arg)
+{
+	int ret_val = 0;
+	int firm_ok = 0;
+	u32 block;
+	u32 page;
+	u32 percentage;
+	unsigned int offset;
+	unsigned int pre_offset;
+	offset = 0;
+	for (block = sblk; block < (sblk + nblk); block++) {
+		ret_val = spinand_is_bad_block(block);
+		if (ret_val & NAND_ALL_BAD_BLOCK_FLAGS) {
+			spinand_output_bad_block(block, ret_val);
+			ret_val = 0;
+			continue;
+		}
+
+		ret_val = spinand_erase_block(block);
+		if (ret_val < 0) {
+			putstr("erase failed. <block ");
+			putdec(block);
+			putstr(">\r\n");
+			putstr("Try next block...\r\n");
+
+			/* Marked and skipped bad block */
+			ret_val = spinand_mark_bad_block(block);
+			if (ret_val < 0) {
+				return FLPROG_ERR_PROG_IMG;
+			} else {
+				continue;
+			}
+		}
+
+		/* erase the unused block after program ok */
+		if (firm_ok == 1)
+			continue;
+
+		pre_offset = offset;
+		/* Program each page */
+		for (page = 0; page < flspinand.pages_per_block; page++) {
+			/* Program a page */
+			ret_val = spinand_prog_pages(block, page, 1,
+				(raw_image + offset));
+			if (ret_val < 0) {
+				putstr("program failed. <block ");
+				putdec(block);
+				putstr(", page ");
+				putdec(page);
+				putstr(">\r\n");
+				break;
+			}
+			/* Read it back for verification */
+			ret_val = spinand_read_pages(block, page, 1,
+				check_buf, 1);
+			if (ret_val < 0) {
+				putstr("read failed. <block ");
+				putdec(block);
+				putstr(", page ");
+				putdec(page);
+				putstr(">\r\n");
+				break;
+			}
+
+			/* Compare memory content after read back */
+			ret_val = memcmp(raw_image + offset,
+				check_buf, flspinand.main_size);
+			if (ret_val != 0) {
+				putstr("check failed. <block ");
+				putdec(block);
+				putstr(", page ");
+				putdec(page);
+				putstr(">\r\n");
+				ret_val = -1;
+				break;
+			}
+			offset += flspinand.main_size;
+			if (offset >= raw_size) {
+				firm_ok = 1;
+				break;
+			}
+		}
+		if (ret_val < 0) {
+			offset = pre_offset;
+			ret_val = spinand_mark_bad_block(block);
+			if (ret_val < 0) {
+				break;
+			} else {
+				ret_val = spinand_is_bad_block(block);
+				spinand_output_bad_block(block, ret_val);
+				ret_val = 0;
+				continue;
+			}
+		} else {
+			if (output_progress) {
+				if (offset >= raw_size)
+					percentage = 100;
+				else
+					percentage = offset / (raw_size / 100);
+
+				output_progress(percentage, NULL);
+			}
+		}
+	}
+
+	if ((ret_val < 0) || (firm_ok == 0)) {
+		ret_val = FLPROG_ERR_PROG_IMG;
+	}
+
+	return ret_val;
+}
+static u32 spinand_bst_crc = 0;
+static int flprog_spinand_prog_bst(u8 *raw_image, u32 raw_size,
+	u32 sblk, u32 nblk, int (*output_progress)(int, void *), void *arg)
+{
+	int address;
+	u32 bst_size;
+
+	struct spinor_boot_header header;
+	int rval;
+
+	memzero(&header, sizeof(struct spinor_boot_header));
+
+	/* SPINOR_LENGTH_REG */
+	header.data_len = AMBOOT_BST_FIXED_SIZE - sizeof(struct spinor_boot_header);
+	header.clk_divider = 32;
+	header.dummy_len = 0;
+	header.addr_len = 3;
+	header.cmd_len = 1;
+	/* SPINOR_CTRL_REG */
+	header.read_en = 1;
+	header.write_en = 0;
+	header.rsvd0 = 0;
+	header.rxlane = 1;
+	header.data_lane = 0x1;
+	header.addr_lane = 0x0;
+	header.cmd_lane = 0x0;
+	header.rsvd1 = 0;
+	header.data_dtr = 0;
+	header.dummy_dtr = 0;
+	header.addr_dtr = 0;
+	header.cmd_dtr = 0;
+	/* SPINOR_CFG_REG */
+	header.rxsampdly = 1;
+	header.rsvd2 = 0;
+	header.chip_sel = (~(1 << (SPINOR_FLASH_CHIP_SEL))) & 0xff;
+	header.hold_timing = 0;
+	header.rsvd3 = 0;
+	header.hold_pin = 0;
+	header.flow_ctrl = 1;
+	/* SPINOR_CMD_REG */
+	header.cmd = SPINOR_CMD_READ;
+	/* SPINOR_ADDRHI_REG */
+	header.addr_hi = 0x0;
+	/* SPINOR_ADDRLO_REG */
+	header.addr_lo = 0x0 + sizeof(struct spinor_boot_header);
+
+	/* bst is always programmed in the first block/page */
+	if (sblk != 0)
+		return -1;
+
+	if (AMBOOT_BST_FIXED_SIZE > flspinand.main_size) {
+		putstr("BST size is too big for spinand page size\r\n");
+		return -1;
+	}
+
+	rval = spinand_erase_block(sblk);
+	if (rval < 0) {
+		putstr("erase failed. <sector 0>\r\n");
+		return rval;
+	}
+
+#if 0
+	spinand_bst_crc = crc32(raw_image, AMBOOT_PTB_BUF_SIZE);
+	putstr("spi nand bst image crc32 value is 0x");
+	puthex(spinand_bst_crc);
+	putstr("\r\n");
+#endif
+	memcpy(check_buf, &header, sizeof(struct spinor_boot_header));
+
+	address = 0 + sizeof(struct spinor_boot_header);
+	bst_size = max((AMBOOT_BST_FIXED_SIZE - sizeof(struct spinor_boot_header)),raw_size);
+	memcpy(check_buf + address, raw_image, bst_size);
+	rval = spinand_program_page(0, 0, check_buf, AMBOOT_BST_FIXED_SIZE);
+	if (rval < 0) {
+		putstr("program failed. <block 0>\r\n");
+		return rval;
+	}
+
+	if (output_progress)
+		output_progress(100, NULL);
+
+	return 0;
+}
+
+static void flprog_ptb_spinand_fix_meta(flpart_meta_t *pmeta)
+{
+	int i;
+
+	for (i = 0; i <= HAS_IMG_PARTS; i++) {
+		memzero(pmeta->part_info[i].name, PART_NAME_LEN);
+		memcpy(pmeta->part_info[i].name, get_part_str(i),
+			strlen(get_part_str(i)));
+		pmeta->part_info[i].dev = get_part_dev(i);
+		pmeta->part_info[i].sblk = flspinand.sblk[i];
+		pmeta->part_info[i].nblk = flspinand.nblk[i];
+	}
+	for (; i < PART_MAX; i++) {
+		memzero(pmeta->part_info[i].name, PART_NAME_LEN);
+		pmeta->part_info[i].dev = PART_DEV_AUTO;
+		pmeta->part_info[i].sblk = 0;
+		pmeta->part_info[i].nblk = 0;
+	}
+
+	pmeta->magic = PTB_META_MAGIC;
+}
+
+static int flprog_ptb_spinand_write(u8 *pptb_buf)
+{
+	int ret_val = -1;
+
+	flprog_ptb_spinand_fix_meta(PTB_META(pptb_buf));
+
+	flprog_ptb_fix_header(pptb_buf);
+
+	ret_val = flprog_spinand_prog_block_loop(pptb_buf, AMBOOT_PTB_BUF_SIZE,
+		flspinand.sblk[PART_PTB], flspinand.nblk[PART_PTB], NULL, NULL);
+
+	return ret_val;
+}
+
+static int flprog_ptb_spinand_read(u8 *pptb_buf)
+{
+	int ret_val;
+	u32 blk, pages, sblk, nblk;
+
+	sblk = flspinand.sblk[PART_PTB];
+	nblk = flspinand.nblk[PART_PTB];
+	/* skip bad block */
+	for (blk = sblk; blk < (sblk + nblk); blk++) {
+		if (!spinand_is_bad_block(blk))
+			break;
+	}
+	if (blk >= (sblk + nblk)) {
+		return -1;
+	}
+	pages = (AMBOOT_PTB_BUF_SIZE + flspinand.main_size - 1) / flspinand.main_size;
+
+	ret_val = spinand_read_pages(blk, 0, pages, pptb_buf, 1);
+	if (ret_val < 0)
+		return ret_val;
+
+	ret_val = flprog_ptb_check_header(pptb_buf);
+	if (ret_val < 0)
+		return ret_val;
+
+	flprog_ptb_spinand_fix_meta(PTB_META(pptb_buf));
+
+	return 0;
+}
+#endif
+
 static int flprog_ptb_read_data(void)
 {
 	int ret_val = -1;
@@ -632,7 +920,11 @@ static int flprog_ptb_read_data(void)
 		ret_val = flprog_ptb_spinor_read(bld_ptb_buf);
 	}
 #endif
-
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+	if ((ret_val < 0) && (part_dev & PART_DEV_SPINAND)) {
+		ret_val = flprog_ptb_spinand_read(bld_ptb_buf);
+	}
+#endif
 	if (ret_val < 0)
 		memzero(bld_ptb_buf, AMBOOT_PTB_BUF_SIZE);
 	else {
@@ -666,6 +958,11 @@ static int flprog_ptb_write_data(void)
 		ret_val = flprog_ptb_spinor_write(bld_ptb_buf);
 	}
 #endif
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+	if (part_dev & PART_DEV_SPINAND) {
+		ret_val = flprog_ptb_spinand_write(bld_ptb_buf);
+	}
+#endif
 	if (ret_val < 0) {
 		putstr("Set ptb failed\r\n");
 		ret_val = FLPROG_ERR_PTB_SET;
@@ -739,7 +1036,6 @@ int flprog_set_part_table(flpart_table_t *pptb)
 }
 
 /*===========================================================================*/
-#if defined(CONFIG_AMBOOT_BD_FDT_SUPPORT)
 int flprog_get_dtb(u8 *dtb)
 {
 	int ret_val = 0;
@@ -793,7 +1089,6 @@ int flprog_set_dtb(u8 *dtb, u32 len, u32 write)
 flprog_set_dtb_exit:
 	return ret_val;
 }
-#endif
 
 /*===========================================================================*/
 static int flprog_validate_image(u8 *image, unsigned int len)
@@ -801,8 +1096,8 @@ static int flprog_validate_image(u8 *image, unsigned int len)
 	partimg_header_t *header;
 	u32 raw_crc32;
 
-	K_ASSERT(image != NULL);
-	K_ASSERT(len > sizeof(partimg_header_t));
+	BUG_ON(!image);
+	BUG_ON(len <= sizeof(partimg_header_t));
 
 	header = (partimg_header_t *)image;
 	if (header->magic != PARTHD_MAGIC) {
@@ -836,7 +1131,7 @@ static int flprog_validate_image(u8 *image, unsigned int len)
 }
 
 #if defined(CONFIG_AMBOOT_ENABLE_NAND)
-int flprog_write_partition_nand(int pid, u8 *image, unsigned int len)
+static int flprog_write_partition_nand(int pid, u8 *image, unsigned int len)
 {
 	int ret_val;
 	partimg_header_t *header;
@@ -860,7 +1155,7 @@ int flprog_write_partition_nand(int pid, u8 *image, unsigned int len)
 #endif
 
 #if defined(CONFIG_AMBOOT_ENABLE_SD)
-int flprog_write_partition_sd(int pid, u8 *image, unsigned int len)
+static int flprog_write_partition_sd(int pid, u8 *image, unsigned int len)
 {
 	int ret_val = 0;
 	partimg_header_t *header;
@@ -884,16 +1179,21 @@ int flprog_write_partition_sd(int pid, u8 *image, unsigned int len)
 	if (ret_val < 0) {
 		goto flprog_write_partition_sd_exit;
 	}
+#if defined(CONFIG_EMMC_BLD_OPTION)
+	if (pid == PART_BLD) {
+#else
 	if (pid == PART_BST) {
+#endif
 		ret_val = sdmmc_set_emmc_normal();
 	}
 
+
 flprog_write_partition_sd_exit:
 	return ret_val;
 }
 #endif
 #if defined(CONFIG_AMBOOT_ENABLE_SPINOR)
-int flprog_write_partition_spinor(int pid, u8 *image, unsigned int len)
+static int flprog_write_partition_spinor(int pid, u8 *image, unsigned int len)
 {
 	partimg_header_t *header;
 	u8 *raw_image;
@@ -920,6 +1220,36 @@ int flprog_write_partition_spinor(int pid, u8 *image, unsigned int len)
 	return ret_val;
 }
 #endif
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+static int flprog_write_partition_spinand(int pid, u8 *image, unsigned int len)
+{
+	partimg_header_t *header;
+	u8 *raw_image;
+	u32 raw_size = 0;
+	u32 sblk = 0;
+	u32 nblk = 0;
+	int ret_val;
+
+	putstr(" into SPINAND\r\n");
+
+	header = (partimg_header_t *)image;
+	raw_image = (image + sizeof(partimg_header_t));
+	raw_size = header->img_len;
+
+	sblk = flspinand.sblk[pid];
+	nblk = flspinand.nblk[pid];
+
+	if (pid == PART_BST) {
+		ret_val = flprog_spinand_prog_bst(raw_image, raw_size,
+				sblk, nblk, flprog_output_progress, NULL);
+	} else {
+		ret_val = flprog_spinand_prog_block_loop(raw_image, raw_size,
+				sblk, nblk, flprog_output_progress, NULL);
+	}
+
+	return ret_val;
+}
+#endif
 
 int flprog_write_partition(int pid, u8 *image, unsigned int len)
 {
@@ -976,7 +1306,13 @@ int flprog_write_partition(int pid, u8 *image, unsigned int len)
 		ret_val = flprog_write_partition_spinor(pid, image, len);
 	}
 #endif
-
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+	if (part_dev & PART_DEV_SPINAND) {
+		ret_val = flprog_write_partition_spinand(pid, image, len);
+		if (pid == PART_BST)
+			header->crc32 = spinand_bst_crc;
+	}
+#endif
 	/* Update the PTB's entry */
 	if (ret_val == 0) {
 		flpart_table_t ptb;
@@ -1034,7 +1370,7 @@ static int flprog_erase_partition_nand(int pid)
 
 	if (pid == HAS_IMG_PARTS) {
 		sblk = 0;
-		nblk = flnand.blocks_per_bank * flnand.banks;
+		nblk = flnand.blocks_per_bank;
 	} else {
 		sblk = flnand.sblk[pid];
 		nblk = flnand.nblk[pid];
@@ -1132,6 +1468,42 @@ static int flprog_erase_partition_spinor(int pid)
 }
 #endif
 
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+static int flprog_erase_partition_spinand(int pid)
+{
+	int ret_val = 0;
+	u32 sblk = 0;
+	u32 nblk = 0;
+	u32 block;
+
+	if (pid == HAS_IMG_PARTS) {
+		sblk = 0;
+		nblk = flspinand.chip_size / flspinand.block_size;
+	} else {
+		sblk = flspinand.sblk[pid];
+		nblk = flspinand.nblk[pid];
+	}
+
+	for (block = sblk; block < (sblk + nblk); block++) {
+		ret_val = spinand_is_bad_block(block);
+		if (ret_val & NAND_FW_BAD_BLOCK_FLAGS) {
+			spinand_output_bad_block(block, ret_val);
+			continue;
+		}
+
+		ret_val = spinand_erase_block(block);
+		if (ret_val < 0) {
+			spinand_mark_bad_block(block);
+			putstr(" failed! <block ");
+			putdec(block);
+			putstr(">\r\n");
+		}
+	}
+
+	return ret_val;
+}
+#endif
+
 int flprog_erase_partition(int pid)
 {
 	int ret_val = -1;
@@ -1165,6 +1537,11 @@ int flprog_erase_partition(int pid)
 		ret_val = flprog_erase_partition_spinor(pid);
 	}
 #endif
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+	if (part_dev & PART_DEV_SPINAND) {
+		ret_val = flprog_erase_partition_spinand(pid);
+	}
+#endif
 	if ((ret_val == 0) && (pid != HAS_IMG_PARTS) && (pid != PART_PTB)) {
 		flpart_table_t ptb;
 		flpart_t part;
@@ -1285,6 +1662,9 @@ static void flprog_show_meta_detail(flpart_meta_t *pmeta)
 		if (pmeta->part_info[i].dev & PART_DEV_SPINOR) {
 			putstr(" SPI NOR");
 		}
+		if (pmeta->part_info[i].dev & PART_DEV_SPINAND) {
+			putstr(" SPI NAND");
+		}
 		putstr("\r\n");
 	}
 	putstr("\r\n");
@@ -1324,6 +1704,36 @@ void flprog_show_meta(void)
 		putstr("\r\n");
 	}
 #endif
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+	if (part_dev & PART_DEV_SPINAND) {
+		putstr("SPINAND meta:\r\n");
+		flprog_ptb_spinand_fix_meta(&meta);
+		flprog_show_meta_detail(&meta);
+		putstr("\r\n");
+	}
+#endif
 	putstr("\r\n");
 }
+void flprog_bootcmd_disable(flpart_table_t *pptb)
+{
+	int ret_val;
+	pptb->dev.rsv[0] = 0;
+	ret_val = flprog_set_part_table(pptb);
+	if (ret_val < 0) {
+		putstr("PTB save error!\r\n");
+	}
+}
+
+void flprog_bootcmd_enable(flpart_table_t *pptb, char *bootcmd)
+{
+	int ret_val;
+
+	pptb->dev.rsv[0] = 3;
+	strncpy(pptb->dev.bootcmd, bootcmd, sizeof(pptb->dev.bootcmd));
+
+	ret_val = flprog_set_part_table(pptb);
+	if (ret_val < 0) {
+		putstr("PTB save error!\r\n");
+	}
+}
 
diff --git a/src/bld/fs/fat.c b/src/bld/fs/fat.c
index 7f6864d..716b648 100644
--- a/src/bld/fs/fat.c
+++ b/src/bld/fs/fat.c
@@ -1,23 +1,56 @@
+/**
+ * fs/fat.c
+ *
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <bldfunc.h>
 #include <sdmmc.h>
 #include <ambhw/cache.h>
-#include <ambhw/vic.h>
+#include <irq.h>
 #include <ambhw/sd.h>
 #include "fat.h"
+#include "fs.h"
 
-#define AMBA_FAT_DBG 0
-#define AMBA_FAT_EXT 0
-
-#define FILE_LIST_MAX  4 * 16
-
-char cur_dir[] = {0x2e, 0x20, 0x20, 0x20, 0x20, 0x20 ,0x20, 0x20};
-char pre_dir[] = {0x2e, 0x2e, 0x20, 0x20, 0x20, 0x20 ,0x20, 0x20};
-
-struct disk_info mydisk;
+#define VFAT_INIT_NECCESSORY()		do { 	\
+	if (disk.vfat_magic != 0x55AA) {		\
+		printf("WARNING: Please execute 'fs init' first.\n", __func__);	 \
+		return -FS_ERROR; 		\
+	}		\
+} while(0)
 
-u8 *load_addr = (u8 *)DEFAULT_BUF_START;
+#define VFAT_DBG				1
+#define VFAT_DUMP				0
+#define VFAT_DEFAULT_EXT_TXT 	0
+#define FILE_LIST_MAX 			4 * 16
 
-u8 *tbl_load_addr = (u8 *)DEFAULT_BUF_START - 16 * SIZE_1MB;
+static struct disk_info disk;
+static u8 *trash_loading = (u8 *)DEFAULT_BUF_START;
+static u8 *tbl_trash_loading = (u8 *)DEFAULT_BUF_START - 16 * SIZE_1MB;
 
 /* fat32 default cluster start is 2 */
 static u32 curcluster = 2;
@@ -28,200 +61,101 @@ static struct file file_list[FILE_LIST_MAX]
 /* file_list offset */
 static int list_offset;
 
+static int progress_speed_up = 0;
+
 static void downcase(char *str)
 {
-	while(*str != '\0'){
-		if(*str <= 'Z' && *str >= 'A'){
+	while (*str != '\0') {
+		if (*str <= 'Z' && *str >= 'A') {
 			*str +='a' - 'A';
 		}
 		str++;
 	}
 }
 
-static int fat_disk_write(u32 sector, u32 nr_sectors, unsigned int *buffer)
+static void showprogress(int s, int progress)
 {
+	 int i;
+	 int f = (progress * 100) / s;
 
-	int ret_val = 0;
+	 if (f > progress_speed_up)
+		 progress_speed_up = f;
+	 else
+		 return;
 
-	ret_val = sdmmc_write_sector(mydisk.boot_sector + sector, nr_sectors,
-			(u8 *)buffer);
-	if (ret_val < 0) {
-		putstrhex("failed write at 0x", sector);
-		return -1;
-	}
-	return 0;
-}
+	 if (f > 100)
+		 return;
 
-static int fat_disk_read(u32 sector, u32 nr_sectors, unsigned int *buffer)
-{
+	 putchar('[');
 
-	int ret_val = 0;
+	 for (i = 0; i <= f; i++)
+		 putchar('=');
 
-	ret_val = sdmmc_read_sector(mydisk.boot_sector + sector, nr_sectors,
-			(u8 *)buffer);
-	if (ret_val < 0) {
-		putstrhex("failed cluster read at 0x", sector);
-		return -1;
-	}
-	return 0;
+	 for(; i <= 100; i++)
+		 putchar(' ');
+
+	 printf("] %d%% %d/%d\r", f , progress, s);
 }
 
-static int fat_disk_write_cluster(u32 cluster, unsigned int *buffer)
+static int vfat_disk_write(u32 ssec, u32 nsec, void *buffer)
 {
 	int ret_val = 0;
-	u32 start = CLUST2SECTOR(cluster);
-	u32 nr_sectors = mydisk.clust_size;
 
-	ret_val = fat_disk_write(start, nr_sectors, (unsigned int *)buffer);
+	ret_val = sdmmc_write_sector(disk.boot_sector + ssec, nsec, (unsigned char *)buffer);
 	if (ret_val < 0) {
-		putstrhex("failed cluster write at:", cluster);
-		return -1;
+		printf("%s: Cluster write at %d sector failed\n", __func__, disk.boot_sector + ssec);
+		return -FS_ERROR;
 	}
-	return 0;
+	return FS_SUCCESS;
 }
 
-static int fat_disk_read_cluster(u32 cluster, unsigned int *buffer)
+static int vfat_disk_read(u32 ssec, u32 nsec, void *buffer)
 {
 	int ret_val = 0;
-	u32 start = CLUST2SECTOR(cluster);
-	u32 nr_sectors = mydisk.clust_size;
 
-	ret_val = fat_disk_read(start, nr_sectors, (unsigned int *)buffer);
+	ret_val = sdmmc_read_sector(disk.boot_sector + ssec, nsec, (unsigned char *)buffer);
 	if (ret_val < 0) {
-		putstrhex("failed Read at:", cluster);
-		return -1;
+		printf("%s: Cluster read at %d sector failed\n", __func__, disk.boot_sector + ssec);
+		return -FS_ERROR;
 	}
-	return 0;
+	return FS_SUCCESS;
 }
 
-static int fat_filesys_check(void)
+static int vfat_disk_write_cluster(u32 cluster, void *buffer)
 {
-
-	/* Make sure it has a valid FAT header */
-	if (fat_disk_read(0, 1, (unsigned int *)load_addr)) {
-		return -1;
-	}
-
-	/* Check if it's actually a DOS volume */
-	if (memcmp(load_addr + DOS_BOOT_MAGIC_OFFSET, "\x55\xAA", 2)) {
-		return -1;
-	}
-
-	/* Check for FAT12/FAT16/FAT32 filesystem */
-	if (!memcmp(load_addr + DOS_FS_TYPE_OFFSET, "FAT", 3))
-		return 0;
-	if (!memcmp(load_addr + DOS_FS32_TYPE_OFFSET, "FAT32", 5))
-		return 0;
-
-	return -2;
+	return vfat_disk_write(CLUST2SECTOR(cluster), disk.clust_size, buffer);
 }
 
-static int sector_magic_check(unsigned char *sector)
+static int vfat_disk_read_cluster(u32 cluster, void *buffer)
 {
-
-	if(memcmp(sector + DOS_PART_MAGIC_OFFSET , "\x55\xAA", 2)){
-		putstr("bad sector magic\r\n");
-		return -1;
-	}
-	return 0;
+	return vfat_disk_read(CLUST2SECTOR(cluster), disk.clust_size, buffer);
 }
 
-
-static int disk_dbr_info(void)
+static int vfat_filename_limit(const char *str)
 {
-	struct boot_sector *dbr;
-
-	if(fat_filesys_check()){
-		putstr("filesystem not been found\r\n");
-		return -1;
+	while(*str != '\0'){
+		if(*str <= 'Z' && *str >= 'A')
+			return -FS_ERROR;
+		str++;
 	}
-
-	if(fat_disk_read(0, 1, (unsigned int *)load_addr))
-		return -1;
-
-	if(sector_magic_check(load_addr))
-		return -1;
-
-	dbr = (struct boot_sector *)load_addr;
-
-
-	mydisk.data_sector = dbr->fats * dbr->fat32_length + dbr->reserved;
-	mydisk.tbl_addr = dbr->reserved;
-	mydisk.fatlength = dbr->fat32_length;
-	mydisk.fat_sect = dbr->reserved;
-	mydisk.sect_size = *(u16 *)dbr->sector_size;
-	mydisk.clust_size = dbr->cluster_size;
-
-	curcluster = 2;
-
-	return 0;
+	return FS_SUCCESS;
 }
 
-static int disk_mbr_info(void)
+#if VFAT_DUMP
+static void vfat_dump(void *p, int len)
 {
+	int i;
+	int *d = p;
+	for (i = 0; i < len / 4; i++) {
+		if ( i % 8 == 0 )
+			printf("\n[%08x]  ", i * 4);
 
-	struct boot_sector *dbr;
-	dos_partition_t *partition;
-	int ret_val = 0;
-
-	ret_val = sdmmc_read_sector(0, 1, load_addr);
-	if (ret_val < 0) {
-		putstr("failed Read at 0 sector\r\n");
-		return -1;
-	}
-
-	if(sector_magic_check(load_addr))
-		return -1;
-
-	/* The first sector is MBR */
-	if(fat_filesys_check() == -2){
-
-		partition = (dos_partition_t *)(load_addr + DOS_PART_TBL_OFFSET);
-
-		mydisk.boot_sector = *(int*)partition->start4;
-		mydisk.total_sector = *(int*)partition->size4;
-	}else{
-
-		/* The first sector is DBR */
-
-		dbr = (struct boot_sector *)load_addr;
-
-		mydisk.boot_sector = 0;
-		mydisk.total_sector = dbr->total_sect;
+		printf("%08x ", d[i]);
 	}
 
-	return 0;
-}
-
-static int disk_probe_once(void)
-{
-	memset(&mydisk, 0 , sizeof(mydisk));
-
-	if(disk_mbr_info())
-		return -1;
-
-	if(disk_dbr_info())
-		return -1;
-
-	return 0;
-}
-
-int file_fat_info(void)
-{
-
-	disk_probe_once();
-
-	putstrhex("DBR[sector]: 0x", mydisk.boot_sector);
-	putstrhex("Total[sector]: 0x", mydisk.total_sector);
-
-	putstrhex("Data[sector]: 0x", mydisk.data_sector);
-	putstrhex("Fat addr[sector]: 0x", mydisk.tbl_addr);
-	putstrhex("Fat length[sector]: 0x", mydisk.fatlength);
-	putstrhex("Sector[byte]: 0x", mydisk.sect_size);
-	putstrhex("Cluster[sector]: 0x", mydisk.clust_size);
-
-	return 0;
+	printf("\n");
 }
+#endif
 
 static int slot2str(dir_slot *slotptr, char *l_name, int *idx)
 {
@@ -248,19 +182,18 @@ static int slot2str(dir_slot *slotptr, char *l_name, int *idx)
 
 	return 0;
 }
-
 dir_entry * getvfatname(dir_entry *retdent, char *name, u8 *low)
 {
 	dir_entry *realdent;
 	dir_slot *slotptr = (dir_slot *)retdent;
-	u8 *limit = low + mydisk.sect_size * mydisk.clust_size;
+	u8 *limit = low + disk.sect_size * disk.clust_size;
 
 	u8 counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
 
 	int idx = 0;
 
 	if (counter > VFAT_MAXSEQ) {
-		putstr("Error: VFAT name is too long\r\n");
+		printf("Error: VFAT name is too long\n");
 		return NULL;
 	}
 
@@ -273,10 +206,10 @@ dir_entry * getvfatname(dir_entry *retdent, char *name, u8 *low)
 		counter--;
 	}
 
-	if((u8 *)slotptr >= limit){
-		putstr("no supported now\r\n");
+	if ((u8 *)slotptr >= limit){
+		printf("no supported now\n");
 		return NULL;
-	}else{
+	} else {
 		realdent = (dir_entry *)slotptr;
 	}
 
@@ -295,19 +228,19 @@ dir_entry * getvfatname(dir_entry *retdent, char *name, u8 *low)
 	return realdent;
 }
 
-static int fat_file_attr(dir_entry *entry)
+static int vfat_file_attr(dir_entry *entry)
 {
-	if((entry->attr & ATTR_DIR) == ATTR_DIR){
-		putstr("/\t");
-	}else if((entry->attr & ATTR_ARCH) == ATTR_ARCH){
-		putstr("\t");
-	}else{
-		putstr("?\t");
-	}
+	if((entry->attr & ATTR_DIR) == ATTR_DIR)
+		printf("/\t");
+	else if((entry->attr & ATTR_ARCH) == ATTR_ARCH)
+		printf("\t");
+	else
+		printf("?\t");
+
 	return 0;
 }
 
-void fat_list_push(dir_entry *entry, char *name, int offset)
+void vfat_list_push(dir_entry *entry, char *name, int offset)
 {
 	strncpy(file_list[offset].name, name, strlen(name));
 
@@ -316,16 +249,6 @@ void fat_list_push(dir_entry *entry, char *name, int offset)
 	file_list[offset].size = entry->size;
 }
 
-static int fat_filename_limit(const char *str)
-{
-	while(*str != '\0'){
-		if(*str <= 'Z' && *str >= 'A')
-			return -1;
-		str++;
-	}
-	return 0;
-}
-
 static void get_name(dir_entry *dirent, char *s_name)
 {
 	char *ptr;
@@ -351,22 +274,23 @@ static void get_name(dir_entry *dirent, char *s_name)
 
 	downcase(s_name);
 }
-static int do_fat_update(int flag)
+
+static int vfat_file_list_loading(int verbose)
 {
 	dir_entry *dirptr;
 	char s_name[256];
+	unsigned char *buffer = trash_loading;
 
 	list_offset = 0;
 	memset(file_list , 0, sizeof(file_list));
 
-	if(fat_disk_read_cluster(curcluster,(unsigned int *)load_addr))
-		return -1;
+	if(vfat_disk_read_cluster(curcluster, buffer))
+		return -FS_ERROR;
 
-	dirptr = (dir_entry *)load_addr;
+	dirptr = (dir_entry *)buffer;
 
-	while(((u32)dirptr - (u32)load_addr) < CLUSTSIZE)
+	while(((uintptr_t)dirptr - (uintptr_t)buffer) < CLUSTSIZE)
 	{
-
 		/* no need show deleted files ... */
 
 		if(dirptr->name[0] == DELETED_FLAG
@@ -380,7 +304,7 @@ static int do_fat_update(int flag)
 			if((dirptr->attr & ATTR_VFAT) == ATTR_VFAT
 					&& (dirptr->name[0] & LAST_LONG_ENTRY_MASK) ){
 
-				dirptr = getvfatname(dirptr, s_name, load_addr);
+				dirptr = getvfatname(dirptr, s_name, buffer);
 				if(!dirptr)
 					return -1;
 			}else{
@@ -393,231 +317,208 @@ static int do_fat_update(int flag)
 			get_name(dirptr, s_name);
 		}
 
-#if AMBA_FAT_DBG
-		if(flag){
-			putstr("[");
-			puthex(dirptr->attr);
-			putstr(" ");
-			puthex((dirptr->starthi << 16)|dirptr->start);
-			putstr(" ");
-			puthex(dirptr->size);
-			putstr(" ");
-			putstr("]");
-		}
-#endif
+		if (verbose)
+			printf("%s A[%08x] L[%08x] ", dirptr->attr == 0x10 ? "D" : "-",
+					(dirptr->starthi << 16)|dirptr->start, dirptr->size);
 
-		fat_list_push(dirptr, s_name, list_offset);
+		vfat_list_push(dirptr, s_name, list_offset);
 		list_offset++;
 
-		if(flag){
-			putstr(s_name);
-			fat_file_attr(dirptr);
-			putstr("\r\n");
+		if (verbose){
+			printf("%s", s_name);
+			vfat_file_attr(dirptr);
+			printf("\n");
 
 			/* just show FILE_LIST_MAX files */
 			if(list_offset >= FILE_LIST_MAX){
-				putstr("... \r\n");
-				return -1;
+				printf("overflow ... \n");
+				return FS_SUCCESS;
 			}
 		}
 		dirptr++;
 	}
 	return 0;
 }
-
-static int do_fat_chdir(const char *dir)
+static int vfat_change_directory(const char *dir)
 {
 	int i;
 	struct file *file;
-
-	for(i = 0; i < list_offset; i++){
-
+	for(i = 0; i < list_offset; i++) {
 		if(!strcmp(dir, file_list[i].name)){
-
 			if(file_list[i].attr == ATTR_DIR){
-
 				file = &file_list[i];
-
 				if(file->cluster != 0){
 					curcluster = file->cluster;
-				}else{
-				/* if parent dir ".." is root dir, the cluster is 0 */
+				} else {
+					/* if parent dir ".." is root dir, the cluster is 0 */
 					curcluster = 2;
 				}
-#if AMBA_FAT_DBG
-				putstrhex("*curcluster: 0x", curcluster);
-#endif
-				return 0;
-			}else{
-				putstr(dir);
-				putstr(" is not a directory\r\n");
-				return -1;
+				printf("Change directory: %s %d\n", dir, curcluster);
+				return FS_SUCCESS;
+			} else {
+				printf("WARNING: %s is not a directory\n", dir);
+				return -FS_ERROR;
 			}
 		}
 	}
-	putstr(dir);
-	putstr(" file no exist\r\n");
-	return -1;
-}
+	printf("ERROR:%s directory is not exist\n", dir);
+	return -FS_ERROR;
 
-static int fat_set_tbl(void)
+}
+static int vfat_magic_check(unsigned char *s)
 {
-	u32 tbl_addr = mydisk.tbl_addr;
-	u32 tbl_length = mydisk.fatlength;
-
-	/* the first TBL may be enough */
-	if(fat_disk_write(tbl_addr, tbl_length, (unsigned int *)tbl_load_addr))
-		return -1;
-
-	return 0;
+	/* Check if it's actually a DOS volume */
+	if (memcmp(s + DOS_PART_MAGIC_OFFSET , "\x55\xAA", 2) != 0) {
+		printf("%s: vfat magic is not matched!\n");
+		return -FS_ERROR;
+	}
+	return FS_SUCCESS;
+}
+static int vfat_format_check(unsigned char *s)
+{
+	return (!memcmp(s + DOS_FS_TYPE_OFFSET, "FAT", 3)
+			|| !memcmp(s + DOS_FS32_TYPE_OFFSET, "FAT32", 5));
 }
 
-static int fat_get_tbl(void)
+static int vfat_dbr_loading(void)
 {
-	u32 tbl_addr = mydisk.tbl_addr;
-	u32 tbl_length = mydisk.fatlength;
+	unsigned char *data = trash_loading;
+	struct boot_sector *dbr;
 
-	/* the first TBL may be enough */
-	if(fat_disk_read(tbl_addr, tbl_length, (unsigned int *)tbl_load_addr))
-		return -1;
+	if (vfat_disk_read(0, 1, data))
+		return -FS_ERROR;
 
-	if(*(int *)tbl_load_addr != FATTBL_MAGIC){
-		putstrhex("Fat TBL format error", *(int *)tbl_load_addr);
-		return -1;
+	if(vfat_magic_check(data)) {
+		printf("%s: magic dismatch!\n");
+		return -FS_ERROR;
 	}
 
-	return 0;
-}
+	if (vfat_format_check(data)) {
+		dbr = (struct boot_sector *)data;
 
-static struct file *fat_read_detect(const char *filename, u32 addr)
-{
-	int i;
-	struct file *file;
-
-	for(i = 0; i < list_offset; i++){
+		disk.data_sector	= dbr->fats * dbr->fat32_length + dbr->reserved;
+		disk.tbl_addr 		= dbr->reserved;
+		disk.fatlength 		= dbr->fat32_length;
+		disk.fat_sect 		= dbr->reserved;
+		disk.sect_size 		= dbr->sector_size[0]|(dbr->sector_size[1] << 8);
+		disk.clust_size 	= dbr->cluster_size;
+		disk.vfat_magic		= 0x55AA;
 
-		if(!strcmp(filename, file_list[i].name)){
-			if(file_list[i].attr == ATTR_ARCH){
+		curcluster = 2;
 
-				file = &file_list[i];
-				if(addr + file->size > (u32)DEFAULT_BUF_START){
-					putstr("file size is too big to read\r\n");
-					return NULL;
-				}
+		return FS_SUCCESS;
 
-				return file;
-			}else{
-				putstr(filename);
-				putstr(" is not a file\r\n");
-				return NULL;
-			}
-		}
 	}
 
-	putstr(filename);
-	putstr(" file no exist\r\n");
-	return NULL;
+	printf("%s: no match vfat filesystem, unbelievable!\n",__func__);
+	return -FS_ERROR;
 }
 
-static void showprogress(int progress)
+static int vfat_filesystem_loading(unsigned char *data)
 {
-	 int k = 0;
-	 int j = 0;
-
-	 if(progress > 100)
-		 return ;
-	 for (k = 0; k < 109; k++)
-		 putchar('\b');
-
-	 putchar('[');
-
-	 for ( j = 0; j < progress; j++)
-		 putchar('=');
-	 putchar('>');
+	struct boot_sector *dbr;
+	dos_partition_t *partition;
 
-	 for ( j = 1; j <= 100 - progress; j++)
-		 putchar(' ');
+	if (vfat_format_check(data)) {
+		dbr = (struct boot_sector *)data;
 
-	 putstr("]%");
-	 putdec(progress);
+		disk.boot_sector 	+= 0;
+		disk.total_sector 	= dbr->total_sect;
+		disk.data_sector	= dbr->fats * dbr->fat32_length + dbr->reserved;
+		disk.tbl_addr 		= dbr->reserved;
+		disk.fatlength 		= dbr->fat32_length;
+		disk.fat_sect 		= dbr->reserved;
+		disk.sect_size 		= dbr->sector_size[0]|(dbr->sector_size[1] << 8);
+		disk.clust_size 	= dbr->cluster_size;
+		disk.vfat_magic		= 0x55AA;
 
-	 putchar('\r');
-}
+		curcluster = 2;
 
-static int fat_load_file(u32 *tbl, u32 cluster, u32 addr, u32 nr_clust)
-{
-	int step, max;
-	int progress = 0;
-	int i = 0;
-	u32 clust_next = cluster;
+		return FS_SUCCESS;
+	}
 
-	step = max = nr_clust / 100;
+	/* If the first sector has correct magic, and is mismatched the FAT32 filesystem,
+	 * then it's a MBR sector */
 
-	do{
-		i++;
-#if AMBA_FAT_DBG
-		putstrhex("Read cluster: ", clust_next);
-#endif
-		fat_disk_read_cluster(clust_next, (unsigned int *)addr);
 
-		addr += CLUSTSIZE;
-		clust_next = *(tbl + clust_next);
+	partition = (dos_partition_t *)(data + DOS_PART_TBL_OFFSET);
 
-		if(!--step){
-			step = max;
-			showprogress(progress++);
-		}
+	disk.boot_sector += partition->start4[0]
+		| (partition->start4[1] << 8)
+		| (partition->start4[2] << 16)
+		| (partition->start4[3] << 24);
 
-		if(clust_next == FATTBL_END
-				|| clust_next == FATTBL_BAD
-				|| clust_next == FATTBL_MAGIC
-				|| !clust_next)
-			break;
+	disk.total_sector = partition->size4[0]
+		| (partition->size4[1] << 8)
+		| (partition->size4[2] << 16)
+		| (partition->size4[3] << 24);
 
-	}while(1);
+	printf("\nvfat filesystem has MBR SECTOR. DBR offset is %d.\n", disk.boot_sector);
 
-	if(max == 0)
-		showprogress(100);
+	vfat_dbr_loading();
 
-	putstr("\n");
-	return 0;
+	return FS_SUCCESS;
 }
 
-static int fat_read_progress(struct file *file, u32 addr)
+static int vfat_mbr_probe(void)
 {
-	u32 *fat_tbl = (u32 *)tbl_load_addr;
-	u32 cluster_start = file->cluster;
+	int ret_val = FS_SUCCESS;
+	unsigned char *data = trash_loading;
 
-	u32 nr_clust =  file->size / CLUSTSIZE;
+	ret_val = sdmmc_read_sector(disk.boot_sector, 1, data);
+	if (ret_val < 0) {
+		printf("%s: read %d sector error!\n", __func__, disk.boot_sector);
+		return ret_val;
+	}
 
+	if(vfat_magic_check(data)) {
+		printf("%s: magic dismatch!\n");
+		return -FS_ERROR;
+	}
 
-	fat_load_file(fat_tbl, cluster_start, addr, nr_clust);
+	ret_val = vfat_filesystem_loading(data);
+	if (ret_val < 0)
+		return ret_val;
 
-	putstr("[");
-	puthex(file->size);
-	putstr("]");
-	putdec(file->size);
-	putstr(" bytes read success ...\r\n");
+	return ret_val;
+}
+
+static int get_disk_partition_position(void)
+{
+	/* FIXME: we also support vfat filesystem on EMMC partition. Please return
+	 * your partition offset on the EMMC disk over here. Normal SD Card offset
+	 * is zero. */
 	return 0;
 }
-static  int do_fat_read(const char *filename, u32 addr)
+
+static void vfat_info_verbose(void)
 {
+	printf("Boot:		%d\n", disk.boot_sector);
+	printf("Total:		%d\n", disk.total_sector);
+	printf("Playload:	%d\n", disk.data_sector);
+	printf("Table:		%d\n", disk.tbl_addr);
+	printf("FatLen:		%d\n", disk.fatlength);
+	printf("FatSect:	%d\n", disk.fat_sect);
+	printf("SectSize:	%d\n", disk.sect_size);
+	printf("ClustSize:	%d\n", disk.clust_size);
 
-	struct file *file;
+	printf("\n");
+}
 
-	file = fat_read_detect(filename, addr);
-	if(!file)
-		return -1;
+static int vfat_disk_probe(void)
+{
+	memset(&disk, 0, sizeof(disk));
 
-	if(fat_get_tbl())
-		return -1;
+	disk.boot_sector = get_disk_partition_position();
 
-	fat_read_progress(file ,addr);
+	if (vfat_mbr_probe())
+		return -FS_ERROR;
 
-	return 0;
+	vfat_info_verbose();
+	return FS_SUCCESS;
 }
 
-static struct file *fat_write_detect(const char *filename)
+static struct file *vfat_file_detect(const char *filename)
 {
 
 	int i;
@@ -631,35 +532,55 @@ static struct file *fat_write_detect(const char *filename)
 	}
 	return file;
 }
+static int vfat_tbl_is_invalid(void)
+{
+	int *data = (int *)tbl_trash_loading;
+	/* FIXME: We don't support multiple files, so one TBL is enough for customers */
+	if (vfat_disk_read(disk.tbl_addr, disk.fatlength, data))
+		return -FS_ERROR;
+
+	if(data[0] != FATTBL_MAGIC) {
+		printf("%s: vfat TBL magic [%08x] dismatch [%08x]\n", data[0], FATTBL_MAGIC);
+		return -FS_ERROR;
+	}
+
+	return FS_SUCCESS;
+}
+static int vfat_update_tbl(void)
+{
+	return	vfat_disk_write(disk.tbl_addr, disk.fatlength, tbl_trash_loading);
+}
 
-static int fat_upload_file(dir_entry *dirptr, u32 addr, u32 size)
+static int vfat_program_write(dir_entry *dirptr, void *addr, u32 size)
 {
 
-	int step, max;
+	int s;
 	int progress = 0;
-	u32 *fat_tbl = (u32 *)tbl_load_addr;
+	u32 *fat_tbl = (u32 *)tbl_trash_loading;
 	int nr_clust =  size / CLUSTSIZE;
-
 	u32 cluster ;
 	u32 *next_clust = NULL;
-
-	step = max = nr_clust / 100;
+	unsigned char *source = addr;
 
 	if(nr_clust * CLUSTSIZE < size)
 		nr_clust++;
 
-	if(fat_get_tbl())
-		return -1;
+	s = nr_clust;
+
+	progress_speed_up = 0;
 
-	while(((u32)fat_tbl - (u32)tbl_load_addr)
-			< (mydisk.fatlength * mydisk.sect_size))
+	if(vfat_tbl_is_invalid())
+		return -FS_ERROR;
+
+	while(((uintptr_t)fat_tbl - (uintptr_t)tbl_trash_loading)
+			< (disk.fatlength * disk.sect_size))
 	{
-		if(*fat_tbl){
+		if (*fat_tbl) {
 			fat_tbl++;
 			continue;
 		}
 
-		cluster = ((u32)fat_tbl - (u32)tbl_load_addr) / 4;
+		cluster = ((uintptr_t)fat_tbl - (uintptr_t)tbl_trash_loading) / 4;
 
 		/* next_clust record next cluster */
 		if(next_clust != NULL)
@@ -672,12 +593,11 @@ static int fat_upload_file(dir_entry *dirptr, u32 addr, u32 size)
 			dirptr->starthi = (cluster >> 16) & 0xffff;
 		}
 
-		if(!--step){
-			step = max;
-			showprogress(progress++);
-		}
+		showprogress(s, ++progress);
 
-		fat_disk_write_cluster(cluster, (u32 *)addr);
+		vfat_disk_write_cluster(cluster, source);
+
+		source += CLUSTSIZE;
 
 		if(!--nr_clust){
 			*next_clust = FATTBL_END;
@@ -686,20 +606,18 @@ static int fat_upload_file(dir_entry *dirptr, u32 addr, u32 size)
 		fat_tbl++;
 	}
 
-	if(max == 0)
-		showprogress(100);
-
-	putstr("\n");
-	fat_set_tbl();
+	printf("\n");
+	vfat_update_tbl();
 	return 0;
 }
 
-static int fat_write_progress(const char *filename, u32 addr, u32 size)
+static int vfat_write_progress(const char *filename, void *addr, u32 size)
 {
 	int i;
 	dir_entry *dirptr;
 	char l_name[8];
 	char default_ext[] = {0x20, 0x20, 0x20};
+	void *data = trash_loading;
 
 	memset(l_name, 0x20, 8);
 
@@ -708,11 +626,10 @@ static int fat_write_progress(const char *filename, u32 addr, u32 size)
 	else
 		memcpy(l_name, filename, strlen(filename));
 
+	if(vfat_disk_read_cluster(curcluster, data))
+		return -FS_ERROR;
 
-	if(fat_disk_read_cluster(curcluster,(unsigned int *)load_addr))
-		return -1;
-
-	dirptr = (dir_entry *)load_addr;
+	dirptr = (dir_entry *)data;
 
 	for(i = 0; i < DIRENTSPERCLUST; i++){
 		if(dirptr->name[0] != DELETED_FLAG
@@ -727,7 +644,7 @@ static int fat_write_progress(const char *filename, u32 addr, u32 size)
 		dirptr->size = size;
 		memcpy(dirptr->name, l_name, 8);
 
-#if  AMBA_FAT_EXT
+#if  VFAT_DEFAULT_EXT_TXT
 		memcpy(dirptr->ext,"TXT",3);
 #else
 		memcpy(dirptr->ext, default_ext, 3);
@@ -741,80 +658,132 @@ static int fat_write_progress(const char *filename, u32 addr, u32 size)
 		dirptr->time     = DEFAULT_TIME;
 		dirptr->date     = DEFAULT_DATE;
 
+		vfat_program_write(dirptr, addr, size);
+		if (vfat_disk_write_cluster(curcluster, data))
+			return -FS_ERROR;
 
-		if(size != 0)
-			fat_upload_file(dirptr, addr, size);
+		printf("%s: %d bytes write at %08x successfully ...\n", filename, size, addr);
+		break;
+	}
 
-		if(fat_disk_write_cluster(curcluster,(unsigned int *)load_addr))
-			return -1;
+	return FS_SUCCESS;
 
-		putstr("[");
-		puthex(size);
-		putstr("]");
-		putdec(size);
-		putstr(" bytes write success ...\r\n");
+}
+static int vfat_file_write(const char *filename, void *src, u32 size)
+{
+	if (vfat_file_detect(filename)) {
+		printf("Collision: %s is exist!\n", filename);
+		return -FS_ERROR;
+	}
 
-		break;
+	if (size <= 0) {
+		printf("WARNING: size = %d\n", size);
+		return -FS_ERROR;
 	}
 
-	return 0;
+	if (vfat_tbl_is_invalid())
+		return -FS_ERROR;
 
+	return vfat_write_progress(filename, src, size);
 }
 
 
-static int do_fat_write(const char *filename, u32 addr, u32 size)
+static int vfat_program_read(void *tbl, unsigned int cluster, void *addr, unsigned int nr_clust)
 {
-	if(fat_write_detect(filename)){
-		putstr("file is exist\r\n");
-		return -1;
-	}
+	int s;
+	int progress = 0;
+	int i = 0;
+	unsigned char *load = addr;
+	unsigned int *offset = tbl;
+	u32 clust_next = cluster;
+	s = nr_clust;
+
+	progress_speed_up = 0;
+
+	do {
+		i++;
+		vfat_disk_read_cluster(clust_next, load);
+
+		load += CLUSTSIZE;
+		clust_next = *(offset + clust_next);
 
-	if(fat_get_tbl())
-		return -1;
+		showprogress(s, ++progress);
 
-	fat_write_progress(filename, addr, size);
+		if(clust_next == FATTBL_END
+				|| clust_next == FATTBL_BAD
+				|| clust_next == FATTBL_MAGIC
+				|| !clust_next)
+			break;
+
+	} while(1);
 
+	printf("\n");
 	return 0;
 }
 
+static int vfat_file_read(const char *name, void *addr)
+{
+	struct file *file;
+	void *vfat_tbl = tbl_trash_loading;
+
+	file = vfat_file_detect(name);
+	if (!file) {
+		printf("WARNING: %s is not found!\n", name);
+		return -FS_ERROR;
+	}
+
+	if (vfat_tbl_is_invalid())
+		return -FS_ERROR;
+
+	vfat_program_read(vfat_tbl, file->cluster, addr, file->size / CLUSTSIZE);
+
+	printf("%s: %d bytes read at %08x successfully ...\n", name, file->size, addr);
+
+	return FS_SUCCESS;
+
+}
+
+int file_fat_init(void)
+{
+	return vfat_disk_probe();
+}
 
 int file_fat_ls(const char *dir)
 {
-	if(disk_probe_once())
-		return -1;
-
-	do_fat_update(1);
-	return 0;
+	VFAT_INIT_NECCESSORY();
+	return vfat_file_list_loading(1);
 }
 
 int file_fat_chdir(const char *dir)
 {
-	if(disk_probe_once())
-		return -1;
+	VFAT_INIT_NECCESSORY();
+	if (vfat_change_directory(dir))
+		return -FS_ERROR;
 
-	do_fat_chdir(dir);
-	do_fat_update(0);
-	return 0;
+	return vfat_file_list_loading(0);
+}
+
+int file_fat_info(void)
+{
+	return FS_SUCCESS;
 }
 
 int file_fat_read(const char *filename, u32 addr, int exec)
 {
+	VFAT_INIT_NECCESSORY();
+
 	void *ptr;
-	void (*jump)(void) = (void *)addr;
+	void (*jump)(void) = (void *)(uintptr_t)addr;
 
 	if(addr < DRAM_START_ADDR || addr > DRAM_START_ADDR + DRAM_SIZE-1){
-		putstr("invalid addr\r\n");
-		return -1;
+		printf("vfat: invalid addr %08x\n", addr);
+		return -FS_ERROR;
 	}
 
-	if(disk_probe_once())
-		return -1;
-
-	do_fat_update(0);
-
-	if(do_fat_read(filename, addr))
-		return -1;
+	vfat_file_list_loading(0);
 
+	if (vfat_file_read(filename, (void *)(uintptr_t)addr))
+		return -FS_ERROR;
 
 	if (exec) {
 		putstr("Start to run...\r\n");
@@ -826,7 +795,7 @@ int file_fat_read(const char *filename, u32 addr, int exec)
 		/* put the return address in 0xc00ffffc
 		 * and let jump() to read and return back */
 		ptr = &&_return_;
-		*(volatile u32 *)(DRAM_START_ADDR + 0x000ffffc) = (u32) ptr;
+		*(volatile u32 *)(DRAM_START_ADDR + 0x000ffffc) = (uintptr_t)ptr;
 
 		__asm__ __volatile__ ("nop");
 		__asm__ __volatile__ ("nop");
@@ -843,29 +812,25 @@ _return_:
 		__asm__ __volatile__ ("nop");
 
 	}
-	return 0;
-}
+	return FS_SUCCESS;
 
+}
 int file_fat_write(const char *filename, u32 addr, u32 size)
 {
 
-	if(disk_probe_once())
-		return -1;
-
-	do_fat_update(0);
+	VFAT_INIT_NECCESSORY();
+	vfat_file_list_loading(0);
 
 	if(addr < DRAM_START_ADDR
 			|| ( addr + size > DRAM_START_ADDR + DRAM_SIZE - 1)){
-		putstr("invalid addr and size\r\n");
-		return -1;
+		printf("invalid addr and size\n");
+		return -FS_ERROR;
 	}
 
-	if(fat_filename_limit(filename)){
-		putstr("file name only support lowcase! Sorry!\r\n");
-		return -1;
+	if(vfat_filename_limit(filename)){
+		printf("file name is only supported lowcase, FIXME!\n");
+		return -FS_ERROR;
 	}
 
-	do_fat_write(filename, addr, size);
-
-	return 0;
+	return vfat_file_write(filename, (void *)(uintptr_t)addr, size);
 }
diff --git a/src/bld/fs/fat.h b/src/bld/fs/fat.h
index 2ba29a2..a342312 100644
--- a/src/bld/fs/fat.h
+++ b/src/bld/fs/fat.h
@@ -1,3 +1,33 @@
+/**
+ * fs/fat.h
+ *
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __AMBA_FAT__
 #define __AMBA_FAT__
 
@@ -15,13 +45,13 @@
 
 #define DEFAULT_BUF_START	bld_hugebuf_addr
 
-#define DIRENTSPERBLOCK	(mydisk.sect_size / sizeof(dir_entry))
-#define DIRENTSPERCLUST	((mydisk.clust_size * mydisk.sect_size) / \
+#define DIRENTSPERBLOCK	(disk.sect_size / sizeof(dir_entry))
+#define DIRENTSPERCLUST	((disk.clust_size * disk.sect_size) / \
 			 sizeof(dir_entry))
 
-#define CLUST2SECTOR(v)  (mydisk.data_sector + (v - 2) * mydisk.clust_size)
+#define CLUST2SECTOR(v)  (disk.data_sector + (v - 2) * disk.clust_size)
 
-#define CLUSTSIZE   (mydisk.clust_size * mydisk.sect_size)
+#define CLUSTSIZE   (disk.clust_size * disk.sect_size)
 
 #define FATBUFBLOCKS	6
 #define FATBUFSIZE	(mydata->sect_size * FATBUFBLOCKS)
@@ -82,7 +112,7 @@ typedef struct dos_partition {
 } dos_partition_t;
 
 
-struct disk_info{
+struct disk_info {
 	int boot_sector;
 	int total_sector;
 	int data_sector;
@@ -92,6 +122,8 @@ struct disk_info{
 	u16	fat_sect;	/* Starting sector of the FAT */
 	u16	sect_size;	/* Size of sectors in bytes */
 	u16	clust_size;	/* Size of clusters in sectors */
+
+	int vfat_magic;
 };
 
 struct file
@@ -190,4 +222,5 @@ int file_fat_chdir(const char *dir);
 int file_fat_info(void);
 int file_fat_read(const char *filename, u32 addr, int exec);
 int file_fat_write(const char *filename, u32 addr, u32 size);
+int file_fat_init(void);
 #endif  /*__AMBA_FAT__*/
diff --git a/src/bld/fs/fs.c b/src/bld/fs/fs.c
index 1b67e95..5dbe8b8 100644
--- a/src/bld/fs/fs.c
+++ b/src/bld/fs/fs.c
@@ -1,3 +1,33 @@
+/**
+ * fs/fs.c
+ *
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <bldfunc.h>
 #include "fs.h"
 #include "fat.h"
@@ -11,6 +41,7 @@ struct fstype_info {
 	int (*read)(const char *filename, u32 addr, int exec);
 	int (*write)(const char *filename, u32 addr, u32 size);
 	int (*info)(void);
+	int (*init)(void);
 };
 
 static struct fstype_info fstypes[] = {
@@ -22,6 +53,7 @@ static struct fstype_info fstypes[] = {
 		.info = file_fat_info,
 		.read = file_fat_read,
 		.write = file_fat_write,
+		.init = file_fat_init,
 	}
 };
 
@@ -48,9 +80,7 @@ int do_ls(int argc, char *argv[], int fstype)
 		return -1;
 	}
 
-	fsinfo->ls(argv[1]);
-
-	return 0;
+	return fsinfo->ls(argv[1]);
 }
 int do_info(int fstype)
 {
@@ -62,10 +92,7 @@ int do_info(int fstype)
 		return -1;
 	}
 
-	fsinfo->info();
-
-	return 0;
-
+	return fsinfo->info();
 }
 
 int do_chdir(int argc, char *argv[], int fstype)
@@ -78,10 +105,7 @@ int do_chdir(int argc, char *argv[], int fstype)
 		return -1;
 	}
 
-	fsinfo->cd(argv[1]);
-
-	return 0;
-
+	return fsinfo->cd(argv[1]);
 }
 int do_fsread(const char *filename, u32 addr, int fstype, int exec)
 {
@@ -93,9 +117,7 @@ int do_fsread(const char *filename, u32 addr, int fstype, int exec)
 		return -1;
 	}
 
-	fsinfo->read(filename, addr, exec);
-
-	return 0;
+	return fsinfo->read(filename, addr, exec);
 }
 
 int do_fswrite(const char *filename, u32 addr, int fstype, u32 size)
@@ -108,7 +130,18 @@ int do_fswrite(const char *filename, u32 addr, int fstype, u32 size)
 		return -1;
 	}
 
-	fsinfo->write(filename, addr, size);
+	return fsinfo->write(filename, addr, size);
+}
+
+int do_fsinit(int fstype)
+{
+	struct fstype_info *fsinfo;
+
+	fsinfo = fs_get_info(fstype);
+	if(fsinfo == NULL){
+		putstr("fstype is not supported\r\n");
+		return -1;
+	}
 
-	return 0;
+	return fsinfo->init();
 }
diff --git a/src/bld/fs/fs.h b/src/bld/fs/fs.h
index edb29be..37367b1 100644
--- a/src/bld/fs/fs.h
+++ b/src/bld/fs/fs.h
@@ -1,3 +1,33 @@
+/**
+ * fs/fs.h
+ *
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #ifndef __AMBA_FS__
 #define __AMBA_FS__
 
@@ -8,5 +38,9 @@ int do_chdir(int argc, char *argv[], int fstype);
 int do_fsread(const char *filename, u32 addr, int fstype, int exec);
 int do_fswrite(const char *filename, u32 addr, int fstype, u32 size);
 int do_info(int fstype);
+int do_fsinit(int fstype);
+
+#define FS_SUCCESS		0
+#define FS_ERROR		1
 
 #endif /* __AMBA_FS__*/
diff --git a/src/bld/gic.c b/src/bld/gic.c
new file mode 100644
index 0000000..34a7f02
--- /dev/null
+++ b/src/bld/gic.c
@@ -0,0 +1,193 @@
+/**
+ * bld/gic.c
+ *
+ * History:
+ *    2015/12/1 - Jorney(qtu@ambarella.com) created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <bldfunc.h>
+#include <irq.h>
+
+void irq_set_type(u32 irq, u32 type)
+{
+	u32 value, typemask;
+
+	switch (type) {
+	case IRQ_LEVEL_HIGH:
+		type = 0;
+		break;
+	case IRQ_RISING_EDGE:
+		type = 1;
+		break;
+	default:
+		ASSERT(1, "Invalid gic irq type: %d\n", type);
+		break;
+	}
+
+	value = readl(GICD_REG(GICD_ICFGR) + (irq / 16 ) * 4);
+	typemask = 0x2 << ((irq % 16) * 2);
+
+	if (type)
+		value |= typemask;
+	else
+		value &= ~typemask;
+
+	writel(GICD_REG(GICD_ICFGR) + (irq / 16 ) * 4, value);
+}
+
+void irq_disable(u32 irq)
+{
+	writel(GICD_REG(GICD_ICENABLER) + (irq / 32) * 4 , 1 << (irq % 32));
+}
+
+/* type switch: 0 - level_sensitive; 1 - edge_triggered */
+void irq_enable(u32 irq)
+{
+	writel(GICD_REG(GICD_ISENABLER) + (irq / 32) * 4 , 1 << (irq % 32));
+}
+
+static int gic_dist_init(int irq_nr)
+{
+	int i;
+
+	writel(GICD_REG(GICD_CTLR), 0);
+
+	/* set type: 0: level-sensitive; 1: edge triggered */
+	for (i = 32; i < irq_nr; i += 16)
+		writel(GICD_REG(GICD_ICFGR) + i / 4, 0x0);
+
+	/* set priority, default 0xa0 higher than cpu priority 0xf0 */
+	for (i = 32; i < irq_nr; i += 4)
+		writel(GICD_REG(GICD_IPRIORITYR) + i, 0xa0a0a0a0);
+
+	/* disable all spi */
+	for (i = 32; i < irq_nr; i += 32)
+		writel(GICD_REG(GICD_ICENABLER) + i / 8, ~0);
+
+	/* all interrupts only send to processor 0 as default */
+	for (i = 32; i < irq_nr; i += 4)
+		writel(GICD_REG(GICD_ITARGETSR) + i , 0x01010101);
+
+
+	/* set group */
+	for (i = 32; i < irq_nr; i += 32) {
+		writel(GICD_REG(GICD_IGROUPR) + i / 8, 0);
+	}
+
+	/*
+	 * Deal with the banked PPI and SGI interrupts:
+	 * - disable all PPI interrupts
+	 * - enable all SGI interrupts.
+	 */
+	writel(GICD_REG(GICD_ICENABLER), 0xffff0000);
+	writel(GICD_REG(GICD_ISENABLER), 0x0000ffff);
+
+	/* Set priority for PPI and SGI interrupts */
+	for (i = 0; i < 32; i += 4)
+		writel(GICD_REG(GICD_IPRIORITYR) + i, 0xa0a0a0a0);
+
+	/* Enable Grp0 Grp1 interrupts forward */
+	writel(GICD_REG(GICD_CTLR), 3);
+
+	return 0;
+
+}
+
+static int gic_cpu_init(void)
+{
+	u32 bypass = 0;
+
+	/* 16 supported priority levels, only interrupts with higher priority
+	 * than the value in this register are signaled to the processor */
+	writel(GICC_REG(GICC_PMR), 0xf0);
+
+	/* TODO When the signaling of FIQs or IRQs by the CPU interface is disabled,
+	 * Bypass signal is not signaled to the processor */
+	bypass = readl(GICC_REG(GICC_CTRL));
+	bypass &= 0x1e0;
+	bypass |= 0x3;
+	writel(GICC_REG(GICC_CTRL), bypass);
+
+	return 0;
+}
+
+void irq_init(void)
+{
+	int irq_nr;
+
+	disable_interrupts();
+
+	/* Get interrupts nr supported */
+	irq_nr = readl(GICD_REG(GICD_TYPER)) & 0x1f;
+	irq_nr = ((irq_nr + 1) * 32);
+	if (irq_nr > 1020)
+		irq_nr = 1020;
+
+
+	/* Distributor init (SPI)*/
+	gic_dist_init(irq_nr);
+
+	/* CPU interface init (SGI & PPI) */
+	gic_cpu_init();
+
+	enable_interrupts();
+}
+
+void irq_handler(void)
+{
+	u32 intack = readl(GICC_REG(GICC_IAR));
+	u32 irq = intack & 0x3ff;
+
+	writel(GICC_REG(GICC_EOIR), intack);
+
+	if (irq < 16)
+		printf("\n Warning: Unexpected SGI interrupt(%d) ...\n", irq);
+	else if (irq < 31)
+		printf("\n Warning: Unexpected PPI interrupt(%d) ...\n", irq);
+	else if (irq < NR_IRQS && irq_manager[irq].handler)
+		irq_manager[irq].handler(irq_manager[irq].data);
+	else if (irq < 1020)
+		printf("\n Warning: Unexpected SPI interrupt(%d) ...\n", irq);
+}
+
+void master_cpu_gic_setup(void)
+{
+#ifdef CONFIG_ARCH_CV1
+	int irq_nr, i;
+
+	irq_nr = readl(GICD_REG(GICD_TYPER)) & 0x1f;
+	irq_nr = ((irq_nr + 1) * 32);
+	if (irq_nr > 1020)
+		irq_nr = 1020;
+
+	/* Configuring all interrupts as Group 1*/
+	for (i = 0; i < irq_nr; i += 32)
+		writel(GICD_REG(GICD_IGROUPR) + i / 8, ~0);
+
+	get_permission();
+#endif
+}
diff --git a/src/bld/gpio.c b/src/bld/gpio.c
new file mode 100644
index 0000000..fbfde7a
--- /dev/null
+++ b/src/bld/gpio.c
@@ -0,0 +1,504 @@
+/**
+ * bld/gpio.c
+ *
+ * Vector interrupt controller related utilities.
+ *
+ * History:
+ *    2015/11/30 - [Cao Rongrong] created file
+ *
+ * Copyright (c) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <ambhw/gpio.h>
+#include <ambhw/uart.h>
+#include <ambhw/nand.h>
+#include <ambhw/sd.h>
+#include <ambhw/spinor.h>
+
+#ifndef DEFAULT_GPIO0_CTRL_ENA
+#define DEFAULT_GPIO0_CTRL_ENA	0x00000000
+#endif
+#ifndef DEFAULT_GPIO0_CTRL_DIR
+#define DEFAULT_GPIO0_CTRL_DIR	0x00000000
+#endif
+#ifndef DEFAULT_GPIO1_CTRL_ENA
+#define DEFAULT_GPIO1_CTRL_ENA	0x00000000
+#endif
+#ifndef DEFAULT_GPIO1_CTRL_DIR
+#define DEFAULT_GPIO1_CTRL_DIR	0x00000000
+#endif
+#ifndef DEFAULT_GPIO2_CTRL_ENA
+#define DEFAULT_GPIO2_CTRL_ENA	0x00000000
+#endif
+#ifndef DEFAULT_GPIO2_CTRL_DIR
+#define DEFAULT_GPIO2_CTRL_DIR	0x00000000
+#endif
+#ifndef DEFAULT_GPIO3_CTRL_ENA
+#define DEFAULT_GPIO3_CTRL_ENA	0x00000000
+#endif
+#ifndef DEFAULT_GPIO3_CTRL_DIR
+#define DEFAULT_GPIO3_CTRL_DIR	0x00000000
+#endif
+#ifndef DEFAULT_GPIO4_CTRL_ENA
+#define DEFAULT_GPIO4_CTRL_ENA	0x00000000
+#endif
+#ifndef DEFAULT_GPIO4_CTRL_DIR
+#define DEFAULT_GPIO4_CTRL_DIR	0x00000000
+#endif
+#ifndef DEFAULT_GPIO5_CTRL_ENA
+#define DEFAULT_GPIO5_CTRL_ENA	0x00000000
+#endif
+#ifndef DEFAULT_GPIO5_CTRL_DIR
+#define DEFAULT_GPIO5_CTRL_DIR	0x00000000
+#endif
+#ifndef DEFAULT_GPIO6_CTRL_DIR
+#define DEFAULT_GPIO6_CTRL_DIR	0x00000000
+#endif
+
+#ifndef DEFAULT_GPIO_DS0_REG_0
+#define DEFAULT_GPIO_DS0_REG_0	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS1_REG_0
+#define DEFAULT_GPIO_DS1_REG_0	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS0_REG_1
+#define DEFAULT_GPIO_DS0_REG_1	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS1_REG_1
+#define DEFAULT_GPIO_DS1_REG_1	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS0_REG_2
+#define DEFAULT_GPIO_DS0_REG_2	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS1_REG_2
+#define DEFAULT_GPIO_DS1_REG_2	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS0_REG_3
+#define DEFAULT_GPIO_DS0_REG_3	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS1_REG_3
+#define DEFAULT_GPIO_DS1_REG_3	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS0_REG_4
+#define DEFAULT_GPIO_DS0_REG_4	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS1_REG_4
+#define DEFAULT_GPIO_DS1_REG_4	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS0_REG_5
+#define DEFAULT_GPIO_DS0_REG_5	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS1_REG_5
+#define DEFAULT_GPIO_DS1_REG_5	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS0_REG_6
+#define DEFAULT_GPIO_DS0_REG_6	0xFFFFFFFF
+#endif
+#ifndef DEFAULT_GPIO_DS1_REG_6
+#define DEFAULT_GPIO_DS1_REG_6	0xFFFFFFFF
+#endif
+
+static inline u32 gpio_bank_to_base(u32 bank)
+{
+	u32 regbase;
+
+	switch (bank) {
+	case 0:
+		regbase = GPIO0_BASE;
+		break;
+	case 1:
+		regbase = GPIO1_BASE;
+		break;
+	case 2:
+		regbase = GPIO2_BASE;
+		break;
+	case 3:
+		regbase = GPIO3_BASE;
+		break;
+	case 4:
+		regbase = GPIO4_BASE;
+		break;
+	case 5:
+		regbase = GPIO5_BASE;
+		break;
+	case 6:
+		regbase = GPIO6_BASE;
+		break;
+	default:
+		return -1;
+	}
+
+	return regbase;
+}
+
+static void gpio_cfg_mode(int gpio, int mode)
+{
+	u32 regbase, bank, offset;
+
+	bank = PINID_TO_BANK(gpio);
+	offset = PINID_TO_OFFSET(gpio);
+	regbase = gpio_bank_to_base(bank);
+
+	if (mode == GPIO_FUNC_HW) {
+		setbitsl(regbase + GPIO_AFSEL_OFFSET, 0x1 << offset);
+		clrbitsl(regbase + GPIO_MASK_OFFSET, 0x1 << offset);
+	} else {
+		if (mode == GPIO_FUNC_SW_INPUT)
+			clrbitsl(regbase + GPIO_DIR_OFFSET, 0x1 << offset);
+		else
+			setbitsl(regbase + GPIO_DIR_OFFSET, 0x1 << offset);
+		clrbitsl(regbase + GPIO_AFSEL_OFFSET, 0x1 << offset);
+		setbitsl(regbase + GPIO_MASK_OFFSET, 0x1 << offset);
+	}
+}
+
+static void gpio_iomux_set_altfunc(int gpio, int alt_func)
+{
+	u32 bank, offset, data, i;
+
+	bank = PINID_TO_BANK(gpio);
+	offset = PINID_TO_OFFSET(gpio);
+
+	for (i = 0; i < 3; i++) {
+		data = readl(IOMUX_REG(IOMUX_REG_OFFSET(bank, i)));
+		data &= (~(0x1 << offset));
+		data |= (((alt_func >> i) & 0x1) << offset);
+		writel(IOMUX_REG(IOMUX_REG_OFFSET(bank, i)), data);
+	}
+}
+
+static void gpio_iomux_enable_altfunc(void)
+{
+	writel(IOMUX_REG(IOMUX_CTRL_SET_OFFSET), 0x1);
+	writel(IOMUX_REG(IOMUX_CTRL_SET_OFFSET), 0x0);
+}
+
+/* ==========================================================================*/
+
+#ifdef CONFIG_AMBOOT_ENABLE_GPIO
+
+int gpio_config_hw(int gpio, int alt_func)
+{
+	if (gpio >= AMBGPIO_SIZE) {
+		printf("gpio_config_hw: Invalid gpio: %d\n", gpio);
+		return -1;
+	}
+
+	gpio_cfg_mode(gpio, GPIO_FUNC_HW);
+	gpio_iomux_set_altfunc(gpio, alt_func);
+	gpio_iomux_enable_altfunc();
+
+	return 0;
+}
+
+int gpio_config_sw_in(int gpio)
+{
+	if (gpio >= AMBGPIO_SIZE) {
+		printf("gpio_config_sw_in: Invalid gpio: %d\n", gpio);
+		return -1;
+	}
+
+	gpio_cfg_mode(gpio, GPIO_FUNC_SW_INPUT);
+	gpio_iomux_set_altfunc(gpio, 0);
+	gpio_iomux_enable_altfunc();
+
+	return 0;
+}
+
+int gpio_config_sw_out(int gpio)
+{
+	if (gpio >= AMBGPIO_SIZE) {
+		printf("gpio_config_sw_out: Invalid gpio: %d\n", gpio);
+		return -1;
+	}
+
+	gpio_cfg_mode(gpio, GPIO_FUNC_SW_OUTPUT);
+	gpio_iomux_set_altfunc(gpio, 0);
+	gpio_iomux_enable_altfunc();
+
+	return 0;
+}
+
+int gpio_set(int gpio)
+{
+	u32 regbase, bank, offset;
+
+	if (gpio >= AMBGPIO_SIZE) {
+		printf("gpio_set: Invalid gpio: %d\n", gpio);
+		return -1;
+	}
+
+	bank = PINID_TO_BANK(gpio);
+	offset = PINID_TO_OFFSET(gpio);
+	regbase = gpio_bank_to_base(bank);
+
+	setbitsl(regbase + GPIO_DATA_OFFSET, 0x1 << offset);
+
+	return 0;
+}
+
+int gpio_clr(int gpio)
+{
+	u32 regbase, bank, offset;
+
+	if (gpio >= AMBGPIO_SIZE) {
+		printf("gpio_clr: Invalid gpio: %d\n", gpio);
+		return -1;
+	}
+
+	bank = PINID_TO_BANK(gpio);
+	offset = PINID_TO_OFFSET(gpio);
+	regbase = gpio_bank_to_base(bank);
+
+	clrbitsl(regbase + GPIO_DATA_OFFSET, 0x1 << offset);
+
+	return 0;
+}
+
+int gpio_get(int gpio)
+{
+	u32 regbase, bank, offset, data;
+
+	if (gpio >= AMBGPIO_SIZE) {
+		printf("gpio_get: Invalid gpio: %d\n", gpio);
+		return -1;
+	}
+
+	bank = PINID_TO_BANK(gpio);
+	offset = PINID_TO_OFFSET(gpio);
+	regbase = gpio_bank_to_base(bank);
+
+	data = readl(regbase + GPIO_DATA_OFFSET);
+
+	clrbitsl(regbase + GPIO_DATA_OFFSET, 0x1 << offset);
+
+	return !!(data & (0x1 << offset));
+}
+
+void gpio_init(void)
+{
+	writel(GPIO0_REG(GPIO_AFSEL_OFFSET), DEFAULT_GPIO0_AFSEL);
+	writel(GPIO0_REG(GPIO_DIR_OFFSET), DEFAULT_GPIO0_DIR);
+	writel(GPIO0_REG(GPIO_MASK_OFFSET), DEFAULT_GPIO0_MASK);
+	writel(GPIO0_REG(GPIO_DATA_OFFSET), DEFAULT_GPIO0_DATA);
+	writel(GPIO0_REG(GPIO_ENABLE_OFFSET), 0xffffffff);
+#if (GPIO_INSTANCES >= 2)
+	writel(GPIO1_REG(GPIO_AFSEL_OFFSET), DEFAULT_GPIO1_AFSEL);
+	writel(GPIO1_REG(GPIO_DIR_OFFSET), DEFAULT_GPIO1_DIR);
+	writel(GPIO1_REG(GPIO_MASK_OFFSET), DEFAULT_GPIO1_MASK);
+	writel(GPIO1_REG(GPIO_DATA_OFFSET), DEFAULT_GPIO1_DATA);
+	writel(GPIO1_REG(GPIO_ENABLE_OFFSET), 0xffffffff);
+#endif
+#if (GPIO_INSTANCES >= 3)
+	writel(GPIO2_REG(GPIO_AFSEL_OFFSET), DEFAULT_GPIO2_AFSEL);
+	writel(GPIO2_REG(GPIO_DIR_OFFSET), DEFAULT_GPIO2_DIR);
+	writel(GPIO2_REG(GPIO_MASK_OFFSET), DEFAULT_GPIO2_MASK);
+	writel(GPIO2_REG(GPIO_DATA_OFFSET), DEFAULT_GPIO2_DATA);
+	writel(GPIO2_REG(GPIO_ENABLE_OFFSET), 0xffffffff);
+#endif
+#if (GPIO_INSTANCES >= 4)
+	writel(GPIO3_REG(GPIO_AFSEL_OFFSET), DEFAULT_GPIO3_AFSEL);
+	writel(GPIO3_REG(GPIO_DIR_OFFSET), DEFAULT_GPIO3_DIR);
+	writel(GPIO3_REG(GPIO_MASK_OFFSET), DEFAULT_GPIO3_MASK);
+	writel(GPIO3_REG(GPIO_DATA_OFFSET), DEFAULT_GPIO3_DATA);
+	writel(GPIO3_REG(GPIO_ENABLE_OFFSET), 0xffffffff);
+#endif
+#if (GPIO_INSTANCES >= 5)
+	writel(GPIO4_REG(GPIO_AFSEL_OFFSET), DEFAULT_GPIO4_AFSEL);
+	writel(GPIO4_REG(GPIO_DIR_OFFSET), DEFAULT_GPIO4_DIR);
+	writel(GPIO4_REG(GPIO_MASK_OFFSET), DEFAULT_GPIO4_MASK);
+	writel(GPIO4_REG(GPIO_DATA_OFFSET), DEFAULT_GPIO4_DATA);
+	writel(GPIO4_REG(GPIO_ENABLE_OFFSET), 0xffffffff);
+#endif
+#if (GPIO_INSTANCES >= 6)
+	writel(GPIO5_REG(GPIO_AFSEL_OFFSET), DEFAULT_GPIO5_AFSEL);
+	writel(GPIO5_REG(GPIO_DIR_OFFSET), DEFAULT_GPIO5_DIR);
+	writel(GPIO5_REG(GPIO_MASK_OFFSET), DEFAULT_GPIO5_MASK);
+	writel(GPIO5_REG(GPIO_DATA_OFFSET), DEFAULT_GPIO5_DATA);
+	writel(GPIO5_REG(GPIO_ENABLE_OFFSET), 0xffffffff);
+#endif
+#if (GPIO_INSTANCES >= 7)
+	writel(GPIO6_REG(GPIO_AFSEL_OFFSET), DEFAULT_GPIO6_AFSEL);
+	writel(GPIO6_REG(GPIO_DIR_OFFSET), DEFAULT_GPIO6_DIR);
+	writel(GPIO6_REG(GPIO_MASK_OFFSET), DEFAULT_GPIO6_MASK);
+	writel(GPIO6_REG(GPIO_DATA_OFFSET), DEFAULT_GPIO6_DATA);
+	writel(GPIO6_REG(GPIO_ENABLE_OFFSET), 0xffffffff);
+#endif
+
+	/* initialize IOMUX */
+	writel(IOMUX_REG(IOMUX_REG0_0_OFFSET), DEFAULT_IOMUX_REG0_0);
+	writel(IOMUX_REG(IOMUX_REG0_1_OFFSET), DEFAULT_IOMUX_REG0_1);
+	writel(IOMUX_REG(IOMUX_REG0_2_OFFSET), DEFAULT_IOMUX_REG0_2);
+#if (GPIO_INSTANCES >= 2)
+	writel(IOMUX_REG(IOMUX_REG1_0_OFFSET), DEFAULT_IOMUX_REG1_0);
+	writel(IOMUX_REG(IOMUX_REG1_1_OFFSET), DEFAULT_IOMUX_REG1_1);
+	writel(IOMUX_REG(IOMUX_REG1_2_OFFSET), DEFAULT_IOMUX_REG1_2);
+#endif
+#if (GPIO_INSTANCES >= 3)
+	writel(IOMUX_REG(IOMUX_REG2_0_OFFSET), DEFAULT_IOMUX_REG2_0);
+	writel(IOMUX_REG(IOMUX_REG2_1_OFFSET), DEFAULT_IOMUX_REG2_1);
+	writel(IOMUX_REG(IOMUX_REG2_2_OFFSET), DEFAULT_IOMUX_REG2_2);
+#endif
+#if (GPIO_INSTANCES >= 4)
+	writel(IOMUX_REG(IOMUX_REG3_0_OFFSET), DEFAULT_IOMUX_REG3_0);
+	writel(IOMUX_REG(IOMUX_REG3_1_OFFSET), DEFAULT_IOMUX_REG3_1);
+	writel(IOMUX_REG(IOMUX_REG3_2_OFFSET), DEFAULT_IOMUX_REG3_2);
+#endif
+#if (GPIO_INSTANCES >= 5)
+	writel(IOMUX_REG(IOMUX_REG4_0_OFFSET), DEFAULT_IOMUX_REG4_0);
+	writel(IOMUX_REG(IOMUX_REG4_1_OFFSET), DEFAULT_IOMUX_REG4_1);
+	writel(IOMUX_REG(IOMUX_REG4_2_OFFSET), DEFAULT_IOMUX_REG4_2);
+#endif
+#if (GPIO_INSTANCES >= 6)
+	writel(IOMUX_REG(IOMUX_REG5_0_OFFSET), DEFAULT_IOMUX_REG5_0);
+	writel(IOMUX_REG(IOMUX_REG5_1_OFFSET), DEFAULT_IOMUX_REG5_1);
+	writel(IOMUX_REG(IOMUX_REG5_2_OFFSET), DEFAULT_IOMUX_REG5_2);
+#endif
+#if (GPIO_INSTANCES >= 7)
+	writel(IOMUX_REG(IOMUX_REG6_0_OFFSET), DEFAULT_IOMUX_REG6_0);
+	writel(IOMUX_REG(IOMUX_REG6_1_OFFSET), DEFAULT_IOMUX_REG6_1);
+	writel(IOMUX_REG(IOMUX_REG6_2_OFFSET), DEFAULT_IOMUX_REG6_2);
+#endif
+
+	writel(IOMUX_REG(IOMUX_CTRL_SET_OFFSET), 0x1);
+	writel(IOMUX_REG(IOMUX_CTRL_SET_OFFSET), 0x0);
+
+	/* initialize pull up/down */
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_EN_0_OFFSET), DEFAULT_GPIO0_CTRL_ENA);
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_DIR_0_OFFSET), DEFAULT_GPIO0_CTRL_DIR);
+#if (GPIO_INSTANCES >= 2)
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_EN_1_OFFSET), DEFAULT_GPIO1_CTRL_ENA);
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_DIR_1_OFFSET), DEFAULT_GPIO1_CTRL_DIR);
+#endif
+#if (GPIO_INSTANCES >= 3)
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_EN_2_OFFSET), DEFAULT_GPIO2_CTRL_ENA);
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_DIR_2_OFFSET), DEFAULT_GPIO2_CTRL_DIR);
+#endif
+#if (GPIO_INSTANCES >= 4)
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_EN_3_OFFSET), DEFAULT_GPIO3_CTRL_ENA);
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_DIR_3_OFFSET), DEFAULT_GPIO3_CTRL_DIR);
+#endif
+#if (GPIO_INSTANCES >= 5)
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_EN_4_OFFSET), DEFAULT_GPIO4_CTRL_ENA);
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_DIR_4_OFFSET), DEFAULT_GPIO4_CTRL_DIR);
+#endif
+#if (GPIO_INSTANCES >= 6)
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_EN_5_OFFSET), DEFAULT_GPIO5_CTRL_ENA);
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_DIR_5_OFFSET), DEFAULT_GPIO5_CTRL_DIR);
+#endif
+#if (GPIO_INSTANCES >= 7)
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_EN_6_OFFSET), DEFAULT_GPIO6_CTRL_ENA);
+	writel(GPIO_PAD_PULL_REG(GPIO_PAD_PULL_DIR_6_OFFSET), DEFAULT_GPIO6_CTRL_DIR);
+#endif
+
+	/* initialize drive strength */
+	writel(RCT_REG(GPIO_DS0_0_OFFSET), DEFAULT_GPIO_DS0_REG_0);
+	writel(RCT_REG(GPIO_DS1_0_OFFSET), DEFAULT_GPIO_DS1_REG_0);
+#if (GPIO_INSTANCES >= 2)
+	writel(RCT_REG(GPIO_DS0_1_OFFSET), DEFAULT_GPIO_DS0_REG_1);
+	writel(RCT_REG(GPIO_DS1_1_OFFSET), DEFAULT_GPIO_DS1_REG_1);
+#endif
+#if (GPIO_INSTANCES >= 3)
+	writel(RCT_REG(GPIO_DS0_2_OFFSET), DEFAULT_GPIO_DS0_REG_2);
+	writel(RCT_REG(GPIO_DS1_2_OFFSET), DEFAULT_GPIO_DS1_REG_2);
+#endif
+#if (GPIO_INSTANCES >= 4)
+	writel(RCT_REG(GPIO_DS0_3_OFFSET), DEFAULT_GPIO_DS0_REG_3);
+	writel(RCT_REG(GPIO_DS1_3_OFFSET), DEFAULT_GPIO_DS1_REG_3);
+#endif
+#if (GPIO_INSTANCES >= 5)
+	writel(RCT_REG(GPIO_DS0_4_OFFSET), DEFAULT_GPIO_DS0_REG_4);
+	writel(RCT_REG(GPIO_DS1_4_OFFSET), DEFAULT_GPIO_DS1_REG_4);
+#endif
+#if (GPIO_INSTANCES >= 6)
+	writel(RCT_REG(GPIO_DS0_5_OFFSET), DEFAULT_GPIO_DS0_REG_5);
+	writel(RCT_REG(GPIO_DS1_5_OFFSET), DEFAULT_GPIO_DS1_REG_5);
+#endif
+#if (GPIO_INSTANCES >= 7)
+	writel(RCT_REG(GPIO_DS0_6_OFFSET), DEFAULT_GPIO_DS0_REG_6);
+	writel(RCT_REG(GPIO_DS1_6_OFFSET), DEFAULT_GPIO_DS1_REG_6);
+#endif
+	/* waiting for pin stable
+	 * ps: uart may work abnormal at very beginnin without delay */
+	rct_timer2_dly_ms(1);
+}
+#endif
+
+/* Initiate minimal pins of UART, NAND, eMMC and SPINOR for USB boot mode */
+void gpio_mini_init(u32 boot_from)
+{
+	u32 i;
+	u32 regbase, gpio_enable = 0;
+	u32 minipin_uart[] = MINIPIN_UART_PIN;
+	u32 minipin_nand[] = MINIPIN_NAND_PIN;
+	u32 minipin_emmc[] = MINIPIN_EMMC_PIN;
+	u32 minipin_spinor[] = MINIPIN_SPINOR_PIN;
+
+	for (i = 0; i < ARRAY_SIZE(minipin_uart); i++) {
+		gpio_enable |= 1 << PINID_TO_BANK(minipin_uart[i]);
+		gpio_cfg_mode(minipin_uart[i], GPIO_FUNC_HW);
+		gpio_iomux_set_altfunc(minipin_uart[i], MINIPIN_UART_ALTFUNC);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(minipin_nand); i++) {
+		if (boot_from != RCT_BOOT_FROM_NAND) {
+			break;
+		}
+		gpio_enable |= 1 << PINID_TO_BANK(minipin_nand[i]);
+		gpio_cfg_mode(minipin_nand[i], GPIO_FUNC_HW);
+		gpio_iomux_set_altfunc(minipin_nand[i], MINIPIN_NAND_ALTFUNC);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(minipin_emmc); i++) {
+		if (boot_from != RCT_BOOT_FROM_EMMC)
+			break;
+		gpio_enable |= 1 << PINID_TO_BANK(minipin_emmc[i]);
+		gpio_cfg_mode(minipin_emmc[i], GPIO_FUNC_HW);
+		gpio_iomux_set_altfunc(minipin_emmc[i], MINIPIN_EMMC_ALTFUNC);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(minipin_spinor); i++) {
+		if (boot_from != RCT_BOOT_FROM_SPINOR)
+			break;
+		gpio_enable |= 1 << PINID_TO_BANK(minipin_spinor[i]);
+		gpio_cfg_mode(minipin_spinor[i], GPIO_FUNC_HW);
+		gpio_iomux_set_altfunc(minipin_spinor[i], MINIPIN_SPINOR_ALTFUNC);
+	}
+
+	gpio_iomux_enable_altfunc();
+
+	for (i = 0; i < GPIO_INSTANCES; i++) {
+		if (gpio_enable & (1 << i)) {
+			regbase = gpio_bank_to_base(i);
+			writel(regbase + GPIO_ENABLE_OFFSET, 0xffffffff);
+		}
+	}
+
+	/* waiting for pin stable
+	 * ps: uart may work abnormal at very beginnin without delay */
+	rct_timer2_dly_ms(1);
+}
diff --git a/src/bld/header.S b/src/bld/header.S
index 36e6af7..99bdfe5 100644
--- a/src/bld/header.S
+++ b/src/bld/header.S
@@ -4,16 +4,33 @@
  * History:
  *    2005/02/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
-#include <flash/flash.h>
 #include <fio/partition.h>
 
 .text
@@ -24,8 +41,8 @@
 .globl end_bld_image
 .globl begin_ptb_image
 .globl end_ptb_image
-.globl begin_splash_image
-.globl end_splash_image
+.globl begin_atf_image
+.globl end_atf_image
 .globl begin_pba_image
 .globl end_pba_image
 .globl begin_kernel_image
@@ -63,10 +80,10 @@ begin_bld_image:	.word	0x0
 
 begin_ptb_image:	.word	0x0
 
-#if defined(__LINK_SPL__)
-begin_splash_image:	.word	__BEGIN_SPL_IMAGE__
+#if defined(__LINK_ATF__)
+begin_atf_image:	.word	__BEGIN_ATF_IMAGE__
 #else
-begin_splash_image:	.word	0x0
+begin_atf_image:	.word	0x0
 #endif
 
 #if defined(__LINK_PBA__)
@@ -154,10 +171,10 @@ end_bld_image:		.word	0x0
 
 end_ptb_image:		.word	0x0
 
-#if defined(__LINK_SPL__)
-end_splash_image:	.word	__END_SPL_IMAGE__
+#if defined(__LINK_ATF__)
+end_atf_image:		.word	__END_ATF_IMAGE__
 #else
-end_splash_image:	.word	0x0
+end_atf_image:		.word	0x0
 #endif
 
 #if defined(__LINK_PBA__)
@@ -254,10 +271,10 @@ size_ptb:	.word		AMBOOT_PTB_SIZE
 #else
 size_ptb:	.word		0x0
 #endif
-#if defined(AMBOOT_SPL_SIZE)
-size_splash:	.word		AMBOOT_SPL_SIZE
+#if defined(AMBOOT_ATF_SIZE)
+size_atf:	.word		AMBOOT_ATF_SIZE
 #else
-size_splash:	.word		0x0
+size_atf:	.word		0x0
 #endif
 #if defined(AMBOOT_PBA_SIZE)
 size_pba:	.word		AMBOOT_PBA_SIZE
diff --git a/src/bld/host_crc32.c b/src/bld/host_crc32.c
index a471b21..4ee6e34 100644
--- a/src/bld/host_crc32.c
+++ b/src/bld/host_crc32.c
@@ -6,12 +6,30 @@
  * History:
  *    2005/03/01 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <stdio.h>
diff --git a/src/bld/host_fixbstini.c b/src/bld/host_fixbstini.c
index b9ab66f..82c4cde 100644
--- a/src/bld/host_fixbstini.c
+++ b/src/bld/host_fixbstini.c
@@ -6,12 +6,30 @@
  * History:
  *    2014/05/09 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <stdio.h>
@@ -21,10 +39,11 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include <string.h>
-#include "config.h"
 #include "bsp.h"
 #include "fio/partition.h"
 
+#define ALIGN(x, a)	(((x) + ((a) - 1)) & ~((a) - 1))
+
 #ifdef LIBXML_TREE_ENABLED
 
 static xmlNode *find_node_by_name(xmlNode *root_node, xmlChar *name)
@@ -51,10 +70,10 @@ int main(int argc, char **argv)
 	xmlDoc *doc = NULL;
 	xmlNode *root_node = NULL, *node;
 	xmlChar *xmlbuff, xmlstr[128];
-	int fd, buffersize;
-	int min_size, value;
+	int fd, buffersize, min_size;
+	int bld_media_start, bld_media_size, atf_media_start, atf_media_size;
 
-	if (argc != 3 || strncmp("bld_", argv[2], 4)){
+	if (argc < 3 || strncmp("bld_", argv[2], 4)){
 		fprintf(stderr, "error: invalid arguments\n");
 		return -1;
 	}
@@ -76,7 +95,9 @@ int main(int argc, char **argv)
 	root_node = xmlDocGetRootElement(doc);
 
 	/* BST must occupy one block or sector at least */
-#if defined(CONFIG_FLASH_ERASE_256k)
+#if defined(CONFIG_BOOT_MEDIA_EMMC)
+	min_size = 4 * 1024;
+#elif defined(CONFIG_FLASH_ERASE_256k)
 	min_size = 256 * 1024;
 #elif defined(CONFIG_FLASH_ERASE_128k)
 	min_size = 128 * 1024;
@@ -91,12 +112,12 @@ int main(int argc, char **argv)
 #endif
 
 	/* fix BLD start address in media */
-	value = AMBOOT_BST_SIZE > min_size ? AMBOOT_BST_SIZE : min_size;
-	if ((value % min_size) != 0) {
+	bld_media_start = AMBOOT_BST_SIZE > min_size ? AMBOOT_BST_SIZE : min_size;
+	if ((bld_media_start % min_size) != 0) {
 		fprintf(stderr, "Invalid bst partition size\n");
 		return -1;
 	}
-	snprintf(xmlstr, 128, "0x%08x", value);
+	snprintf(xmlstr, 128, "0x%08x", bld_media_start);
 
 	node = find_node_by_name(root_node, BAD_CAST "AMBOOT_BLD_MEDIA_START");
 	if (node == NULL) {
@@ -110,8 +131,9 @@ int main(int argc, char **argv)
 		fprintf(stderr, "Cannot open %s\n", argv[2]);
 		return -1;
 	}
-	value = lseek(fd, 0, SEEK_END);
-	snprintf(xmlstr, 128, "0x%08x", value);
+	bld_media_size = lseek(fd, 0, SEEK_END);
+	snprintf(xmlstr, 128, "0x%08x", bld_media_size);
+	close(fd);
 
 	node = find_node_by_name(root_node, BAD_CAST "AMBOOT_BLD_MEDIA_SIZE");
 	if (node == NULL) {
@@ -120,8 +142,7 @@ int main(int argc, char **argv)
 	xmlSetProp(node, BAD_CAST "value", xmlstr);
 
 	/* fix BLD start address in DRAM */
-	value = AMBOOT_BLD_RAM_START;
-	snprintf(xmlstr, 128, "0x%08x", value);
+	snprintf(xmlstr, 128, "0x%08x", AMBOOT_BLD_RAM_START);
 
 	node = find_node_by_name(root_node, BAD_CAST "AMBOOT_BLD_RAM_ADDRESS");
 	if (node == NULL) {
@@ -129,6 +150,37 @@ int main(int argc, char **argv)
 	}
 	xmlSetProp(node, BAD_CAST "value", xmlstr);
 
+	/* If ATF bin (BL31) exist, we need to fix ATF related information in .ini */
+	if (argc > 3) {
+		/* fix ATF start address in media */
+		atf_media_start = ALIGN(AMBOOT_BST_SIZE, min_size) +
+				  ALIGN(AMBOOT_PTB_SIZE, min_size) +
+				  ALIGN(AMBOOT_BLD_SIZE, min_size);
+		snprintf(xmlstr, 128, "0x%08x", atf_media_start);
+
+		node = find_node_by_name(root_node, BAD_CAST "AMBOOT_ATF_MEDIA_START");
+		if (node == NULL) {
+			node = xmlNewChild(root_node, NULL, BAD_CAST "AMBOOT_ATF_MEDIA_START", NULL);
+		}
+		xmlSetProp(node, BAD_CAST "value", xmlstr);
+
+		/* fix ATF size in media */
+		fd = open(argv[3], O_RDONLY);
+		if (fd < 0) {
+			fprintf(stderr, "Cannot open %s\n", argv[3]);
+			return -1;
+		}
+		atf_media_size = lseek(fd, 0, SEEK_END);
+		snprintf(xmlstr, 128, "0x%08x", atf_media_size);
+		close(fd);
+
+		node = find_node_by_name(root_node, BAD_CAST "AMBOOT_ATF_MEDIA_SIZE");
+		if (node == NULL) {
+			node = xmlNewChild(root_node, NULL, BAD_CAST "AMBOOT_ATF_MEDIA_SIZE", NULL);
+		}
+		xmlSetProp(node, BAD_CAST "value", xmlstr);
+	}
+
 	xmlDocDumpFormatMemory(doc, &xmlbuff, &buffersize, 1);
 	printf("%s", (char *) xmlbuff);
 
diff --git a/src/bld/host_permutate.c b/src/bld/host_permutate.c
index 81887d8..ebdd673 100644
--- a/src/bld/host_permutate.c
+++ b/src/bld/host_permutate.c
@@ -6,12 +6,30 @@
  * History:
  *    2008/11/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <stdio.h>
diff --git a/src/bld/hwusbcfg.h b/src/bld/hwusbcfg.h
index ba18ebd..bc0c2bd 100644
--- a/src/bld/hwusbcfg.h
+++ b/src/bld/hwusbcfg.h
@@ -4,12 +4,30 @@
  * History:
  *    2005/09/07 - [Arthur Yang] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HWUSBCFG_H__
diff --git a/src/bld/hwusbreg.h b/src/bld/hwusbreg.h
index 41c29af..5226022 100644
--- a/src/bld/hwusbreg.h
+++ b/src/bld/hwusbreg.h
@@ -4,12 +4,30 @@
  * History:
  *    2005/09/07 - [Arthur Yang] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __HWUSBREG_H__
@@ -34,7 +52,7 @@
 #define USB_TXFIFO_DEPTH_INTRIN		(512 / 4)		// 128 32-bit
 
 #define USB_TXFIFO_DEPTH		(64 / 4 + 4 * 512 / 4)	// 528 32-bit
-#define USB_RXFIFO_DEPTH		(0x400)			// 256 32-bit
+#define USB_RXFIFO_DEPTH		(256)			// 256 32-bit
 
 //-------------------------------------
 // USB memory map
@@ -50,33 +68,33 @@
 // USB register address
 //-------------------------------------
 
-#define	USB_EP_IN_CTRL_REG(n)	((int *)(USB_EP_IN_BASE + 0x0000 + 0x0020 * (n)))
-#define	USB_EP_IN_STS_REG(n)	((int *)(USB_EP_IN_BASE + 0x0004 + 0x0020 * (n)))
-#define	USB_EP_IN_BUF_SZ_REG(n)	((int *)(USB_EP_IN_BASE + 0x0008 + 0x0020 * (n)))
-#define	USB_EP_IN_MAX_PKT_SZ_REG(n)	((int *)(USB_EP_IN_BASE + 0x000c + 0x0020 * (n)))
-#define	USB_EP_IN_DAT_DESC_PTR_REG(n)	((int *)(USB_EP_IN_BASE + 0x0014 + 0x0020 * (n)))
-#define USB_EP_IN_WR_CFM_REG		((int *)(USB_EP_IN_BASE + 0x001c + 0x0020 * (n)))
+#define	USB_EP_IN_CTRL_REG(n)			((USB_EP_IN_BASE + 0x0000 + 0x0020 * (n)))
+#define	USB_EP_IN_STS_REG(n)			((USB_EP_IN_BASE + 0x0004 + 0x0020 * (n)))
+#define	USB_EP_IN_BUF_SZ_REG(n)			((USB_EP_IN_BASE + 0x0008 + 0x0020 * (n)))
+#define	USB_EP_IN_MAX_PKT_SZ_REG(n)		((USB_EP_IN_BASE + 0x000c + 0x0020 * (n)))
+#define	USB_EP_IN_DAT_DESC_PTR_REG(n)	((USB_EP_IN_BASE + 0x0014 + 0x0020 * (n)))
+#define USB_EP_IN_WR_CFM_REG			((USB_EP_IN_BASE + 0x001c + 0x0020 * (n)))
 
-#define	USB_EP_OUT_CTRL_REG(n)	((int *)(USB_EP_OUT_BASE + 0x0000 + 0x0020 * (n)))
-#define	USB_EP_OUT_STS_REG(n)	((int *)(USB_EP_OUT_BASE + 0x0004 + 0x0020 * (n)))
-#define	USB_EP_OUT_PKT_FRM_NUM_REG(n)	((int *)(USB_EP_OUT_BASE + 0x0008 + 0x0020 * (n)))
-#define	USB_EP_OUT_MAX_PKT_SZ_REG(n) 	((int *)(USB_EP_OUT_BASE + 0x000c + 0x0020 * (n)))
-#define	USB_EP_OUT_SETUP_BUF_PTR_REG(n) ((int *)(USB_EP_OUT_BASE + 0x0010 + 0x0020 * (n)))
-#define	USB_EP_OUT_DAT_DESC_PTR_REG(n)	((int *)(USB_EP_OUT_BASE + 0x0014 + 0x0020 * (n)))
-#define USB_EP_OUT_RD_CFM_ZO_REG		((int *)(USB_EP_OUT_BASE + 0x001c + 0x0020 * (n)))	// for slave-only mode
+#define	USB_EP_OUT_CTRL_REG(n)			((USB_EP_OUT_BASE + 0x0000 + 0x0020 * (n)))
+#define	USB_EP_OUT_STS_REG(n)			((USB_EP_OUT_BASE + 0x0004 + 0x0020 * (n)))
+#define	USB_EP_OUT_PKT_FRM_NUM_REG(n)	((USB_EP_OUT_BASE + 0x0008 + 0x0020 * (n)))
+#define	USB_EP_OUT_MAX_PKT_SZ_REG(n) 	((USB_EP_OUT_BASE + 0x000c + 0x0020 * (n)))
+#define	USB_EP_OUT_SETUP_BUF_PTR_REG(n) ((USB_EP_OUT_BASE + 0x0010 + 0x0020 * (n)))
+#define	USB_EP_OUT_DAT_DESC_PTR_REG(n)	((USB_EP_OUT_BASE + 0x0014 + 0x0020 * (n)))
+#define USB_EP_OUT_RD_CFM_ZO_REG		((USB_EP_OUT_BASE + 0x001c + 0x0020 * (n)))	// for slave-only mode
 
-#define USB_DEV_CFG_REG		((int *)(USB_DEV_BASE + 0x0000))
-#define USB_DEV_CTRL_REG	((int *)(USB_DEV_BASE + 0x0004))
-#define USB_DEV_STS_REG		((int *)(USB_DEV_BASE + 0x0008))
-#define USB_DEV_INTR_REG	((int *)(USB_DEV_BASE + 0x000c))
-#define USB_DEV_INTR_MSK_REG	((int *)(USB_DEV_BASE + 0x0010))
-#define USB_DEV_EP_INTR_REG	((int *)(USB_DEV_BASE + 0x0014))
-#define USB_DEV_EP_INTR_MSK_REG	((int *)(USB_DEV_BASE + 0x0018))
-#define USB_DEV_TEST_MODE_REG	((int *)(USB_DEV_BASE + 0x001c))
+#define USB_DEV_CFG_REG		((USB_DEV_BASE + 0x0000))
+#define USB_DEV_CTRL_REG	((USB_DEV_BASE + 0x0004))
+#define USB_DEV_STS_REG		((USB_DEV_BASE + 0x0008))
+#define USB_DEV_INTR_REG	((USB_DEV_BASE + 0x000c))
+#define USB_DEV_INTR_MSK_REG	((USB_DEV_BASE + 0x0010))
+#define USB_DEV_EP_INTR_REG		((USB_DEV_BASE + 0x0014))
+#define USB_DEV_EP_INTR_MSK_REG	((USB_DEV_BASE + 0x0018))
+#define USB_DEV_TEST_MODE_REG	((USB_DEV_BASE + 0x001c))
 
 
 
-#define USB_UDC_REG(n)		((int *)(USB_UDC_BASE + 0x0004 * (n)))
+#define USB_UDC_REG(n)		((USB_UDC_BASE + 0x0004 * (n)))
 
 //-------------------------------------
 // USB register fields
@@ -344,7 +362,11 @@
 #define BULK_OUT	3
 #define EP_NUM		(BULK_OUT + 1)
 
-#define BIT(n)		(1 << n)
+#define CTRL_IN_ID	0
+#define BULK_IN_ID	1
+#define CTRL_OUT_ID	0
+#define BULK_OUT_ID	1
+
 
 
 //-------------------------------------
@@ -362,55 +384,10 @@ struct USB_SETUP_PKT {
 struct USB_DATA_DESC {
 	u32 status;
 	u32 reserved;
-	u32 *data_ptr;
-	u32 *next_desc_ptr;
-};
-
-struct USB_DEV_REG {
-	u32 config;
-	u32 control;
-	u32 status;
-	u32 intr;
-	u32 intrmask;
-	u32 ep_intr;
-	u32 ep_intrmask;
-	u32 testmode;
-};
-
-struct USB_EP_UDC_REG {
-	u32 value;
-};
-
-struct USB_EP_IN_REG {
-	u32 control;
-	u32 status;
-	u32 buf_size;
-	u32 max_pkt_size;
-	u32 reserved1;
-	struct USB_DATA_DESC *descriptor_p;
-	u32 reserved2;
-	u32 wr_confirm;
+	u32 data_ptr;
+	u32 next_desc_ptr;
 };
 
-struct USB_EP_OUT_REG {
-	u32 control;
-	u32 status;
-	u32 pkt_frame_n;
-	u32 max_pkt_size;
-	u32 *setup_buffer_p;
-	struct USB_DATA_DESC *descriptor_p;
-	u32 rd_confirm;
-};
-
-// for usbd.tx_fifo_size/rx_fifo_size
-#define TX_FIFO_SIZE 		(528*4)
-#define RX_FIFO_SIZE		(256*4)
-// for usbd.bulk_pkt_size/control_pkt_size
-#define MAX_CTRL_PKT_SIZE64	64
-#define MAX_BULK_PKT_SIZE64	64		// Full-Speed
-#define MAX_BULK_PKT_SIZE512	512		// High-Speed
-
-
 /* for usbd.link */
 #define USB_DISCONNECT 		0
 #define USB_CONNECT		1
@@ -460,17 +437,19 @@ struct USB_EP_OUT_REG {
 #define USB_CMD_GET_FW_PTB	16
 
 /* Inquiry types */
-#define USB_BLD_INQUIRY_CHIP	0x00000001
+#define USB_BLD_INQUIRY_CHIP	0x00000001 /* Query chip ID */
+#define USB_BLD_INQUIRY_ADDR	0x00000002 /* Query BLD start address */
+#define USB_BLD_INQUIRY_REG		0x00000003 /* Query Register value */
 
 
 typedef struct _COMMAND_QUEUE_ {
 	u32 pendding;
-	u32	pipe;
-	u32	TX_RX;
-	u8	*pBuf;
-	u32	need_size;
-	u32	done_size;
-	u32	lock;
+	u32 pipe;
+	u32 TX_RX;
+	uintptr_t pBuf;
+	u32 need_size;
+	u32 done_size;
+	u32 lock;
 } COMMAND_QUEUE;
 
 
@@ -513,64 +492,29 @@ enum RX_FSM {
 	SND_DATA_PHASE,
 };
 
-typedef struct
-{
-    	u16 usb_cable;
-    	u16 usb_address;
-    	u8  enumeration;
-   	u16 device;
-    	u16 interface;
-    	u16 endpoint[EP_NUM];
-
-} DEVICE_STATUS;
-
-typedef struct
-{
-    	u8 	logical;  /* logical endpoint number  */
-    	u8 	physical; /* physical endpoint number */
-} EP_ID;
-
-typedef struct
-{
-    	EP_ID  	id;            /* endpoint id       */
-    	u8  	transfer_type; /* USB transfer type */
-    	u32 	maxpkt_size;   /* maxpacket size    */
-    	u32		fifo_size;
-} EP_INFO;
-
-struct USBDEV {
-	u32	base;
-	struct USB_DEV_REG	*dev_reg;	/* device base register */
-	void	*ep[EP_NUM];			/* endpoint base register */
-	u32	ep_descriptor[EP_NUM];	/* descriptor address */
-	u32	ep_buffer[EP_NUM];		/* packet buffer address */
-
-	u32	*setup_buffer;
-
-	EP_INFO	ep_info[EP_NUM];
-
-	u32	ctrl_tx_cnt;
-	u32	ctrl_rx_cnt;
-	u32	bulk_tx_cnt;
-	u32	bulk_rx_cnt;
-	u32	error_cnt;
-	u32	bulk_pkt_size;
-	u32	control_pkt_size;
-	u32	mode;		/* DMA or slave */
-	u32	link;		/* connected or disconnected */
-	u32	tx_fifo_size;
-	u32	rx_fifo_size;
-	u32	speed;
-	u32	intr_num;
-
-	DEVICE_STATUS status; /* feature set by host */
-
-	u32	address;	/* address set by host */
-	u32	setup[2];
-};
-
-
-
 
+void device_interrupt(u32 int_value);
+void endpoint_in_interrupt(u32 int_value);
+void endpoint_out_interrupt(u32 int_value);
+void init_setup_descriptor(int ep_num);
+void init_endpoint(int ep_num, int speed);
+void init_data_descriptor(u32 ep_num);
+u32 init_usb_hardware(void);
+u32 start_tx(u32 ep_num, void *buf_ptr, u32 *pkt_size);
+void start_rx(u32 ep_num, void *buf_ptr);
+int usb_task(void);
+void bulk_in_handler(void);
+void rx_fsm(COMMAND_QUEUE *cur_cmd);
+void control_out_handler(void);
+void decode_request(void);
+void get_descriptor(USB_DEVICE_REQUEST *req);
+void init_usb_dev(void);
+u32 usb_download(void *addr,int exec, int test_case);
+void init_usb_pll(void);
+void init_udc_reg(void);
+void print_twiddle(void);
+void set_softdisc(void);
+void usb_test (int flag);
+void usb_download_kernel (int is_fw_prog);
 
 #endif // __HWUSBREG_H__
diff --git a/src/bld/idc_bld.c b/src/bld/idc_bld.c
index c53b15f..c3d90aa 100644
--- a/src/bld/idc_bld.c
+++ b/src/bld/idc_bld.c
@@ -3,12 +3,30 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -20,61 +38,33 @@ static u32 idc_bld_get_addr(u8 idc_id, u32 reg_offset)
 {
 	u32 reg_adds = 0xFFFFFFFF;
 
-	K_ASSERT(idc_id < IDC_INSTANCES);
 	switch (idc_id) {
 	case IDC_MASTER1:
-		reg_adds = IDC_REG(reg_offset);
+		reg_adds = IDC0_REG(reg_offset);
 		break;
 #if (IDC_INSTANCES >= 2)
 	case IDC_MASTER2:
-		reg_adds = IDC2_REG(reg_offset);
+		reg_adds = IDC1_REG(reg_offset);
 		break;
 #endif
 #if (IDC_INSTANCES >= 3)
 	case IDC_MASTER3:
+		reg_adds = IDC2_REG(reg_offset);
+		break;
+#endif
+#if (IDC_INSTANCES >= 4)
+	case IDC_MASTER4:
 		reg_adds = IDC3_REG(reg_offset);
 		break;
 #endif
+	default:
+		printf("Invalid IDC id: %d\n", idc_id);
+		BUG_ON(idc_id >= IDC_INSTANCES);
 	}
 
 	return reg_adds;
 }
 
-static void idc_bld_set_pin_mux(u8 idc_id)
-{
-#if (CHIP_REV == A5S)
-	switch (idc_id) {
-	case IDC_MASTER1:
-		/* GPIO1.AFSEL[4] == 0 (IDC1)*/
-		writel(GPIO1_REG(GPIO_AFSEL_OFFSET),
-			(readl(GPIO1_REG(GPIO_AFSEL_OFFSET)) &
-			(~(0x1 << 4))));
-		break;
-	case IDC_MASTER3:
-		/* GPIO1.AFSEL[4] == 1 (IDC3)*/
-		writel(GPIO1_REG(GPIO_AFSEL_OFFSET),
-			(readl(GPIO1_REG(GPIO_AFSEL_OFFSET)) |
-			(0x1 << 4)));
-		break;
-	}
-#elif (CHIP_REV == S2) || (CHIP_REV == S2E)
-	switch (idc_id) {
-	case IDC_MASTER1:
-		/* GPIO0.AFSEL[17] == 0 (IDC1)*/
-		writel(GPIO0_REG(GPIO_AFSEL_OFFSET),
-			(readl(GPIO0_REG(GPIO_AFSEL_OFFSET)) &
-			(~(0x1 << 17))));
-		break;
-	case IDC_MASTER3:
-		/* GPIO0.AFSEL[17] == 1 (IDC3)*/
-		writel(GPIO0_REG(GPIO_AFSEL_OFFSET),
-			(readl(GPIO0_REG(GPIO_AFSEL_OFFSET)) |
-			(0x1 << 17)));
-		break;
-	}
-#endif
-}
-
 /*===========================================================================*/
 static u32 idc_bld_readl(u8 idc_id, u32 reg_offset)
 {
@@ -94,9 +84,7 @@ static inline void idc_bld_writel(u8 idc_id, u32 reg_offset, u32 reg_val)
 	u32 reg_add;
 
 	reg_add = idc_bld_get_addr(idc_id, reg_offset);
-	if (reg_add != 0xFFFFFFFF) {
-		reg_val = writel(reg_add, reg_val);
-	}
+	writel(reg_add, reg_val);
 }
 
 /*===========================================================================*/
@@ -122,8 +110,6 @@ void idc_bld_init(u8 idc_id, u32 freq_hz)
 	idc_bld_writel(idc_id, IDC_ENR_OFFSET, 0);
 	idc_bld_dclk_config(idc_id, freq_hz);
 	idc_bld_writel(idc_id, IDC_ENR_OFFSET, 1);
-
-	idc_bld_set_pin_mux(idc_id);
 }
 
 /*===========================================================================*/
@@ -165,58 +151,6 @@ static void idc_bld_writeb(u8 idc_id, u8 data)
 }
 
 /*===========================================================================*/
-#if defined(CONFIG_AMBOOT_ENABLE_ISL12022M)
-#define ISL12022M_I2C_ADDR			(0xDE)
-
-u8 idc_bld_isl12022m_read(u8 idc_id, u8 sub_adds)
-{
-	u8 isl12022m_adds = ISL12022M_I2C_ADDR;
-	u8 reg_val = 0;
-
-	idc_bld_set_8bit_addr(idc_id, isl12022m_adds, 0);
-	idc_bld_writeb(idc_id, sub_adds);
-	idc_bld_set_8bit_addr(idc_id, isl12022m_adds, 1);
-	reg_val = idc_bld_readb(idc_id, 0x0);
-	idc_bld_stop(idc_id);
-
-	return reg_val;
-}
-
-void idc_bld_isl12022m_write(u8 idc_id, u8 sub_adds, u8 reg_val)
-{
-	u8 isl12022m_adds = ISL12022M_I2C_ADDR;
-
-	idc_bld_set_8bit_addr(idc_id, isl12022m_adds, 0);
-	idc_bld_writeb(idc_id, sub_adds);
-	idc_bld_writeb(idc_id, reg_val);
-	idc_bld_stop(idc_id);
-}
-#endif
-
-/*===========================================================================*/
-#if defined(CONFIG_AMBOOT_ENABLE_PCA953X)
-u8 idc_bld_pca953x_read(u8 idc_id, u8 adds, u8 sub_adds)
-{
-	u8 reg_val = 0;
-
-	idc_bld_set_8bit_addr(idc_id, adds, 0);
-	idc_bld_writeb(idc_id, sub_adds);
-	idc_bld_set_8bit_addr(idc_id, adds, 1);
-	reg_val = idc_bld_readb(idc_id, 0x0);
-	idc_bld_stop(idc_id);
-
-	return reg_val;
-}
-
-void idc_bld_pca953x_write(u8 idc_id, u8 adds, u8 sub_adds, u8 reg_val)
-{
-	idc_bld_set_8bit_addr(idc_id, adds, 0);
-	idc_bld_writeb(idc_id, sub_adds);
-	idc_bld_writeb(idc_id, reg_val);
-	idc_bld_stop(idc_id);
-}
-#endif
-
 int idc_bld_send_buf_without_ack(unsigned char idc_id, unsigned char adds, unsigned char* buf, int count)
 {
 	int i = 0;
@@ -347,4 +281,3 @@ void idc_bld_write_8_8(u8 idc_id, u8 adds, u8 sub_adds, u8 reg_val)
 	idc_bld_stop(idc_id);
 }
 
-
diff --git a/src/bld/irq.c b/src/bld/irq.c
new file mode 100644
index 0000000..66906a7
--- /dev/null
+++ b/src/bld/irq.c
@@ -0,0 +1,56 @@
+/**
+ * bld/irq.c
+ *
+ * History:
+ *    2015/12/1 - Jorney(qtu@ambarella.com) created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <bldfunc.h>
+#include <irq.h>
+
+/* ==========================================================================*/
+
+static irq_manager_t irq_manager[NR_IRQS];
+
+#if defined(__aarch64__)
+#include "gic.c"
+#else
+#include "vic.c"
+#endif
+
+void request_irq(u32 irq, u32 type, irq_handler_t handler, void *data)
+{
+	ASSERT(irq >= NR_IRQS);
+	ASSERT(irq_manager[irq].handler != NULL);
+
+	irq_manager[irq].irq = irq;
+	irq_manager[irq].handler = handler;
+	irq_manager[irq].data = data;
+
+	irq_set_type(irq, type);
+	irq_enable(irq);
+}
diff --git a/src/bld/lib/memory.c b/src/bld/lib/memory.c
index 7462ac2..832f19f 100644
--- a/src/bld/lib/memory.c
+++ b/src/bld/lib/memory.c
@@ -4,16 +4,33 @@
  * Author: Jorney Tu <qtu@ambarella.com>
  * History: 2015/04/29 - created
  *
- * Copyright (C) 2004-2015, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
-#include <vsprintf.h>
 
 #if 0
 #define pr_debug(fmt, args...)  printf(fmt, ##args)
@@ -78,12 +95,14 @@ void *malloc(int size)
 		return NULL;
 	}
 
+#if 0
 	/* NOTE: if you need memory buffer with small size, you'd better
 	 * use stack instead of malloc */
 	if (size < MALLOC_BLOCK_SIZE / 2) {
 		printf("requested size is too small: %d!\n", size);
 		return NULL;
 	}
+#endif
 
 
 	blks = (size + MALLOC_BLOCK_SIZE - 1) / MALLOC_BLOCK_SIZE;
@@ -127,7 +146,7 @@ void *malloc(int size)
 
 	pr_debug("start_blk: %d, blks: %d\n", start_blk, blks);
 
-	return (void *)((u32)malloc_bitmap + start_blk * MALLOC_BLOCK_SIZE);
+	return (void *)((uintptr_t)malloc_bitmap + start_blk * MALLOC_BLOCK_SIZE);
 }
 
 void free(void *ptr)
@@ -139,7 +158,7 @@ void free(void *ptr)
 	if (ptr == NULL)
 		return;
 
-	start_blk = ((u32)ptr - (u32)malloc_bitmap) / MALLOC_BLOCK_SIZE;
+	start_blk = ((uintptr_t)ptr - (uintptr_t)malloc_bitmap) / MALLOC_BLOCK_SIZE;
 	nr_blk = 0;
 
 	for (i = 0; i < malloc_table_num; i++) {
@@ -161,21 +180,22 @@ void free(void *ptr)
 	}
 }
 
-int mem_malloc_init(void)
+/*
+ * Initialize memory pool for malloc heap.
+ * NOTE:
+ *   1. the memory pool start address must be 1024 aligned.
+ *   2. It's forbidden to output any message by UART in malloc_init.
+ */
+int malloc_init(void)
 {
 	int i, total_blks;
 
-	/* the memory pool address must be 1024 aligned */
-	BUG_ON(((u32)bld_buf_addr) % 1024);
-
-	malloc_bitmap = (u32 *)bld_buf_addr;
-	malloc_table = (struct malloc_info *)((u32)bld_buf_addr + MALLOC_BLOCK_SIZE);
+	malloc_bitmap = (u32 *)(uintptr_t)bld_buf_addr;
+	malloc_table = (struct malloc_info *)((uintptr_t)bld_buf_addr + MALLOC_BLOCK_SIZE);
 	malloc_table_num = MALLOC_BLOCK_SIZE / sizeof(struct malloc_info);
 
 	total_blks = (bld_buf_end  - bld_buf_addr) / MALLOC_BLOCK_SIZE;
 
-	pr_debug("mem_malloc_init: total blocks = 0x%x\n", total_blks);
-
 	memset(malloc_table ,0 , MALLOC_BLOCK_SIZE);
 
 	/* now clear the bitmap for existed memory, and set the bitmap for
diff --git a/src/bld/lib/random.c b/src/bld/lib/random.c
new file mode 100644
index 0000000..64acc95
--- /dev/null
+++ b/src/bld/lib/random.c
@@ -0,0 +1,64 @@
+
+/**
+ * lib/random.c
+ *
+ * Author: Jorney Tu <qtu@ambarella.com>
+ * History: 2015/11/13 - created
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <bldfunc.h>
+#include <ambhw/timer.h>
+
+static unsigned int grand(unsigned int value)
+{
+	int seed = value;
+	seed ^= (seed << 13);
+	seed ^= (seed >> 17);
+	seed ^= (seed << 5);
+
+	return seed;
+}
+
+int rand(void)
+{
+	static unsigned int virt_timer = 0x5a;
+	static unsigned int tmp = 0;
+#if (RCT_TIMER_INSTANCES >= 1)
+	unsigned int value = readl(RCT_TIMER_REG);
+#else
+	unsigned int value = readl(TIMER2_STATUS_REG);
+#endif
+
+	if (value == 0 || tmp == value){
+		value = virt_timer;
+		virt_timer += 0xbad;
+	}else
+		tmp = value;
+
+
+	return grand(value);
+}
diff --git a/src/bld/lib/thaw_lzo.c b/src/bld/lib/thaw_lzo.c
new file mode 100644
index 0000000..45fb6d8
--- /dev/null
+++ b/src/bld/lib/thaw_lzo.c
@@ -0,0 +1,496 @@
+/**
+ * lib/thaw_lzo.c
+ *
+ *
+ * Copyright (c) 2020 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <ambhw/nand.h>
+#include <fio/ftl_const.h>
+#include <irq.h>
+#include <ambhw/cortex.h>
+#include <ambhw/cache.h>
+
+#define __NEW_UTS_LEN		64
+#define PAGE_SIZE		0x1000
+#define CPU_RESUME_MAIC		0x0badbeef
+#define SWAP_RESERVE_PAGE	1
+#define THAW_MTD_NAME		"swp"
+
+#define LZO_HEADER		sizeof(size_t)
+#define LZO_UNC_PAGES		32
+#define LZO_CMP_PAGES		35
+#define LZO_UNC_SIZE		(LZO_UNC_PAGES * PAGE_SIZE)
+#define LZO_CMP_SIZE		(LZO_CMP_PAGES * PAGE_SIZE)
+
+static int swap_start_blk = 0;
+static int swap_total_blk = 0;
+static int pages_per_4k = 0;
+static int lzo_image_page_offset = 0;
+static int original_image_page_offset = 0;
+static unsigned int cmp_crc = 0, unc_crc = 0;
+static unsigned int nr_cmp_pages = 0, nr_unc_pages = 0;
+
+static void *__lzo_unc_area ;
+static void *__lzo_work_area ;
+static void *__lzo_cmp_area ;
+
+static unsigned long __lzo_reserve_addr;
+
+struct new_utsname {
+	char sysname[__NEW_UTS_LEN + 1];
+	char nodename[__NEW_UTS_LEN + 1];
+	char release[__NEW_UTS_LEN + 1];
+	char version[__NEW_UTS_LEN + 1];
+	char machine[__NEW_UTS_LEN + 1];
+	char domainname[__NEW_UTS_LEN + 1];
+};
+
+struct arch_hibernate_hdr_invariants {
+	char	uts_version[__NEW_UTS_LEN + 1];
+};
+
+static struct arch_hibernate_hdr {
+	struct arch_hibernate_hdr_invariants invariants;
+
+	size_t		ttbr1_el1;
+	void		(*reenter_kernel)(void);
+	size_t		__hyp_stub_vectors;
+	size_t		sleep_cpu_mpidr;
+} *resume_hdr;
+
+struct swsusp_info {
+	struct new_utsname	uts;
+	u32		version_code;
+	size_t		num_physpages;
+	int		cpus;
+	size_t		image_pages;
+	size_t		pages;
+	size_t		size;
+	size_t		magic;
+	size_t		addr;
+	size_t		lzo_enable;
+	size_t		crc32;
+} __attribute__((aligned(PAGE_SIZE)));
+
+
+#if defined(__aarch64__)
+int lzo_compress(const unsigned char *, int, unsigned char *, int *, void *);
+int lzo_uncompress(const unsigned char *, size_t , unsigned char *, size_t *);
+
+#else
+int lzo_compress(const unsigned char *in, int in_len, unsigned char *out,
+		int *out_len, void *work_area)
+{
+	printf("LZO not supported!\n");
+
+	return 0;
+}
+
+int lzo_uncompress(const unsigned char *in, size_t in_len, unsigned char *out,
+		size_t *out_len)
+{
+	printf("LZO not supported!\n");
+
+	return 0;
+}
+#endif
+
+static int block_check_by_page(unsigned int page)
+{
+	unsigned int block = swap_start_blk + page / flnand.pages_per_block;
+
+	while (nand_is_bad_block(block)){
+		printf("page %d or block %d [%d]is a bad block ...\n",
+				page, block, block - swap_start_blk);
+		block++;
+		page += flnand.pages_per_block;
+	}
+
+	return page;
+}
+
+static int mtd_read_linux_page(unsigned int page_offset, void *buf)
+{
+	int ofs, block, ret;
+
+	block = page_offset / flnand.pages_per_block;
+	ofs   = page_offset % flnand.pages_per_block;
+
+	ret = nand_read_pages(swap_start_blk + block, ofs, pages_per_4k,
+			buf, NULL, 0);
+	if (ret < 0) {
+		printf("THAW: nand read %d page failed\n", page_offset);
+		return -1;
+	}
+	return 0;
+}
+
+static int get_swap_info(void)
+{
+	int i;
+	int ret = -1;
+	for (i = 0; i < HAS_IMG_PARTS; i++) {
+		if(strcmp(get_part_str(i), THAW_MTD_NAME))
+			continue;
+
+		swap_start_blk = flnand.sblk[i];
+		swap_total_blk = flnand.nblk[i];
+
+		ret = 0;
+		break;
+	}
+
+	pages_per_4k = PAGE_SIZE / flnand.main_size ;
+
+	BUG_ON(!pages_per_4k);
+
+	return ret;
+}
+
+static int load_snapshot_header(struct swsusp_info *info, int flag)
+{
+	int page_offset;
+	void *buf;
+
+	/* DATA store in NAND is PAGE_SIZE */
+	buf = malloc(PAGE_SIZE);
+	if(buf == NULL){
+		printf("THAW: failed to malloc for swsusp_info!\n");
+		return -1;
+	}
+
+	page_offset = SWAP_RESERVE_PAGE * pages_per_4k;
+
+	if(page_offset != block_check_by_page(page_offset))
+		return -1;
+
+	if(mtd_read_linux_page(page_offset, buf))
+		return -1;
+
+	memcpy(info, buf, sizeof(struct swsusp_info));
+
+	if(info->magic != CPU_RESUME_MAIC) {
+		return -1;
+	}
+
+	resume_hdr = (struct arch_hibernate_hdr *)&info->uts;
+
+	if (flag) {
+
+		printf("sysname :	%s\n", info->uts.sysname);
+		printf("release :	%s\n", info->uts.release);
+		printf("version :	%s\n", info->uts.version);
+		printf("machine :	%s\n", info->uts.machine);
+		printf("image_pages:	%d\n", info->image_pages);
+		printf("nr_meta_pages:	%d\n", info->pages - info->image_pages - 1);
+		printf("info_magic :	%08x\n", info->magic);
+		printf("jump addr :	%08x\n", info->addr);
+		printf("lzo:		%s\n", info->lzo_enable ? "enable" : "disable");
+		printf("crc:		%08x\n", info->crc32);
+
+	} else {
+		/* FIXME: Not checking the CRC when loading snapshot automatically. */
+		info->crc32 = 0;
+	}
+
+	free(buf);
+
+	return 0;
+}
+
+static void jump_to_resume(struct swsusp_info *info)
+{
+	if(info->magic !=  CPU_RESUME_MAIC){
+		printf("Hibernate: Boot Magic error ...\n");
+		return ;
+	}
+
+#if defined(__aarch64__)
+	pr_color(RED, "ARM64: Start to run ... %x\n", info->addr);
+#else
+	pr_color(RED, "ARM: Start to run... %x\n", info->addr);
+#endif
+	jump_to_kernel((void *)(unsigned long)info->addr, 0);
+	__asm__ __volatile__ ("b .");
+}
+
+static int load_image_original_page(size_t addr)
+{
+
+	original_image_page_offset = block_check_by_page(original_image_page_offset);
+
+	BUG_ON(!addr);
+
+	if (mtd_read_linux_page(original_image_page_offset, (unsigned char *)(unsigned long)addr))
+		return -1;
+
+	original_image_page_offset += pages_per_4k;
+
+	return 0;
+}
+
+static void load_image_original(struct swsusp_info *info)
+{
+	int i, j, nr_pages = 0;
+	unsigned int nr_meta_pages, meta_page_offset, crc = 0;
+	void *buf;
+	size_t *phys_addr;
+
+	buf = malloc(PAGE_SIZE);
+	if(buf == NULL){
+		printf("THAW: failed malloc for load image lzo\n");
+		return ;
+	}
+
+	phys_addr = (size_t *)buf;
+
+	nr_meta_pages = info->pages - info->image_pages - 1;
+
+	/* swap partition:
+	 *
+	 * PAGE-0: reserve
+	 * PAGE-1: header
+	 * PAGE-2: meta-0
+	 * PAGE-3: meta-1
+	 *  ...
+	 * PAGE-x: lzo compress image
+	 *
+	 */
+
+	meta_page_offset = (1 + 1) * pages_per_4k;
+	original_image_page_offset = nr_meta_pages * pages_per_4k + meta_page_offset;
+
+	for (i = 0; i < nr_meta_pages; i++){
+		if (mtd_read_linux_page(meta_page_offset, buf)) {
+			free(buf);
+			return ;
+		}
+
+		for (j = 0; j < PAGE_SIZE / sizeof(size_t); j ++) {
+			if ((*(phys_addr + j) & 0xffffffff) == 0xffffffff)
+				break;
+
+			if (load_image_original_page(*(phys_addr + j))) {
+				break;
+			}
+			if (info->crc32)
+				crc = __crc32(crc, (void *)(unsigned long)(*(phys_addr + j)), PAGE_SIZE);
+			nr_pages++;
+		}
+		meta_page_offset += pages_per_4k;
+	}
+
+	printf("LINUX:	%d pages, crc = %08x\n", nr_pages, crc);
+	free(buf);
+
+	if (info->crc32)
+		BUG_ON(crc != info->crc32);
+
+#if defined(CONFIG_PANDORA_RTOS) && defined(AMBOOT_BOOT_DSP)
+	wait_dsp_done();
+#endif
+	jump_to_resume(info);
+
+}
+static int load_image_lzo1x(size_t crc_enable, size_t *target)
+{
+	size_t lzo_size = 0, offset = 0, unc_size = LZO_UNC_SIZE;
+	unsigned char *lzo_cmp_addr = (unsigned char *)__lzo_cmp_area;
+	unsigned char *lzo_target_addr = (unsigned char *)__lzo_unc_area;
+	int i;
+#ifdef LZO_DEBUG
+	static int uncompress_loop = 0;
+#endif
+
+	lzo_image_page_offset = block_check_by_page(lzo_image_page_offset);
+
+#ifdef LZO_DEBUG
+	printf("%d:", lzo_image_page_offset / pages_per_4k);
+#endif
+
+	mtd_read_linux_page(lzo_image_page_offset, lzo_cmp_addr + offset);
+	lzo_size = *(size_t *)(lzo_cmp_addr + offset);
+
+	offset += PAGE_SIZE;
+	lzo_image_page_offset += pages_per_4k;
+	nr_cmp_pages++;
+
+	BUG_ON(lzo_size > LZO_CMP_SIZE);
+
+	/* if compress data size > PAGE_SIZE , read more */
+	if (offset < lzo_size + LZO_HEADER) {
+		for ( ; offset < lzo_size + LZO_HEADER; offset += PAGE_SIZE) {
+
+			lzo_image_page_offset = block_check_by_page(lzo_image_page_offset);
+			mtd_read_linux_page(lzo_image_page_offset, lzo_cmp_addr + offset);
+
+			lzo_image_page_offset += pages_per_4k;
+			nr_cmp_pages++;
+		}
+	}
+
+	if (crc_enable)
+		cmp_crc = __crc32(cmp_crc, lzo_cmp_addr + LZO_HEADER, lzo_size);
+
+	lzo_uncompress(lzo_cmp_addr + LZO_HEADER,
+			(size_t)lzo_size,
+			lzo_target_addr,
+			(size_t *)&unc_size);
+
+	if (crc_enable)
+		unc_crc = __crc32(unc_crc, lzo_target_addr, unc_size);
+
+	nr_unc_pages += unc_size / PAGE_SIZE;
+
+
+#ifdef LZO_DEBUG
+	uncompress_loop ++;
+	printf("%d: %08x[%08x] uncompress %08x[%08x]\n",
+			uncompress_loop, lzo_size, cmp_crc, unc_size, unc_crc);
+#endif
+
+	/* copy to target phys address after uncompress */
+	for (i = 0; i < LZO_UNC_PAGES; i++) {
+		/* end of the snapshot of kernel, return */
+		if ((target[i] & 0xffffffff) == 0xffffffff)
+			return -1;
+
+		BUG_ON(target[i] > DRAM_SIZE || target[i] < 0x200000);
+		memcpy((void *)(unsigned long)target[i], lzo_target_addr + PAGE_SIZE * i, PAGE_SIZE);
+	}
+
+	return 0;
+}
+static int load_image_lzo(struct swsusp_info *info)
+{
+	int i, j;
+	unsigned int nr_meta_pages, meta_page_offset;
+	void *buf;
+	size_t *phys_addr;
+	size_t lzo_phy_addr[LZO_UNC_PAGES];
+
+	buf = malloc(PAGE_SIZE);
+	if(buf == NULL){
+		printf("THAW: failed malloc for load image lzo\n");
+		return -1;
+	}
+
+	phys_addr = (size_t *)buf;
+
+	nr_meta_pages = info->pages - info->image_pages - 1;
+
+	/* swap partition:
+	 *
+	 * PAGE-0: reserve
+	 * PAGE-1: header
+	 * PAGE-2: meta-0
+	 * PAGE-3: meta-1
+	 *  ...
+	 * PAGE-x: lzo compress image
+	 *
+	 */
+
+	meta_page_offset = (1 + 1) * pages_per_4k;
+	lzo_image_page_offset = nr_meta_pages * pages_per_4k + meta_page_offset;
+
+	for (i = 0; i < nr_meta_pages; i++){
+		if (mtd_read_linux_page(meta_page_offset, buf)) {
+			free(buf);
+			return -1;
+		}
+
+		for (j = 0; j < PAGE_SIZE / sizeof(size_t);
+				j += LZO_UNC_PAGES) {
+
+			if (((*(phys_addr + j)) & 0xffffffff) == 0xffffffff)
+				break;
+
+			memcpy(lzo_phy_addr, phys_addr + j, sizeof(lzo_phy_addr));
+
+			if (load_image_lzo1x(info->crc32, lzo_phy_addr))
+				break;
+		}
+		meta_page_offset += pages_per_4k;
+	}
+
+	printf("LINUX:	%d pages, crc = %08x\n", nr_unc_pages, unc_crc);
+	printf("LZO:	%d pages, crc = %08x\n", nr_cmp_pages, cmp_crc);
+
+	free(buf);
+
+	if (info->crc32)
+		BUG_ON(info->crc32 != unc_crc);
+
+#if defined(CONFIG_PANDORA_RTOS) && defined(AMBOOT_BOOT_DSP)
+	wait_dsp_done();
+#endif
+	jump_to_resume(info);
+
+	return 0;
+}
+int thaw_hibernation(int force_disable, int debug)
+{
+	struct swsusp_info info;
+
+	if (force_disable || get_swap_info())
+		return 0;
+
+#if defined(AMBOOT_BOOT_SECONDARY_CORTEX)
+	bld_boot_secondary_cortex();
+#endif
+
+	__lzo_reserve_addr =
+		IDSP_RAM_START - FRAMEBUFFER_SIZE - AMBOOT_LZO_RESERVE_SIZE;
+	__lzo_unc_area = (void *)__lzo_reserve_addr;
+	__lzo_work_area = (void *)(__lzo_reserve_addr + 0x100000);
+	__lzo_cmp_area = (void *)(__lzo_reserve_addr + 0x200000);
+
+	if (load_snapshot_header(&info, debug))
+		return 0;
+
+	if (info.lzo_enable)
+		load_image_lzo(&info);
+	else
+		load_image_original(&info);
+	return 0;
+
+}
+
+int thaw_hibernation_info(void)
+{
+	struct swsusp_info info;
+
+	if (get_swap_info())
+		return 0;
+
+	if (load_snapshot_header(&info, 1))
+		return 0;
+
+	return 0;
+
+}
diff --git a/src/bld/lib/vsprintf.c b/src/bld/lib/vsprintf.c
index 645f0be..130e9af 100644
--- a/src/bld/lib/vsprintf.c
+++ b/src/bld/lib/vsprintf.c
@@ -1,12 +1,41 @@
+/**
+ * lib/vsprintf.c
+ *
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
 #include <bldfunc.h>
-#include <vsprintf.h>
 
-typedef  char* va_list ;
+#define CONFIG_SYS_PBSIZE  0x400
 
-#define _INTSIZEOF(n) ((sizeof(n)+sizeof(int)-1)&~(sizeof(int) - 1))
-#define va_start(ap,v) (ap = (va_list)&v + _INTSIZEOF(v))
-#define va_arg(ap, t) (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))
-#define va_end(ap)  (ap = (va_list)0)
+#define va_list		__builtin_va_list
+#define va_start(v,l)   __builtin_va_start(v,l)
+#define va_end(v)       __builtin_va_end(v)
+#define va_arg(v,l)     __builtin_va_arg(v,l)
 
 # define NUM_TYPE long long
 #define noinline __attribute__((noinline))
@@ -471,7 +500,7 @@ int sprintf(char * buf, const char *fmt, ...)
 
 int printf(const char *fmt, ...)
 {
-	char buf[128];
+	char buf[512];
 	va_list args;
 
 	va_start(args, fmt);
@@ -479,5 +508,6 @@ int printf(const char *fmt, ...)
 	va_end(args);
 
 	serial_puts(buf);
+
 	return 0;
 }
diff --git a/src/bld/libfdt/fdt_ro.c b/src/bld/libfdt/fdt_ro.c
index 935c2a9..da99064 100644
--- a/src/bld/libfdt/fdt_ro.c
+++ b/src/bld/libfdt/fdt_ro.c
@@ -444,7 +444,7 @@ int fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,
 
 int fdt_node_depth(const void *fdt, int nodeoffset)
 {
-	int nodedepth;
+	int nodedepth = 0;
 	int err;
 
 	err = fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, &nodedepth);
@@ -455,7 +455,8 @@ int fdt_node_depth(const void *fdt, int nodeoffset)
 
 int fdt_parent_offset(const void *fdt, int nodeoffset)
 {
-	int nodedepth = fdt_node_depth(fdt, nodeoffset);
+	int nodedepth = 0 ;
+	nodedepth = fdt_node_depth(fdt, nodeoffset);
 
 	if (nodedepth < 0)
 		return nodedepth;
diff --git a/src/bld/loader.c b/src/bld/loader.c
index 14583c7..8139d04 100644
--- a/src/bld/loader.c
+++ b/src/bld/loader.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/03/08 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -73,12 +91,12 @@ void bld_loader_display_ptb_content(const flpart_table_t *ptb)
 /*===========================================================================*/
 #if defined(CONFIG_AMBOOT_ENABLE_NAND)
 static int bld_loader_load_partition_nand(int part_id,
-	u32 mem_addr, u32 img_len, u32 flag)
+	uintptr_t mem_addr, u32 img_len, u32 flag)
 {
 	int ret_val = -1;
 
 	ret_val = nand_read_data((u8 *)mem_addr,
-		(u8 *)(flnand.sblk[part_id] * flnand.block_size), img_len);
+		(u8 *)(uintptr_t)(flnand.sblk[part_id] * flnand.block_size), img_len);
 	if (ret_val == img_len) {
 		ret_val = 0;
 	} else {
@@ -87,11 +105,27 @@ static int bld_loader_load_partition_nand(int part_id,
 
 	return ret_val;
 }
+
+static int bld_loader_load_partition_nand_addr(uintptr_t src_addr,
+	uintptr_t mem_addr,  u32 img_len)
+{
+	int ret_val = -1;
+
+	ret_val = nand_read_data((u8 *)mem_addr, (u8 *)(uintptr_t)(src_addr), img_len);
+	if (ret_val == img_len) {
+		ret_val = 0;
+	} else {
+		ret_val = -1;
+	}
+
+	return ret_val;
+}
+
 #endif
 
 #if defined(CONFIG_AMBOOT_ENABLE_SD)
 static int bld_loader_load_partition_sm(int part_id,
-	u32 mem_addr, u32 img_len, u32 flag)
+	uintptr_t mem_addr, u32 img_len, u32 flag)
 {
 	u32 sectors = (img_len + sdmmc.sector_size - 1) / sdmmc.sector_size;
 
@@ -102,14 +136,31 @@ static int bld_loader_load_partition_sm(int part_id,
 
 #if defined(CONFIG_AMBOOT_ENABLE_SPINOR)
 static int bld_loader_load_partition_spinor(int part_id,
-	u32 mem_addr, u32 img_len, u32 flag)
+	uintptr_t mem_addr, u32 img_len, u32 flag)
 {
 	u32 address;
 	int ret_val;
 
 	address = flspinor.ssec[part_id] * flspinor.sector_size;
 
-	ret_val = spinor_read_data(address, (void *)mem_addr, img_len);
+	ret_val = flspinor.read(address, (void *)mem_addr, img_len);
+	if (ret_val < 0)
+		return ret_val;
+
+	return 0;
+}
+
+#endif
+
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+static int bld_loader_load_partition_spinand(int part_id,
+	uintptr_t mem_addr, u32 img_len, u32 flag)
+{
+	int ret_val;
+
+	ret_val = spinand_read_data((u8 *)mem_addr,
+		(u8 *)(flspinand.sblk[part_id] * flspinand.block_size), img_len);
+
 	if (ret_val < 0)
 		return ret_val;
 
@@ -119,12 +170,12 @@ static int bld_loader_load_partition_spinor(int part_id,
 #endif
 
 int bld_loader_load_partition(int part_id,
-	const flpart_table_t *pptb, int verbose)
+	const flpart_table_t *pptb, u32 size, int verbose)
 {
 	int ret_val = -1;
 	const char *ppart_name;
 	const flpart_t *pptb_part;
-	u32 mem_addr = 0x0;
+	uintptr_t mem_addr = 0x0;
 	u32 img_len = 0x0;
 	u32 boot_from;
 
@@ -166,8 +217,11 @@ int bld_loader_load_partition(int part_id,
 		}
 		goto bld_loader_load_partition_exit;
 	}
-
-	img_len = pptb_part->img_len;
+	if (size > 0) {
+		img_len = size;
+	} else {
+		img_len = pptb_part->img_len;
+	}
 	mem_addr = pptb_part->mem_addr;
 	if (verbose) {
 		putstr("loading ");
@@ -197,6 +251,13 @@ int bld_loader_load_partition(int part_id,
 	}
 #endif
 
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+	if ((ret_val < 0) && (boot_from & PART_DEV_SPINAND)) {
+		ret_val = bld_loader_load_partition_spinand(part_id,
+			mem_addr, img_len, pptb_part->flag);
+	}
+#endif
+
 	if (ret_val < 0) {
 		if (verbose) {
 			putstr(ppart_name);
@@ -211,14 +272,45 @@ bld_loader_load_partition_exit:
 	return ret_val;
 }
 
+int bld_loader_load_partition_partial(int part_id, unsigned int offset, unsigned int size,
+	uintptr_t mem_addr, int verbose)
+{
+	int ret_val = -1;
+	uintptr_t src_addr = 0;
+	unsigned int c_offset = 0;
+
+#if defined(CONFIG_AMBOOT_ENABLE_NAND)
+	/* Normally, load partition totally;
+	 * But in order to speed up the dsp boot time, use load dsp partition paritally.
+	 * Then will encounter bad block issue, use nand_correct_offset() to skip bad block */
+	ret_val = nand_correct_offset(flnand.sblk[part_id], offset, &c_offset);
+
+	src_addr = flnand.sblk[part_id] * flnand.block_size  + c_offset;
+	ret_val = bld_loader_load_partition_nand_addr(src_addr, mem_addr, size);
+#endif
+
+	if (ret_val < 0) {
+		if (verbose) {
+			putstr("[0x");
+			puthex(src_addr);
+			putstr("] - load_partition partial failed!\r\n");
+		}
+	}
+
+	return ret_val;
+
+}
+
 /*===========================================================================*/
-int bld_loader_boot_partition(int verbose, u32 *pjump_addr,
-	u32 *pinitrd2_start, u32 *pinitrd2_size)
+int bld_loader_boot_partition(int verbose, uintptr_t *pjump_addr,
+	uintptr_t *pinitrd2_start, uintptr_t *pinitrd2_size)
 {
 	int ret_val;
 	flpart_table_t ptb;
 	u32 os_start = 0;
+#if defined(SECURE_BOOT)
 	u32 os_len = 0;
+#endif
 	u32 rmd_start = 0;
 	u32 rmd_size = 0;
 
@@ -230,17 +322,21 @@ int bld_loader_boot_partition(int verbose, u32 *pjump_addr,
 		bld_loader_display_ptb_content(&ptb);
 	}
 
-	ret_val = bld_loader_load_partition(PART_PRI, &ptb, verbose);
+	ret_val = bld_loader_load_partition(PART_PRI, &ptb, 0, verbose);
 	if (ret_val < 0) {
-		ret_val = bld_loader_load_partition(PART_SEC, &ptb, verbose);
+		ret_val = bld_loader_load_partition(PART_SEC, &ptb, 0, verbose);
 		if (ret_val < 0)
 			return ret_val;
 
 		os_start = ptb.part[PART_SEC].mem_addr;
+#if defined(SECURE_BOOT)
 		os_len = ptb.part[PART_SEC].img_len;
+#endif
 	} else {
 		os_start = ptb.part[PART_PRI].mem_addr;
+#if defined(SECURE_BOOT)
 		os_len = ptb.part[PART_PRI].img_len;
+#endif
 	}
 
 #if defined(SECURE_BOOT)
@@ -265,7 +361,7 @@ int bld_loader_boot_partition(int verbose, u32 *pjump_addr,
 	}
 #endif
 
-	ret_val = bld_loader_load_partition(PART_RMD, &ptb, verbose);
+	ret_val = bld_loader_load_partition(PART_RMD, &ptb, 0, verbose);
 	if (ret_val == 0x0) {
 		rmd_start = ptb.part[PART_RMD].mem_addr;
 		rmd_size  = ptb.part[PART_RMD].img_len;
@@ -286,8 +382,8 @@ int bld_loader_boot_partition(int verbose, u32 *pjump_addr,
 
 int boot(const char *cmdline, int verbose)
 {
-	u32 jump_addr = 0, rmd_start = 0, rmd_size = 0;
-	u32 cortex_jump, cortex_atag;
+	uintptr_t jump_addr = 0, rmd_start = 0, rmd_size = 0;
+	u32 cortex_jump, dtb_addr;
 	int ret_val;
 
 	ret_val = bld_loader_boot_partition(verbose,
@@ -305,39 +401,29 @@ int boot(const char *cmdline, int verbose)
 	bld_net_down();
 #endif
 
-#if defined(AMBOOT_DEV_BOOT_CORTEX)
-	cortex_jump = ARM11_TO_CORTEX((u32)cortex_processor_start);
-#elif defined(AMBOOT_BOOT_SECONDARY_CORTEX)
-	cortex_jump = (u32)secondary_cortex_jump;
+#if defined(AMBOOT_BOOT_SECONDARY_CORTEX)
+	cortex_jump = (uintptr_t)secondary_cortex_jump;
 #else
 	cortex_jump = 0;
 #endif
-
-#if defined(CONFIG_AMBOOT_BD_FDT_SUPPORT)
-	cortex_atag = fdt_update_tags((void *)jump_addr,
+	dtb_addr = fdt_update_tags((void *)jump_addr,
 		cmdline, cortex_jump, rmd_start, rmd_size, verbose);
-#elif defined(CONFIG_AMBOOT_BD_ATAG_SUPPORT)
-	cortex_atag = setup_tags((void *)jump_addr,
-		cmdline, cortex_jump, rmd_start, rmd_size, verbose);
-#endif
 
 #if defined(AMBOOT_BOOT_SECONDARY_CORTEX)
 	bld_boot_secondary_cortex();
 #endif
 
-#if defined(AMBOOT_DEV_BOOT_CORTEX)
-	*cortex_atag_data = cortex_atag;
-	ret_val = bld_cortex_boot(verbose, jump_addr);
-#else
-	jump_to_kernel((void *)jump_addr, cortex_atag);
+#if defined(CONFIG_PANDORA_RTOS) && defined(AMBOOT_BOOT_DSP)
+	wait_dsp_done();
 #endif
+	jump_to_kernel((void *)jump_addr, dtb_addr);
 
 boot_exit:
 	return ret_val;
 }
 
 /*===========================================================================*/
-static int bld_loader_bios_partition(int verbose, u32 *pjump_addr)
+static int bld_loader_bios_partition(int verbose, uintptr_t *pjump_addr)
 {
 	flpart_table_t ptb;
 	int ret_val;
@@ -350,7 +436,7 @@ static int bld_loader_bios_partition(int verbose, u32 *pjump_addr)
 		bld_loader_display_ptb_content(&ptb);
 	}
 
-	ret_val = bld_loader_load_partition(PART_PBA, &ptb, verbose);
+	ret_val = bld_loader_load_partition(PART_PBA, &ptb, 0, verbose);
 	if (ret_val < 0)
 		return ret_val;
 
@@ -363,9 +449,8 @@ static int bld_loader_bios_partition(int verbose, u32 *pjump_addr)
 
 int bios(const char *cmdline, int verbose)
 {
-	u32 jump_addr = 0;
-	u32 cortex_jump;
-	u32 cortex_atag;
+	uintptr_t jump_addr = 0;
+	u32 cortex_jump, dtb_addr;
 	int ret_val;
 
 	ret_val = bld_loader_bios_partition(verbose, &jump_addr);
@@ -382,28 +467,18 @@ int bios(const char *cmdline, int verbose)
 	bld_net_down();
 #endif
 
-#if defined(AMBOOT_DEV_BOOT_CORTEX)
-	cortex_jump = ARM11_TO_CORTEX((u32)cortex_processor_start);
-#elif defined(AMBOOT_BOOT_SECONDARY_CORTEX)
-	cortex_jump = (u32)secondary_cortex_jump;
+#if defined(AMBOOT_BOOT_SECONDARY_CORTEX)
+	cortex_jump = (uintptr_t)secondary_cortex_jump;
 #else
 	cortex_jump = 0;
 #endif
-
-#if defined(CONFIG_AMBOOT_BD_FDT_SUPPORT)
-	cortex_atag = fdt_update_tags((void *)jump_addr,
-			cmdline, cortex_jump, 0, 0, verbose);
-#elif defined(CONFIG_AMBOOT_BD_ATAG_SUPPORT)
-	cortex_atag = setup_tags((void *)jump_addr,
+	dtb_addr = fdt_update_tags((void *)jump_addr,
 			cmdline, cortex_jump, 0, 0, verbose);
-#endif
 
-#if defined(AMBOOT_DEV_BOOT_CORTEX)
-	*cortex_atag_data = cortex_atag;
-	ret_val = bld_cortex_boot(verbose, jump_addr);
-#else
-	jump_to_kernel((void *)jump_addr, cortex_atag);
+#if defined(CONFIG_PANDORA_RTOS) && defined(AMBOOT_BOOT_DSP)
+	wait_dsp_done();
 #endif
+	jump_to_kernel((void *)jump_addr, dtb_addr);
 
 bios_exit:
 	return ret_val;
diff --git a/src/bld/main.c b/src/bld/main.c
index 16439f6..c08f7f3 100644
--- a/src/bld/main.c
+++ b/src/bld/main.c
@@ -4,33 +4,47 @@
  * History:
  *    2005/01/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
-#include <ambhw/vic.h>
+#include <irq.h>
 #include <ambhw/uart.h>
 #include <ambhw/nand.h>
 #include <ambhw/spinor.h>
 #include <ambhw/usbdc.h>
 #include <ambhw/gpio.h>
 #include <sdmmc.h>
-#include <bapi.h>
 #include <eth/network.h>
 #include <dsp/dsp.h>
+#include <pandora.h>
 
-#if defined(SECURE_BOOT)
-#include "secure/cryptography_if.h"
-#include "secure/secure_boot.h"
-#endif
-
+static u32 main_boot_from;
 /* ==========================================================================*/
-const char *AMBOOT_LOGO =						\
+static const char *AMBOOT_LOGO =						\
 	"\r\n"								\
 	"             ___  ___  _________                _   \r\n"	\
 	"            / _ \\ |  \\/  || ___ \\              | |  \r\n"	\
@@ -39,13 +53,12 @@ const char *AMBOOT_LOGO =						\
 	"           | | | || |  | || |_/ /| (_) || (_) || |_ \r\n"	\
 	"           \\_| |_/\\_|  |_/\\____/  \\___/  \\___/  \\__|\r\n" \
 	"----------------------------------------------------------\r\n" \
-	"Amboot(R) Ambarella(R) Copyright (C) 2004-2014\r\n";
+	"Amboot(R) Ambarella(R) Copyright (C) 2004-2024\r\n";
 
 /* ==========================================================================*/
 int main(void)
 {
 	int ret_val = 0;
-	u32 boot_from;
 	u32 part_dev;
 	int escape = 0;
 #if defined(AMBOOT_DEV_NORMAL_MODE)
@@ -56,41 +69,43 @@ int main(void)
 	int l;
 	char cmd[MAX_CMDLINE_LEN];
 #endif
-#if defined(SECURE_BOOT)
-	int secure_boot_ret = 0;
-	int ask_for_debug = 1;
-	int force_reinitialize_for_debug = 0;
-#endif
 
+	/* Initial boot device */
+	main_boot_from = ambausb_boot_from[0] ? ambausb_boot_from[0] : rct_boot_from();
+	part_dev = set_part_dev(main_boot_from);
+
+#if !defined(CONFIG_PANDORA_RTOS) /* !Pandora */
+	malloc_init();
 	rct_pll_init();
 	enable_fio_dma();
 	rct_reset_fio();
-	fio_exit_random_mode();
 	dma_channel_select();
 
+#if defined(CONFIG_AMBOOT_ENABLE_GPIO)
+	gpio_init();
+#else
+	gpio_mini_init(main_boot_from);
+#endif
+
 	/* Initialize various peripherals used in AMBoot */
 	if (amboot_bsp_early_init != NULL) {
 		amboot_bsp_early_init();
 	}
-	vic_init();
 	uart_init();
 	putstr("\x1b[4l");	/* Set terminal to replacement mode */
 	putstr("\r\n");		/* First, output a blank line to UART */
 
-	mem_malloc_init();
+	irq_init();
+#endif
 
-	/* Initial boot device */
-	boot_from = ambausb_boot_from[0] ? ambausb_boot_from[0] : rct_boot_from();
-	part_dev = set_part_dev(boot_from);
 #if defined(CONFIG_AMBOOT_ENABLE_SD)
 	if (part_dev & PART_DEV_EMMC) {
-		sdmmc_init_mmc(0, SDMMC_MODE_AUTO, -1, 1);
+		sdmmc_init_mmc(0, SDMMC_MODE_AUTO, -1, 1, 1);
 	}
 #endif
 #if defined(CONFIG_AMBOOT_ENABLE_NAND)
 	if (part_dev & PART_DEV_NAND) {
 		nand_init();
-		nand_reset();
 #if defined(CONFIG_NAND_USE_FLASH_BBT)
 		nand_scan_bbt(0);
 #endif
@@ -101,12 +116,17 @@ int main(void)
 		spinor_init();
 	}
 #endif
-#if defined(AMBOOT_DEV_USBDL_MODE)
-	if (usb_check_connected()) {
-		usb_boot(USB_MODE_DEFAULT);
-	} else {
-		usb_disconnect();
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+	if (part_dev & PART_DEV_SPINAND) {
+		spinand_init();
+#if defined(CONFIG_SPINAND_USE_FLASH_BBT)
+		spinand_scan_bbt(0);
+#endif
 	}
+#endif
+#if defined(AMBOOT_DEV_USBDL_MODE)
+	usb_boot(USB_MODE_DEFAULT);
+
 #elif defined(AMBOOT_DEV_NORMAL_MODE)
 	flprog_get_part_table(&ptb);
 	if (ptb.dev.magic != FLPART_MAGIC) {
@@ -118,13 +138,12 @@ int main(void)
 		amboot_bsp_hw_init();
 	}
 
-#if defined(CONFIG_AMBOOT_BAPI_SUPPORT)
-	bld_bapi_init(0);
-#endif
-
 #if defined(AMBOOT_BOOT_DSP)
-	dsp_init();
+	dsp_init_pre(&ptb);
 	audio_init();
+#if defined(CONFIG_PANDORA_RTOS)
+	ret_val = dsp_pandora_init(&ptb);
+#endif
 #endif
 
 	if ((ptb.dev.usbdl_mode == 0) && (amboot_bsp_check_usbmode != NULL)) {
@@ -141,211 +160,76 @@ int main(void)
 #endif
 	}
 
+#if defined(CONFIG_PANDORA_RTOS)
+    if (escape)
+	    dsp_halt();
+#endif
+
 #if defined(CONFIG_AMBOOT_ENABLE_USB)
 	/* If automatic USB download mode is enabled, */
 	/* then enter special USB download mode */
-	if (escape == 0 && ptb.dev.usbdl_mode) {
+	if (escape == 0 && (ptb.dev.usbdl_mode || ambausb_boot_usb[0])) {
 		usb_boot(ptb.dev.usbdl_mode);
 	} else {
 		usb_disconnect();
 	}
 #endif
 
+#if defined(CONFIG_AMBOOT_ENABLE_ETH)
+	/* Try booting from the network */
+	ret_val = bld_net_init(0, &ptb);
+	if ((ret_val == 0) && (escape == 0) && ptb.dev.auto_dl) {
+		putstr("auto-boot from network\r\n");
+		bld_netboot(NULL, 0);
+	}
+#endif
 
 	/* If automatic boot is enabled, attempt to boot from flash */
 	if (escape == 0 && ptb.dev.auto_boot) {
 		/* Call out to BSP supplied entry point (if exists) */
+#if !defined(CONFIG_PANDORA_RTOS)
 		if (amboot_bsp_entry != NULL) {
 			ret_val = amboot_bsp_entry(&ptb);
 		}
-
-#if defined(AMBOOT_THAW_HIBERNATION)
-		thaw_hibernation();
 #endif
 
 #if defined(SECURE_BOOT)
-		secure_boot_ret = secure_boot_init();
-		if (0 > secure_boot_ret) {
-			putstr("[secure boot check fail]: no cryptochip found, exit..\r\n");
-			goto __amboot_console;
-		} else if (1 == secure_boot_ret) {
-			goto __force_reinitialize_secure_boot;
-		} else {
-			if (!ptb.dev.secure_boot_init) {
-				putstr("[secure boot check fail]: cryptochip is initialized, but firmware is not initialized\r\n");
-				if (ask_for_debug) {
-					int c = 0x0;
-					putstr("[debug]: do you want force re-initialize?\r\n");
-					c = uart_get_onechar_blocked();
-					if (('y' == c) || ('Y' == c)) {
-						goto __force_reinitialize_secure_boot;
-					}
-				}
-				putstr("fail 1, exit...\r\n");
-				goto __amboot_console;
-			} else {
-				rsa_context_t rsa_content;
-
-				//putstr("rsakey-n:\r\n");
-				//putstr((const char*) ptb.dev.rsa_key_n);
-				//putstr("\r\nrsakey-e:\r\n");
-				//putstr((const char*) ptb.dev.rsa_key_e);
-				//putstr("\r\n");
-
-				secure_boot_ret = verify_and_fill_pubkey(&ptb.dev, &rsa_content);
-				if (secure_boot_ret) {
-					putstr("[secure boot check fail]: invalid rsa pubkey\r\n");
-					if (ask_for_debug) {
-						int c = 0x0;
-						putstr("[debug]: do you want force re-initialize?\r\n");
-						c = uart_get_onechar_blocked();
-						if (('y' == c) || ('Y' == c)) {
-							goto __force_reinitialize_secure_boot;
-						}
-					}
-					putstr("fail 2, exit...\r\n");
-					goto __amboot_console;
-				} else {
-					putstr("[secure boot check]: key is a valid rsa pubkey\r\n");
-				}
-
-				secure_boot_ret = verify_rsapubkey_hw_signature((unsigned char *) ptb.dev.rsa_key_n, 256 + 4 + 16);
-				if (secure_boot_ret) {
-					putstr("[secure boot check fail]: rsa pubkey is modified?\r\n");
-					if (ask_for_debug) {
-						int c = 0x0;
-						putstr("[debug]: do you want force re-initialize?\r\n");
-						c = uart_get_onechar_blocked();
-						if (('y' == c) || ('Y' == c)) {
-							goto __force_reinitialize_secure_boot;
-						}
-					}
-					putstr("fail 3, exit...\r\n");
-					goto __amboot_console;
-				} else {
-					putstr("[secure boot check]: verify rsa pubkey OK\r\n");
-				}
-
-				secure_boot_ret = verify_sn_signature(ptb.dev.sn_signature, &rsa_content);
-				if (secure_boot_ret) {
-					putstr("[secure boot check fail]: serial number signature check fail, hardware clone?\r\n");
-					if (ask_for_debug) {
-						int c = 0x0;
-						putstr("[debug]: do you want force re-initialize?\r\n");
-						c = uart_get_onechar_blocked();
-						if (('y' == c) || ('Y' == c)) {
-							goto __force_reinitialize_secure_boot;
-						}
-					}
-					putstr("fail 4, exit...\r\n");
-					goto __amboot_console;
-				} else {
-					putstr("[secure boot check]: verify serial number signature OK\r\n");
-				}
-
-			}
-		}
-
-		if (force_reinitialize_for_debug) {
-			rsa_key_t rsa_key;
-
-__force_reinitialize_secure_boot:
-
-			putstr("[secure boot for initialization]: please enter rsa key\r\n");
-			memset(&rsa_key, 0x0, sizeof(rsa_key));
-
-			secure_boot_ret = uart_get_rsakey_1024(&rsa_key);
-			if (secure_boot_ret) {
-				putstr("[secure boot for initialization error]: read rsa key fail...\r\n");
-				uart_print_rsakey_1024(&rsa_key);
-				goto __amboot_console;
-			} else {
-				rsa_context_t rsa_content;
-
-				uart_print_rsakey_1024(&rsa_key);
-
-				secure_boot_ret = verify_and_fill_key(&rsa_key, &rsa_content);
-				if (secure_boot_ret) {
-					putstr("[secure boot for initialization error]: invalid rsa key\r\n");
-					goto __amboot_console;
-				}
-
-				memcpy(ptb.dev.rsa_key_n, rsa_key.n, 256 + 4);
-				memcpy(ptb.dev.rsa_key_e, rsa_key.e, 16);
-
-				secure_boot_ret = generate_rsapubkey_hw_signature((unsigned char *) ptb.dev.rsa_key_n, 256 + 4 + 16);
-				if (0 == secure_boot_ret) {
-					putstr("[secure boot for initialization]: generate rsa public key hw signature done\r\n");
-				} else {
-					putstr("[secure boot for initialization error]: generate rsa public key hw signature fail\r\n");
-					goto __amboot_console;
-				}
-
-				secure_boot_ret = generate_sn_signature(ptb.dev.sn_signature, &rsa_content);
-				if (secure_boot_ret) {
-					putstr("[secure boot for initialization error]: sign serial number fail?\r\n");
-					goto __amboot_console;
-				} else {
-					putstr("[secure boot for initialization]: sign serial number done\r\n");
-				}
-
-				ptb.dev.secure_boot_init = 1;
-				ptb.dev.need_generate_firmware_hw_signature = 1;
-				flprog_set_part_table(&ptb);
-			}
-		}
-
+		secure_boot_main(ret_val, &ptb);
 #endif
 
 		if (ret_val == 1) {
 			bios(NULL, 0);
 		} else if (ret_val == 2) {
 			bios(ptb.dev.cmdline, 0);  /* Auto BIOS */
-		}  else {
+		} else if (ret_val == 3) {
+#if defined(CONFIG_AMBOOT_COMMAND_SUPPORT)
+			flprog_bootcmd_disable(&ptb);
+			boot_command_program(ptb.dev.bootcmd);
+#endif
+		} else {
+#if defined(AMBOOT_THAW_HIBERNATION)
+			thaw_hibernation(!!ret_val, 0);
+#endif
 			ret_val = boot(NULL, 0);  /* Auto boot */
 		}
 
-#if defined(SECURE_BOOT)
-		switch (ret_val) {
-
-			case FLPROG_ERR_FIRM_HW_SIGN_FAIL:
-			case FLPROG_ERR_FIRM_HW_SIGN_VERIFY_FAIL:
-				putstr("[secure boot check fail]: firmware changed?\r\n");
-				if (ask_for_debug) {
-					int c = 0x0;
-					putstr("[debug]: do you want force re-initialize?\r\n");
-					c = uart_get_onechar_blocked();
-					if (('y' == c) || ('Y' == c)) {
-						goto __force_reinitialize_secure_boot;
-					}
-				}
-				putstr("fail 6, exit...\r\n");
-				goto __amboot_console;
-				break;
-
-			default:
-				break;
-		}
-#endif
-
 	}
 
-#if defined(CONFIG_AMBOOT_ENABLE_ETH)
-	/* Try booting from the network */
-	ret_val = bld_net_init(0, &ptb);
-	if ((ret_val == 0) && (escape == 0) && ptb.dev.auto_dl) {
-		putstr("auto-boot from network\r\n");
-		bld_netboot(NULL, 0);
-	}
 #endif
 
+#if defined(CONFIG_PANDORA_RTOS)
+	if (escape == 0) {
+#if defined(AMBOOT_BOOT_DSP)
+		wait_dsp_done();
 #endif
-
-#if defined(SECURE_BOOT)
-__amboot_console:
+		schedule_disable();
+	}
 #endif
-
 	putstr(AMBOOT_LOGO);
+	amboot_show_version();
+#if defined(CONFIG_PANDORA_RTOS)
+	pandora_fingerprint();
+#endif
 	rct_show_boot_from(rct_boot_from());
 	rct_show_pll();
 
diff --git a/src/bld/memcmp.c b/src/bld/memcmp.c
index ca93911..d91a61f 100644
--- a/src/bld/memcmp.c
+++ b/src/bld/memcmp.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/03/06 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -21,7 +39,7 @@ int memcmp(const void *dst, const void *src, unsigned int n)
 
 	while (n--) {
 		if (*_dst != *_src) {
-			return -n;
+			return -1;
 		}
 		_dst++;
 		_src++;
diff --git a/src/bld/memcpy.c b/src/bld/memcpy.c
index d413a94..b0b20d2 100644
--- a/src/bld/memcpy.c
+++ b/src/bld/memcpy.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/01/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -30,7 +48,7 @@ void *memcpy(void* dst, const void* src, unsigned int n)
 {
 	if (n)
 	{
-		switch (((unsigned int)src | (unsigned int)dst | n) & 3)
+		switch (((uintptr_t)src | (uintptr_t)dst | n) & 3)
 		{
 		case 0: {
 			unsigned int *xp = (unsigned int *)src;
diff --git a/src/bld/memfwprog.c b/src/bld/memfwprog.c
index 7d8f3eb..cba4d5d 100644
--- a/src/bld/memfwprog.c
+++ b/src/bld/memfwprog.c
@@ -4,16 +4,35 @@
  * History:
  *    2005/02/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
-#include <ambhw/vic.h>
+#include <irq.h>
+#include <ambhw/gpio.h>
 #include <ambhw/uart.h>
 #include <ambhw/nand.h>
 #include <ambhw/spinor.h>
@@ -33,8 +52,8 @@ extern u32 begin_bst_image;
 extern u32 end_bst_image;
 extern u32 begin_bld_image;
 extern u32 end_bld_image;
-extern u32 begin_splash_image;
-extern u32 end_splash_image;
+extern u32 begin_atf_image;
+extern u32 end_atf_image;
 extern u32 begin_pba_image;
 extern u32 end_pba_image;
 extern u32 begin_kernel_image;
@@ -57,10 +76,8 @@ extern u32 begin_add_image;
 extern u32 end_add_image;
 extern u32 begin_adc_image;
 extern u32 end_adc_image;
-#if defined(CONFIG_AMBOOT_BD_FDT_SUPPORT)
 extern u8 dt_blob_start[];
 extern u8 dt_blob_abs_end[];
-#endif
 
 /* ==========================================================================*/
 extern void hook_pre_memfwprog(fwprog_cmd_t *) __attribute__ ((weak));
@@ -136,37 +153,45 @@ int main(void)
 	flpart_table_t ptb;
 	fwprog_result_t *result = (fwprog_result_t *)&__memfwprog_result;
 
+	malloc_init();
+
 	enable_fio_dma();
 	rct_reset_fio();
-	fio_exit_random_mode();
-
-	/* Initialize the UART */
-	uart_init();
-	putstr("\x1b[4l");
-	putstr("\r\n");
-
-	putstr(MEMFWPROG_LOGO);
 
 #if defined(CONFIG_BOOT_MEDIA_EMMC)
 	boot_from = RCT_BOOT_FROM_EMMC;
 #elif defined(CONFIG_BOOT_MEDIA_SPINOR)
 	boot_from = RCT_BOOT_FROM_SPINOR;
+#elif defined(CONFIG_BOOT_MEDIA_SPINAND)
+	boot_from = RCT_BOOT_FROM_SPINOR;
 #else
 	boot_from = RCT_BOOT_FROM_NAND;
 #endif
+
+#if defined(CONFIG_AMBOOT_ENABLE_GPIO)
+	gpio_init();
+#endif
+
+	/* Initialize the UART */
+	uart_init();
+	putstr("\x1b[4l");
+	putstr("\r\n");
+
+	putstr(MEMFWPROG_LOGO);
+	amboot_show_version();
+
 	rct_show_boot_from(boot_from);
 	rct_show_pll();
 
 	part_dev = set_part_dev(boot_from);
 #if defined(CONFIG_AMBOOT_ENABLE_SD)
 	if (part_dev & PART_DEV_EMMC) {
-		sdmmc_init_mmc(0, SDMMC_MODE_AUTO, -1, 1);
+		sdmmc_init_mmc(0, SDMMC_MODE_AUTO, -1, 1, 1);
 	}
 #endif
 #if defined(CONFIG_AMBOOT_ENABLE_NAND)
 	if (part_dev & PART_DEV_NAND) {
 		nand_init();
-		nand_reset();
 #if defined(CONFIG_NAND_USE_FLASH_BBT)
 		nand_scan_bbt(0);
 #endif
@@ -177,6 +202,14 @@ int main(void)
 		spinor_init();
 	}
 #endif
+#if defined(CONFIG_AMBOOT_ENABLE_SPINAND)
+	if (part_dev & PART_DEV_SPINAND) {
+		spinand_init();
+#if defined(CONFIG_SPINAND_USE_FLASH_BBT)
+		spinand_scan_bbt(0);
+#endif
+	}
+#endif
 	if (hook_pre_memfwprog != 0x0) {
 		fwprog_cmd_t *fwprog_cmd;
 		fwprog_cmd = (fwprog_cmd_t *) &__memfwprog_command;
@@ -192,7 +225,7 @@ int main(void)
 	begin_image[PART_BST] = begin_bst_image;
 	begin_image[PART_PTB] = 0;
 	begin_image[PART_BLD] = begin_bld_image;
-	begin_image[PART_SPL] = begin_splash_image;
+	begin_image[PART_ATF] = begin_atf_image;
 	begin_image[PART_PBA] = begin_pba_image;
 	begin_image[PART_PRI] = begin_kernel_image;
 	begin_image[PART_SEC] = begin_secondary_image;
@@ -208,7 +241,7 @@ int main(void)
 	part_len[PART_BST] = end_bst_image - begin_bst_image;
 	part_len[PART_PTB] = 0;
 	part_len[PART_BLD] = end_bld_image - begin_bld_image;
-	part_len[PART_SPL] = end_splash_image - begin_splash_image;
+	part_len[PART_ATF] = end_atf_image - begin_atf_image;
 	part_len[PART_PBA] = end_pba_image - begin_pba_image;
 	part_len[PART_PRI] = end_kernel_image - begin_kernel_image;
 	part_len[PART_SEC] = end_secondary_image - begin_secondary_image;
@@ -227,7 +260,7 @@ int main(void)
 			putstr(get_part_str(i));
 			putstr(" code found in firmware!\r\n");
 
-			image = (u8 *)(firmware_start + begin_image[i]);
+			image = (u8 *)(uintptr_t)(firmware_start + begin_image[i]);
 
 			if (i == PART_BST) {
 				ret_val = select_bst_fw(image, part_len[i],
@@ -248,7 +281,6 @@ select_bst_err:
 		}
 	}
 
-#if defined(CONFIG_AMBOOT_BD_FDT_SUPPORT)
 	if ((int)(dt_blob_abs_end - dt_blob_start) > 0 && part_len[PART_BLD] > 0) {
 		void *fdt = dt_blob_start;
 
@@ -262,7 +294,6 @@ select_bst_err:
 			putstr("\r\nInvalid DTB!\r\n");
 		}
 	}
-#endif
 
 	putstr("\r\n------ Report ------\r\n");
 	for (i = 0; i < HAS_IMG_PARTS; i++) {
diff --git a/src/bld/memmove.c b/src/bld/memmove.c
index a77d7e1..089bdd5 100644
--- a/src/bld/memmove.c
+++ b/src/bld/memmove.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/01/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
diff --git a/src/bld/memset.c b/src/bld/memset.c
index d5ce762..a8edc5f 100644
--- a/src/bld/memset.c
+++ b/src/bld/memset.c
@@ -4,12 +4,30 @@
  * History:
  *    2008/09/17 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
diff --git a/src/bld/memzero.c b/src/bld/memzero.c
index 4413e0a..4a355a6 100644
--- a/src/bld/memzero.c
+++ b/src/bld/memzero.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/03/09 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -21,7 +39,7 @@ void memzero(void *s, unsigned int n)
 {
 	union {
 		void *vp;
-		unsigned long *ulp;
+		unsigned int *ulp;
 		unsigned char *ucp;
 	} u;
 	int i;
diff --git a/src/bld/nand_bbt.c b/src/bld/nand_bbt.c
index b98bc42..e712f51 100644
--- a/src/bld/nand_bbt.c
+++ b/src/bld/nand_bbt.c
@@ -6,12 +6,30 @@
  * History:
  *    2011/09/21 - [Kerson Chen] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -32,10 +50,11 @@
  * 01b, 10b:	block is marked bad due to wear
  */
 
-#define MAIN_SPARE_SIZE		(2048 + 128)
-#define NAND_BBT_SIZE		(4096 >> 2)
+#define MAIN_SPARE_SIZE		((2048 + 128) << 1 )
+#define NAND_BBT_SIZE		(8192 >> 2)
 
 static int bbt_is_created = 0;
+static u32 bbt_pages = 1;
 
 static u8 bbt[NAND_BBT_SIZE]
 __attribute__ ((aligned(32), section(".bss.noinit")));
@@ -89,7 +108,7 @@ static int read_bbt(nand_bbt_descr_t *td)
 	int rval, i;
 	u32 offs;
 
-	rval = nand_read_pages(td->block, 0, 1, page_data, NULL, 1);
+	rval = nand_read_pages(td->block, 0, bbt_pages, page_data, NULL, 1);
 	if (rval < 0) {
 		nand_mark_bad_block(td->block);
 		putstr("read failed. <block ");
@@ -100,7 +119,7 @@ static int read_bbt(nand_bbt_descr_t *td)
 	}
 
 	offs = add_marker_len(td);
-	for (i = 0; i < (flnand.blocks_per_bank >> 2); i++)
+	for (i = 0; i < ((flnand.blocks_per_bank) >> 2); i++)
 		bbt[i] &= page_data[offs + i];
 
 	return 0;
@@ -153,7 +172,7 @@ static int search_bbt(nand_bbt_descr_t *td, int verbose)
 		}
 
 		/* Read first page */
-		rval = nand_read_pages(actblock, 0, 1, page_data, NULL, 1);
+		rval = nand_read_pages(actblock, 0, bbt_pages, page_data, NULL, 1);
 		if (rval < 0) {
 			nand_mark_bad_block(actblock);
 			putstr("read failed. <block ");
@@ -199,9 +218,8 @@ static int search_bbt(nand_bbt_descr_t *td, int verbose)
 static int write_bbt(nand_bbt_descr_t *td, nand_bbt_descr_t *md, int verbose)
 {
 	int i, rval;
-	int numblocks, startblock, bbt_block;
+	int startblock, bbt_block;
 
-	numblocks = flnand.blocks_per_bank;
 	/* There was already a version of the table, reuse the page
 	 * This applies for absolute placement too, as we have the
 	 * page nr. in td->pages.
@@ -230,7 +248,7 @@ static int write_bbt(nand_bbt_descr_t *td, nand_bbt_descr_t *md, int verbose)
 
 write:
 	/* Preset the buffer with 0xff */
-	memset(page_data, 0xff, flnand.main_size + flnand.spare_size);
+	memset(page_data, 0xff, (flnand.main_size + flnand.spare_size ) * bbt_pages);
 
 	/* bbt pattern */
 	memcpy(&page_data[td->offs], td->pattern, td->len);
@@ -251,9 +269,9 @@ write:
 
 	/* dual spare mode use ecc bit >1 case */
 	if (flnand.ecc_bits > 1)
-		rval = nand_prog_pages(bbt_block, 0, 1, page_data, page_data + flnand.main_size);
+		rval = nand_prog_pages(bbt_block, 0, bbt_pages, page_data, page_data + flnand.main_size * bbt_pages);
 	else
-		rval = nand_prog_pages(bbt_block, 0, 1, page_data, NULL);
+		rval = nand_prog_pages(bbt_block, 0, bbt_pages, page_data, NULL);
 	if (rval < 0) {
 		putstr("program failed. <block ");
 		putdec(bbt_block);
@@ -264,9 +282,9 @@ write:
 
 	/* Read it back for verification */
 	if (flnand.ecc_bits > 1)
-		rval = nand_read_pages(bbt_block, 0, 1, check_buf, check_buf + flnand.main_size, 1);
+		rval = nand_read_pages(bbt_block, 0, bbt_pages, check_buf, check_buf + flnand.main_size * bbt_pages, 1);
 	else
-		rval = nand_read_pages(bbt_block, 0, 1, check_buf, NULL, 1);
+		rval = nand_read_pages(bbt_block, 0, bbt_pages, check_buf, NULL, 1);
 	if (rval < 0) {
 		putstr("read failed. <block ");
 		putdec(bbt_block);
@@ -315,7 +333,7 @@ static int create_bbt(int verbose)
 	if (verbose)
 		putstr("Scanning device for bad blocks\r\n");
 
-	if (flnand.blocks_per_bank > (NAND_BBT_SIZE << 2)) {
+	if ((flnand.blocks_per_bank) > (NAND_BBT_SIZE << 2)) {
 		putstr("bbt size is too small (");
 		putdec(flnand.blocks_per_bank);
 		putstr("/");
@@ -324,7 +342,7 @@ static int create_bbt(int verbose)
 		return -1;
 	}
 
-	for (block = 0; block < flnand.blocks_per_bank; block++) {
+	for (block = 0; block < (flnand.blocks_per_bank); block++) {
 		ret = nand_is_bad_block(block);
 		if (ret) {
 			if (verbose) {
@@ -451,6 +469,7 @@ writecheck:
 int nand_scan_bbt(int verbose)
 {
 	int rval = 0;
+	u32 total_len = 0;
 	nand_bbt_descr_t *td;
 	nand_bbt_descr_t *md;
 
@@ -461,6 +480,8 @@ int nand_scan_bbt(int verbose)
 	if (bbt_is_created)
 		return 0;
 
+	total_len = ((flnand.blocks_per_bank ) >> 2) + add_marker_len(td);
+	bbt_pages = (total_len + flnand.main_size - 1 ) / flnand.main_size;
 	/* Preset bbt contents with 0xff */
 	memset(&bbt, 0xff, NAND_BBT_SIZE);
 
@@ -606,7 +627,7 @@ int nand_show_bbt()
 {
 	int i, rval = 0;
 
-	for (i = 0; i < flnand.blocks_per_bank; i++) {
+	for (i = 0; i < (flnand.blocks_per_bank); i++) {
 		rval = nand_isbad_bbt(i);
 		if (rval < 0)
 			return -1;
diff --git a/src/bld/nand_combo.c b/src/bld/nand_combo.c
new file mode 100644
index 0000000..4a2ba29
--- /dev/null
+++ b/src/bld/nand_combo.c
@@ -0,0 +1,907 @@
+/**
+ * bld/nand.c
+ *
+ * Flash controller functions with NAND chips.
+ *
+ * History:
+ *    2017/05/12 - [Cao Rongrong] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <ambhw/nand.h>
+#include <ambhw/cache.h>
+#include <fio/ftl_const.h>
+#include <flash/nanddb.h>
+
+#define NAND_SUPPORT_WP			1
+
+/* ==========================================================================*/
+#define NAND_CMD_MASK			0xf
+#define NAND_CMD_NOP			0x0
+#define NAND_CMD_RESET			0x2
+#define NAND_CMD_READID			0xa
+#define NAND_CMD_READSTATUS		0xc
+#define NAND_CMD_READ			0xe
+#define NAND_CMD_PROGRAM		0xf
+
+#define NAND_CMD_TIMEOUT		1000
+/* ==========================================================================*/
+/* For NO-ECC USAGE */
+#define NAND_DSM_JP_DEFAULT		0xB6
+/* ==========================================================================*/
+extern flnand_t flnand;
+
+#define MAX_SCRATCH_BUFFER_SIZE		8192
+static u8 scratch_buffer[MAX_SCRATCH_BUFFER_SIZE] __attribute__ ((aligned(32)));
+static u8 page_buffer[4096] __attribute__ ((aligned(32)));
+
+static u32 fdma_dsm_ctrl;
+static u32 fdma_dsm_no_ecc_ctrl = 0;
+/* ==========================================================================*/
+
+static void nand_wait_cmd_done(u32 cmd)
+{
+	u32 rval;
+
+	writel(FIO_RAW_INT_STATUS_REG, 0xff);
+
+	if ((cmd & NAND_CMD_MASK) != NAND_CMD_NOP)
+		writel(NAND_CMD_REG, cmd);
+
+	rct_timer2_reset_count();
+
+	while(1) {
+		rval = readl(FIO_RAW_INT_STATUS_REG);
+
+		if (rval & (FIO_INT_ECC_RPT_UNCORR |
+				FIO_INT_ECC_RPT_THRESH |
+				FIO_INT_OPERATION_DONE))
+			break;
+
+		if (rct_timer2_get_count() >= NAND_CMD_TIMEOUT) {
+			printf("nand cmd timeout: %d\n", cmd);
+			while(1);
+		}
+	}
+
+	writel(FIO_RAW_INT_STATUS_REG, rval);
+}
+
+static void nand_enable_wp()
+{
+#if (NAND_SUPPORT_WP == 1)
+	setbitsl(NAND_CTRL_REG, NAND_CTRL_WP);
+#endif
+}
+
+static void nand_disable_wp()
+{
+#if (NAND_SUPPORT_WP == 1)
+	clrbitsl(NAND_CTRL_REG, NAND_CTRL_WP);
+#endif
+}
+
+static void nand_init_hw(void)
+{
+	u32 poc = rct_get_nand_poc();
+
+	ASSERT(!(poc & RCT_BOOT_NAND_ECC_BCH_EN), "Please enable BCH in POC!\n\r");
+
+	/* Reset FIO FIFO, and Exit random read mode */
+	setbitsl(FIO_CTRL_REG, FIO_CTRL_RANDOM_READ);
+	rct_timer2_dly_ms(1); /* delay is must have */
+	clrbitsl(FIO_CTRL_REG, FIO_CTRL_RANDOM_READ);
+
+	if (poc & RCT_BOOT_NAND_ECC_SPARE_2X) {
+		fdma_dsm_ctrl = FDMA_DSM_MAIN_JP_SIZE_512B | FDMA_DSM_SPARE_JP_SIZE_32B;
+		setbitsl(NAND_EXT_CTRL_REG, NAND_EXT_CTRL_SPARE_2X);
+	}
+	else {
+		fdma_dsm_ctrl = FDMA_DSM_MAIN_JP_SIZE_512B | FDMA_DSM_SPARE_JP_SIZE_16B;
+		clrbitsl(NAND_EXT_CTRL_REG, NAND_EXT_CTRL_SPARE_2X);
+	}
+
+	writel(FDMA_DSM_CTRL_REG, fdma_dsm_ctrl);
+	setbitsl(FIO_CTRL_REG, FIO_CTRL_RDERR_STOP | FIO_CTRL_SKIP_BLANK_ECC);
+
+	if (poc & RCT_BOOT_NAND_PAGE_SIZE)
+		clrbitsl(NAND_EXT_CTRL_REG, NAND_EXT_CTRL_4K_PAGE);
+	else
+		setbitsl(NAND_EXT_CTRL_REG, NAND_EXT_CTRL_4K_PAGE);
+
+	/* disable and clear all of NAND Interrupt status */
+	writel(FIO_INT_ENABLE_REG, 0x00);
+	writel(FIO_RAW_INT_STATUS_REG, 0xff);
+
+	flnand.ecc_bits = (poc & RCT_BOOT_NAND_ECC_SPARE_2X) ? 8 : 6;
+}
+
+/**
+ * Check for bad block.
+ */
+int nand_is_bad_block(u32 block)
+{
+	int ret_val = -1, i;
+	u8 sbuf[1024], *sbuf_ptr;
+	u8 bi;
+
+	/* make sure 32 bytes aligned */
+	sbuf_ptr = (u8 *)(((uintptr_t)sbuf + 31) & (~31));
+
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+	if(nand_has_bbt())
+		return nand_isbad_bbt(block);
+#endif
+	ret_val = nand_read_spare(block, 0, BAD_BLOCK_PAGES, sbuf_ptr);
+	if (ret_val < 0) {
+		putstr("check bad block failed >> "
+				"read spare data error.\r\n");
+		/* Treat as factory bad block */
+		return NAND_INITIAL_BAD_BLOCK;
+	}
+
+	for (i = 0; i < INIT_BAD_BLOCK_PAGES; i++) {
+		bi = *(sbuf_ptr + i * flnand.spare_size);
+		if (bi != 0xff)
+			break;
+	}
+
+
+	/* Good block */
+	if (i == INIT_BAD_BLOCK_PAGES)
+		return NAND_GOOD_BLOCK;
+
+	for (i = INIT_BAD_BLOCK_PAGES; i < BAD_BLOCK_PAGES; i++) {
+		bi = *(sbuf_ptr + i * flnand.spare_size);
+		if (bi != 0xff)
+			break;
+	}
+
+	if (i < BAD_BLOCK_PAGES) {
+		/* Late developed bad blocks. */
+		return NAND_LATE_DEVEL_BAD_BLOCK;
+	} else {
+		/* Initial invalid blocks. */
+		return NAND_INITIAL_BAD_BLOCK;
+	}
+}
+
+int nand_correct_offset(u32 start_blk, u32 offset, u32 *c_offset)
+{
+	int i = 0;
+	u32 bad_blk = 0, valid_blk = 0;
+	u32 blk_size = flnand.block_size;
+	u32 offset_blk = ROUND_DOWN(offset, blk_size)/blk_size;
+
+	for (i = 0, valid_blk = 0; valid_blk < offset_blk; i++) {
+		if (nand_is_bad_block(start_blk + i) == NAND_GOOD_BLOCK) {
+			valid_blk++;
+		} else {
+			bad_blk++;
+		}
+	}
+	if (c_offset) {
+		*c_offset = (bad_blk * blk_size) + offset;
+	}
+
+	return 0;
+}
+
+void nand_output_bad_block(u32 block, int bb_type)
+{
+	if (bb_type & NAND_INITIAL_BAD_BLOCK) {
+		putstr("initial bad block. <block ");
+	} else if (bb_type & NAND_LATE_DEVEL_BAD_BLOCK) {
+		putstr("late developed bad block. <block ");
+	} else {
+		putstr("other bad block. <block ");
+	}
+	putdec(block);
+	putstr(">\r\n");
+	putstr("Try next block...\r\n");
+}
+
+/**
+ * Mark a bad block.
+ */
+int nand_mark_bad_block(u32 block)
+{
+	int ret_val = -1, i;
+	u8 sbuf[1024], *sbuf_ptr;
+	u8 bi;
+
+	/* make sure 32 bytes aligned */
+	sbuf_ptr = (u8 *)(((uintptr_t)sbuf + 31) & (~31));
+
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+	nand_update_bbt(block, 0);
+#endif
+
+	for (i = AMB_BB_START_PAGE; i < BAD_BLOCK_PAGES; i++) {
+		memset(sbuf_ptr, 0xff, flnand.spare_size);
+		*sbuf_ptr = AMB_BAD_BLOCK_MARKER;
+
+		ret_val = nand_prog_spare(block, i, 1, sbuf_ptr);
+		if (ret_val < 0) {
+			putstr("mark bad block failed >> "
+				"write spare data error.\r\n");
+			return ret_val;
+		}
+
+		ret_val = nand_read_spare(block, i, 1, sbuf_ptr);
+		if (ret_val < 0) {
+			putstr("mark bad block failed >> "
+				"read spare data error.\r\n");
+			return ret_val;
+		}
+
+		bi = *sbuf_ptr;
+
+		if (bi == 0xff) {
+			putstr("mark bad block failed >> "
+				"verify failed at block ");
+			putdec(block);
+			putstr("\r\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * Initialize NAND parameters.
+ */
+int nand_init(void)
+{
+	flnand_t *fn = &flnand;
+	nand_db_t *nand_db;
+	int sblk, nblk, part_size[HAS_IMG_PARTS];
+	u32 i, id, id5, match = 0;
+
+	nand_init_hw();
+
+	/* Force ReadID with 4-cycles */
+	setbitsl(NAND_CTRL_REG, NAND_CTRL_I4);
+
+	/* Reset chip */
+	nand_wait_cmd_done(NAND_CMD_RESET);
+
+	/* Read ID with maximun 5 times if id is 0. */
+	for (i = 0; i < 5; i++) {
+		nand_wait_cmd_done(NAND_CMD_READID);
+		id = readl(NAND_ID_REG);
+		if (id)
+			break;
+	}
+
+	ASSERT(id == 0, "NAND chip absence?\n");
+
+	/* Read ID5 with maximun 5 times if id is 0. */
+	clrbitsl(NAND_CTRL_REG, NAND_CTRL_I4);	/* Disable NAND_CTR_I4 */
+	setbitsl(NAND_EXT_CTRL_REG, NAND_EXT_CTRL_I5);
+	for (i = 0; i < 5; i++) {
+		nand_wait_cmd_done(NAND_CMD_READID);
+		id5 = readl(NAND_EXT_ID_REG) & 0xff;
+		if (id5)
+			break;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ns_nand_ids); i++) {
+		ASSERT((id == ns_nand_ids[i].nand_id && id5 == ns_nand_ids[i].id5),
+				"Unsupport NAND flash\r\n");
+	}
+
+	/* Search the NAND-DB for an exact match */
+	for (nand_db = __nanddb_start; nand_db < __nanddb_end; nand_db++) {
+		if ((nand_db->id == id && nand_db->id5 == id5) ||
+			(id == 0x01F1801D && nand_db->id == id)) {
+			match = 1;
+			break;
+		}
+	}
+
+	ASSERT(!match, "Non-matched NAND: 0x%x, 0x%x\n", id, id5);
+
+	fn->nandtiming0 = nand_db->timing0;
+	fn->nandtiming1 = nand_db->timing1;
+	fn->nandtiming2 = nand_db->timing2;
+	fn->nandtiming3 = nand_db->timing3;
+	fn->nandtiming4 = nand_db->timing4;
+	fn->nandtiming5 = nand_db->timing5;
+	fn->nandtiming6 = nand_db->timing6;
+
+	/* Setup flash timing register */
+	writel(NAND_TIMING0_REG, FLASH_TIMING_MIN(nand_db->timing0, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing0, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing0, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing0, 0));
+
+	writel(NAND_TIMING1_REG, FLASH_TIMING_MIN(nand_db->timing1, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing1, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing1, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing1, 0));
+
+	writel(NAND_TIMING2_REG, FLASH_TIMING_MIN(nand_db->timing2, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing2, 16)	|
+			 FLASH_TIMING_MAX(nand_db->timing2, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing2, 0));
+
+	writel(NAND_TIMING3_REG, FLASH_TIMING_MIN(nand_db->timing3, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing3, 16)	|
+			 FLASH_TIMING_MAX(nand_db->timing3, 8)	|
+			 FLASH_TIMING_MAX(nand_db->timing3, 0));
+
+	writel(NAND_TIMING4_REG, FLASH_TIMING_MIN(nand_db->timing4, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing4, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing4, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing4, 0));
+
+	writel(NAND_TIMING5_REG, FLASH_TIMING_MIN(nand_db->timing5, 16)	|
+			 FLASH_TIMING_MAX(nand_db->timing5, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing5, 0));
+
+	writel(NAND_TIMING6_REG, FLASH_TIMING_MIN(nand_db->timing6, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing6, 8)	|
+			 FLASH_TIMING_MAX(nand_db->timing6, 0));
+
+	fn->main_size = nand_db->main_size;
+	fn->spare_size = nand_db->spare_size;
+	fn->blocks_per_bank = nand_db->blocks_per_bank;
+	fn->pages_per_block = nand_db->pages_per_block;
+	fn->block_size = nand_db->main_size * nand_db->pages_per_block;
+
+	switch (fn->block_size * fn->blocks_per_bank) {
+	case 8 * 1024 * 1024:
+		fn->control = NAND_CTRL_SIZE_64M;
+		break;
+	case 16 * 1024 * 1024:
+		fn->control = NAND_CTRL_SIZE_128M;
+		break;
+	case 32 * 1024 * 1024:
+		fn->control = NAND_CTRL_SIZE_256M;
+		break;
+	case 64 * 1024 * 1024:
+		fn->control = NAND_CTRL_SIZE_512M;
+		break;
+	case 128 * 1024 * 1024:
+		fn->control = NAND_CTRL_SIZE_1G;
+		break;
+	case 256 * 1024 * 1024:
+		fn->control = NAND_CTRL_SIZE_2G;
+		break;
+	case 512 * 1024 * 1024:
+		fn->control = NAND_CTRL_SIZE_4G;
+		break;
+	case 1024 * 1024 * 1024:
+		fn->control = NAND_CTRL_SIZE_8G;
+		break;
+	default:
+		ASSERT(1, "Unexpected NAND flash chipsize\r\n");
+		break;
+	}
+
+	if (fn->blocks_per_bank * fn->pages_per_block > 65536)
+		fn->control |= NAND_CTRL_P3;
+
+	get_part_size(part_size);
+
+	sblk = nblk = 0;
+	for (i = 0; i < HAS_IMG_PARTS; i++) {
+		if ((get_part_dev(i) & PART_DEV_NAND) != PART_DEV_NAND) {
+			continue;
+		}
+
+		sblk += nblk;
+		nblk = part_size[i] / fn->block_size;
+		if ((part_size[i] % fn->block_size) != 0x0)
+			nblk++;
+		fn->sblk[i] = (nblk == 0) ? 0 : sblk;
+		fn->nblk[i] = nblk;
+	}
+	for (; i < PART_MAX; i++) {
+		fn->sblk[i] = 0;
+		fn->nblk[i] = 0;
+	}
+
+	nblk = (fn->blocks_per_bank > sblk) ? (fn->blocks_per_bank - sblk) : 0;
+	fn->sblk[PART_RAW] = (nblk == 0) ? 0 : sblk; /* Raw part has BBT, take care!*/
+	fn->nblk[PART_RAW] = nblk;
+	ASSERT(fn->sblk[PART_RAW] < 2, "No Space for BBT!\r\n");
+
+	fdma_dsm_no_ecc_ctrl = NAND_DSM_JP_DEFAULT;
+	fdma_dsm_no_ecc_ctrl += (((fn->main_size >> 12 ) << 4) | (fn->spare_size >> 7));
+	return 0;
+}
+
+/**
+ * Read multiple pages from NAND flash with ecc check.
+ */
+int nand_read_pages(u32 block, u32 page, u32 pages,
+		u8 *main_buf, u8 *spare_buf, u32 enable_ecc)
+{
+	u32 mlen, slen, status, addr;
+	u64 addr64;
+
+	/* check parameters */
+	if ((page + pages) > flnand.pages_per_block || (!main_buf && !spare_buf)) {
+		putstr("ERR: parameter error in nand_read_pages()");
+		return -1;
+	}
+
+	mlen = pages * flnand.main_size;
+	BUG_ON(!main_buf && mlen > MAX_SCRATCH_BUFFER_SIZE);
+	main_buf = main_buf ? : scratch_buffer;
+	clean_flush_d_cache((void *)main_buf, mlen);
+
+	slen = pages * flnand.spare_size;
+	BUG_ON(!spare_buf && slen > MAX_SCRATCH_BUFFER_SIZE);
+	spare_buf = spare_buf ? : scratch_buffer;
+	clean_flush_d_cache(spare_buf, slen);
+
+	/* clear all of NAND Interrupt status */
+	writel(FIO_RAW_INT_STATUS_REG, 0xff);
+
+	/* Setup Flash IO Control Register */
+	if (enable_ecc && main_buf) {
+		setbitsl(FIO_CTRL_REG, FIO_CTRL_ECC_BCH_ENABLE);
+		writel(FDMA_DSM_CTRL_REG, fdma_dsm_ctrl);
+	} else {
+		clrbitsl(FIO_CTRL_REG, FIO_CTRL_ECC_BCH_ENABLE);
+		writel(FDMA_DSM_CTRL_REG, fdma_dsm_no_ecc_ctrl);
+	}
+
+	/* Setup FDMA engine transfer */
+	writel(FDMA_MN_MEM_ADDR_REG, (uintptr_t)main_buf);
+	writel(FDMA_SP_MEM_ADDR_REG, (uintptr_t)spare_buf);
+	writel(FDMA_MN_CTRL_REG, FDMA_CTRL_ENABLE | FDMA_CTRL_WRITE_MEM |
+				 FDMA_CTRL_BLK_SIZE_512B | (mlen + slen));
+
+	/* Write start address for memory target to */
+	addr64 = (u64)(block * flnand.pages_per_block + page) * flnand.main_size;
+
+	addr = (addr64 >> 32) << 28;
+	writel(NAND_CTRL_REG, addr | flnand.control);
+
+	addr = addr64 & 0xffffffff;
+	nand_wait_cmd_done(addr | NAND_CMD_READ);
+
+	status = readl(FDMA_MN_STATUS_REG);
+	if (status & (FDMA_STATUS_DMA_BUS_ERR | FDMA_STATUS_DMA_ADDR_ERR))
+		return -1;
+
+	if (enable_ecc && main_buf) {
+		status = readl(FIO_ECC_RPT_STATUS_REG);
+		if (status & FIO_ECC_RPT_CORR_FAIL) {
+			printf("BCH real corrected failed (0x%x)!\n", status);
+			return -1;
+		}
+	}
+
+	_clean_flush_d_cache();
+
+	return 0;
+}
+
+static int nand_read(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	u32 first_blk_pages, blocks, last_blk_pages, bad_blks = 0;
+	int rval = 0;
+
+	first_blk_pages = flnand.pages_per_block - page;
+	if (pages > first_blk_pages) {
+		pages -= first_blk_pages;
+		blocks = pages / flnand.pages_per_block;
+		last_blk_pages = pages % flnand.pages_per_block;
+	} else {
+		first_blk_pages = pages;
+		blocks = 0;
+		last_blk_pages = 0;
+	}
+
+	if (first_blk_pages) {
+		while (nand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = nand_read_pages(block, page, first_blk_pages, buf, NULL, 1);
+		if (rval < 0)
+			return -1;
+		block++;
+		buf += first_blk_pages * flnand.main_size;
+	}
+
+	while (blocks > 0) {
+		while (nand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = nand_read_pages(block, 0, flnand.pages_per_block, buf, NULL, 1);
+		if (rval < 0)
+			return -1;
+		block++;
+		blocks--;
+		buf += flnand.block_size;
+	}
+
+	if (last_blk_pages) {
+		while (nand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = nand_read_pages(block, 0, last_blk_pages, buf, NULL, 1);
+		if (rval < 0)
+			return -1;
+	}
+
+	return bad_blks;
+}
+
+static void nand_get_offset_addr(u32 *block, u32 *page, u32 pages, u32 bad_blks)
+{
+	u32 blocks;
+
+	blocks = pages / flnand.pages_per_block;
+	pages  = pages % flnand.pages_per_block;
+
+	*block =  *block + blocks;
+	*page += pages;
+
+	if (*page >= flnand.pages_per_block) {
+		*page -= flnand.pages_per_block;
+		*block += 1;
+	}
+
+	*block += bad_blks;
+}
+
+/**
+ * Read data from NAND flash to memory.
+ * dst - address in dram.
+ * src - address in nand device.
+ * len - length to be read from nand.
+ * return - length of read data.
+ */
+int nand_read_data(u8 *dst, u8 *src, int len)
+{
+	u32 block, page, pages, pos;
+	u32 first_ppage_size, last_ppage_size;
+	uintptr_t val, rval = -1;
+
+	/* translate address to block, page, address */
+	val = (uintptr_t)src;
+	block = val / flnand.block_size;
+	val  -= block * flnand.block_size;
+	page  = val / flnand.main_size;
+	pos   = val % flnand.main_size;
+	pages = len / flnand.main_size;
+
+	if (pos == 0)
+		first_ppage_size = 0;
+	else
+		first_ppage_size = flnand.main_size - pos;
+
+	if (len >= first_ppage_size) {
+		pages = (len - first_ppage_size) / flnand.main_size;
+
+		last_ppage_size = (len - first_ppage_size) % flnand.main_size;
+	} else {
+		first_ppage_size = len;
+		pages = 0;
+		last_ppage_size = 0;
+	}
+
+	if (len != (first_ppage_size + pages * flnand.main_size + last_ppage_size))
+		return -1;
+
+	len = 0;
+
+	if (first_ppage_size) {
+		rval = nand_read(block, page, 1, page_buffer);
+		if (rval < 0)
+			return len;
+
+		memcpy(dst, page_buffer + pos, first_ppage_size);
+		dst += first_ppage_size;
+		len += first_ppage_size;
+		nand_get_offset_addr(&block, &page, 1, rval);
+	}
+
+	if (pages > 0) {
+		rval = nand_read(block, page, pages, dst);
+		if (rval < 0)
+			return len;
+
+		dst += pages * flnand.main_size;
+		len += pages * flnand.main_size;
+		nand_get_offset_addr(&block, &page, pages, rval);
+	}
+
+	if (last_ppage_size > 0) {
+		rval = nand_read(block, page, 1, page_buffer);
+		if (rval < 0)
+			return len;
+
+		memcpy(dst, page_buffer, last_ppage_size);
+		len += last_ppage_size;
+	}
+
+	return len;
+}
+
+/**
+ * Program a page to NAND flash.
+ */
+int nand_prog_pages(u32 block, u32 page, u32 pages, u8 *main_buf, u8 *spare_buf)
+{
+	u32 mlen, slen, status, addr;
+	u64 addr64;
+
+	/* check parameters */
+	if ((page + pages) > flnand.pages_per_block || !main_buf) {
+		putstr("ERR: parameter error in nand_read_pages()");
+		return -1;
+	}
+
+	mlen = pages * flnand.main_size;
+	clean_d_cache((void *)main_buf, mlen);
+
+	slen = pages * flnand.spare_size;
+	if (spare_buf == NULL) {
+		spare_buf = scratch_buffer;
+		memset(spare_buf, 0xff, slen);
+	}
+	clean_d_cache(spare_buf, slen);
+
+	nand_disable_wp();
+
+	/* enable BCH */
+	writel(FDMA_DSM_CTRL_REG, fdma_dsm_ctrl);
+	setbitsl(FIO_CTRL_REG, FIO_CTRL_ECC_BCH_ENABLE);
+
+	/* clear all of NAND Interrupt status */
+	writel(FIO_RAW_INT_STATUS_REG, 0xff);
+
+	/* Setup FDMA engine transfer */
+	writel(FDMA_MN_MEM_ADDR_REG, (uintptr_t)main_buf);
+	writel(FDMA_SP_MEM_ADDR_REG, (uintptr_t)spare_buf);
+	writel(FDMA_MN_CTRL_REG, FDMA_CTRL_ENABLE | FDMA_CTRL_READ_MEM |
+				 FDMA_CTRL_BLK_SIZE_512B | (mlen + slen));
+
+	/* Write start address for memory target to */
+	addr64 = (u64)(block * flnand.pages_per_block + page) * flnand.main_size;
+
+	addr = (addr64 >> 32) << 28;
+	writel(NAND_CTRL_REG, addr | flnand.control);
+
+	addr = addr64 & 0xffffffff;
+	nand_wait_cmd_done(addr | NAND_CMD_PROGRAM);
+
+	nand_enable_wp();
+
+	status = readl(FDMA_MN_STATUS_REG);
+	if (status & (FDMA_STATUS_DMA_BUS_ERR | FDMA_STATUS_DMA_ADDR_ERR))
+		return -1;
+
+	status = readl(FIO_ECC_RPT_STATUS_REG);
+	if (status & FIO_ECC_RPT_CORR_FAIL) {
+		printf("BCH real corrected failed (0x%x)!\n", status);
+		return -1;
+	}
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STATUS_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+int nand_prog_pages_noecc(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	u32 mlen, slen, status, addr;
+	u64 addr64;
+
+	/* check parameters */
+	if ((page + pages) > flnand.pages_per_block || !buf) {
+		putstr("ERR: parameter error in nand_read_pages()");
+		return -1;
+	}
+
+	mlen = pages * flnand.main_size;
+	clean_d_cache((void *)buf, mlen);
+
+	slen = pages * flnand.spare_size;
+	memset(scratch_buffer, 0xff, slen);
+	clean_d_cache(scratch_buffer, slen);
+
+	nand_disable_wp();
+
+	/* disable BCH */
+	writel(FDMA_DSM_CTRL_REG, fdma_dsm_no_ecc_ctrl);
+	clrbitsl(FIO_CTRL_REG, FIO_CTRL_ECC_BCH_ENABLE);
+
+	/* clear all of NAND Interrupt status */
+	writel(FIO_RAW_INT_STATUS_REG, 0xff);
+
+	/* Setup FDMA engine transfer */
+	writel(FDMA_MN_MEM_ADDR_REG, (uintptr_t)buf);
+	writel(FDMA_SP_MEM_ADDR_REG, (uintptr_t)scratch_buffer);
+	writel(FDMA_MN_CTRL_REG, FDMA_CTRL_ENABLE | FDMA_CTRL_READ_MEM |
+				 FDMA_CTRL_BLK_SIZE_512B | (mlen + slen));
+
+	/* Write start address for memory target to */
+	addr64 = (u64)(block * flnand.pages_per_block + page) * flnand.main_size;
+
+	addr = (addr64 >> 32) << 28;
+	writel(NAND_CTRL_REG, addr | flnand.control);
+
+	addr = addr64 & 0xffffffff;
+	nand_wait_cmd_done(addr | NAND_CMD_PROGRAM);
+
+	nand_enable_wp();
+
+	status = readl(FDMA_MN_STATUS_REG);
+	if (status & (FDMA_STATUS_DMA_BUS_ERR | FDMA_STATUS_DMA_ADDR_ERR))
+		return -1;
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STATUS_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+/**
+ * Read spare area from NAND flash. PS: always disable ECC.
+ */
+int nand_read_spare(u32 block, u32 page, u32 pages, u8 *spare_buf)
+{
+	return nand_read_pages(block, page, pages, NULL, spare_buf, 0);
+}
+
+/**
+ * Program spare area to NAND flash.
+ * Only for mark bad block, disable ECC.
+ */
+int nand_prog_spare(u32 block, u32 page, u32 pages, u8 *spare_buf)
+{
+	u32 mlen, slen, status, addr;
+	u64 addr64;
+
+	/* check parameters */
+	if ((page + pages) > flnand.pages_per_block || !spare_buf) {
+		putstr("ERR: parameter error in nand_read_pages()");
+		return -1;
+	}
+
+	mlen = pages * flnand.main_size;
+	memset(scratch_buffer, 0xff, mlen);
+	clean_d_cache((void *)scratch_buffer, mlen);
+
+	slen = pages * flnand.spare_size;
+	clean_d_cache(spare_buf, slen);
+
+	nand_disable_wp();
+
+	/* disable BCH */
+	writel(FDMA_DSM_CTRL_REG, fdma_dsm_no_ecc_ctrl);
+	clrbitsl(FIO_CTRL_REG, FIO_CTRL_ECC_BCH_ENABLE);
+
+	/* clear all of NAND Interrupt status */
+	writel(FIO_RAW_INT_STATUS_REG, 0xff);
+
+	/* Setup FDMA engine transfer */
+	writel(FDMA_MN_MEM_ADDR_REG, (uintptr_t)scratch_buffer);
+	writel(FDMA_SP_MEM_ADDR_REG, (uintptr_t)spare_buf);
+	writel(FDMA_MN_CTRL_REG, FDMA_CTRL_ENABLE | FDMA_CTRL_READ_MEM |
+				 FDMA_CTRL_BLK_SIZE_512B | (mlen + slen));
+
+	/* Write start address for memory target to */
+	addr64 = (u64)(block * flnand.pages_per_block + page) * flnand.main_size;
+
+	addr = (addr64 >> 32) << 28;
+	writel(NAND_CTRL_REG, addr | flnand.control);
+
+	addr = addr64 & 0xffffffff;
+	nand_wait_cmd_done(addr | NAND_CMD_PROGRAM);
+
+	nand_enable_wp();
+
+	status = readl(FDMA_MN_STATUS_REG);
+	if (status & (FDMA_STATUS_DMA_BUS_ERR | FDMA_STATUS_DMA_ADDR_ERR))
+		return -1;
+
+	status = readl(FIO_ECC_RPT_STATUS_REG);
+	if (status & FIO_ECC_RPT_CORR_FAIL) {
+		printf("BCH real corrected failed (0x%x)!\n", status);
+		return -1;
+	}
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STATUS_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+/**
+ * Erase a NAND flash block.
+ */
+int nand_erase_block(u32 block)
+{
+	u64 addr64 = (u64)block * flnand.block_size;
+	u32 status, addr, val;
+
+	nand_disable_wp();
+
+	/* clear all of NAND Interrupt status */
+	writel(FIO_RAW_INT_STATUS_REG, 0xff);
+
+	/* Setup Flash Control Register */
+	addr = (addr64 >> 32) << 28;
+	writel(NAND_CTRL_REG, addr | flnand.control);
+
+	addr = addr64 & 0xffffffff;
+	writel(NAND_CMD_REG, addr);
+
+	val = NAND_CC_WORD_CMD1VAL0(0x60) | NAND_CC_WORD_CMD2VAL0(0xD0);
+	writel(NAND_CC_WORD_REG, val);
+
+	val = NAND_CC_DATA_CYCLE(5) | NAND_CC_WAIT_RB | NAND_CC_RW_NODATA |
+		NAND_CC_CMD2(1) | NAND_CC_ADDR_CYCLE(3) | NAND_CC_CMD1(1) |
+		NAND_CC_ADDR_SRC(1) | NAND_CC_DATA_SRC_REGISTER | NAND_CC_TERMINATE_CE;
+	writel(NAND_CC_REG, val);
+
+	nand_wait_cmd_done(NAND_CMD_NOP);
+
+	nand_enable_wp();
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STATUS_REG);
+
+	if ((status & 0x1)) {
+		/* Reset chip */
+		nand_wait_cmd_done(NAND_CMD_RESET);
+		return -1;
+	} else {
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+		/*
+		 * If erase successfully and block is marked as bad in BBT,
+		 * then update BBT.
+		 */
+		if (nand_is_bad_block(block))
+			nand_update_bbt(0, block);
+#endif
+		return 0;
+	}
+}
+
diff --git a/src/bld/nand_legacy.c b/src/bld/nand_legacy.c
new file mode 100644
index 0000000..4a8e6dd
--- /dev/null
+++ b/src/bld/nand_legacy.c
@@ -0,0 +1,1548 @@
+/**
+ * bld/nand.c
+ *
+ * Flash controller functions with NAND chips.
+ *
+ * History:
+ *    2005/02/15 - [Charles Chiou] created file
+ *    2006/07/26 - [Charles Chiou] converted to DMA descriptor-mode
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <ambhw/nand.h>
+#include <ambhw/dma.h>
+#include <ambhw/cache.h>
+#include <fio/ftl_const.h>
+#include <flash/nanddb.h>
+
+/* ==========================================================================*/
+#define NAND_CMD_NOP			0x0
+#define NAND_CMD_DMA			0x1
+#define NAND_CMD_RESET			0x2
+#define NAND_CMD_NOP2			0x3
+#define NAND_CMD_NOP3			0x4
+#define NAND_CMD_NOP4			0x5
+#define NAND_CMD_NOP5			0x6
+#define NAND_CMD_COPYBACK		0x7
+#define NAND_CMD_NOP6			0x8
+#define NAND_CMD_ERASE			0x9
+#define NAND_CMD_READID			0xa
+#define NAND_CMD_NOP7			0xb
+#define NAND_CMD_READSTATUS		0xc
+#define NAND_CMD_NOP8			0xd
+#define NAND_CMD_READ			0xe
+#define NAND_CMD_PROGRAM		0xf
+
+#define NAND_CMD_TIMEOUT		1000
+#define NAND_DMA_TIMEOUT		1000
+
+/* ==========================================================================*/
+extern flnand_t flnand;
+
+/**
+ * DMA descriptor.
+ */
+struct fio_dmadesc_s
+{
+	u32	src_addr;	/**< Source address */
+	u32	dst_addr;	/**< Destination address */
+	u32	next;		/**< Next descriptor */
+	u32	rpt_addr;	/**< Report address */
+	u32	xfrcnt;		/**< Transfer count */
+	u32	ctrl;		/**< Control */
+	u32	rsv0;		/**< Reserved */
+	u32	rsv1;		/**< Reserved */
+	u32	rpt;		/**< Report */
+	u32	rsv2;		/**< Reserved */
+	u32	rsv3;		/**< Reserved */
+	u32	rsv4;		/**< Reserved */
+} __attribute__((packed));
+
+static struct fio_dmadesc_s G_fio_dmadesc __attribute__((aligned(32)));
+static struct fio_dmadesc_s G_fio_dma_spr_desc __attribute__((aligned(32)));
+
+#define PAGE_SIZE_512		512
+#define PAGE_SIZE_2K		2048
+#define MAX_SPARE_SIZE_BLK	8192
+
+#define ECC_STEPS			4
+static u8 buffer[PAGE_SIZE_2K] __attribute__ ((aligned(32)));
+static u8 dummy_buffer_bch[MAX_SPARE_SIZE_BLK] __attribute__ ((aligned(32)));
+
+/* ==========================================================================*/
+
+static void nand_wait_cmd_done(u32 cmd)
+{
+	writel(NAND_CMD_REG, cmd);
+
+	rct_timer2_reset_count();
+
+	while(1) {
+		if (readl(NAND_INT_REG) & NAND_INT_DI)
+			break;
+
+		if (rct_timer2_get_count() >= NAND_CMD_TIMEOUT) {
+			putstr("nand cmd timeout: ");
+			puthex(cmd);
+			putstr("\r\n");
+			while(1);
+		}
+	}
+
+	writel(NAND_INT_REG, 0x0);
+}
+
+static void nand_wait_dma_done(void)
+{
+	rct_timer2_reset_count();
+
+	while(1) {
+		if ((readl(NAND_INT_REG) & NAND_INT_DI) &&
+			(readl(FDMA_REG(DMA_INT_OFFSET)) & 0x1) &&
+			(readl(FIO_DMASTA_REG) & FIO_DMASTA_DN) &&
+			!(readl(FDMA_CHAN_CTR_REG) & FDMA_CHAN_CTR_EN) &&
+			!(readl(FIO_DMACTR_REG) & FIO_DMACTR_EN))
+			break;
+
+		if (rct_timer2_get_count() >= NAND_DMA_TIMEOUT) {
+			putstr("nand dma timeout\r\n");
+			while(1);
+		}
+	}
+}
+
+static void nand_wait_desc_dma_done(void)
+{
+	rct_timer2_reset_count();
+
+	while(1) {
+		_clean_flush_d_cache();
+
+		if ((readl(NAND_INT_REG) & NAND_INT_DI) &&
+			(readl(FDMA_REG(DMA_INT_OFFSET)) & 0x1) &&
+			(readl(FIO_DMASTA_REG) & FIO_DMASTA_DN) &&
+			(G_fio_dmadesc.rpt & FDMA_CHAN_STA_DN))
+			break;
+
+		if (rct_timer2_get_count() >= NAND_DMA_TIMEOUT) {
+			putstr("nand desc dma timeout\r\n");
+			while(1);
+		}
+	}
+}
+
+/* ==========================================================================*/
+
+/**
+ * Calculate address from the (block, page) pair.
+ */
+u32 addr_from_block_page(u32 block, u32 page)
+{
+	u32 rval = ((block * flnand.pages_per_block) + page);
+
+	if (flnand.main_size == PAGE_SIZE_512)
+		return (rval << 9);
+	else if (flnand.main_size == PAGE_SIZE_2K)
+		return (rval << 11);
+
+	return -1;
+}
+
+#define hweight8(w)		\
+      (	(!!((w) & (0x01 << 0))) +	\
+	(!!((w) & (0x01 << 1))) +	\
+	(!!((w) & (0x01 << 2))) +	\
+	(!!((w) & (0x01 << 3))) +	\
+	(!!((w) & (0x01 << 4))) +	\
+	(!!((w) & (0x01 << 5))) +	\
+	(!!((w) & (0x01 << 6))) +	\
+	(!!((w) & (0x01 << 7)))	)
+
+static int count_zero_bits(u8 *buf, int size, int max_bits)
+{
+	int i, zero_bits = 0;
+
+	for (i = 0; i < size; i++) {
+		zero_bits += hweight8(~buf[i]);
+		if (zero_bits > max_bits)
+			break;
+	}
+	return zero_bits;
+}
+
+
+/*
+	This func maybe not have effect when read (>1)pages data
+	and we do not memset the erased page to 0xFF, if error bit < ecc_bits
+*/
+static int nand_bch_check_blank_pages(u32 pages, u8 *main, u8 *spare)
+{
+	u32 i, j;
+	int zeroflip = 0;
+	int oob_subset, main_subset;
+	int zero_bits = 0;
+	u8 *bsp;
+	u8 *bufpos;
+
+	bsp = spare;
+	bufpos = main;
+	main_subset = flnand.main_size / ECC_STEPS;
+	oob_subset  = flnand.spare_size / ECC_STEPS;
+	if (flnand.ecc_bits > 0x1) {
+		for (i = 0; i < pages; i++) {
+			zeroflip = 0;
+			for (j = 0; j < ECC_STEPS; j++) {
+				zero_bits = count_zero_bits(bufpos, main_subset,
+								flnand.ecc_bits);
+				if (zero_bits > flnand.ecc_bits)
+					return -1;
+
+				if (zero_bits)
+					zeroflip = 1;
+
+				zero_bits += count_zero_bits(bsp, oob_subset,
+								flnand.ecc_bits);
+				if (zero_bits > flnand.ecc_bits)
+					return -1;
+
+				bufpos += main_subset;
+				bsp += oob_subset;
+			}
+			/* use zeroflip for declaring blank page status */
+			if (zeroflip)
+				printf("Erased blank page has bitflip \n");
+		}
+	}
+	return 0;
+}
+
+static void nand_corrected_recovery(void)
+{
+	u32 fio_ctr_reg;
+
+	/* FIO reset will just reset FIO registers, but will not affect
+	 * Nand controller. */
+	fio_ctr_reg = readl(FIO_CTR_REG);
+
+	writel(FIO_RESET_REG, FIO_RESET_FIO_RST);
+	rct_timer_dly_ms(1);
+	writel(FIO_RESET_REG, 0x0);
+	rct_timer_dly_ms(1);
+
+	writel(FIO_CTR_REG, fio_ctr_reg);
+}
+
+/*
+ * Set Flash_IO_dsm_control Register
+ */
+static void nand_en_bch()
+{
+	u32 fio_dsm_ctr = 0, fio_ctr_reg = 0, dma_dsm_ctr = 0;
+
+	fio_ctr_reg = readl(FIO_CTR_REG);
+	/* Setup FIO Dual Space Mode Control Register */
+	if (flnand.ecc_bits > 0x1) {
+		/* Using BCH */
+		fio_dsm_ctr |= (FIO_DSM_EN | FIO_DSM_MAJP_2KB);
+		dma_dsm_ctr |= (DMA_DSM_EN | DMA_DSM_MAJP_2KB);
+		fio_ctr_reg |= (FIO_CTR_RS | FIO_CTR_CO);
+
+		if (flnand.ecc_bits == 0x6) {
+			fio_dsm_ctr |= FIO_DSM_SPJP_64B;
+			dma_dsm_ctr |= DMA_DSM_SPJP_64B;
+			fio_ctr_reg |=	FIO_CTR_ECC_6BIT;
+		} else {
+			fio_dsm_ctr |= FIO_DSM_SPJP_128B;
+			dma_dsm_ctr |= DMA_DSM_SPJP_128B;
+			fio_ctr_reg |=	FIO_CTR_ECC_8BIT;
+			writel(NAND_EXT_CTR_REG, readl(NAND_EXT_CTR_REG) | NAND_EXT_CTR_SP_2X);
+		}
+	} else {
+		/* Should not be here! */
+		putstr("ECC bit is 0 or 1,Do not need to enable BCH,so it can not be here!\n\r");
+	}
+
+	if (FIO_SUPPORT_SKIP_BLANK_ECC)
+		fio_ctr_reg |= FIO_CTR_SKIP_BLANK;
+
+	writel(FIO_DSM_CTR_REG, fio_dsm_ctr);
+	writel(FIO_CTR_REG, fio_ctr_reg);
+	writel(FDMA_CHAN_DSM_CTR_REG, dma_dsm_ctr);
+}
+
+/*
+ * Disable Flash_IO_dsm_control and Flash_IO_control Register
+ */
+static void nand_dis_bch()
+{
+	u32 fio_ctr_reg = 0;
+
+	fio_ctr_reg = readl(FIO_CTR_REG);
+	/* Setup FIO Dual Space Mode Control Register */
+	fio_ctr_reg |= FIO_CTR_RS;
+	fio_ctr_reg &= ~(FIO_CTR_CO |
+			 FIO_CTR_ECC_6BIT |
+			 FIO_CTR_ECC_8BIT);
+
+	writel(FIO_CTR_REG, fio_ctr_reg);
+}
+
+/**
+ * Check for bad block.
+ */
+int nand_is_bad_block(u32 block)
+{
+	int ret_val = -1, i;
+	u8 sbuf[1024], *sbuf_ptr;
+	u8 bi;
+
+	/* make sure 32 bytes aligned */
+	sbuf_ptr = (u8 *)(((uintptr_t)sbuf + 31) & (~31));
+
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+	if(nand_has_bbt())
+		return nand_isbad_bbt(block);
+#endif
+
+	ret_val = nand_read_spare(block, 0, BAD_BLOCK_PAGES, sbuf_ptr);
+	if (ret_val < 0) {
+		putstr("check bad block failed >> "
+				"read spare data error.\r\n");
+		/* Treat as factory bad block */
+		return NAND_INITIAL_BAD_BLOCK;
+	}
+
+	for (i = 0; i < INIT_BAD_BLOCK_PAGES; i++) {
+		if (flnand.main_size == 512)
+			bi = *(sbuf_ptr + i * flnand.spare_size + 5);
+		else
+			bi = *(sbuf_ptr + i * flnand.spare_size);
+
+		if (bi != 0xff)
+			break;
+	}
+
+
+	/* Good block */
+	if (i == INIT_BAD_BLOCK_PAGES)
+		return NAND_GOOD_BLOCK;
+
+	for (i = INIT_BAD_BLOCK_PAGES; i < BAD_BLOCK_PAGES; i++) {
+		if (flnand.main_size == 512)
+			bi = *(sbuf_ptr + i * flnand.spare_size + 5);
+		else
+			bi = *(sbuf_ptr + i * flnand.spare_size);
+
+		if (bi != 0xff)
+			break;
+	}
+
+	if (i < BAD_BLOCK_PAGES) {
+		/* Late developed bad blocks. */
+		return NAND_LATE_DEVEL_BAD_BLOCK;
+	} else {
+		/* Initial invalid blocks. */
+		return NAND_INITIAL_BAD_BLOCK;
+	}
+}
+
+int nand_correct_offset(u32 start_blk, u32 offset, u32 *c_offset)
+{
+	int i = 0;
+	u32 bad_blk = 0, valid_blk = 0;
+	u32 blk_size = flnand.block_size;
+	u32 offset_blk = ROUND_DOWN(offset, blk_size)/blk_size;
+
+	for (i = 0, valid_blk = 0; valid_blk < offset_blk; i++) {
+		if (nand_is_bad_block(start_blk + i) == NAND_GOOD_BLOCK) {
+			valid_blk++;
+		} else {
+			bad_blk++;
+		}
+	}
+	if (c_offset) {
+		*c_offset = (bad_blk * blk_size) + offset;
+	}
+
+	return 0;
+}
+
+void nand_output_bad_block(u32 block, int bb_type)
+{
+	if (bb_type & NAND_INITIAL_BAD_BLOCK) {
+		putstr("initial bad block. <block ");
+	} else if (bb_type & NAND_LATE_DEVEL_BAD_BLOCK) {
+		putstr("late developed bad block. <block ");
+	} else {
+		putstr("other bad block. <block ");
+	}
+	putdec(block);
+	putstr(">\r\n");
+	putstr("Try next block...\r\n");
+}
+
+/**
+ * Mark a bad block.
+ */
+int nand_mark_bad_block(u32 block)
+{
+	int ret_val = -1, i;
+	u8 sbuf[256], *sbuf_ptr;
+	u8 bi;
+
+	/* make sure 32 bytes aligned */
+	sbuf_ptr = (u8 *)(((uintptr_t)sbuf + 31) & (~31));
+
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+	nand_update_bbt(block, 0);
+#endif
+
+	for (i = AMB_BB_START_PAGE; i < BAD_BLOCK_PAGES; i++) {
+		memset(sbuf_ptr, 0xff, flnand.spare_size);
+		if (flnand.main_size == 512) {
+			*(sbuf_ptr + 5) = AMB_BAD_BLOCK_MARKER;
+		} else {
+			*sbuf_ptr = AMB_BAD_BLOCK_MARKER;
+		}
+
+		ret_val = nand_prog_spare(block, i, 1, sbuf_ptr);
+		if (ret_val < 0) {
+			putstr("mark bad block failed >> "
+				"write spare data error.\r\n");
+			return ret_val;
+		}
+
+		ret_val = nand_read_spare(block, i, 1, sbuf_ptr);
+		if (ret_val < 0) {
+			putstr("mark bad block failed >> "
+				"read spare data error.\r\n");
+			return ret_val;
+		}
+
+		if (flnand.main_size == 512)
+			bi = *(sbuf_ptr + 5);
+		else
+			bi = *sbuf_ptr;
+
+		if (bi == 0xff) {
+			putstr("mark bad block failed >> "
+				"verify failed at block ");
+			putdec(block);
+			putstr("\r\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * Initialize NAND parameters.
+ */
+int nand_init(void)
+{
+	nand_db_t *nand_db;
+	u32 id, id5, sys_config_val;
+	int i, match = 0;
+	flnand_t *fn = &flnand;
+	int sblk, nblk, part_size[HAS_IMG_PARTS];
+
+	writel(FIO_DMACTR_REG,
+	       (readl(FIO_DMACTR_REG) & 0xcfffffff) | FIO_DMACTR_FL);
+
+	/* Force ReadID with 4-cycles */
+	writel(NAND_CTR_REG, readl(NAND_CTR_REG) | NAND_CTR_I4);
+
+	/* Reset chip */
+	nand_wait_cmd_done(NAND_CMD_RESET);
+
+	/* Read ID with maximun 5 times if id is 0. */
+	for (i = 0; i < 5; i++) {
+		nand_wait_cmd_done(NAND_CMD_READID);
+		id = readl(NAND_ID_REG);
+		if (id)
+			break;
+	}
+
+	ASSERT(id == 0, "NAND chip absence?\n");
+
+	/* Read ID5 with maximun 5 times if id is 0. */
+	/* Disable NAND_CTR_I4 */
+	writel(NAND_CTR_REG, readl(NAND_CTR_REG) & ~(NAND_CTR_I4));
+	writel(NAND_EXT_CTR_REG, readl(NAND_EXT_CTR_REG) | NAND_EXT_CTR_I5);
+	for (i = 0; i < 5; i++) {
+		nand_wait_cmd_done(NAND_CMD_READID);
+		id5 = readl(NAND_EXT_ID5_REG) & 0xff;
+		if (id5)
+			break;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ns_nand_ids); i++) {
+		ASSERT((id == ns_nand_ids[i].nand_id && id5 == ns_nand_ids[i].id5),
+				"Unsupport NAND flash\r\n");
+	}
+
+	/* Search the NAND-DB for an exact match */
+	for (nand_db = __nanddb_start; nand_db < __nanddb_end; nand_db++) {
+		if ((nand_db->id == id && nand_db->id5 == id5) ||
+			(id == 0x01F1801D && nand_db->id == id)) {
+			match = 1;
+			break;
+		}
+	}
+
+	ASSERT(!match, "Non-matched NAND: 0x%x, 0x%x\n", id, id5);
+
+	fn->nandtiming0 = nand_db->timing0;
+	fn->nandtiming1 = nand_db->timing1;
+	fn->nandtiming2 = nand_db->timing2;
+	fn->nandtiming3 = nand_db->timing3;
+	fn->nandtiming4 = nand_db->timing4;
+	fn->nandtiming5 = nand_db->timing5;
+	fn->nandtiming6 = nand_db->timing6;
+
+	/* Setup flash timing register */
+	writel(NAND_TIMING0_REG, FLASH_TIMING_MIN(nand_db->timing0, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing0, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing0, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing0, 0));
+
+	writel(NAND_TIMING1_REG, FLASH_TIMING_MIN(nand_db->timing1, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing1, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing1, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing1, 0));
+
+	writel(NAND_TIMING2_REG, FLASH_TIMING_MIN(nand_db->timing2, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing2, 16)	|
+			 FLASH_TIMING_MAX(nand_db->timing2, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing2, 0));
+
+	writel(NAND_TIMING3_REG, FLASH_TIMING_MIN(nand_db->timing3, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing3, 16)	|
+			 FLASH_TIMING_MAX(nand_db->timing3, 8)	|
+			 FLASH_TIMING_MAX(nand_db->timing3, 0));
+
+	writel(NAND_TIMING4_REG, FLASH_TIMING_MIN(nand_db->timing4, 24)	|
+			 FLASH_TIMING_MIN(nand_db->timing4, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing4, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing4, 0));
+
+	writel(NAND_TIMING5_REG, FLASH_TIMING_MIN(nand_db->timing5, 16)	|
+			 FLASH_TIMING_MAX(nand_db->timing5, 8)	|
+			 FLASH_TIMING_MIN(nand_db->timing5, 0));
+
+#if (NAND_CUSTOM_CMD_SUPPORT == 1)
+	writel(NAND_TIMING6_REG, FLASH_TIMING_MIN(nand_db->timing6, 16)	|
+			 FLASH_TIMING_MIN(nand_db->timing6, 8)	|
+			 FLASH_TIMING_MAX(nand_db->timing6, 0));
+#endif
+
+	fn->main_size = nand_db->main_size;
+	fn->spare_size = nand_db->spare_size;
+	fn->blocks_per_bank = nand_db->blocks_per_bank;
+	fn->pages_per_block = nand_db->pages_per_block;
+	fn->block_size = nand_db->main_size * nand_db->pages_per_block;
+
+	fn->control = NAND_CTR_IE;
+
+	if (fn->blocks_per_bank * fn->pages_per_block > 65536)
+		fn->control |= NAND_CTR_P3;
+
+	if (fn->main_size == 2048)
+		fn->control |= NAND_CTR_C2 | NAND_CTR_RC;
+
+	switch (fn->block_size * fn->blocks_per_bank) {
+	case 8 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_64M;
+		break;
+	case 16 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_128M;
+		break;
+	case 32 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_256M;
+		break;
+	case 64 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_512M;
+		break;
+	case 128 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_1G;
+		break;
+	case 256 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_2G;
+		break;
+	case 512 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_4G;
+		break;
+	case 1024 * 1024 * 1024:
+		fn->control |= NAND_CTR_SZ_8G;
+		break;
+	default:
+		ASSERT(1, "Unexpected NAND flash chipsize\r\n");
+		break;
+	}
+
+	sys_config_val = rct_get_nand_poc();
+	if ((sys_config_val & RCT_BOOT_NAND_ECC_BCH_EN) ==
+		RCT_BOOT_NAND_ECC_BCH_EN) {
+		if ((sys_config_val & RCT_BOOT_NAND_ECC_SPARE_2X) ==
+			RCT_BOOT_NAND_ECC_SPARE_2X) {
+			fn->ecc_bits = 8;
+		} else {
+			fn->ecc_bits = 6;
+		}
+	} else {
+		fn->ecc_bits = 1;
+	}
+
+	ASSERT((fn->ecc_bits != 1) && (fn->main_size == 512),
+		"Small page does not support multi-bits ECC!\r\n");
+
+	ASSERT((fn->ecc_bits == 8) && (fn->spare_size != 128),
+		"Spare size must be 2x for 8-bits ECC!\r\n");
+
+	if (fn->ecc_bits > 1)
+		nand_en_bch();
+
+	get_part_size(part_size);
+
+	sblk = nblk = 0;
+	for (i = 0; i < HAS_IMG_PARTS; i++) {
+		if ((get_part_dev(i) & PART_DEV_NAND) != PART_DEV_NAND) {
+			continue;
+		}
+
+		sblk += nblk;
+		nblk = part_size[i] / fn->block_size;
+		if ((part_size[i] % fn->block_size) != 0x0)
+			nblk++;
+		fn->sblk[i] = (nblk == 0) ? 0 : sblk;
+		fn->nblk[i] = nblk;
+	}
+	for (; i < PART_MAX; i++) {
+		fn->sblk[i] = 0;
+		fn->nblk[i] = 0;
+	}
+
+	nblk = (fn->blocks_per_bank > sblk) ? (fn->blocks_per_bank - sblk) : 0;
+	//Raw part include BBT, take care!
+	fn->sblk[PART_RAW] = (nblk == 0) ? 0 : sblk;
+	fn->nblk[PART_RAW] = nblk;
+	ASSERT(fn->sblk[PART_RAW] < 2, "No Space for BBT!\r\n");
+
+	/* Reset FIO FIFO, and Exit random read mode */
+	setbitsl(FIO_CTR_REG, FIO_CTR_RR);
+	rct_timer2_dly_ms(1); /* delay is must have */
+	clrbitsl(FIO_CTR_REG, FIO_CTR_RR);
+
+	/* Clear the FIO DMA Status Register */
+	writel(FIO_DMASTA_REG, 0x0);
+
+	/* Setup FIO DMA Control Register */
+	writel(FIO_DMACTR_REG, FIO_DMACTR_FL | FIO_DMACTR_TS4B);
+
+	/* Setup NAND Flash Control Register */
+	writel(NAND_CTR_REG, flnand.control);
+	writel(NAND_INT_REG, 0x0);
+
+	return 0;
+}
+
+/**
+ * Read multiple pages from NAND flash with ecc check.
+ */
+int nand_read_pages(u32 block, u32 page, u32 pages,
+		u8 *main_buf, u8 *spare_buf, u32 enable_ecc)
+{
+	u32 status, addr, mlen, slen;
+	u32 spare_buf_addr = 0, fio_ctr_reg = 0;
+	u32 nand_ctr_reg = flnand.control, i;
+
+	/* check parameters */
+	if ((page + pages) > flnand.pages_per_block || !main_buf) {
+		putstr("ERR: parameter error in nand_read_pages()");
+		return -1;
+	}
+
+	mlen = pages * flnand.main_size;
+	clean_flush_d_cache((void *)main_buf, mlen);
+
+	/* Setup Flash Control Register */
+#if (NAND_XD_SUPPORT_WAS == 0) && (NAND_SUPPORT_INTLVE == 0)
+	nand_ctr_reg = flnand.control;
+#elif (NAND_XD_SUPPORT_WAS >= 1) && (NAND_SUPPORT_INTLVE == 0)
+	nand_ctr_reg = flnand.control | NAND_CTR_WAS;
+#elif (NAND_XD_SUPPORT_WAS >= 1) && (NAND_SUPPORT_INTLVE == 1)
+	nand_ctr_reg = flnand.control | NAND_CTR_WAS;
+
+#if defined(NAND_K9K8_INTLVE)
+	nand_ctr_reg = flnand.control | NAND_CTR_K9;
+#endif
+#endif
+
+	spare_buf = spare_buf ? : dummy_buffer_bch;
+	spare_buf_addr = (uintptr_t)spare_buf;
+
+	/* Setup Flash IO Control Register */
+	if (enable_ecc) {
+		if (flnand.ecc_bits > 1) {
+			slen = pages * flnand.spare_size;
+			clean_flush_d_cache(spare_buf, slen);
+
+			nand_en_bch();
+			/* Setup Flash Control Register*/
+			/* Don't set NAND_CTR_EC_MAIN, because we use BCH */
+			writel(NAND_CTR_REG, nand_ctr_reg | NAND_CTR_SE);
+			/* Clean Flash_IO_ecc_rpt_status Register */
+			writel(FIO_ECC_RPT_STA_REG, 0x0);
+		} else {
+			slen = 0;
+			/* Setup Flash IO Control Register */
+			writel(FIO_CTR_REG, FIO_CTR_XD | FIO_CTR_RS | FIO_CTR_CO);
+
+			/* Setup Flash Control Register*/
+			writel(NAND_CTR_REG, nand_ctr_reg | NAND_CTR_SE | NAND_CTR_EC_MAIN);
+		}
+	} else {
+		if (flnand.ecc_bits > 1) {
+			slen = pages * flnand.spare_size;
+			clean_flush_d_cache(spare_buf, slen);
+
+			nand_dis_bch();
+			fio_ctr_reg = FIO_CTR_XD | FIO_CTR_RS;
+		} else {
+			slen = 0;
+			fio_ctr_reg = FIO_CTR_XD;
+		}
+
+		/* NO ECC */
+		writel(FIO_CTR_REG, fio_ctr_reg);
+		writel(NAND_CTR_REG, nand_ctr_reg);
+	}
+
+	/* Setup main external DMA engine transfer */
+	writel(FDMA_CHAN_STA_REG, 0x0);
+	writel(FDMA_CHAN_SRC_REG, (uintptr_t)FIO_FIFO_BASE);
+	writel(FDMA_CHAN_DST_REG, (uintptr_t)main_buf);
+
+	if (flnand.ecc_bits > 1) {
+		/* Setup spare external DMA engine transfer */
+		writel(FDMA_CHAN_SPR_STA_REG, 0x0);
+		writel(FDMA_CHAN_SPR_SRC_REG, (uintptr_t)FIO_FIFO_BASE);
+		writel(FDMA_CHAN_SPR_DST_REG, spare_buf_addr);
+		writel(FDMA_CHAN_SPR_CNT_REG, slen);
+	}
+
+	writel(FDMA_CHAN_CTR_REG,
+	       FDMA_CHAN_CTR_EN		|
+	       FDMA_CHAN_CTR_WM		|
+	       FDMA_CHAN_CTR_NI		|
+	       FDMA_NODC_MN_BURST_SIZE	|
+	       mlen);
+
+	/* Write start address for memory target to */
+	/* FIO DMA Address Register. */
+	addr = addr_from_block_page(block, page);
+	writel(FIO_DMAADR_REG, addr);
+
+	/* Setup the Flash IO DMA Control Register */
+	writel(FIO_DMACTR_REG,
+	       FIO_DMACTR_EN		|
+	       FIO_DMACTR_FL		|
+	       FIO_DMACTR_BLK_512B |
+	       FIO_DMACTR_TS8B	|
+	       (mlen + slen));
+
+	/* Wait for interrupt for DMA done */
+	nand_wait_dma_done();
+	status = readl(FIO_DMASTA_REG);
+
+	writel(NAND_INT_REG, 0x0);
+	writel(FIO_DMASTA_REG, 0x0);	/* clear */
+	writel(FDMA_REG(DMA_INT_OFFSET), 0x0);	/* clear */
+	writel(FDMA_CHAN_STA_REG, 0);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	if (flnand.ecc_bits > 1 && enable_ecc) {
+		status = readl(FIO_ECC_RPT_STA_REG);
+		if (status & FIO_ECC_RPT_FAIL) {
+			if (FIO_SUPPORT_SKIP_BLANK_ECC) {
+				if ((readl(FIO_CTR_REG) & FIO_CTR_SKIP_BLANK)) {
+					putstr("BCH real corrected failed (0x");
+					puthex(status);
+					putstr(")!\n\r");
+				} else {
+					putstr("Should not be here, error path");
+				}
+			} else {
+				/* Workaround for page never used, BCH will failed */
+				i = nand_bch_check_blank_pages(pages, (u8 *)main_buf,
+						(u8 *)(uintptr_t)spare_buf_addr);
+
+				if (i < 0) {
+					putstr("BCH corrected failed (0x");
+					puthex(status);
+					putstr(")!\n\r");
+				}
+			}
+		} else if (status & FIO_ECC_RPT_ERR) {
+#if 0
+			putstr("BCH code corrected (0x");
+			puthex(status);
+			putstr(")!\n\r");
+#endif
+			/* once bitflip and data corrected happened, BCH will keep
+			 * on to report bitflip in next read operation, even though
+			 * there is no bitflip happened really. So this is a workaround
+			 * to get it back. */
+			nand_corrected_recovery();
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static int nand_read(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	int rval = 0;
+	u32 first_blk_pages, blocks, last_blk_pages;
+	u32 bad_blks = 0;
+
+	first_blk_pages = flnand.pages_per_block - page;
+	if (pages > first_blk_pages) {
+		pages -= first_blk_pages;
+		blocks = pages / flnand.pages_per_block;
+		last_blk_pages = pages % flnand.pages_per_block;
+	} else {
+		first_blk_pages = pages;
+		blocks = 0;
+		last_blk_pages = 0;
+	}
+
+	if (first_blk_pages) {
+		while (nand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = nand_read_pages(block, page, first_blk_pages, buf, NULL, 1);
+		if (rval < 0)
+			return -1;
+		block++;
+		buf += first_blk_pages * flnand.main_size;
+	}
+
+	while (blocks > 0) {
+		while (nand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = nand_read_pages(block, 0, flnand.pages_per_block, buf, NULL, 1);
+		if (rval < 0)
+			return -1;
+		block++;
+		blocks--;
+		buf += flnand.block_size;
+	}
+
+	if (last_blk_pages) {
+		while (nand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = nand_read_pages(block, 0, last_blk_pages, buf, NULL, 1);
+		if (rval < 0)
+			return -1;
+	}
+
+	return bad_blks;
+}
+
+static void nand_get_offset_adr(u32 *block, u32 *page, u32 pages, u32 bad_blks)
+{
+	u32 blocks;
+
+	blocks = pages / flnand.pages_per_block;
+	pages  = pages % flnand.pages_per_block;
+
+	*block =  *block + blocks;
+	*page += pages;
+
+	if (*page >= flnand.pages_per_block) {
+		*page -= flnand.pages_per_block;
+		*block += 1;
+	}
+
+	*block += bad_blks;
+}
+
+/**
+ * Read data from NAND flash to memory.
+ * dst - address in dram.
+ * src - address in nand device.
+ * len - length to be read from nand.
+ * return - length of read data.
+ */
+int nand_read_data(u8 *dst, u8 *src, int len)
+{
+	u32 block, page, pages, pos;
+	u32 first_ppage_size, last_ppage_size;
+	uintptr_t val, rval = -1;
+
+	/* translate address to block, page, address */
+	val = (uintptr_t) src;
+	block = val / flnand.block_size;
+	val  -= block * flnand.block_size;
+	page  = val / flnand.main_size;
+	pos   = val % flnand.main_size;
+	pages = len / flnand.main_size;
+
+	if (pos == 0)
+		first_ppage_size = 0;
+	else
+		first_ppage_size = flnand.main_size - pos;
+
+	if (len >= first_ppage_size) {
+		pages = (len - first_ppage_size) / flnand.main_size;
+
+		last_ppage_size = (len - first_ppage_size) % flnand.main_size;
+	} else {
+		first_ppage_size = len;
+		pages = 0;
+		last_ppage_size = 0;
+	}
+
+	if (len !=
+	    (first_ppage_size + pages * flnand.main_size + last_ppage_size)) {
+		return -1;
+	}
+
+	len = 0;
+	if (first_ppage_size) {
+		rval = nand_read(block, page, 1, buffer);
+		if (rval < 0)
+			return len;
+
+		memcpy(dst, (void *) (buffer + pos), first_ppage_size);
+		dst += first_ppage_size;
+		len += first_ppage_size;
+		nand_get_offset_adr(&block, &page, 1, rval);
+	}
+
+	if (pages > 0) {
+		rval = nand_read(block, page, pages, dst);
+		if (rval < 0)
+			return len;
+
+		dst += pages * flnand.main_size;
+		len += pages * flnand.main_size;
+		nand_get_offset_adr(&block, &page, pages, rval);
+	}
+
+	if (last_ppage_size > 0) {
+		rval = nand_read(block, page, 1, buffer);
+		if (rval < 0)
+			return len;
+
+		memcpy(dst, (void *) buffer, last_ppage_size);
+		len += last_ppage_size;
+	}
+
+	return len;
+}
+
+/**
+ * Program a page to NAND flash.
+ */
+int nand_prog_pages(u32 block, u32 page, u32 pages, u8 *main_buf, u8 *spare_buf)
+{
+	int i;
+	u32 status;
+	u32 addr;
+	u32 mlen = 0, slen = 0;
+	u32 nand_ctr_reg = 0;
+	u32 spare_buf_addr = 0;
+	u32 dma_burst_ctrl, fio_burst_ctrl;
+
+	/* check parameters */
+	if ((page < 0 || page >= flnand.pages_per_block)	||
+	    (pages <= 0 || pages > flnand.pages_per_block)	||
+	    ((page + pages) > flnand.pages_per_block)		||
+	    (main_buf == NULL)) {
+		putstr("ERR: parameter error in nand_prog_pages()");
+		return -1;
+	}
+
+	for (i = 0; i < pages; i++)
+		mlen += flnand.main_size;
+
+	/* Setup FIO DMA Control Register */
+	writel(FIO_DMACTR_REG, FIO_DMACTR_FL | FIO_DMACTR_TS4B);
+
+	clean_d_cache((void *) main_buf, mlen);
+
+	/* diable write protect */
+	//gpio_set(FL_WP);
+
+	/* Always enable ECC */
+	if (flnand.ecc_bits > 1) {
+		/* Don't set NAND_CTR_EC_MAIN, because we use BCH */
+		nand_ctr_reg = flnand.control | NAND_CTR_SE;
+
+		slen = pages * flnand.spare_size;
+
+		if (spare_buf == NULL) {
+			memset(dummy_buffer_bch, 0xff, slen);
+			spare_buf_addr = (uintptr_t)dummy_buffer_bch;
+			clean_d_cache((void *) dummy_buffer_bch, slen);
+		} else {
+			spare_buf_addr = (uintptr_t)spare_buf;
+			clean_d_cache((void *) spare_buf, slen);
+		}
+		nand_en_bch();
+
+		/* Setup Flash Control Register*/
+		writel(NAND_CTR_REG, nand_ctr_reg);
+		/* Clean Flash_IO_ecc_rpt_status Register */
+		writel(FIO_ECC_RPT_STA_REG, 0x0);
+	} else {
+		/* Setup Flash IO Control Register */
+		writel(FIO_CTR_REG, FIO_CTR_RS | FIO_CTR_XD);
+
+		/* Setup Flash Control Register */
+		writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE | NAND_CTR_EG_MAIN);
+	}
+
+	/* Setup main external DMA engine transfer */
+	writel(FDMA_CHAN_STA_REG, 0x0);
+	writel(FDMA_CHAN_SRC_REG, (uintptr_t)main_buf);
+	writel(FDMA_CHAN_DST_REG, (uintptr_t)FIO_FIFO_BASE);
+
+	dma_burst_ctrl = FDMA_NODC_MN_BURST_SIZE;
+	fio_burst_ctrl = FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B;
+
+	if ((flnand.ecc_bits > 1)) {
+		/* Setup spare external DMA engine transfer */
+		writel(FDMA_CHAN_SPR_STA_REG, 0x0);
+		writel(FDMA_CHAN_SPR_SRC_REG, spare_buf_addr);
+		writel(FDMA_CHAN_SPR_DST_REG, (uintptr_t)FIO_FIFO_BASE);
+		writel(FDMA_CHAN_SPR_CNT_REG, slen);
+
+		dma_burst_ctrl = FDMA_CHAN_CTR_BLK_512B | FDMA_CHAN_CTR_TS_8B;
+		fio_burst_ctrl = FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B;
+	}
+
+	writel(FDMA_CHAN_CTR_REG,
+	       FDMA_CHAN_CTR_EN		|
+	       FDMA_CHAN_CTR_RM		|
+	       FDMA_CHAN_CTR_NI		|
+	       dma_burst_ctrl	|
+	       mlen);
+
+	/* Write start address for memory target to */
+	/* FIO DMA Address Register. */
+	addr =  addr_from_block_page(block, page);
+	writel(FIO_DMAADR_REG, addr);
+
+	/* Setup the Flash IO DMA Control Register */
+	writel(FIO_DMACTR_REG,
+	       FIO_DMACTR_EN		|
+	       FIO_DMACTR_RM		|
+	       FIO_DMACTR_FL		|
+	       fio_burst_ctrl	|
+			(mlen + slen));
+
+	/* Wait for interrupt for NAND operation done and DMA done */
+	nand_wait_dma_done();
+	status = readl(FIO_DMASTA_REG);
+
+	writel(NAND_INT_REG, 0x0);
+	writel(FIO_DMASTA_REG, 0x0);
+	writel(FDMA_REG(DMA_INT_OFFSET), 0x0);
+	writel(FDMA_CHAN_STA_REG, 0);
+
+	/* Enable write protect */
+	//gpio_clr(FL_WP);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	if (flnand.ecc_bits > 1) {
+		status = readl(FIO_ECC_RPT_STA_REG);
+		if (status & FIO_ECC_RPT_FAIL) {
+				putstr("BCH corrected failed (0x");
+				puthex(status);
+				putstr(")!\n\r");
+		} else if (status & FIO_ECC_RPT_ERR) {
+			putstr("BCH code corrected (0x");
+			puthex(status);
+			putstr(")!\n\r");
+		}
+	}
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STA_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+int nand_prog_pages_noecc(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	int i;
+	u32 status;
+	u32 addr;
+	u32 mlen = 0, slen = 0;
+	u32 spare_buf_addr = 0;
+	u32 dma_burst_ctrl, fio_burst_ctrl;
+
+	/* check parameters */
+	if ((page < 0 || page >= flnand.pages_per_block)	||
+	    (pages <= 0 || pages > flnand.pages_per_block)	||
+	    ((page + pages) > flnand.pages_per_block)		||
+	    (buf == NULL)) {
+		putstr("ERR: parameter error in nand_prog_pages()");
+		return -1;
+	}
+
+	for (i = 0; i < pages; i++)
+		mlen += flnand.main_size;
+
+	/* Setup FIO DMA Control Register */
+	writel(FIO_DMACTR_REG, FIO_DMACTR_FL | FIO_DMACTR_TS4B);
+
+	clean_d_cache((void *)buf, mlen);
+
+	if (flnand.ecc_bits > 1) {
+		slen = pages * flnand.spare_size;
+
+		memset(dummy_buffer_bch, 0xff, slen);
+		spare_buf_addr = (uintptr_t)dummy_buffer_bch;
+		clean_d_cache((void *)dummy_buffer_bch, slen);
+
+		nand_dis_bch();
+
+		/* Clean Flash_IO_ecc_rpt_status Register */
+		writel(FIO_ECC_RPT_STA_REG, 0x0);
+	} else {
+		putstr("ERR: Not implemented for 1-bit ECC yet!\r\n");
+		return -1;
+	}
+
+	/* Setup Flash IO Control Register */
+	writel(FIO_CTR_REG, FIO_CTR_RS | FIO_CTR_XD);
+	/* Setup Flash Control Register */
+	writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE);
+
+	/* Setup main external DMA engine transfer */
+	writel(FDMA_CHAN_STA_REG, 0x0);
+	writel(FDMA_CHAN_SRC_REG, (uintptr_t)buf);
+	writel(FDMA_CHAN_DST_REG, (uintptr_t)FIO_FIFO_BASE);
+
+	dma_burst_ctrl = FDMA_NODC_MN_BURST_SIZE;
+	fio_burst_ctrl = FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B;
+
+	if ((flnand.ecc_bits > 1)) {
+		/* Setup spare external DMA engine transfer */
+		writel(FDMA_CHAN_SPR_STA_REG, 0x0);
+		writel(FDMA_CHAN_SPR_SRC_REG, spare_buf_addr);
+		writel(FDMA_CHAN_SPR_DST_REG, (uintptr_t)FIO_FIFO_BASE);
+		writel(FDMA_CHAN_SPR_CNT_REG, slen);
+
+		dma_burst_ctrl = FDMA_CHAN_CTR_BLK_512B | FDMA_CHAN_CTR_TS_8B;
+		fio_burst_ctrl = FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B;
+	}
+
+	writel(FDMA_CHAN_CTR_REG,
+	       FDMA_CHAN_CTR_EN		|
+	       FDMA_CHAN_CTR_RM		|
+	       FDMA_CHAN_CTR_NI		|
+	       dma_burst_ctrl	|
+	       mlen);
+
+	/* Write start address for memory target to */
+	/* FIO DMA Address Register. */
+	addr =  addr_from_block_page(block, page);
+	writel(FIO_DMAADR_REG, addr);
+
+	/* Setup the Flash IO DMA Control Register */
+	writel(FIO_DMACTR_REG,
+	       FIO_DMACTR_EN		|
+	       FIO_DMACTR_RM		|
+	       FIO_DMACTR_FL		|
+	       fio_burst_ctrl		|
+	       (mlen + slen));
+
+	/* Wait for interrupt for NAND operation done and DMA done */
+	nand_wait_dma_done();
+	status = readl(FIO_DMASTA_REG);
+
+	writel(NAND_INT_REG, 0x0);
+	writel(FIO_DMASTA_REG, 0x0);
+	writel(FDMA_REG(DMA_INT_OFFSET), 0x0);
+	writel(FDMA_CHAN_STA_REG, 0);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STA_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+/**
+ * Read spare area from NAND flash.
+ * Always disable ECC.
+ */
+int nand_read_spare(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	int i;
+	u32 status;
+	u32 addr, size = 0, mlen = 0;
+	u32 desc_burst_ctrl = 0, fio_burst_ctrl;
+
+	/* check parameters */
+	if ((page < 0 || page >= flnand.pages_per_block)	||
+	    (pages <= 0 || pages > flnand.pages_per_block)	||
+	    ((page + pages) > flnand.pages_per_block)		||
+	    (buf == NULL)) {
+		putstr("ERR: parameter error in nand_read_spare()");
+		return -1;
+	}
+
+	for (i = 0; i < pages; i++) {
+		mlen += flnand.main_size;
+		size += flnand.spare_size;
+	}
+
+	if (flnand.ecc_bits > 1) {
+		if (mlen > MAX_SPARE_SIZE_BLK) {
+			putstr("ERR: too many pages at one time\n");
+		}
+		/* Always disable ECC */
+		/* Setup DMA main descriptor */
+		G_fio_dmadesc.src_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dmadesc.dst_addr = (uintptr_t)dummy_buffer_bch;
+		G_fio_dmadesc.next= 0x0;
+		G_fio_dmadesc.rpt_addr = (uintptr_t)&G_fio_dmadesc.rpt;
+		G_fio_dmadesc.xfrcnt = mlen;
+
+		/* Setup DMA spare descriptor */
+		G_fio_dma_spr_desc.src_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dma_spr_desc.dst_addr = (uintptr_t)buf;
+		G_fio_dma_spr_desc.next= 0x0;
+		G_fio_dma_spr_desc.rpt_addr = (uintptr_t)&G_fio_dma_spr_desc.rpt;
+		G_fio_dma_spr_desc.xfrcnt = size;
+		G_fio_dma_spr_desc.rpt = 0x0;
+
+		desc_burst_ctrl = FDMA_DESC_MN_BURST_SIZE;
+		fio_burst_ctrl 	= FIO_DMACTR_BLK_512B | FIO_DMACTR_TS8B;
+	} else {
+		/* Setup DMA descriptor */
+		G_fio_dmadesc.src_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dmadesc.dst_addr = (uintptr_t)buf;
+		G_fio_dmadesc.next= 0x0;
+		G_fio_dmadesc.rpt_addr = (uintptr_t)&G_fio_dmadesc.rpt;
+		G_fio_dmadesc.xfrcnt = size;
+
+		desc_burst_ctrl = FDMA_DESC_SP_BURST_SIZE;
+		fio_burst_ctrl 	= FIO_DMACTR_BLK_16B | FIO_DMACTR_TS8B;
+		mlen = 0;
+	}
+
+	G_fio_dmadesc.ctrl =
+		FDMA_DESC_WM |
+		FDMA_DESC_EOC |
+		FDMA_DESC_NI |
+		FDMA_DESC_IE |
+		FDMA_DESC_ST |
+		desc_burst_ctrl;
+	G_fio_dmadesc.rpt = 0x0;
+
+	_clean_flush_d_cache();
+
+	if (flnand.ecc_bits > 1) {
+		nand_dis_bch();
+
+		/* Setup Flash IO Control Register */
+		writel(FIO_CTR_REG, FIO_CTR_RS | FIO_CTR_XD);
+		/* Setup Flash Control Register*/
+		writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE);
+		/* Clean Flash_IO_ecc_rpt_status Register */
+		writel(FIO_ECC_RPT_STA_REG, 0x0);
+	} else {
+		/* Setup Flash IO Control Register */
+		writel(FIO_CTR_REG, FIO_CTR_RS | FIO_CTR_XD);
+		/* Setup Flash Control Register */
+		writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE  | NAND_CTR_SA);
+	}
+
+	/* Setup external DMA engine transfer */
+	writel(FDMA_CHAN_DA_REG, (uintptr_t)&G_fio_dmadesc);
+	writel(FDMA_CHAN_STA_REG, 0x0);
+
+	if (flnand.ecc_bits > 1) {
+		/* Setup spare external DMA engine descriptor address */
+		writel(FDMA_CHAN_SPR_DA_REG, (uintptr_t)&G_fio_dma_spr_desc);
+		writel(FDMA_CHAN_SPR_STA_REG, 0);
+	}
+
+	writel(FDMA_CHAN_CTR_REG,   FDMA_CHAN_CTR_D |   FDMA_CHAN_CTR_EN);
+
+	/* Write start address for memory target to */
+	/* FIO DMA Address Register. */
+	addr = addr_from_block_page(block, page);
+	writel(FIO_DMAADR_REG, addr);
+
+	/* Setup the Flash IO DMA Control Register */
+	writel(FIO_DMACTR_REG,
+	       FIO_DMACTR_EN		|
+	       FIO_DMACTR_FL		|
+	       fio_burst_ctrl		|
+	       (mlen + size));
+
+	/* Wait for interrupt for NAND operation done and DMA done */
+	nand_wait_desc_dma_done();
+	status = readl(FIO_DMASTA_REG);
+
+	writel(NAND_INT_REG, 0x0);
+	writel(FIO_DMASTA_REG, 0x0);
+	writel(FDMA_REG(DMA_INT_OFFSET), 0x0);
+	writel(FDMA_CHAN_STA_REG, 0x0);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STA_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+/**
+ * Program spare area to NAND flash.
+ * Only for mark bad block, disable ECC.
+ */
+int nand_prog_spare(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	int i;
+	u32 status;
+	u32 addr, size = 0, mlen = 0;
+
+	/* check parameters */
+	if ((page < 0 || page >= flnand.pages_per_block)	||
+	    (pages <= 0 || pages > flnand.pages_per_block)	||
+	    ((page + pages) > flnand.pages_per_block)		||
+	    (buf == NULL)) {
+		putstr("ERR: parameter error in nand_prog_spare()");
+		return -1;
+	}
+
+	for (i = 0; i < pages; i++) {
+		mlen += flnand.main_size;
+		size += flnand.spare_size;
+	}
+
+	if (flnand.ecc_bits > 1) {
+		if (mlen > MAX_SPARE_SIZE_BLK) {
+			putstr("ERR: too many pages at one time\n");
+		} else {
+			memset(dummy_buffer_bch, 0xff, mlen);
+		}
+
+		/* Always disable ECC */
+		/* Setup DMA main descriptor */
+		G_fio_dmadesc.src_addr = (uintptr_t)dummy_buffer_bch;
+		G_fio_dmadesc.dst_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dmadesc.next= 0x0;
+		G_fio_dmadesc.rpt_addr = (uintptr_t)&G_fio_dmadesc.rpt;
+		G_fio_dmadesc.xfrcnt = mlen;
+
+		/* Setup DMA spare descriptor */
+		G_fio_dma_spr_desc.src_addr = (uintptr_t)buf;
+		G_fio_dma_spr_desc.dst_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dma_spr_desc.next= 0x0;
+		G_fio_dma_spr_desc.rpt_addr = (uintptr_t)&G_fio_dma_spr_desc.rpt;
+		G_fio_dma_spr_desc.xfrcnt = size;
+		G_fio_dma_spr_desc.rpt = 0x0;
+	} else {
+		/* Setup DMA descriptor */
+		G_fio_dmadesc.src_addr = (uintptr_t)buf;
+		G_fio_dmadesc.dst_addr = (uintptr_t)FIO_FIFO_BASE;
+		G_fio_dmadesc.next= 0x0;
+		G_fio_dmadesc.rpt_addr = (uintptr_t)&G_fio_dmadesc.rpt;
+		G_fio_dmadesc.xfrcnt = size;
+		mlen = 0;
+	}
+
+	G_fio_dmadesc.ctrl =
+		FDMA_DESC_RM	|
+		FDMA_DESC_EOC	|
+		FDMA_DESC_NI	|
+		FDMA_DESC_IE	|
+		FDMA_DESC_ST	|
+		FDMA_DESC_SP_BURST_SIZE;
+	G_fio_dmadesc.rpt = 0x0;
+
+	_clean_d_cache();
+
+	/* Diable write protect */
+	//gpio_set(FL_WP);
+
+	if (flnand.ecc_bits > 1) {
+		nand_dis_bch();
+
+		/* Setup Flash IO Control Register */
+		writel(FIO_CTR_REG, FIO_CTR_RS);
+		/* Setup Flash Control Register*/
+		writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE);
+		/* Clean Flash_IO_ecc_rpt_status Register */
+		writel(FIO_ECC_RPT_STA_REG, 0x0);
+	} else {
+		/* Setup Flash IO Control Register */
+		writel(FIO_CTR_REG, FIO_CTR_RS);
+		/* Setup Flash Control Register */
+		writel(NAND_CTR_REG, flnand.control | NAND_CTR_SE  | NAND_CTR_SA);
+	}
+
+	/* Setup main external DMA engine descriptor address */
+	writel(FDMA_CHAN_DA_REG, (uintptr_t)&G_fio_dmadesc);
+	writel(FDMA_CHAN_STA_REG, 0);
+
+	if (flnand.ecc_bits > 1) {
+		writel(FDMA_CHAN_SPR_STA_REG, 0);
+		/* Setup spare external DMA engine descriptor address */
+		writel(FDMA_CHAN_SPR_DA_REG, (uintptr_t)&G_fio_dma_spr_desc);
+	}
+	writel(FDMA_CHAN_CTR_REG,   FDMA_CHAN_CTR_D |   FDMA_CHAN_CTR_EN);
+
+	/* Write start address for memory target to */
+	/* FIO DMA Address Register. */
+	addr =  addr_from_block_page(block, page);
+	writel(FIO_DMAADR_REG, addr);
+
+	/* Setup the Flash IO DMA Control Register */
+	writel(FIO_DMACTR_REG,
+	       FIO_DMACTR_EN		|
+	       FIO_DMACTR_RM		|
+	       FIO_DMACTR_FL		|
+	       FIO_DMACTR_BLK_16B |
+	       FIO_DMACTR_TS8B	|
+	       (mlen + size));
+
+	/* Wait for interrupt for NAND operation done and DMA done */
+	nand_wait_desc_dma_done();
+	status = readl(FIO_DMASTA_REG);
+
+	writel(NAND_INT_REG, 0x0);
+	writel(FIO_DMASTA_REG, 0x0);
+	writel(FDMA_REG(DMA_INT_OFFSET), 0x0);
+	writel(FDMA_CHAN_STA_REG, 0x0);
+
+	/* Enable write protect */
+	//gpio_clr(FL_WP);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STA_REG);
+
+	return (status & 0x1) ? -1 : 0;
+}
+
+/**
+ * Erase a NAND flash block.
+ */
+int nand_erase_block(u32 block)
+{
+	u32 status;
+	u32 addr;
+
+#if defined(DEBUG)
+	putstr("nand_erase_block( ");
+	putdec(block);
+	putstr(" )\r\n");
+#endif
+
+	/* Disable write protect */
+	//gpio_set(FL_WP);
+
+	/* Setup FIO DMA Control Register */
+	writel(FIO_DMACTR_REG, FIO_DMACTR_FL | FIO_DMACTR_TS4B);
+
+	/* Setup Flash IO Control Register */
+	writel(FIO_CTR_REG, FIO_CTR_XD);
+
+	/* Setup Flash Control Register */
+	writel(NAND_CTR_REG, flnand.control);
+
+	/* Erase block */
+	addr = addr_from_block_page(block, 0);
+
+	/* Workround for DSM bug!*/
+	writel(FIO_DMAADR_REG, addr);
+
+	writel(NAND_INT_REG, 0x0);
+	nand_wait_cmd_done(NAND_CMD_ERASE | addr);
+
+	status = readl(FIO_DMASTA_REG);
+	writel(FIO_DMASTA_REG, 0x0);
+
+	/* Enable write protect */
+	//gpio_clr(FL_WP);
+
+	if (status & (FIO_DMASTA_RE | FIO_DMASTA_AE))
+		return -1;
+
+	/* Read Status */
+	nand_wait_cmd_done(NAND_CMD_READSTATUS);
+	status = readl(NAND_STA_REG);
+
+	if ((status & 0x1)) {
+		/* Reset chip */
+		nand_wait_cmd_done(NAND_CMD_RESET);
+		return -1;
+	} else {
+#if defined(CONFIG_NAND_USE_FLASH_BBT)
+		/* If erase success and block is marked as bad in BBT */
+		/* then update BBT. */
+		if (nand_is_bad_block(block))
+			nand_update_bbt(0, block);
+#endif
+		return 0;
+	}
+}
+
diff --git a/src/bld/partition.c b/src/bld/partition.c
index c7d7cd4..a27fdb1 100644
--- a/src/bld/partition.c
+++ b/src/bld/partition.c
@@ -7,12 +7,30 @@
  *    2009/10/06 - [Evan Chen] created file
  *    2014/02/13 - [Anthony Ginger] Amboot V2
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
@@ -20,7 +38,7 @@
 
 /*===========================================================================*/
 static const char *g_part_str[HAS_IMG_PARTS + 1] = {
-	"bst", "bld", "ptb", "spl", "pba",
+	"bst", "bld", "ptb", "atf", "pba",
 	"pri", "sec", "bak", "rmd", "rom",
 	"dsp", "lnx", "swp", "add", "adc",
 	"raw"};
@@ -29,7 +47,7 @@ static u32 g_part_dev[HAS_IMG_PARTS + 1] = {
 	PART_BST_DEV,
 	PART_BLD_DEV,
 	PART_PTB_DEV,
-	PART_SPL_DEV,
+	PART_ATF_DEV,
 	PART_PBA_DEV,
 	PART_PRI_DEV,
 	PART_SEC_DEV,
@@ -50,7 +68,7 @@ void get_part_size(int *part_size)
 	part_size[PART_BST] = AMBOOT_BST_SIZE;
 	part_size[PART_PTB] = AMBOOT_PTB_SIZE;
 	part_size[PART_BLD] = AMBOOT_BLD_SIZE;
-	part_size[PART_SPL] = AMBOOT_SPL_SIZE;
+	part_size[PART_ATF] = AMBOOT_ATF_SIZE;
 	part_size[PART_PBA] = AMBOOT_PBA_SIZE;
 	part_size[PART_PRI] = AMBOOT_PRI_SIZE;
 	part_size[PART_SEC] = AMBOOT_SEC_SIZE;
@@ -66,7 +84,7 @@ void get_part_size(int *part_size)
 
 const char *get_part_str(int part_id)
 {
-	K_ASSERT(part_id <= HAS_IMG_PARTS);
+	BUG_ON(part_id > HAS_IMG_PARTS);
 	return g_part_str[part_id];
 }
 
@@ -83,7 +101,11 @@ u32 set_part_dev(u32 boot_from)
 		dev = PART_DEV_EMMC;
 		break;
 	case RCT_BOOT_FROM_SPINOR:
+#if defined(CONFIG_BOOT_MEDIA_SPINAND)
+		dev = PART_DEV_SPINAND;
+#else
 		dev = PART_DEV_SPINOR;
+#endif
 		break;
 	case RCT_BOOT_FROM_BYPASS:
 	case RCT_BOOT_FROM_USB:
@@ -93,6 +115,8 @@ u32 set_part_dev(u32 boot_from)
 		dev = PART_DEV_EMMC;
 #elif defined(CONFIG_BOOT_MEDIA_SPINOR)
 		dev = PART_DEV_SPINOR;
+#elif defined(CONFIG_BOOT_MEDIA_SPINAND)
+		dev = PART_DEV_SPINAND;
 #else
 		dev = PART_DEV_NAND;
 #endif
@@ -112,7 +136,7 @@ u32 set_part_dev(u32 boot_from)
 
 u32 get_part_dev(u32 part_id)
 {
-	K_ASSERT(part_id <= HAS_IMG_PARTS);
+	BUG_ON(part_id > HAS_IMG_PARTS);
 	return g_part_dev[part_id];
 }
 
diff --git a/src/bld/peripheral/crypto_chip.h b/src/bld/peripheral/crypto_chip.h
index 43c322c..77a62f3 100644
--- a/src/bld/peripheral/crypto_chip.h
+++ b/src/bld/peripheral/crypto_chip.h
@@ -1,17 +1,34 @@
-/*
+/*******************************************************************************
  * crypto_chip.h
  *
  * History:
- *	2015/06/19 - [Zhi He] Created file
+ *  2015/06/19 - [Zhi He] Created file
  *
- * Copyright (C) 2015 - 2025, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #ifndef __CRYPTO_CHIP_H__
 #define __CRYPTO_CHIP_H__
diff --git a/src/bld/peripheral/isl12022m.c b/src/bld/peripheral/isl12022m.c
new file mode 100644
index 0000000..48c63d2
--- /dev/null
+++ b/src/bld/peripheral/isl12022m.c
@@ -0,0 +1,54 @@
+/**
+ * isl12022m.c
+ *
+ * Author: XianqingZheng <xqzheng@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <ambhw/idc.h>
+#include <peripheral.h>
+
+void isl12022m_init(int i2c_id)
+{
+	u8 isl12022m_addr = 0xde;
+	u8 reg_val;
+	u8 retry = 3;
+
+	/* Disable IRQ */
+	do {
+		idc_bld_write_8_8(i2c_id, isl12022m_addr, 0x08, 0x10);
+		reg_val = idc_bld_read_8_8(i2c_id, isl12022m_addr, 0x08);
+		retry--;
+	} while ((reg_val != 0x10) && retry);
+	if (retry == 0) {
+		putstr("isl12022m[0x8]: 0x");
+		puthex(reg_val);
+		putstr("\r\n");
+	}
+}
+
diff --git a/src/bld/peripheral/library_atsha204.h b/src/bld/peripheral/library_atsha204.h
index cf87ae5..e0c4c7b 100644
--- a/src/bld/peripheral/library_atsha204.h
+++ b/src/bld/peripheral/library_atsha204.h
@@ -1,17 +1,34 @@
-/*
+/*******************************************************************************
  * library_atsha204.h
  *
  * History:
- *	2015/06/23 - [Zhi He] create file for ATSHA204
+ *  2015/06/23 - [Zhi He] create file for ATSHA204
  *
- * Copyright (C) 2015 -2025, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #ifndef __LIBRARY_ATSHA204_H__
 #define __LIBRARY_ATSHA204_H__
@@ -40,7 +57,7 @@ int libatsha204_is_config_zone_locked(void* context);
 int libatsha204_is_otp_data_zone_locked(void* context);
 void libatsha204_get_serial_number(void* context, unsigned char* p_buf);
 
-void* libatsha204_open();
+void* libatsha204_open(unsigned char i2c_index);
 void libatsha204_release(void* context);
 
 #endif
diff --git a/src/bld/peripheral/micrel.c b/src/bld/peripheral/micrel.c
new file mode 100644
index 0000000..c7303c7
--- /dev/null
+++ b/src/bld/peripheral/micrel.c
@@ -0,0 +1,210 @@
+/**
+ * pca953x.c
+ *
+ * Author: XianqingZheng <xqzheng@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <bldfunc.h>
+#include <eth/network.h>
+
+#define BMCR_ANRESTART		0x0200	/* Auto negotiation restart    */
+#define BMCR_ANENABLE		0x1000	/* Enable auto negotiation     */
+
+
+#define MII_KSZPHY_CTRL				0x1F
+#define MII_KSZPHY_INTCS			0x1B
+#define MII_STAT1000				0x0A
+#define MII_KSZ9031RN_MMD_CTRL_REG		0x0D
+#define MII_KSZ9031RN_MMD_REGDATA_REG		0x0E
+
+#define OP_DATA					1
+#define KSZ9031_PS_TO_REG		60
+
+/* Extended registers */
+/* MMD Address 0x0 */
+#define MII_KSZ9031RN_FLP_BURST_TX_LO	3
+#define MII_KSZ9031RN_FLP_BURST_TX_HI	4
+
+/* MMD Address 0x2 */
+#define MII_KSZ9031RN_CONTROL_PAD_SKEW	4
+#define MII_KSZ9031RN_RX_DATA_PAD_SKEW	5
+#define MII_KSZ9031RN_TX_DATA_PAD_SKEW	6
+#define MII_KSZ9031RN_CLK_PAD_SKEW	8
+
+#define KSZ80X1R_CTRL_INT_ACTIVE_HIGH		(1 << 9)
+#define KSZ80X1R_RMII_50MHZ_CLK			(1 << 7)
+
+#define PHY_ID_KSZ8081		0x00221560
+#define PHY_ID_KSZ9031		0x00221620
+
+typedef struct eth_phy_device
+{
+	u32 phy_id;
+	unsigned int phy_id_mask;
+	void (*config_init)(struct bld_eth_dev_s *dev, u8 phy_addr);
+} eth_phy;
+
+extern u16 eth_mii_read(struct bld_eth_dev_s *dev, u8 addr, u8 reg);
+extern void eth_mii_write(struct bld_eth_dev_s *dev, u8 addr, u8 reg, u16 data);
+extern u8 eth_scan_phy_addr(struct bld_eth_dev_s *dev);
+
+void ksz9031_extended_write(struct bld_eth_dev_s *dev, u8 phy_addr,
+				  u8 mode, u32 dev_addr, u32 regnum, u16 val)
+{
+	eth_mii_write(dev, phy_addr, MII_KSZ9031RN_MMD_CTRL_REG, dev_addr);
+	eth_mii_write(dev, phy_addr, MII_KSZ9031RN_MMD_REGDATA_REG, regnum);
+	eth_mii_write(dev, phy_addr, MII_KSZ9031RN_MMD_CTRL_REG, (mode << 14) | dev_addr);
+	eth_mii_write(dev,phy_addr, MII_KSZ9031RN_MMD_REGDATA_REG, val);
+}
+
+ int ksz9031_extended_read(struct bld_eth_dev_s *dev, u8 phy_addr,
+				 u8 mode, u32 dev_addr, u32 regnum)
+{
+	eth_mii_write(dev, phy_addr, MII_KSZ9031RN_MMD_CTRL_REG, dev_addr);
+	eth_mii_write(dev, phy_addr, MII_KSZ9031RN_MMD_REGDATA_REG, regnum);
+	eth_mii_write(dev, phy_addr, MII_KSZ9031RN_MMD_CTRL_REG, (mode << 14) | dev_addr);
+	return eth_mii_read(dev, phy_addr, MII_KSZ9031RN_MMD_REGDATA_REG);
+}
+
+void ksz9031_of_load_skew_values(struct bld_eth_dev_s *dev, u8 phy_addr, u16 reg,
+				u32 field_sz, u8 numfields, u16 *skew)
+{
+	u16 mask, maxval, useless = 0;
+	u16 newval = 0;
+	int i;
+
+	for (i = 0; i < numfields; i++) {
+		if (!skew[i]) {
+			newval = ksz9031_extended_read(dev, phy_addr, OP_DATA, 2, reg);
+			break;
+		}
+	}
+
+	for (i = 0; i < numfields; i++)
+		if (!skew[i])
+			useless++;
+
+	if (useless == numfields)
+		return;
+
+	maxval = (field_sz == 4) ? 0xf : 0x1f;
+	for (i = 0; i < numfields; i++)
+		if (skew[i]) {
+			mask = 0xffff;
+			mask ^= maxval << (field_sz * i);
+			newval = (newval & mask) |
+				(((skew[i] / KSZ9031_PS_TO_REG) & maxval)
+					<< (field_sz * i));
+		}
+
+	return ksz9031_extended_write(dev, phy_addr, OP_DATA, 2, reg, newval);
+}
+
+void ksz80x1_config_init(struct bld_eth_dev_s *dev, u8 phy_addr)
+{
+	u16 phy_reg;
+
+	phy_reg = eth_mii_read(dev, phy_addr, MII_KSZPHY_CTRL);
+	phy_reg |= KSZ80X1R_RMII_50MHZ_CLK;
+	eth_mii_write(dev, phy_addr, MII_KSZPHY_CTRL, phy_reg);
+}
+
+void ksz9031_config_init(struct bld_eth_dev_s *dev, u8 phy_addr)
+{
+	u16 value;
+
+	/* rxc-skew-ps, txc-skew-ps */
+	u16 clk_skew[] = {1320, 0};
+	/* txen-skew-ps, rxdv-skew-ps */
+	u16 control_skew[] = {0, 140};
+	/* rxd0-skew-ps, rxd1-skew-ps, rxd2-skew-ps, rxd3-skew-ps */
+	u16 rx_data_skew[] = {140 , 140 , 140 , 140};
+	/* txd0-skew-ps, txd1-skew-ps, txd2-skew-ps, txd3-skew-ps */
+	u16 tx_data_skew[] = {0 , 0 , 0 , 0};
+
+
+	ksz9031_of_load_skew_values(dev, phy_addr,
+			MII_KSZ9031RN_CLK_PAD_SKEW, 5, 2, clk_skew);
+	ksz9031_of_load_skew_values(dev, phy_addr,
+			MII_KSZ9031RN_CONTROL_PAD_SKEW, 4, 2, control_skew);
+	ksz9031_of_load_skew_values(dev, phy_addr,
+			MII_KSZ9031RN_RX_DATA_PAD_SKEW, 4, 4, rx_data_skew);
+	ksz9031_of_load_skew_values(dev, phy_addr,
+			MII_KSZ9031RN_TX_DATA_PAD_SKEW, 4, 4, tx_data_skew);
+
+	ksz9031_extended_write(dev, phy_addr,
+			OP_DATA, 0, MII_KSZ9031RN_FLP_BURST_TX_HI, 0x0006);
+	ksz9031_extended_write(dev, phy_addr,
+			OP_DATA, 0, MII_KSZ9031RN_FLP_BURST_TX_LO, 0x1A80);
+
+	value = eth_mii_read(dev, phy_addr, 0x00);
+	value |= BMCR_ANENABLE | BMCR_ANRESTART;
+	eth_mii_write(dev, phy_addr, 0x00, value);
+
+	eth_mii_write(dev, phy_addr, 0x09, 0x0300);
+	eth_mii_write(dev, phy_addr, 0x09, 0x1300);
+}
+
+struct eth_phy_device ksphy[] = {
+	{
+		.phy_id 	= PHY_ID_KSZ8081,
+		.phy_id_mask	= 0x00fffff0,
+		.config_init	= ksz80x1_config_init,
+	},
+	{
+		.phy_id 	= PHY_ID_KSZ9031,
+		.phy_id_mask	= 0x00fffff0,
+		.config_init	= ksz9031_config_init,
+	},
+	{}
+
+};
+
+void micrel_phy_init(void *dev) {
+	u8 phy_addr;
+	u16 phy_reg;
+	u32 phy_id;
+	int i;
+
+	phy_addr = eth_scan_phy_addr(dev);
+	phy_reg = eth_mii_read(dev, phy_addr, 0x02);	//PHYSID1
+	phy_id = (phy_reg & 0xffff) << 16;
+	phy_reg = eth_mii_read(dev, phy_addr, 0x03);	//PHYSID2
+	phy_id |= (phy_reg & 0xffff);
+
+	for(i = 0; i < ARRAY_SIZE(ksphy); i++) {
+		if((phy_id & ksphy[i].phy_id_mask) == ksphy[i].phy_id &&
+					ksphy[i].config_init != NULL) {
+			ksphy[i].config_init(dev, phy_addr);
+			break;
+		}
+
+	}
+
+}
+
+
diff --git a/src/bld/peripheral/pca953x.c b/src/bld/peripheral/pca953x.c
new file mode 100644
index 0000000..1087575
--- /dev/null
+++ b/src/bld/peripheral/pca953x.c
@@ -0,0 +1,99 @@
+/**
+ * pca953x.c
+ *
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ * Modify: XianqingZheng <xqzheng@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <ambhw/idc.h>
+#include <peripheral.h>
+
+void pca9539_set_gpio(int i2c_id, u32 id, u32 set)
+{
+	u8 pca9539_adds = 0xE8;
+	u8 pca9539_cfg_adds;
+	u8 pca9539_out_adds;
+	u8 pca9539_shift;
+	u8 reg_val;
+
+	if (id < 8) {
+		pca9539_cfg_adds = 0x06;
+		pca9539_out_adds = 0x02;
+		pca9539_shift = id;
+	} else if (id < 16) {
+		pca9539_cfg_adds = 0x07;
+		pca9539_out_adds = 0x03;
+		pca9539_shift = (id - 8);
+	} else {
+		printf("pca953x: Invalid gpio id %d\n", id);
+		return;
+	}
+
+	reg_val = idc_bld_read_8_8(i2c_id,
+		pca9539_adds, pca9539_cfg_adds);
+	reg_val &= ~(0x1 << pca9539_shift);
+	idc_bld_write_8_8(i2c_id,
+		pca9539_adds, pca9539_cfg_adds, reg_val);
+
+	reg_val = idc_bld_read_8_8(i2c_id,
+		pca9539_adds, pca9539_out_adds);
+	if (set) {
+		reg_val |= (0x1 << pca9539_shift);
+	} else {
+		reg_val &= ~(0x1 << pca9539_shift);
+	}
+	idc_bld_write_8_8(i2c_id,
+		pca9539_adds, pca9539_out_adds, reg_val);
+}
+
+void pca9539_direction_input(int i2c_id, u32 id)
+{
+	u8 pca9539_adds = 0xE8;
+	u8 pca9539_cfg_adds;
+	u8 pca9539_shift;
+	u8 reg_val;
+
+	if (id < 8) {
+		pca9539_cfg_adds = 0x06;
+		pca9539_shift = id;
+	} else if (id < 16) {
+		pca9539_cfg_adds = 0x07;
+		pca9539_shift = (id - 8);
+	} else {
+		printf("pca953x: Invalid gpio id %d\n", id);
+		return;
+	}
+
+	reg_val = idc_bld_read_8_8(i2c_id,
+		pca9539_adds, pca9539_cfg_adds);
+	reg_val |= (0x1 << pca9539_shift);
+	idc_bld_write_8_8(i2c_id,
+		pca9539_adds, pca9539_cfg_adds, reg_val);
+}
+
diff --git a/src/bld/piggy_adc.S b/src/bld/piggy_adc.S
index 2fafa32..2fac610 100644
--- a/src/bld/piggy_adc.S
+++ b/src/bld/piggy_adc.S
@@ -4,12 +4,30 @@
  * History:
  *    2010/12/23 - [Cao Rongrong] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_add.S b/src/bld/piggy_add.S
index b8a5fab..822d44b 100644
--- a/src/bld/piggy_add.S
+++ b/src/bld/piggy_add.S
@@ -4,12 +4,30 @@
  * History:
  *    2010/12/23 - [Cao Rongrong] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_atf.S b/src/bld/piggy_atf.S
new file mode 100644
index 0000000..3ef8072
--- /dev/null
+++ b/src/bld/piggy_atf.S
@@ -0,0 +1,92 @@
+/**
+ * bld/piggy_atf.S
+ *
+ * History:
+ *    2008/11/18 - [Charles Chiou] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <amboot.h>
+#include <fio/firmfl.h>
+
+piggy_atf:
+
+#ifdef VERSION_INFO
+#include xstr(VERSION_INFO)
+#endif
+
+.text
+
+#ifdef INCBIN
+
+#ifdef CRC32
+.word	CRC32
+#else
+#error "CRC32 not defined!"
+#endif
+
+#ifdef FIRM_VER_NUM
+.word	FIRM_VER_NUM
+#else
+.word	0x0
+#endif
+
+#ifdef FIRM_VER_DATE
+.word	FIRM_VER_DATE
+#else
+.word	0x0
+#endif
+
+#ifdef IMG_LEN
+.word	IMG_LEN
+#else
+.word	0x0
+#endif
+
+#ifdef FIRM_MEM_ADDR
+.word	FIRM_MEM_ADDR
+#else
+.word	0x0
+#endif
+
+#ifdef FIRM_FLAG
+.word	FIRM_FLAG
+#else
+.word	0x0
+#endif
+
+.word	PARTHD_MAGIC
+
+.rept 57
+.word	0x0
+.endr
+
+.incbin xstr(INCBIN)
+
+#endif
+
+.end
diff --git a/src/bld/piggy_backup.S b/src/bld/piggy_backup.S
index 0bc5e47..b4a7909 100644
--- a/src/bld/piggy_backup.S
+++ b/src/bld/piggy_backup.S
@@ -4,12 +4,30 @@
  * History:
  *    2008/10/29 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_bld.S b/src/bld/piggy_bld.S
index 6cec780..35a7d1c 100644
--- a/src/bld/piggy_bld.S
+++ b/src/bld/piggy_bld.S
@@ -4,12 +4,30 @@
  * History:
  *    2005/02/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_bst.S b/src/bld/piggy_bst.S
index 8083aa7..4d110d1 100644
--- a/src/bld/piggy_bst.S
+++ b/src/bld/piggy_bst.S
@@ -4,12 +4,30 @@
  * History:
  *    2005/02/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_dsp.S b/src/bld/piggy_dsp.S
index ad6f344..83f41e1 100644
--- a/src/bld/piggy_dsp.S
+++ b/src/bld/piggy_dsp.S
@@ -4,12 +4,30 @@
  * History:
  *    2005/02/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_kernel.S b/src/bld/piggy_kernel.S
index ce5ac2b..2566d4e 100644
--- a/src/bld/piggy_kernel.S
+++ b/src/bld/piggy_kernel.S
@@ -4,12 +4,30 @@
  * History:
  *    2005/02/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_lnx.S b/src/bld/piggy_lnx.S
index e9b1c10..9a9e46a 100644
--- a/src/bld/piggy_lnx.S
+++ b/src/bld/piggy_lnx.S
@@ -4,12 +4,30 @@
  * History:
  *    2009/10/28 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_pba.S b/src/bld/piggy_pba.S
index 3f0eb87..c2f5655 100644
--- a/src/bld/piggy_pba.S
+++ b/src/bld/piggy_pba.S
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/09 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_ramdisk.S b/src/bld/piggy_ramdisk.S
index 68ce844..5128b61 100644
--- a/src/bld/piggy_ramdisk.S
+++ b/src/bld/piggy_ramdisk.S
@@ -4,12 +4,30 @@
  * History:
  *    2005/02/27 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_romfs.S b/src/bld/piggy_romfs.S
index 0eeb490..cb70392 100644
--- a/src/bld/piggy_romfs.S
+++ b/src/bld/piggy_romfs.S
@@ -4,12 +4,30 @@
  * History:
  *    2006/04/23 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_secondary.S b/src/bld/piggy_secondary.S
index 975310e..a804d68 100644
--- a/src/bld/piggy_secondary.S
+++ b/src/bld/piggy_secondary.S
@@ -4,12 +4,30 @@
  * History:
  *    2008/11/18 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/piggy_swp.S b/src/bld/piggy_swp.S
index cdafd0b..fe39361 100644
--- a/src/bld/piggy_swp.S
+++ b/src/bld/piggy_swp.S
@@ -4,12 +4,30 @@
  * History:
  *    2010/12/23 - [Cao Rongrong] created file
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
diff --git a/src/bld/rct.c b/src/bld/rct.c
index 1b49898..b157105 100644
--- a/src/bld/rct.c
+++ b/src/bld/rct.c
@@ -3,19 +3,37 @@
  *
  * Author: Anthony Ginger <hfjiang@ambarella.com>
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
 #include <ambhw/dma.h>
-#include <ambhw/fio.h>
 #include <ambhw/i2s.h>
 #include <ambhw/timer.h>
+#include <ambhw/cortex.h>
 #include <sdmmc.h>
 
 /* ==========================================================================*/
@@ -119,26 +137,16 @@ u32 rct_get_frac_pll_freq(u32 c, u32 f, u32 pres, u32 posts)
 /* ==========================================================================*/
 u32 get_core_bus_freq_hz(void)
 {
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L) || (CHIP_REV == S5L)
 	return (rct_get_integer_pll_freq(readl(PLL_CORE_CTRL_REG), 1, 1) >> 1);
-#elif (CHIP_REV == A7L)
-	return (rct_get_integer_pll_freq(readl(PLL_CORE_CTRL_REG), 1,
-		readl(SCALER_CORE_POST_REG)) >> 1);
 #else
-	return (rct_get_integer_pll_freq(readl(PLL_CORE_CTRL_REG),
-		1, readl(SCALER_CORE_POST_REG)));
+	return rct_get_integer_pll_freq(readl(PLL_CORE_CTRL_REG), 1, 1);
 #endif
 }
 
 u32 get_ahb_bus_freq_hz(void)
 {
-#if (CHIP_REV == A5S) || (CHIP_REV == S2)
-	return (get_core_bus_freq_hz() >> (readl(CORE_CLK_RATIO_1X_REG)^0x1));
-#elif (CHIP_REV == A7L)
-	return (get_core_bus_freq_hz());
-#else
 	return (get_core_bus_freq_hz() >> 1);
-#endif
 }
 
 u32 get_apb_bus_freq_hz(void)
@@ -149,13 +157,8 @@ u32 get_apb_bus_freq_hz(void)
 /* ==========================================================================*/
 u32 get_idsp_freq_hz(void)
 {
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 	return rct_get_integer_pll_freq(readl(PLL_IDSP_CTRL_REG),
 		1, PLL_SCALER_JDIV(readl(SCALER_IDSP_POST_REG)));
-#else
-	return rct_get_integer_pll_freq(readl(PLL_IDSP_CTRL_REG),
-		1, readl(SCALER_IDSP_POST_REG));
-#endif
 }
 
 /* ==========================================================================*/
@@ -165,114 +168,90 @@ u32 get_ddr_freq_hz(void)
 }
 
 /* ==========================================================================*/
-u32 get_arm_bus_freq_hz(void)
-{
-#if (CHIP_REV == A5S) || (CHIP_REV == S2)
-	return rct_get_integer_pll_freq(readl(PLL_IDSP_CTRL_REG),
-		1, readl(SCALER_ARM_ASYNC_REG));
-#else
-	return 0;
-#endif
-}
-
-/* ==========================================================================*/
 u32 get_cortex_freq_hz(void)
 {
-#if (CHIP_REV == A5S)
-	return 0;
-#else
 	return rct_get_frac_pll_freq(readl(PLL_CORTEX_CTRL_REG),
 		readl(PLL_CORTEX_FRAC_REG), 1, 1);
-#endif
 }
 
 u32 get_enet_freq_hz(void)
 {
-#if (CHIP_REV == S2)
-	return (get_cortex_freq_hz() / readl(SCALER_GTX_POST_REG));
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3L)
 	return rct_get_frac_pll_freq(readl(PLL_ENET_CTRL_REG),
 		readl(PLL_ENET_FRAC_REG), 1,
 		PLL_SCALER_JDIV(readl(SCALER_ENET_POST_REG)));
-#elif (CHIP_REV == S2E)
-        if(SDVCO_FOR_GTX_SOURCE && readl(FUNC_MISC_CTRL_REG)){
-                return (rct_get_frac_pll_freq(readl(PLL_SD_CTRL_REG),
-                        readl(PLL_SD_FRAC_REG),1, 1)
-                        / readl(SCALER_GTX_POST_REG));
-        }else{
-	        return (get_cortex_freq_hz() / readl(SCALER_GTX_POST_REG));
-        }
+}
+
+u32 get_nand_freq_hz(void)
+{
+#if defined(CONFIG_NAND_COMBO_CONTROLLER)
+	return rct_get_integer_pll_freq(readl(PLL_NAND_CTRL_REG), 1, 1);
 #else
-	return 0;
+	u32 sys_config = readl(SYS_CONFIG_REG);
+	u32 freq = get_core_bus_freq_hz();
+
+	if (POC_GCLK_CORE_DIV2_MASK && !(sys_config & POC_GCLK_CORE_DIV2_MASK))
+		return freq >> 1;
+	else
+		return freq;
 #endif
 }
 
 /* ==========================================================================*/
-void rct_set_uart_pll(void)
+void rct_set_uart_pll(u32 reg)
 {
-	writel(CG_UART_REG, 0x1);
+	writel(reg, 0x1);
 }
 
-u32 get_uart_freq_hz(void)
+u32 get_uart_freq_hz(u32 reg)
 {
-	return (REF_CLK_FREQ / readl(CG_UART_REG));
+	return (REF_CLK_FREQ / readl(reg));
 }
-
 /* ==========================================================================*/
 u32 rct_timer_tick2ms(u32 s_tck, u32 e_tck)
 {
-#if ((CHIP_REV == A5S) || defined(CONFIG_AMBOOT_RCTTM_USE_SYS_TIMER))
-	return (s_tck - e_tck) / (get_apb_bus_freq_hz() / 1000);
-#else
+#if (RCT_TIMER_INSTANCES >= 1)
 	return (e_tck - s_tck) / (REF_CLK_FREQ / 1000);
-#endif
-}
-
-void rct_timer_enable()
-{
-#if ((CHIP_REV == A5S) || defined(CONFIG_AMBOOT_RCTTM_USE_SYS_TIMER))
-	writel(TIMER_CTR_REG, (readl(TIMER_CTR_REG) | 0x10));
 #else
-	writel(RCT_TIMER_CTRL_REG, 0x0);
-#endif
-}
-
-void rct_timer_disable()
-{
-#if ((CHIP_REV == A5S) || defined(CONFIG_AMBOOT_RCTTM_USE_SYS_TIMER))
-	writel(TIMER_CTR_REG, (readl(TIMER_CTR_REG) & (~0xF0)));
-#else
-	writel(RCT_TIMER_CTRL_REG, 0x1);
+	return (s_tck - e_tck) / (get_apb_bus_freq_hz() / 1000);
 #endif
 }
 
 void rct_timer_reset_count()
 {
-	rct_timer_disable();
-#if ((CHIP_REV == A5S) || defined(CONFIG_AMBOOT_RCTTM_USE_SYS_TIMER))
+	/* reset timer */
+#if (RCT_TIMER_INSTANCES >= 1)
+	writel(RCT_TIMER_CTRL_REG, 0x1);
+#else
+	writel(TIMER_CTR_REG, (readl(TIMER_CTR_REG) & (~0xF0)));
 	writel(TIMER2_STATUS_REG, 0xFFFFFFFF);
 	writel(TIMER2_RELOAD_REG, 0x00000000);
 	writel(TIMER2_MATCH1_REG, 0x00000000);
 	writel(TIMER2_MATCH2_REG, 0x00000000);
 #endif
-	rct_timer_enable();
+
+	/* enable timer */
+#if (RCT_TIMER_INSTANCES >= 1)
+	writel(RCT_TIMER_CTRL_REG, 0x0);
+#else
+	writel(TIMER_CTR_REG, (readl(TIMER_CTR_REG) | 0x10));
+#endif
 }
 
 u32 rct_timer_get_count()
 {
-#if ((CHIP_REV == A5S) || defined(CONFIG_AMBOOT_RCTTM_USE_SYS_TIMER))
-	return rct_timer_tick2ms(0xFFFFFFFF, readl(TIMER2_STATUS_REG));
-#else
+#if (RCT_TIMER_INSTANCES >= 1)
 	return rct_timer_tick2ms(0x00000000, readl(RCT_TIMER_REG));
+#else
+	return rct_timer_tick2ms(0xFFFFFFFF, readl(TIMER2_STATUS_REG));
 #endif
 }
 
 u32 rct_timer_get_tick()
 {
-#if ((CHIP_REV == A5S) || defined(CONFIG_AMBOOT_RCTTM_USE_SYS_TIMER))
-	return readl(TIMER2_STATUS_REG);
-#else
+#if (RCT_TIMER_INSTANCES >= 1)
 	return readl(RCT_TIMER_REG);
+#else
+	return readl(TIMER2_STATUS_REG);
 #endif
 }
 
@@ -288,42 +267,63 @@ void rct_timer_dly_ms(u32 dly_tim)
 	}
 }
 
-u32 rct_timer_get_frequency_div_1000()
+u32 rct_timer2_tick2ms(u32 s_tck, u32 e_tck)
 {
-#if ((CHIP_REV == A5S) || defined(CONFIG_AMBOOT_RCTTM_USE_SYS_TIMER))
-	return (get_apb_bus_freq_hz() / 1000);
+#if (RCT_TIMER_INSTANCES >= 2)
+	return (e_tck - s_tck) / (REF_CLK_FREQ / 1000);
 #else
-	return (REF_CLK_FREQ / 1000);
+	return (s_tck - e_tck) / (get_apb_bus_freq_hz() / 1000);
 #endif
 }
 
-static u32 rct_timer_get_ticks()
+void rct_timer2_reset_count()
 {
-#if ((CHIP_REV == A5S) || defined(CONFIG_AMBOOT_RCTTM_USE_SYS_TIMER))
-	return readl(TIMER2_STATUS_REG);
+	/* reset timer */
+#if (RCT_TIMER_INSTANCES >= 2)
+	writel(RCT_TIMER2_CTRL_REG, 0x1);
 #else
-	return readl(RCT_TIMER_REG);
+	writel(TIMER_CTR_REG, (readl(TIMER_CTR_REG) & (~0xF00)));
+	writel(TIMER3_STATUS_REG, 0xFFFFFFFF);
+	writel(TIMER3_RELOAD_REG, 0x00000000);
+	writel(TIMER3_MATCH1_REG, 0x00000000);
+	writel(TIMER3_MATCH2_REG, 0x00000000);
+#endif
+
+	/* enable timer */
+#if (RCT_TIMER_INSTANCES >= 2)
+	writel(RCT_TIMER2_CTRL_REG, 0x0);
+#else
+	writel(TIMER_CTR_REG, (readl(TIMER_CTR_REG) | 0x100));
+#endif
+}
+
+u32 rct_timer2_get_count()
+{
+#if (RCT_TIMER_INSTANCES >= 2)
+	return rct_timer2_tick2ms(0x00000000, readl(RCT_TIMER2_REG));
+#else
+	return rct_timer2_tick2ms(0xFFFFFFFF, readl(TIMER3_STATUS_REG));
 #endif
 }
 
-void rct_timer_delay_ticks(u32 ticks)
+u32 rct_timer2_get_tick()
 {
-	u32 begin_time = rct_timer_get_ticks();
-	u32 end_time = begin_time + ticks;
-	u32 cur_time = 0;
+#if (RCT_TIMER_INSTANCES >= 2)
+	return readl(RCT_TIMER2_REG);
+#else
+	return readl(TIMER3_STATUS_REG);
+#endif
+}
 
-	if (end_time > begin_time) {
-		while (1) {
-			cur_time = rct_timer_get_ticks();
-			if (cur_time > end_time)
-				break;
-		}
-	} else {
-		while (1) {
-			cur_time = rct_timer_get_ticks();
-			if ((cur_time > end_time) && (cur_time < begin_time))
-				break;
-		}
+void rct_timer2_dly_ms(u32 dly_tim)
+{
+	u32 cur_tim;
+
+	rct_timer2_reset_count();
+	while (1) {
+		cur_tim = rct_timer2_get_count();
+		if (cur_tim >= dly_tim)
+			break;
 	}
 }
 
@@ -340,13 +340,9 @@ void rct_timer_delay_ticks(u32 ticks)
  */
 void rct_enable_usb(void)
 {
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
 	writel(ANA_PWR_REG, readl(ANA_PWR_REG) | 0x3006);
-#else
-	writel(ANA_PWR_REG, readl(ANA_PWR_REG) | 0x6);
-#endif
 
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+#if (USBP0_FORCE_TO_DEVICE == 1)
 	/* force to set USBPHY0 as device */
 	writel(USBP0_SEL_REG, readl(USBP0_SEL_REG) | 0x3);
 #endif
@@ -354,11 +350,7 @@ void rct_enable_usb(void)
 
 void rct_suspend_usb(void)
 {
-#if (CHIP_REV == S2L) || (CHIP_REV == S3)
 	writel(ANA_PWR_REG, readl(ANA_PWR_REG) & ~0x3006);
-#else
-	writel(ANA_PWR_REG, readl(ANA_PWR_REG) & ~0x6);
-#endif
 }
 
 void rct_usb_reset(void)
@@ -434,13 +426,7 @@ u32 rct_is_eth_enabled(void)
 {
 	u32 sys_config = readl(SYS_CONFIG_REG);
 
-#if (CHIP_REV == S2) || (CHIP_REV == S2E)
-	return ((sys_config & 0x00800000) != 0x0);
-#elif (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
-	return ((sys_config & 0x00000001) != 0x0);
-#else
-	return ((sys_config & 0x00000080) != 0x0);
-#endif
+	return !!(sys_config & POC_ETH_IS_ENABLED);
 }
 
 u32 rct_get_nand_poc(void)
@@ -451,6 +437,7 @@ u32 rct_get_nand_poc(void)
 	if (sysconfig & SYS_CONFIG_NAND_ECC_BCH_EN) {
 		ret_val |= RCT_BOOT_NAND_ECC_BCH_EN;
 	}
+
 	if (sysconfig & SYS_CONFIG_NAND_ECC_SPARE_2X) {
 		ret_val |= RCT_BOOT_NAND_ECC_SPARE_2X;
 	}
@@ -458,6 +445,7 @@ u32 rct_get_nand_poc(void)
 	if (sysconfig & SYS_CONFIG_NAND_PAGE_SIZE) {
 		ret_val |= RCT_BOOT_NAND_PAGE_SIZE;
 	}
+
 	if (sysconfig & SYS_CONFIG_NAND_READ_CONFIRM) {
 		ret_val |= RCT_BOOT_NAND_READ_CONFIRM;
 	}
@@ -489,6 +477,38 @@ u32 rct_get_emmc_poc(void)
 /* ==========================================================================*/
 void rct_pll_init(void)
 {
+#if (CHIP_REV == S5L)
+	u32 sysconfig = readl(SYS_CONFIG_REG);
+	u32 core_freq = get_core_bus_freq_hz();
+	if (core_freq <= 450000000) {
+		sysconfig |= 0x1 << 20;
+		sysconfig &= ~(0x1 << 30);
+		writel(SYS_CONFIG_REG, sysconfig);
+	}
+#endif
+
+#if (CHIP_REV == S3L) || (CHIP_REV == S5) || (CHIP_REV == S5L) || (CHIP_REV == CV1)
+	writel(ENET_CLK_SRC_SEL_REG, 0x1);
+	setbitsl(AHB_MISC_REG, 0x20); /* output enet clk */
+#endif
+
+	/*init pll for pll_out_sd*/
+#if (CHIP_REV == S2L)
+	writel(PLL_SD_CTRL_REG, 0x18000000);//pll_out_sd 600M
+	writel(SCALER_SD48_REG, 0x0c);//sd 50M
+	writel(SCALER_SDIO_REG, 0x0c);//sdio 50M
+#else
+	writel(PLL_SD_CTRL_REG, 0x31100000);//pll_out_sd 1200M
+	writel(SCALER_SD48_REG, 0x18);//sd 50M
+	writel(SCALER_SDXC_REG, 0x18);//sdxc 50M
+
+#endif
+
+#if (CHIP_REV == CV1)
+	writel(RCT_REG(0x0bc), 0x0);	//clk_si input
+	writel(RCT_REG(0x744), 0x14);	//display b clk sel
+#endif
+
 }
 
 void rct_reset_chip(void)
@@ -526,27 +546,13 @@ void rct_reset_fio(void)
 	for (c = 0; c < 0xffff; c++);
 }
 
-void fio_exit_random_mode(void)
-{
-	u32 fio_ctr;
-
-	/* Exit random read mode */
-	fio_ctr = readl(FIO_CTR_REG);
-	fio_ctr &= (~FIO_CTR_RR);
-	writel(FIO_CTR_REG, fio_ctr);
-}
-
 /* ==========================================================================*/
 void rct_set_sd_pll(u32 freq_hz)
 {
 	u32 parent_rate, divider, post_scaler;
 	u32 max_divider  = (1 << 16) - 1;
 
-#if (CHIP_REV == A5S) || (CHIP_REV == S2)
-	parent_rate = rct_get_integer_pll_freq(readl(PLL_CORE_CTRL_REG), 1, 1);
-#else
 	parent_rate = rct_get_integer_pll_freq(readl(PLL_SD_CTRL_REG), 1, 1);
-#endif
 	divider = (parent_rate + freq_hz - 1) / freq_hz ;
 
 	if(divider > max_divider)
@@ -559,27 +565,18 @@ void rct_set_sd_pll(u32 freq_hz)
 
 u32 get_sd_freq_hz(void)
 {
-#if (CHIP_REV == A5S) || (CHIP_REV == S2)
-	return rct_get_integer_pll_freq(readl(PLL_CORE_CTRL_REG),
-		1, readl(SCALER_SD48_REG));
-#else
 	return rct_get_integer_pll_freq(readl(PLL_SD_CTRL_REG),
 		1, readl(SCALER_SD48_REG));
-#endif
 }
 
 void rct_set_sdio_pll(u32 freq_hz)
 {
+#if (SD_SUPPORT_SDIO == 1)
 	u32 divider, post_scaler;
 	unsigned long parent_rate;
 	u32 max_divider  = (1 << 16) - 1;
 
-#if (CHIP_REV == A5S) || (CHIP_REV == S2)
-	parent_rate = rct_get_integer_pll_freq(readl(PLL_CORE_CTRL_REG), 1, 1);
-#else
 	parent_rate = rct_get_integer_pll_freq(readl(PLL_SD_CTRL_REG), 1, 1);
-#endif
-
 	divider = (parent_rate + freq_hz - 1) / freq_hz ;
 
 	if(divider > max_divider)
@@ -587,33 +584,27 @@ void rct_set_sdio_pll(u32 freq_hz)
 
 	post_scaler = divider;
 	writel(SCALER_SDIO_REG, post_scaler);
+#endif
 }
 
 u32 get_sdio_freq_hz(void)
 {
-#if (CHIP_REV == A5S) || (CHIP_REV == S2)
-	return rct_get_integer_pll_freq(readl(PLL_CORE_CTRL_REG),
-		1, readl(SCALER_SDIO_REG));
-#elif (CHIP_REV == S3L)
-	return 0;
-#else
+#if (SD_SUPPORT_SDIO == 1)
 	return rct_get_integer_pll_freq(readl(PLL_SD_CTRL_REG),
 		1, readl(SCALER_SDIO_REG));
+#else
+	return 0;
 #endif
 }
 
 void rct_set_sdxc_pll(u32 freq_hz)
 {
+#if (SD_SUPPORT_SDXC == 1)
 	u32 divider, post_scaler;
 	unsigned long parent_rate;
 	u32 max_divider  = (1 << 16) - 1;
 
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
 	parent_rate = rct_get_integer_pll_freq(readl(PLL_SD_CTRL_REG), 1, 1);
-#else
-	parent_rate = rct_get_integer_pll_freq(readl(PLL_CORE_CTRL_REG), 1, 1);
-#endif
-
 	divider = (parent_rate + freq_hz - 1) / freq_hz ;
 
 	if(divider > max_divider)
@@ -621,11 +612,12 @@ void rct_set_sdxc_pll(u32 freq_hz)
 
 	post_scaler = divider;
 	writel(SCALER_SDXC_REG, post_scaler);
+#endif
 }
 
 u32 get_sdxc_freq_hz(void)
 {
-#if (CHIP_REV == S2L) || (CHIP_REV == S3) || (CHIP_REV == S3L)
+#if (SD_SUPPORT_SDXC == 1)
 	return rct_get_integer_pll_freq(readl(PLL_SD_CTRL_REG),
 		1, readl(SCALER_SDXC_REG));
 #else
@@ -643,9 +635,13 @@ void rct_set_ir_pll(void)
 /* ==========================================================================*/
 void rct_set_ssi_pll(void)
 {
-#if (CHIP_REV == S2L) || (CHIP_REV == S3L)
-	writel(CLK_REF_SSI_REG,0x1);  /* use core_2x as reference clock */
-	writel(CG_SSI_REG, 2); /* use the same frequency as core clock */
+	/* use the same frequency as core clock */
+#if (CHIP_REV == S2L) || (CHIP_REV == S3L) || (CHIP_REV == S5L)
+	writel(CLK_REF_SSI_REG, 0x1);
+	writel(CG_SSI_REG, 2);
+#elif (CHIP_REV == S5) || (CHIP_REV == CV1)
+	writel(CLK_REF_SSI_REG, 0x1);
+	writel(CG_SSI_REG, 1);
 #endif
 }
 
@@ -659,20 +655,15 @@ u32 get_ssi_freq_hz(void)
 
 	if (val == 0)
 		val = 1;
-#if (CHIP_REV == S2L) || (CHIP_REV == S3L)
+
 	return (get_core_bus_freq_hz() << 1) / val;
-#else
-	return 0;
-#endif
 }
 
 u32 get_ssi2_freq_hz(void)
 {
 	return 0;
 }
-#if (CHIP_REV == S2L)
-#define PLL_OUT_ENET	300000000
-#endif
+
 u32 get_ssi3_freq_hz(void)
 {
 	u32 val;
@@ -683,22 +674,15 @@ u32 get_ssi3_freq_hz(void)
 
 	if (val == 0)
 		val = 1;
-#if (CHIP_REV == S2L)
-	return (PLL_OUT_ENET) / val;
-#else
-	return (get_core_bus_freq_hz() << 1) / val;
-#endif
+
+	return rct_get_frac_pll_freq(readl(PLL_ENET_CTRL_REG),
+		readl(PLL_ENET_FRAC_REG), 1, 1) / val;
 }
 
 void rct_set_ssi3_pll(void)
 {
-#if (CHIP_REV == S2L) || (CHIP_REV == S3L)
-	writel(CLK_REF_SSI3_REG,0x0);  /* use pll_out_enet as reference clock */
-	writel(CG_SSI3_REG, 2); /* use pll_out_enet/2 as spi nor reference clock */
-#else
-	writel(CLK_REF_SSI3_REG,0x1);  /* use core_2x as reference clock */
-	writel(CG_SSI3_REG, 2); /* use the same frequency as core clock */
-#endif
+	writel(CLK_REF_SSI3_REG,0x0);	/* use pll_out_enet as reference clock */
+	writel(CG_SSI3_REG, 2);		/* use pll_out_enet/2 as spi nor reference clock */
 }
 
 /* ==========================================================================*/
@@ -787,12 +771,6 @@ void rct_show_pll(void)
 		putdec(pll_freq / 1000);
 		putstr("000\r\n");
 	}
-	pll_freq = get_arm_bus_freq_hz();
-	if (pll_freq) {
-		putstr("ARM freq: ");
-		putdec(pll_freq / 1000);
-		putstr("000\r\n");
-	}
 	putstr("iDSP freq: ");
 	putdec(get_idsp_freq_hz());
 	putstr("\r\n");
@@ -811,8 +789,8 @@ void rct_show_pll(void)
 	putstr("APB freq: ");
 	putdec(get_apb_bus_freq_hz());
 	putstr("\r\n");
-	putstr("UART freq: ");
-	putdec(get_uart_freq_hz());
+	putstr("UART0 freq: ");
+	putdec(get_uart_freq_hz(CG_UART_REG));
 	putstr("\r\n");
 	pll_freq = get_sd_freq_hz();
 	if (pll_freq) {
@@ -854,6 +832,8 @@ static void rct_show_nand_boot(void)
 		} else {
 			putstr(" 6bit");
 		}
+	} else {
+		putstr(" ECC 1-bit");
 	}
 }
 
@@ -901,7 +881,11 @@ void rct_show_boot_from(u32 boot_from)
 		putstr("USB");
 		break;
 	case RCT_BOOT_FROM_SPINOR:
+#if defined(CONFIG_BOOT_MEDIA_SPINAND)
+		putstr("SPI NAND");
+#else
 		putstr("SPI NOR");
+#endif
 		break;
 	default:
 		putstr("Unknown");
@@ -931,10 +915,10 @@ void dma_channel_select(void)
 			val |= SSI1_RX_DMA_REQ_IDX << (i * 4);
 			break;
 		case UART_TX_DMA_CHAN:
-			val |= UART_TX_DMA_REQ_IDX << (i * 4);
+			val |= UART1_TX_DMA_REQ_IDX << (i * 4);
 			break;
 		case UART_RX_DMA_CHAN:
-			val |= UART_RX_DMA_REQ_IDX << (i * 4);
+			val |= UART1_RX_DMA_REQ_IDX << (i * 4);
 			break;
 		case I2S_RX_DMA_CHAN:
 			val |= I2S_RX_DMA_REQ_IDX << (i * 4);
@@ -944,7 +928,12 @@ void dma_channel_select(void)
 			break;
 		}
 	}
-	writel(AHBSP_DMA_CHANNEL_SEL_REG, val);
+	writel(AHBSP_DMA0_SEL0_REG, val);
 #endif
 }
 
+void rct_power_off(void)
+{
+	setbitsl(ANA_PWR_REG, ANA_PWR_POWER_DOWN);
+}
+
diff --git a/src/bld/sdmmc.c b/src/bld/sdmmc.c
index 103f551..ba4e9a8 100644
--- a/src/bld/sdmmc.c
+++ b/src/bld/sdmmc.c
@@ -5,21 +5,49 @@
  *    2008/05/23 - [Dragon Chiang] created file
  *    2015/04/20 - [Cao Rongrong] rewrite the codes
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
 #include <ambhw/cache.h>
 #include <ambhw/gpio.h>
-#include <ambhw/fio.h>
 #include <ambhw/sd.h>
 #include <sdmmc.h>
 
+static const char tuning_block_pattern[] = {
+	0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,
+	0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,
+	0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,
+	0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,
+	0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,
+	0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,
+	0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,
+	0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,
+};
+
 /*===========================================================================*/
 #define sd_putstr(s) do {if (sdmmc.verbose) putstr(s);} while(0)
 #define sd_puthex(h) do {if (sdmmc.verbose) puthex(h);} while(0)
@@ -213,8 +241,17 @@ static void sdmmc_reset_all(u32 slot)
 	/* Wait for reset to complete (busy wait!) */
 	while (readb(sd_base + SD_RESET_OFFSET) != 0x0);
 
+#if defined(CONFIG_EMMC_BOOT_1_8V)
+	/* Set SD Power (1.8V) */
+	writeb((sd_base + SD_PWR_OFFSET), (SD_PWR_1_8V | SD_PWR_ON));
+#else
 	/* Set SD Power (3.3V) */
 	writeb((sd_base + SD_PWR_OFFSET), (SD_PWR_3_3V | SD_PWR_ON));
+#endif
+
+	/* Clr High Speed Mode*/
+	writeb((sd_base + SD_HOST_OFFSET), readb(sd_base + SD_HOST_OFFSET)
+			& (~SD_HOST_HIGH_SPEED));
 
 	/* Set data timeout */
 	writeb((sd_base + SD_TMO_OFFSET), 0xe);
@@ -387,7 +424,7 @@ static int sdmmc_command_with_data(int command, int argument, void *buf, int siz
 	/* wait DAT line ready */
 	while ((readl(sd_base + SD_STA_OFFSET) & SD_STA_CMD_INHIBIT_DAT));
 
-	writel((sd_base + SD_DMA_ADDR_OFFSET), (u32)sdmmc_safe_buf);
+	writel((sd_base + SD_DMA_ADDR_OFFSET), (uintptr_t)sdmmc_safe_buf);
 	writel((sd_base + SD_ARG_OFFSET), argument);
 	writew((sd_base + SD_BLK_SZ_OFFSET), (SD_BLK_SZ_512KB | size));
 	writew((sd_base + SD_BLK_CNT_OFFSET), 0x0);
@@ -428,20 +465,6 @@ sdmmc_send_status_exit:
 	return resp0;
 }
 
-static void sdmmc_fio_select(int slot)
-{
-#if (FIO_INDEPENDENT_SD == 0)
-	if (slot == 1)
-		setbitsl(FIO_CTR_REG, FIO_CTR_XD);
-	else
-		clrbitsl(FIO_CTR_REG, FIO_CTR_XD);
-
-	/* enable SD controller */
-	writel(FIO_DMACTR_REG,
-	       ((readl(FIO_DMACTR_REG) & 0xcfffffff) | FIO_DMACTR_SD));
-#endif
-}
-
 static int mmc_init_partition()
 {
 #if defined(CONFIG_BOOT_MEDIA_EMMC)
@@ -460,6 +483,11 @@ static int mmc_init_partition()
 		ssec += nsec;
 	}
 
+	/*calculate the spare capacity to fill RAW partition*/
+	sdmmc.ssec[PART_RAW] = ssec;
+	sdmmc.nsec[PART_RAW] = (sdmmc.capacity / sdmmc.sector_size) - ssec;
+	i++;
+
 	for (; i < PART_MAX; i++) {
 		sdmmc.ssec[i] = 0;
 		sdmmc.nsec[i] = 0;
@@ -478,6 +506,9 @@ static int sd_switch_to_1v8(int slot)
 	u32 sd_base = SD_BASE(slot);
 	int rval;
 
+	/*delay for some sd card before send cmd11*/
+	rct_timer_dly_ms(25);
+
 	/* CMD11: invoke voltage switch sequence */
 	rval = sdmmc_command(cmd_11, 0x0);
 	if (rval < 0)
@@ -491,9 +522,9 @@ static int sd_switch_to_1v8(int slot)
 	/* Set SD Power (1.8V) */
 	writeb(sd_base + SD_PWR_OFFSET, SD_PWR_1_8V | SD_PWR_ON);
 	amboot_bsp_sd_slot_init(slot, SDMMC_VOLTAGE_1V8);
-	/*sd spec needs 5ms at least, but some cards need more than 10ms
-	 * so we wait for 20ms here for safe. */
-	rct_timer_dly_ms(20);
+	/*sd spec needs 5ms at least, but some cards or borads need more than
+	 * 10ms, so we wait for 100ms here for safe. */
+	rct_timer_dly_ms(100);
 
 	/* enable clock */
 	setbitsw(sd_base + SD_CLK_OFFSET, SD_CLK_EN);
@@ -503,7 +534,7 @@ static int sd_switch_to_1v8(int slot)
 	/*wait switch voltage is completed*/
 	rct_timer_reset_count();
 	while(1) {
-		if(readl(sd_base + SD_STA_OFFSET) & 0x01f00000)
+		if(readl(sd_base + SD_STA_OFFSET) & 0x00f00000)
 			break;
 
 		if (rct_timer_get_count() > 500) {
@@ -639,8 +670,13 @@ static int sdmmc_init_pre(int slot, int verbose)
 	sdmmc.no_1v8 = 0;
 
 	/*power on slot for card*/
-	if(amboot_bsp_sd_slot_init != NULL)
+	if(amboot_bsp_sd_slot_init != NULL) {
+#if defined(CONFIG_EMMC_BOOT_1_8V)
+		amboot_bsp_sd_slot_init(slot, SDMMC_VOLTAGE_1V8);
+#else
 		amboot_bsp_sd_slot_init(slot, SDMMC_VOLTAGE_3V3);
+#endif
+	}
 
 	/* reset PHY to default value */
 	if(amboot_bsp_sd_phy_init != NULL)
@@ -648,9 +684,6 @@ static int sdmmc_init_pre(int slot, int verbose)
 
 	sdmmc_set_pll(slot, 24000000);
 
-	/* configure FIO */
-	sdmmc_fio_select(slot);
-
 	sdmmc_reset_all(slot);
 
 	/* make sure card present */
@@ -695,15 +728,17 @@ static int sdmmc_init_post(int slot, int clock)
 	/* Wait until clock becomes stable */
 	while (!(readw(sd_base + SD_CLK_OFFSET) & SD_CLK_ICLK_STABLE));
 
-	amboot_bsp_sd_phy_init(slot, sdmmc.current_mode);
+	if(amboot_bsp_sd_phy_init != NULL)
+		amboot_bsp_sd_phy_init(slot, sdmmc.current_mode);
 
 	return 0;
 }
 
-int sdmmc_init_mmc(int slot, int mode, int clock, int verbose)
+int sdmmc_init_mmc(int slot, int mode, int clock, int verbose, int emmc_boot)
 {
 	u32 sd_base = SD_BASE(slot);
 	u32 poll_count, resp[4];
+	u32 emmc_poc;
 	int rval;
 
 	rval = sdmmc_init_pre(slot, verbose);
@@ -783,36 +818,60 @@ int sdmmc_init_mmc(int slot, int mode, int clock, int verbose)
 	if (rval < 0)
 		goto emmc_done;
 
-	clock = (clock == -1) ? 48000000 : clock;
+	emmc_poc = rct_get_emmc_poc();
 
-	if (clock > 52000000) {
-		sdmmc_command(cmd_6, 0x03b90201);
-		if (rval < 0)
-			goto emmc_done;
-		sdmmc.current_mode = SDMMC_MODE_HS200;
-	} else if (clock > 26000000) {
-		sdmmc_command(cmd_6, 0x03b90101);
-		if (rval < 0)
-			goto emmc_done;
-		sdmmc.current_mode = SDMMC_MODE_HS;
+	if(emmc_boot) {
+		if (emmc_poc & RCT_BOOT_EMMC_DDR) {
+			putstr("Now Don't Support DDR Mode\r\n");
+		} else if (emmc_poc & RCT_BOOT_EMMC_HS) {
+			clock = 50000000;
+			sdmmc_command(cmd_6, 0x03b90101);
+			if (rval < 0)
+				goto emmc_done;
+			sdmmc.current_mode = SDMMC_MODE_HS;
+		} else {
+			clock = 25000000;
+			sdmmc.current_mode = SDMMC_MODE_DS;
+		}
+
+		if (emmc_poc & RCT_BOOT_EMMC_8BIT) {
+			rval = sdmmc_command(cmd_6, 0x03b70200);
+			if (rval == 0)
+				writeb((sd_base + SD_HOST_OFFSET), SD_HOST_8BIT);
+			else
+				writeb((sd_base + SD_HOST_OFFSET), 0x0);
+		} else if (emmc_poc & RCT_BOOT_EMMC_4BIT) {
+			rval = sdmmc_command(cmd_6, 0x03b70100);
+			if (rval == 0)
+				writeb((sd_base + SD_HOST_OFFSET), SD_HOST_4BIT);
+			else
+				writeb((sd_base + SD_HOST_OFFSET), 0x0);
+		} else {
+			writeb((sd_base + SD_HOST_OFFSET), 0x0);
+		}
 	} else {
-		sdmmc.current_mode = SDMMC_MODE_DS;
+		clock = (clock == -1) ? 50000000 : clock;
+		if (clock > 52000000) {
+			sdmmc_command(cmd_6, 0x03b90201);
+			if (rval < 0)
+				goto emmc_done;
+			sdmmc.current_mode = SDMMC_MODE_HS200;
+		} else if (clock > 26000000) {
+			sdmmc_command(cmd_6, 0x03b90101);
+			if (rval < 0)
+				goto emmc_done;
+			sdmmc.current_mode = SDMMC_MODE_HS;
+		} else {
+			sdmmc.current_mode = SDMMC_MODE_DS;
+		}
+		/*Default 4bit*/
+		rval = sdmmc_command(cmd_6, 0x03b70100);
+		if (rval == 0)
+			writeb((sd_base + SD_HOST_OFFSET), SD_HOST_4BIT);
+		else
+			writeb((sd_base + SD_HOST_OFFSET), 0x0);
 	}
 
-#if defined (ENABLE_MMC_8BIT)
-	rval = sdmmc_command(cmd_6, 0x03b70200);
-	if (rval == 0)
-		writeb((sd_base + SD_HOST_OFFSET), SD_HOST_8BIT);
-	else
-		writeb((sd_base + SD_HOST_OFFSET), 0x0);
-#else
-	rval = sdmmc_command(cmd_6, 0x03b70100);
-	if (rval == 0)
-		writeb((sd_base + SD_HOST_OFFSET), SD_HOST_4BIT);
-	else
-		writeb((sd_base + SD_HOST_OFFSET), 0x0);
-#endif
-
 	rval = sdmmc_init_post(slot, clock);
 	if (rval < 0)
 		goto emmc_done;
@@ -821,7 +880,9 @@ int sdmmc_init_mmc(int slot, int mode, int clock, int verbose)
 	if (rval < 0)
 		goto emmc_done;
 
-	sdmmc.capacity = *(u32 *)(sdmmc_safe_buf + 212); /* sector count */
+	/* calculate the count of sector */
+	sdmmc.capacity = (u32 )sdmmc_safe_buf[212] | (((u32)sdmmc_safe_buf[213]) << 8) |
+		(((u32)sdmmc_safe_buf[214]) << 16) | (((u32)sdmmc_safe_buf[215]) << 24);
 	sdmmc.capacity <<= 9;
 
 	sdmmc.type = SDMMC_TYPE_MMC;
@@ -829,7 +890,7 @@ int sdmmc_init_mmc(int slot, int mode, int clock, int verbose)
 	rval = mmc_init_partition();
 emmc_done:
 	if (rval < 0)
-		putstr("sdmmc init mmc fail!!!\r\n");
+		sd_putstr("sdmmc init mmc fail!!!\r\n");
 
 	return rval;
 }
@@ -1038,7 +1099,7 @@ int sdmmc_init_sd(int slot, int mode, int clock, int verbose)
 	sdmmc.type = SDMMC_TYPE_SD;
 sd_done:
 	if (rval < 0)
-		putstr("sdmmc init sd fail!!!\r\n");
+		sd_putstr("sdmmc init sd fail!!!\r\n");
 
 	return rval;
 }
@@ -1055,8 +1116,8 @@ static int _sdmmc_read_sector_DMA(int sector, int sectors, u8 *target)
 	u32 timout = 0;
 	int rval = 0;
 
-	u32 start_512kb = (u32)target & 0xfff80000;
-	u32 end_512kb = ((u32)target + (sectors << 9) - 1) & 0xfff80000;
+	u32 start_512kb = (uintptr_t)target & 0xfff80000;
+	u32 end_512kb = ((uintptr_t)target + (sectors << 9) - 1) & 0xfff80000;
 
 	if (start_512kb != end_512kb) {
 		putstr("WARNING: crosses 512KB DMA boundary!\r\n");
@@ -1079,7 +1140,7 @@ static int _sdmmc_read_sector_DMA(int sector, int sectors, u8 *target)
 		}
 	}
 
-	writel((sd_base + SD_DMA_ADDR_OFFSET), (u32)target);
+	writel((sd_base + SD_DMA_ADDR_OFFSET), (uintptr_t)target);
 
 	if (sdmmc.sector_mode)			/* argument */
 		writel((sd_base + SD_ARG_OFFSET), sector);
@@ -1142,8 +1203,8 @@ static int sdmmc_read_sector_DMA(int sector, int sectors, u8 *target)
 single_block_read:
 	/* Single-block read */
 
-	s_bound = ((u32) buf_ptr) & 0xfff80000;
-	e_bound = ((u32) buf_ptr) + (sectors << 9) - 1;
+	s_bound = ((uintptr_t) buf_ptr) & 0xfff80000;
+	e_bound = ((uintptr_t) buf_ptr) + (sectors << 9) - 1;
 	e_bound &= 0xfff80000;
 
 	if (s_bound != e_bound) {
@@ -1164,10 +1225,10 @@ multi_block_read:
 	while (s_block < blocks) {
 		/* Check if the first block crosses DMA buffer */
 		/* boundary */
-		s_bound = ((u32) target) + (s_block << 9);
+		s_bound = ((uintptr_t) target) + (s_block << 9);
 		s_bound &= 0xfff80000;
 
-		e_bound = ((u32) target) + ((s_block + 1) << 9) - 1;
+		e_bound = ((uintptr_t) target) + ((s_block + 1) << 9) - 1;
 		e_bound &= 0xfff80000;
 
 		if (s_bound != e_bound) {
@@ -1179,7 +1240,7 @@ multi_block_read:
 			rval = _sdmmc_read_sector_DMA(addr, 1, tmp);
 			if (rval < 0)
 				return rval;
-			memcpy((u32 *)((u32)target + (s_block << 9)), tmp, 512);
+			memcpy((u32 *)((uintptr_t)target + (s_block << 9)), tmp, 512);
 			s_block++;
 
 			if (s_block >= sectors)
@@ -1187,12 +1248,12 @@ multi_block_read:
 		}
 
 		/* Try with maximum data within same boundary */
-		s_bound = ((u32) target) + (s_block << 9);
+		s_bound = ((uintptr_t) target) + (s_block << 9);
 		s_bound &= 0xfff80000;
 		e_block = s_block;
 		do {
 			e_block++;
-			e_bound = ((u32) target) + ((e_block + 1) << 9) - 1;
+			e_bound = ((uintptr_t) target) + ((e_block + 1) << 9) - 1;
 			e_bound &= 0xfff80000;
 		} while (e_block < blocks && s_bound == e_bound);
 		e_block--;
@@ -1201,7 +1262,7 @@ multi_block_read:
 
 		/* Read multiple blocks */
 		rval = _sdmmc_read_sector_DMA(addr, e_block - s_block + 1,
-					(u8 *)((u32)target + (s_block << 9)));
+					(u8 *)((uintptr_t)target + (s_block << 9)));
 		if (rval < 0)
 			return rval;
 
@@ -1215,8 +1276,6 @@ int sdmmc_read_sector(int sector, int sectors, u8 *target)
 {
 	int rval = -1;
 
-	sdmmc_fio_select(sdmmc.slot);
-
 	while (sectors > SDMMC_SEC_CNT) {
 
 		rval = sdmmc_read_sector_DMA(sector, SDMMC_SEC_CNT, target);
@@ -1225,7 +1284,7 @@ int sdmmc_read_sector(int sector, int sectors, u8 *target)
 
 		sector += SDMMC_SEC_CNT;
 		sectors -= SDMMC_SEC_CNT;
-		target += ((SDMMC_SEC_SIZE * SDMMC_SEC_CNT) >> 2);
+		target += (SDMMC_SEC_SIZE * SDMMC_SEC_CNT);
 	}
 
 	rval = sdmmc_read_sector_DMA(sector, sectors, target);
@@ -1262,8 +1321,8 @@ static int _sdmmc_write_sector_DMA(int sector, int sectors, u8 *image)
 	u32 cur_tim = 0, s_tck, e_tck;
 	int rval = 0;
 
-	u32 start_512kb = (u32)image & 0xfff80000;
-	u32 end_512kb = ((u32)image + (sectors << 9) - 1) & 0xfff80000;
+	u32 start_512kb = (uintptr_t)image & 0xfff80000;
+	u32 end_512kb = ((uintptr_t)image + (sectors << 9) - 1) & 0xfff80000;
 
 	if (start_512kb != end_512kb) {
 		putstr("WARNING: crosses 512KB DMA boundary!\r\n");
@@ -1295,7 +1354,7 @@ static int _sdmmc_write_sector_DMA(int sector, int sectors, u8 *image)
 
 	}
 
-	writel((sd_base + SD_DMA_ADDR_OFFSET), (u32)image);
+	writel((sd_base + SD_DMA_ADDR_OFFSET), (uintptr_t)image);
 
 	if (sdmmc.sector_mode)			/* argument */
 		writel((sd_base + SD_ARG_OFFSET), sector);
@@ -1355,8 +1414,8 @@ static int sdmmc_write_sector_DMA(int sector, int sectors, u8 *image)
 single_block_write:
 	/* Single-block write */
 
-	s_bound = ((u32) image) & 0xfff80000;
-	e_bound = ((u32) image) + (sectors << 9) - 1;
+	s_bound = ((uintptr_t) image) & 0xfff80000;
+	e_bound = ((uintptr_t) image) + (sectors << 9) - 1;
 	e_bound &= 0xfff80000;
 
 	rval = sdmmc_set_wr_blk_erase_cnt(1);
@@ -1380,15 +1439,15 @@ multi_block_write:
 	while (s_block < blocks) {
 		/* Check if the first block crosses DMA buffer */
 		/* boundary */
-		s_bound = ((u32) image) + (s_block << 9);
+		s_bound = ((uintptr_t) image) + (s_block << 9);
 		s_bound &= 0xfff80000;
 
-		e_bound = ((u32) image) + ((s_block + 1) << 9) - 1;
+		e_bound = ((uintptr_t) image) + ((s_block + 1) << 9) - 1;
 		e_bound &= 0xfff80000;
 
 		if (s_bound != e_bound) {
 			u8 *tmp = sdmmc_safe_buf;
-			memcpy(tmp, (u32 *)((u32)image + (s_block << 9)), 512);
+			memcpy(tmp, (u32 *)((uintptr_t)image + (s_block << 9)), 512);
 
 			addr = (sector + s_block);
 
@@ -1408,12 +1467,12 @@ multi_block_write:
 		}
 
 		/* Try with maximum data within same boundary */
-		s_bound = ((u32) image) + (s_block << 9);
+		s_bound = ((uintptr_t) image) + (s_block << 9);
 		s_bound &= 0xfff80000;
 		e_block = s_block;
 		do {
 			e_block++;
-			e_bound = ((u32) image) + ((e_block + 1) << 9) - 1;
+			e_bound = ((uintptr_t) image) + ((e_block + 1) << 9) - 1;
 			e_bound &= 0xfff80000;
 		} while (e_block < blocks && s_bound == e_bound);
 		e_block--;
@@ -1427,7 +1486,7 @@ multi_block_write:
 
 		/* Write multiple blocks */
 		rval = _sdmmc_write_sector_DMA(addr, e_block - s_block + 1,
-					(u8 *)((u32)image + (s_block << 9)));
+					(u8 *)((uintptr_t)image + (s_block << 9)));
 		if (rval < 0)
 			return rval;
 
@@ -1441,8 +1500,6 @@ int sdmmc_write_sector(int sector, int sectors, u8 *image)
 {
 	int rval = -1;
 
-	sdmmc_fio_select(sdmmc.slot);
-
 	while (sectors > SDMMC_SEC_CNT) {
 
 		rval = sdmmc_write_sector_DMA(sector, SDMMC_SEC_CNT, image);
@@ -1451,7 +1508,7 @@ int sdmmc_write_sector(int sector, int sectors, u8 *image)
 
 		sector += SDMMC_SEC_CNT;
 		sectors -= SDMMC_SEC_CNT;
-		image += ((SDMMC_SEC_SIZE * SDMMC_SEC_CNT) >> 2);
+		image += (SDMMC_SEC_SIZE * SDMMC_SEC_CNT);
 	}
 
 	rval = sdmmc_write_sector_DMA(sector, sectors, image);
@@ -1459,7 +1516,7 @@ int sdmmc_write_sector(int sector, int sectors, u8 *image)
 	return rval;
 }
 
-int __sdmmc_erase_sector(int sector, int sectors)
+static int __sdmmc_erase_sector(int sector, int sectors)
 {
 	int cmd1, cmd2, rval;
 
@@ -1477,8 +1534,6 @@ int __sdmmc_erase_sector(int sector, int sectors)
 	cmd1 = (sdmmc.type == SDMMC_TYPE_MMC) ? cmd_35 : cmd_32;
 	cmd2 = (sdmmc.type == SDMMC_TYPE_MMC) ? cmd_36 : cmd_33;
 
-	sdmmc_fio_select(sdmmc.slot);
-
 	/* CMD32/35:ERASE_WR_BLK_START */
 	rval = sdmmc_command(cmd1, sector);
 	if (rval < 0)
@@ -1653,3 +1708,29 @@ int sdmmc_set_emmc_normal(void)
 	return ret_val;
 }
 
+int sdmmc_send_tuning(void)
+{
+	char data_buf[64];
+	int ret;
+
+	/* Tuning is only valid for SDR50 and SDR104 mode SD-cards.
+	 * Note that tuning is mandatory for SDR104.
+	 * FIXME: is DDR50 valid ?*/
+	if (sdmmc.current_mode != SDMMC_MODE_SDR50
+			&& sdmmc.current_mode != SDMMC_MODE_SDR104
+			&& sdmmc.current_mode != SDMMC_MODE_DDR50)
+		return 1;
+
+	ret = sdmmc_command_with_data(cmd_19, 0, data_buf, 64);
+	if (ret < 0) {
+		//printf(" %s Tuning execution CMD failed!\n", __func__);
+		return ret;
+	}
+
+	if (memcmp(tuning_block_pattern, data_buf, 64)) {
+		//printf(" %s Tuning execution DATA error !\n");
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/src/bld/secure/aes.c b/src/bld/secure/aes.c
new file mode 100644
index 0000000..5176316
--- /dev/null
+++ b/src/bld/secure/aes.c
@@ -0,0 +1,1236 @@
+/*******************************************************************************
+ * aes.c
+ *
+ * History:
+ *  2017/02/24 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include "cryptography_if.h"
+
+#ifndef DNOT_INCLUDE_C_HEADER
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#else
+#include <bldfunc.h>
+#endif
+
+//precalculated tables from aes_precalc_table.c
+
+static const unsigned char gcsForwardSBox[256] = {
+    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
+};
+
+
+static const unsigned char gcsReverseSBox[256] = {
+    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
+    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
+    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
+    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
+    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
+    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
+    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
+    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
+    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
+    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
+    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
+    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
+    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
+    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
+    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
+    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
+};
+
+
+static const unsigned int gcsForwardTable0[256] = {
+    0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,
+    0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,
+    0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,
+    0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,
+    0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,
+    0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,
+    0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,
+    0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,
+    0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,
+    0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,
+    0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,
+    0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,
+    0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,
+    0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,
+    0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,
+    0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,
+    0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,
+    0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,
+    0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,
+    0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,
+    0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,
+    0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,
+    0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,
+    0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,
+    0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,
+    0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,
+    0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,
+    0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,
+    0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,
+    0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,
+    0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,
+    0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,
+    0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,
+    0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,
+    0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,
+    0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,
+    0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,
+    0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,
+    0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,
+    0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,
+    0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,
+    0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,
+    0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,
+    0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,
+    0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,
+    0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,
+    0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,
+    0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,
+    0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,
+    0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,
+    0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,
+    0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,
+    0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,
+    0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,
+    0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,
+    0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,
+    0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,
+    0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,
+    0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,
+    0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,
+    0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,
+    0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,
+    0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,
+    0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c,
+};
+
+
+static const unsigned int gcsForwardTable1[256] = {
+    0x6363c6a5, 0x7c7cf884, 0x7777ee99, 0x7b7bf68d,
+    0xf2f2ff0d, 0x6b6bd6bd, 0x6f6fdeb1, 0xc5c59154,
+    0x30306050, 0x01010203, 0x6767cea9, 0x2b2b567d,
+    0xfefee719, 0xd7d7b562, 0xabab4de6, 0x7676ec9a,
+    0xcaca8f45, 0x82821f9d, 0xc9c98940, 0x7d7dfa87,
+    0xfafaef15, 0x5959b2eb, 0x47478ec9, 0xf0f0fb0b,
+    0xadad41ec, 0xd4d4b367, 0xa2a25ffd, 0xafaf45ea,
+    0x9c9c23bf, 0xa4a453f7, 0x7272e496, 0xc0c09b5b,
+    0xb7b775c2, 0xfdfde11c, 0x93933dae, 0x26264c6a,
+    0x36366c5a, 0x3f3f7e41, 0xf7f7f502, 0xcccc834f,
+    0x3434685c, 0xa5a551f4, 0xe5e5d134, 0xf1f1f908,
+    0x7171e293, 0xd8d8ab73, 0x31316253, 0x15152a3f,
+    0x0404080c, 0xc7c79552, 0x23234665, 0xc3c39d5e,
+    0x18183028, 0x969637a1, 0x05050a0f, 0x9a9a2fb5,
+    0x07070e09, 0x12122436, 0x80801b9b, 0xe2e2df3d,
+    0xebebcd26, 0x27274e69, 0xb2b27fcd, 0x7575ea9f,
+    0x0909121b, 0x83831d9e, 0x2c2c5874, 0x1a1a342e,
+    0x1b1b362d, 0x6e6edcb2, 0x5a5ab4ee, 0xa0a05bfb,
+    0x5252a4f6, 0x3b3b764d, 0xd6d6b761, 0xb3b37dce,
+    0x2929527b, 0xe3e3dd3e, 0x2f2f5e71, 0x84841397,
+    0x5353a6f5, 0xd1d1b968, 0x00000000, 0xededc12c,
+    0x20204060, 0xfcfce31f, 0xb1b179c8, 0x5b5bb6ed,
+    0x6a6ad4be, 0xcbcb8d46, 0xbebe67d9, 0x3939724b,
+    0x4a4a94de, 0x4c4c98d4, 0x5858b0e8, 0xcfcf854a,
+    0xd0d0bb6b, 0xefefc52a, 0xaaaa4fe5, 0xfbfbed16,
+    0x434386c5, 0x4d4d9ad7, 0x33336655, 0x85851194,
+    0x45458acf, 0xf9f9e910, 0x02020406, 0x7f7ffe81,
+    0x5050a0f0, 0x3c3c7844, 0x9f9f25ba, 0xa8a84be3,
+    0x5151a2f3, 0xa3a35dfe, 0x404080c0, 0x8f8f058a,
+    0x92923fad, 0x9d9d21bc, 0x38387048, 0xf5f5f104,
+    0xbcbc63df, 0xb6b677c1, 0xdadaaf75, 0x21214263,
+    0x10102030, 0xffffe51a, 0xf3f3fd0e, 0xd2d2bf6d,
+    0xcdcd814c, 0x0c0c1814, 0x13132635, 0xececc32f,
+    0x5f5fbee1, 0x979735a2, 0x444488cc, 0x17172e39,
+    0xc4c49357, 0xa7a755f2, 0x7e7efc82, 0x3d3d7a47,
+    0x6464c8ac, 0x5d5dbae7, 0x1919322b, 0x7373e695,
+    0x6060c0a0, 0x81811998, 0x4f4f9ed1, 0xdcdca37f,
+    0x22224466, 0x2a2a547e, 0x90903bab, 0x88880b83,
+    0x46468cca, 0xeeeec729, 0xb8b86bd3, 0x1414283c,
+    0xdedea779, 0x5e5ebce2, 0x0b0b161d, 0xdbdbad76,
+    0xe0e0db3b, 0x32326456, 0x3a3a744e, 0x0a0a141e,
+    0x494992db, 0x06060c0a, 0x2424486c, 0x5c5cb8e4,
+    0xc2c29f5d, 0xd3d3bd6e, 0xacac43ef, 0x6262c4a6,
+    0x919139a8, 0x959531a4, 0xe4e4d337, 0x7979f28b,
+    0xe7e7d532, 0xc8c88b43, 0x37376e59, 0x6d6ddab7,
+    0x8d8d018c, 0xd5d5b164, 0x4e4e9cd2, 0xa9a949e0,
+    0x6c6cd8b4, 0x5656acfa, 0xf4f4f307, 0xeaeacf25,
+    0x6565caaf, 0x7a7af48e, 0xaeae47e9, 0x08081018,
+    0xbaba6fd5, 0x7878f088, 0x25254a6f, 0x2e2e5c72,
+    0x1c1c3824, 0xa6a657f1, 0xb4b473c7, 0xc6c69751,
+    0xe8e8cb23, 0xdddda17c, 0x7474e89c, 0x1f1f3e21,
+    0x4b4b96dd, 0xbdbd61dc, 0x8b8b0d86, 0x8a8a0f85,
+    0x7070e090, 0x3e3e7c42, 0xb5b571c4, 0x6666ccaa,
+    0x484890d8, 0x03030605, 0xf6f6f701, 0x0e0e1c12,
+    0x6161c2a3, 0x35356a5f, 0x5757aef9, 0xb9b969d0,
+    0x86861791, 0xc1c19958, 0x1d1d3a27, 0x9e9e27b9,
+    0xe1e1d938, 0xf8f8eb13, 0x98982bb3, 0x11112233,
+    0x6969d2bb, 0xd9d9a970, 0x8e8e0789, 0x949433a7,
+    0x9b9b2db6, 0x1e1e3c22, 0x87871592, 0xe9e9c920,
+    0xcece8749, 0x5555aaff, 0x28285078, 0xdfdfa57a,
+    0x8c8c038f, 0xa1a159f8, 0x89890980, 0x0d0d1a17,
+    0xbfbf65da, 0xe6e6d731, 0x424284c6, 0x6868d0b8,
+    0x414182c3, 0x999929b0, 0x2d2d5a77, 0x0f0f1e11,
+    0xb0b07bcb, 0x5454a8fc, 0xbbbb6dd6, 0x16162c3a,
+};
+
+
+static const unsigned int gcsForwardTable2[256] = {
+    0x63c6a563, 0x7cf8847c, 0x77ee9977, 0x7bf68d7b,
+    0xf2ff0df2, 0x6bd6bd6b, 0x6fdeb16f, 0xc59154c5,
+    0x30605030, 0x01020301, 0x67cea967, 0x2b567d2b,
+    0xfee719fe, 0xd7b562d7, 0xab4de6ab, 0x76ec9a76,
+    0xca8f45ca, 0x821f9d82, 0xc98940c9, 0x7dfa877d,
+    0xfaef15fa, 0x59b2eb59, 0x478ec947, 0xf0fb0bf0,
+    0xad41ecad, 0xd4b367d4, 0xa25ffda2, 0xaf45eaaf,
+    0x9c23bf9c, 0xa453f7a4, 0x72e49672, 0xc09b5bc0,
+    0xb775c2b7, 0xfde11cfd, 0x933dae93, 0x264c6a26,
+    0x366c5a36, 0x3f7e413f, 0xf7f502f7, 0xcc834fcc,
+    0x34685c34, 0xa551f4a5, 0xe5d134e5, 0xf1f908f1,
+    0x71e29371, 0xd8ab73d8, 0x31625331, 0x152a3f15,
+    0x04080c04, 0xc79552c7, 0x23466523, 0xc39d5ec3,
+    0x18302818, 0x9637a196, 0x050a0f05, 0x9a2fb59a,
+    0x070e0907, 0x12243612, 0x801b9b80, 0xe2df3de2,
+    0xebcd26eb, 0x274e6927, 0xb27fcdb2, 0x75ea9f75,
+    0x09121b09, 0x831d9e83, 0x2c58742c, 0x1a342e1a,
+    0x1b362d1b, 0x6edcb26e, 0x5ab4ee5a, 0xa05bfba0,
+    0x52a4f652, 0x3b764d3b, 0xd6b761d6, 0xb37dceb3,
+    0x29527b29, 0xe3dd3ee3, 0x2f5e712f, 0x84139784,
+    0x53a6f553, 0xd1b968d1, 0x00000000, 0xedc12ced,
+    0x20406020, 0xfce31ffc, 0xb179c8b1, 0x5bb6ed5b,
+    0x6ad4be6a, 0xcb8d46cb, 0xbe67d9be, 0x39724b39,
+    0x4a94de4a, 0x4c98d44c, 0x58b0e858, 0xcf854acf,
+    0xd0bb6bd0, 0xefc52aef, 0xaa4fe5aa, 0xfbed16fb,
+    0x4386c543, 0x4d9ad74d, 0x33665533, 0x85119485,
+    0x458acf45, 0xf9e910f9, 0x02040602, 0x7ffe817f,
+    0x50a0f050, 0x3c78443c, 0x9f25ba9f, 0xa84be3a8,
+    0x51a2f351, 0xa35dfea3, 0x4080c040, 0x8f058a8f,
+    0x923fad92, 0x9d21bc9d, 0x38704838, 0xf5f104f5,
+    0xbc63dfbc, 0xb677c1b6, 0xdaaf75da, 0x21426321,
+    0x10203010, 0xffe51aff, 0xf3fd0ef3, 0xd2bf6dd2,
+    0xcd814ccd, 0x0c18140c, 0x13263513, 0xecc32fec,
+    0x5fbee15f, 0x9735a297, 0x4488cc44, 0x172e3917,
+    0xc49357c4, 0xa755f2a7, 0x7efc827e, 0x3d7a473d,
+    0x64c8ac64, 0x5dbae75d, 0x19322b19, 0x73e69573,
+    0x60c0a060, 0x81199881, 0x4f9ed14f, 0xdca37fdc,
+    0x22446622, 0x2a547e2a, 0x903bab90, 0x880b8388,
+    0x468cca46, 0xeec729ee, 0xb86bd3b8, 0x14283c14,
+    0xdea779de, 0x5ebce25e, 0x0b161d0b, 0xdbad76db,
+    0xe0db3be0, 0x32645632, 0x3a744e3a, 0x0a141e0a,
+    0x4992db49, 0x060c0a06, 0x24486c24, 0x5cb8e45c,
+    0xc29f5dc2, 0xd3bd6ed3, 0xac43efac, 0x62c4a662,
+    0x9139a891, 0x9531a495, 0xe4d337e4, 0x79f28b79,
+    0xe7d532e7, 0xc88b43c8, 0x376e5937, 0x6ddab76d,
+    0x8d018c8d, 0xd5b164d5, 0x4e9cd24e, 0xa949e0a9,
+    0x6cd8b46c, 0x56acfa56, 0xf4f307f4, 0xeacf25ea,
+    0x65caaf65, 0x7af48e7a, 0xae47e9ae, 0x08101808,
+    0xba6fd5ba, 0x78f08878, 0x254a6f25, 0x2e5c722e,
+    0x1c38241c, 0xa657f1a6, 0xb473c7b4, 0xc69751c6,
+    0xe8cb23e8, 0xdda17cdd, 0x74e89c74, 0x1f3e211f,
+    0x4b96dd4b, 0xbd61dcbd, 0x8b0d868b, 0x8a0f858a,
+    0x70e09070, 0x3e7c423e, 0xb571c4b5, 0x66ccaa66,
+    0x4890d848, 0x03060503, 0xf6f701f6, 0x0e1c120e,
+    0x61c2a361, 0x356a5f35, 0x57aef957, 0xb969d0b9,
+    0x86179186, 0xc19958c1, 0x1d3a271d, 0x9e27b99e,
+    0xe1d938e1, 0xf8eb13f8, 0x982bb398, 0x11223311,
+    0x69d2bb69, 0xd9a970d9, 0x8e07898e, 0x9433a794,
+    0x9b2db69b, 0x1e3c221e, 0x87159287, 0xe9c920e9,
+    0xce8749ce, 0x55aaff55, 0x28507828, 0xdfa57adf,
+    0x8c038f8c, 0xa159f8a1, 0x89098089, 0x0d1a170d,
+    0xbf65dabf, 0xe6d731e6, 0x4284c642, 0x68d0b868,
+    0x4182c341, 0x9929b099, 0x2d5a772d, 0x0f1e110f,
+    0xb07bcbb0, 0x54a8fc54, 0xbb6dd6bb, 0x162c3a16,
+};
+
+
+static const unsigned int gcsForwardTable3[256] = {
+    0xc6a56363, 0xf8847c7c, 0xee997777, 0xf68d7b7b,
+    0xff0df2f2, 0xd6bd6b6b, 0xdeb16f6f, 0x9154c5c5,
+    0x60503030, 0x02030101, 0xcea96767, 0x567d2b2b,
+    0xe719fefe, 0xb562d7d7, 0x4de6abab, 0xec9a7676,
+    0x8f45caca, 0x1f9d8282, 0x8940c9c9, 0xfa877d7d,
+    0xef15fafa, 0xb2eb5959, 0x8ec94747, 0xfb0bf0f0,
+    0x41ecadad, 0xb367d4d4, 0x5ffda2a2, 0x45eaafaf,
+    0x23bf9c9c, 0x53f7a4a4, 0xe4967272, 0x9b5bc0c0,
+    0x75c2b7b7, 0xe11cfdfd, 0x3dae9393, 0x4c6a2626,
+    0x6c5a3636, 0x7e413f3f, 0xf502f7f7, 0x834fcccc,
+    0x685c3434, 0x51f4a5a5, 0xd134e5e5, 0xf908f1f1,
+    0xe2937171, 0xab73d8d8, 0x62533131, 0x2a3f1515,
+    0x080c0404, 0x9552c7c7, 0x46652323, 0x9d5ec3c3,
+    0x30281818, 0x37a19696, 0x0a0f0505, 0x2fb59a9a,
+    0x0e090707, 0x24361212, 0x1b9b8080, 0xdf3de2e2,
+    0xcd26ebeb, 0x4e692727, 0x7fcdb2b2, 0xea9f7575,
+    0x121b0909, 0x1d9e8383, 0x58742c2c, 0x342e1a1a,
+    0x362d1b1b, 0xdcb26e6e, 0xb4ee5a5a, 0x5bfba0a0,
+    0xa4f65252, 0x764d3b3b, 0xb761d6d6, 0x7dceb3b3,
+    0x527b2929, 0xdd3ee3e3, 0x5e712f2f, 0x13978484,
+    0xa6f55353, 0xb968d1d1, 0x00000000, 0xc12ceded,
+    0x40602020, 0xe31ffcfc, 0x79c8b1b1, 0xb6ed5b5b,
+    0xd4be6a6a, 0x8d46cbcb, 0x67d9bebe, 0x724b3939,
+    0x94de4a4a, 0x98d44c4c, 0xb0e85858, 0x854acfcf,
+    0xbb6bd0d0, 0xc52aefef, 0x4fe5aaaa, 0xed16fbfb,
+    0x86c54343, 0x9ad74d4d, 0x66553333, 0x11948585,
+    0x8acf4545, 0xe910f9f9, 0x04060202, 0xfe817f7f,
+    0xa0f05050, 0x78443c3c, 0x25ba9f9f, 0x4be3a8a8,
+    0xa2f35151, 0x5dfea3a3, 0x80c04040, 0x058a8f8f,
+    0x3fad9292, 0x21bc9d9d, 0x70483838, 0xf104f5f5,
+    0x63dfbcbc, 0x77c1b6b6, 0xaf75dada, 0x42632121,
+    0x20301010, 0xe51affff, 0xfd0ef3f3, 0xbf6dd2d2,
+    0x814ccdcd, 0x18140c0c, 0x26351313, 0xc32fecec,
+    0xbee15f5f, 0x35a29797, 0x88cc4444, 0x2e391717,
+    0x9357c4c4, 0x55f2a7a7, 0xfc827e7e, 0x7a473d3d,
+    0xc8ac6464, 0xbae75d5d, 0x322b1919, 0xe6957373,
+    0xc0a06060, 0x19988181, 0x9ed14f4f, 0xa37fdcdc,
+    0x44662222, 0x547e2a2a, 0x3bab9090, 0x0b838888,
+    0x8cca4646, 0xc729eeee, 0x6bd3b8b8, 0x283c1414,
+    0xa779dede, 0xbce25e5e, 0x161d0b0b, 0xad76dbdb,
+    0xdb3be0e0, 0x64563232, 0x744e3a3a, 0x141e0a0a,
+    0x92db4949, 0x0c0a0606, 0x486c2424, 0xb8e45c5c,
+    0x9f5dc2c2, 0xbd6ed3d3, 0x43efacac, 0xc4a66262,
+    0x39a89191, 0x31a49595, 0xd337e4e4, 0xf28b7979,
+    0xd532e7e7, 0x8b43c8c8, 0x6e593737, 0xdab76d6d,
+    0x018c8d8d, 0xb164d5d5, 0x9cd24e4e, 0x49e0a9a9,
+    0xd8b46c6c, 0xacfa5656, 0xf307f4f4, 0xcf25eaea,
+    0xcaaf6565, 0xf48e7a7a, 0x47e9aeae, 0x10180808,
+    0x6fd5baba, 0xf0887878, 0x4a6f2525, 0x5c722e2e,
+    0x38241c1c, 0x57f1a6a6, 0x73c7b4b4, 0x9751c6c6,
+    0xcb23e8e8, 0xa17cdddd, 0xe89c7474, 0x3e211f1f,
+    0x96dd4b4b, 0x61dcbdbd, 0x0d868b8b, 0x0f858a8a,
+    0xe0907070, 0x7c423e3e, 0x71c4b5b5, 0xccaa6666,
+    0x90d84848, 0x06050303, 0xf701f6f6, 0x1c120e0e,
+    0xc2a36161, 0x6a5f3535, 0xaef95757, 0x69d0b9b9,
+    0x17918686, 0x9958c1c1, 0x3a271d1d, 0x27b99e9e,
+    0xd938e1e1, 0xeb13f8f8, 0x2bb39898, 0x22331111,
+    0xd2bb6969, 0xa970d9d9, 0x07898e8e, 0x33a79494,
+    0x2db69b9b, 0x3c221e1e, 0x15928787, 0xc920e9e9,
+    0x8749cece, 0xaaff5555, 0x50782828, 0xa57adfdf,
+    0x038f8c8c, 0x59f8a1a1, 0x09808989, 0x1a170d0d,
+    0x65dabfbf, 0xd731e6e6, 0x84c64242, 0xd0b86868,
+    0x82c34141, 0x29b09999, 0x5a772d2d, 0x1e110f0f,
+    0x7bcbb0b0, 0xa8fc5454, 0x6dd6bbbb, 0x2c3a1616,
+};
+
+
+static const unsigned int gcsReverseTable0[256] = {
+    0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a,
+    0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b,
+    0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5,
+    0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5,
+    0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d,
+    0x02752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b,
+    0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295,
+    0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e,
+    0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927,
+    0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d,
+    0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362,
+    0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9,
+    0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52,
+    0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566,
+    0x0728ebb2, 0x03c2b52f, 0x9a7bc586, 0xa50837d3,
+    0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed,
+    0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e,
+    0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4,
+    0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4,
+    0x39ec830b, 0xaaef6040, 0x069f715e, 0x51106ebd,
+    0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d,
+    0xb58d5491, 0x055dc471, 0x6fd40604, 0xff155060,
+    0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967,
+    0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879,
+    0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x00000000,
+    0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c,
+    0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36,
+    0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624,
+    0xb1670a0c, 0x0fe75793, 0xd296eeb4, 0x9e919b1b,
+    0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c,
+    0x0aba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12,
+    0x0b0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14,
+    0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3,
+    0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b,
+    0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8,
+    0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684,
+    0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7,
+    0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177,
+    0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947,
+    0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322,
+    0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498,
+    0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f,
+    0xe49d3a2c, 0x0d927850, 0x9bcc5f6a, 0x62467e54,
+    0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382,
+    0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf,
+    0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb,
+    0x097826cd, 0xf418596e, 0x01b79aec, 0xa89a4f83,
+    0x656e95e6, 0x7ee6ffaa, 0x08cfbc21, 0xe6e815ef,
+    0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029,
+    0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235,
+    0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733,
+    0x4a9804f1, 0xf7daec41, 0x0e50cd7f, 0x2ff69117,
+    0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4,
+    0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546,
+    0x04ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb,
+    0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d,
+    0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb,
+    0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a,
+    0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773,
+    0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478,
+    0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2,
+    0x72c31d16, 0x0c25e2bc, 0x8b493c28, 0x41950dff,
+    0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664,
+    0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0,
+};
+
+
+static const unsigned int gcsReverseTable1[256] = {
+    0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96,
+    0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x03e34b93,
+    0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525,
+    0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f,
+    0x5ab1de49, 0x1bba2567, 0x0eea4598, 0xc0fe5de1,
+    0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6,
+    0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da,
+    0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44,
+    0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd,
+    0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4,
+    0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245,
+    0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994,
+    0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7,
+    0xd373ab23, 0x024b72e2, 0x8f1fe357, 0xab55662a,
+    0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x0837d3a5,
+    0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c,
+    0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1,
+    0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a,
+    0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475,
+    0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51,
+    0x8a213ef9, 0x06dd963d, 0x053eddae, 0xbde64d46,
+    0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff,
+    0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777,
+    0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db,
+    0x0a7ca147, 0x0f427ce9, 0x1e84f8c9, 0x00000000,
+    0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e,
+    0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627,
+    0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a,
+    0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e,
+    0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16,
+    0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d,
+    0x0d090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8,
+    0x19f15785, 0x0775af4c, 0xdd99eebb, 0x607fa3fd,
+    0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34,
+    0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863,
+    0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420,
+    0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d,
+    0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0,
+    0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722,
+    0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef,
+    0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0x0bd49836,
+    0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4,
+    0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462,
+    0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5,
+    0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3,
+    0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b,
+    0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8,
+    0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6,
+    0x9be7bad9, 0x366f4ace, 0x099fead4, 0x7cb029d6,
+    0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0,
+    0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315,
+    0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f,
+    0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x0496e4df,
+    0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f,
+    0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e,
+    0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13,
+    0x61d79a8c, 0x0ca1377a, 0x14f8598e, 0x3c13eb89,
+    0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c,
+    0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf,
+    0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886,
+    0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f,
+    0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41,
+    0x01a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490,
+    0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042,
+};
+
+
+static const unsigned int gcsReverseTable2[256] = {
+    0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e,
+    0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303,
+    0x302055fa, 0x76adf66d, 0xcc889176, 0x02f5254c,
+    0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3,
+    0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0,
+    0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9,
+    0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59,
+    0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8,
+    0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71,
+    0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a,
+    0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f,
+    0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x08f9942b,
+    0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8,
+    0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab,
+    0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508,
+    0x2830f287, 0xbf23b2a5, 0x0302ba6a, 0x16ed5c82,
+    0xcf8a2b1c, 0x79a792b4, 0x07f3f0f2, 0x694ea1e2,
+    0xda65cdf4, 0x0506d5be, 0x34d11f62, 0xa6c48afe,
+    0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb,
+    0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110,
+    0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd,
+    0x5491b58d, 0xc471055d, 0x06046fd4, 0x5060ff15,
+    0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e,
+    0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee,
+    0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x00000000,
+    0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72,
+    0x0efdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739,
+    0x0f0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e,
+    0x0a0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91,
+    0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a,
+    0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17,
+    0x090e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9,
+    0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60,
+    0x01f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e,
+    0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1,
+    0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011,
+    0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1,
+    0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3,
+    0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264,
+    0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90,
+    0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b,
+    0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf,
+    0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246,
+    0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af,
+    0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312,
+    0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb,
+    0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a,
+    0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8,
+    0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c,
+    0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066,
+    0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8,
+    0x04f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6,
+    0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04,
+    0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51,
+    0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0x0bfb2e41,
+    0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347,
+    0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c,
+    0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1,
+    0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37,
+    0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db,
+    0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40,
+    0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0x0dff4195,
+    0xa8397101, 0x0c08deb3, 0xb4d89ce4, 0x566490c1,
+    0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257,
+};
+
+
+static const unsigned int gcsReverseTable3[256] = {
+    0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27,
+    0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3,
+    0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02,
+    0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362,
+    0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe,
+    0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3,
+    0x03e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952,
+    0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9,
+    0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9,
+    0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace,
+    0x63184adf, 0xe582311a, 0x97603351, 0x62457f53,
+    0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08,
+    0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b,
+    0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55,
+    0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837,
+    0x30f28728, 0x23b2a5bf, 0x02ba6a03, 0xed5c8216,
+    0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269,
+    0x65cdf4da, 0x06d5be05, 0xd11f6234, 0xc48afea6,
+    0x349d532e, 0xa2a055f3, 0x0532e18a, 0xa475ebf6,
+    0x0b39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e,
+    0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6,
+    0x91b58d54, 0x71055dc4, 0x046fd406, 0x60ff1550,
+    0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9,
+    0xb0bd42e8, 0x07888b89, 0xe7385b19, 0x79dbeec8,
+    0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x00000000,
+    0x09838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a,
+    0xfdfbff0e, 0x0f563885, 0x3d1ed5ae, 0x3627392d,
+    0x0a64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36,
+    0x0cb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b,
+    0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12,
+    0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b,
+    0x0e0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e,
+    0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f,
+    0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb,
+    0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4,
+    0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6,
+    0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129,
+    0x1d4b2f9e, 0xdcf330b2, 0x0dec5286, 0x77d0e3c1,
+    0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9,
+    0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033,
+    0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4,
+    0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad,
+    0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e,
+    0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3,
+    0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225,
+    0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b,
+    0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f,
+    0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815,
+    0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0,
+    0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2,
+    0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7,
+    0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691,
+    0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496,
+    0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165,
+    0x9d04ea5e, 0x015d358c, 0xfa737487, 0xfb2e410b,
+    0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6,
+    0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13,
+    0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147,
+    0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7,
+    0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44,
+    0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3,
+    0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d,
+    0x397101a8, 0x08deb30c, 0xd89ce4b4, 0x6490c156,
+    0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8,
+};
+
+
+static const unsigned int gcsRoundConstant[10] = {
+    0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010,
+    0x00000020, 0x00000040, 0x00000080, 0x0000001b, 0x00000036,
+};
+
+#define DReadLE32(x, p) \
+{ \
+    x = ((unsigned int) p[0]) \
+        | ((unsigned int) p[1] << 8) \
+        | ((unsigned int) p[2] << 16) \
+        | ((unsigned int) p[3] << 24); \
+}
+
+#define DWriteLE32(x, p) \
+{ \
+    p[0] = (0xff & x); \
+    p[1] = (0xff & (x >> 8)); \
+    p[2] = (0xff & (x >> 16)); \
+    p[3] = (0xff & (x >> 24)); \
+}
+
+static int __aes_set_encrypt_key(unsigned int *p_rk, const unsigned char *key, unsigned int key_length)
+{
+    unsigned int i = 0;
+
+    //read key
+    for (i = 0; i < ( key_length >> 5 ); i++ ) {
+        DReadLE32(p_rk[i], key);
+        key += 4;
+    }
+
+    //generate round keys
+    if (128 == key_length) {
+        for (i = 0; i < 10; i++, p_rk += 4) {
+            p_rk[4]  = p_rk[0] ^ gcsRoundConstant[i] ^
+                ((unsigned int) gcsForwardSBox[(p_rk[3] >>  8) & 0xFF]) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[3] >> 16) & 0xFF] <<  8) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[3] >> 24) & 0xFF] << 16) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[3]) & 0xFF] << 24);
+
+            p_rk[5]  = p_rk[1] ^ p_rk[4];
+            p_rk[6]  = p_rk[2] ^ p_rk[5];
+            p_rk[7]  = p_rk[3] ^ p_rk[6];
+        }
+    } else if (192 == key_length) {
+        for (i = 0; i < 8; i++, p_rk += 6) {
+            p_rk[6] = p_rk[0] ^ gcsRoundConstant[i] ^
+                ((unsigned int) gcsForwardSBox[(p_rk[5] >>  8) & 0xFF]) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[5] >> 16) & 0xFF] <<  8) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[5] >> 24) & 0xFF] << 16) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[5]) & 0xFF] << 24);
+
+            p_rk[7]  = p_rk[1] ^ p_rk[6];
+            p_rk[8]  = p_rk[2] ^ p_rk[7];
+            p_rk[9]  = p_rk[3] ^ p_rk[8];
+            p_rk[10] = p_rk[4] ^ p_rk[9];
+            p_rk[11] = p_rk[5] ^ p_rk[10];
+        }
+    } else if (256 == key_length) {
+        for (i = 0; i < 7; i++, p_rk += 8 ) {
+            p_rk[8]  = p_rk[0] ^ gcsRoundConstant[i] ^
+                ((unsigned int) gcsForwardSBox[(p_rk[7] >>  8) & 0xFF]) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[7] >> 16) & 0xFF] <<  8) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[7] >> 24) & 0xFF] << 16) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[7]) & 0xFF] << 24);
+
+            p_rk[9]  = p_rk[1] ^ p_rk[8];
+            p_rk[10] = p_rk[2] ^ p_rk[9];
+            p_rk[11] = p_rk[3] ^ p_rk[10];
+
+            p_rk[12] = p_rk[4] ^
+                ((unsigned int) gcsForwardSBox[(p_rk[11]) & 0xFF]) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[11] >>  8) & 0xFF] <<  8) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[11] >> 16) & 0xFF] << 16) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[11] >> 24) & 0xFF] << 24);
+
+            p_rk[13] = p_rk[5] ^ p_rk[12];
+            p_rk[14] = p_rk[6] ^ p_rk[13];
+            p_rk[15] = p_rk[7] ^ p_rk[14];
+        }
+    } else {
+        DCRYPT_LOG("error: invalid key_length.. %d\n", key_length);
+        return (-2);
+    }
+
+    return( 0 );
+}
+
+static void __aes_encrypt_block(aes_context_t *ctx, const unsigned char *input, unsigned char *output)
+{
+
+#define D_AES_FORWARD_ROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
+{                                               \
+    X0 = *p_rk++ ^ gcsForwardTable0[(Y0) & 0xFF] ^   \
+         gcsForwardTable1[(Y1 >>  8) & 0xFF] ^   \
+         gcsForwardTable2[(Y2 >> 16) & 0xFF] ^   \
+         gcsForwardTable3[(Y3 >> 24) & 0xFF];    \
+    X1 = *p_rk++ ^ gcsForwardTable0[(Y1) & 0xFF] ^   \
+         gcsForwardTable1[(Y2 >>  8) & 0xFF] ^   \
+         gcsForwardTable2[(Y3 >> 16) & 0xFF] ^   \
+         gcsForwardTable3[(Y0 >> 24) & 0xFF];    \
+    X2 = *p_rk++ ^ gcsForwardTable0[(Y2) & 0xFF] ^   \
+         gcsForwardTable1[(Y3 >>  8) & 0xFF] ^   \
+         gcsForwardTable2[(Y0 >> 16) & 0xFF] ^   \
+         gcsForwardTable3[(Y1 >> 24) & 0xFF];    \
+    X3 = *p_rk++ ^ gcsForwardTable0[(Y3) & 0xFF] ^   \
+         gcsForwardTable1[(Y0 >>  8) & 0xFF] ^   \
+         gcsForwardTable2[(Y1 >> 16) & 0xFF] ^   \
+         gcsForwardTable3[(Y2 >> 24) & 0xFF];    \
+}
+
+    int i;
+    unsigned int *p_rk, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+    p_rk = ctx->p_round_key;
+
+    DReadLE32(X0, input);
+    input += 4;
+    X0 ^= *p_rk++;
+    DReadLE32(X1, input);
+    input += 4;
+    X1 ^= *p_rk++;
+    DReadLE32(X2, input);
+    input += 4;
+    X2 ^= *p_rk++;
+    DReadLE32(X3, input);
+    input += 4;
+    X3 ^= *p_rk++;
+
+    for( i = (ctx->round >> 1) - 1; i > 0; i--) {
+        D_AES_FORWARD_ROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+        D_AES_FORWARD_ROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);
+    }
+
+    D_AES_FORWARD_ROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+
+    X0 = *p_rk++ ^ \
+        ((unsigned int) gcsForwardSBox[(Y0) & 0xFF]) ^
+        ((unsigned int) gcsForwardSBox[(Y1 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsForwardSBox[(Y2 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsForwardSBox[(Y3 >> 24) & 0xFF] << 24);
+
+    X1 = *p_rk++ ^ \
+        ((unsigned int) gcsForwardSBox[(Y1) & 0xFF]) ^
+        ((unsigned int) gcsForwardSBox[(Y2 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsForwardSBox[(Y3 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsForwardSBox[(Y0 >> 24) & 0xFF] << 24);
+
+    X2 = *p_rk++ ^ \
+        ((unsigned int) gcsForwardSBox[(Y2) & 0xFF]) ^
+        ((unsigned int) gcsForwardSBox[(Y3 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsForwardSBox[(Y0 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsForwardSBox[(Y1 >> 24) & 0xFF] << 24);
+
+    X3 = *p_rk++ ^ \
+        ((unsigned int) gcsForwardSBox[(Y3) & 0xFF]) ^
+        ((unsigned int) gcsForwardSBox[(Y0 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsForwardSBox[(Y1 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsForwardSBox[(Y2 >> 24) & 0xFF] << 24);
+
+    DWriteLE32(X0, output);
+    output += 4;
+    DWriteLE32(X1, output);
+    output += 4;
+    DWriteLE32(X2, output);
+    output += 4;
+    DWriteLE32(X3, output);
+
+    return;
+}
+
+static void __aes_decrypt_block(aes_context_t *ctx, const unsigned char *input, unsigned char *output)
+{
+
+#define D_AES_REVERSE_ROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
+{                                               \
+    X0 = *p_rk++ ^ gcsReverseTable0[(Y0) & 0xFF] ^   \
+         gcsReverseTable1[(Y3 >>  8) & 0xFF] ^   \
+         gcsReverseTable2[(Y2 >> 16) & 0xFF] ^   \
+         gcsReverseTable3[(Y1 >> 24) & 0xFF];    \
+    X1 = *p_rk++ ^ gcsReverseTable0[(Y1) & 0xFF] ^   \
+         gcsReverseTable1[(Y0 >>  8) & 0xFF] ^   \
+         gcsReverseTable2[(Y3 >> 16) & 0xFF] ^   \
+         gcsReverseTable3[(Y2 >> 24) & 0xFF];    \
+    X2 = *p_rk++ ^ gcsReverseTable0[(Y2) & 0xFF] ^   \
+         gcsReverseTable1[(Y1 >>  8) & 0xFF] ^   \
+         gcsReverseTable2[(Y0 >> 16) & 0xFF] ^   \
+         gcsReverseTable3[(Y3 >> 24) & 0xFF];    \
+    X3 = *p_rk++ ^ gcsReverseTable0[(Y3) & 0xFF] ^   \
+         gcsReverseTable1[(Y2 >>  8) & 0xFF] ^   \
+         gcsReverseTable2[(Y1 >> 16) & 0xFF] ^   \
+         gcsReverseTable3[(Y0 >> 24) & 0xFF];    \
+}
+
+    int i;
+    unsigned int *p_rk, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+    p_rk = ctx->p_round_key;
+
+    DReadLE32(X0, input);
+    input += 4;
+    X0 ^= *p_rk++;
+    DReadLE32(X1, input);
+    input += 4;
+    X1 ^= *p_rk++;
+    DReadLE32(X2, input);
+    input += 4;
+    X2 ^= *p_rk++;
+    DReadLE32(X3, input);
+    input += 4;
+    X3 ^= *p_rk++;
+
+    for (i = (ctx->round >> 1) - 1; i > 0; i--) {
+        D_AES_REVERSE_ROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+        D_AES_REVERSE_ROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);
+    }
+    D_AES_REVERSE_ROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+
+    X0 = *p_rk++ ^ \
+        ((unsigned int) gcsReverseSBox[(Y0) & 0xFF]) ^
+        ((unsigned int) gcsReverseSBox[(Y3 >>  8 ) & 0xFF] <<  8) ^
+        ((unsigned int) gcsReverseSBox[(Y2 >> 16 ) & 0xFF] << 16) ^
+        ((unsigned int) gcsReverseSBox[(Y1 >> 24 ) & 0xFF] << 24);
+
+    X1 = *p_rk++ ^ \
+        ((unsigned int) gcsReverseSBox[(Y1) & 0xFF]) ^
+        ((unsigned int) gcsReverseSBox[(Y0 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsReverseSBox[(Y3 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsReverseSBox[(Y2 >> 24) & 0xFF] << 24);
+
+    X2 = *p_rk++ ^ \
+        ((unsigned int) gcsReverseSBox[(Y2) & 0xFF]) ^
+        ((unsigned int) gcsReverseSBox[(Y1 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsReverseSBox[(Y0 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsReverseSBox[(Y3 >> 24) & 0xFF] << 24);
+
+    X3 = *p_rk++ ^ \
+        ((unsigned int) gcsReverseSBox[(Y3) & 0xFF]) ^
+        ((unsigned int) gcsReverseSBox[(Y2 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsReverseSBox[(Y1 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsReverseSBox[(Y0 >> 24) & 0xFF] << 24);
+
+    DWriteLE32(X0, output);
+    output += 4;
+    DWriteLE32(X1, output);
+    output += 4;
+    DWriteLE32(X2, output);
+    output += 4;
+    DWriteLE32(X3, output);
+
+    return;
+}
+
+aes_context_t *aes_init()
+{
+    aes_context_t *thiz = (aes_context_t *) malloc(sizeof(aes_context_t));
+    if (thiz) {
+        memset(thiz, 0x0, sizeof(aes_context_t));
+    } else {
+        DCRYPT_LOG("error: no memory\n");
+    }
+    return thiz;
+}
+
+void aes_destroy(aes_context_t *ctx)
+{
+    if (ctx) {
+        free(ctx);
+    }
+}
+
+int aes_set_encrypt_key(aes_context_t *ctx, const unsigned char *key, unsigned int key_length)
+{
+    if ((!ctx) || (!key)) {
+        DCRYPT_LOG("error: null pointer\n");
+        return (-1);
+    }
+
+    if (128 == key_length) {
+        ctx->round = 10;
+    } else if (192 == key_length) {
+        ctx->round = 12;
+    } else if (256 == key_length) {
+        ctx->round = 14;
+    } else {
+        DCRYPT_LOG("error: enc invalid key_length %d\n", key_length);
+        return (-2);
+    }
+
+    return __aes_set_encrypt_key(ctx->p_round_key, key, key_length);
+}
+
+int aes_set_decrypt_key(aes_context_t *ctx, const unsigned char *key, unsigned int key_length)
+{
+    int ret = 0;
+    unsigned int i = 0, j = 0;
+    unsigned int enc_rk[72] = {0};
+    unsigned int *p_rk = NULL;
+    unsigned int *p_enc_rk = NULL;
+
+    if ((!ctx) || (!key)) {
+        DCRYPT_LOG("error: null pointer\n");
+        return (-1);
+    }
+
+    if (128 == key_length) {
+        ctx->round = 10;
+    } else if (192 == key_length) {
+        ctx->round = 12;
+    } else if (256 == key_length) {
+        ctx->round = 14;
+    } else {
+        DCRYPT_LOG("error: dec invalid key_length %d\n", key_length);
+        return (-2);
+    }
+
+    ret = __aes_set_encrypt_key(enc_rk, key, key_length);
+    if (0 > ret) {
+        return ret;
+    }
+
+    p_rk = ctx->p_round_key;
+
+    p_enc_rk = (unsigned int *) enc_rk + ctx->round * 4;
+
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+
+    for (i = ctx->round - 1, p_enc_rk -= 8; i > 0; i--, p_enc_rk -= 8) {
+        for (j = 0; j < 4; j++, p_enc_rk++ ) {
+            *p_rk++ = gcsReverseTable0[gcsForwardSBox[(*p_enc_rk) & 0xFF]] ^
+                gcsReverseTable1[gcsForwardSBox[(*p_enc_rk >>  8) & 0xFF]] ^
+                gcsReverseTable2[gcsForwardSBox[(*p_enc_rk >> 16) & 0xFF]] ^
+                gcsReverseTable3[gcsForwardSBox[(*p_enc_rk >> 24) & 0xFF]];
+        }
+    }
+
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+
+    return 0;
+}
+
+int aes_ecb_encrypt(aes_context_t *ctx, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        __aes_encrypt_block(ctx, input, output);
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+int aes_ecb_decrypt(aes_context_t *ctx, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        __aes_decrypt_block(ctx, input, output);
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+int aes_ctr_crypt(aes_context_t *ctx, unsigned char *p_nonce, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    unsigned int i;
+    unsigned int cur = ctx->cur_position;
+    unsigned char block[16] = {0};
+
+    while (data_length--) {
+        if (!cur) {
+            __aes_encrypt_block(ctx, input, block);
+            for (i = 16; i > 0; i--) {
+                if (++ p_nonce[i - 1] != 0) {
+                    break;
+                }
+            }
+        }
+        *output++ = ((*input++) ^ block[cur]);
+        cur = (cur + 1) & 0x0F;
+    }
+    ctx->cur_position = cur;
+
+    return 0;
+}
+
+int aes_cbc_encrypt(aes_context_t *ctx, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    unsigned int i;
+
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        for (i = 0; i < 16; i++) {
+            output[i] = input[i] ^ iv[i];
+        }
+
+        __aes_encrypt_block(ctx, output, output);
+        memcpy(iv, output, 16);
+
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+int aes_cbc_decrypt(aes_context_t *ctx, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    unsigned int i;
+    unsigned char temp[16] = {0};
+
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        memcpy(temp, input, 16);
+        __aes_decrypt_block(ctx, input, output);
+
+        for (i = 0; i < 16; i++) {
+            output[i] = output[i] ^ iv[i];
+        }
+
+        memcpy(iv, temp, 16);
+
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+
+//one shot api
+
+int aes_ecb_encrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_encrypt_key(thiz, key, key_length);
+    if (ret) {
+        return (-2);
+    }
+
+    aes_ecb_encrypt(thiz, input, output, data_length);
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+int aes_ecb_decrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_decrypt_key(thiz, key, key_length);
+    if (ret) {
+        return (-2);
+    }
+
+    aes_ecb_decrypt(thiz, input, output, data_length);
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+int aes_ctr_crypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *p_nonce, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !p_nonce || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_encrypt_key(thiz, key, key_length);
+    if (ret) {
+        return (-2);
+    }
+
+    aes_ctr_crypt(thiz, p_nonce, input, output, data_length);
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+
+int aes_cbc_encrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !iv || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_encrypt_key(thiz, key, key_length);
+    if (ret) {
+        return ret;
+    }
+
+    ret = aes_cbc_encrypt(thiz, iv, input, output, data_length);
+    if (ret) {
+        return ret;
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+int aes_cbc_decrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !iv || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_decrypt_key(thiz, key, key_length);
+    if (ret) {
+        return ret;
+    }
+
+    ret = aes_cbc_decrypt(thiz, iv, input, output, data_length);
+    if (ret) {
+        return ret;
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+
diff --git a/src/bld/secure/big_number.c b/src/bld/secure/big_number.c
index ecb9ada..dd14015 100644
--- a/src/bld/secure/big_number.c
+++ b/src/bld/secure/big_number.c
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * big_number.c
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include "cryptography_if.h"
 
@@ -20,6 +38,7 @@
 #include <stdlib.h>
 #else
 #include <bldfunc.h>
+typedef unsigned int size_t;
 #endif
 
 #include "big_number.h"
@@ -29,14 +48,18 @@
 #define D_LN_2_DIV_LN_10_SCALE100                 332
 #define D_BIG_NUMBER_RW_BUFFER_SIZE             (((D_BIG_NUMBER_MAX_BITS_SCALE100 + D_LN_2_DIV_LN_10_SCALE100 - 1) / D_LN_2_DIV_LN_10_SCALE100) + 10 + 6)
 
-#define DCHARS_IN_LIMB    (sizeof(unsigned int))
+#define DCHARS_IN_LIMB    (sizeof(TUINT))
 #define DBITS_IN_LIMB    (DCHARS_IN_LIMB << 3)
 #define DHALF_BITS_IN_LIMB    (DCHARS_IN_LIMB << 2)
 
-#define DBITS_TO_LIMBS(i)  (((i) + DBITS_IN_LIMB - 1) / DBITS_IN_LIMB)
-#define DCHARS_TO_LIMBS(i) (((i) + DCHARS_IN_LIMB - 1) / DCHARS_IN_LIMB)
+#define MPI_SIZE_T_MAX  ( (size_t) -1 ) /* SIZE_T_MAX is not standard */
 
-static void __zeroize(void *v, unsigned int n)
+//#define DBITS_TO_LIMBS(i)  (((i) + DBITS_IN_LIMB - 1) / DBITS_IN_LIMB)
+//#define DCHARS_TO_LIMBS(i) (((i) + DCHARS_IN_LIMB - 1) / DCHARS_IN_LIMB)
+#define DBITS_TO_LIMBS(i)  ((i) / DBITS_IN_LIMB + ( (i) % DBITS_IN_LIMB != 0 ))
+#define DCHARS_TO_LIMBS(i) ((i) / DCHARS_IN_LIMB + ( (i) % DCHARS_IN_LIMB != 0 ))
+
+static void __zerosize(void *v, unsigned int n)
 {
     volatile unsigned char *p = v;
 
@@ -73,7 +96,7 @@ void big_number_free(big_number_t* X)
     }
 
     if ( X->p != NULL ) {
-        __zeroize(X->p, X->n * DCHARS_IN_LIMB);
+        __zerosize(X->p, X->n * DCHARS_IN_LIMB);
         free(X->p);
     }
 
@@ -84,7 +107,7 @@ void big_number_free(big_number_t* X)
 
 int big_number_grow(big_number_t* X, unsigned int nblimbs)
 {
-    unsigned int *p;
+    TUINT *p;
 
     if (nblimbs > D_BIG_NUMBER_MAX_LIMBS) {
         return CRYPTO_ECODE_ERROR_NO_MEMORY;
@@ -99,7 +122,7 @@ int big_number_grow(big_number_t* X, unsigned int nblimbs)
 
         if (X->p != NULL) {
             memcpy(p, X->p, X->n * DCHARS_IN_LIMB);
-            __zeroize(X->p, X->n * DCHARS_IN_LIMB);
+            __zerosize(X->p, X->n * DCHARS_IN_LIMB);
             free(X->p);
         }
 
@@ -112,7 +135,7 @@ int big_number_grow(big_number_t* X, unsigned int nblimbs)
 
 int big_number_shrink(big_number_t* X, unsigned int nblimbs)
 {
-    unsigned int *p;
+    TUINT *p;
     unsigned int i;
 
     if (X->n <= nblimbs) {
@@ -138,7 +161,7 @@ int big_number_shrink(big_number_t* X, unsigned int nblimbs)
 
     if (X->p != NULL) {
         memcpy(p, X->p, i * DCHARS_IN_LIMB);
-        __zeroize(X->p, X->n * DCHARS_IN_LIMB);
+        __zerosize(X->p, X->n * DCHARS_IN_LIMB);
         free (X->p);
     }
 
@@ -217,7 +240,7 @@ int big_number_safe_cond_swap(big_number_t *X, big_number_t *Y, unsigned char sw
 {
     int ret, s;
     unsigned int i;
-    unsigned int tmp;
+    TUINT tmp;
 
     if (X == Y) {
         return CRYPTO_ECODE_OK;
@@ -243,7 +266,7 @@ cleanup:
     return ret;
 }
 
-int big_number_lset(big_number_t *X, int z)
+int big_number_lset(big_number_t *X, TSINT z)
 {
     int ret;
 
@@ -285,8 +308,8 @@ int big_number_set_bit( big_number_t *X, unsigned int pos, unsigned char val )
         D_CLEAN_IF_FAILED( big_number_grow(X, off + 1));
     }
 
-    X->p[off] &= ~((unsigned int) 0x01 << idx);
-    X->p[off] |= (unsigned int) val << idx;
+    X->p[off] &= ~((TUINT) 0x01 << idx);
+    X->p[off] |= (TUINT) val << idx;
 
 cleanup:
 
@@ -336,7 +359,7 @@ unsigned int big_number_size(const big_number_t *X)
     return ((big_number_msb(X) + 7) >> 3);
 }
 
-static int big_number_get_digit(unsigned int *d, int radix, char c)
+static int big_number_get_digit(TUINT *d, int radix, char c)
 {
     *d = 255;
 
@@ -352,7 +375,7 @@ static int big_number_get_digit(unsigned int *d, int radix, char c)
         *d = c - 0x57;
     }
 
-    if ( *d >= (unsigned int) radix ) {
+    if ( *d >= (TUINT) radix ) {
         return CRYPTO_ECODE_INVALID_CHARACTER;
     }
 
@@ -363,7 +386,7 @@ int big_number_read_string(big_number_t *X, int radix, const char *s)
 {
     int ret;
     unsigned int i, j, slen, n;
-    unsigned int d;
+    TUINT d;
     big_number_t T;
 
     if (radix < 2 || radix > 16) {
@@ -375,6 +398,9 @@ int big_number_read_string(big_number_t *X, int radix, const char *s)
     slen = strlen(s);
 
     if (radix == 16) {
+        if ( slen > MPI_SIZE_T_MAX >> 2 ) {
+             return( CRYPTO_ECODE_BAD_INPUT_DATA );
+        }
         n = DBITS_TO_LIMBS(slen << 2);
 
         D_CLEAN_IF_FAILED(big_number_grow( X, n));
@@ -419,7 +445,7 @@ cleanup:
 static int big_number_write_hlp(big_number_t *X, int radix, char **p)
 {
     int ret;
-    unsigned int r;
+    TUINT r;
 
     if (radix < 2 || radix > 16) {
         return CRYPTO_ECODE_BAD_INPUT_DATA;
@@ -518,7 +544,7 @@ cleanup:
 #ifndef DNOT_INCLUDE_C_HEADER
 int big_number_read_file(big_number_t* X, int radix, void* f)
 {
-    unsigned int d;
+    TUINT d;
     unsigned int slen;
     char *p;
     FILE* fin = (FILE*) f;
@@ -608,7 +634,7 @@ int big_number_read_binary(big_number_t* X, const unsigned char* buf, unsigned i
     D_CLEAN_IF_FAILED(big_number_lset(X, 0));
 
     for (i = buflen, j = 0; i > n; i--, j++) {
-        X->p[j / DCHARS_IN_LIMB] |= ((unsigned int) buf[i - 1]) << ((j % DCHARS_IN_LIMB) << 3);
+        X->p[j / DCHARS_IN_LIMB] |= ((TUINT) buf[i - 1]) << ((j % DCHARS_IN_LIMB) << 3);
     }
 
 cleanup:
@@ -639,7 +665,7 @@ int big_number_shift_l(big_number_t* X, unsigned int count)
 {
     int ret;
     unsigned int i, v0, t1;
-    unsigned int r0 = 0, r1;
+    TUINT r0 = 0, r1;
 
     v0 = count / (DBITS_IN_LIMB);
     t1 = count & (DBITS_IN_LIMB - 1);
@@ -679,7 +705,7 @@ cleanup:
 int big_number_shift_r(big_number_t* X, unsigned int count)
 {
     unsigned int i, v0, v1;
-    unsigned int r0 = 0, r1;
+    TUINT r0 = 0, r1;
 
     v0 = count /  DBITS_IN_LIMB;
     v1 = count & (DBITS_IN_LIMB - 1);
@@ -800,10 +826,10 @@ int big_number_cmp_big_number(const big_number_t* X, const big_number_t* Y)
     return 0;
 }
 
-int big_number_cmp_int(const big_number_t *X, int z)
+int big_number_cmp_int(const big_number_t *X, TSINT z)
 {
     big_number_t Y;
-    unsigned int p[1];
+    TUINT p[1];
 
     *p  = (z < 0) ? -z : z;
     Y.s = (z < 0) ? -1 : 1;
@@ -817,7 +843,7 @@ int big_number_add_abs(big_number_t *X, const big_number_t *A, const big_number_
 {
     int ret;
     unsigned int i, j;
-    unsigned int *o, *p, c;
+    TUINT *o, *p, c;
 
     if (X == B) {
         const big_number_t *T = A; A = X; B = T;
@@ -858,10 +884,10 @@ cleanup:
     return ret;
 }
 
-static void big_number_sub_hlp(unsigned int n, unsigned int* s, unsigned int* d)
+static void big_number_sub_hlp(unsigned int n, TUINT *s, TUINT *d)
 {
     unsigned int i;
-    unsigned int c, z;
+    TUINT c, z;
 
     for (i = c = 0; i < n; i++, s++, d++) {
         z = (*d <  c);     *d -=  c;
@@ -958,10 +984,10 @@ cleanup:
     return ret;
 }
 
-int big_number_add_int(big_number_t* X, const big_number_t* A, int b)
+int big_number_add_int(big_number_t* X, const big_number_t* A, TSINT b)
 {
     big_number_t _B;
-    unsigned int p[1];
+    TUINT p[1];
 
     p[0] = ( b < 0 ) ? -b : b;
     _B.s = ( b < 0 ) ? -1 : 1;
@@ -971,10 +997,10 @@ int big_number_add_int(big_number_t* X, const big_number_t* A, int b)
     return (big_number_add_big_number(X, A, &_B));
 }
 
-int big_number_sub_int(big_number_t* X, const big_number_t* A, int b)
+int big_number_sub_int(big_number_t* X, const big_number_t* A, TSINT b)
 {
     big_number_t _B;
-    unsigned int p[1];
+    TUINT p[1];
 
     p[0] = ( b < 0 ) ? -b : b;
     _B.s = ( b < 0 ) ? -1 : 1;
@@ -984,9 +1010,9 @@ int big_number_sub_int(big_number_t* X, const big_number_t* A, int b)
     return (big_number_sub_big_number(X, A, &_B));
 }
 
-static void big_number_mul_hlp(unsigned int i, unsigned int* s, unsigned int* d, unsigned int b)
+static void big_number_mul_hlp(unsigned int i, TUINT *s, TUINT *d, TUINT b)
 {
-    unsigned int c = 0, t = 0;
+    TUINT c = 0, t = 0;
 
 #if defined(MULADDC_HUIT)
 
@@ -1090,10 +1116,10 @@ cleanup:
     return( ret );
 }
 
-int big_number_mul_int(big_number_t* X, const big_number_t* A, int b)
+int big_number_mul_int(big_number_t* X, const big_number_t* A, TSINT b)
 {
     big_number_t _B;
-    unsigned int p[1];
+    TUINT p[1];
 
     _B.s = 1;
     _B.n = 1;
@@ -1165,17 +1191,55 @@ int big_number_div_big_number(big_number_t* Q, big_number_t* R, const big_number
         if (X.p[i] >= Y.p[t]) {
             Z.p[i - t - 1] = ~0;
         } else {
-            unsigned long long r;
+#ifdef DHAVE_DOUBLE_LONG_INT
+            TUDBL r;
 
-            r  = (unsigned long long) X.p[i] << DBITS_IN_LIMB;
-            r |= (unsigned long long) X.p[i - 1];
+            r  = (TUDBL) X.p[i] << DBITS_IN_LIMB;
+            r |= (TUDBL) X.p[i - 1];
             r /= Y.p[t];
+            if (r > ((TUDBL) 1 << DBITS_IN_LIMB) - 1) {
+                r = ((TUDBL) 1 << DBITS_IN_LIMB) - 1;
+            }
 
-            if (r > ((unsigned long long) 1 << DBITS_IN_LIMB) - 1) {
-                r = ((unsigned long long) 1 << DBITS_IN_LIMB) - 1;
+            Z.p[i - t - 1] = (TUINT) r;
+#else
+            TUINT q0, q1, r0, r1;
+            TUINT d0, d1, d, m;
+
+            d  = Y.p[t];
+            d0 = ( d << DHALF_BITS_IN_LIMB ) >> DHALF_BITS_IN_LIMB;
+            d1 = ( d >> DHALF_BITS_IN_LIMB );
+
+            q1 = X.p[i] / d1;
+            r1 = X.p[i] - d1 * q1;
+            r1 <<= DHALF_BITS_IN_LIMB;
+            r1 |= ( X.p[i - 1] >> DHALF_BITS_IN_LIMB );
+
+            m = q1 * d0;
+            if( r1 < m )
+            {
+                q1--, r1 += d;
+                while( r1 >= d && r1 < m )
+                    q1--, r1 += d;
             }
+            r1 -= m;
+
+            q0 = r1 / d1;
+            r0 = r1 - d1 * q0;
+            r0 <<= DHALF_BITS_IN_LIMB;
+            r0 |= ( X.p[i - 1] << DHALF_BITS_IN_LIMB ) >> DHALF_BITS_IN_LIMB;
+
+            m = q0 * d0;
+            if( r0 < m )
+            {
+                q0--, r0 += d;
+                while( r0 >= d && r0 < m )
+                    q0--, r0 += d;
+            }
+            r0 -= m;
 
-            Z.p[i - t - 1] = (unsigned int) r;
+            Z.p[i - t - 1] = ( q1 << DHALF_BITS_IN_LIMB ) | q0;
+#endif
         }
 
         Z.p[i - t - 1]++;
@@ -1232,10 +1296,10 @@ cleanup:
     return ret;
 }
 
-int big_number_div_int(big_number_t *Q, big_number_t *R, const big_number_t *A, int b)
+int big_number_div_int(big_number_t *Q, big_number_t *R, const big_number_t *A, TSINT b)
 {
     big_number_t _B;
-    unsigned int p[1];
+    TUINT p[1];
 
     p[0] = ( b < 0 ) ? -b : b;
     _B.s = ( b < 0 ) ? -1 : 1;
@@ -1245,7 +1309,7 @@ int big_number_div_int(big_number_t *Q, big_number_t *R, const big_number_t *A,
     return (big_number_div_big_number(Q, R, A, &_B));
 }
 
-int big_number_mod_big_number(big_number_t* R, const big_number_t* A, const big_number_t* B)
+int big_number_mod_big_number(big_number_t *R, const big_number_t *A, const big_number_t *B)
 {
     int ret;
 
@@ -1268,10 +1332,10 @@ cleanup:
     return ret;
 }
 
-int big_number_mod_int(unsigned int* r, const big_number_t* A, int b)
+int big_number_mod_int(TUINT *r, const big_number_t *A, TSINT b)
 {
     unsigned int i;
-    unsigned int x, y, z;
+    TUINT x, y, z;
 
     if (b == 0) {
         return CRYPTO_ECODE_DIVISION_BY_ZERO;
@@ -1312,9 +1376,9 @@ int big_number_mod_int(unsigned int* r, const big_number_t* A, int b)
     return CRYPTO_ECODE_OK;
 }
 
-static void big_number_montg_init(unsigned int* mm, const big_number_t* N)
+static void big_number_montg_init(TUINT *mm, const big_number_t* N)
 {
-    unsigned int x, m0 = N->p[0];
+    TUINT x, m0 = N->p[0];
     unsigned int i;
 
     x  = m0;
@@ -1327,10 +1391,10 @@ static void big_number_montg_init(unsigned int* mm, const big_number_t* N)
     *mm = ~x + 1;
 }
 
-static void big_number_montmul(big_number_t* A, const big_number_t* B, const big_number_t* N, unsigned int mm, const big_number_t* T)
+static void big_number_montmul(big_number_t* A, const big_number_t* B, const big_number_t* N, TUINT mm, const big_number_t* T)
 {
     unsigned int i, n, m;
-    unsigned int u0, u1, *d;
+    TUINT u0, u1, *d;
 
     memset(T->p, 0, T->n * DCHARS_IN_LIMB);
 
@@ -1357,9 +1421,9 @@ static void big_number_montmul(big_number_t* A, const big_number_t* B, const big
     }
 }
 
-static void big_number_montred(big_number_t* A, const big_number_t* N, unsigned int mm, const big_number_t* T)
+static void big_number_montred(big_number_t* A, const big_number_t* N, TUINT mm, const big_number_t* T)
 {
-    unsigned int z = 1;
+    TUINT z = 1;
     big_number_t U;
 
     U.n = U.s = (int) z;
@@ -1374,7 +1438,7 @@ int big_number_exp_mod(big_number_t* X, const big_number_t* A, const big_number_
     unsigned int wbits, wsize, one = 1;
     unsigned int i, j, nblimbs;
     unsigned int bufsize, nbits;
-    unsigned int ei, mm, state;
+    TUINT ei, mm, state;
     big_number_t RR, T, W[2 << D_BIG_NUMBER_WINDOW_SIZE], Apos;
     int neg;
 
@@ -1469,7 +1533,7 @@ int big_number_exp_mod(big_number_t* X, const big_number_t* A, const big_number_
 
             nblimbs--;
 
-            bufsize = sizeof( unsigned int ) << 3;
+            bufsize = sizeof(TUINT) << 3;
         }
 
         bufsize--;
@@ -1728,7 +1792,7 @@ static int big_number_check_small_factors(const big_number_t* X)
 {
     int ret = 0;
     unsigned int i;
-    unsigned int r;
+    TUINT r;
 
     if ((X->p[0] & 1) == 0) {
         return CRYPTO_ECODE_NOT_ACCEPTABLE;
@@ -1861,7 +1925,7 @@ int big_number_gen_prime(big_number_t* X, unsigned int nbits, int dh_flag, int (
 {
     int ret;
     unsigned int k, n;
-    unsigned int r;
+    TUINT r;
     big_number_t Y;
 
     if (nbits < 3 || nbits > D_BIG_NUMBER_MAX_BITS) {
diff --git a/src/bld/secure/big_number.h b/src/bld/secure/big_number.h
index 0f13565..71d1f34 100644
--- a/src/bld/secure/big_number.h
+++ b/src/bld/secure/big_number.h
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * big_number.h
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 
 #ifndef __BIG_NUMBER_H__
@@ -28,7 +46,7 @@ int big_number_copy(big_number_t* X, const big_number_t* Y);
 void big_number_swap(big_number_t* X, big_number_t* Y);
 int big_number_safe_cond_assign(big_number_t* X, const big_number_t* Y, unsigned char assign);
 int big_number_safe_cond_swap(big_number_t* X, big_number_t* Y, unsigned char assign);
-int big_number_lset(big_number_t* X, int z);
+int big_number_lset(big_number_t* X, TSINT z);
 int big_number_get_bit(const big_number_t* X, unsigned int pos);
 int big_number_set_bit(big_number_t* X, unsigned int pos, unsigned char val);
 unsigned int big_number_lsb(const big_number_t* X);
@@ -41,19 +59,19 @@ int big_number_shift_l(big_number_t* X, unsigned int count);
 int big_number_shift_r(big_number_t* X, unsigned int count);
 int big_number_cmp_abs(const big_number_t* X, const big_number_t* Y);
 int big_number_cmp_big_number(const big_number_t* X, const big_number_t* Y);
-int big_number_cmp_int(const big_number_t* X, int z);
+int big_number_cmp_int(const big_number_t* X, TSINT z);
 int big_number_add_abs(big_number_t* X, const big_number_t* A, const big_number_t* B);
 int big_number_sub_abs(big_number_t* X, const big_number_t* A, const big_number_t* B);
 int big_number_add_big_number(big_number_t* X, const big_number_t* A, const big_number_t* B);
 int big_number_sub_big_number(big_number_t* X, const big_number_t* A, const big_number_t* B);
-int big_number_add_int(big_number_t* X, const big_number_t* A, int b);
-int big_number_sub_int(big_number_t* X, const big_number_t* A, int b);
+int big_number_add_int(big_number_t* X, const big_number_t* A, TSINT b);
+int big_number_sub_int(big_number_t* X, const big_number_t* A, TSINT b);
 int big_number_mul_big_number(big_number_t* X, const big_number_t* A, const big_number_t* B);
-int big_number_mul_int(big_number_t* X, const big_number_t* A, int b);
+int big_number_mul_int(big_number_t* X, const big_number_t* A, TSINT b);
 int big_number_div_big_number(big_number_t* Q, big_number_t* R, const big_number_t* A, const big_number_t* B);
-int big_number_div_int(big_number_t* Q, big_number_t* R, const big_number_t* A, int b);
+int big_number_div_int(big_number_t* Q, big_number_t* R, const big_number_t* A, TSINT b);
 int big_number_mod_big_number(big_number_t* R, const big_number_t* A, const big_number_t* B);
-int big_number_mod_int(unsigned int* r, const big_number_t* A, int b);
+int big_number_mod_int(TUINT *r, const big_number_t *A, TSINT b);
 int big_number_exp_mod(big_number_t* X, const big_number_t* A, const big_number_t* E, const big_number_t* N, big_number_t* _RR);
 int big_number_fill_random(big_number_t* X, unsigned int size, int (*f_rng)(void*, unsigned char*, unsigned int), void* p_rng);
 int big_number_gcd(big_number_t* G, const big_number_t* A, const big_number_t* B);
diff --git a/src/bld/secure/big_number_asm.h b/src/bld/secure/big_number_asm.h
index e3158eb..68f205b 100644
--- a/src/bld/secure/big_number_asm.h
+++ b/src/bld/secure/big_number_asm.h
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * big_number_asm.h
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #ifndef __BIG_NUMBER_ASM_H__
 #define __BIG_NUMBER_ASM_H__
@@ -36,7 +54,7 @@
     "movl   %%edx,   %%ecx      \n\t"   \
     "stosl                      \n\t"
 
-#if defined(POLARSSL_HAVE_SSE2)
+#if defined(HAVE_SSE2)
 
 #define MULADDC_HUIT                            \
     "movd     %%ecx,     %%mm1      \n\t"   \
@@ -159,377 +177,6 @@
 
 #endif /* AMD64 */
 
-#if defined(__mc68020__) || defined(__mcpu32__)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-                                        "movl   %3, %%a2        \n\t"   \
-                                        "movl   %4, %%a3        \n\t"   \
-                                        "movl   %5, %%d3        \n\t"   \
-                                        "movl   %6, %%d2        \n\t"   \
-                                        "moveq  #0, %%d0        \n\t"
-
-#define MULADDC_CORE                    \
-    "movel  %%a2@+, %%d1    \n\t"   \
-    "mulul  %%d2, %%d4:%%d1 \n\t"   \
-    "addl   %%d3, %%d1      \n\t"   \
-    "addxl  %%d0, %%d4      \n\t"   \
-    "moveq  #0,   %%d3      \n\t"   \
-    "addl   %%d1, %%a3@+    \n\t"   \
-    "addxl  %%d4, %%d3      \n\t"
-
-#define MULADDC_STOP                    \
-    "movl   %%d3, %0        \n\t"   \
-    "movl   %%a3, %1        \n\t"   \
-    "movl   %%a2, %2        \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "d0", "d1", "d2", "d3", "d4", "a2", "a3"  \
-        );
-
-#define MULADDC_HUIT                        \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d4:%%d1  \n\t"   \
-    "addxl  %%d3,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d4       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d3:%%d1  \n\t"   \
-    "addxl  %%d4,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d3       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d4:%%d1  \n\t"   \
-    "addxl  %%d3,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d4       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d3:%%d1  \n\t"   \
-    "addxl  %%d4,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d3       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d4:%%d1  \n\t"   \
-    "addxl  %%d3,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d4       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d3:%%d1  \n\t"   \
-    "addxl  %%d4,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d3       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d4:%%d1  \n\t"   \
-    "addxl  %%d3,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d4       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d3:%%d1  \n\t"   \
-    "addxl  %%d4,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d3       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "addxl  %%d0,    %%d3       \n\t"
-
-#endif /* MC68000 */
-
-#if defined(__powerpc64__) || defined(__ppc64__)
-
-#if defined(__MACH__) && defined(__APPLE__)
-
-#define MULADDC_INIT                        \
-    asm(                                    \
-                                            "ld     r3, %3              \n\t"   \
-                                            "ld     r4, %4              \n\t"   \
-                                            "ld     r5, %5              \n\t"   \
-                                            "ld     r6, %6              \n\t"   \
-                                            "addi   r3, r3, -8          \n\t"   \
-                                            "addi   r4, r4, -8          \n\t"   \
-                                            "addic  r5, r5,  0          \n\t"
-
-#define MULADDC_CORE                        \
-    "ldu    r7, 8(r3)           \n\t"   \
-    "mulld  r8, r7, r6          \n\t"   \
-    "mulhdu r9, r7, r6          \n\t"   \
-    "adde   r8, r8, r5          \n\t"   \
-    "ld     r7, 8(r4)           \n\t"   \
-    "addze  r5, r9              \n\t"   \
-    "addc   r8, r8, r7          \n\t"   \
-    "stdu   r8, 8(r4)           \n\t"
-
-#define MULADDC_STOP                        \
-    "addze  r5, r5              \n\t"   \
-    "addi   r4, r4, 8           \n\t"   \
-    "addi   r3, r3, 8           \n\t"   \
-    "std    r5, %0              \n\t"   \
-    "std    r4, %1              \n\t"   \
-    "std    r3, %2              \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-        );
-
-
-#else /* __MACH__ && __APPLE__ */
-
-#define MULADDC_INIT                        \
-    asm(                                    \
-                                            "ld     %%r3, %3            \n\t"   \
-                                            "ld     %%r4, %4            \n\t"   \
-                                            "ld     %%r5, %5            \n\t"   \
-                                            "ld     %%r6, %6            \n\t"   \
-                                            "addi   %%r3, %%r3, -8      \n\t"   \
-                                            "addi   %%r4, %%r4, -8      \n\t"   \
-                                            "addic  %%r5, %%r5,  0      \n\t"
-
-#define MULADDC_CORE                        \
-    "ldu    %%r7, 8(%%r3)       \n\t"   \
-    "mulld  %%r8, %%r7, %%r6    \n\t"   \
-    "mulhdu %%r9, %%r7, %%r6    \n\t"   \
-    "adde   %%r8, %%r8, %%r5    \n\t"   \
-    "ld     %%r7, 8(%%r4)       \n\t"   \
-    "addze  %%r5, %%r9          \n\t"   \
-    "addc   %%r8, %%r8, %%r7    \n\t"   \
-    "stdu   %%r8, 8(%%r4)       \n\t"
-
-#define MULADDC_STOP                        \
-    "addze  %%r5, %%r5          \n\t"   \
-    "addi   %%r4, %%r4, 8       \n\t"   \
-    "addi   %%r3, %%r3, 8       \n\t"   \
-    "std    %%r5, %0            \n\t"   \
-    "std    %%r4, %1            \n\t"   \
-    "std    %%r3, %2            \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-        );
-
-#endif /* __MACH__ && __APPLE__ */
-
-#elif defined(__powerpc__) || defined(__ppc__) /* end PPC64/begin PPC32  */
-
-#if defined(__MACH__) && defined(__APPLE__)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-                                        "lwz    r3, %3          \n\t"   \
-                                        "lwz    r4, %4          \n\t"   \
-                                        "lwz    r5, %5          \n\t"   \
-                                        "lwz    r6, %6          \n\t"   \
-                                        "addi   r3, r3, -4      \n\t"   \
-                                        "addi   r4, r4, -4      \n\t"   \
-                                        "addic  r5, r5,  0      \n\t"
-
-#define MULADDC_CORE                    \
-    "lwzu   r7, 4(r3)       \n\t"   \
-    "mullw  r8, r7, r6      \n\t"   \
-    "mulhwu r9, r7, r6      \n\t"   \
-    "adde   r8, r8, r5      \n\t"   \
-    "lwz    r7, 4(r4)       \n\t"   \
-    "addze  r5, r9          \n\t"   \
-    "addc   r8, r8, r7      \n\t"   \
-    "stwu   r8, 4(r4)       \n\t"
-
-#define MULADDC_STOP                    \
-    "addze  r5, r5          \n\t"   \
-    "addi   r4, r4, 4       \n\t"   \
-    "addi   r3, r3, 4       \n\t"   \
-    "stw    r5, %0          \n\t"   \
-    "stw    r4, %1          \n\t"   \
-    "stw    r3, %2          \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-        );
-
-#else /* __MACH__ && __APPLE__ */
-
-#define MULADDC_INIT                        \
-    asm(                                    \
-                                            "lwz    %%r3, %3            \n\t"   \
-                                            "lwz    %%r4, %4            \n\t"   \
-                                            "lwz    %%r5, %5            \n\t"   \
-                                            "lwz    %%r6, %6            \n\t"   \
-                                            "addi   %%r3, %%r3, -4      \n\t"   \
-                                            "addi   %%r4, %%r4, -4      \n\t"   \
-                                            "addic  %%r5, %%r5,  0      \n\t"
-
-#define MULADDC_CORE                        \
-    "lwzu   %%r7, 4(%%r3)       \n\t"   \
-    "mullw  %%r8, %%r7, %%r6    \n\t"   \
-    "mulhwu %%r9, %%r7, %%r6    \n\t"   \
-    "adde   %%r8, %%r8, %%r5    \n\t"   \
-    "lwz    %%r7, 4(%%r4)       \n\t"   \
-    "addze  %%r5, %%r9          \n\t"   \
-    "addc   %%r8, %%r8, %%r7    \n\t"   \
-    "stwu   %%r8, 4(%%r4)       \n\t"
-
-#define MULADDC_STOP                        \
-    "addze  %%r5, %%r5          \n\t"   \
-    "addi   %%r4, %%r4, 4       \n\t"   \
-    "addi   %%r3, %%r3, 4       \n\t"   \
-    "stw    %%r5, %0            \n\t"   \
-    "stw    %%r4, %1            \n\t"   \
-    "stw    %%r3, %2            \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-        );
-
-#endif /* __MACH__ && __APPLE__ */
-
-#endif /* PPC32 */
-
-/*
- * The Sparc64 assembly is reported to be broken.
- * Disable it for now, until we're able to fix it.
- */
-#if 0 && defined(__sparc__) && defined(__sparc64__)
-
-#define MULADDC_INIT                                    \
-    asm(                                                \
-            "ldx     %3, %%o0               \n\t"   \
-            "ldx     %4, %%o1               \n\t"   \
-            "ld      %5, %%o2               \n\t"   \
-            "ld      %6, %%o3               \n\t"
-
-#define MULADDC_CORE                                    \
-    "ld      [%%o0], %%o4           \n\t"   \
-    "inc     4, %%o0                \n\t"   \
-    "ld      [%%o1], %%o5           \n\t"   \
-    "umul    %%o3, %%o4, %%o4       \n\t"   \
-    "addcc   %%o4, %%o2, %%o4       \n\t"   \
-    "rd      %%y, %%g1              \n\t"   \
-    "addx    %%g1, 0, %%g1          \n\t"   \
-    "addcc   %%o4, %%o5, %%o4       \n\t"   \
-    "st      %%o4, [%%o1]           \n\t"   \
-    "addx    %%g1, 0, %%o2          \n\t"   \
-    "inc     4, %%o1                \n\t"
-
-#define MULADDC_STOP                            \
-    "st      %%o2, %0               \n\t"   \
-    "stx     %%o1, %1               \n\t"   \
-    "stx     %%o0, %2               \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)          \
-        : "m" (s), "m" (d), "m" (c), "m" (b)    \
-        : "g1", "o0", "o1", "o2", "o3", "o4",   \
-        "o5"                                  \
-        );
-#endif /* SPARCv9 */
-
-#if defined(__sparc__) && !defined(__sparc64__)
-
-#define MULADDC_INIT                                    \
-    asm(                                                \
-            "ld      %3, %%o0               \n\t"   \
-            "ld      %4, %%o1               \n\t"   \
-            "ld      %5, %%o2               \n\t"   \
-            "ld      %6, %%o3               \n\t"
-
-#define MULADDC_CORE                                    \
-    "ld      [%%o0], %%o4           \n\t"   \
-    "inc     4, %%o0                \n\t"   \
-    "ld      [%%o1], %%o5           \n\t"   \
-    "umul    %%o3, %%o4, %%o4       \n\t"   \
-    "addcc   %%o4, %%o2, %%o4       \n\t"   \
-    "rd      %%y, %%g1              \n\t"   \
-    "addx    %%g1, 0, %%g1          \n\t"   \
-    "addcc   %%o4, %%o5, %%o4       \n\t"   \
-    "st      %%o4, [%%o1]           \n\t"   \
-    "addx    %%g1, 0, %%o2          \n\t"   \
-    "inc     4, %%o1                \n\t"
-
-#define MULADDC_STOP                                    \
-    "st      %%o2, %0               \n\t"   \
-    "st      %%o1, %1               \n\t"   \
-    "st      %%o0, %2               \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)          \
-        : "m" (s), "m" (d), "m" (c), "m" (b)    \
-        : "g1", "o0", "o1", "o2", "o3", "o4",   \
-        "o5"                                  \
-        );
-
-#endif /* SPARCv8 */
-
-#if defined(__microblaze__) || defined(microblaze)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-                                        "lwi   r3,   %3         \n\t"   \
-                                        "lwi   r4,   %4         \n\t"   \
-                                        "lwi   r5,   %5         \n\t"   \
-                                        "lwi   r6,   %6         \n\t"   \
-                                        "andi  r7,   r6, 0xffff \n\t"   \
-                                        "bsrli r6,   r6, 16     \n\t"
-
-#define MULADDC_CORE                    \
-    "lhui  r8,   r3,   0    \n\t"   \
-    "addi  r3,   r3,   2    \n\t"   \
-    "lhui  r9,   r3,   0    \n\t"   \
-    "addi  r3,   r3,   2    \n\t"   \
-    "mul   r10,  r9,  r6    \n\t"   \
-    "mul   r11,  r8,  r7    \n\t"   \
-    "mul   r12,  r9,  r7    \n\t"   \
-    "mul   r13,  r8,  r6    \n\t"   \
-    "bsrli  r8, r10,  16    \n\t"   \
-    "bsrli  r9, r11,  16    \n\t"   \
-    "add   r13, r13,  r8    \n\t"   \
-    "add   r13, r13,  r9    \n\t"   \
-    "bslli r10, r10,  16    \n\t"   \
-    "bslli r11, r11,  16    \n\t"   \
-    "add   r12, r12, r10    \n\t"   \
-    "addc  r13, r13,  r0    \n\t"   \
-    "add   r12, r12, r11    \n\t"   \
-    "addc  r13, r13,  r0    \n\t"   \
-    "lwi   r10,  r4,   0    \n\t"   \
-    "add   r12, r12, r10    \n\t"   \
-    "addc  r13, r13,  r0    \n\t"   \
-    "add   r12, r12,  r5    \n\t"   \
-    "addc   r5, r13,  r0    \n\t"   \
-    "swi   r12,  r4,   0    \n\t"   \
-    "addi   r4,  r4,   4    \n\t"
-
-#define MULADDC_STOP                    \
-    "swi   r5,   %0         \n\t"   \
-    "swi   r4,   %1         \n\t"   \
-    "swi   r3,   %2         \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4"  "r5", "r6", "r7", "r8",       \
-        "r9", "r10", "r11", "r12", "r13"          \
-        );
-
-#endif /* MicroBlaze */
-
-#if defined(__tricore__)
-
-#define MULADDC_INIT                            \
-    asm(                                        \
-            "ld.a   %%a2, %3                \n\t"   \
-            "ld.a   %%a3, %4                \n\t"   \
-            "ld.w   %%d4, %5                \n\t"   \
-            "ld.w   %%d1, %6                \n\t"   \
-            "xor    %%d5, %%d5              \n\t"
-
-#define MULADDC_CORE                            \
-    "ld.w   %%d0,   [%%a2+]         \n\t"   \
-    "madd.u %%e2, %%e4, %%d0, %%d1  \n\t"   \
-    "ld.w   %%d0,   [%%a3]          \n\t"   \
-    "addx   %%d2,    %%d2,  %%d0    \n\t"   \
-    "addc   %%d3,    %%d3,    0     \n\t"   \
-    "mov    %%d4,    %%d3           \n\t"   \
-    "st.w  [%%a3+],  %%d2           \n\t"
-
-#define MULADDC_STOP                            \
-    "st.w   %0, %%d4                \n\t"   \
-    "st.a   %1, %%a3                \n\t"   \
-    "st.a   %2, %%a2                \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)          \
-        : "m" (s), "m" (d), "m" (c), "m" (b)    \
-        : "d0", "d1", "e2", "d4", "a2", "a3"    \
-        );
-
-#endif /* TriCore */
-
 #if defined(__arm__)
 
 #if defined(__thumb__) && !defined(__thumb2__)
@@ -540,15 +187,15 @@
             "ldr    r1, %4                      \n\t"   \
             "ldr    r2, %5                      \n\t"   \
             "ldr    r3, %6                      \n\t"   \
-            "lsr    r7, r3, #16                 \n\t"   \
-            "mov    r9, r7                      \n\t"   \
-            "lsl    r7, r3, #16                 \n\t"   \
-            "lsr    r7, r7, #16                 \n\t"   \
-            "mov    r8, r7                      \n\t"
+            "lsr    r10, r3, #16                 \n\t"   \
+            "mov    r9, r10                      \n\t"   \
+            "lsl    r10, r3, #16                 \n\t"   \
+            "lsr    r10, r10, #16                 \n\t"   \
+            "mov    r8, r10                      \n\t"
 
 #define MULADDC_CORE                                    \
     "ldmia  r0!, {r6}                   \n\t"   \
-    "lsr    r7, r6, #16                 \n\t"   \
+    "lsr    r10, r6, #16                 \n\t"   \
     "lsl    r6, r6, #16                 \n\t"   \
     "lsr    r6, r6, #16                 \n\t"   \
     "mov    r4, r8                      \n\t"   \
@@ -556,12 +203,12 @@
     "mov    r3, r9                      \n\t"   \
     "mul    r6, r3                      \n\t"   \
     "mov    r5, r9                      \n\t"   \
-    "mul    r5, r7                      \n\t"   \
+    "mul    r5, r10                      \n\t"   \
     "mov    r3, r8                      \n\t"   \
-    "mul    r7, r3                      \n\t"   \
+    "mul    r10, r3                      \n\t"   \
     "lsr    r3, r6, #16                 \n\t"   \
     "add    r5, r5, r3                  \n\t"   \
-    "lsr    r3, r7, #16                 \n\t"   \
+    "lsr    r3, r10, #16                 \n\t"   \
     "add    r5, r5, r3                  \n\t"   \
     "add    r4, r4, r2                  \n\t"   \
     "mov    r2, #0                      \n\t"   \
@@ -569,7 +216,7 @@
     "lsl    r3, r6, #16                 \n\t"   \
     "add    r4, r4, r3                  \n\t"   \
     "adc    r5, r2                      \n\t"   \
-    "lsl    r3, r7, #16                 \n\t"   \
+    "lsl    r3, r10, #16                 \n\t"   \
     "add    r4, r4, r3                  \n\t"   \
     "adc    r5, r2                      \n\t"   \
     "ldr    r3, [r1]                    \n\t"   \
@@ -584,7 +231,7 @@
     : "=m" (c),  "=m" (d), "=m" (s)        \
         : "m" (s), "m" (d), "m" (c), "m" (b)   \
         : "r0", "r1", "r2", "r3", "r4", "r5",  \
-        "r6", "r7", "r8", "r9", "cc"         \
+        "r6", "r10", "r8", "r9", "cc"         \
         );
 
 #else
@@ -601,9 +248,9 @@
     "mov    r5, #0                      \n\t"   \
     "ldr    r6, [r1]                    \n\t"   \
     "umlal  r2, r5, r3, r4              \n\t"   \
-    "adds   r7, r6, r2                  \n\t"   \
+    "adds   r10, r6, r2                  \n\t"   \
     "adc    r2, r5, #0                  \n\t"   \
-    "str    r7, [r1], #4                \n\t"
+    "str    r10, [r1], #4                \n\t"
 
 #define MULADDC_STOP                                    \
     "str    r2, %0                      \n\t"   \
@@ -612,82 +259,13 @@
     : "=m" (c),  "=m" (d), "=m" (s)        \
         : "m" (s), "m" (d), "m" (c), "m" (b)   \
         : "r0", "r1", "r2", "r3", "r4", "r5",  \
-        "r6", "r7", "cc"                     \
+        "r6", "r10", "cc"                     \
         );
 
 #endif /* Thumb */
 
 #endif /* ARMv3 */
 
-#if defined(__alpha__)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-                                        "ldq    $1, %3          \n\t"   \
-                                        "ldq    $2, %4          \n\t"   \
-                                        "ldq    $3, %5          \n\t"   \
-                                        "ldq    $4, %6          \n\t"
-
-#define MULADDC_CORE                    \
-    "ldq    $6,  0($1)      \n\t"   \
-    "addq   $1,  8, $1      \n\t"   \
-    "mulq   $6, $4, $7      \n\t"   \
-    "umulh  $6, $4, $6      \n\t"   \
-    "addq   $7, $3, $7      \n\t"   \
-    "cmpult $7, $3, $3      \n\t"   \
-    "ldq    $5,  0($2)      \n\t"   \
-    "addq   $7, $5, $7      \n\t"   \
-    "cmpult $7, $5, $5      \n\t"   \
-    "stq    $7,  0($2)      \n\t"   \
-    "addq   $2,  8, $2      \n\t"   \
-    "addq   $6, $3, $3      \n\t"   \
-    "addq   $5, $3, $3      \n\t"
-
-#define MULADDC_STOP                                    \
-    "stq    $3, %0          \n\t"   \
-    "stq    $2, %1          \n\t"   \
-    "stq    $1, %2          \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "$1", "$2", "$3", "$4", "$5", "$6", "$7"  \
-        );
-#endif /* Alpha */
-
-#if defined(__mips__) && !defined(__mips64)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-                                        "lw     $10, %3         \n\t"   \
-                                        "lw     $11, %4         \n\t"   \
-                                        "lw     $12, %5         \n\t"   \
-                                        "lw     $13, %6         \n\t"
-
-#define MULADDC_CORE                    \
-    "lw     $14, 0($10)     \n\t"   \
-    "multu  $13, $14        \n\t"   \
-    "addi   $10, $10, 4     \n\t"   \
-    "mflo   $14             \n\t"   \
-    "mfhi   $9              \n\t"   \
-    "addu   $14, $12, $14   \n\t"   \
-    "lw     $15, 0($11)     \n\t"   \
-    "sltu   $12, $14, $12   \n\t"   \
-    "addu   $15, $14, $15   \n\t"   \
-    "sltu   $14, $15, $14   \n\t"   \
-    "addu   $12, $12, $9    \n\t"   \
-    "sw     $15, 0($11)     \n\t"   \
-    "addu   $12, $12, $14   \n\t"   \
-    "addi   $11, $11, 4     \n\t"
-
-#define MULADDC_STOP                    \
-    "sw     $12, %0         \n\t"   \
-    "sw     $11, %1         \n\t"   \
-    "sw     $10, %2         \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)                      \
-        : "m" (s), "m" (d), "m" (c), "m" (b)                \
-        : "$9", "$10", "$11", "$12", "$13", "$14", "$15"    \
-        );
-
-#endif /* MIPS */
 #endif /* GNUC */
 
 #if (defined(_MSC_VER) && defined(_M_IX86)) || defined(__WATCOMC__)
@@ -708,7 +286,7 @@
     __asm   mov     ecx, edx                    \
     __asm   stosd
 
-#if defined(POLARSSL_HAVE_SSE2)
+#if defined(HAVE_SSE2)
 
 #define EMIT __asm _emit
 
@@ -792,22 +370,51 @@
 #endif /* MSVC */
 
 #if !defined(MULADDC_CORE)
+#if defined(DHAVE_DOUBLE_LONG_INT)
 
 #define MULADDC_INIT                    \
-    {                                       \
-        t_udbl r;                           \
-        t_uint r0, r1;
+{                                       \
+    TUDBL r;                           \
+    TUINT r0, r1;
 
 #define MULADDC_CORE                    \
-    r   = *(s++) * (t_udbl) b;          \
-    r0  = (t_uint) r;                   \
-    r1  = (t_uint)( r >> biL );         \
+    r   = *(s++) * (TUDBL) b;          \
+    r0  = (TUINT) r;                   \
+    r1  = (TUINT)( r >> DBITS_IN_LIMB );         \
     r0 += c;  r1 += (r0 <  c);          \
     r0 += *d; r1 += (r0 < *d);          \
     c = r1; *(d++) = r0;
 
 #define MULADDC_STOP                    \
-    }
+}
+
+#else
+#define MULADDC_INIT                    \
+{                                       \
+    TUINT s0, s1, b0, b1;              \
+    TUINT r0, r1, rx, ry;              \
+    b0 = ( b << DHALF_BITS_IN_LIMB ) >> DHALF_BITS_IN_LIMB;           \
+    b1 = ( b >> DHALF_BITS_IN_LIMB );
+
+#define MULADDC_CORE                    \
+    s0 = ( *s << DHALF_BITS_IN_LIMB ) >> DHALF_BITS_IN_LIMB;          \
+    s1 = ( *s >> DHALF_BITS_IN_LIMB ); s++;            \
+    rx = s0 * b1; r0 = s0 * b0;         \
+    ry = s1 * b0; r1 = s1 * b1;         \
+    r1 += ( rx >> DHALF_BITS_IN_LIMB );                \
+    r1 += ( ry >> DHALF_BITS_IN_LIMB );                \
+    rx <<= DHALF_BITS_IN_LIMB; ry <<= DHALF_BITS_IN_LIMB;             \
+    r0 += rx; r1 += (r0 < rx);          \
+    r0 += ry; r1 += (r0 < ry);          \
+    r0 +=  c; r1 += (r0 <  c);          \
+    r0 += *d; r1 += (r0 < *d);          \
+    c = r1; *(d++) = r0;
+
+#define MULADDC_STOP                    \
+}
+
+#endif /* C (generic)  */
+
 
 #endif
 
diff --git a/src/bld/secure/crypt_utils.c b/src/bld/secure/crypt_utils.c
index 493e050..d84d9a2 100644
--- a/src/bld/secure/crypt_utils.c
+++ b/src/bld/secure/crypt_utils.c
@@ -1,17 +1,34 @@
-/*
+/*******************************************************************************
  * crypt_utils.c
  *
  * History:
  *  2015/06/16 - [Zhi He] create utils file for cryptography library
  *
- * Copyright (C) 2015 -2025, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include "cryptography_if.h"
 
diff --git a/src/bld/secure/cryptography_if.h b/src/bld/secure/cryptography_if.h
index cf09334..840e515 100644
--- a/src/bld/secure/cryptography_if.h
+++ b/src/bld/secure/cryptography_if.h
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * cryptography_if.h
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #ifndef __CRYPTOGRAPHY_IF_H__
 #define __CRYPTOGRAPHY_IF_H__
@@ -76,10 +94,6 @@ typedef enum {
 #define DCRYPTO_SHA384_DIGEST_LENGTH 48
 #define DCRYPTO_SHA512_DIGEST_LENGTH 64
 
-enum {
-    CRYPTO_PKEY_TYPE_RSA = 0x1,
-};
-
 #define D_CLEAN_IF_FAILED(f) do { if ((ret = f) != CRYPTO_ECODE_OK) goto cleanup; } while(0)
 
 #define D_BIG_NUMBER_MAX_LIMBS                             10000
@@ -92,10 +106,28 @@ enum {
 #define RSA_PKCS_V15    0
 #define RSA_PKCS_V21    1
 
+#if (defined(_MSC_VER) && defined(_M_AMD64))
+    typedef  long long TSINT;
+    typedef unsigned long long TUINT;
+    #define DHAVE_INT_64
+#else
+    #define DHAVE_DOUBLE_LONG_INT
+#if (defined(__GNUC__) && (defined(__amd64__) || defined(__x86_64__) || defined(__ia64__) || (defined(__arch64__))))
+    typedef  long long TSINT;
+    typedef unsigned long long TUINT;
+    typedef unsigned int TUDBL __attribute__((mode(TI)));
+    #define DHAVE_INT_64
+#else
+    typedef int TSINT;
+    typedef unsigned int TUINT;
+    typedef unsigned long long TUDBL;
+#endif
+#endif
+
 typedef struct {
     int s;
     unsigned int n;
-    unsigned int *p;
+    TUINT *p;
 } big_number_t;
 
 typedef struct {
@@ -143,7 +175,7 @@ void digest_md5_final(void* ctx, unsigned char* digest);
 #endif
 
 void rsa_init(rsa_context_t* ctx, int padding, int hash_id);
-void rsa_free(rsa_context_t* ctx );
+void rsa_free(rsa_context_t* ctx);
 int rsa_check_pubkey(const rsa_context_t* ctx);
 int rsa_check_privkey(const rsa_context_t* ctx);
 int rsa_check_key_pair(const rsa_context_t* pub, const rsa_context_t* prv);
@@ -166,6 +198,38 @@ extern unsigned int big_number_size(const big_number_t* X);
 extern unsigned int big_number_msb(const big_number_t *X);
 
 
+typedef struct {
+    unsigned int round;
+    unsigned int p_round_key[72];
+    unsigned int cur_position;
+} aes_context_t;
+
+aes_context_t *aes_init();
+void aes_destroy(aes_context_t *ctx);
+
+int aes_set_encrypt_key(aes_context_t *ctx, const unsigned char *key, unsigned int key_length);
+int aes_set_decrypt_key(aes_context_t *ctx, const unsigned char *key, unsigned int key_length);
+
+//ecb mode
+int aes_ecb_encrypt(aes_context_t *ctx, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_ecb_decrypt(aes_context_t *ctx, unsigned char *input, unsigned char *output, unsigned int data_length);
+
+//ctr mode
+int aes_ctr_crypt(aes_context_t *ctx, unsigned char *p_nonce, unsigned char *input, unsigned char *output, unsigned int data_length);
+
+//cbc mode
+int aes_cbc_encrypt(aes_context_t *ctx, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_cbc_decrypt(aes_context_t *ctx, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length);
+
+
+//one shot api
+int aes_ecb_encrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_ecb_decrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_ctr_crypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *p_nonce, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_cbc_encrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_cbc_decrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/bld/secure/digest_md5.c b/src/bld/secure/digest_md5.c
index d583a83..56eb7f4 100644
--- a/src/bld/secure/digest_md5.c
+++ b/src/bld/secure/digest_md5.c
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * digest_md5.c
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include "cryptography_if.h"
 
diff --git a/src/bld/secure/digest_sha256.c b/src/bld/secure/digest_sha256.c
index f8f16fe..6e800c3 100644
--- a/src/bld/secure/digest_sha256.c
+++ b/src/bld/secure/digest_sha256.c
@@ -1,314 +1,332 @@
-/**
- * digest_sha256.c
+/*******************************************************************************
+ * digest_sha256.c
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
-
-
-#include "cryptography_if.h"
-
-#ifndef DNOT_INCLUDE_C_HEADER
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-#else
-#include <bldfunc.h>
-#endif
-
-#define DSHA256_BLOCK_SIZE  (512 / 8)
-
-typedef struct {
-    unsigned int tot_len;
-    unsigned int len;
-    unsigned char block[2 * DSHA256_BLOCK_SIZE];
-    unsigned int h[8];
-} sha256_ctx_t;
-
-#define DSHFR(x, n)    (x >> n)
-#define DROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
-#define DROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
-#define DCH(x, y, z)  ((x & y) ^ (~x & z))
-#define DMAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
-
-#define DSHA256_F1(x) (DROTR(x,  2) ^ DROTR(x, 13) ^ DROTR(x, 22))
-#define DSHA256_F2(x) (DROTR(x,  6) ^ DROTR(x, 11) ^ DROTR(x, 25))
-#define DSHA256_F3(x) (DROTR(x,  7) ^ DROTR(x, 18) ^ DSHFR(x,  3))
-#define DSHA256_F4(x) (DROTR(x, 17) ^ DROTR(x, 19) ^ DSHFR(x, 10))
-
-#define DUNPACK32(x, str)                      \
-    {                                             \
-        *((str) + 3) = (unsigned char) ((x));       \
-        *((str) + 2) = (unsigned char) ((x) >>  8);       \
-        *((str) + 1) = (unsigned char) ((x) >> 16);       \
-        *((str) + 0) = (unsigned char) ((x) >> 24);       \
-    }
-
-#define DPACK32(str, x)                        \
-    {                                             \
-        *(x) =   ((unsigned int) *((str) + 3))    \
-                 | ((unsigned int) *((str) + 2) <<  8)    \
-                 | ((unsigned int) *((str) + 1) << 16)    \
-                 | ((unsigned int) *((str) + 0) << 24);   \
-    }
-
-#define DSHA256_SCR(i)                         \
-    {                                             \
-        w[i] =  DSHA256_F4(w[i -  2]) + w[i -  7]  \
-                + DSHA256_F3(w[i - 15]) + w[i - 16]; \
-    }
-
-#define DSHA256_EXP(a, b, c, d, e, f, g, h, j)               \
-    {                                                           \
-        t1 = wv[h] + DSHA256_F2(wv[e]) + DCH(wv[e], wv[f], wv[g]) \
-             + g_sha256_k[j] + w[j];                              \
-        t2 = DSHA256_F1(wv[a]) + DMAJ(wv[a], wv[b], wv[c]);       \
-        wv[d] += t1;                                            \
-        wv[h] = t1 + t2;                                        \
-    }
-
-static unsigned int g_sha256_h0[8] = {
-    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
-    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
-};
-
-static unsigned int g_sha256_k[64] = {
-    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
-    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
-    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
-    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
-    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
-    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
-    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
-    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
-    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
-    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
-    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
-    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
-    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
-    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
-    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
-    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
-};
-
-static void __sha256_transf(sha256_ctx_t* ctx, const unsigned char* message, unsigned int block_nb)
-{
-    unsigned int w[64];
-    unsigned int wv[8];
-
-    unsigned int t1, t2;
-    const unsigned char *sub_block;
-    int i;
-
-    for (i = 0; i < (int) block_nb; i++) {
-        sub_block = message + (i << 6);
-
-        DPACK32(&sub_block[ 0], &w[ 0]); DPACK32(&sub_block[ 4], &w[ 1]);
-        DPACK32(&sub_block[ 8], &w[ 2]); DPACK32(&sub_block[12], &w[ 3]);
-        DPACK32(&sub_block[16], &w[ 4]); DPACK32(&sub_block[20], &w[ 5]);
-        DPACK32(&sub_block[24], &w[ 6]); DPACK32(&sub_block[28], &w[ 7]);
-        DPACK32(&sub_block[32], &w[ 8]); DPACK32(&sub_block[36], &w[ 9]);
-        DPACK32(&sub_block[40], &w[10]); DPACK32(&sub_block[44], &w[11]);
-        DPACK32(&sub_block[48], &w[12]); DPACK32(&sub_block[52], &w[13]);
-        DPACK32(&sub_block[56], &w[14]); DPACK32(&sub_block[60], &w[15]);
-
-        DSHA256_SCR(16); DSHA256_SCR(17); DSHA256_SCR(18); DSHA256_SCR(19);
-        DSHA256_SCR(20); DSHA256_SCR(21); DSHA256_SCR(22); DSHA256_SCR(23);
-        DSHA256_SCR(24); DSHA256_SCR(25); DSHA256_SCR(26); DSHA256_SCR(27);
-        DSHA256_SCR(28); DSHA256_SCR(29); DSHA256_SCR(30); DSHA256_SCR(31);
-        DSHA256_SCR(32); DSHA256_SCR(33); DSHA256_SCR(34); DSHA256_SCR(35);
-        DSHA256_SCR(36); DSHA256_SCR(37); DSHA256_SCR(38); DSHA256_SCR(39);
-        DSHA256_SCR(40); DSHA256_SCR(41); DSHA256_SCR(42); DSHA256_SCR(43);
-        DSHA256_SCR(44); DSHA256_SCR(45); DSHA256_SCR(46); DSHA256_SCR(47);
-        DSHA256_SCR(48); DSHA256_SCR(49); DSHA256_SCR(50); DSHA256_SCR(51);
-        DSHA256_SCR(52); DSHA256_SCR(53); DSHA256_SCR(54); DSHA256_SCR(55);
-        DSHA256_SCR(56); DSHA256_SCR(57); DSHA256_SCR(58); DSHA256_SCR(59);
-        DSHA256_SCR(60); DSHA256_SCR(61); DSHA256_SCR(62); DSHA256_SCR(63);
-
-        wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
-        wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
-        wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
-        wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
-
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 0); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 1);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 2); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 3);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 4); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 5);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 6); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 7);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 8); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 9);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 10); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 11);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 12); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 13);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 14); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 15);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 16); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 17);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 18); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 19);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 20); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 21);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 22); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 23);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 24); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 25);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 26); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 27);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 28); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 29);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 30); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 31);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 32); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 33);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 34); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 35);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 36); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 37);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 38); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 39);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 40); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 41);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 42); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 43);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 44); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 45);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 46); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 47);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 48); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 49);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 50); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 51);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 52); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 53);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 54); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 55);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 56); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 57);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 58); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 59);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 60); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 61);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 62); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 63);
-
-        ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
-        ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
-        ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
-        ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
-    }
-}
-
-static void __sha256_init(sha256_ctx_t *ctx)
-{
-    ctx->h[0] = g_sha256_h0[0]; ctx->h[1] = g_sha256_h0[1];
-    ctx->h[2] = g_sha256_h0[2]; ctx->h[3] = g_sha256_h0[3];
-    ctx->h[4] = g_sha256_h0[4]; ctx->h[5] = g_sha256_h0[5];
-    ctx->h[6] = g_sha256_h0[6]; ctx->h[7] = g_sha256_h0[7];
-
-    ctx->len = 0;
-    ctx->tot_len = 0;
-}
-
-static void __sha256_update(sha256_ctx_t* ctx, const unsigned char* message, unsigned int len)
-{
-    unsigned int block_nb;
-    unsigned int new_len, rem_len, tmp_len;
-    const unsigned char *shifted_message;
-
-    tmp_len = DSHA256_BLOCK_SIZE - ctx->len;
-    rem_len = len < tmp_len ? len : tmp_len;
-
-    memcpy(&ctx->block[ctx->len], message, rem_len);
-
-    if (ctx->len + len < DSHA256_BLOCK_SIZE) {
-        ctx->len += len;
-        return;
-    }
-
-    new_len = len - rem_len;
-    block_nb = new_len / DSHA256_BLOCK_SIZE;
-
-    shifted_message = message + rem_len;
-
-    __sha256_transf(ctx, ctx->block, 1);
-    __sha256_transf(ctx, shifted_message, block_nb);
-
-    rem_len = new_len % DSHA256_BLOCK_SIZE;
-
-    memcpy(ctx->block, &shifted_message[block_nb << 6], rem_len);
-
-    ctx->len = rem_len;
-    ctx->tot_len += (block_nb + 1) << 6;
-}
-
-static void __sha256_final(sha256_ctx_t* ctx, unsigned char* digest)
-{
-    unsigned int block_nb;
-    unsigned int pm_len;
-    unsigned int len_b;
-
-    block_nb = (1 + ((DSHA256_BLOCK_SIZE - 9) < (ctx->len % DSHA256_BLOCK_SIZE)));
-
-    len_b = (ctx->tot_len + ctx->len) << 3;
-    pm_len = block_nb << 6;
-
-    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
-    ctx->block[ctx->len] = 0x80;
-    DUNPACK32(len_b, ctx->block + pm_len - 4);
-
-    __sha256_transf(ctx, ctx->block, block_nb);
-
-    DUNPACK32(ctx->h[0], &digest[ 0]);
-    DUNPACK32(ctx->h[1], &digest[ 4]);
-    DUNPACK32(ctx->h[2], &digest[ 8]);
-    DUNPACK32(ctx->h[3], &digest[12]);
-    DUNPACK32(ctx->h[4], &digest[16]);
-    DUNPACK32(ctx->h[5], &digest[20]);
-    DUNPACK32(ctx->h[6], &digest[24]);
-    DUNPACK32(ctx->h[7], &digest[28]);
-}
-
-void digest_sha256(const unsigned char* message, unsigned int len, unsigned char* digest)
-{
-    sha256_ctx_t ctx;
-
-    __sha256_init(&ctx);
-    __sha256_update(&ctx, message, len);
-    __sha256_final(&ctx, digest);
-}
-
-#ifndef DNOT_INCLUDE_C_HEADER
-int digest_sha256_file(const char* file, unsigned char* digest)
-{
-    FILE *f;
-    unsigned int n;
-    sha256_ctx_t ctx;
-    unsigned char buf[1024];
-
-    if ((f = fopen(file, "rb")) == NULL) {
-        return (-1);
-    }
-
-    __sha256_init(&ctx);
-    while ((n = fread( buf, 1, sizeof( buf ), f)) > 0) {
-        __sha256_update(&ctx, buf, n);
-    }
-
-    __sha256_final(&ctx, digest);
-
-    fclose(f);
-
-    return 0;
-}
-
-void* digest_sha256_init()
-{
-    sha256_ctx_t* ctx = (sha256_ctx_t*) malloc(sizeof(sha256_ctx_t));
-    if (ctx) {
-        __sha256_init(ctx);
-        return (void*) ctx;
-    }
-
-    printf("error: digest_sha256_init, malloc fail\n");
-    return NULL;
-}
-
-void digest_sha256_update(void* ctx, const unsigned char* message, unsigned int len)
-{
-    if (ctx && message && len) {
-        __sha256_update((sha256_ctx_t* )ctx, message, len);
-    } else {
-        printf("error: digest_sha256_update, bad input parameters\n");
-    }
-    return;
-}
-
-void digest_sha256_final(void* ctx, unsigned char* digest)
-{
-    if (ctx && digest) {
-        __sha256_final((sha256_ctx_t* )ctx, digest);
-    } else {
-        printf("error: digest_sha256_final, bad input parameters\n");
-    }
-}
-#endif
-
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+
+#include "cryptography_if.h"
+
+#ifndef DNOT_INCLUDE_C_HEADER
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#else
+#include <bldfunc.h>
+#endif
+
+#define DSHA256_BLOCK_SIZE  (512 / 8)
+
+typedef struct {
+    unsigned int tot_len;
+    unsigned int len;
+    unsigned char block[2 * DSHA256_BLOCK_SIZE];
+    unsigned int h[8];
+} sha256_ctx_t;
+
+#define DSHFR(x, n)    (x >> n)
+#define DROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
+#define DROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
+#define DCH(x, y, z)  ((x & y) ^ (~x & z))
+#define DMAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
+
+#define DSHA256_F1(x) (DROTR(x,  2) ^ DROTR(x, 13) ^ DROTR(x, 22))
+#define DSHA256_F2(x) (DROTR(x,  6) ^ DROTR(x, 11) ^ DROTR(x, 25))
+#define DSHA256_F3(x) (DROTR(x,  7) ^ DROTR(x, 18) ^ DSHFR(x,  3))
+#define DSHA256_F4(x) (DROTR(x, 17) ^ DROTR(x, 19) ^ DSHFR(x, 10))
+
+#define DUNPACK32(x, str)                      \
+    {                                             \
+        *((str) + 3) = (unsigned char) ((x));       \
+        *((str) + 2) = (unsigned char) ((x) >>  8);       \
+        *((str) + 1) = (unsigned char) ((x) >> 16);       \
+        *((str) + 0) = (unsigned char) ((x) >> 24);       \
+    }
+
+#define DPACK32(str, x)                        \
+    {                                             \
+        *(x) =   ((unsigned int) *((str) + 3))    \
+                 | ((unsigned int) *((str) + 2) <<  8)    \
+                 | ((unsigned int) *((str) + 1) << 16)    \
+                 | ((unsigned int) *((str) + 0) << 24);   \
+    }
+
+#define DSHA256_SCR(i)                         \
+    {                                             \
+        w[i] =  DSHA256_F4(w[i -  2]) + w[i -  7]  \
+                + DSHA256_F3(w[i - 15]) + w[i - 16]; \
+    }
+
+#define DSHA256_EXP(a, b, c, d, e, f, g, h, j)               \
+    {                                                           \
+        t1 = wv[h] + DSHA256_F2(wv[e]) + DCH(wv[e], wv[f], wv[g]) \
+             + g_sha256_k[j] + w[j];                              \
+        t2 = DSHA256_F1(wv[a]) + DMAJ(wv[a], wv[b], wv[c]);       \
+        wv[d] += t1;                                            \
+        wv[h] = t1 + t2;                                        \
+    }
+
+static unsigned int g_sha256_h0[8] = {
+    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
+    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
+};
+
+static unsigned int g_sha256_k[64] = {
+    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+static void __sha256_transf(sha256_ctx_t* ctx, const unsigned char* message, unsigned int block_nb)
+{
+    unsigned int w[64];
+    unsigned int wv[8];
+
+    unsigned int t1, t2;
+    const unsigned char *sub_block;
+    int i;
+
+    for (i = 0; i < (int) block_nb; i++) {
+        sub_block = message + (i << 6);
+
+        DPACK32(&sub_block[ 0], &w[ 0]); DPACK32(&sub_block[ 4], &w[ 1]);
+        DPACK32(&sub_block[ 8], &w[ 2]); DPACK32(&sub_block[12], &w[ 3]);
+        DPACK32(&sub_block[16], &w[ 4]); DPACK32(&sub_block[20], &w[ 5]);
+        DPACK32(&sub_block[24], &w[ 6]); DPACK32(&sub_block[28], &w[ 7]);
+        DPACK32(&sub_block[32], &w[ 8]); DPACK32(&sub_block[36], &w[ 9]);
+        DPACK32(&sub_block[40], &w[10]); DPACK32(&sub_block[44], &w[11]);
+        DPACK32(&sub_block[48], &w[12]); DPACK32(&sub_block[52], &w[13]);
+        DPACK32(&sub_block[56], &w[14]); DPACK32(&sub_block[60], &w[15]);
+
+        DSHA256_SCR(16); DSHA256_SCR(17); DSHA256_SCR(18); DSHA256_SCR(19);
+        DSHA256_SCR(20); DSHA256_SCR(21); DSHA256_SCR(22); DSHA256_SCR(23);
+        DSHA256_SCR(24); DSHA256_SCR(25); DSHA256_SCR(26); DSHA256_SCR(27);
+        DSHA256_SCR(28); DSHA256_SCR(29); DSHA256_SCR(30); DSHA256_SCR(31);
+        DSHA256_SCR(32); DSHA256_SCR(33); DSHA256_SCR(34); DSHA256_SCR(35);
+        DSHA256_SCR(36); DSHA256_SCR(37); DSHA256_SCR(38); DSHA256_SCR(39);
+        DSHA256_SCR(40); DSHA256_SCR(41); DSHA256_SCR(42); DSHA256_SCR(43);
+        DSHA256_SCR(44); DSHA256_SCR(45); DSHA256_SCR(46); DSHA256_SCR(47);
+        DSHA256_SCR(48); DSHA256_SCR(49); DSHA256_SCR(50); DSHA256_SCR(51);
+        DSHA256_SCR(52); DSHA256_SCR(53); DSHA256_SCR(54); DSHA256_SCR(55);
+        DSHA256_SCR(56); DSHA256_SCR(57); DSHA256_SCR(58); DSHA256_SCR(59);
+        DSHA256_SCR(60); DSHA256_SCR(61); DSHA256_SCR(62); DSHA256_SCR(63);
+
+        wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
+        wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
+        wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
+        wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
+
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 0); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 1);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 2); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 3);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 4); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 5);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 6); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 7);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 8); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 9);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 10); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 11);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 12); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 13);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 14); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 15);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 16); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 17);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 18); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 19);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 20); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 21);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 22); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 23);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 24); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 25);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 26); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 27);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 28); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 29);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 30); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 31);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 32); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 33);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 34); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 35);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 36); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 37);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 38); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 39);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 40); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 41);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 42); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 43);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 44); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 45);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 46); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 47);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 48); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 49);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 50); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 51);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 52); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 53);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 54); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 55);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 56); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 57);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 58); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 59);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 60); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 61);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 62); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 63);
+
+        ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
+        ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
+        ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
+        ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
+    }
+}
+
+static void __sha256_init(sha256_ctx_t *ctx)
+{
+    ctx->h[0] = g_sha256_h0[0]; ctx->h[1] = g_sha256_h0[1];
+    ctx->h[2] = g_sha256_h0[2]; ctx->h[3] = g_sha256_h0[3];
+    ctx->h[4] = g_sha256_h0[4]; ctx->h[5] = g_sha256_h0[5];
+    ctx->h[6] = g_sha256_h0[6]; ctx->h[7] = g_sha256_h0[7];
+
+    ctx->len = 0;
+    ctx->tot_len = 0;
+}
+
+static void __sha256_update(sha256_ctx_t* ctx, const unsigned char* message, unsigned int len)
+{
+    unsigned int block_nb;
+    unsigned int new_len, rem_len, tmp_len;
+    const unsigned char *shifted_message;
+
+    tmp_len = DSHA256_BLOCK_SIZE - ctx->len;
+    rem_len = len < tmp_len ? len : tmp_len;
+
+    memcpy(&ctx->block[ctx->len], message, rem_len);
+
+    if (ctx->len + len < DSHA256_BLOCK_SIZE) {
+        ctx->len += len;
+        return;
+    }
+
+    new_len = len - rem_len;
+    block_nb = new_len / DSHA256_BLOCK_SIZE;
+
+    shifted_message = message + rem_len;
+
+    __sha256_transf(ctx, ctx->block, 1);
+    __sha256_transf(ctx, shifted_message, block_nb);
+
+    rem_len = new_len % DSHA256_BLOCK_SIZE;
+
+    memcpy(ctx->block, &shifted_message[block_nb << 6], rem_len);
+
+    ctx->len = rem_len;
+    ctx->tot_len += (block_nb + 1) << 6;
+}
+
+static void __sha256_final(sha256_ctx_t* ctx, unsigned char* digest)
+{
+    unsigned int block_nb;
+    unsigned int pm_len;
+    unsigned int len_b;
+
+    block_nb = (1 + ((DSHA256_BLOCK_SIZE - 9) < (ctx->len % DSHA256_BLOCK_SIZE)));
+
+    len_b = (ctx->tot_len + ctx->len) << 3;
+    pm_len = block_nb << 6;
+
+    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
+    ctx->block[ctx->len] = 0x80;
+    DUNPACK32(len_b, ctx->block + pm_len - 4);
+
+    __sha256_transf(ctx, ctx->block, block_nb);
+
+    DUNPACK32(ctx->h[0], &digest[ 0]);
+    DUNPACK32(ctx->h[1], &digest[ 4]);
+    DUNPACK32(ctx->h[2], &digest[ 8]);
+    DUNPACK32(ctx->h[3], &digest[12]);
+    DUNPACK32(ctx->h[4], &digest[16]);
+    DUNPACK32(ctx->h[5], &digest[20]);
+    DUNPACK32(ctx->h[6], &digest[24]);
+    DUNPACK32(ctx->h[7], &digest[28]);
+}
+
+void digest_sha256(const unsigned char* message, unsigned int len, unsigned char* digest)
+{
+    sha256_ctx_t ctx;
+
+    __sha256_init(&ctx);
+    __sha256_update(&ctx, message, len);
+    __sha256_final(&ctx, digest);
+}
+
+#ifndef DNOT_INCLUDE_C_HEADER
+int digest_sha256_file(const char* file, unsigned char* digest)
+{
+    FILE *f;
+    unsigned int n;
+    sha256_ctx_t ctx;
+    unsigned char buf[1024];
+
+    if ((f = fopen(file, "rb")) == NULL) {
+        return (-1);
+    }
+
+    __sha256_init(&ctx);
+    while ((n = fread( buf, 1, sizeof( buf ), f)) > 0) {
+        __sha256_update(&ctx, buf, n);
+    }
+
+    __sha256_final(&ctx, digest);
+
+    fclose(f);
+
+    return 0;
+}
+
+void* digest_sha256_init()
+{
+    sha256_ctx_t* ctx = (sha256_ctx_t*) malloc(sizeof(sha256_ctx_t));
+    if (ctx) {
+        __sha256_init(ctx);
+        return (void*) ctx;
+    }
+
+    printf("error: digest_sha256_init, malloc fail\n");
+    return NULL;
+}
+
+void digest_sha256_update(void* ctx, const unsigned char* message, unsigned int len)
+{
+    if (ctx && message && len) {
+        __sha256_update((sha256_ctx_t* )ctx, message, len);
+    } else {
+        printf("error: digest_sha256_update, bad input parameters\n");
+    }
+    return;
+}
+
+void digest_sha256_final(void* ctx, unsigned char* digest)
+{
+    if (ctx && digest) {
+        __sha256_final((sha256_ctx_t* )ctx, digest);
+    } else {
+        printf("error: digest_sha256_final, bad input parameters\n");
+    }
+}
+#endif
+
diff --git a/src/bld/secure/pk_rsa.c b/src/bld/secure/pk_rsa.c
index 19ce590..05c87b0 100644
--- a/src/bld/secure/pk_rsa.c
+++ b/src/bld/secure/pk_rsa.c
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * pk_rsa.c
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include "cryptography_if.h"
 
@@ -23,8 +41,37 @@
 #endif
 
 #include "big_number.h"
-#include "tiny_asn1.h"
-#include "tiny_oid.h"
+
+//ASN1
+#define ASN1_BOOLEAN                 0x01
+#define ASN1_INTEGER                 0x02
+#define ASN1_BIT_STRING              0x03
+#define ASN1_OCTET_STRING            0x04
+#define ASN1_NULL                    0x05
+#define ASN1_OID                     0x06
+#define ASN1_UTF8_STRING             0x0C
+#define ASN1_SEQUENCE                0x10
+#define ASN1_SET                     0x11
+#define ASN1_PRINTABLE_STRING        0x13
+#define ASN1_T61_STRING              0x14
+#define ASN1_IA5_STRING              0x16
+#define ASN1_UTC_TIME                0x17
+#define ASN1_GENERALIZED_TIME        0x18
+#define ASN1_UNIVERSAL_STRING        0x1C
+#define ASN1_BMP_STRING              0x1E
+#define ASN1_PRIMITIVE               0x00
+#define ASN1_CONSTRUCTED             0x20
+#define ASN1_CONTEXT_SPECIFIC        0x80
+
+//OIDs
+static unsigned char gsOIDDigestSHA256[] = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01};
+//{ joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 1 }
+
+//static unsigned char gsOIDDigestSHA384[] = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02};
+//{ joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 2 }
+
+//static unsigned char gsOIDDigestSHA512[] = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03};
+//{ joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 3 }
 
 #define DRSA_SIGN   1
 #define DRSA_CRYPT  2
@@ -258,10 +305,6 @@ static int __rsa_private(rsa_context_t* ctx, const unsigned char* input, unsigne
     int ret;
     unsigned int olen;
     big_number_t T, T1, T2;
-    //big_number_t* Vi, * Vf;
-
-    //Vi = &ctx->Vi;
-    //Vf = &ctx->Vf;
 
     big_number_init(&T);
     big_number_init(&T1);
@@ -304,20 +347,17 @@ int rsa_sha256_sign(rsa_context_t* ctx, const unsigned char* hash, unsigned char
 {
     unsigned int nb_pad, olen, oid_size = 0;
     unsigned char *p = sig;
-    const char *oid = NULL;
 
     olen = ctx->len;
     nb_pad = olen - 3;
 
-    if (oid_get_oid_by_sha(CRYPTO_SHA_TYPE_SHA256, &oid, &oid_size) != 0) {
-        return CRYPTO_ECODE_BAD_INPUT_DATA;
-    }
+    oid_size = sizeof(gsOIDDigestSHA256);
 
     nb_pad -= 10 + oid_size;
     nb_pad -= DCRYPTO_SHA256_DIGEST_LENGTH;
 
     if (( nb_pad < 8 ) || ( nb_pad > olen )) {
-        return( CRYPTO_ECODE_BAD_INPUT_DATA );
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
     }
 
     *p++ = 0;
@@ -326,18 +366,26 @@ int rsa_sha256_sign(rsa_context_t* ctx, const unsigned char* hash, unsigned char
     p += nb_pad;
     *p++ = 0;
 
+    //ASN1 1
     *p++ = ASN1_SEQUENCE | ASN1_CONSTRUCTED;
     *p++ = (unsigned char) (0x08 + oid_size + DCRYPTO_SHA256_DIGEST_LENGTH);
+
+    //ASN1 2
     *p++ = ASN1_SEQUENCE | ASN1_CONSTRUCTED;
     *p++ = (unsigned char) (0x04 + oid_size);
+
+    //OID
     *p++ = ASN1_OID;
     *p++ = oid_size & 0xFF;
-    memcpy( p, oid, oid_size );
+    memcpy(p, gsOIDDigestSHA256, oid_size);
     p += oid_size;
+
     *p++ = ASN1_NULL;
     *p++ = 0x00;
     *p++ = ASN1_OCTET_STRING;
     *p++ = DCRYPTO_SHA256_DIGEST_LENGTH;
+
+    //digest
     memcpy(p, hash, DCRYPTO_SHA256_DIGEST_LENGTH);
 
     return __rsa_private(ctx, sig, sig);
@@ -346,11 +394,9 @@ int rsa_sha256_sign(rsa_context_t* ctx, const unsigned char* hash, unsigned char
 int rsa_sha256_verify(rsa_context_t* ctx, const unsigned char* hash, const unsigned char* sig)
 {
     int ret;
-    unsigned int len, siglen, asn1_len;
-    unsigned char *p, *end;
+    unsigned int len, siglen;
+    unsigned char *p;
     unsigned char buf[D_BIG_NUMBER_MAX_SIZE];
-    sha_type_t sha_type = CRYPTO_SHA_TYPE_SHA256;
-    asn1_buf oid;
 
     siglen = ctx->len;
 
@@ -379,59 +425,58 @@ int rsa_sha256_verify(rsa_context_t* ctx, const unsigned char* hash, const unsig
 
     p++;
     len = siglen - ( p - buf );
-    end = p + len;
 
-    if ((ret = asn1_get_tag( &p, end, &asn1_len, ASN1_CONSTRUCTED | ASN1_SEQUENCE)) != CRYPTO_ECODE_OK) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL);
+    //check ASN1 header 1
+    if ((ASN1_CONSTRUCTED | ASN1_SEQUENCE) != p[0]) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p ++;
 
-    if (asn1_len + 2 != len) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 1);
+    //check ASN1 size 1
+    if (p[0] & 0x80) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
-
-    if ((ret = asn1_get_tag( &p, end, &asn1_len, ASN1_CONSTRUCTED | ASN1_SEQUENCE)) != 0) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 2);
+    if (p[0] + 2 != len) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p ++;
 
-    if (asn1_len + 6 + DCRYPTO_SHA256_DIGEST_LENGTH != len) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 3);
+    //check ASN1 header 2
+    if ((ASN1_CONSTRUCTED | ASN1_SEQUENCE) != p[0]) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p ++;
 
-    if ((ret = asn1_get_tag( &p, end, &oid.len, ASN1_OID)) != CRYPTO_ECODE_OK) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 4);
+    //check ASN1 size 2
+    if (p[0] + 6 + DCRYPTO_SHA256_DIGEST_LENGTH != len) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p ++;
 
-    oid.p = p;
-    p += oid.len;
-
-    if (oid_get_sha_type(&oid, &sha_type) != 0) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 5);
+    //check ASN1 for OID
+    if ((ASN1_OID != p[0]) || (sizeof(gsOIDDigestSHA256) != p[1])) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p += 2;
 
-    //if (CRYPTO_SHA_TYPE_SHA256 != sha_type ) {
-    //    return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 6);
-    //}
-
-    if ((ret = asn1_get_tag(&p, end, &asn1_len, ASN1_NULL)) != CRYPTO_ECODE_OK) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 7);
+    //check OID
+    if (memcmp(gsOIDDigestSHA256, p, sizeof(gsOIDDigestSHA256))) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p += sizeof(gsOIDDigestSHA256);
 
-    if ((ret = asn1_get_tag(&p, end, &asn1_len, ASN1_OCTET_STRING)) != CRYPTO_ECODE_OK) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 8);
+    if ((p[0] != ASN1_NULL) || (0 != p[1])) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p += 2;
 
-    if (asn1_len != DCRYPTO_SHA256_DIGEST_LENGTH) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 9);
+    if ((p[0] != ASN1_OCTET_STRING) || (DCRYPTO_SHA256_DIGEST_LENGTH != p[1])) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p += 2;
 
     if (memcmp( p, hash, DCRYPTO_SHA256_DIGEST_LENGTH) != 0) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 10);
-    }
-
-    p += DCRYPTO_SHA256_DIGEST_LENGTH;
-
-    if (p != end) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 11);
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
 
     return CRYPTO_ECODE_OK;
diff --git a/src/bld/secure/platform_misc.c b/src/bld/secure/platform_misc.c
new file mode 100644
index 0000000..709344a
--- /dev/null
+++ b/src/bld/secure/platform_misc.c
@@ -0,0 +1,265 @@
+/*******************************************************************************
+ * platform_misc.c
+ *
+ * History:
+ *  2015/11/24 - [Zhi He] create file for secure boot logic
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <bldfunc.h>
+#include <ambhw/idc.h>
+#include <ambhw/gpio.h>
+#include <ambhw/dma.h>
+#include <ambhw/fio.h>
+#include <ambhw/i2s.h>
+#include <ambhw/timer.h>
+#include <sdmmc.h>
+
+#include "secure_boot.h"
+
+void rct_timer_delay_ticks(u32 ticks)
+{
+	u32 begin_time = rct_timer_get_tick();
+	u32 end_time = begin_time + ticks;
+	u32 cur_time = 0;
+
+	if (end_time > begin_time) {
+		while (1) {
+			cur_time = rct_timer_get_tick();
+			if (cur_time > end_time)
+				break;
+		}
+	} else {
+		while (1) {
+			cur_time = rct_timer_get_tick();
+			if ((cur_time > end_time) && (cur_time < begin_time))
+				break;
+		}
+	}
+}
+
+u32 rct_timer_get_frequency_div_1000()
+{
+#if (RCT_TIMER_INSTANCES >= 1)
+	return (REF_CLK_FREQ / 1000);
+#else
+	return (get_apb_bus_freq_hz() / 1000);
+#endif
+}
+
+int uart_get_readable_string(const char* begin, int head_length, char* string, int number)
+{
+	int c;
+	int i = 0;
+
+uart_get_readable_string_resync_get:
+
+	for (i = 0; i < head_length; i++) {
+		while (uart_poll() == 0) {
+			continue;
+		}
+
+		c = uart_read();
+
+		if ((c == '\r') || (c == '\n')) {
+			goto uart_get_readable_string_resync_get;
+		}
+
+		if (c != begin[i]) {
+			putchar((char) c);
+			putstr(":read header fail\r\n");
+			return (-1);
+		}
+	}
+
+	for (i = 0; i < number; i++) {
+		while (uart_poll() == 0) {
+			continue;
+		}
+
+		c = uart_read();
+		if ((c == '\r') || (c == '\n')) {
+			putstr("read content fail\r\n");
+			return (-3);
+		}
+		string[i] = c;
+	}
+
+	return 0;
+}
+
+int uart_get_readable_string_variable_length(const char* begin, char* string, int number)
+{
+	int c;
+	int i = 0;
+
+uart_get_readable_string_variable_length_resync_get:
+
+	for (i = 0; i < 4; i++) {
+		while (uart_poll() == 0) {
+			continue;
+		}
+
+		c = uart_read();
+
+		if ((c == '\r') || (c == '\n')) {
+			goto uart_get_readable_string_variable_length_resync_get;
+		}
+
+		if (c != begin[i]) {
+			putchar((char) c);
+			putstr(":read header fail\r\n");
+			return (-1);
+		}
+	}
+
+	for (i = 0; i < number; i++) {
+		while (uart_poll() == 0) {
+			continue;
+		}
+
+		c = uart_read();
+		if ((c == '\r') || (c == '\n')) {
+			break;
+		}
+		string[i] = c;
+	}
+
+	if (i == number) {
+		putstr("read string exceed length\r\n");
+		return (-2);
+	}
+
+	return 0;
+}
+
+int uart_get_rsakey_1024(void* p_key)
+{
+	int ret = 0;
+	rsa_key_t* p_rsa_key = (rsa_key_t*) p_key;
+
+	ret = uart_get_readable_string("N = ", 4, p_rsa_key->n, 256);
+	if (ret) {
+		putstr("read n fail\r\n");
+		return ret;
+	}
+
+	ret = uart_get_readable_string_variable_length("E = ", p_rsa_key->e, 16);
+	if (ret) {
+		putstr("read e fail\r\n");
+		return ret;
+	}
+
+	ret = uart_get_readable_string("D = ", 4, p_rsa_key->d, 256);
+	if (ret) {
+		putstr("read d fail\r\n");
+		return ret;
+	}
+
+	ret = uart_get_readable_string("P = ", 4, p_rsa_key->p, 128);
+	if (ret) {
+		putstr("read p fail\r\n");
+		return ret;
+	}
+
+	ret = uart_get_readable_string("Q = ", 4, p_rsa_key->q, 128);
+	if (ret) {
+		putstr("read q fail\r\n");
+		return ret;
+	}
+
+	ret = uart_get_readable_string("DP = ", 5, p_rsa_key->dp, 128);
+	if (ret) {
+		putstr("read dp fail\r\n");
+		return ret;
+	}
+
+	ret = uart_get_readable_string("DQ = ", 5, p_rsa_key->dq, 128);
+	if (ret) {
+		putstr("read dq fail\r\n");
+		return ret;
+	}
+
+	ret = uart_get_readable_string("QP = ", 5, p_rsa_key->qp, 128);
+	if (ret) {
+		putstr("read qp fail\r\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+void uart_print_rsakey_1024(void* p_key)
+{
+	rsa_key_t* p_rsa_key = (rsa_key_t*) p_key;
+
+	uart_putstr("print rsa key for debug:\r\n");
+
+	uart_putstr("N = ");
+	uart_putstr((const char*) p_rsa_key->n);
+	uart_putstr("\r\n");
+
+	uart_putstr("E = ");
+	uart_putstr((const char*) p_rsa_key->e);
+	uart_putstr("\r\n");
+
+	uart_putstr("D = ");
+	uart_putstr((const char*) p_rsa_key->d);
+	uart_putstr("\r\n");
+
+	uart_putstr("P = ");
+	uart_putstr((const char*) p_rsa_key->p);
+	uart_putstr("\r\n");
+
+	uart_putstr("Q = ");
+	uart_putstr((const char*) p_rsa_key->q);
+	uart_putstr("\r\n");
+
+	uart_putstr("DP = ");
+	uart_putstr((const char*) p_rsa_key->dp);
+	uart_putstr("\r\n");
+
+	uart_putstr("DQ = ");
+	uart_putstr((const char*) p_rsa_key->dq);
+	uart_putstr("\r\n");
+
+	uart_putstr("QP = ");
+	uart_putstr((const char*) p_rsa_key->qp);
+	uart_putstr("\r\n");
+
+	return;
+}
+
+int uart_get_onechar_blocked()
+{
+	while (uart_poll() == 0) {
+		continue;
+	}
+
+	return uart_read();
+}
+
diff --git a/src/bld/secure/platform_misc.h b/src/bld/secure/platform_misc.h
new file mode 100644
index 0000000..3a20dc6
--- /dev/null
+++ b/src/bld/secure/platform_misc.h
@@ -0,0 +1,45 @@
+/*******************************************************************************
+ * platform_misc.h
+ *
+ * History:
+ *  2015/11/19 - [Zhi He] create file for secure boot logic
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#ifndef __PLATFORM_MISC_H__
+#define __PLATFORM_MISC_H__
+
+void rct_timer_delay_ticks(u32 ticks);
+u32 rct_timer_get_frequency_div_1000();
+int uart_get_readable_string(const char* begin, int head_length, char* string, int number);
+int uart_get_readable_string(const char* begin, int head_length, char* string, int number);
+int uart_get_rsakey_1024(void* p_key);
+void uart_print_rsakey_1024(void* p_key);
+int uart_get_onechar_blocked();
+
+#endif
+
diff --git a/src/bld/secure/secure_boot.c b/src/bld/secure/secure_boot.c
index b4de984..5f3ba58 100644
--- a/src/bld/secure/secure_boot.c
+++ b/src/bld/secure/secure_boot.c
@@ -1,17 +1,34 @@
-/*
+/*******************************************************************************
  * secure_boot.c
  *
  * History:
- *	2015/07/01 - [Zhi He] create file for secure boot logic
+ *  2015/07/01 - [Zhi He] create file for secure boot logic
  *
- * Copyright (C) 2015 -2025, Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include <bldfunc.h>
 #include <ambhw/idc.h>
@@ -53,12 +70,12 @@ static void __print_memory(unsigned char* p, unsigned int size)
 }
 #endif
 
-int secure_boot_init()
+int secure_boot_init(unsigned char i2c_index, unsigned int i2c_freq)
 {
 	//putstr("secure_boot_init\r\n");
 	if (!gp_atsha204) {
-		idc_bld_init(0, 100 * 1000);
-		gp_atsha204 = libatsha204_open();
+		idc_bld_init(i2c_index, i2c_freq);
+		gp_atsha204 = libatsha204_open(i2c_index);
 		if (!gp_atsha204) {
 			putstr("[error]: libatsha204_open fail\r\n");
 			return (-1);
@@ -75,7 +92,7 @@ int secure_boot_init()
 
 			ret = libatsha204_initialize_otp_and_data_zone(gp_atsha204);
 			if (ret) {
-				putstr("[error]: libatsha204_initialize_config_zone fail\r\n");
+				putstr("[error]: libatsha204_initialize_otp_and_data_zone fail\r\n");
 				return (-5);
 			} else {
 				putstr("atsha204 init otp and data zone done\r\n");
diff --git a/src/bld/secure/secure_boot.h b/src/bld/secure/secure_boot.h
index b7b4f45..747ae0b 100644
--- a/src/bld/secure/secure_boot.h
+++ b/src/bld/secure/secure_boot.h
@@ -1,17 +1,34 @@
-/*
+/*******************************************************************************
  * secure_boot.h
  *
  * History:
- *	2015/07/01 - [Zhi He] create file for secure boot logic
+ *  2015/07/01 - [Zhi He] create file for secure boot logic
  *
- * Copyright (C) 2015 -2025, Ambarella, Inc.
+ * Copyright (c) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #ifndef __SECURE_BOOT_H__
 #define __SECURE_BOOT_H__
@@ -30,7 +47,7 @@ typedef struct {
 	char qp[(D_RSA_KEY_BN_TXT_LENGTH/2) + 8];
 } rsa_key_t;
 
-int secure_boot_init();
+int secure_boot_init(unsigned char i2c_index, unsigned int i2c_freq);
 
 int generate_firmware_hw_signature(unsigned char* p_firmware, unsigned int firmware_length);
 int verify_firmware_hw_signature(unsigned char* p_firmware, unsigned int firmware_length);
diff --git a/src/bld/secure/secure_boot_main.c b/src/bld/secure/secure_boot_main.c
new file mode 100644
index 0000000..8aedc94
--- /dev/null
+++ b/src/bld/secure/secure_boot_main.c
@@ -0,0 +1,258 @@
+/**
+ * bld/secure/secure_boot_main.c
+ *
+ * History:
+ *    2015/11/24 - [Zhi He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <ambhw/uart.h>
+#include <ambhw/nand.h>
+#include <ambhw/spinor.h>
+#include <ambhw/usbdc.h>
+#include <ambhw/gpio.h>
+
+#include "cryptography_if.h"
+#include "platform_misc.h"
+#include "secure_boot.h"
+
+/* ==========================================================================*/
+static const char *AM_SECURE_BOOT_LOGO =	\
+	"\r\n"
+	"    _    __  __   ____                             ____              _\r\n"	\
+	"   / \\  |  \\/  | / ___|  ___  ___ _   _ _ __ ___  | __ )  ___   ___ | |_\r\n"	\
+	"  / _ \\ | |\\/| | \\___ \\ / _ \\/ __| | | | '__/ _ \\ |  _ \\ / _ \\ / _ \\| __|\r\n"	\
+	" / ___ \\| |  | |  ___) |  __/ (__| |_| | | |  __/ | |_) | (_) | (_) | |_\r\n"	\
+	"/_/   \\_\\_|  |_| |____/ \\___|\\___|\\__,_|_|  \\___| |____/ \\___/ \\___/ \\__|\r\n"	\
+	"--------------------------------------------------------------------------\r\n" \
+	"Amboot(R) (SecureBoot) Ambarella(R) Copyright (C) 2015\r\n";
+
+/* ==========================================================================*/
+
+int secure_boot_main(int ret_val, flpart_table_t *pptb)
+{
+	int h;
+#if defined(CONFIG_AMBOOT_COMMAND_SUPPORT)
+	int l;
+	char cmd[MAX_CMDLINE_LEN];
+#endif
+	int secure_boot_ret = 0;
+	int ask_for_debug = 1;
+	int force_reinitialize_for_debug = 0;
+
+	unsigned char i2c_index = 0;
+	unsigned int i2c_freq = 100 * 1000;
+
+	i2c_index = 0; //i2c index should be set correctly, according to HW connection
+
+	putstr("i2c index:");
+	putbyte(i2c_index);
+	putstr("\r\n");
+	secure_boot_ret = secure_boot_init(i2c_index, i2c_freq);
+	if (0 > secure_boot_ret) {
+		putstr("[secure boot check fail]: no cryptochip found, exit..\r\n");
+		goto __am_secure_boot_console;
+	} else if (1 == secure_boot_ret) {
+		goto __force_reinitialize_secure_boot;
+	} else {
+		if (!pptb->dev.secure_boot_init) {
+			putstr("[secure boot check fail]: cryptochip is initialized, but firmware is not initialized\r\n");
+			if (ask_for_debug) {
+				int c = 0x0;
+				putstr("[debug]: do you want force re-initialize?\r\n");
+				c = uart_get_onechar_blocked();
+				if (('y' == c) || ('Y' == c)) {
+					goto __force_reinitialize_secure_boot;
+				}
+			}
+			putstr("fail 1, exit...\r\n");
+			goto __am_secure_boot_console;
+		} else {
+			rsa_context_t rsa_content;
+
+			//putstr("rsakey-n:\r\n");
+			//putstr((const char*) pptb->dev.rsa_key_n);
+			//putstr("\r\nrsakey-e:\r\n");
+			//putstr((const char*) pptb->dev.rsa_key_e);
+			//putstr("\r\n");
+
+			secure_boot_ret = verify_and_fill_pubkey(&pptb->dev, &rsa_content);
+			if (secure_boot_ret) {
+				putstr("[secure boot check fail]: invalid rsa pubkey\r\n");
+				if (ask_for_debug) {
+					int c = 0x0;
+					putstr("[debug]: do you want force re-initialize?\r\n");
+					c = uart_get_onechar_blocked();
+					if (('y' == c) || ('Y' == c)) {
+						goto __force_reinitialize_secure_boot;
+					}
+				}
+				putstr("fail 2, exit...\r\n");
+				goto __am_secure_boot_console;
+			} else {
+				putstr("[secure boot check]: key is a valid rsa pubkey\r\n");
+			}
+
+			secure_boot_ret = verify_rsapubkey_hw_signature((unsigned char *) pptb->dev.rsa_key_n, 256 + 4 + 16);
+			if (secure_boot_ret) {
+				putstr("[secure boot check fail]: rsa pubkey is modified?\r\n");
+				if (ask_for_debug) {
+					int c = 0x0;
+					putstr("[debug]: do you want force re-initialize?\r\n");
+					c = uart_get_onechar_blocked();
+					if (('y' == c) || ('Y' == c)) {
+						goto __force_reinitialize_secure_boot;
+					}
+				}
+				putstr("fail 3, exit...\r\n");
+				goto __am_secure_boot_console;
+			} else {
+				putstr("[secure boot check]: verify rsa pubkey OK\r\n");
+			}
+
+			secure_boot_ret = verify_sn_signature(pptb->dev.sn_signature, &rsa_content);
+			if (secure_boot_ret) {
+				putstr("[secure boot check fail]: serial number signature check fail, hardware clone?\r\n");
+				if (ask_for_debug) {
+					int c = 0x0;
+					putstr("[debug]: do you want force re-initialize?\r\n");
+					c = uart_get_onechar_blocked();
+					if (('y' == c) || ('Y' == c)) {
+						goto __force_reinitialize_secure_boot;
+					}
+				}
+				putstr("fail 4, exit...\r\n");
+				goto __am_secure_boot_console;
+			} else {
+				putstr("[secure boot check]: verify serial number signature OK\r\n");
+			}
+
+		}
+	}
+
+	if (force_reinitialize_for_debug) {
+		rsa_key_t rsa_key;
+
+__force_reinitialize_secure_boot:
+
+		putstr("[secure boot for initialization]: please enter rsa key\r\n");
+		memset(&rsa_key, 0x0, sizeof(rsa_key));
+
+		secure_boot_ret = uart_get_rsakey_1024(&rsa_key);
+		if (secure_boot_ret) {
+			putstr("[secure boot for initialization error]: read rsa key fail...\r\n");
+			uart_print_rsakey_1024(&rsa_key);
+			goto __am_secure_boot_console;
+		} else {
+			rsa_context_t rsa_content;
+
+			uart_print_rsakey_1024(&rsa_key);
+
+			secure_boot_ret = verify_and_fill_key(&rsa_key, &rsa_content);
+			if (secure_boot_ret) {
+				putstr("[secure boot for initialization error]: invalid rsa key\r\n");
+				goto __am_secure_boot_console;
+			}
+
+			memcpy(pptb->dev.rsa_key_n, rsa_key.n, 256 + 4);
+			memcpy(pptb->dev.rsa_key_e, rsa_key.e, 16);
+
+			secure_boot_ret = generate_rsapubkey_hw_signature((unsigned char *) pptb->dev.rsa_key_n, 256 + 4 + 16);
+			if (0 == secure_boot_ret) {
+				putstr("[secure boot for initialization]: generate rsa public key hw signature done\r\n");
+			} else {
+				putstr("[secure boot for initialization error]: generate rsa public key hw signature fail\r\n");
+				goto __am_secure_boot_console;
+			}
+
+			secure_boot_ret = generate_sn_signature(pptb->dev.sn_signature, &rsa_content);
+			if (secure_boot_ret) {
+				putstr("[secure boot for initialization error]: sign serial number fail?\r\n");
+				goto __am_secure_boot_console;
+			} else {
+				putstr("[secure boot for initialization]: sign serial number done\r\n");
+			}
+
+			pptb->dev.secure_boot_init = 1;
+			pptb->dev.need_generate_firmware_hw_signature = 1;
+			flprog_set_part_table(pptb);
+		}
+	}
+
+	if (ret_val == 1) {
+		bios(NULL, 0);
+	} else if (ret_val == 2) {
+		bios(pptb->dev.cmdline, 0);  /* Auto BIOS */
+	}  else {
+		ret_val = boot(NULL, 0);  /* Auto boot */
+	}
+
+	switch (ret_val) {
+
+		case FLPROG_ERR_FIRM_HW_SIGN_FAIL:
+		case FLPROG_ERR_FIRM_HW_SIGN_VERIFY_FAIL:
+			putstr("[secure boot check fail]: firmware changed?\r\n");
+			if (ask_for_debug) {
+				int c = 0x0;
+				putstr("[debug]: do you want force re-initialize?\r\n");
+				c = uart_get_onechar_blocked();
+				if (('y' == c) || ('Y' == c)) {
+					goto __force_reinitialize_secure_boot;
+				}
+			}
+			putstr("fail 6, exit...\r\n");
+			goto __am_secure_boot_console;
+			break;
+
+		default:
+			break;
+	}
+
+__am_secure_boot_console:
+
+	putstr(AM_SECURE_BOOT_LOGO);
+	amboot_show_version();
+	rct_show_boot_from(rct_boot_from());
+	rct_show_pll();
+
+#if defined(CONFIG_AMBOOT_COMMAND_SUPPORT)
+	commands_init();
+#endif
+	for (h = 0; ; h++) {
+#if defined(CONFIG_AMBOOT_COMMAND_SUPPORT)
+		putstr("amboot> ");
+		l = uart_getcmd(cmd, sizeof(cmd), 0);
+		if (l > 0) {
+			parse_command(cmd);
+		}
+#endif
+	}
+
+	return 0;
+}
+
diff --git a/src/bld/spi_bld.c b/src/bld/spi_bld.c
new file mode 100644
index 0000000..b5daa17
--- /dev/null
+++ b/src/bld/spi_bld.c
@@ -0,0 +1,306 @@
+/**
+ * bld/spi_bld.c
+ *
+ * Author: Long Zhao <longzhao@ambarella.com>
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <ambhw/spi.h>
+#include <ambhw/gpio.h>
+
+typedef union {
+	struct {
+		u32		dfs	: 4;	/* [3:0] */
+		u32		frf	: 2;	/* [5:4] */
+		u32		scph	: 1;	/* [6] */
+		u32		scpol	: 1;	/* [7] */
+		u32		tmod	: 2;	/* [9:8] */
+		u32		slv_oe	: 1;	/* [10] */
+		u32		srl	: 1;	/* [11] */
+		u32		reserv1	: 5;	/* [16:12] */
+		u32		residue	: 1;	/* [17] */
+		u32		tx_lsb	: 1;	/* [18] */
+		u32		rx_lsb	: 1;	/* [19] */
+		u32		reserv2	: 1;	/* [20] */
+		u32		fc_en	: 1;	/* [21] */
+		u32		rxd_mg	: 4;	/* [25:22] */
+		u32		byte_ws	: 1;	/* [26] */
+		u32		hold	: 1;	/* [27] */
+		u32		reserv3	: 4;	/* [31:28] */
+	} s;
+	u32	w;
+} spi_ctrl0_reg_t;
+
+typedef struct {
+	u8 cs_gpio;
+	u8 act_level;
+	u8 cs_change;
+} spi_cs_info_t;
+
+static spi_cs_info_t spi_cs;
+static u8 cfs_dfs;
+/*===========================================================================*/
+static u32 spi_bld_get_addr(u8 spi_id, u32 reg_offset)
+{
+	u32 reg_adds = 0xFFFFFFFF;
+
+	switch (spi_id) {
+	case SPI_MASTER1:
+		reg_adds = SPI0_REG(reg_offset);
+		break;
+	case SPI_MASTER2:
+		reg_adds = SPI1_REG(reg_offset);
+		break;
+	default:
+		printf("Invalid SPI id: %d\n", spi_id);
+	}
+
+	return reg_adds;
+}
+
+/*===========================================================================*/
+static u32 spi_bld_readl(u8 spi_id, u32 reg_offset)
+{
+	u32 reg_adds;
+	u32 reg_val = 0;
+
+	reg_adds = spi_bld_get_addr(spi_id, reg_offset);
+	if (reg_adds != 0xFFFFFFFF) {
+		reg_val = readl(reg_adds);
+	}
+
+	return reg_val;
+}
+
+static inline void spi_bld_writel(u8 spi_id, u32 reg_offset, u32 reg_val)
+{
+	u32 reg_add;
+
+	reg_add = spi_bld_get_addr(spi_id, reg_offset);
+	writel(reg_add, reg_val);
+}
+
+/*===========================================================================*/
+static inline void spi_bld_enable(u8 spi_id)
+{
+	spi_bld_writel(spi_id, SPI_SSIENR_OFFSET, 1);
+	spi_bld_writel(spi_id, SPI_SER_OFFSET, 1);
+}
+
+static inline void spi_bld_disable(u8 spi_id)
+{
+	spi_bld_writel(spi_id, SPI_SSIENR_OFFSET, 0);
+	spi_bld_writel(spi_id, SPI_IMR_OFFSET, 0);
+	spi_bld_writel(spi_id, SPI_SER_OFFSET, 0);
+}
+
+/*===========================================================================*/
+static void spi_bld_cs_active(void)
+{
+	if (spi_cs.act_level)
+		gpio_set(spi_cs.cs_gpio);
+	else
+		gpio_clr(spi_cs.cs_gpio);
+}
+
+static void spi_bld_cs_deactive(void)
+{
+	if (spi_cs.act_level)
+		gpio_clr(spi_cs.cs_gpio);
+	else
+		gpio_set(spi_cs.cs_gpio);
+}
+
+/*===========================================================================*/
+static void spi_bld_set_baudrate(u8 spi_id, u32 freq_hz)
+{
+	unsigned int ssi_clk;
+	u32 sckdv;
+
+	if (!freq_hz) {
+		return;
+	}
+	ssi_clk = get_ssi_freq_hz();
+	sckdv = ((ssi_clk / freq_hz) + 0x01) & 0xFFFE;
+
+	spi_bld_writel(spi_id, SPI_BAUDR_OFFSET, sckdv);
+}
+
+/*===========================================================================*/
+void spi_bld_init(u8 spi_id, amba_spi_cfg_t *spi_cfg)
+{
+	spi_ctrl0_reg_t reg_cr0;
+
+	spi_bld_disable(spi_id);
+
+	spi_bld_set_baudrate(spi_id, spi_cfg->baud_rate);
+
+	reg_cr0.w = 0;
+	reg_cr0.s.dfs	= spi_cfg->cfs_dfs - 1;
+	reg_cr0.s.scph = (spi_cfg->spi_mode & SPI_CPHA) ? 1 : 0;
+	reg_cr0.s.scpol = (spi_cfg->spi_mode & SPI_CPOL) ? 1 : 0;
+	reg_cr0.s.tx_lsb = (spi_cfg->spi_mode & SPI_LSB_FIRST) ? 1 : 0;
+	reg_cr0.s.rx_lsb = (spi_cfg->spi_mode & SPI_LSB_FIRST) ? 1 : 0;
+	reg_cr0.s.residue = 1;
+	spi_bld_writel(spi_id, SPI_CTRLR0_OFFSET, reg_cr0.w);
+
+	spi_bld_writel(spi_id, SPI_IMR_OFFSET, SPI_TXEIS_MASK);
+	spi_bld_writel(spi_id, SPI_TXFTLR_OFFSET, 0);
+	spi_bld_writel(spi_id, SPI_RXFTLR_OFFSET, 1);
+
+	cfs_dfs = spi_cfg->cfs_dfs;
+
+	spi_cs.cs_gpio = spi_cfg->cs_gpio;
+	spi_cs.act_level = (spi_cfg->spi_mode & SPI_CS_HIGH) ? 1 : 0;
+	spi_cs.cs_change = spi_cfg->cs_change;
+
+	gpio_config_sw_out(spi_cfg->cs_gpio);
+	spi_bld_cs_deactive();
+}
+
+/*===========================================================================*/
+static void spi_bld_polling_status(u8 spi_id)
+{
+	u32 reg_ctrl;
+	int wait_loop = SPI_POLLING_MAX_WAIT_LOOP;
+
+	do {
+		reg_ctrl = spi_bld_readl(spi_id, SPI_SR_OFFSET);
+		wait_loop--;
+	} while (((reg_ctrl & 0x05) != 0x04) && (wait_loop > 0));
+}
+
+/*===========================================================================*/
+static int spi_bld_write_fifo(u8 spi_id, u8 *buf, int len)
+{
+	int i = 0;
+	u16 data;
+	void *wbuf;
+	u32 widx, total_len, xfer_len;
+
+	wbuf = (void *)buf;
+	widx = 0;
+	total_len = (cfs_dfs > 8) ? (len >> 1) : (len);
+
+	while(total_len > widx) {
+		xfer_len = ((total_len - widx) < SPI_DATA_FIFO_SIZE_16) ? (total_len - widx) : SPI_DATA_FIFO_SIZE_16;
+
+		for (i = 0; i < xfer_len; i++) {
+			if (cfs_dfs <= 8)
+				data = ((u8 *)wbuf)[widx++];
+			else
+				data = ((u16 *)wbuf)[widx++];
+			spi_bld_writel(spi_id, SPI_DR_OFFSET, data);
+		}
+		spi_bld_polling_status(spi_id);
+	}
+
+	return len;
+}
+
+/*===========================================================================*/
+static int spi_bld_read_fifo(u8 spi_id, u8 *buf, int len)
+{
+	int i = 0;
+	u16 data;
+	void *rbuf;
+	u32 ridx, total_len, xfer_len, rxflr;
+
+	rbuf = (void *)buf;
+	ridx = 0;
+	total_len = (cfs_dfs > 8) ? (len >> 1) : (len);
+
+	while(total_len > ridx) {
+		/* dummy write */
+		xfer_len = ((total_len - ridx) < SPI_DATA_FIFO_SIZE_16) ? (total_len - ridx) : SPI_DATA_FIFO_SIZE_16;
+
+		for (i = 0; i < xfer_len; i++)
+			spi_bld_writel(spi_id, SPI_DR_OFFSET, SPI_DUMMY_DATA);
+
+		spi_bld_polling_status(spi_id);
+
+		/* read */
+		rxflr = spi_bld_readl(spi_id, SPI_RXFLR_OFFSET);
+		if (xfer_len > rxflr)
+			xfer_len = rxflr;
+		for(i = 0; i < xfer_len; i++) {
+			data = spi_bld_readl(spi_id, SPI_DR_OFFSET);
+			if (cfs_dfs <= 8)
+				((u8 *)rbuf)[ridx++] = data & 0xff;
+			else
+				((u16 *)rbuf)[ridx++] = data;
+		}
+	}
+
+	return len;
+}
+
+/*===========================================================================*/
+int spi_bld_write(u8 spi_id, u8 *tx_buf, int tx_len)
+{
+	spi_bld_enable(spi_id);
+	spi_bld_cs_active();
+	spi_bld_write_fifo(spi_id, tx_buf, tx_len);
+	spi_bld_cs_deactive();
+	spi_bld_disable(spi_id);
+
+	return tx_len;
+}
+
+int spi_bld_read(u8 spi_id, u8 *rx_buf, int rx_len)
+{
+	spi_bld_enable(spi_id);
+	spi_bld_cs_active();
+	spi_bld_read_fifo(spi_id, rx_buf, rx_len);
+	spi_bld_cs_deactive();
+	spi_bld_disable(spi_id);
+
+	return rx_len;
+}
+
+int spi_bld_write_then_read(u8 spi_id, u8 *tx_buf, int tx_len, u8 *rx_buf, int rx_len)
+{
+	/* write */
+	spi_bld_enable(spi_id);
+	spi_bld_cs_active();
+	spi_bld_write_fifo(spi_id, tx_buf, tx_len);
+	if (spi_cs.cs_change)
+		spi_bld_cs_deactive();
+	spi_bld_disable(spi_id);
+
+	/* then read */
+	spi_bld_enable(spi_id);
+	if (spi_cs.cs_change)
+		spi_bld_cs_active();
+	spi_bld_read_fifo(spi_id, rx_buf, rx_len);
+	spi_bld_cs_deactive();
+	spi_bld_disable(spi_id);
+
+	return rx_len;
+}
+
diff --git a/src/bld/spinand.c b/src/bld/spinand.c
new file mode 100644
index 0000000..0079e52
--- /dev/null
+++ b/src/bld/spinand.c
@@ -0,0 +1,1867 @@
+/**
+ * src/bld/spinand.c
+ *
+ * SPI NOR-Flash controller functions with spi nand chips.
+ *
+ * History:
+ *    2015/10/26 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <bldfunc.h>
+#include <fio/firmfl.h>
+#include <flash/spinor/spinor_flash.h>
+#include <ambhw/dma.h>
+#include <ambhw/cache.h>
+#include <ambhw/rct.h>
+#include <ambhw/spinor.h>
+#include <fio/ftl_const.h>
+
+//#define SPINAND_DEBUG		/* Use the macro for spinand debug message */
+struct spinor_ctrl {
+	u32 len;
+	u8 *buf;
+	u8 lane;
+	u8 is_dtr : 1;
+	u8 is_read : 1; /* following are only avaiable for data */
+	u8 is_io : 1;
+	u8 is_dma : 1;
+};
+
+#define PAGE_CACHE_SIZE		(2048 + 64)
+#define SPARE_SIZE_PAGE		128
+#define PAGES_PER_BLCOK		64
+#define NAND_SPARE_128_SHF	7	/* spare size 128B */
+#define SPINAND_SPARE_USE_SIZE	64
+
+static u8 spinand_cache_buf[PAGE_CACHE_SIZE] __attribute__ ((aligned(32)));
+
+#if defined(CONFIG_SPINAND_USE_FLASH_BBT)
+/*
+ * The bad block table is located in the last good blocks of the device, and
+ * is marked in the OOB area with an ident pattern.
+ *
+ * The table is mirrored, so it can be updated eventually. Both tables has a
+ * version number which indicates which of both tables is more up to date.
+ *
+ * The bad block table uses 2 bits per block
+ * 11b:		block is good
+ * 00b:		block is factory marked bad
+ * 01b, 10b:	block is marked bad due to wear
+ */
+
+#define MAIN_SPARE_SIZE		(2048 + 128)
+#define NAND_BBT_SIZE		(4096 >> 2)
+
+static int bbt_is_created = 0;
+
+static u8 bbt[NAND_BBT_SIZE]
+__attribute__ ((aligned(32), section(".bss.noinit")));
+static u8 page_data[MAIN_SPARE_SIZE]
+__attribute__ ((aligned(32), section(".bss.noinit")));
+static u8 check_buf[MAIN_SPARE_SIZE]
+__attribute__ ((aligned(32), section(".bss.noinit")));
+
+static u8 bbt_pattern[] = { 'B', 'b', 't', '0' };
+static u8 mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static nand_bbt_descr_t bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_VERSION | NAND_BBT_NO_OOB,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = bbt_pattern,
+	.block = -1,
+};
+
+static nand_bbt_descr_t bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_VERSION | NAND_BBT_NO_OOB,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = mirror_pattern,
+	.block = -1,
+};
+
+static u32 add_marker_len(nand_bbt_descr_t *td)
+{
+	u32 len;
+	if (!(td->options & NAND_BBT_NO_OOB))
+		return 0;
+
+	len = td->len;
+	if (td->options & NAND_BBT_VERSION)
+		len++;
+	return len;
+}
+
+/**
+ * read_bbt - [GENERIC] Read the bad block table starting from page
+ *
+ * Read the bad block table starting from page.
+ */
+static int read_bbt(nand_bbt_descr_t *td)
+{
+	int rval, i;
+	u32 offs;
+	u32 total_blks;
+	total_blks = flspinand.chip_size / flspinand.block_size;
+
+	rval = spinand_read_pages(td->block, 0, 1, page_data, 1);
+	if (rval < 0) {
+		spinand_mark_bad_block(td->block);
+		putstr("read failed. <block ");
+		putdec(td->block);
+		putstr(", page 0 ");
+		putstr(">\r\n");
+		return -1;
+	}
+
+	offs = add_marker_len(td);
+	for (i = 0; i < (total_blks >> 2); i++)
+		bbt[i] &= page_data[offs + i];
+
+	return 0;
+}
+/**
+ * check_pattern_no_oob - [GENERIC] check if a pattern is in the buffer
+ *
+ * Check for a pattern at the given place. Used to search bad block
+ * tables and good / bad block identifiers.
+*/
+static int check_pattern_no_oob(u8 *buf_data, nand_bbt_descr_t *td)
+{
+	int ret;
+	ret = memcmp(buf_data, td->pattern, td->len);
+	if (!ret)
+		return ret;
+
+	return -1;
+}
+
+/**
+ * search_bbt - [GENERIC] scan the device for a specific bad block table
+ *
+ * Read the bad block table by searching for a given ident pattern.
+ * Search is preformed either from the beginning up or from the end of
+ * the device downwards. The search starts always at the start of a
+ * block.
+ *
+ * The bbt ident pattern resides in the oob area of the first page
+ * in a block.
+ */
+static int search_bbt(nand_bbt_descr_t *td, int verbose)
+{
+	int actblock, startblock, block, rval;
+
+	u32 total_blks;
+	total_blks = flspinand.chip_size / flspinand.block_size;
+
+	/* Reset version information */
+	td->version = 0;
+	td->block = -1;
+
+	/* Search direction backward */
+	startblock = total_blks - 1;
+
+	/* Scan the maximum number of blocks */
+	for (block = 0; block < td->maxblocks; block++) {
+		actblock = startblock - block;
+		if (spinand_is_bad_block(actblock)) {
+			startblock--;
+			block--;
+			continue;
+		}
+
+		/* Read first page */
+		rval = spinand_read_pages(actblock, 0, 1, page_data, 1);
+		if (rval < 0) {
+			spinand_mark_bad_block(actblock);
+			putstr("read failed. <block ");
+			putdec(actblock);
+			putstr(", page 1");
+			putstr(">\r\n");
+			break;
+		}
+
+		if (!check_pattern_no_oob(page_data, td)) {
+			td->block = actblock;
+			if (td->options & NAND_BBT_VERSION) {
+				td->version = page_data[td->veroffs];
+			}
+			break;
+		}
+
+	}
+
+	/* Check, if we found a bbt for each requested chip */
+	if (td->block == -1) {
+		if (verbose)
+			putstr("Bad block table not found!\r\n");
+		return 0;
+	} else {
+		if (verbose) {
+			putstr("Bad block table found at block ");
+			putdec(td->block);
+			putstr(", page 0 ");
+			putstr(", version 0x");
+			puthex(td->version);
+			putstr("\r\n");
+		}
+		return 1;
+	}
+}
+
+/**
+ * write_bbt - [GENERIC] (Re)write the bad block table
+ *
+ * (Re)write the bad block table
+*/
+static int write_bbt(nand_bbt_descr_t *td, nand_bbt_descr_t *md, int verbose)
+{
+	int i, rval;
+	int numblocks, startblock, bbt_block;
+
+	numblocks = flspinand.chip_size / flspinand.block_size;
+	/* There was already a version of the table, reuse the page
+	 * This applies for absolute placement too, as we have the
+	 * page nr. in td->pages.
+	 */
+	if (td->block != -1) {
+		bbt_block = td->block;
+		goto write;
+	}
+
+	/* Search direction backward */
+	startblock = numblocks - 1;
+
+	for (i = 0; i < td->maxblocks; i++) {
+		bbt_block = startblock - i;
+		if (spinand_is_bad_block(bbt_block)) {
+			startblock--;
+			i--;
+			continue;
+		}
+		/* Check, if the block is used by the mirror table */
+		if (!md || md->block != bbt_block)
+			goto write;
+	}
+	putstr("No space left to write bad block table\n");
+	return -1;
+
+write:
+	/* Preset the buffer with 0xff */
+	memset(page_data, 0xff, flspinand.main_size + flspinand.spare_size);
+
+	/* bbt pattern */
+	memcpy(&page_data[td->offs], td->pattern, td->len);
+
+	/* bbt version */
+	if (td->options & NAND_BBT_VERSION)
+		page_data[td->veroffs] = td->version;
+	/* bbt contents */
+	memcpy(&page_data[add_marker_len(td)], bbt, NAND_BBT_SIZE);
+
+	rval = spinand_erase_block(bbt_block);
+	if (rval < 0) {
+		putstr("erase failed. <block ");
+		putdec(bbt_block);
+		putstr(">\r\n");
+		goto outerr;
+	}
+
+	rval = spinand_prog_pages(bbt_block, 0, 1, page_data);
+	if (rval < 0) {
+		putstr("program failed. <block ");
+		putdec(bbt_block);
+		putstr(", page 0 ");
+		putstr(">\r\n");
+		goto outerr;
+	}
+
+	/* Read it back for verification */
+	rval = spinand_read_pages(bbt_block, 0, 1, check_buf, 1);
+	if (rval < 0) {
+		putstr("read failed. <block ");
+		putdec(bbt_block);
+		putstr(", page 0 ");
+		putstr(">\r\n");
+		goto outerr;
+	}
+
+	/* Compare memory content after read back */
+	rval = memcmp(page_data, check_buf, flspinand.main_size);
+	if (rval != 0) {
+		putstr("write_bbt check failed. <block ");
+		putdec(bbt_block);
+		putstr(", page 0 ");
+		putstr(">\r\n");
+		rval = -1;
+		goto outerr;
+	}
+
+	if (verbose) {
+		putstr("Bad block table written to block ");
+		putdec(bbt_block);
+		putstr(", version 0x");
+		puthex(td->version);
+		putstr("\r\n");
+	}
+
+	/* Mark it as used */
+	td->block = bbt_block;
+
+	return 0;
+
+outerr:
+	spinand_mark_bad_block(bbt_block);
+	putstr("nand_bbt: Error while writing bad block table.\n");
+	return rval;
+}
+
+/**
+ * create_bbt - [GENERIC] Create a bad block table by scanning the device
+ */
+static int create_bbt(int verbose)
+{
+	int block, ret;
+	u32 total_blks;
+	total_blks = flspinand.chip_size / flspinand.block_size;
+
+	if (verbose)
+		putstr("Scanning device for bad blocks\r\n");
+
+	if (total_blks > (NAND_BBT_SIZE << 2)) {
+		putstr("bbt size is too small (");
+		putdec(total_blks);
+		putstr("/");
+		putdec(NAND_BBT_SIZE << 2);
+		putstr(")\r\n");
+		return -1;
+	}
+
+	for (block = 0; block < total_blks; block++) {
+		ret = spinand_is_bad_block(block);
+		if (ret) {
+			if (verbose) {
+				putstr("Bad block found at ");
+				putdec(block);
+				putstr("\r\n");
+			}
+			if (ret == NAND_LATE_DEVEL_BAD_BLOCK)
+				bbt[block >> 2] &= ~(0x01 << ((block << 1) % 8));
+			else
+				bbt[block >> 2] &= ~(0x03 << ((block << 1) % 8));
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * check_create - [GENERIC] create and write bbt(s) if necessary
+ *
+ * The function checks the results of the previous call to read_bbt
+ * and creates / updates the bbt(s) if necessary
+ * Creation is necessary if no bbt was found for the chip/device
+ * Update is necessary if one of the tables is missing or the
+ * version nr. of one table is less than the other
+*/
+static int check_create(nand_bbt_descr_t *td, nand_bbt_descr_t *md, int verbose)
+{
+	int writeops = 0, rval;
+	nand_bbt_descr_t *rd = NULL, *rd2 = NULL;
+
+	/* Mirrored table avilable ? */
+	if (md) {
+		if (td->block == -1 && md->block == -1) {
+			writeops = 0x03;
+			goto create;
+		}
+
+		if (td->block == -1) {
+			rd = md;
+			td->version = md->version;
+			writeops = 1;
+			goto writecheck;
+		}
+
+		if (md->block == -1) {
+			rd = td;
+			md->version = td->version;
+			writeops = 2;
+			goto writecheck;
+		}
+
+		if (td->version == md->version) {
+			rd = td;
+			if (!(td->options & NAND_BBT_VERSION))
+				rd2 = md;
+			goto writecheck;
+		}
+
+		if (td->version > md->version) {
+			rd = td;
+			md->version = td->version;
+			writeops = 2;
+		} else {
+			rd = md;
+			td->version = md->version;
+			writeops = 1;
+		}
+
+		goto writecheck;
+
+	} else {
+		if (td->block == -1) {
+			writeops = 0x01;
+			goto create;
+		}
+		rd = td;
+		goto writecheck;
+	}
+
+create:
+	/* Create the table in memory by scanning the chip(s) */
+	rval = create_bbt(verbose);
+	if (rval < 0)
+		return rval;
+
+	td->version = 1;
+	if (md)
+		md->version = 1;
+
+writecheck:
+	/* read back first ? */
+	if (rd)
+		read_bbt(rd);
+	/* If don't use version, read both. */
+	if (rd2)
+		read_bbt(rd2);
+
+	/* Write the bad block table to the device ? */
+	if (writeops & 0x01) {
+		rval = write_bbt(td, md, verbose);
+		if (rval < 0)
+			return rval;
+	}
+
+	/* Write the mirror bad block table to the device ? */
+	if ((writeops & 0x02) && md) {
+		rval = write_bbt(md, td, verbose);
+		if (rval < 0)
+			return rval;
+	}
+
+	return 0;
+}
+
+/**
+ * nand_scan_bbt - [NAND Interface] scan, find, read and maybe create bad block table(s)
+ *
+ * The function checks, if a bad block table(s) is/are already
+ * available. If not it scans the device for manufacturer
+ * marked good / bad blocks and writes the bad block table(s) to
+ * the selected place.
+*/
+int spinand_scan_bbt(int verbose)
+{
+	int rval = 0;
+	nand_bbt_descr_t *td;
+	nand_bbt_descr_t *md;
+
+	td = &bbt_main_descr;
+	md = &bbt_mirror_descr;
+
+	/* Avoid to be called more times */
+	if (bbt_is_created)
+		return 0;
+
+	/* Preset bbt contents with 0xff */
+	memset(&bbt, 0xff, NAND_BBT_SIZE);
+
+	/* Search the primary bad block table */
+	search_bbt(td, verbose);
+
+	/* Search the mirror bad block table */
+	search_bbt(md, verbose);
+
+	rval = check_create(td, md, verbose);
+	if (rval < 0)
+		return rval;
+
+	bbt_is_created = 1;
+
+	return 0;
+}
+
+/**
+ * nand_update_bbt - [NAND Interface] update bad block table(s)
+ * @bblock:	the newly bad block
+ * @gblock:	the newly good block save by diag_nand_rclm_bb
+ *
+ * The function updates the bad block table(s)
+*/
+int spinand_update_bbt(u32 bblock, u32 gblock)
+{
+	int rval = 0, writeops = 0;
+	nand_bbt_descr_t *td;
+	nand_bbt_descr_t *md;
+
+	td = &bbt_main_descr;
+	md = &bbt_mirror_descr;
+
+	if (!bbt_is_created)
+		return -1;
+
+	if (bblock) {
+		/* If it was bad already, return success and do nothing. */
+		if (spinand_isbad_bbt(bblock))
+			return 0;
+
+		bbt[bblock >> 2] &= ~(0x01 << ((bblock << 1) % 8));
+	} else {
+		/* If it was good already, return success and do nothing. */
+		if (!spinand_isbad_bbt(gblock))
+			return 0;
+
+		bbt[gblock >> 2] |= 0x03 << ((gblock << 1) % 8);
+	}
+
+	writeops = 0x1;
+	td->version++;
+	if (md) {
+		md->version++;
+		writeops |= 0x2;
+	}
+
+	/* Write the bad block table to the device ? */
+	if (writeops & 0x01) {
+		rval = write_bbt(td, md, 0);
+		if (rval < 0)
+			goto out;
+	}
+
+	/* Write the mirror bad block table to the device ? */
+	if ((writeops & 0x02) && md) {
+		rval = write_bbt(md, td, 0);
+	}
+out:
+	return rval;
+}
+
+int spinand_erase_bbt(void)
+{
+	int rval;
+	nand_bbt_descr_t *td;
+	nand_bbt_descr_t *md;
+
+	td = &bbt_main_descr;
+	md = &bbt_mirror_descr;
+
+	putstr("erase bad block table...\r\n");
+
+	bbt_is_created = 0;
+
+	search_bbt(td, 1);
+	search_bbt(md, 1);
+
+	if (td->block != -1) {
+		rval = spinand_erase_block(td->block);
+		if (rval < 0) {
+			spinand_mark_bad_block(td->block);
+			putstr("erase failed. <block ");
+			putdec(td->block);
+			putstr(">\r\n");
+		}
+	}
+
+	if (md->block != -1) {
+		rval = spinand_erase_block(md->block);
+		if (rval < 0) {
+			spinand_mark_bad_block(md->block);
+			putstr("erase failed. <block ");
+			putdec(md->block);
+			putstr(">\r\n");
+		}
+	}
+
+	putstr("\r\n");
+
+	return 0;
+}
+
+int spinand_show_bbt()
+{
+	int i, rval = 0;
+	u32 total_blks;
+	total_blks = flspinand.chip_size / flspinand.block_size;
+
+	for (i = 0; i < total_blks; i++) {
+		rval = spinand_isbad_bbt(i);
+		if (rval < 0)
+			return -1;
+		else if (rval != 0) {
+			putstr("Bad block found at ");
+			putdec(i);
+			putstr("\r\n");
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * nand_isbad_bbt - [NAND Interface] Check if a block is bad
+*/
+int spinand_isbad_bbt(u32 block)
+{
+	int rval = -1;
+	u8 bb;
+
+	if (!bbt_is_created)
+		return rval;
+
+	bb = (bbt[block >> 2] >> ((block << 1) % 8)) & 0x03;
+
+	/* good block */
+	if (bb == 0x03)
+		rval = NAND_GOOD_BLOCK;
+	else if (bb == 0x02 || bb == 0x01)
+		rval = NAND_LATE_DEVEL_BAD_BLOCK;
+	else if (bb == 0x00)
+		rval = NAND_INITIAL_BAD_BLOCK;
+
+	return rval;
+}
+
+/**
+ * nand_has_bbt - Does nand have bad block table
+*/
+int spinand_has_bbt()
+{
+	return bbt_is_created;
+}
+#endif
+
+static void spinor_setup_dma_devmem(struct spinor_ctrl *data)
+{
+	u32 reg;
+
+	clean_flush_d_cache(data->buf, data->len);
+
+	reg = DMA0_CHAN_STA_REG(NOR_SPI_RX_DMA_CHAN);
+	writel(reg, 0x0);
+
+	reg = DMA0_CHAN_SRC_REG(NOR_SPI_RX_DMA_CHAN);
+	writel(reg, SPINOR_RXDATA_REG);
+
+	reg = DMA0_CHAN_DST_REG(NOR_SPI_RX_DMA_CHAN);
+	writel(reg, (u32)data->buf);
+
+	reg = DMA0_CHAN_CTR_REG(NOR_SPI_RX_DMA_CHAN);
+	writel(reg, DMA_CHANX_CTR_EN | DMA_CHANX_CTR_WM |
+		    DMA_CHANX_CTR_NI | DMA_CHANX_CTR_BLK_32B |
+		    DMA_CHANX_CTR_TS_4B | (data->len & (~0x1f)));
+
+	writel(SPINOR_DMACTRL_REG, SPINOR_DMACTRL_RXEN);
+}
+
+static void spinor_setup_dma_memdev(struct spinor_ctrl *data)
+{
+	u32 reg;
+
+	clean_flush_d_cache(data->buf, data->len);
+
+	reg = DMA0_CHAN_STA_REG(NOR_SPI_TX_DMA_CHAN);
+	writel(reg, 0x0);
+
+	reg = DMA0_CHAN_SRC_REG(NOR_SPI_TX_DMA_CHAN);
+	writel(reg, (u32)data->buf);
+
+	reg = DMA0_CHAN_DST_REG(NOR_SPI_TX_DMA_CHAN);
+	writel(reg, SPINOR_TXDATA_REG);
+
+	reg = DMA0_CHAN_CTR_REG(NOR_SPI_TX_DMA_CHAN);
+	writel(reg, DMA_CHANX_CTR_EN | DMA_CHANX_CTR_RM |
+		    DMA_CHANX_CTR_NI | DMA_CHANX_CTR_BLK_32B |
+		    DMA_CHANX_CTR_TS_4B | data->len);
+
+	writel(SPINOR_DMACTRL_REG, SPINOR_DMACTRL_TXEN);
+}
+
+static int spinor_send_cmd(struct spinor_ctrl *cmd, struct spinor_ctrl *addr,
+		struct spinor_ctrl *data, struct spinor_ctrl *dummy)
+{
+	u32 reg_length = 0, reg_ctrl = 0;
+	u32 val, i;
+
+	/* setup basic info */
+	if (cmd != NULL) {
+		reg_length |= SPINOR_LENGTH_CMD(cmd->len);
+
+		reg_ctrl |= cmd->is_dtr ? SPINOR_CTRL_CMDDTR : 0;
+		switch(cmd->lane) {
+		case 8:
+			reg_ctrl |= SPINOR_CTRL_CMD8LANE;
+			break;
+		case 4:
+			reg_ctrl |= SPINOR_CTRL_CMD4LANE;
+			break;
+		case 2:
+			reg_ctrl |= SPINOR_CTRL_CMD2LANE;
+			break;
+		case 1:
+		default:
+			reg_ctrl |= SPINOR_CTRL_CMD1LANE;
+			break;
+		}
+	} else {
+		return -1;
+	}
+
+	if (addr != NULL) {
+		reg_length |= SPINOR_LENGTH_ADDR(addr->len);
+
+		reg_ctrl |= addr->is_dtr ? SPINOR_CTRL_ADDRDTR : 0;
+		switch(addr->lane) {
+		case 4:
+			reg_ctrl |= SPINOR_CTRL_ADDR4LANE;
+			break;
+		case 2:
+			reg_ctrl |= SPINOR_CTRL_ADDR2LANE;
+			break;
+		case 1:
+		default:
+			reg_ctrl |= SPINOR_CTRL_ADDR1LANE;
+			break;
+		}
+	}
+
+	if (data != NULL) {
+		if (data->len > SPINOR_MAX_DATA_LENGTH) {
+			putstr("spinor: data length is too large.\r\n");
+			return -1;
+		}
+
+		reg_length |= SPINOR_LENGTH_DATA(data->len);
+
+		reg_ctrl |= data->is_dtr ? SPINOR_CTRL_DATADTR : 0;
+		switch(data->lane) {
+		case 8:
+			reg_ctrl |= SPINOR_CTRL_DATA8LANE;
+			break;
+		case 4:
+			reg_ctrl |= SPINOR_CTRL_DATA4LANE;
+			break;
+		case 2:
+			reg_ctrl |= SPINOR_CTRL_DATA2LANE;
+			break;
+		case 1:
+		default:
+			reg_ctrl |= SPINOR_CTRL_DATA1LANE;
+			break;
+		}
+
+		if (data->is_read)
+			reg_ctrl |= SPINOR_CTRL_RDEN;
+		else
+			reg_ctrl |= SPINOR_CTRL_WREN;
+
+		if (!data->is_io)
+			reg_ctrl |= SPINOR_CTRL_RXLANE_TXRX;
+
+		if (data->is_dma && data->is_read && data->len < 32)
+			data->is_dma = 0;
+	}
+
+	if (dummy != NULL) {
+		reg_length |= SPINOR_LENGTH_DUMMY(dummy->len);
+		reg_ctrl |= dummy->is_dtr ? SPINOR_CTRL_DUMMYDTR : 0;
+	}
+
+	writel(SPINOR_LENGTH_REG, reg_length);
+	writel(SPINOR_CTRL_REG, reg_ctrl);
+
+	/* setup cmd id */
+	val = 0;
+	for (i = 0; i < cmd->len; i++)
+		val |= (cmd->buf[i] << (i << 3));
+	writel(SPINOR_CMD_REG, val);
+
+	/* setup address */
+	val = 0;
+	for (i = 0; addr && i < addr->len; i++) {
+		if (i >= 4)
+			break;
+		val |= (addr->buf[i] << (i << 3));
+	}
+	writel(SPINOR_ADDRLO_REG, val);
+
+	val = 0;
+	for (; addr && i < addr->len; i++)
+		val |= (addr->buf[i] << ((i - 4) << 3));
+	writel(SPINOR_ADDRHI_REG, val);
+
+	/* setup dma if data phase is existed and dma is required.
+	 * Note: for READ, dma will just transfer the length multiple of
+	 * 32Bytes, the residual data in FIFO need to be read manually. */
+	if (data != NULL && data->is_dma) {
+		if (data->is_read)
+			spinor_setup_dma_devmem(data);
+		else
+			spinor_setup_dma_memdev(data);
+	} else if (data != NULL && !data->is_read) {
+		if (data->len >= 0x7f) {
+			putstr("spinor: tx length exceeds fifo size.\r\n");
+			return -1;
+		}
+		for (i = 0; i < data->len; i++) {
+			writeb(SPINOR_TXDATA_REG, data->buf[i]);
+		}
+	}
+
+	/* clear all pending interrupts */
+	writel(SPINOR_CLRINTR_REG, SPINOR_INTR_ALL);
+
+	/* start tx/rx transaction */
+	writel(SPINOR_START_REG, 0x1);
+
+	/* wait for spi done */
+	while((readl(SPINOR_RAWINTR_REG) & SPINOR_INTR_DATALENREACH) == 0x0);
+
+	if (data != NULL && data->is_dma) {
+		u32 chan, n;
+
+		if (data->is_read)
+			chan = NOR_SPI_RX_DMA_CHAN;
+		else
+			chan = NOR_SPI_TX_DMA_CHAN;
+		/* wait for dma done */
+		while(!(readl(DMA0_REG(DMA_INT_OFFSET)) & DMA_INT_CHAN(chan)));
+		writel(DMA0_REG(DMA_INT_OFFSET), 0x0);	/* clear */
+
+		if (data->is_read) {
+			clean_flush_d_cache(data->buf, data->len);
+			/* read the residual data in FIFO manually */
+			n = data->len & (~0x1f);
+			for (i = 0; i < (data->len & 0x1f); i++)
+				data->buf[n + i] = readb(SPINOR_RXDATA_REG);
+		}
+		/* disable spi-nor dma */
+		writel(SPINOR_DMACTRL_REG, 0x0);
+	} else if (data != NULL && data->is_read) {
+		for (i = 0; i < data->len; i++) {
+			data->buf[i] = readb(SPINOR_RXDATA_REG);
+		}
+	}
+
+	return 0;
+}
+
+int spinor_send_alone_cmd(u8 cmd_id)
+{
+	struct spinor_ctrl cmd;
+	int rval;
+
+	cmd.buf = &cmd_id;
+	cmd.len = 1;
+	cmd.lane = 1;
+	cmd.is_dtr = 0;
+
+	rval = spinor_send_cmd(&cmd, NULL, NULL, NULL);
+
+	return rval;
+}
+
+int spinor_read_reg(u8 cmd_id, void *buf, u8 len)
+{
+	struct spinor_ctrl cmd;
+	struct spinor_ctrl data;
+	int rval;
+
+	cmd.buf = &cmd_id;
+	cmd.len = 1;
+	cmd.lane = 1;
+	cmd.is_dtr = 0;
+
+	data.buf = buf;
+	data.len = len;
+	data.lane = 2;
+	data.is_read = 1;
+	data.is_io = 0;
+	data.is_dtr = 0;
+	data.is_dma = 0;
+
+	rval = spinor_send_cmd(&cmd, NULL, &data, NULL);
+
+	return rval;
+}
+
+/* spinor_write_reg is also called when issuing operation cmd, e.g., SE */
+int spinor_write_reg(u8 cmd_id, void *buf, u8 len)
+{
+	struct spinor_ctrl cmd;
+	struct spinor_ctrl addr;
+	int rval;
+
+	cmd.buf = &cmd_id;
+	cmd.len = 1;
+	cmd.lane = 1;
+	cmd.is_dtr = 0;
+
+	addr.buf = buf;
+	addr.len = len;
+	addr.lane = 1;
+	addr.is_dtr = 0;
+
+	rval = spinor_send_cmd(&cmd, &addr, NULL, NULL);
+
+	return rval;
+}
+
+static int spinand_set_feature(u8 feature_addr, void *buf)
+{
+	struct spinor_ctrl cmd;
+	struct spinor_ctrl addr;
+	struct spinor_ctrl data;
+	struct spinor_ctrl dummy;
+	u8 cmd_id;
+	int rval;
+
+	cmd_id = SPINAND_CMD_SET_REG;
+	cmd.buf = &cmd_id;
+	cmd.len = 1;
+	cmd.lane = 1;
+	cmd.is_dtr = 0;
+
+	addr.buf = (u8 *)&feature_addr;
+	addr.len = 1;
+	addr.lane = 1;
+	addr.is_dtr = 0;
+
+	data.buf = buf;
+	data.len = 1;
+	data.lane = 1;
+	data.is_dtr = 0;
+	data.is_read = 0;
+	data.is_io = 0;
+	data.is_dma = 0;
+
+	dummy.len = 0;
+	dummy.is_dtr = 0;
+
+	rval = spinor_send_cmd(&cmd, &addr, &data, &dummy);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+static int spinand_get_feature(u8 feature_addr, void *buf)
+{
+	struct spinor_ctrl cmd;
+	struct spinor_ctrl addr;
+	struct spinor_ctrl data;
+	struct spinor_ctrl dummy;
+	u8 cmd_id;
+	int rval;
+
+	cmd_id = SPINAND_CMD_GET_REG;
+	cmd.buf = &cmd_id;
+	cmd.len = 1;
+	cmd.lane = 1;
+	cmd.is_dtr = 0;
+
+	addr.buf = (u8 *)&feature_addr;
+	addr.len = 1;
+	addr.lane = 1;
+	addr.is_dtr = 0;
+
+	data.buf = buf;
+	data.len = 1;
+	data.lane = 2;
+	data.is_dtr = 0;
+	data.is_read = 1;
+	data.is_io = 0;
+	data.is_dma = 0;
+
+	dummy.len = 0;
+	dummy.is_dtr = 0;
+
+	rval = spinor_send_cmd(&cmd, &addr, &data, &dummy);
+	if (rval < 0)
+		return rval;
+
+	return 0;
+}
+
+#if 0
+static int spinand_get_status(void *value)
+{
+       return spinand_get_feature(REG_STATUS, value);
+}
+
+static int spinand_get_pro(void *value)
+{
+       return spinand_get_feature(REG_PROTECTION, value);
+}
+
+static int spinand_get_ecc_en(void *value)
+{
+       return spinand_get_feature(REG_FEATURE, value);
+}
+#endif
+
+static int spinand_disable_ecc(void)
+{
+	u8 status;
+	int ret;
+
+	status = 0;
+	spinand_get_feature(REG_FEATURE, &status);
+	status &= (~SPI_NAND_ECC_EN);
+	ret = spinand_set_feature(REG_FEATURE, &status);
+	return ret;
+}
+
+static int spinand_enable_ecc(void)
+{
+	u8 status;
+	int ret;
+
+	status = 0;
+	spinand_get_feature(REG_FEATURE, &status);
+	status |= SPI_NAND_ECC_EN;
+	ret = spinand_set_feature(REG_FEATURE, &status);
+	return ret;
+}
+
+int spinand_wait_till_ready()
+{
+	int rval = 0;
+	u8 status;
+	do {
+			rval = spinand_get_feature(REG_STATUS, &status);
+			if (rval < 0)
+				return rval;
+		} while (status & 0x1);
+	return 0;
+}
+
+int spinand_erase_block(u32 block_id)
+{
+	u32 address;
+	u8 status;
+	int ret = 0;
+
+	spinor_send_alone_cmd(SPINAND_CMD_WREN);
+
+	address = block_id * flspinand.pages_per_block;
+	spinor_write_reg(SPINAND_CMD_ERASE_BLK, &address, 3);
+
+	/* Wait until the operation completes or a timeout occurs. */
+	ret = spinand_wait_till_ready();
+	if (ret) {
+		if (ret < 0) {
+			putstr("Wait execution complete failed!\n");
+			return ret;
+		}
+	}
+
+	/* Check status register for program fail bit */
+	ret = spinand_get_feature(REG_STATUS, &status);
+	if (ret < 0) {
+		putstr("Error when reading status register.\n");
+		return ret;
+	}
+
+	if (status & STATUS_E_FAIL) {
+		putstr("Erase failed on block 0x");
+		puthex(block_id);
+		putstr("\r\n");
+		   return -1;
+	}
+	return 0;
+}
+
+static int spinand_read_page_to_cache(u32 page_id)
+{
+	struct spinor_ctrl cmd;
+	struct spinor_ctrl addr;
+	int rval = 0;
+	u8 cmd_id;
+
+	cmd_id = SPINAND_CMD_READ;
+	cmd.buf = &cmd_id;
+	cmd.len = 1;
+	cmd.lane = 1;
+	cmd.is_dtr = 0;
+
+	addr.buf = (u8 *)&page_id;
+	addr.len = 3;
+	addr.lane = 1;
+	addr.is_dtr = 0;
+
+	rval = spinor_send_cmd(&cmd, &addr, NULL, NULL);
+	if (rval < 0) {
+		putstr("send read command error \r\n");
+	}
+
+	return rval;
+}
+
+static int spinand_read_from_cache(u32 byte_id, void *rbuf, int len)
+{
+	struct spinor_ctrl cmd;
+	struct spinor_ctrl addr;
+	struct spinor_ctrl data;
+	struct spinor_ctrl dummy;
+	u8 cmd_id, is_dma;
+	//u32 addr_id;
+
+	//cmd_id = SPINAND_CMD_RFC;
+	cmd_id = SPINAND_CMD_RDIO; // 0x3B 2IO cache read
+	cmd.buf = &cmd_id;
+	cmd.len = 1;
+	cmd.lane = 1;
+	cmd.is_dtr = 0;
+
+	//addr_id = 0;
+	//addr_id = byte_id << 8;
+	addr.buf = (u8 *)&byte_id;
+	//addr.buf = (u8 *)&addr_id;
+	addr.len = 3;//sizeof(byte_id);
+	addr.lane = 1;
+	addr.is_dtr = 0;
+
+	if ((u32)rbuf & 0x7) {
+		is_dma = 0;
+	} else {
+		is_dma = 1;
+	}
+
+	data.buf = rbuf;
+	data.len = len;
+	data.lane = 2;
+	data.is_dtr = 0;
+	data.is_read = 1;
+	data.is_io = 1;
+	data.is_dma = is_dma;
+
+	dummy.len = 8;
+	dummy.is_dtr = 0;
+
+	return spinor_send_cmd(&cmd, &addr, &data, &dummy);
+}
+
+int spinand_read_page(u32 page, u32 offset, void *buf, int len, u32 enable_ecc)
+{
+	int ret;
+	u8 status;
+
+	/* Issue read cache command */
+	ret = spinand_read_page_to_cache(page);
+	if (ret < 0) {
+		putstr("Error when reading page to cache.\r\n");
+		return ret;
+	}
+
+	/* Wait until the operation completes or a timeout occurs. */
+	ret = spinand_wait_till_ready();
+	if (ret) {
+		if (ret < 0) {
+			putstr("Wait execution complete failed!\n");
+			return ret;
+		}
+	}
+
+	ret = spinand_read_from_cache(offset, buf, len);
+	if (ret < 0) {
+		putstr("Error when reading page from cache.\r\n");
+		return ret;
+	}
+
+	status = 0;
+	/* Check status register for ecc bits */
+	ret = spinand_get_feature(REG_STATUS, &status);
+	if (ret < 0) {
+		putstr("Error when reading status register.\n");
+		return ret;
+	}
+
+	if (enable_ecc) {
+		if ((status & STATUS_ECC) == STATUS_ECC) {
+			putstr("ecc error on status value 0x");
+			puthex(status);
+			putstr("\r\n");
+			putstr("ecc error on page 0x");
+			puthex(page);
+			putstr("\r\n");
+			putstr("ecc error on offset 0x");
+			puthex(offset);
+			putstr("\r\n");
+			puthex(len);
+			putstr("\r\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+int spinand_read_pages(u32 block, u32 page, u32 pages,
+		void *rbuf, u32 enable_ecc)
+{
+	u32 i, page_start;
+	u32 len;
+	u8 *buf;
+	int ret = 0;
+
+	buf = rbuf;
+	//len = flspinand.main_size + flspinand.spare_size;
+	len = flspinand.main_size;
+	page_start = block * flspinand.pages_per_block + page;
+
+	if (enable_ecc == 0)
+		spinand_disable_ecc();
+
+	for (i = page_start; i < (page_start + pages); i++) {
+		ret = spinand_read_page(i, 0, buf, len, enable_ecc);
+		if (ret < 0) {
+			if (enable_ecc == 0)
+				spinand_enable_ecc();
+			return ret;
+		}
+		buf += len;
+	}
+
+	if (enable_ecc == 0)
+		spinand_enable_ecc();
+	return ret;
+}
+static int spinand_program_data_to_cache(u16 byte_id, void *buf, int len)
+{
+	struct spinor_ctrl cmd;
+	struct spinor_ctrl addr;
+	struct spinor_ctrl data;
+	u8 cmd_id, is_dma;
+
+	cmd_id = SPINAND_CMD_PRG_LOAD;
+	cmd.buf = &cmd_id;
+	cmd.len = 1;
+	cmd.lane = 1;
+	cmd.is_dtr = 0;
+
+	addr.buf = (u8 *)&byte_id;
+	addr.len = 2;//sizeof(byte_id);
+	addr.lane = 1;
+	addr.is_dtr = 0;
+
+	if ((u32)buf & 0x7) {
+		is_dma = 0;
+	} else {
+		is_dma = 1;
+	}
+
+	data.buf = buf;
+	data.len = len;
+	data.lane = 1;
+	data.is_dtr = 0;
+	data.is_read = 0;
+	data.is_io = 0;
+	data.is_dma = is_dma;
+
+	return spinor_send_cmd(&cmd, &addr, &data, NULL);
+
+}
+
+static int spinand_program_execute(void *buf)
+{
+	struct spinor_ctrl cmd;
+	struct spinor_ctrl addr;
+	u8 cmd_id;
+	int rval;
+
+	cmd_id = SPINAND_CMD_PRG_EXC;
+	cmd.buf = &cmd_id;
+	cmd.len = 1;
+	cmd.lane = 1;
+	cmd.is_dtr = 0;
+
+	addr.buf = buf;
+	addr.len = 3;
+	addr.lane = 1;
+	addr.is_dtr = 0;
+
+	rval = spinor_send_cmd(&cmd, &addr, NULL, NULL);
+
+	return rval;
+}
+
+int spinand_program_page(u32 page, u16 offset, void *buf, int len)
+{
+	int ret;
+	u8 status;
+	u32 page_id;
+
+	/* Issue program cache command */
+	ret = spinand_program_data_to_cache(offset, buf, len);
+	if (ret < 0) {
+		putstr("Error when programming cache.\n");
+		return ret;
+	}
+
+	spinor_send_alone_cmd(SPINOR_CMD_WREN);
+
+	page_id = page;
+	/* Issue program execute command */
+	ret = spinand_program_execute(&page_id);
+	if (ret < 0) {
+		putstr("Error when programming NAND cells.\n");
+		return ret;
+	}
+
+	/* Wait until the operation completes or a timeout occurs. */
+	ret = spinand_wait_till_ready();
+	if (ret) {
+		if (ret < 0) {
+			putstr("Wait execution complete failed!\n");
+			return ret;
+		}
+	}
+
+	/* Check status register for program fail bit */
+	ret = spinand_get_feature(REG_STATUS, &status);
+	if (ret < 0) {
+		putstr("Error when reading status register.\n");
+		return ret;
+	}
+
+	if (status & STATUS_P_FAIL) {
+		putstr("Program failed on page 0x");
+		puthex(page);
+		putstr("\r\n");
+		   return -1;
+	}
+	return 0;
+}
+
+int spinand_prog_pages(u32 block, u32 page, u32 pages, void *wbuf)
+{
+	u32 i, page_start;
+	u32 len;
+	int ret = 0;
+	u8 *buf;
+
+	page_start = block * flspinand.pages_per_block + page;
+	len = flspinand.main_size;
+	buf = wbuf;
+
+	for (i = page_start; i < (page_start + pages); i++) {
+		ret = spinand_program_page(i, 0, buf, len);
+		if (ret < 0) {
+			putstr("program page failed at 0x");
+			puthex(i);
+			putstr("\r\n");
+			return ret;
+		}
+		buf += len;
+	}
+
+	return ret;
+}
+
+static int spinand_read(u32 block, u32 page, u32 pages, u8 *buf)
+{
+	int rval = 0;
+	u32 first_blk_pages, blocks, last_blk_pages;
+	u32 bad_blks = 0;
+
+#if defined(DEBUG)
+	putstr("spinand_read( ");
+	putdec(block);
+	putstr(", ");
+	putdec(page);
+	putstr(", ");
+	putdec(pages);
+	putstr(", 0x");
+	puthex((u32)buf);
+	putstr(" )\r\n");
+#endif
+
+	first_blk_pages = flspinand.pages_per_block - page;
+	if (pages > first_blk_pages) {
+		pages -= first_blk_pages;
+		blocks = pages / flspinand.pages_per_block;
+		last_blk_pages = pages % flspinand.pages_per_block;
+	} else {
+		first_blk_pages = pages;
+		blocks = 0;
+		last_blk_pages = 0;
+	}
+
+	if (first_blk_pages) {
+		while (spinand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = spinand_read_pages(block, page, first_blk_pages, buf, 1);
+		if (rval < 0)
+			return -1;
+		block++;
+		buf += first_blk_pages * flspinand.main_size;
+	}
+
+	while (blocks > 0) {
+		while (spinand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = spinand_read_pages(block, 0, flspinand.pages_per_block, buf, 1);
+		if (rval < 0)
+			return -1;
+		block++;
+		blocks--;
+		buf += flspinand.block_size;
+	}
+
+	if (last_blk_pages) {
+		while (spinand_is_bad_block(block)) {
+			/* if bad block, find next */
+			block++;
+			bad_blks++;
+		}
+		rval = spinand_read_pages(block, 0, last_blk_pages, buf, 1);
+		if (rval < 0)
+			return -1;
+	}
+
+	return bad_blks;
+}
+
+static void spinand_get_offset_adr(u32 *block, u32 *page, u32 pages, u32 bad_blks)
+{
+	u32 blocks;
+
+	blocks = pages / flspinand.pages_per_block;
+	pages  = pages % flspinand.pages_per_block;
+
+	*block =  *block + blocks;
+	*page += pages;
+
+	if (*page >= flspinand.pages_per_block) {
+		*page -= flspinand.pages_per_block;
+		*block += 1;
+	}
+
+	*block += bad_blks;
+}
+
+int spinand_read_data(u8 *dst, u8 *src, int len)
+{
+	u32 block, page, pages, pos;
+	u32 first_ppage_size, last_ppage_size;
+	int val, rval = -1;
+
+#if defined(DEBUG)
+	putstr("spinand_read_data( 0x");
+	puthex((u32)dst);
+	putstr(", 0x");
+	puthex((u32)src);
+	putstr(", ");
+	putdec(len);
+	putstr(" )\r\n");
+#endif
+
+	/* translate address to block, page, address */
+	val = (int) src;
+	block = val / flspinand.block_size;
+	val  -= block * flspinand.block_size;
+	page  = val / flspinand.main_size;
+	pos   = val % flspinand.main_size;
+	pages = len / flspinand.main_size;
+
+	if (pos == 0)
+		first_ppage_size = 0;
+	else
+		first_ppage_size = flspinand.main_size - pos;
+
+	if (len >= first_ppage_size) {
+		pages = (len - first_ppage_size) / flspinand.main_size;
+
+		last_ppage_size = (len - first_ppage_size) % flspinand.main_size;
+	} else {
+		first_ppage_size = len;
+		pages = 0;
+		last_ppage_size = 0;
+	}
+
+	if (len !=
+	    (first_ppage_size + pages * flspinand.main_size + last_ppage_size)) {
+		return -1;
+	}
+
+	len = 0;
+	if (first_ppage_size) {
+		rval = spinand_read(block, page, 1, spinand_cache_buf);
+		if (rval < 0)
+			return len;
+
+		memcpy(dst, (void *) (spinand_cache_buf + pos), first_ppage_size);
+		dst += first_ppage_size;
+		len += first_ppage_size;
+		spinand_get_offset_adr(&block, &page, 1, rval);
+	}
+
+	if (pages > 0) {
+		rval = spinand_read(block, page, pages, dst);
+		if (rval < 0)
+			return len;
+
+		dst += pages * flspinand.main_size;
+		len += pages * flspinand.main_size;
+		spinand_get_offset_adr(&block, &page, pages, rval);
+	}
+
+	if (last_ppage_size > 0) {
+		rval = spinand_read(block, page, 1, spinand_cache_buf);
+		if (rval < 0)
+			return len;
+
+		memcpy(dst, (void *) spinand_cache_buf, last_ppage_size);
+		len += last_ppage_size;
+	}
+
+	return len;
+}
+
+int spinand_init(void)
+{
+	int part_size[HAS_IMG_PARTS];
+	u32 divider, val, i;
+	u32 sblk, nblk;
+	u32 total_blocks;
+	u8 status = 0;
+
+	rct_set_ssi3_pll();
+
+	/* make sure spinor occupy dma channel 0 */
+	val = readl(AHB_SCRATCHPAD_REG(0x0c));
+	val &= ~(1 << 21);
+	writel(AHB_SCRATCHPAD_REG(0x0c), val);
+
+	divider = get_ssi3_freq_hz() / SPINOR_SPI_CLOCK;
+
+	/* global configuration for spinor controller. Note: if the
+	 * data received is invalid, we need to tune rxsampldly.*/
+	val = SPINOR_CFG_FLOWCTRL_EN |
+	      SPINOR_CFG_HOLDPIN(0) |
+	      SPINOR_CFG_CHIPSEL(SPINOR_FLASH_CHIP_SEL) |
+	      SPINOR_CFG_CLKDIV(divider) |
+	      SPINOR_CFG_RXSAMPDLY(SPINOR_RX_SAMPDLY);
+	writel(SPINOR_CFG_REG, val);
+
+	/* mask all interrupts */
+	writel(SPINOR_INTRMASK_REG, SPINOR_INTR_ALL);
+
+	/* reset tx/rx fifo */
+	writel(SPINOR_TXFIFORST_REG, 0x1);
+	writel(SPINOR_RXFIFORST_REG, 0x1);
+	/* SPINOR_RXFIFOLV_REG may have invalid value, so we read rx fifo
+	 * manually to clear tx fifo. This is a hardware bug. */
+	while (readl(SPINOR_RXFIFOLV_REG) != 0) {
+		val = readl(SPINOR_RXDATA_REG);
+	}
+
+	writel(SPINOR_TXFIFOTHLV_REG, 31);
+	writel(SPINOR_RXFIFOTHLV_REG, 31);
+
+	flspinand.main_size = SPINAND_MAIN_SIZE;
+	flspinand.spare_size = SPINAND_SPARE_SIZE;
+	flspinand.pages_per_block = SPINAND_PAGES_PER_BLOCK;
+	flspinand.block_size = flspinand.main_size * flspinand.pages_per_block;
+	flspinand.chip_size = SPINAND_CHIP_SIZE;
+
+	sblk = nblk = 0;
+	get_part_size(part_size);
+
+	for (i = 0; i < HAS_IMG_PARTS; i++) {
+		if ((get_part_dev(i) & PART_DEV_SPINAND) != PART_DEV_SPINAND) {
+			continue;
+		}
+
+		sblk += nblk;
+		nblk = part_size[i] / flspinand.block_size;
+		if ((part_size[i] % flspinand.block_size) != 0x0)
+			nblk++;
+		flspinand.sblk[i] = (nblk == 0) ? 0 : sblk;
+		flspinand.nblk[i] = nblk;
+	}
+	for (; i < PART_MAX; i++) {
+		flspinand.sblk[i] = 0;
+		flspinand.nblk[i] = 0;
+	}
+	total_blocks = (flspinand.chip_size / flspinand.block_size);
+	nblk = (total_blocks > sblk) ? (total_blocks - sblk) : 0;
+	//Raw part include BBT, take care!
+	flspinand.sblk[PART_RAW] = (nblk == 0) ? 0 : sblk;
+	flspinand.nblk[PART_RAW] = nblk;
+	if (flspinand.sblk[PART_RAW] < 2) {
+		putstr("No Space for BBT!\n\r");
+	}
+
+	spinand_flash_reset();
+
+	val = 0;
+	spinor_read_reg(SPINOR_CMD_READID, &val, sizeof(val));
+
+	putstr("spi device flash ID is 0x");
+	puthex(val);
+	putstr("\r\n");
+
+	status = 0;
+	//spinand_get_pro(&val);
+	spinand_get_feature(REG_PROTECTION, &status);
+#if defined(SPINAND_DEBUG)
+	putstr("spi device flash pro value is 0x");
+	puthex(status);
+	putstr("\r\n");
+#endif
+	status = 0;
+	spinand_set_feature(REG_PROTECTION, &status);
+
+#if defined(SPINAND_DEBUG)
+	/* unlock all blocks */
+	status = 0;
+	spinand_get_feature(REG_PROTECTION, &status);
+	putstr("spi device flash pro value is 0x");
+	puthex(status);
+	putstr("\r\n");
+#endif
+
+#if defined(SPINAND_DEBUG)
+	status = 0;
+	//spinand_get_status(&val);
+	spinand_get_feature(REG_STATUS, &status);
+	putstr("spi device flash status value is 0x");
+	puthex(status);
+	putstr("\r\n");
+
+	status = 0;
+	//spinand_get_ecc_en(&val);
+	spinand_get_feature(REG_FEATURE, &status);
+	putstr("spi device flash ecc value is 0x");
+	puthex(status);
+	putstr("\r\n");
+
+	status = 0;
+	//spinand_get_status(&val);
+	spinand_get_feature(REG_STATUS, &status);
+	putstr("spi device flash status value is 0x");
+	puthex(status);
+	putstr("\r\n");
+#endif
+#if defined(CONFIG_SPINAND_USE_RESET_PIN)
+	status = 0;
+	//spinand_get_status(&val);
+	spinand_get_feature(REG_FEATURE_2, &status);
+#if defined(SPINAND_DEBUG)
+	putstr("spi device flash Feature_2 value is 0x");
+	puthex(status);
+	putstr("\r\n");
+#endif
+	status |= (1 << 7);
+	spinand_set_feature(REG_FEATURE_2, &status);
+
+#if defined(SPINAND_DEBUG)
+	status = 0;
+	//spinand_get_status(&val);
+	spinand_get_feature(REG_FEATURE_2, &status);
+	putstr("spi device flash after Feature_2 value is 0x");
+	puthex(status);
+	putstr("\r\n");
+#endif
+#endif
+
+	return 0;
+}
+
+/* spinand read spare*/
+int spinand_read_spare(u32 block, u32 page, u32 pages, void *buf)
+{
+	int i = 0;
+	int ret;
+	u32 page_start = 0;
+
+	page_start = block * flspinand.pages_per_block + page;
+	ret = spinand_disable_ecc();
+	if (ret < 0) {
+		putstr("disable ecc error.\r\n");
+		spinand_enable_ecc();
+		return ret;
+	}
+	for (i = page_start; i < (page_start + pages); i++)
+	{
+		ret = spinand_read_page(i, flspinand.main_size, buf, flspinand.spare_size, 0);
+		if (ret < 0)
+			return ret;
+		buf += flspinand.spare_size;
+	}
+	ret = spinand_enable_ecc();
+	return ret;
+}
+
+/**
+ * Program spare area to NAND flash.
+ * Only for mark bad block, disable ECC.
+ * only one byte for 0x800H pos
+ */
+int spinand_prog_spare(u32 block, u32 page, u32 pages, void *buf, u32 len)
+{
+	int i = 0;
+	int ret;
+	u32 page_start = 0;
+
+	page_start = block * flspinand.pages_per_block + page;
+	ret = spinand_disable_ecc();
+	if (ret < 0) {
+		putstr("disable ecc 2 error.\r\n");
+		spinand_enable_ecc();
+		return ret;
+	}
+	i = page_start;
+	//for (i = page_start; i < (page_start + pages); i++)
+	{
+		ret = spinand_program_page(i, flspinand.main_size, buf, len);
+		if (ret < 0)
+			return ret;
+		buf += len;
+	}
+	ret = spinand_enable_ecc();
+	return ret;
+}
+
+/**
+ * Check for bad block.
+ */
+int spinand_is_bad_block(u32 block)
+{
+	int ret_val = -1;
+	u8 sbuf[1024], *sbuf_ptr;
+	u8 bi;
+
+	/* make sure 32 bytes aligned */
+	sbuf_ptr = (u8 *)(((u32)sbuf + 31) & (~31));
+
+#if defined(CONFIG_SPINAND_USE_FLASH_BBT)
+	if(spinand_has_bbt())
+		return spinand_isbad_bbt(block);
+#endif
+
+	ret_val = spinand_read_spare(block, 0, 1, sbuf_ptr);
+	if (ret_val < 0) {
+		putstr("check bad block failed >> "
+				"read spare data error.\r\n");
+		/* Treat as factory bad block */
+		return NAND_INITIAL_BAD_BLOCK;
+	}
+
+	bi = *sbuf_ptr;
+
+	if (bi != 0xff)
+		return NAND_INITIAL_BAD_BLOCK;
+	else
+		return NAND_GOOD_BLOCK;
+}
+
+void spinand_output_bad_block(u32 block, int bb_type)
+{
+	if (bb_type & NAND_INITIAL_BAD_BLOCK) {
+		putstr("initial bad block. <block ");
+	} else if (bb_type & NAND_LATE_DEVEL_BAD_BLOCK) {
+		putstr("late developed bad block. <block ");
+	} else {
+		putstr("other bad block. <block ");
+	}
+	putdec(block);
+	putstr(">\r\n");
+	putstr("Try next block...\r\n");
+}
+
+/**
+ * Mark a bad block.
+ */
+int spinand_mark_bad_block(u32 block)
+{
+	int ret_val = -1;
+	u8 sbuf[256], *sbuf_ptr;
+	u8 bi;
+
+	/* make sure 32 bytes aligned */
+	sbuf_ptr = (u8 *)(((u32)sbuf + 31) & (~31));
+
+	putstr("try to mark bad block failed >> "
+				"verify failed at block ");
+			putdec(block);
+			putstr("\r\n");
+#if defined(CONFIG_SPINAND_USE_FLASH_BBT)
+	spinand_update_bbt(block, 0);
+#endif
+
+	memset(sbuf_ptr, 0xff, flspinand.spare_size);
+	*sbuf_ptr = AMB_BAD_BLOCK_MARKER;
+
+	ret_val = spinand_prog_spare(block, 0, 1, sbuf_ptr, 16);
+	if (ret_val < 0) {
+			putstr("mark bad block failed >> "
+				"write spare data error.\r\n");
+			return ret_val;
+		}
+
+		ret_val = spinand_read_spare(block, 0, 1, sbuf_ptr);
+		if (ret_val < 0) {
+			putstr("mark bad block failed >> "
+				"read spare data error.\r\n");
+			return ret_val;
+		}
+
+		bi = *sbuf_ptr;
+
+		if (bi == 0xff) {
+			putstr("mark bad block failed >> "
+				"verify failed at block ");
+			putdec(block);
+			putstr("\r\n");
+			return -1;
+		}
+	return 0;
+}
diff --git a/src/bld/spinor.c b/src/bld/spinor.c
index f2819eb..5eae699 100644
--- a/src/bld/spinor.c
+++ b/src/bld/spinor.c
@@ -1,17 +1,35 @@
 /**
- * system/src/bld/spi_nor.c
+ * system/src/bld/spinor.c
  *
  * Flash controller functions with spi nor  chips.
  *
  * History:
  *    2013/10/12 - [cddiao] creat
  *
- * Copyright (C) 2013-2017, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <bldfunc.h>
@@ -32,10 +50,18 @@ struct spinor_ctrl {
 	u8 is_dma : 1;
 };
 
-int (*spinor_read_data)(u32 address, void *buf, int len);
-static u32 spi_nor_addr_mode = 4;
-static u32 spi_nor_id = 0;
-#define JEDEC_MFR(_jedec_id)	((_jedec_id) & 0x000000FF)
+static const struct spi_flash_info spi_nor_ids[] = {
+	{"S25FL512S", 	0x010220, 0x4d00,   256 * 1024,   256,  512, 1,  SPI_NOR_DTR_DUAL_READ},
+	{"N25Q256A", 	0x20ba19, 0, 64 * 1024, 512, 256, 2, SPI_NOR_DTR_DUAL_READ },
+	{"MX25L25645G",  0xc22019, 0, 64 * 1024, 512, 256, 0, 0 },
+	{"MX66L51235F",   0xc2201a, 0, 64 * 1024, 1024, 256, 0, 0 },
+	{"W25Q128", 		0xef4018, 0, 64 * 1024, 256, 256, 0, 0 },
+	{"W25Q256", 		0xef4019, 0, 64 * 1024, 512, 256, 0, 0 },
+	{"GD25Q128", 	0xc84018, 0, 64 * 1024, 256, 256, 0, 0 },
+	{"GD25Q256C", 	0xc84019, 0, 64 * 1024, 512, 256, 0, 0 },
+	{"GD25Q512", 	0xc84020, 0, 64 * 1024, 1024, 256, 0, 0 },
+	{},
+};
 
 static void spinor_setup_dma_devmem(struct spinor_ctrl *data)
 {
@@ -43,16 +69,16 @@ static void spinor_setup_dma_devmem(struct spinor_ctrl *data)
 
 	clean_flush_d_cache(data->buf, data->len);
 
-	reg = DMA_CHAN_STA_REG(NOR_SPI_RX_DMA_CHAN);
+	reg = DMA0_CHAN_STA_REG(NOR_SPI_RX_DMA_CHAN);
 	writel(reg, 0x0);
 
-	reg = DMA_CHAN_SRC_REG(NOR_SPI_RX_DMA_CHAN);
+	reg = DMA0_CHAN_SRC_REG(NOR_SPI_RX_DMA_CHAN);
 	writel(reg, SPINOR_RXDATA_REG);
 
-	reg = DMA_CHAN_DST_REG(NOR_SPI_RX_DMA_CHAN);
-	writel(reg, (u32)data->buf);
+	reg = DMA0_CHAN_DST_REG(NOR_SPI_RX_DMA_CHAN);
+	writel(reg, (uintptr_t)data->buf);
 
-	reg = DMA_CHAN_CTR_REG(NOR_SPI_RX_DMA_CHAN);
+	reg = DMA0_CHAN_CTR_REG(NOR_SPI_RX_DMA_CHAN);
 	writel(reg, DMA_CHANX_CTR_EN | DMA_CHANX_CTR_WM |
 		    DMA_CHANX_CTR_NI | DMA_CHANX_CTR_BLK_32B |
 		    DMA_CHANX_CTR_TS_4B | (data->len & (~0x1f)));
@@ -66,16 +92,16 @@ static void spinor_setup_dma_memdev(struct spinor_ctrl *data)
 
 	clean_flush_d_cache(data->buf, data->len);
 
-	reg = DMA_CHAN_STA_REG(NOR_SPI_TX_DMA_CHAN);
+	reg = DMA0_CHAN_STA_REG(NOR_SPI_TX_DMA_CHAN);
 	writel(reg, 0x0);
 
-	reg = DMA_CHAN_SRC_REG(NOR_SPI_TX_DMA_CHAN);
-	writel(reg, (u32)data->buf);
+	reg = DMA0_CHAN_SRC_REG(NOR_SPI_TX_DMA_CHAN);
+	writel(reg, (uintptr_t)data->buf);
 
-	reg = DMA_CHAN_DST_REG(NOR_SPI_TX_DMA_CHAN);
+	reg = DMA0_CHAN_DST_REG(NOR_SPI_TX_DMA_CHAN);
 	writel(reg, SPINOR_TXDATA_REG);
 
-	reg = DMA_CHAN_CTR_REG(NOR_SPI_TX_DMA_CHAN);
+	reg = DMA0_CHAN_CTR_REG(NOR_SPI_TX_DMA_CHAN);
 	writel(reg, DMA_CHANX_CTR_EN | DMA_CHANX_CTR_RM |
 		    DMA_CHANX_CTR_NI | DMA_CHANX_CTR_BLK_32B |
 		    DMA_CHANX_CTR_TS_4B | data->len);
@@ -137,11 +163,6 @@ static int spinor_send_cmd(struct spinor_ctrl *cmd, struct spinor_ctrl *addr,
 			return -1;
 		}
 
-		if (data->is_dma && ((u32)data->buf & 0x7)) {
-			putstr("spinor: data buf is not 8 Bytes align.\r\n");
-			return -1;
-		}
-
 		reg_length |= SPINOR_LENGTH_DATA(data->len);
 
 		reg_ctrl |= data->is_dtr ? SPINOR_CTRL_DATADTR : 0;
@@ -169,7 +190,7 @@ static int spinor_send_cmd(struct spinor_ctrl *cmd, struct spinor_ctrl *addr,
 		if (!data->is_io)
 			reg_ctrl |= SPINOR_CTRL_RXLANE_TXRX;
 
-		if (data->is_dma && data->len < 32)
+		if (data->is_dma && data->is_read && data->len < 32)
 			data->is_dma = 0;
 	}
 
@@ -236,8 +257,8 @@ static int spinor_send_cmd(struct spinor_ctrl *cmd, struct spinor_ctrl *addr,
 		else
 			chan = NOR_SPI_TX_DMA_CHAN;
 		/* wait for dma done */
-		while(!(readl(DMA_REG(DMA_INT_OFFSET)) & DMA_INT_CHAN(chan)));
-		writel(DMA_REG(DMA_INT_OFFSET), 0x0);	/* clear */
+		while(!(readl(DMA0_REG(DMA_INT_OFFSET)) & DMA_INT_CHAN(chan)));
+		writel(DMA0_REG(DMA_INT_OFFSET), 0x0);	/* clear */
 
 		if (data->is_read) {
 			clean_flush_d_cache(data->buf, data->len);
@@ -342,8 +363,8 @@ int spinor_erase_sector(u32 sector)
 
 	spinor_send_alone_cmd(SPINOR_CMD_WREN);
 
-	address = sector * SPINOR_SECTOR_SIZE;
-	spinor_write_reg(SPINOR_CMD_SE, &address, spi_nor_addr_mode);
+	address = sector * flspinor.sector_size;
+	spinor_write_reg(flspinor.erase_opcode, &address, flspinor.addr_width);
 
 	do {
 		spinor_read_reg(SPINOR_CMD_RDSR, &status, sizeof(status));
@@ -355,24 +376,21 @@ int spinor_erase_sector(u32 sector)
 	return 0;
 }
 
-int spinor_erase_sector_4K(u32 sector)
+void spinor_flash_reset(void)
 {
-	u32 address;
-	u8 status;
-
-	spinor_send_alone_cmd(SPINOR_CMD_WREN);
-
-	address = sector * SPINOR_SECTOR_SIZE;
-	spinor_write_reg(SPINOR_CMD_SE_4K, &address, spi_nor_addr_mode);
-
-	do {
-		spinor_read_reg(SPINOR_CMD_RDSR, &status, sizeof(status));
-	} while (status & 0x1);
-
-	if (status & 0x20)
-		return -1;
-
-	return 0;
+	switch (JEDEC_MFR(flspinor.jedec)) {
+		case CFI_MFR_MICRON:
+		case CFI_MFR_MACRONIX:
+		case CFI_MFR_WINBOND:
+		case CFI_MFR_GD:
+			spinor_send_alone_cmd(FLASH_RESET_ENABLE);
+			spinor_send_alone_cmd(FLASH_RESET_MEMORY);
+			return;
+		default:
+			/* Spansion style */
+			spinor_send_alone_cmd(FLASH_RESET);
+			return;
+	}
 }
 
 int spinor_read_data_diofr(u32 address, void *buf, int len)
@@ -392,12 +410,12 @@ int spinor_read_data_diofr(u32 address, void *buf, int len)
 		cmd.is_dtr = 0;
 
 		addr.buf = (u8 *)&address;
-		addr.len = spi_nor_addr_mode;
+		addr.len = flspinor.addr_width;
 		addr.lane = 2;
 		addr.is_dtr = 0;
 
-		if ((u32)buf & 0x7) {
-			n = 8 - ((u32)buf & 0x7);
+		if ((uintptr_t)buf & 0x7) {
+			n = 8 - ((uintptr_t)buf & 0x7);
 			is_dma = 0;
 		} else {
 			n = min(SPINOR_MAX_DATA_LENGTH, len);
@@ -447,12 +465,12 @@ int spinor_read_data_ddrdior(u32 address, void *buf, int len)
 		cmd.is_dtr = 0;
 
 		addr.buf = (u8 *)&address;
-		addr.len = spi_nor_addr_mode;
+		addr.len = flspinor.addr_width;
 		addr.lane = 2;
 		addr.is_dtr = 1;
 
-		if ((u32)buf & 0x7) {
-			n = 8 - ((u32)buf & 0x7);
+		if ((uintptr_t)buf & 0x7) {
+			n = 8 - ((uintptr_t)buf & 0x7);
 			is_dma = 0;
 		} else {
 			n = min(SPINOR_MAX_DATA_LENGTH, len);
@@ -502,12 +520,12 @@ int spinor_read_data_dor(u32 address, void *buf, int len)
 		cmd.is_dtr = 0;
 
 		addr.buf = (u8 *)&address;
-		addr.len = spi_nor_addr_mode;
+		addr.len = flspinor.addr_width;
 		addr.lane = 1;
 		addr.is_dtr = 0;
 
-		if ((u32)buf & 0x7) {
-			n = 8 - ((u32)buf & 0x7);
+		if ((uintptr_t)buf & 0x7) {
+			n = 8 - ((uintptr_t)buf & 0x7);
 			is_dma = 0;
 		} else {
 			n = min(SPINOR_MAX_DATA_LENGTH, len);
@@ -557,7 +575,7 @@ int spinor_read_data_dior(u32 address, void *buf, int len)
 		cmd.lane = 1;
 		cmd.is_dtr = 0;
 
-		switch (JEDEC_MFR(spi_nor_id)) {
+		switch (JEDEC_MFR(flspinor.jedec)) {
 		case CFI_MFR_MICRON:
 			//micron DIOR mode is 3 bytes
 			addr.len = 3;
@@ -575,8 +593,8 @@ int spinor_read_data_dior(u32 address, void *buf, int len)
 		addr.lane = 2;
 		addr.is_dtr = 0;
 
-		if ((u32)buf & 0x7) {
-			n = 8 - ((u32)buf & 0x7);
+		if ((uintptr_t)buf & 0x7) {
+			n = 8 - ((uintptr_t)buf & 0x7);
 			is_dma = 0;
 		} else {
 			n = min(SPINOR_MAX_DATA_LENGTH, len);
@@ -625,12 +643,12 @@ int spinor_read_data_read(u32 address, void *buf, int len)
 		cmd.is_dtr = 0;
 
 		addr.buf = (u8 *)&address;
-		addr.len = spi_nor_addr_mode;
+		addr.len = flspinor.addr_width;
 		addr.lane = 1;
 		addr.is_dtr = 0;
 
-		if ((u32)buf & 0x7) {
-			n = 8 - ((u32)buf & 0x7);
+		if ((uintptr_t)buf & 0x7) {
+			n = 8 - ((uintptr_t)buf & 0x7);
 			is_dma = 0;
 		} else {
 			n = min(SPINOR_MAX_DATA_LENGTH, len);
@@ -682,19 +700,24 @@ int spinor_write_data(u32 address, void *buf, int len)
 		cmd.is_dtr = 0;
 
 		addr.buf = (u8 *)&address;
-		addr.len = spi_nor_addr_mode;
+		addr.len = flspinor.addr_width;
 		addr.lane = 1;
 		addr.is_dtr = 0;
 
-		bound = SPINOR_PAGE_SIZE - (address % SPINOR_PAGE_SIZE);
-		if ((u32)buf & 0x7) {
-			n = 8 - ((u32)buf & 0x7);
-			n = min(n, bound);
-			is_dma = 0;
-		} else {
-			n = min(len, bound);
-			is_dma = 1;
+		/* Use dma transfer as default setting */
+		is_dma = 1;
+
+		bound = flspinor.page_size - (address % flspinor.page_size);
+		n = min(len, bound);
+
+		if (n % 4){
+			if (n > 4) {
+				n -= n % 4;
+			} else {
+				is_dma = 0;
+			}
 		}
+
 		data.buf = buf;
 		data.len = n;
 		data.lane = 1;
@@ -749,7 +772,7 @@ int spinor_write_boot_header(void)
 	header.addr_dtr = 0;
 	header.cmd_dtr = 0;
 	/* SPINOR_CFG_REG */
-	header.rxsampdly = 1;
+	header.rxsampdly = 0;
 	header.rsvd2 = 0;
 	header.chip_sel = (~(1 << (SPINOR_FLASH_CHIP_SEL))) & 0xff;
 	header.hold_timing = 0;
@@ -770,8 +793,68 @@ int spinor_write_boot_header(void)
 	return rval;
 }
 
+static int spinor_flash_4b_mode(const struct spi_flash_info *info, int enable)
+{
+	int ret = 0;
+	u8 need_wren = 0;
+	u8 cmd, val;
+	switch (JEDEC_MFR(info->jedec)) {
+		case CFI_MFR_MICRON:
+			need_wren = 1;
+		case CFI_MFR_MACRONIX:
+		case CFI_MFR_WINBOND:
+		case CFI_MFR_GD:
+			if (need_wren)
+				spinor_send_alone_cmd(SPINAND_CMD_WREN);
+			cmd = enable ? OPCODE_EN4B : OPCODE_EX4B;
+			ret = spinor_send_alone_cmd(cmd);
+			if (need_wren)
+				spinor_send_alone_cmd(SPINAND_CMD_WRDI);
+			return ret;
+		default:
+			/* Spansion style */
+			val = enable << 7;
+			ret = spinor_write_reg(OPCODE_BRWR, &val, sizeof(u8));
+			return ret;
+	}
+}
+
+static const struct spi_flash_info *spi_nor_check_id(void)
+{
+	const struct spi_flash_info *flash_info;
+	u16 jedec, ext_jedec;
+	u8 id[SPI_NOR_MAX_ID_LEN];
+
+	spinor_read_reg(SPINOR_CMD_READID, id, SPI_NOR_MAX_ID_LEN);
+
+	jedec = id[1] << 8 | id[2];
+	ext_jedec = id[3] << 8 | id[4];
+
+	/* Validate params from spi_nor_ids table */
+	flash_info = spi_nor_ids;
+	for (; flash_info->name != NULL; flash_info++) {
+		if ((flash_info->jedec >> 16) == id[0]) {
+			if ((flash_info->jedec & 0xFFFF) == jedec) {
+				if (flash_info->ext_jedec == 0)
+					break;
+				else if (flash_info->ext_jedec == ext_jedec)
+					break;
+			}
+		}
+	}
+
+	if (!flash_info->name) {
+		printf("SF: Unsupported flash IDs: ");
+		printf("manuf %02x, jedec %04x, ext_jedec %04x\n",
+		       id[0], jedec, ext_jedec);
+		return NULL;
+	}
+	return flash_info;
+}
+
 int spinor_init(void)
 {
+	const struct spi_flash_info *info = NULL;
 	int part_size[TOTAL_FW_PARTS];
 	u32 divider, val, i;
 	u32 ssec, nsec;
@@ -793,6 +876,7 @@ int spinor_init(void)
 	      SPINOR_CFG_CHIPSEL(SPINOR_FLASH_CHIP_SEL) |
 	      SPINOR_CFG_CLKDIV(divider) |
 	      SPINOR_CFG_RXSAMPDLY(SPINOR_RX_SAMPDLY);
+
 	writel(SPINOR_CFG_REG, val);
 
 	/* mask all interrupts */
@@ -810,9 +894,22 @@ int spinor_init(void)
 	writel(SPINOR_TXFIFOTHLV_REG, 31);
 	writel(SPINOR_RXFIFOTHLV_REG, 31);
 
-	flspinor.page_size = SPINOR_PAGE_SIZE;
-	flspinor.sector_size = SPINOR_SECTOR_SIZE;
-	flspinor.chip_size = SPINOR_CHIP_SIZE;
+	info = spi_nor_check_id();
+	if (!info) {
+		printf("Do not found match spinor \n");
+		return -1;
+	}
+
+	flspinor.page_size = info->page_size;
+	flspinor.sector_size = info->sector_size;
+	flspinor.chip_size = info->sector_size * info->nr_sectors;
+	flspinor.sectors_per_chip = info->nr_sectors;
+	flspinor.jedec = info->jedec;
+
+	if (info->flags & SECT_4K)
+		flspinor.erase_opcode = SPINOR_CMD_SE_4K;
+	else
+		flspinor.erase_opcode = SPINOR_CMD_SE;
 
 	ssec = nsec = 0;
 	get_part_size(part_size);
@@ -830,26 +927,26 @@ int spinor_init(void)
 		return -1;
 	}
 
-	spinor_flash_reset();
-
-	val = 0;
-	spinor_read_reg(SPINOR_CMD_READID, &val, sizeof(val));
-
-	putstr("spinor flash ID is 0x");
-	puthex(val);
-	putstr("\r\n");
-	spi_nor_id = val;
+	if(info->rx_sample_delay) {
+		val = SPINOR_CFG_FLOWCTRL_EN |
+			  SPINOR_CFG_HOLDPIN(3) |
+			  SPINOR_CFG_CHIPSEL(SPINOR_FLASH_CHIP_SEL) |
+			  SPINOR_CFG_CLKDIV(divider) |
+			  SPINOR_CFG_RXSAMPDLY(info->rx_sample_delay);
+		writel(SPINOR_CFG_REG, val);
+	}
 
 	if (flspinor.chip_size > 0x1000000) {
-		ret = spinor_flash_4b_mode();
-		if (SUPPORT_DTR_DUAL)
-			spinor_read_data = spinor_read_data_ddrdior;
+		flspinor.addr_width = 4;
+		ret = spinor_flash_4b_mode(info, 1);
+		if (info->flags & SPI_NOR_DTR_DUAL_READ)
+			flspinor.read = spinor_read_data_ddrdior;
 		else
-			spinor_read_data = spinor_read_data_diofr;
+			flspinor.read = spinor_read_data_diofr;
 	} else {
-		spi_nor_addr_mode = 3;
-		spinor_read_data = spinor_read_data_dior;
+		flspinor.addr_width = 3;
+		flspinor.read = spinor_read_data_dior;
 	}
-	return 0;
+	return ret;
 }
 
diff --git a/src/bld/strutil.c b/src/bld/strutil.c
index aeacc87..61ad74b 100644
--- a/src/bld/strutil.c
+++ b/src/bld/strutil.c
@@ -4,12 +4,30 @@
  * History:
  *    2005/08/18 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 /*-
@@ -139,6 +157,22 @@ char *strchr(const char * s, int c)
 	return (char *) s;
 }
 
+char *strstr(const char *s1, const char *s2, int n)
+{
+	int len = strlen(s2);
+
+	if (!len)
+		return NULL;
+
+	while (n--){
+		if(*s1 == *s2)
+			if(!strncmp(s1, s2, len))
+				return (char *)s1;
+		s1++;
+	}
+	return NULL;
+}
+
 void *memchr(const void *s, int c, unsigned int n)
 {
 	const unsigned char *p = s;
@@ -150,7 +184,7 @@ void *memchr(const void *s, int c, unsigned int n)
 	return NULL;
 }
 
-int strtou32(const char *str, u32 *endptr)
+int strtou32(const char *str, unsigned int *endptr)
 {
 	const char *s = str;
 	unsigned long acc;
@@ -324,19 +358,18 @@ int str_to_ipaddr(const char *src, u32 *addr)
 	return 0;
 }
 
-char *strstr(const char *s1, const char *s2, int n)
+void hex_to_str(const u32 hex, char *dest)
 {
-	int len = strlen(s2);
-
-	if (!len)
-		return NULL;
-
-	while (n--){
-		if(*s1 == *s2)
-			if(!strncmp(s1, s2, len))
-				return (char *)s1;
-		s1++;
+	char i, c;
+
+	for (i = 0; i < 32; i += 4) {
+		c = (hex >> (28 - i)) & 0xf;
+		if (c >= 10)
+			dest[i/4] = 'a' + c - 10;
+		else
+			dest[i/4] = '0' + c;
 	}
-	return NULL;
+
+	dest[8] = '\0';
 }
 
diff --git a/src/bld/uart.c b/src/bld/uart.c
index bee69f8..12bdfb5 100644
--- a/src/bld/uart.c
+++ b/src/bld/uart.c
@@ -5,35 +5,59 @@
  *    2005/01/27 - [Charles Chiou] created file
  *    2014/02/13 - [Anthony Ginger] Amboot V2
  *
- * Copyright (C) 2004-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
 #include <ambhw/uart.h>
 #include <ambhw/gpio.h>
 
-#if defined(SECURE_BOOT)
-#include "secure/secure_boot.h"
-#endif
-
 /* ==========================================================================*/
 #if defined(CONFIG_AMBOOT_ENABLE_UART0)
 #define CONFIG_BUILD_WITH_UART
-
 #define uart_writeb(p, v)		__raw_writeb(v, UART0_REG(p))
 #define uart_readb(p)			__raw_readb(UART0_REG(p))
-
+#define uart_setclk()			rct_set_uart_pll(CG_UART_REG)
+#define uart_getclk()			get_uart_freq_hz(CG_UART_REG)
+#elif defined(CONFIG_AMBOOT_ENABLE_UART1)
+#define CONFIG_BUILD_WITH_UART
+#define uart_writeb(p, v)		__raw_writeb(v, UART1_REG(p))
+#define uart_readb(p)			__raw_readb(UART1_REG(p))
+#define uart_setclk()			rct_set_uart_pll(CG_UART1_REG);
+#define uart_getclk()			get_uart_freq_hz(CG_UART1_REG)
+#elif defined(CONFIG_AMBOOT_ENABLE_UART2)
+#define CONFIG_BUILD_WITH_UART
+#define uart_writeb(p, v)		__raw_writeb(v, UART2_REG(p))
+#define uart_readb(p)			__raw_readb(UART2_REG(p))
+#define uart_setclk()			rct_set_uart_pll(CG_UART2_REG);
+#define uart_getclk()			get_uart_freq_hz(CG_UART2_REG)
 #else
 #undef CONFIG_BUILD_WITH_UART
-
 #define uart_writeb(p, v)
 #define uart_readb(p)
-
 #endif
 
 #if defined(AMBOOT_UART_19200)
@@ -53,9 +77,9 @@ void uart_init(void)
 	u32 clk;
 	u16 dl;
 
-	rct_set_uart_pll();
+	uart_setclk();
 	uart_writeb(UART_SRR_OFFSET, 0x00);
-	clk = get_uart_freq_hz();
+	clk = uart_getclk();
 	dl = clk * 10 / uart_baud / 16;
 	if (dl % 10 >= 5) {
 		dl = (dl / 10) + 1;
@@ -203,9 +227,8 @@ int uart_read(void)
 void uart_flush_input(void)
 {
 #if defined(CONFIG_BUILD_WITH_UART)
-	unsigned char dump;
 	while (uart_readb(UART_LS_OFFSET) & UART_LS_DR) {
-		dump = uart_readb(UART_RB_OFFSET);
+		uart_readb(UART_RB_OFFSET);
 	}
 #endif
 }
@@ -349,203 +372,3 @@ int uart_getblock(char *buf, int n, int timeout)
 	return nread;
 }
 
-#if defined(SECURE_BOOT)
-
-static int uart_get_readable_string(const char* begin, int head_length, char* string, int number)
-{
-	int c;
-	int i = 0;
-
-uart_get_readable_string_resync_get:
-
-	for (i = 0; i < head_length; i++) {
-		while (uart_poll() == 0) {
-			//rct_timer_delay_ticks(5);
-			continue;
-		}
-
-		c = uart_read();
-
-		if ((c == '\r') || (c == '\n')) {
-			goto uart_get_readable_string_resync_get;
-		}
-
-		if (c != begin[i]) {
-			putchar((char) c);
-			putstr(":read header fail\r\n");
-			return (-1);
-		}
-	}
-
-	for (i = 0; i < number; i++) {
-		while (uart_poll() == 0) {
-			//rct_timer_delay_ticks(5);
-			continue;
-		}
-
-		c = uart_read();
-		if ((c == '\r') || (c == '\n')) {
-			putstr("read content fail\r\n");
-			return (-3);
-		}
-		string[i] = c;
-	}
-
-	return 0;
-}
-
-static int uart_get_readable_string_variable_length(const char* begin, char* string, int number)
-{
-	int c;
-	int i = 0;
-
-uart_get_readable_string_variable_length_resync_get:
-
-	for (i = 0; i < 4; i++) {
-		while (uart_poll() == 0) {
-			//rct_timer_delay_ticks(5);
-			continue;
-		}
-
-		c = uart_read();
-
-		if ((c == '\r') || (c == '\n')) {
-			goto uart_get_readable_string_variable_length_resync_get;
-		}
-
-		if (c != begin[i]) {
-			putchar((char) c);
-			putstr(":read header fail\r\n");
-			return (-1);
-		}
-	}
-
-	for (i = 0; i < number; i++) {
-		while (uart_poll() == 0) {
-			//rct_timer_delay_ticks(5);
-			continue;
-		}
-
-		c = uart_read();
-		if ((c == '\r') || (c == '\n')) {
-			break;
-		}
-		string[i] = c;
-	}
-
-	if (i == number) {
-		putstr("read string exceed length\r\n");
-		return (-2);
-	}
-
-	return 0;
-}
-
-int uart_get_rsakey_1024(void* p_key)
-{
-	int ret = 0;
-	rsa_key_t* p_rsa_key = (rsa_key_t*) p_key;
-
-	ret = uart_get_readable_string("N = ", 4, p_rsa_key->n, 256);
-	if (ret) {
-		putstr("read n fail\r\n");
-		return ret;
-	}
-
-	ret = uart_get_readable_string_variable_length("E = ", p_rsa_key->e, 16);
-	if (ret) {
-		putstr("read e fail\r\n");
-		return ret;
-	}
-
-	ret = uart_get_readable_string("D = ", 4, p_rsa_key->d, 256);
-	if (ret) {
-		putstr("read d fail\r\n");
-		return ret;
-	}
-
-	ret = uart_get_readable_string("P = ", 4, p_rsa_key->p, 128);
-	if (ret) {
-		putstr("read p fail\r\n");
-		return ret;
-	}
-
-	ret = uart_get_readable_string("Q = ", 4, p_rsa_key->q, 128);
-	if (ret) {
-		putstr("read q fail\r\n");
-		return ret;
-	}
-
-	ret = uart_get_readable_string("DP = ", 5, p_rsa_key->dp, 128);
-	if (ret) {
-		putstr("read dp fail\r\n");
-		return ret;
-	}
-
-	ret = uart_get_readable_string("DQ = ", 5, p_rsa_key->dq, 128);
-	if (ret) {
-		putstr("read dq fail\r\n");
-		return ret;
-	}
-
-	ret = uart_get_readable_string("QP = ", 5, p_rsa_key->qp, 128);
-	if (ret) {
-		putstr("read qp fail\r\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-void uart_print_rsakey_1024(void* p_key)
-{
-	rsa_key_t* p_rsa_key = (rsa_key_t*) p_key;
-
-	uart_putstr("print rsa key for debug:\r\n");
-
-	uart_putstr("N = ");
-	uart_putstr((const char*) p_rsa_key->n);
-	uart_putstr("\r\n");
-
-	uart_putstr("E = ");
-	uart_putstr((const char*) p_rsa_key->e);
-	uart_putstr("\r\n");
-
-	uart_putstr("D = ");
-	uart_putstr((const char*) p_rsa_key->d);
-	uart_putstr("\r\n");
-
-	uart_putstr("P = ");
-	uart_putstr((const char*) p_rsa_key->p);
-	uart_putstr("\r\n");
-
-	uart_putstr("Q = ");
-	uart_putstr((const char*) p_rsa_key->q);
-	uart_putstr("\r\n");
-
-	uart_putstr("DP = ");
-	uart_putstr((const char*) p_rsa_key->dp);
-	uart_putstr("\r\n");
-
-	uart_putstr("DQ = ");
-	uart_putstr((const char*) p_rsa_key->dq);
-	uart_putstr("\r\n");
-
-	uart_putstr("QP = ");
-	uart_putstr((const char*) p_rsa_key->qp);
-	uart_putstr("\r\n");
-
-	return;
-}
-
-#endif
-
-int uart_get_onechar_blocked()
-{
-	while (uart_poll() == 0) {
-		continue;
-	}
-
-	return uart_read();
-}
-
diff --git a/src/bld/usb_drv.c b/src/bld/usb_drv.c
index cb60d38..53f1fa1 100644
--- a/src/bld/usb_drv.c
+++ b/src/bld/usb_drv.c
@@ -6,25 +6,42 @@
  *
  *    Notes: The data pointer for USB DMA TX/RX should be aligned to 8-bytes
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <amboot.h>
-#include <ambhw/vic.h>
+#include <irq.h>
 #include <ambhw/cache.h>
 #include <ambhw/usbdc.h>
-
 #include <bldfunc.h>
+#include "descriptor.h"
 #include "hwusbreg.h"
 #include "hwusbcfg.h"
-#include "bld_usb_descriptors.c"
 
-#define _VERSION_	"Version 0.1"
+#include "bld_usb_descriptors.c"
 
 #define _DEBUG_
 
@@ -38,22 +55,11 @@
 #define _DEBUG_PRINTK(...)
 #endif
 
-#ifdef _DEBUG_
-#define _DEBUG_PRINTHEX puthex
-#else
-#define _DEBUG_PRINTHEX(...)
-#endif
-
-#ifdef _DEBUG_
-#define _DEBUG_PRINTDEC putdec
-#else
-#define _DEBUG_PRINTDEC(...)
-#endif
-
 #define QUEUE_DEPTH		10
 #define DEFAULT_PLL_MODE	7
-#define DESCRIPTOR_BASE(x) 	((u32)descriptor_buf[x])
-#define BUFFER_BASE(x)		((u32)data_buf[x])
+
+#define DMA_DESC_ADDR(x) 	dma_desc_buf[x]
+#define DMA_BUF_ADDR(x) 	dma_data_buf[x]
 #define RETRY_COUNT		2
 #define FAILED			1
 #define SUCCESSED		0
@@ -65,9 +71,20 @@
 #define FLAG_JUMP_EXEC		0x04
 #define FLAG_COMMAND		0x08
 #define FLAG_FORCE_FINISH	0x10
+#define bulk_process_trylock()		do { \
+										if (!bulk_process_lock) \
+											bulk_process_lock = 1; \
+											} while(0)
+
+#define bulk_process_tryunlock()	do { \
+										if (bulk_process_lock) \
+											bulk_process_lock = 0; \
+											} while(0)
+
+#define bulk_process_is_locked()	(!!bulk_process_lock)
 
 typedef struct _buf_info {
-	u32 addr;
+	uintptr_t addr;
 	u32 length;
 	u32 crc_value;
 } buf_info_t;
@@ -75,114 +92,96 @@ typedef struct _buf_info {
 typedef struct _transfer_info {
 	volatile u32	flag;
 	volatile u32	task_finished;
-	u32		jump_address;
+	uintptr_t	jump_address;
 	u32		total_length;
 	buf_info_t 	tx;
 	buf_info_t 	rx;
 } transfer_info_t;
 
-void usb_isr(void);
-void device_interrupt(u32 int_value);
-void endpoint_in_interrupt(u32 int_value);
-void endpoint_out_interrupt(u32 int_value);
-void init_setup_descriptor(int ep_num);
-void init_endpoint(int ep_num, int speed);
-void init_data_descriptor(u32 ep_num);
-u32 init_usb_hardware(void);
-u32 start_tx(u32 ep_num, u32 *buf_ptr, u32 *pkt_size);
-void start_rx(u32 ep_num, u32 *buf_ptr);
-int  usb_task(void);
-void bulk_in_handler(void);
-void rx_fsm(COMMAND_QUEUE *cur_cmd);
-void control_out_handler(void);
-void decode_request(void);
-void config_endpoint(void);
-void get_descriptor(void);
-void init_usb_dev(void);
-u32 usb_download(void *addr,int exec, int test_case);
-void init_usb_pll(void);
-void init_udc_reg(void);
-void print_twiddle(void);
-void set_softdisc(void);
-static void do_reboot(void);
-void usb_download_file (u32 addr);
-void usb_download_kernel (int is_fw_prog);
-void usb_test_download (void);
-//void usb_test_pll (void);
-void usb_test (int flag);
-
-
-/* This is the global usb device data structure container */
-static struct USBDEV usbd;
-static struct USB_EP_UDC_REG *udc_reg[EP_NUM];
-
-/* external function */
-extern u32 crc32(const void *buf, unsigned int size);
-extern void rct_enable_usb(void);
-//extern int nand_load(u32 sblk, u32 nblk, u32 mem_addr, u32 img_len);
-
 /* Fixed descriptor address */
 extern u8 *uds_bld_descriptors[];
 extern u8 uds_bld_configuration1_hs[];
 extern u8 uds_bld_configuration1_fs[];
 
-u32 setup_desc[64] __attribute__ ((aligned(32), section(".bss.noinit")));
-u32 descriptor_buf[8][64] __attribute__ ((aligned(32), section(".bss.noinit")));
-u8 data_buf[8][1024] __attribute__ ((aligned(32), section(".bss.noinit")));
-DEV_RSP dev_response __attribute__ ((aligned(32), section(".bss.noinit")));
+static u32 setup_desc[16] __attribute__ ((aligned(32), section(".bss.noinit")));
+static u32 dma_desc_buf[EP_NUM][16] __attribute__ ((aligned(32), section(".bss.noinit")));
+static u8 dma_data_buf[EP_NUM][1024] __attribute__ ((aligned(32), section(".bss.noinit")));
+static DEV_RSP dev_response __attribute__ ((aligned(32), section(".bss.noinit")));
 
 static u8 twiddle[] ={'\\','|','/','-'};
 
-volatile COMMAND_QUEUE	command[QUEUE_DEPTH]
-	__attribute__ ((section(".bss.noinit")));;
-volatile WAIT_QUEUE	response[QUEUE_DEPTH]
-	__attribute__ ((section(".bss.noinit")));;
-volatile QUEUE_INDEX	qindex={0};
+volatile COMMAND_QUEUE command[QUEUE_DEPTH] __attribute__ ((section(".bss.noinit")));
+volatile WAIT_QUEUE response[QUEUE_DEPTH] __attribute__ ((section(".bss.noinit")));
+volatile QUEUE_INDEX qindex={0};
 
 transfer_info_t transfer;
 static u32 rx_state = COMMAND_PHASE;
 static int enable_usb = 0;	/* identify if usb is initialized */
+static u32 usb_speed = USB_HS;
+static volatile int ep_event[EP_NUM] = {0};
+/* FIXME: When USB device is transmitting binary from host, the host may request a
+ * configuration description(why?). We need ignore this request. */
+static volatile int bulk_process_lock = 0;
 
 
 /* =========================================================
  * Global Function Call
  * =========================================================*/
 
-/*
- * Name: usb_isr
- * Description:
- *	ISR for CPU to handle the USB interrupt signal
- *	Dispatch interrupt to device/endpoint interrupt
- * 	BIT(0)	- device interrupt
- *  	BIT(1)	- OUT endpoint interrupt
- *	BIT(2)	- IN endpoint interrupt
- *	BIT(16) - unknown interrupt from endpoint interrupt
- *	0 	- no recognized interrupt source
- * Input :
- * Return:
- */
-void usb_isr(void)
+void usb_dump(u32 ep, void *data, int size)
+{
+#ifdef USB_DUMP
+	int i;
+	char *ctrl = data;
+	int *bulk = data;
+	int sz = size > 32 ? 32 : size;
+	char *epx[4] = {"CTRL_IN", "BULK_IN", "CTRL_OUT", "BULK_OUT"};
+
+	if ((!ctrl[0] && !ctrl[1] && !ctrl[2] && !ctrl[3])
+			|| (size == 512))
+		return ;
+
+	printf("EP: %s	SZ: %d", epx[ep], size);
+
+	if (ep == CTRL_IN || (ep == CTRL_OUT))
+	{
+		for (i = 0; i < sz; i++) {
+
+			if (i % 12 == 0)
+				printf("\n");
+			printf("%02x ", ctrl[i]);
+		}
+	} else {
+
+		for (i = 0; i < sz / 4; i++) {
+			if (i % 4 == 0)
+				printf("\n");
+			printf("%08x ", bulk[i]);
+		}
+	}
+	printf("\n\n");
+#endif
+}
+
+static void usb_isr(void *data)
 {
-	volatile u32	value = 0;
+	u32 value = 0;
 
 	if(!enable_usb) /* this could be ethernet interrupt on A2, just return */
 		return;
 
-	/* disable USB interrupt in VIC */
-	/* not really necessary */
-	vic_disable(USBC_IRQ);
-
 	/* 1. check if device interrupt */
-	value = usbd.dev_reg->intr;
+
+	value = readl(USB_DEV_INTR_REG);
 	if(value) {
 		/* ack the interrupt */
-		usbd.dev_reg->intr = value;
+		writel(USB_DEV_INTR_REG, value);
 
 		device_interrupt(value);
 
 	}
 	/* 2. check if endpoint interrupt */
-	value = usbd.dev_reg->ep_intr;
+	value = readl(USB_DEV_EP_INTR_REG);
 	if(value) {
 
 		if(value & USB_DEV_EP_OUT) {
@@ -200,12 +199,6 @@ void usb_isr(void)
 
 		}
 	}
-
-	/* re-enable USB interrupt */
-	/* not really necessary */
-	vic_enable(USBC_IRQ);
-
-
 }
 
 /*
@@ -218,13 +211,7 @@ void usb_isr(void)
  */
 void device_interrupt(u32 int_value)
 {
-	volatile struct USB_EP_OUT_REG 	*out_reg = NULL;
-	volatile struct USB_EP_IN_REG  	*in_reg = NULL;
-	volatile struct USB_DEV_REG	*dev_reg = NULL;
-	u32 				value = 0;
-	u32				serviced_int = 0;
-
-	dev_reg = usbd.dev_reg;
+	u32 value = 0, serviced_int = 0;
 
 	/* case 1. enumeration complete */
 	if(int_value & USB_DEV_ENUM_CMPL) {
@@ -232,45 +219,48 @@ void device_interrupt(u32 int_value)
 		init_udc_reg();
 
 		serviced_int = USB_DEV_ENUM_CMPL;
-		value = dev_reg->status & USB_DEV_ENUM_SPD;
+		value = readl(USB_DEV_STS_REG) & USB_DEV_ENUM_SPD ;
 
-		usbd.speed = _SPEED_(value);
+		usb_speed = _SPEED_(value);
 
-		if(usbd.speed == USB_HS) {  /* high speed */
+		if(usb_speed == USB_HS) {  /* high speed */
 
 //			_DEBUG_PRINTK("enum HS",0);
 			/* set BULK_IN size register */
-			in_reg = (struct USB_EP_IN_REG *)usbd.ep[BULK_IN];
-			value = udc_reg[BULK_IN]->value;
+			writel(USB_EP_IN_MAX_PKT_SZ_REG(BULK_IN_ID),
+						USB_EP_BULKIN_MAX_PKT_SZ_HI);
+			value = readl(USB_UDC_REG(BULK_IN));
 			value &= (~USB_UDC_MAX_PKT_SZ);
 			value |= USB_UDC_BULKIN_MAX_PKT_SZ_HI;
-			udc_reg[BULK_IN]->value = value;
-			in_reg->max_pkt_size = USB_EP_BULKIN_MAX_PKT_SZ_HI;
+			writel(USB_UDC_REG(BULK_IN), value);
+
+
 			/* set BULK_OUT size register */
-			out_reg = (struct USB_EP_OUT_REG *)usbd.ep[BULK_OUT];
-			value = udc_reg[BULK_OUT]->value;
+			writel(USB_EP_OUT_MAX_PKT_SZ_REG(BULK_OUT_ID),
+						USB_EP_BULKOUT_MAX_PKT_SZ_HI);
+			value = readl(USB_UDC_REG(BULK_OUT));
 			value &= (~USB_UDC_MAX_PKT_SZ);
 			value |= USB_UDC_BULKIN_MAX_PKT_SZ_HI;
-			udc_reg[BULK_OUT]->value = value;
-			out_reg->max_pkt_size = USB_EP_BULKOUT_MAX_PKT_SZ_HI;
+			writel(USB_UDC_REG(BULK_OUT), value);
 
-		} else if (usbd.speed == USB_FS) { /* full speed */
+		} else if (usb_speed == USB_FS) { /* full speed */
 
 //			_DEBUG_PRINTK("enum FS",0);
 			/* set BULK_IN size register */
-			in_reg = (struct USB_EP_IN_REG *)usbd.ep[BULK_IN];
-			value = udc_reg[BULK_IN]->value;
+			writel(USB_EP_IN_MAX_PKT_SZ_REG(BULK_IN_ID),
+						USB_EP_BULKIN_MAX_PKT_SZ_FU);
+			value = readl(USB_UDC_REG(BULK_IN));
 			value &= (~USB_UDC_MAX_PKT_SZ);
 			value |= USB_UDC_BULKIN_MAX_PKT_SZ_FU;
-			udc_reg[BULK_IN]->value = value;
-			in_reg->max_pkt_size = USB_EP_BULKIN_MAX_PKT_SZ_FU;
+			writel(USB_UDC_REG(BULK_IN), value);
+
 			/* set BULK_IN size register */
-			out_reg = (struct USB_EP_OUT_REG *)usbd.ep[BULK_OUT];
-			value = udc_reg[BULK_OUT]->value;
+			writel(USB_EP_OUT_MAX_PKT_SZ_REG(BULK_OUT_ID),
+						USB_EP_BULKOUT_MAX_PKT_SZ_FU);
+			value = readl(USB_UDC_REG(BULK_OUT));
 			value &= (~USB_UDC_MAX_PKT_SZ);
 			value |= USB_UDC_BULKIN_MAX_PKT_SZ_FU;
-			udc_reg[BULK_OUT]->value = value;
-			out_reg->max_pkt_size = USB_EP_BULKOUT_MAX_PKT_SZ_FU;
+			writel(USB_UDC_REG(BULK_OUT), value);
 
 		} else {
 
@@ -288,14 +278,15 @@ void device_interrupt(u32 int_value)
 			serviced_int |= USB_DEV_SET_INTF;
 
 	  	/* unlock endpoint stall status */
-		in_reg = (struct USB_EP_IN_REG *)usbd.ep[CTRL_IN];
-		in_reg->control &= (~USB_EP_STALL);
+		clrbitsl(USB_EP_IN_CTRL_REG(CTRL_IN_ID), USB_EP_STALL);
 
 		/* told UDC the configuration is done, and to ack HOST */
-		dev_reg->control |= USB_DEV_CSR_DONE ;
+		value = readl(USB_DEV_CTRL_REG);
+		value |= USB_DEV_CSR_DONE;
+		writel(USB_DEV_CTRL_REG, value);
 
 		/* The device is full configured, data IN/OUT can be started */
-		start_rx(BULK_OUT, (u32 *)usbd.ep_buffer[BULK_OUT]);
+		start_rx(BULK_OUT, DMA_BUF_ADDR(BULK_OUT));
 
 
 	}
@@ -306,43 +297,35 @@ void device_interrupt(u32 int_value)
 	if(serviced_int != int_value) {
 		/* some interrupts are not serviced, why ? */
 		_DEBUG_PRINTK("serviced_int= ",serviced_int);
-		dev_reg->intr = serviced_int;
+		writel(USB_DEV_INTR_REG, serviced_int);
 	}
 }
-/*
- * Name: endpoint_in_interrupt
- * Description:
- *	Process IN(CTRL or BULK) endpoint interrupt
- * Input :
- * Return:
- */
+
 void endpoint_in_interrupt(u32 int_value)
 {
-	volatile struct USB_DEV_REG 	*dev_reg = NULL;
-	volatile struct USB_EP_IN_REG 	*in_reg = NULL;
 	struct USB_DATA_DESC *desc = NULL;
-	volatile u32 int_status = 0;
+	u32 int_status = 0;
 	volatile u32 value = 0;
 
-	dev_reg = usbd.dev_reg;
-
 	if(int_value & USB_DEV_EP1_IN) { /* BULK_IN */
 
 		/* ack the device interrupt */
-		dev_reg->ep_intr = USB_DEV_EP1_IN;
+		writel(USB_DEV_EP_INTR_REG, USB_DEV_EP1_IN);
 
-		in_reg = (struct USB_EP_IN_REG *)usbd.ep[BULK_IN];
-		int_status = in_reg->status;
+		int_status = readl(USB_EP_IN_STS_REG(BULK_IN_ID));
 //		_DEBUG_PRINTK("bulk in interrupt",int_status);
 
 		if(int_status & USB_EP_TRN_DMA_CMPL) {
 
 			/* if a previous TX DMA complete interrupt happens
 			   disable interrupt before next TX DMA is prepared */
-			dev_reg->ep_intrmask |= USB_DEV_EP1_IN;
+			writel(USB_DEV_EP_INTR_MSK_REG, readl(USB_DEV_EP_INTR_MSK_REG)|USB_DEV_EP1_IN);
 
 			/* acknowledge the status bit */
-			in_reg->status = USB_EP_TRN_DMA_CMPL;
+			writel(USB_EP_IN_STS_REG(BULK_IN_ID), USB_EP_TRN_DMA_CMPL);
+
+			/* Tx DMA finished, wakeup */
+			ep_event[BULK_IN_ID] = 1;
 
 			/* FIXME: this is a delay for PHY to finish sending and
 			   prevent from stopping transmitting */
@@ -352,10 +335,8 @@ void endpoint_in_interrupt(u32 int_value)
 			   then update the information in the command
 			   structure	*/
 			if(command[qindex.cmd_start].lock) {
-
 				/* update tx data size */
-				desc = (struct USB_DATA_DESC *)
-						in_reg->descriptor_p;
+				desc = (struct USB_DATA_DESC *)DMA_DESC_ADDR(BULK_IN);
 
 				command[qindex.cmd_start].done_size +=
 					(desc->status & USB_DMA_RXTX_BYTES);
@@ -379,31 +360,25 @@ void endpoint_in_interrupt(u32 int_value)
 			bulk_in_handler();
 
 			/* NAK the request before next IN packet is ready */
-			in_reg->control |= USB_EP_SET_NAK;
+			setbitsl(USB_EP_IN_CTRL_REG(BULK_IN_ID), USB_EP_SET_NAK);
 			/* acknowledge the status bit */
-			in_reg->status = USB_EP_IN_PKT;
+			writel(USB_EP_IN_STS_REG(BULK_IN_ID), USB_EP_IN_PKT);
 
 		}
 		if (int_status & USB_EP_BUF_NOT_AVAIL) {
-
-			in_reg->status = USB_EP_BUF_NOT_AVAIL;
+			writel(USB_EP_IN_STS_REG(BULK_IN_ID), USB_EP_BUF_NOT_AVAIL);
 			_DEBUG_PRINTK("BNA", 0);
-
 		}
 		if (int_status & USB_EP_HOST_ERR) {
-
-			in_reg->status = USB_EP_HOST_ERR;
+			writel(USB_EP_IN_STS_REG(BULK_IN_ID), USB_EP_HOST_ERR);
 			_DEBUG_PRINTK("HE", 0);
-
 		}
 		if (int_status & USB_EP_RCV_CLR_STALL) {
-			in_reg->status = USB_EP_RCV_CLR_STALL;
+			writel(USB_EP_IN_STS_REG(BULK_IN_ID), USB_EP_RCV_CLR_STALL);
 		}
 
 	} else {  			/* CTRL_IN */
-
-		in_reg = (struct USB_EP_IN_REG *)usbd.ep[CTRL_IN];
-		int_status = in_reg->status;
+		int_status = readl(USB_EP_IN_STS_REG(CTRL_IN_ID));
 
 		/* ack the device interrupt */
 		/* disable interrupt before next TX DMA is prepared */
@@ -411,14 +386,16 @@ void endpoint_in_interrupt(u32 int_value)
 		if(int_status & USB_EP_TRN_DMA_CMPL) {
 
 			/* disable EP0 IN interrupt */
-			dev_reg->ep_intrmask |= USB_DEV_EP0_IN;
+			writel(USB_DEV_EP_INTR_MSK_REG, readl(USB_DEV_EP_INTR_MSK_REG)| USB_DEV_EP0_IN);
 
 			/* acknowledge the DMA complete status */
-			while(in_reg->status & USB_EP_TRN_DMA_CMPL)
-			in_reg->status = USB_EP_TRN_DMA_CMPL;
+			writel(USB_EP_IN_STS_REG(CTRL_IN_ID), USB_EP_TRN_DMA_CMPL);
+
+			/* Tx DMA finished, wakeup */
+			ep_event[CTRL_IN_ID] = 1;
 
 			/* update tx data size */
-			desc = (struct USB_DATA_DESC *)in_reg->descriptor_p;
+			desc = (struct USB_DATA_DESC *)DMA_DESC_ADDR(CTRL_IN);
 
 			command[qindex.cmd_start].done_size +=
 					(desc->status & USB_DMA_RXTX_BYTES);
@@ -430,69 +407,51 @@ void endpoint_in_interrupt(u32 int_value)
 				_DEBUG_PRINTK("response index failed",0);
 
 		} else if (int_status & USB_EP_IN_PKT) {
-
-			/* acknowledge the status bit */
-			in_reg->status = USB_EP_IN_PKT;
+			writel(USB_EP_IN_STS_REG(CTRL_IN_ID), USB_EP_IN_PKT);
 
 		} else if (int_status & USB_EP_BUF_NOT_AVAIL) {
-
-			in_reg->status = USB_EP_BUF_NOT_AVAIL;
+			writel(USB_EP_IN_STS_REG(CTRL_IN_ID), USB_EP_BUF_NOT_AVAIL);
 
 		} else if (int_status & USB_EP_HOST_ERR) {
-
-			in_reg->status = USB_EP_HOST_ERR;
+			writel(USB_EP_IN_STS_REG(CTRL_IN_ID), USB_EP_HOST_ERR);
 
 		} else {  /* other interrupt reasons */
-
-			in_reg->status = int_status;
+			writel(USB_EP_IN_STS_REG(CTRL_IN_ID), int_status);
 			//_DEBUG_PRINTK("ep(in) int status=",int_status);
 		}
 
-		dev_reg->ep_intr = USB_DEV_EP0_IN;
+		writel(USB_DEV_EP_INTR_REG, USB_DEV_EP0_IN);
 	}
 }
 
-
-/*
- * Name: endpoint_out_interrupt
- * Description:
- *	Process OUT endpoint interrupt
- * Input :
- * Return:
- */
 void endpoint_out_interrupt(u32 int_value)
 {
-	volatile struct USB_DEV_REG 	*dev_reg = NULL;
-	volatile struct USB_EP_OUT_REG 	*out_reg = NULL;
-	volatile struct USB_SETUP_PKT 	*setup = NULL;
-	u32 int_status = 0;
+	struct USB_DATA_DESC *desc;
+	u32 dma_status = 0, int_status;
 	u32 ep_status = 0;
 	u32 rx_length = 0;
 
-	dev_reg = usbd.dev_reg;
-
 	if(int_value & USB_DEV_EP1_OUT) { /*** BULK_OUT ***/
 		/* ack the device interrupt */
-		dev_reg->ep_intr = USB_DEV_EP1_OUT;
+		writel(USB_DEV_EP_INTR_REG, USB_DEV_EP1_OUT);
 
-		out_reg = usbd.ep[BULK_OUT];
+		desc = (struct USB_DATA_DESC *)DMA_DESC_ADDR(BULK_OUT);
 
-		int_status = out_reg->descriptor_p->status;
+		dma_status = desc->status;
 
 		/* received data */
-		if((int_status & USB_DMA_BUF_STS) == USB_DMA_BUF_DMA_DONE) {
+		if((dma_status & USB_DMA_BUF_STS) == USB_DMA_BUF_DMA_DONE) {
 
-			rx_length = (out_reg->descriptor_p->status &
-					USB_DMA_RXTX_BYTES);
+			rx_length = dma_status & USB_DMA_RXTX_BYTES;
 
 			if (rx_length == 0)
 				_DEBUG_PRINTK("rx_length is 0",0);
 
 			/* disable OUT endpoint */
-			dev_reg->ep_intrmask |= USB_DEV_EP1_OUT;
+			writel(USB_DEV_EP_INTR_MSK_REG, readl(USB_DEV_EP_INTR_MSK_REG)| USB_DEV_EP1_OUT);
 
 			/* set NAK until next rx is ready */
-			out_reg->control |= USB_EP_SET_NAK;
+			setbitsl(USB_EP_OUT_CTRL_REG(BULK_OUT_ID), USB_EP_SET_NAK);
 
 			/* queue reuest for background processing */
 			qindex.cmd_end ++;
@@ -503,53 +462,48 @@ void endpoint_out_interrupt(u32 int_value)
 			command[qindex.cmd_end].pipe = BULK_OUT;
 			command[qindex.cmd_end].need_size = rx_length;
 			command[qindex.cmd_end].done_size = rx_length;
-			command[qindex.cmd_end].pBuf =
-				(u8 *)out_reg->descriptor_p->data_ptr;
+			command[qindex.cmd_end].pBuf = desc->data_ptr;
 			command[qindex.cmd_end].lock = 0;
 
 		}
 
-		ep_status = out_reg->status;
+		ep_status = readl(USB_EP_OUT_STS_REG(BULK_OUT_ID));
 
 		/* check if any endpoint error status */
 		/* case 1. buffer is not available */
 		if(ep_status & USB_EP_BUF_NOT_AVAIL) {
-
-			out_reg->status = USB_EP_BUF_NOT_AVAIL;
+			writel(USB_EP_OUT_STS_REG(BULK_OUT_ID), USB_EP_BUF_NOT_AVAIL);
 		}
 		/* case 2. host error */
 		if(ep_status & USB_EP_HOST_ERR) {
-
-			out_reg->status = USB_EP_HOST_ERR;
+			writel(USB_EP_OUT_STS_REG(BULK_OUT_ID), USB_EP_HOST_ERR);
 		}
 
 		/* Receive Clear Stall interrupt */
 		if (ep_status & USB_EP_RCV_CLR_STALL) {
-			out_reg->status = USB_EP_RCV_CLR_STALL;
+			writel(USB_EP_OUT_STS_REG(BULK_OUT_ID), USB_EP_RCV_CLR_STALL);
 		}
 
 		/* acknowledge endpoint status bit */
-		if(out_reg->status & USB_EP_OUT_PKT) {
-			out_reg->status = USB_EP_OUT_PKT;
+		if(ep_status & USB_EP_OUT_PKT) {
+			writel(USB_EP_OUT_STS_REG(BULK_OUT_ID), USB_EP_OUT_PKT);
 		}
 
 	} else { 				/*** CTRL_OUT ***/
 		/* ack the device interrupt */
-		dev_reg->ep_intr = USB_DEV_EP0_OUT;
+		writel(USB_DEV_EP_INTR_REG, USB_DEV_EP0_OUT);
 
-		out_reg = usbd.ep[CTRL_OUT];
 		/* check the status bits for what kind of packets in */
-		int_status = out_reg->status;
+		int_status = readl(USB_EP_OUT_STS_REG(CTRL_OUT_ID));
 
 		if((int_status & USB_EP_OUT_PKT_MSK) == USB_EP_OUT_PKT) {
-			out_reg->status = USB_EP_OUT_PKT;
+			writel(USB_EP_OUT_STS_REG(CTRL_OUT_ID), USB_EP_OUT_PKT);
 
-			rx_length = (out_reg->descriptor_p->status &
-					USB_DMA_RXTX_BYTES);
+			desc = (struct USB_DATA_DESC *)DMA_DESC_ADDR(CTRL_OUT);
+			rx_length = desc->status & USB_DMA_RXTX_BYTES;
 
 			if(rx_length == 0) {
-
-				dev_reg->control |= USB_DEV_RCV_DMA_EN;
+				writel(USB_DEV_CTRL_REG, readl(USB_DEV_CTRL_REG) | USB_DEV_RCV_DMA_EN);
 				init_setup_descriptor(CTRL_OUT);
 				//return;
 
@@ -558,18 +512,18 @@ void endpoint_out_interrupt(u32 int_value)
 			control_out_handler();
 			return;
 
-		} else if ((int_status & USB_EP_OUT_PKT_MSK) ==
-				USB_EP_SETUP_PKT) {
+		} else if ((int_status & USB_EP_OUT_PKT_MSK) == USB_EP_SETUP_PKT) {
 
 			/* SETUP packet, always 8 bytes */
 			/* ack setup packet status */
-			out_reg->status = USB_EP_SETUP_PKT;
+			writel(USB_EP_OUT_STS_REG(CTRL_OUT_ID), USB_EP_SETUP_PKT);
+
+			/* If transmitting binary is in process, ignore the SETUP packet */
+			if (bulk_process_is_locked()) {
+				printf("WARNNING: get configuration request! Ignore it ...\n");
+				return ;
+			}
 
-			/* read out setup packet */
-			setup = (struct USB_SETUP_PKT *)
-					out_reg->setup_buffer_p;
-			usbd.setup[0] = setup->data0;
-			usbd.setup[1] = setup->data1;
 			decode_request();
 
 		} else { /* none or reserved */
@@ -591,40 +545,22 @@ void bulk_in_handler(void)
 	/* not implmented */
 }
 
-/*
- * Name: control_out_handler
- * Description:
- *	Process the CONTROL OUT request from host
- * Input : none
- * Return: none
- */
 void control_out_handler(void)
 {
-	volatile struct USB_EP_OUT_REG *out_reg;
-	volatile struct USB_DATA_DESC *desc;
-	volatile u32	dma_status;
-	volatile u32	ep_status;
-	volatile u32	rcv_size;
-
-	out_reg = (struct USB_EP_OUT_REG *)usbd.ep[CTRL_OUT];
-	ep_status = out_reg->status;
-
-	desc = out_reg->descriptor_p;
+	struct USB_DATA_DESC *desc;
+	u32 dma_status, ep_status;
 
 	/* check if the descriptor has fresh data */
+	desc = (struct USB_DATA_DESC *)DMA_DESC_ADDR(CTRL_OUT);
 	dma_status = desc->status;
 
 	if((dma_status & USB_DMA_BUF_STS) == USB_DMA_BUF_DMA_DONE) {
-
 		if((dma_status & USB_DMA_RXTX_STS) == USB_DMA_RXTX_SUCC) {
-			/* process error case */
+			ep_status = readl(USB_EP_OUT_STS_REG(CTRL_OUT_ID));
 			if(ep_status & USB_EP_BUF_NOT_AVAIL)
-				out_reg->status = USB_EP_BUF_NOT_AVAIL;
+				writel(USB_EP_OUT_STS_REG(CTRL_OUT_ID), USB_EP_BUF_NOT_AVAIL);
 			if(ep_status & USB_EP_HOST_ERR)
-				out_reg->status = USB_EP_HOST_ERR;
-
-			rcv_size = desc->status & USB_DMA_RXTX_BYTES;
-		} else { // RXTX DMA failed
+				writel(USB_EP_OUT_STS_REG(CTRL_OUT_ID), USB_EP_HOST_ERR);
 
 		}
 	}
@@ -641,12 +577,19 @@ void control_out_handler(void)
  */
 void decode_request(void)
 {
+	struct USB_SETUP_PKT *setup;
+	u32 setup_data[2];
 	u8 bmRequestType;
 	u8 bRequest;
 	u8 request;
 	USB_DEVICE_REQUEST *req;
 
-	req = (USB_DEVICE_REQUEST *)&(usbd.setup[0]);
+	/* read out setup packet */
+	setup = (struct USB_SETUP_PKT *)setup_desc;
+	setup_data[0] = setup->data0;
+	setup_data[1] = setup->data1;
+
+	req = (USB_DEVICE_REQUEST *)setup_data;
 
 	bmRequestType = req->bmRequestType;
 	bRequest = req->bRequest;
@@ -660,10 +603,10 @@ void decode_request(void)
 	case USB_DEV_REQ_TYPE_STANDARD: 	/* Standard request */
 		switch(bRequest) {
               	case USB_GET_DESCRIPTOR:   	/* get descriptor    */
-               		get_descriptor();
-               		break;
+			get_descriptor(req);
+			break;
 		default:
-                	_DEBUG_PRINTK("unknown request= ",bRequest);
+			_DEBUG_PRINTK("unknown request= ",bRequest);
 			break;
 		} /* bRequest */
 		break;
@@ -686,23 +629,12 @@ void decode_request(void)
 	init_setup_descriptor(CTRL_OUT);
 }
 
-/*
- * Name: get_descriptor
- * Description:
- *	Request from host. Device sends descriptor back to
- *	host
- * Input : none
- * Return: none
- */
-void get_descriptor(void)
+void get_descriptor(USB_DEVICE_REQUEST *req)
 {
-	USB_DEVICE_REQUEST *req;
-	u16	type;
-	u16 index;
-	u32	tx_size = 0;
-	u8	*descriptor_p = NULL;
+	u16 type, index;
+	u32 tx_size = 0;
+	u8 *descriptor_p = NULL;
 
-	req = (USB_DEVICE_REQUEST *)&(usbd.setup[0]);
 	type = (req->wValue & 0xff00) >> 8;
 	index = (req->wValue & 0xff);
 
@@ -719,7 +651,7 @@ void get_descriptor(void)
 			tx_size = req->wLength;
 		break;
 	case USB_CONFIGURATION_DESCRIPTOR:
-		if(usbd.speed == USB_HS) {
+		if(usb_speed == USB_HS) {
 			descriptor_p = (u8 *)uds_bld_descriptors[CONFIG_HS];
 			if(req->wLength == 0xff)
 				tx_size = sizeof(uds_bld_configuration1_hs);
@@ -745,8 +677,11 @@ void get_descriptor(void)
 		else
 			_DEBUG_PRINTK("Unknown string index",0);
 
+		/* XXX: old mac OS send the SETUP with shorter wLength(wLength = 2).
+		 * Howerver , descriptor_p[0] is larger than that , so the reponse
+		 * tx_size = min(wLength, descriptor_p[0]) */
 		if (descriptor_p)
-			tx_size = descriptor_p[0];
+			tx_size = descriptor_p[0] > req->wLength ? req->wLength : descriptor_p[0];
 		break;
 	case USB_DEVICE_QUALIFIER:
 		descriptor_p = (u8 *)uds_bld_descriptors[DEVICE_QUA];
@@ -771,34 +706,24 @@ void get_descriptor(void)
 	command[qindex.cmd_end].pipe = CTRL_IN;
 	command[qindex.cmd_end].need_size = tx_size;
 	command[qindex.cmd_end].done_size = 0;
-	command[qindex.cmd_end].pBuf = descriptor_p;
+	command[qindex.cmd_end].pBuf = (uintptr_t)descriptor_p;
 	command[qindex.cmd_end].lock = 0;
 }
 
-/*
- * Name: init_setup_descriptor
- * Description:
- *  Config the setup packet to specific endpoint register
- * Input : ep_num - endpoint number, can only be CTRL_OUT
- * Return: none
- */
 void init_setup_descriptor(int ep_num)
 {
-	struct USB_EP_OUT_REG *out_reg = NULL;
-	struct USB_SETUP_PKT *setup = NULL;
-
-	out_reg = (struct USB_EP_OUT_REG *)usbd.ep[ep_num];
+	struct USB_SETUP_PKT *setup;
 
-	out_reg->setup_buffer_p = (void *)setup_desc;
-
-	setup = (struct USB_SETUP_PKT *)(out_reg->setup_buffer_p);
+	setup = (struct USB_SETUP_PKT *)setup_desc;
 
 	setup->status 	= USB_DMA_BUF_HOST_RDY;
 	setup->reserved = 0xffffffff;
 	setup->data0	= 0xffffffff;
 	setup->data1	= 0xffffffff;
 
-	clean_d_cache((void *)setup, sizeof(struct USB_SETUP_PKT));
+	clean_d_cache(setup, sizeof(struct USB_SETUP_PKT));
+
+	writel(USB_EP_OUT_SETUP_BUF_PTR_REG(CTRL_OUT_ID), (uintptr_t)setup);
 }
 
 /*
@@ -810,94 +735,44 @@ void init_setup_descriptor(int ep_num)
  */
 void init_endpoint(int ep_num, int speed)
 {
-	volatile struct USB_EP_IN_REG *in_reg = NULL;
-	volatile struct USB_EP_OUT_REG *out_reg = NULL;
+	u32 value;
 
 	if(ep_num == CTRL_OUT) {	/*** initialize CTROL_OUT ***/
-		out_reg = (struct USB_EP_OUT_REG *)usbd.ep[CTRL_OUT];
-		out_reg->control = USB_EP_TYPE_CTRL;
-		out_reg->max_pkt_size = USB_EP_CTRLOUT_MAX_PKT_SZ;
-		udc_reg[CTRL_OUT] =
-			(struct USB_EP_UDC_REG *)USB_UDC_REG(CTRL_OUT);
+		writel(USB_EP_OUT_CTRL_REG(CTRL_OUT_ID), USB_EP_TYPE_CTRL);
+		writel(USB_EP_OUT_MAX_PKT_SZ_REG(CTRL_OUT_ID), USB_EP_CTRLOUT_MAX_PKT_SZ);
 		init_setup_descriptor(CTRL_OUT);
 		init_data_descriptor(CTRL_OUT);
 
 	} else if(ep_num == CTRL_IN) {	/*** initialize CTROL_IN ***/
-		in_reg = (struct USB_EP_IN_REG *)usbd.ep[CTRL_IN];
-		in_reg->control = USB_EP_TYPE_CTRL;
-		in_reg->buf_size = USB_TXFIFO_DEPTH_CTRLIN;
-		in_reg->max_pkt_size = USB_EP_CTRLIN_MAX_PKT_SZ;
-		udc_reg[CTRL_IN] =
-			(struct USB_EP_UDC_REG *)USB_UDC_REG(CTRL_IN);
+		writel(USB_EP_IN_CTRL_REG(CTRL_IN_ID), USB_EP_TYPE_CTRL);
+		writel(USB_EP_IN_BUF_SZ_REG(CTRL_IN_ID), USB_TXFIFO_DEPTH_CTRLIN);
+		writel(USB_EP_IN_MAX_PKT_SZ_REG(CTRL_IN_ID), USB_EP_CTRLIN_MAX_PKT_SZ);
 		init_data_descriptor(CTRL_IN);
 
 	} else if(ep_num == BULK_OUT) {	/*** initialize BULK_OUT ***/
-		out_reg = (struct USB_EP_OUT_REG *)usbd.ep[BULK_OUT];
-		out_reg->control = USB_EP_TYPE_BULK | USB_EP_SET_NAK;
+		writel(USB_EP_OUT_CTRL_REG(BULK_OUT_ID), USB_EP_TYPE_BULK | USB_EP_SET_NAK);
 		if(speed == USB_HS)
-			out_reg->max_pkt_size = USB_EP_BULKOUT_MAX_PKT_SZ_HI;
+			value = USB_EP_BULKOUT_MAX_PKT_SZ_HI;
 		else	/* either FS or LS */
-			out_reg->max_pkt_size = USB_EP_BULKOUT_MAX_PKT_SZ_FU;
+			value = USB_EP_BULKOUT_MAX_PKT_SZ_FU;
+		writel(USB_EP_OUT_MAX_PKT_SZ_REG(BULK_OUT_ID), value);
 
-		udc_reg[BULK_OUT] =
-			(struct USB_EP_UDC_REG *)USB_UDC_REG(BULK_OUT);
 		init_data_descriptor(BULK_OUT);
 
 	} else {			/*** initialize BULK_IN ***/
-		in_reg = (struct USB_EP_IN_REG *)usbd.ep[BULK_IN];
-		in_reg->control = USB_EP_TYPE_BULK | USB_EP_SET_NAK;
-		in_reg->buf_size = USB_TXFIFO_DEPTH_BULKIN;
+		writel(USB_EP_IN_CTRL_REG(BULK_IN_ID), USB_EP_TYPE_BULK | USB_EP_SET_NAK);
+		writel(USB_EP_IN_BUF_SZ_REG(BULK_IN_ID), USB_TXFIFO_DEPTH_BULKIN);
 		if(speed == USB_HS)
-			in_reg->max_pkt_size = USB_EP_BULKIN_MAX_PKT_SZ_HI;
+			value = USB_EP_BULKIN_MAX_PKT_SZ_HI;
 		else
-			in_reg->max_pkt_size = USB_EP_BULKIN_MAX_PKT_SZ_FU;
+			value = USB_EP_BULKIN_MAX_PKT_SZ_FU;
+		writel(USB_EP_IN_MAX_PKT_SZ_REG(BULK_IN_ID), value);
 
-		udc_reg[BULK_IN] =
-			(struct USB_EP_UDC_REG *)USB_UDC_REG(BULK_IN);
 		init_data_descriptor(BULK_IN);
 	}
 }
 
 /*
- * Name: config_endpoint
- * Description:
- *	Setup the related software data structure for each endpoint
- *	host
- * Input : none
- * Return: none
- */
-void config_endpoint(void)
-{
-	/* config control in endpoint */
-	usbd.ep_info[CTRL_IN].id.physical = CTRL_IN;
-	usbd.ep_info[CTRL_IN].id.logical = 0 | 0x80;
-	usbd.ep_info[CTRL_IN].transfer_type = 0;//PUD_TRANSTYPE_CONTROL;
-	usbd.ep_info[CTRL_IN].maxpkt_size = MAX_CTRL_PKT_SIZE64;
-	usbd.ep_info[CTRL_IN].fifo_size = MAX_CTRL_PKT_SIZE64;
-
-	/* config control out endpoint */
-	usbd.ep_info[CTRL_OUT].id.physical = CTRL_OUT;
-	usbd.ep_info[CTRL_OUT].id.logical = 0;
-	usbd.ep_info[CTRL_OUT].transfer_type = 0;//PUD_TRANSTYPE_CONTROL;
-	usbd.ep_info[CTRL_OUT].maxpkt_size = MAX_CTRL_PKT_SIZE64;
-	usbd.ep_info[CTRL_OUT].fifo_size = MAX_CTRL_PKT_SIZE64;
-
-	/* config bulk in endpoint */
-	usbd.ep_info[BULK_IN].id.physical = BULK_IN;
-	usbd.ep_info[BULK_IN].id.logical =	BULK_IN | 0x80;
-	usbd.ep_info[BULK_IN].transfer_type = 0;//PUD_TRANSTYPE_BULK;
-	usbd.ep_info[BULK_IN].maxpkt_size = MAX_BULK_PKT_SIZE512;
-	usbd.ep_info[BULK_IN].fifo_size = 0;
-
-	/* config bulk out endpoint */
-	usbd.ep_info[BULK_OUT].id.physical = BULK_OUT;
-	usbd.ep_info[BULK_OUT].id.logical = BULK_OUT;
-	usbd.ep_info[BULK_OUT].transfer_type = 0;//PUD_TRANSTYPE_BULK;
-	usbd.ep_info[BULK_OUT].maxpkt_size = MAX_BULK_PKT_SIZE512;
-	usbd.ep_info[BULK_OUT].fifo_size = 0;
-}
-
-/*
  * Name: setup_data_descriptor
  * Description:
  *	Initialize the descriptor data structure
@@ -906,27 +781,33 @@ void config_endpoint(void)
  */
 void init_data_descriptor(u32 ep_num)
 {
-	struct USB_DATA_DESC *desc_p = NULL;
-	struct USB_EP_IN_REG *in_reg = NULL;
-	struct USB_EP_OUT_REG *out_reg = NULL;
-
+	struct USB_DATA_DESC *desc;
 
-	desc_p = (struct USB_DATA_DESC *)usbd.ep_descriptor[ep_num];
+	desc = (struct USB_DATA_DESC *)DMA_DESC_ADDR(ep_num);
+	desc->status = (USB_DMA_BUF_DMA_DONE | USB_DMA_LAST);
+	desc->reserved = 0xffffffff;
+	desc->data_ptr = (uintptr_t)DMA_BUF_ADDR(ep_num);
+	desc->next_desc_ptr = (uintptr_t)desc;
 
-	desc_p->status = (USB_DMA_BUF_DMA_DONE | USB_DMA_LAST);
-	desc_p->reserved = 0xffffffff;
-	desc_p->data_ptr = (u32 *)(usbd.ep_buffer[ep_num]);
-	desc_p->next_desc_ptr = (u32 *)desc_p;
+	clean_d_cache(desc, sizeof(struct USB_DATA_DESC));
 
-	if((ep_num == BULK_IN) || (ep_num == CTRL_IN)) {
-		in_reg = (struct USB_EP_IN_REG *)usbd.ep[ep_num];
-		in_reg->descriptor_p = desc_p;
-	} else {
-		out_reg = (struct USB_EP_OUT_REG *)usbd.ep[ep_num];
-		out_reg->descriptor_p = desc_p;
+	switch (ep_num) {
+	case CTRL_IN:
+		writel(USB_EP_IN_DAT_DESC_PTR_REG(CTRL_IN_ID), (uintptr_t)desc);
+		break;
+	case CTRL_OUT:
+		writel(USB_EP_OUT_DAT_DESC_PTR_REG(CTRL_OUT_ID), (uintptr_t)desc);
+		break;
+	case BULK_IN:
+		writel(USB_EP_IN_DAT_DESC_PTR_REG(BULK_IN_ID), (uintptr_t)desc);
+		break;
+	case BULK_OUT:
+		writel(USB_EP_OUT_DAT_DESC_PTR_REG(BULK_OUT_ID), (uintptr_t)desc);
+		break;
+	default:
+		printf("Invalid ep_num: %d\n", ep_num);
+		break;
 	}
-
-	clean_d_cache((void *)desc_p, sizeof(struct USB_DATA_DESC));
 }
 
 /*
@@ -938,7 +819,7 @@ void init_data_descriptor(u32 ep_num)
  */
 u32 init_usb_hardware(void)
 {
-	volatile u32 value = 0;
+	u32 value = 0;
 
 	rct_usb_reset();
 
@@ -958,7 +839,7 @@ u32 init_usb_hardware(void)
 		USB_DEV_DDR |
 		USB_DEV_REMOTE_WAKEUP_EN;
 
-	usbd.dev_reg->config = value;
+	writel(USB_DEV_CFG_REG, value);
 
 	/* device control register */
 	value = USB_DEV_RCV_DMA_EN |
@@ -966,15 +847,14 @@ u32 init_usb_hardware(void)
 		USB_DEV_DESC_UPD_PYL |
 		USB_DEV_LITTLE_ENDN |
 		USB_DEV_DMA_MD;
-	usbd.dev_reg->control = value;
+	writel(USB_DEV_CTRL_REG, value);
 
 	/* device interrupt mask register */
 	/* ack previous interrupt, but necessary ? */
-	usbd.dev_reg->intr = 0x0000007f;
-	usbd.dev_reg->ep_intr = 0xffffffff;
-	/* from a clean status */
-	usbd.dev_reg->intrmask = 0x0000007f;
-	usbd.dev_reg->ep_intrmask = 0xffffffff;
+	writel(USB_DEV_INTR_REG, 0x0000007f);
+	writel(USB_DEV_EP_INTR_REG, 0xffffffff);
+	writel(USB_DEV_INTR_MSK_REG, 0x0000007f);
+	writel(USB_DEV_EP_INTR_MSK_REG, 0xffffffff);
 
 	/* enable device interrupt for
 		Set_Configure
@@ -984,14 +864,15 @@ u32 init_usb_hardware(void)
 	value = ~(USB_DEV_MSK_SET_CFG |
 			  USB_DEV_MSK_SET_INTF |
 			  USB_DEV_MSK_SPD_ENUM_CMPL);
-	usbd.dev_reg->intrmask = value;
+	writel(USB_DEV_INTR_MSK_REG, value);
 
 	/* enable endpoint interrupt */
 	value = ~(USB_DEV_MSK_EP0_IN |
 			  USB_DEV_MSK_EP0_OUT |
 			  USB_DEV_MSK_EP1_IN |
 			  USB_DEV_MSK_EP1_OUT);
-	usbd.dev_reg->ep_intrmask = value;
+	writel(USB_DEV_EP_INTR_MSK_REG, value);
+
 
 	_DEBUG_PRINTK("init_usb_hardware done",0);
 
@@ -1007,48 +888,6 @@ u32 init_usb_hardware(void)
  */
 void init_usb_dev(void)
 {
-	usbd.base 	 = USBDC_BASE;
-	usbd.dev_reg 	 = (struct USB_DEV_REG *)USB_DEV_BASE;
-	usbd.intr_num 	 = USBC_IRQ;
-
-	/*
-	   note: the start index of EP IN and EP OUT register
-	   should be 0 since both base address are different.
-	 */
-	usbd.ep[CTRL_IN] = (void *)USB_EP_IN_CTRL_REG(CTRL_IN);
-	usbd.ep[BULK_IN] = (void *)USB_EP_IN_CTRL_REG(BULK_IN);
-	usbd.ep[CTRL_OUT] = (void *)USB_EP_OUT_CTRL_REG(CTRL_IN);
-	usbd.ep[BULK_OUT] = (void *)USB_EP_OUT_CTRL_REG(BULK_IN);
-
-	usbd.tx_fifo_size = TX_FIFO_SIZE;
-	usbd.rx_fifo_size = RX_FIFO_SIZE;
-	usbd.control_pkt_size = MAX_CTRL_PKT_SIZE64;
-	usbd.bulk_pkt_size = MAX_BULK_PKT_SIZE512;
-
-	/*	descriptor will be located at
-	 */
-	usbd.ep_descriptor[CTRL_IN] = DESCRIPTOR_BASE(CTRL_IN);
-	usbd.ep_descriptor[CTRL_OUT]= DESCRIPTOR_BASE(CTRL_OUT);
-	usbd.ep_descriptor[BULK_IN] = DESCRIPTOR_BASE(BULK_IN);
-	usbd.ep_descriptor[BULK_OUT]= DESCRIPTOR_BASE(BULK_OUT);
-
-	/*  data buffer will be located at
-	 */
-	usbd.ep_buffer[CTRL_IN]	= BUFFER_BASE(CTRL_IN);
-	usbd.ep_buffer[CTRL_OUT]= BUFFER_BASE(CTRL_OUT);
-	usbd.ep_buffer[BULK_IN]	= BUFFER_BASE(BULK_IN);
-	usbd.ep_buffer[BULK_OUT]= BUFFER_BASE(BULK_OUT);
-
-	usbd.ctrl_tx_cnt = 0;
-	usbd.ctrl_rx_cnt = 0;
-	usbd.bulk_tx_cnt = 0;
-	usbd.bulk_rx_cnt = 0;
-	usbd.error_cnt	 = 0;
-	usbd.link	 = USB_DISCONNECT;
-	usbd.speed	 = USB_HS;	// default High-Speed
-	usbd.mode	 = MODE_DMA;	// default DMA mode
-	usbd.address	 = 0;
-
 	/* init command/response queue */
 	memzero ((u8 *)command, sizeof(COMMAND_QUEUE) * QUEUE_DEPTH);
 	memzero ((u8 *)response, sizeof(WAIT_QUEUE) * QUEUE_DEPTH);
@@ -1084,7 +923,7 @@ void init_usb_pll(void)
  */
 void init_udc_reg(void)
 {
-	volatile u32 value;
+	u32 value;
 
 	value = USB_UDC_EP0_NUM |
 		USB_UDC_OUT |
@@ -1093,7 +932,8 @@ void init_udc_reg(void)
 		USB_UDC_INTF_NUM |
 		USB_UDC_ALT_SET |
 		USB_UDC_CTRLOUT_MAX_PKT_SZ;
-	udc_reg[CTRL_OUT]->value = value;
+	writel(USB_UDC_REG(CTRL_OUT), value);
+
 	value = USB_UDC_EP0_NUM |
 		USB_UDC_IN  |
 		USB_UDC_CTRL |
@@ -1101,7 +941,8 @@ void init_udc_reg(void)
 		USB_UDC_INTF_NUM |
 		USB_UDC_ALT_SET |
 		USB_UDC_CTRLIN_MAX_PKT_SZ;
-	udc_reg[CTRL_IN]->value = value;
+	writel(USB_UDC_REG(CTRL_IN), value);
+
 	value = USB_UDC_EP1_NUM |
 		USB_UDC_OUT |
 		USB_UDC_BULK |
@@ -1109,7 +950,8 @@ void init_udc_reg(void)
 		USB_UDC_INTF_NUM |
 		USB_UDC_ALT_SET;
 	value |= USB_UDC_BULKOUT_MAX_PKT_SZ_HI;
-	udc_reg[BULK_OUT]->value = value;
+	writel(USB_UDC_REG(BULK_OUT), value);
+
 	value = USB_UDC_EP1_NUM |
 		USB_UDC_IN  |
 		USB_UDC_BULK |
@@ -1117,9 +959,9 @@ void init_udc_reg(void)
 		USB_UDC_INTF_NUM |
 		USB_UDC_ALT_SET;
 	value |= USB_UDC_BULKIN_MAX_PKT_SZ_HI;
-	udc_reg[BULK_IN]->value = value;
+	writel(USB_UDC_REG(BULK_IN), value);
 
-	usbd.dev_reg->config |= USB_DEV_CSR_PRG_EN;
+	writel(USB_DEV_CFG_REG, readl(USB_DEV_CFG_REG) | USB_DEV_CSR_PRG_EN);
 
 }
 
@@ -1130,8 +972,7 @@ void init_udc_reg(void)
  * Input : none
  * Return: none
  */
-void
-usb_init (void)
+void usb_init (void)
 {
 	/* initialize software data structure */
 	init_usb_dev();
@@ -1139,92 +980,90 @@ usb_init (void)
 	/* initialize hardware */
 	init_usb_hardware();
 
-	/* configure endpoint register and data structure */
-	config_endpoint();
-
-	/* setup VIC interrupt and install ISR */
-	vic_set_type(USBC_IRQ, VIRQ_LEVEL_HIGH);
-
-	/* install interrupt handler */
-	// Skip here, since IRQ Exception Handler of BLD do it directly.
-
-	/* enable USB interrupt */
-	vic_enable(USBC_IRQ);
+	request_irq(USBC_IRQ, IRQ_LEVEL_HIGH, usb_isr, NULL);
 
 	/* re-enable USB connection by SW */
-	if(usb_check_connected())
-		usbd.dev_reg->control |= USB_DEV_REMOTE_WAKEUP; // resume
+	writel(USB_DEV_CTRL_REG, readl(USB_DEV_CTRL_REG) | USB_DEV_REMOTE_WAKEUP);
 }
 
-/*
- * Name: start_tx
- * Description:
- *	do tx dma stuffs
- * Input : 	ep_num - endpoint number
- *		buf_ptr - packet buffer pointer
- *		pkt_size - packet size
- * Return: transmitted tx packet length
- */
-u32 start_tx(u32 ep_num, u32 *buf_ptr, u32 *pkt_size)
+u32 start_tx(u32 ep_num, void *buf_ptr, u32 *pkt_size)
 {
-	volatile struct USB_DATA_DESC *tx = NULL;
-	volatile struct USB_DEV_REG *dev_reg = NULL;
-	volatile struct USB_EP_IN_REG *in_reg = NULL;
+	struct USB_DATA_DESC *desc;
 	volatile u32 value = 0;
-	volatile u32 send_size = 0;
+	u32 send_size, ep_id, max_pkt_size;
+
+	usb_dump(ep_num, buf_ptr, *pkt_size);
+
+	if (ep_num == CTRL_IN)
+		ep_id = CTRL_IN_ID;
+	else
+		ep_id = BULK_IN_ID;
 
-	in_reg = (struct USB_EP_IN_REG *)usbd.ep[ep_num];
-	dev_reg = (struct USB_DEV_REG *)usbd.dev_reg;
+	max_pkt_size = readl(USB_EP_IN_MAX_PKT_SZ_REG(ep_id));
 
 	/* sending NULL packet, *buf_ptr should be NULL	*/
 	if(*pkt_size == 0) {
-		buf_ptr = (u32 *)usbd.ep_buffer[ep_num];
+		buf_ptr = DMA_BUF_ADDR(ep_num);
 		send_size = 0;
 	} else {
-		send_size = (*pkt_size > in_reg->max_pkt_size)?
-				in_reg->max_pkt_size:*pkt_size;
+		send_size = min(*pkt_size, max_pkt_size);
 
 	}
-	tx = (struct USB_DATA_DESC *)usbd.ep_descriptor[ep_num];
-	tx->data_ptr = buf_ptr; /* assign new packet buffer pointer */
-	tx->status = USB_DMA_BUF_HOST_RDY | USB_DMA_LAST | send_size;
-	clean_d_cache((void *)buf_ptr, send_size);
-	clean_d_cache((void *)tx, sizeof(struct USB_DATA_DESC));
 
-	vic_disable(USBC_IRQ);
+	desc = (struct USB_DATA_DESC *)DMA_DESC_ADDR(ep_num);
+	desc->data_ptr = (uintptr_t)buf_ptr; /* assign new packet buffer pointer */
+	desc->status = USB_DMA_BUF_HOST_RDY | USB_DMA_LAST | send_size;
+	clean_d_cache(desc, sizeof(struct USB_DATA_DESC));
+	clean_d_cache(buf_ptr, send_size);
 
-	in_reg->control |= (USB_EP_CLR_NAK);
+	irq_disable(USBC_IRQ);
+
+	setbitsl(USB_EP_IN_CTRL_REG(ep_id), USB_EP_CLR_NAK);
 
 	/*
 	 * Wait IN token before issue DMA polling
 	 * NOTE: Please add your own timeout here.
 	 * Or it will wait forever ....
 	 */
-	while(!(in_reg->status & USB_EP_IN_PKT));
+	while(!(readl(USB_EP_IN_STS_REG(ep_id)) & USB_EP_IN_PKT));
 
-	in_reg->status &= USB_EP_IN_PKT;
+	writel(USB_EP_IN_STS_REG(ep_id), USB_EP_IN_PKT);
 
-	value = dev_reg->ep_intrmask;
+	value = readl(USB_DEV_EP_INTR_MSK_REG);
 	if(ep_num == CTRL_IN)
 		value &= ~(USB_DEV_MSK_EP0_IN);
 	else /* if(ep_num == BULK_IN) */
 		value &= ~(USB_DEV_MSK_EP1_IN);
 
 	/* enable the corresponding EP interrupt */
-	dev_reg->ep_intrmask = value;
+	writel(USB_DEV_EP_INTR_MSK_REG, value);
 
 	/* issue polling bit */
-	in_reg->control |= (USB_EP_POLL_DEMAND);
+	setbitsl(USB_EP_IN_CTRL_REG(ep_id), USB_EP_POLL_DEMAND);
 
+	/*
+	 * FIXME: No need to delay for macbook and verified with other OS,
+	 * so remove it.
+	 */
+#if 0
 	for(value=0;value<0xffff;value++);
+#endif
 
 	/* update data buffer and size in current command element*/
 	buf_ptr += send_size;
 	*pkt_size -= send_size;
 
-	vic_enable(USBC_IRQ);
+	irq_enable(USBC_IRQ);
+
+	/* wait tx DMA finished, woke up by DMA complete interrupt */
+	while(!ep_event[ep_id]);
+	ep_event[ep_id] = 0;
+
+	/* FIXME: Host will failed to get description sometimes. this delay is
+	 * in order to makesure packet tx finished */
+	rct_timer_dly_ms(1);
 
-	if((send_size == 0) || (send_size < in_reg->max_pkt_size)) {
+	if((send_size == 0) || (send_size < max_pkt_size)) {
 		/* the last packet */
 		if(*pkt_size)
 			_DEBUG_PRINTK("remaind size is not 0",0);
@@ -1236,49 +1075,42 @@ u32 start_tx(u32 ep_num, u32 *buf_ptr, u32 *pkt_size)
 	}
 }
 
-/*
- * Name: start_rx
- * Description:
- *	do rx dma stuffs
- * Input : ep_num - endpoint number
- *	   buf_ptr - received packet buffer pointer
- * Return: none
- */
-void start_rx(u32 ep_num, u32 *buf_ptr)
+void start_rx(u32 ep_num, void *buf_ptr)
 {
-	volatile struct USB_DATA_DESC 	*rx = NULL;
-	volatile struct USB_DEV_REG 	*dev_reg = NULL;
-	volatile struct USB_EP_OUT_REG 	*out_reg = NULL;
+	struct USB_DATA_DESC *desc;
 	volatile u32 value=0;
+	u32 ep_id = (ep_num == CTRL_OUT) ? CTRL_OUT_ID : BULK_OUT_ID;
 
-	vic_disable(USBC_IRQ); /* critical section */
-
-	out_reg = (struct USB_EP_OUT_REG *)usbd.ep[ep_num];
-	rx = out_reg->descriptor_p;
+	irq_disable(USBC_IRQ); /* critical section */
 
-	rx = (struct USB_DATA_DESC *)usbd.ep_descriptor[ep_num];
-	rx->data_ptr = buf_ptr;
-	rx->status = USB_DMA_BUF_HOST_RDY | USB_DMA_LAST;
-	clean_d_cache((void *)rx, sizeof(struct USB_DATA_DESC));
+	desc = (struct USB_DATA_DESC *)DMA_DESC_ADDR(ep_num);
+	desc->data_ptr = (unsigned long)buf_ptr;
+	desc->status = USB_DMA_BUF_HOST_RDY | USB_DMA_LAST;
+	clean_d_cache(desc, sizeof(struct USB_DATA_DESC));
 
-	vic_enable(USBC_IRQ); /* critical section */
+	irq_enable(USBC_IRQ); /* critical section */
 
-	dev_reg = usbd.dev_reg;
-	value = dev_reg->ep_intrmask;
+	value = readl(USB_DEV_EP_INTR_MSK_REG);
 
 	if(ep_num == CTRL_OUT)
 		value &= ~(USB_DEV_MSK_EP0_OUT);
 	else /* if(ep_num == BULK_OUT) */
 		value &= ~(USB_DEV_MSK_EP1_OUT);
 
-	dev_reg->ep_intrmask = value;
+	writel(USB_DEV_EP_INTR_MSK_REG, value);
 
 	// clear NAK
-	dev_reg->control |= USB_DEV_RCV_DMA_EN;
+	writel(USB_DEV_CTRL_REG, readl(USB_DEV_CTRL_REG) | USB_DEV_RCV_DMA_EN);
 
+	/*
+	 * FIXME: No need to delay for macbook and verified with other OS,
+	 * so remove it.
+	 */
+#if 0
 	for(value=0;value < 0x100;value++);
+#endif
 
-	out_reg->control |= USB_EP_CLR_NAK;
+	setbitsl(USB_EP_OUT_CTRL_REG(ep_id), USB_EP_CLR_NAK);
 }
 
 /*
@@ -1300,7 +1132,7 @@ void send_response (u32 rsp, u32 r0, u32 r1)
 	dev_response.parameter0 = r0;
 	dev_response.parameter1 = r1;
 
-	start_tx(BULK_IN, (u32 *)&dev_response, &rsp_length);
+	start_tx(BULK_IN, &dev_response, &rsp_length);
 	//_DEBUG_PRINTK ("Send response", rsp);
 }
 
@@ -1314,11 +1146,11 @@ void send_response (u32 rsp, u32 r0, u32 r1)
  *	   length - the length of data to send
  * Return: <0: failed, 0: success
  */
-int process_cmd_send_fw (u32 cmd, u32 *addr, u32 *length)
+int process_cmd_send_fw (u32 cmd, uintptr_t *addr, u32 *length)
 {
 	flpart_table_t ptb;
 	flpart_t *part;
-	u32 mem_addr = (u32)bld_hugebuf_addr;
+	uintptr_t mem_addr = (uintptr_t)bld_hugebuf_addr;
 	u32 header_len = sizeof(partimg_header_t);
 
 	if ((addr == NULL) || (length == NULL))
@@ -1330,39 +1162,6 @@ int process_cmd_send_fw (u32 cmd, u32 *addr, u32 *length)
 
 	/* Load image into memory */
 	switch (cmd) {
-#if defined(CONFIG_AMBOOT_ENABLE_NAND)
-	u32 sblk, nblk;
-	case USB_CMD_GET_FW_BST:
-		sblk = flnand.sblk[PART_BST];
-		nblk = flnand.nblk[PART_BST];
-		part = &ptb.part[PART_BST];
-		break;
-	case USB_CMD_GET_FW_BLD:
-		sblk = flnand.sblk[PART_BLD];
-		nblk = flnand.nblk[PART_BLD];
-		part = &ptb.part[PART_BLD];
-		break;
-	case USB_CMD_GET_FW_PRI:
-		sblk = flnand.sblk[PART_PRI];
-		nblk = flnand.nblk[PART_PRI];
-		part = &ptb.part[PART_PRI];
-		break;
-	case USB_CMD_GET_FW_RMD:
-		sblk = flnand.sblk[PART_RMD];
-		nblk = flnand.nblk[PART_RMD];
-		part = &ptb.part[PART_RMD];
-		break;
-	case USB_CMD_GET_FW_ROM:
-		sblk = flnand.sblk[PART_ROM];
-		nblk = flnand.nblk[PART_ROM];
-		part = &ptb.part[PART_ROM];
-		break;
-	case USB_CMD_GET_FW_DSP:
-		sblk = flnand.sblk[PART_DSP];
-		nblk = flnand.nblk[PART_DSP];
-		part = &ptb.part[PART_DSP];
-		break;
-#endif
 	case USB_CMD_GET_FW_PTB:
 		memcpy ((void *)mem_addr, &ptb, sizeof(flpart_table_t));
 		*addr = mem_addr;
@@ -1414,7 +1213,7 @@ void process_cmd_recv (HOST_CMD *host_cmd)
 			transfer.rx.addr > (DRAM_START_ADDR + DRAM_SIZE - 1)) {
 			_DEBUG_PRINTK("Invalid recv address: 0x",
 				transfer.rx.addr);
-			transfer.rx.addr = (u32)bld_hugebuf_addr;
+			transfer.rx.addr = (uintptr_t)bld_hugebuf_addr;
 			_DEBUG_PRINTK("Revert to default address: ",
 				transfer.rx.addr);
 		}
@@ -1425,7 +1224,7 @@ void process_cmd_recv (HOST_CMD *host_cmd)
 			transfer.jump_address > (DRAM_START_ADDR + DRAM_SIZE - 1)) {
 			_DEBUG_PRINTK("Invalid jump address: 0x",
 				transfer.jump_address);
-			transfer.jump_address = (u32)bld_hugebuf_addr;
+			transfer.jump_address = (uintptr_t)bld_hugebuf_addr;
 			_DEBUG_PRINTK("Revert to default address: 0x",
 				transfer.jump_address);
 		}
@@ -1557,7 +1356,7 @@ void process_cmd_send_data (HOST_CMD *host_cmd)
 	command[qindex.cmd_end].pipe = BULK_IN;
 	command[qindex.cmd_end].need_size = transfer.tx.length;
 	command[qindex.cmd_end].done_size = 0;
-	command[qindex.cmd_end].pBuf = (u8 *)transfer.tx.addr;
+	command[qindex.cmd_end].pBuf = transfer.tx.addr;
 	command[qindex.cmd_end].lock = 1;
 }
 
@@ -1573,6 +1372,10 @@ void process_cmd_inquiry (HOST_CMD *host_cmd)
 {
 	if (host_cmd->parameter0 == USB_BLD_INQUIRY_CHIP) {
 		send_response(USB_RSP_SUCCESS, CHIP_REV, 0);
+	} else if (host_cmd->parameter0 == USB_BLD_INQUIRY_ADDR) {
+		send_response(USB_RSP_SUCCESS, AMBOOT_BLD_RAM_START, 0);
+	} else if (host_cmd->parameter0 == USB_BLD_INQUIRY_REG) {
+		send_response(USB_RSP_SUCCESS, readl(host_cmd->parameter1), 0);
 	} else {
 		/* reponse */
 		send_response(USB_RSP_IN_BLD, 0, 0);
@@ -1588,14 +1391,14 @@ void process_cmd_inquiry (HOST_CMD *host_cmd)
  */
 void rx_fsm(COMMAND_QUEUE *cur_cmd)
 {
-	struct USB_EP_OUT_REG *out_reg = NULL;
 	HOST_CMD *host_cmd = (HOST_CMD *)cur_cmd->pBuf;
-	volatile u32 *next_rx_ptr = NULL;
-
-	out_reg = (struct USB_EP_OUT_REG *)usbd.ep[BULK_OUT];
+	u32 *next_rx_ptr = NULL;
+	u32 max_pkt_size = readl(USB_EP_OUT_MAX_PKT_SZ_REG(BULK_OUT_ID));
 
 	/* Set next_rx_ptr to EP buffer for receive next command */
-	next_rx_ptr = (u32 *)usbd.ep_buffer[BULK_OUT];
+	next_rx_ptr = (u32 *)DMA_BUF_ADDR(BULK_OUT);
+
+	usb_dump(BULK_OUT, (void *)cur_cmd->pBuf, cur_cmd->done_size);
 
 	switch (rx_state) {
 	case COMMAND_PHASE:
@@ -1633,11 +1436,11 @@ void rx_fsm(COMMAND_QUEUE *cur_cmd)
 
 	case RCV_DATA_PHASE:
 		 /* done_size = need_size = received packet size */
-		 if (cur_cmd->done_size < out_reg->max_pkt_size) {
+		 if (cur_cmd->done_size < max_pkt_size) {
 		 	u32 cal_crc_value;
 
 			/* Short packet received */
-		 	transfer.rx.length = (u32)cur_cmd->pBuf +
+		 	transfer.rx.length = (uintptr_t)cur_cmd->pBuf +
 		 			     cur_cmd->done_size -
 		 			     transfer.rx.addr;
 			transfer.total_length += transfer.rx.length;
@@ -1661,8 +1464,15 @@ void rx_fsm(COMMAND_QUEUE *cur_cmd)
 
 			transfer.task_finished= 1;
 		 	rx_state = COMMAND_PHASE;
+
+			 /* finish transmitting the binary, unlock the bulk process */
+			bulk_process_tryunlock();
+
 		 } else {
 
+			 /* in transmitting process, lock the bulk process */
+			 bulk_process_trylock();
+
 			/* advanced rx buffer pointer */
 			/* done_size is "byte", but address is "word" */
 			next_rx_ptr = (u32 *)cur_cmd->pBuf;
@@ -1677,7 +1487,7 @@ void rx_fsm(COMMAND_QUEUE *cur_cmd)
 	} /* switch */
 
 	cur_cmd->pendding = 0;
-	start_rx(BULK_OUT, (u32 *)next_rx_ptr);
+	start_rx(BULK_OUT, next_rx_ptr);
 }
 
 /*
@@ -1709,7 +1519,7 @@ void process_bulk_in (COMMAND_QUEUE *cur_cmd)
 		/* prepare wait response data */
 		/* wait for TX DMA finish */
 		qindex.rsp_index ++;
-		start_tx(BULK_IN, (u32*)cur_cmd->pBuf, &(cur_cmd->need_size));
+		start_tx(BULK_IN, (void *)cur_cmd->pBuf, &cur_cmd->need_size);
 
 		print_twiddle ();
 	}
@@ -1725,9 +1535,9 @@ void process_bulk_in (COMMAND_QUEUE *cur_cmd)
  */
 void process_ctrl_in (COMMAND_QUEUE *cur_cmd)
 {
-	struct USB_EP_IN_REG *in_reg = (struct USB_EP_IN_REG *) usbd.ep[CTRL_IN];
+	u32 value = readl(USB_EP_IN_MAX_PKT_SZ_REG(CTRL_IN_ID));
 
-	if(cur_cmd->need_size < in_reg->max_pkt_size) {
+	if(cur_cmd->need_size < value) {
 		/* the last packet */
 		cur_cmd->pendding = 0;
 	}
@@ -1741,10 +1551,10 @@ void process_ctrl_in (COMMAND_QUEUE *cur_cmd)
 	}
 
 	qindex.rsp_index ++;
-	start_tx(CTRL_IN, (u32 *)cur_cmd->pBuf, &(cur_cmd->need_size));
+	start_tx(CTRL_IN, (void *)cur_cmd->pBuf, &cur_cmd->need_size);
 
 	/* prepare the status stage */
-	start_rx(CTRL_OUT, (u32 *)usbd.ep_buffer[CTRL_OUT]);
+	start_rx(CTRL_OUT, DMA_BUF_ADDR(CTRL_OUT));
 }
 
 /*
@@ -1759,8 +1569,7 @@ void process_ctrl_in (COMMAND_QUEUE *cur_cmd)
 int usb_task(void)
 {
 	COMMAND_QUEUE *cur_cmd = NULL;
-	struct USB_EP_OUT_REG *out_reg = NULL;
-	struct USB_DEV_REG *dev_reg = usbd.dev_reg;
+	struct USB_DATA_DESC *desc;
 
 	_DEBUG_PRINTK("entering usb_task",0);
 
@@ -1768,17 +1577,17 @@ int usb_task(void)
 
 	transfer.task_finished = 0;
 	while(!transfer.task_finished) {
-
 		/* issuing RX DMA enable all the time if in RCV_DATA */
 		if(rx_state == RCV_DATA_PHASE) {
-
-			vic_disable(USBC_IRQ);
-			out_reg = usbd.ep[BULK_OUT];
+			irq_disable(USBC_IRQ);
+			/* check if the descriptor has fresh data */
+			desc = (struct USB_DATA_DESC *)DMA_DESC_ADDR(BULK_OUT);
 			_clean_flush_d_cache();
+
 			/* if descriptor is ready to receive */
-			if(!(out_reg->descriptor_p->status & USB_DMA_BUF_STS))
-				dev_reg->control |= USB_DEV_RCV_DMA_EN;
-			vic_enable(USBC_IRQ);
+			if(!(desc->status & USB_DMA_BUF_STS))
+				writel(USB_DEV_CTRL_REG, readl(USB_DEV_CTRL_REG) | USB_DEV_RCV_DMA_EN);
+			irq_enable(USBC_IRQ);
 		}
 
 		/* the rsp_index is set caused by previous command,
@@ -1801,7 +1610,6 @@ int usb_task(void)
 				qindex.cmd_start ++;
 				qindex.cmd_start %= QUEUE_DEPTH;
 				cur_cmd = (COMMAND_QUEUE *)&command[qindex.cmd_start];
-				_clean_flush_d_cache(); /* FIXME : workaround for A7L/S2 out interrupt ; Remove this once found the root casue */
 			}
 		}
 
@@ -1856,20 +1664,20 @@ u32 usb_download(void *addr, int exec, int flag)
 		usb_download_kernel (flag & USB_FLAG_FW_PROG);
 
 		/* disable TX/RX DMA */
-		usbd.dev_reg->control &= 0xfffffff3;
+		writel(USB_DEV_CTRL_REG, readl(USB_DEV_CTRL_REG) & 0xfffffff3);
 
 		/* mask device/endpoint interrupt */
-		usbd.dev_reg->intrmask = 0xffffffff;
-		usbd.dev_reg->ep_intrmask = 0xffffffff;
+		writel(USB_DEV_INTR_MSK_REG, 0xffffffff);
+		writel(USB_DEV_EP_INTR_MSK_REG, 0xffffffff);
 
 		/* set soft-disconnect
 		 * set_softdisc() got problem because it set the VIC again
 		 */
-		usbd.dev_reg->control = UDC_CTRL_SD;	// Soft disconnect
-		usbd.dev_reg->config = UDC_CFG_RWKP;	// Enable remote wakeup
+		writel(USB_DEV_CTRL_REG, UDC_CTRL_SD);
+		writel(USB_DEV_CFG_REG, UDC_CFG_RWKP);
 
 	} else if (flag & USB_FLAG_MEMORY) {
-		transfer.rx.addr = (u32) addr;
+		transfer.rx.addr = (uintptr_t) addr;
 		usb_task();
 
 	} else {
@@ -1880,28 +1688,29 @@ u32 usb_download(void *addr, int exec, int flag)
 			jump = (void *) transfer.jump_address;
 		}
 
+
 		/* disable TX/RX DMA */
-		usbd.dev_reg->control &= 0xfffffff3;
+		writel(USB_DEV_CTRL_REG, readl(USB_DEV_CTRL_REG) & 0xfffffff3);
 
 		/* mask device/endpoint interrupt */
-		usbd.dev_reg->intrmask = 0xffffffff;
-		usbd.dev_reg->ep_intrmask = 0xffffffff;
+		writel(USB_DEV_INTR_MSK_REG, 0xffffffff);
+		writel(USB_DEV_EP_INTR_MSK_REG, 0xffffffff);
 
 		/* set soft-disconnect
 		 * set_softdisc() got problem because it set the VIC again
 		 */
-		usbd.dev_reg->control = UDC_CTRL_SD;	// Soft disconnect
-		usbd.dev_reg->config = UDC_CFG_RWKP;	// Enable remote wakeup
+		writel(USB_DEV_CTRL_REG, UDC_CTRL_SD);    // Soft disconnect
+		writel(USB_DEV_CFG_REG, UDC_CFG_RWKP);    // Enable remote wakeup
 	}
 
 	/* Tranfer finished */
 	if(!connected_at_boot) {
-		usbd.dev_reg->config = 0;
-		usbd.dev_reg->control = 0;
-		usbd.dev_reg->intr = 0x7f;
-		usbd.dev_reg->ep_intr = 0xffffffff;
-		usbd.dev_reg->intrmask = 0x7f;
-		usbd.dev_reg->ep_intrmask = 0xffffffff;
+		writel(USB_DEV_CFG_REG, 0);
+		writel(USB_DEV_CTRL_REG, 0);
+		writel(USB_DEV_INTR_REG, 0x7f);
+		writel(USB_DEV_EP_INTR_REG, 0xffffffff);
+		writel(USB_DEV_INTR_MSK_REG, 0x7f);
+		writel(USB_DEV_EP_INTR_MSK_REG, 0xffffffff);
 	}
 
 	if (exec) {
@@ -1914,7 +1723,7 @@ u32 usb_download(void *addr, int exec, int flag)
 		/* put the return address in 0xc00ffffc
 		 * and let jump() to read and return back */
 		ptr = &&_return_;
-		*(volatile u32 *)(DRAM_START_ADDR + 0x000ffffc) = (u32) ptr;
+		*(volatile uintptr_t *)(DRAM_START_ADDR + 0x000ffffc) = (uintptr_t) ptr;
 
 		__asm__ __volatile__ ("nop");
 		__asm__ __volatile__ ("nop");
@@ -1970,31 +1779,6 @@ void set_softdisc(void)
 }
 
 /*
- * Name: usb_check_connected
- * Description:
- *	Check if USB cable is connected to a host
- * Input : none
- * Return: 1 - Yes
- * 	   0 - No
- */
-int usb_check_connected(void)
-{
-	/* Setup VBUS interrupt */
-	vic_set_type(USBVBUS_IRQ, VIRQ_LEVEL_HIGH);
-
-	/* Read VBUS status */
-#if defined(VIC_2NDGEN_BITASSIGNMENT)
-	if (readl(VIC4_REG(VIC_RAW_STA_OFFSET)) & 1) {
-#else
-	if (readl(VIC_REG(VIC_RAW_STA_OFFSET)) & 1) {
-#endif
-		return 1;
-	} else {
-		return 0;
-	}
-}
-
-/*
  * Name: usb_boot_logo
  * Description:
  *	Show usb boot information
@@ -2078,7 +1862,7 @@ static void do_reboot(void)
  * Input : addr - target address
  * Return: none
  */
-void usb_download_file (u32 addr)
+void usb_download_file (uintptr_t addr)
 {
 	unsigned int retry_counter;
 
@@ -2111,7 +1895,6 @@ void usb_download_kernel (int is_fw_prog)
 	putstr("=============================");
 	putstr("\r\n");
 	putstr("USB download ");
-	putstr(_VERSION_);		/* major change version */
 	putstr("\r\n");
 	putstr("Built @ ");
 	putstr(__DATE__);		/* compiling time */
@@ -2123,12 +1906,12 @@ void usb_download_kernel (int is_fw_prog)
 
 	if (is_fw_prog) {
 		putstr("Download 1 firmware programming file\r\n");
-		usb_download_file((u32)bld_hugebuf_addr);
+		usb_download_file((uintptr_t)bld_hugebuf_addr);
 		putstr("firmware program is loaded\r\n");
 	} else {
 		putstr("Download 4 kernel files\r\n");
 
-		usb_download_file((u32)bld_hugebuf_addr);
+		usb_download_file((uintptr_t)bld_hugebuf_addr);
 		putstr("Prkernel is loaded\r\n");
 
 		/* Flow broken if PC application ask to finish */
@@ -2155,9 +1938,9 @@ void usb_download_kernel (int is_fw_prog)
  */
 void usb_test_download (void)
 {
-	u32 addr = (u32)bld_hugebuf_addr;
-	u32 mem_start = DRAM_START_ADDR;
-	u32 mem_end = DRAM_END_ADDR;
+	uintptr_t addr = (uintptr_t)bld_hugebuf_addr;
+	uintptr_t mem_start = DRAM_START_ADDR;
+	uintptr_t mem_end = DRAM_END_ADDR;
 	u32 mem_jump = 0x500000;	// 5MB
 	u32 max_file_size = 0x400000;	// 4MB
 	int i;
diff --git a/src/bld/version.info b/src/bld/version.info
index d77af53..6ae71d2 100644
--- a/src/bld/version.info
+++ b/src/bld/version.info
@@ -6,12 +6,30 @@
  * History:
  *    2005/03/06 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __VERSION_INFO__
diff --git a/src/bld/vic.c b/src/bld/vic.c
index 8c20e1b..77656c4 100644
--- a/src/bld/vic.c
+++ b/src/bld/vic.c
@@ -6,336 +6,175 @@
  * History:
  *    2005/07/26 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2005, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
-
-#include <amboot.h>
 #include <bldfunc.h>
-#include <ambhw/vic.h>
+#include <irq.h>
+
+#define IRQ_TO_BANK(irq)	((irq) >> 5)
+#define IRQ_TO_OFFSET(irq)	((irq) & 0x1f)
 
 /* ==========================================================================*/
-void enable_interrupts(void)
+
+void irq_set_type(u32 irq, u32 type)
 {
-	unsigned long tmp;
+	u32 bank = IRQ_TO_BANK(irq);
+	u32 offset = IRQ_TO_OFFSET(irq);
 
-	__asm__ __volatile__ (
-		"mrs %0, cpsr\n"
-		"bic %0, %0, #0x80\n"
-		"msr cpsr_c, %0"
-		: "=r" (tmp)
-		:
-		: "memory");
+	switch (type) {
+	case IRQ_RISING_EDGE:
+		writel(VIC_REG(bank, VIC_INT_SENSE_CLR_INT_OFFSET), offset);
+		writel(VIC_REG(bank, VIC_INT_BOTHEDGE_CLR_INT_OFFSET), offset);
+		writel(VIC_REG(bank, VIC_INT_EVT_INT_OFFSET), offset);
+		break;
+	case IRQ_FALLING_EDGE:
+		writel(VIC_REG(bank, VIC_INT_SENSE_CLR_INT_OFFSET), offset);
+		writel(VIC_REG(bank, VIC_INT_BOTHEDGE_CLR_INT_OFFSET), offset);
+		writel(VIC_REG(bank, VIC_INT_EVT_CLR_INT_OFFSET), offset);
+		break;
+	case IRQ_BOTH_EDGES:
+		writel(VIC_REG(bank, VIC_INT_SENSE_CLR_INT_OFFSET), offset);
+		writel(VIC_REG(bank, VIC_INT_BOTHEDGE_INT_OFFSET), offset);
+		writel(VIC_REG(bank, VIC_INT_EVT_CLR_INT_OFFSET), offset);
+		break;
+	case IRQ_LEVEL_HIGH:
+		writel(VIC_REG(bank, VIC_INT_SENSE_INT_OFFSET), offset);
+		writel(VIC_REG(bank, VIC_INT_BOTHEDGE_CLR_INT_OFFSET), offset);
+		writel(VIC_REG(bank, VIC_INT_EVT_INT_OFFSET), offset);
+		break;
+	case IRQ_LEVEL_LOW:
+		writel(VIC_REG(bank, VIC_INT_SENSE_INT_OFFSET), offset);
+		writel(VIC_REG(bank, VIC_INT_BOTHEDGE_CLR_INT_OFFSET), offset);
+		writel(VIC_REG(bank, VIC_INT_EVT_CLR_INT_OFFSET), offset);
+		break;
+	default:
+		BUG_ON(1);
+		break;
+	}
 }
 
-void disable_interrupts(void)
+void irq_enable(u32 irq)
 {
-	unsigned long old;
-	unsigned long tmp;
+	u32 bank = IRQ_TO_BANK(irq);
+	u32 offset = IRQ_TO_OFFSET(irq);
 
-	__asm__ __volatile__ (
-		"mrs %0, cpsr\n"
-		"orr %1, %0, #0xc0\n"
-		"msr cpsr_c, %1"
-		: "=r" (old), "=r" (tmp)
-		:
-		: "memory");
+	writel(VIC_REG(bank, VIC_INT_EN_INT_OFFSET), offset);
 }
 
-/* ==========================================================================*/
-void vic_init(void)
+void irq_disable(u32 irq)
 {
-	disable_interrupts();
+	u32 bank = IRQ_TO_BANK(irq);
+	u32 offset = IRQ_TO_OFFSET(irq);
 
-	/* Set VIC sense and event type for each entry
-	 * note: we initialize udc vbus irq type here */
-	writel(VIC_REG(VIC_SENSE_OFFSET), 0x00000001);
-	writel(VIC_REG(VIC_BOTHEDGE_OFFSET), 0x00000000);
-	writel(VIC_REG(VIC_EVENT_OFFSET), 0x00000001);
-#if (VIC_INSTANCES >= 2)
-	writel(VIC2_REG(VIC_SENSE_OFFSET), 0x00000000);
-	writel(VIC2_REG(VIC_BOTHEDGE_OFFSET), 0x00000000);
-	writel(VIC2_REG(VIC_EVENT_OFFSET), 0x00000000);
-#endif
-#if (VIC_INSTANCES >= 3)
-	writel(VIC3_REG(VIC_SENSE_OFFSET), 0x00000000);
-	writel(VIC3_REG(VIC_BOTHEDGE_OFFSET), 0x00000000);
-	writel(VIC3_REG(VIC_EVENT_OFFSET), 0x00000000);
-#endif
-#if (VIC_INSTANCES >= 4)
-	writel(VIC4_REG(VIC_SENSE_OFFSET), 0x00000000);
-	writel(VIC4_REG(VIC_BOTHEDGE_OFFSET), 0x00000000);
-	writel(VIC4_REG(VIC_EVENT_OFFSET), 0x00000000);
-#endif
-	/* Disable all IRQ */
-	writel(VIC_REG(VIC_INT_SEL_OFFSET), 0x00000000);
-	writel(VIC_REG(VIC_INTEN_OFFSET), 0x00000000);
-	writel(VIC_REG(VIC_INTEN_CLR_OFFSET), 0xffffffff);
-	writel(VIC_REG(VIC_EDGE_CLR_OFFSET), 0xffffffff);
-	writel(VIC_REG(VIC_INT_PTR0_OFFSET), 0xffffffff);
-	writel(VIC_REG(VIC_INT_PTR1_OFFSET), 0x00000000);
-#if (VIC_INSTANCES >= 2)
-	writel(VIC2_REG(VIC_INT_SEL_OFFSET), 0x00000000);
-	writel(VIC2_REG(VIC_INTEN_OFFSET), 0x00000000);
-	writel(VIC2_REG(VIC_INTEN_CLR_OFFSET), 0xffffffff);
-	writel(VIC2_REG(VIC_EDGE_CLR_OFFSET), 0xffffffff);
-	writel(VIC2_REG(VIC_INT_PTR0_OFFSET), 0xffffffff);
-	writel(VIC2_REG(VIC_INT_PTR1_OFFSET), 0x00000000);
-#endif
-#if (VIC_INSTANCES >= 3)
-	writel(VIC3_REG(VIC_INT_SEL_OFFSET), 0x00000000);
-	writel(VIC3_REG(VIC_INTEN_OFFSET), 0x00000000);
-	writel(VIC3_REG(VIC_INTEN_CLR_OFFSET), 0xffffffff);
-	writel(VIC3_REG(VIC_EDGE_CLR_OFFSET), 0xffffffff);
-	writel(VIC3_REG(VIC_INT_PTR0_OFFSET), 0xffffffff);
-	writel(VIC3_REG(VIC_INT_PTR1_OFFSET), 0x00000000);
-#endif
-#if (VIC_INSTANCES >= 4)
-	writel(VIC4_REG(VIC_INT_SEL_OFFSET), 0x00000000);
-	writel(VIC4_REG(VIC_INTEN_OFFSET), 0x00000000);
-	writel(VIC4_REG(VIC_INTEN_CLR_OFFSET), 0xffffffff);
-	writel(VIC4_REG(VIC_EDGE_CLR_OFFSET), 0xffffffff);
-	writel(VIC4_REG(VIC_INT_PTR0_OFFSET), 0xffffffff);
-	writel(VIC4_REG(VIC_INT_PTR1_OFFSET), 0x00000000);
+	/* clear obsolete edge irq */
+#if (VIC_SUPPORT_CPU_OFFLOAD == 1)
+	writel(VIC_REG(bank, VIC_EDGE_CLR_OFFSET), 0x1 << offset);
+#else
+	writel(VIC_REG(bank, VIC_INT_EDGE_CLR_OFFSET), offset);
 #endif
 
-	enable_interrupts();
+	writel(VIC_REG(bank, VIC_INT_EN_CLR_INT_OFFSET), offset);
 }
 
-void vic_set_type(u32 line, u32 type)
+void irq_init(void)
 {
-	u32 mask = 0x0, sense = 0x0 , bothedges = 0x0, event = 0x0;
-	u32 bit = 0x0;
+	int i;
 
-	if (line < VIC_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		mask = ~(0x1 << line);
-		bit = (0x1 << line);
+	disable_interrupts();
 
-		/* Line directly connected to VIC */
-		sense = readl(VIC_REG(VIC_SENSE_OFFSET));
-		bothedges = readl(VIC_REG(VIC_BOTHEDGE_OFFSET));
-		event = readl(VIC_REG(VIC_EVENT_OFFSET));
-#if (VIC_INSTANCES >= 2)
-	} else if (line < VIC2_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		mask = ~(0x1 << (line - VIC2_INT_VEC(0)) );
-		bit = (0x1 << (line - VIC2_INT_VEC(0)) );
+	/*
+	 * Set VIC sense and event type for each entry
+	 */
+	for (i = 0; i < VIC_INSTANCES; i++) {
+		writel(VIC_REG(i, VIC_SENSE_OFFSET), 0x00000000);
+		writel(VIC_REG(i, VIC_BOTHEDGE_OFFSET), 0x00000000);
+		writel(VIC_REG(i, VIC_EVENT_OFFSET), 0x00000000);
+		/* Disable all IRQ */
+		writel(VIC_REG(i, VIC_INT_SEL_OFFSET), 0x00000000);
+		writel(VIC_REG(i, VIC_INTEN_OFFSET), 0x00000000);
+		writel(VIC_REG(i, VIC_INTEN_CLR_OFFSET), 0xffffffff);
+		writel(VIC_REG(i, VIC_EDGE_CLR_OFFSET), 0xffffffff);
+		writel(VIC_REG(i, VIC_INT_PTR0_OFFSET), 0xffffffff);
+		writel(VIC_REG(i, VIC_INT_PTR1_OFFSET), 0x00000000);
+	}
 
-		/* Line directly connected to VIC */
-		sense = readl(VIC2_REG(VIC_SENSE_OFFSET));
-		bothedges = readl(VIC2_REG(VIC_BOTHEDGE_OFFSET));
-		event = readl(VIC2_REG(VIC_EVENT_OFFSET));
-#endif
-#if (VIC_INSTANCES >= 3)
-	} else if (line < VIC3_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		mask = ~(0x1 << (line - VIC3_INT_VEC(0)) );
-		bit = (0x1 << (line - VIC3_INT_VEC(0)) );
+	enable_interrupts();
+}
 
-		/* Line directly connected to VIC */
-		sense = readl(VIC3_REG(VIC_SENSE_OFFSET));
-		bothedges = readl(VIC3_REG(VIC_BOTHEDGE_OFFSET));
-		event = readl(VIC3_REG(VIC_EVENT_OFFSET));
-#endif
-#if (VIC_INSTANCES >= 4)
-	} else if (line < VIC4_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		mask = ~(0x1 << (line - VIC4_INT_VEC(0)) );
-		bit = (0x1 << (line - VIC4_INT_VEC(0)) );
+void irq_handler(void)
+{
+	u32 irq, irq_sta;
+#if (VIC_SUPPORT_CPU_OFFLOAD == 1)
+	u32 i;
 
-		/* Line directly connected to VIC */
-		sense = readl(VIC4_REG(VIC_SENSE_OFFSET));
-		bothedges = readl(VIC4_REG(VIC_BOTHEDGE_OFFSET));
-		event = readl(VIC4_REG(VIC_EVENT_OFFSET));
-#endif
-	}
+	for (i = 0; i < VIC_INSTANCES; i++) {
+		do {
+			irq = readl(VIC_REG(i, VIC_INT_PENDING_OFFSET));
+			if (irq == 0) {
+				irq_sta = readl(VIC_REG(i, VIC_IRQ_STA_OFFSET));
+				if ((irq_sta & 0x1) == 0)
+					break;
+			}
 
-	switch (type) {
-	case VIRQ_RISING_EDGE:
-		sense &= mask;
-		bothedges &= mask;
-		event |= bit;
-		break;
-	case VIRQ_FALLING_EDGE:
-		sense &= mask;
-		bothedges &= mask;
-		event &= mask;
-		break;
-	case VIRQ_BOTH_EDGES:
-		sense &= mask;
-		bothedges |= bit;
-		event &= mask;
-		break;
-	case VIRQ_LEVEL_LOW:
-		sense |= bit;
-		bothedges &= mask;
-		event &= mask;
-		break;
-	case VIRQ_LEVEL_HIGH:
-		sense |= bit;
-		bothedges &= mask;
-		event |= bit;
-		break;
-	}
+			irq += i * NR_VIC_IRQ_SIZE;
 
-	if (line < VIC_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC_REG(VIC_SENSE_OFFSET), sense);
-		writel(VIC_REG(VIC_BOTHEDGE_OFFSET), bothedges);
-		writel(VIC_REG(VIC_EVENT_OFFSET), event);
-#if (VIC_INSTANCES >= 2)
-	} else if (line < VIC2_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC2_REG(VIC_SENSE_OFFSET), sense);
-		writel(VIC2_REG(VIC_BOTHEDGE_OFFSET), bothedges);
-		writel(VIC2_REG(VIC_EVENT_OFFSET), event);
-#endif
-#if (VIC_INSTANCES >= 3)
-	} else if (line < VIC3_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC3_REG(VIC_SENSE_OFFSET), sense);
-		writel(VIC3_REG(VIC_BOTHEDGE_OFFSET), bothedges);
-		writel(VIC3_REG(VIC_EVENT_OFFSET), event);
-#endif
-#if (VIC_INSTANCES >= 4)
-	} else if (line < VIC4_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC4_REG(VIC_SENSE_OFFSET), sense);
-		writel(VIC4_REG(VIC_BOTHEDGE_OFFSET), bothedges);
-		writel(VIC4_REG(VIC_EVENT_OFFSET), event);
-#endif
-	} else {
-		K_ASSERT(0);
-	}
-}
+			if (irq >= NR_IRQS)
+				break;
 
-void vic_enable(u32 line)
-{
-	u32 r;
+			/* ack and disable the irq */
+			irq_disable(irq);
 
-	if (line < VIC_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC_REG(VIC_INTEN_OFFSET));
-		r |= (0x1 << line);
-		writel(VIC_REG(VIC_INTEN_OFFSET), r);
-#if (VIC_INSTANCES >= 2)
-	} else if (line < VIC2_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC2_REG(VIC_INTEN_OFFSET));
-		r |= (0x1 << (line - VIC2_INT_VEC(0)));
-		writel(VIC2_REG(VIC_INTEN_OFFSET), r);
-#endif
-#if (VIC_INSTANCES >= 3)
-	} else if (line < VIC3_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC3_REG(VIC_INTEN_OFFSET));
-		r |= (0x1 << (line - VIC3_INT_VEC(0)));
-		writel(VIC3_REG(VIC_INTEN_OFFSET), r);
-#endif
-#if (VIC_INSTANCES >= 4)
-	} else if (line < VIC4_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC4_REG(VIC_INTEN_OFFSET));
-		r |= (0x1 << (line - VIC4_INT_VEC(0)));
-		writel(VIC4_REG(VIC_INTEN_OFFSET), r);
-#endif
-	}
-}
+			ASSERT(!irq_manager[irq].handler, "irq = %d\n", irq);
+			irq_manager[irq].handler(irq_manager[irq].data);
 
-void vic_disable(u32 line)
-{
-	if (line < VIC_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC_REG(VIC_INTEN_CLR_OFFSET),
-			(0x1 << line));
-#if (VIC_INSTANCES >= 2)
-	} else if (line < VIC2_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC2_REG(VIC_INTEN_CLR_OFFSET),
-			(0x1 << (line - VIC2_INT_VEC(0))));
-#endif
-#if (VIC_INSTANCES >= 3)
-	} else if (line < VIC3_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC3_REG(VIC_INTEN_CLR_OFFSET),
-			(0x1 << (line - VIC3_INT_VEC(0))));
-#endif
-#if (VIC_INSTANCES >= 4)
-	} else if (line < VIC4_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC4_REG(VIC_INTEN_CLR_OFFSET),
-			(0x1 << (line - VIC4_INT_VEC(0))));
-#endif
-	}
-}
+			irq_enable(irq);
 
-void vic_ackint(u32 line)
-{
-	if (line < VIC_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC_REG(VIC_EDGE_CLR_OFFSET),
-			(0x1 << line));
-#if (VIC_INSTANCES >= 2)
-	} else if (line < VIC2_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC2_REG(VIC_EDGE_CLR_OFFSET),
-			(0x1 << (line - VIC2_INT_VEC(0))));
-#endif
-#if (VIC_INSTANCES >= 3)
-	} else if (line < VIC3_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC3_REG(VIC_EDGE_CLR_OFFSET),
-			(0x1 << (line - VIC3_INT_VEC(0))));
-#endif
-#if (VIC_INSTANCES >= 4)
-	} else if (line < VIC4_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		writel(VIC4_REG(VIC_EDGE_CLR_OFFSET),
-			(0x1 << (line - VIC4_INT_VEC(0))));
-#endif
+		} while (1);
 	}
-}
+#else
+	do {
+		irq = readl(AHBSP_PRI_IRQ_C0_REG);
+		if (irq == VIC_NULL_PRI_IRQ_VAL)
+			break;
+		else if (irq == 0) {
+			irq_sta = readl(VIC_REG(0, VIC_IRQ_STA_OFFSET));
+			if ((irq_sta & 0x1) == 0)
+				break;
+		} else if (irq >= NR_IRQS)
+			break;
 
-void vic_sw_set(u32 line)
-{
-	u32 r;
+		/* ack and disable the irq */
+		irq_disable(irq);
 
-	if (line < VIC_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC_REG(VIC_SOFTEN_OFFSET));
-		r |= (0x1 << line);
-		writel(VIC_REG(VIC_SOFTEN_OFFSET), r);
-#if (VIC_INSTANCES >= 2)
-	} else if (line < VIC2_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC2_REG(VIC_SOFTEN_OFFSET));
-		r |= (0x1 << (line - VIC2_INT_VEC(0)));
-		writel(VIC2_REG(VIC_SOFTEN_OFFSET), r);
-#endif
-#if (VIC_INSTANCES >= 3)
-	} else if (line < VIC3_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC3_REG(VIC_SOFTEN_OFFSET));
-		r |= (0x1 << (line - VIC3_INT_VEC(0)));
-		writel(VIC3_REG(VIC_SOFTEN_OFFSET), r);
-#endif
-#if (VIC_INSTANCES >= 4)
-	} else if (line < VIC4_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC4_REG(VIC_SOFTEN_OFFSET));
-		r |= (0x1 << (line - VIC4_INT_VEC(0)));
-		writel(VIC4_REG(VIC_SOFTEN_OFFSET), r);
-#endif
-	}
-}
+		ASSERT(!irq_manager[irq].handler, "irq = %d\n", irq);
+		irq_manager[irq].handler(irq_manager[irq].data);
 
-void vic_sw_clr(u32 line)
-{
-	u32 r;
+		irq_enable(irq);
 
-	if (line < VIC_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC_REG(VIC_SOFTEN_CLR_OFFSET));
-		r |= (0x1 << line);
-		writel(VIC_REG(VIC_SOFTEN_CLR_OFFSET), r);
-#if (VIC_INSTANCES >= 2)
-	} else if (line < VIC2_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC2_REG(VIC_SOFTEN_CLR_OFFSET));
-		r |= (0x1 << (line - VIC2_INT_VEC(0)));
-		writel(VIC2_REG(VIC_SOFTEN_CLR_OFFSET), r);
-#endif
-#if (VIC_INSTANCES >= 3)
-	} else if (line < VIC3_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC3_REG(VIC_SOFTEN_CLR_OFFSET));
-		r |= (0x1 << (line - VIC3_INT_VEC(0)));
-		writel(VIC3_REG(VIC_SOFTEN_CLR_OFFSET), r);
+	} while (1);
 #endif
-#if (VIC_INSTANCES >= 4)
-	} else if (line < VIC4_INT_VEC(NR_VIC_IRQ_SIZE)) {
-		r = readl(VIC4_REG(VIC_SOFTEN_CLR_OFFSET));
-		r |= (0x1 << (line - VIC4_INT_VEC(0)));
-		writel(VIC4_REG(VIC_SOFTEN_CLR_OFFSET), r);
-#endif
-	}
 }
 
diff --git a/src/bst/version.info b/src/bst/version.info
index 58817cd..07ed3a1 100644
--- a/src/bst/version.info
+++ b/src/bst/version.info
@@ -6,12 +6,30 @@
  * History:
  *    2005/03/06 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #ifndef __VERSION_INFO__
diff --git a/src/flashdb/slcnand/asu1ga30ht.c b/src/flashdb/slcnand/asu1ga30ht.c
index 0eed0f0..4e8a028 100644
--- a/src/flashdb/slcnand/asu1ga30ht.c
+++ b/src/flashdb/slcnand/asu1ga30ht.c
@@ -4,12 +4,30 @@
  * History:
  *    2010/11/11 - [Geng-Ken Wu] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/asu1ga30ht.h>
diff --git a/src/flashdb/slcnand/ct48248ns486g1.c b/src/flashdb/slcnand/ct48248ns486g1.c
index 7f7f09d..06d6d14 100644
--- a/src/flashdb/slcnand/ct48248ns486g1.c
+++ b/src/flashdb/slcnand/ct48248ns486g1.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/ct48248ns486g1.h>
diff --git a/src/flashdb/slcnand/f59l1g81a.c b/src/flashdb/slcnand/f59l1g81a.c
index 183684b..e2a55ae 100644
--- a/src/flashdb/slcnand/f59l1g81a.c
+++ b/src/flashdb/slcnand/f59l1g81a.c
@@ -4,12 +4,30 @@
  * History:
  *    2012/05/22 - [Cao Rongrong] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/f59l1g81a.h>
diff --git a/src/flashdb/slcnand/f59l1g81la.c b/src/flashdb/slcnand/f59l1g81la.c
index d3fb3c8..49e3cfc 100644
--- a/src/flashdb/slcnand/f59l1g81la.c
+++ b/src/flashdb/slcnand/f59l1g81la.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/12/15 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/f59l1g81la.h>
diff --git a/src/flashdb/slcnand/f59l1g81ma.c b/src/flashdb/slcnand/f59l1g81ma.c
index 8a213d3..0a20315 100644
--- a/src/flashdb/slcnand/f59l1g81ma.c
+++ b/src/flashdb/slcnand/f59l1g81ma.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/12/15 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/f59l1g81ma.h>
diff --git a/src/flashdb/slcnand/f59l2g81a.c b/src/flashdb/slcnand/f59l2g81a.c
index 4d91e5f..3d1e5c7 100644
--- a/src/flashdb/slcnand/f59l2g81a.c
+++ b/src/flashdb/slcnand/f59l2g81a.c
@@ -4,12 +4,30 @@
  * History:
  *    2012/12/18 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/f59l2g81a.h>
diff --git a/src/flashdb/slcnand/f59l4g81a.c b/src/flashdb/slcnand/f59l4g81a.c
index 47178d7..86d1c69 100644
--- a/src/flashdb/slcnand/f59l4g81a.c
+++ b/src/flashdb/slcnand/f59l4g81a.c
@@ -4,12 +4,30 @@
  * History:
  *    2012/12/18 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/f59l4g81a.h>
diff --git a/src/flashdb/slcnand/h27u2g8f2c.c b/src/flashdb/slcnand/h27u2g8f2c.c
new file mode 100644
index 0000000..df342e4
--- /dev/null
+++ b/src/flashdb/slcnand/h27u2g8f2c.c
@@ -0,0 +1,41 @@
+/**
+ * system/src/flashdb/slcnand/h27u2g8f2c.c
+ *
+ * History:
+ *    2016/01/26 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <flash/slcnand/h27u2g8f2c.h>
+#include <flash/nanddb.h>
+
+#ifndef NAND_DEVICES
+#define NAND_DEVICES	1
+#endif
+
+IMPLEMENT_NAND_DB_DEV(h27u2g8f2c);
+
diff --git a/src/flashdb/slcnand/h27u2g8f2d.c b/src/flashdb/slcnand/h27u2g8f2d.c
index 857d870..336b957 100644
--- a/src/flashdb/slcnand/h27u2g8f2d.c
+++ b/src/flashdb/slcnand/h27u2g8f2d.c
@@ -4,12 +4,30 @@
  * History:
  *    2015/05/13 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/h27u2g8f2d.h>
diff --git a/src/flashdb/slcnand/h27u518s2c.c b/src/flashdb/slcnand/h27u518s2c.c
index 3e75056..4a174f2 100644
--- a/src/flashdb/slcnand/h27u518s2c.c
+++ b/src/flashdb/slcnand/h27u518s2c.c
@@ -4,12 +4,30 @@
  * History:
  *    2010/09/20 - [Evan Chen] created file
  *
- * Copyright (C) 2010-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/h27u518s2c.h>
diff --git a/src/flashdb/slcnand/hy27u1g8f2b.c b/src/flashdb/slcnand/hy27u1g8f2b.c
index 4a39897..7cda76d 100644
--- a/src/flashdb/slcnand/hy27u1g8f2b.c
+++ b/src/flashdb/slcnand/hy27u1g8f2b.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27u1g8f2b.h>
diff --git a/src/flashdb/slcnand/hy27ua081g1m.c b/src/flashdb/slcnand/hy27ua081g1m.c
index d8760a1..1224ee4 100644
--- a/src/flashdb/slcnand/hy27ua081g1m.c
+++ b/src/flashdb/slcnand/hy27ua081g1m.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/12/06 - [Dragon Chiang] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27ua081g1m.h>
diff --git a/src/flashdb/slcnand/hy27uf081g2a.c b/src/flashdb/slcnand/hy27uf081g2a.c
index 57a97c8..ca741fc 100644
--- a/src/flashdb/slcnand/hy27uf081g2a.c
+++ b/src/flashdb/slcnand/hy27uf081g2a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/12/26 - [Louvre Tseng] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27uf081g2a.h>
diff --git a/src/flashdb/slcnand/hy27uf082g2a.c b/src/flashdb/slcnand/hy27uf082g2a.c
index 53cdc12..bce4626 100644
--- a/src/flashdb/slcnand/hy27uf082g2a.c
+++ b/src/flashdb/slcnand/hy27uf082g2a.c
@@ -4,12 +4,30 @@
  * History:
  *    2009/08/05 - [Anthony Ginger] created file
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27uf082g2a.h>
diff --git a/src/flashdb/slcnand/hy27uf082g2b.c b/src/flashdb/slcnand/hy27uf082g2b.c
index cd052ac..8546353 100644
--- a/src/flashdb/slcnand/hy27uf082g2b.c
+++ b/src/flashdb/slcnand/hy27uf082g2b.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/12/26 - [Evan Chen] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27uf082g2b.h>
diff --git a/src/flashdb/slcnand/hy27uf084g2b.c b/src/flashdb/slcnand/hy27uf084g2b.c
index 10297f5..4b94dd7 100644
--- a/src/flashdb/slcnand/hy27uf084g2b.c
+++ b/src/flashdb/slcnand/hy27uf084g2b.c
@@ -4,12 +4,30 @@
  * History:
  *    2009/11/10 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27uf084g2b.h>
diff --git a/src/flashdb/slcnand/hy27uf084g2m.c b/src/flashdb/slcnand/hy27uf084g2m.c
index 3b56075..03b2d7a 100644
--- a/src/flashdb/slcnand/hy27uf084g2m.c
+++ b/src/flashdb/slcnand/hy27uf084g2m.c
@@ -4,12 +4,30 @@
  * History:
  *    2008/04/01 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27uf084g2m.h>
diff --git a/src/flashdb/slcnand/hy27us08121a.c b/src/flashdb/slcnand/hy27us08121a.c
index b60c76f..2d480ab 100644
--- a/src/flashdb/slcnand/hy27us08121a.c
+++ b/src/flashdb/slcnand/hy27us08121a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Chien-Yang Chen] created file
  *
- * Copyright (C) 2004-2008, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27us08121a.h>
diff --git a/src/flashdb/slcnand/hy27us08121m.c b/src/flashdb/slcnand/hy27us08121m.c
index 80128db..1eb513b 100644
--- a/src/flashdb/slcnand/hy27us08121m.c
+++ b/src/flashdb/slcnand/hy27us08121m.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27us08121m.h>
diff --git a/src/flashdb/slcnand/hy27us08281a.c b/src/flashdb/slcnand/hy27us08281a.c
index 6ce0fb1..38a45de 100644
--- a/src/flashdb/slcnand/hy27us08281a.c
+++ b/src/flashdb/slcnand/hy27us08281a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27us08281a.h>
diff --git a/src/flashdb/slcnand/hy27us08561a.c b/src/flashdb/slcnand/hy27us08561a.c
index 2afb05b..2f67250 100644
--- a/src/flashdb/slcnand/hy27us08561a.c
+++ b/src/flashdb/slcnand/hy27us08561a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27us08561a.h>
diff --git a/src/flashdb/slcnand/hy27us08561m.c b/src/flashdb/slcnand/hy27us08561m.c
index 311e536..fb61ce2 100644
--- a/src/flashdb/slcnand/hy27us08561m.c
+++ b/src/flashdb/slcnand/hy27us08561m.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/hy27us08561m.h>
diff --git a/src/flashdb/slcnand/k9f1208.c b/src/flashdb/slcnand/k9f1208.c
index c49e339..7218c0a 100644
--- a/src/flashdb/slcnand/k9f1208.c
+++ b/src/flashdb/slcnand/k9f1208.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f1208.h>
diff --git a/src/flashdb/slcnand/k9f1208x0c.c b/src/flashdb/slcnand/k9f1208x0c.c
index cba8306..e29fa3f 100644
--- a/src/flashdb/slcnand/k9f1208x0c.c
+++ b/src/flashdb/slcnand/k9f1208x0c.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f1208x0c.h>
diff --git a/src/flashdb/slcnand/k9f1g08.c b/src/flashdb/slcnand/k9f1g08.c
index cfb8452..bacd3e7 100644
--- a/src/flashdb/slcnand/k9f1g08.c
+++ b/src/flashdb/slcnand/k9f1g08.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f1g08.h>
diff --git a/src/flashdb/slcnand/k9f1g08u0b.c b/src/flashdb/slcnand/k9f1g08u0b.c
index 943fc1e..041bf95 100644
--- a/src/flashdb/slcnand/k9f1g08u0b.c
+++ b/src/flashdb/slcnand/k9f1g08u0b.c
@@ -4,12 +4,30 @@
  * History:
  *    2010/05/24 - [Evan Chen] created file
  *
- * Copyright (C) 2010-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f1g08u0b.h>
diff --git a/src/flashdb/slcnand/k9f1g08u0e.c b/src/flashdb/slcnand/k9f1g08u0e.c
index 1f7a176..35f833a 100644
--- a/src/flashdb/slcnand/k9f1g08u0e.c
+++ b/src/flashdb/slcnand/k9f1g08u0e.c
@@ -4,12 +4,30 @@
  * History:
  *    2013/10/24 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f1g08u0e.h>
diff --git a/src/flashdb/slcnand/k9f2808.c b/src/flashdb/slcnand/k9f2808.c
index 97bbe40..405d6d2 100644
--- a/src/flashdb/slcnand/k9f2808.c
+++ b/src/flashdb/slcnand/k9f2808.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f2808.h>
diff --git a/src/flashdb/slcnand/k9f2g08.c b/src/flashdb/slcnand/k9f2g08.c
index 578f1b1..93c005b 100644
--- a/src/flashdb/slcnand/k9f2g08.c
+++ b/src/flashdb/slcnand/k9f2g08.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f2g08.h>
diff --git a/src/flashdb/slcnand/k9f2g08u0c.c b/src/flashdb/slcnand/k9f2g08u0c.c
index b131297..1a0d025 100644
--- a/src/flashdb/slcnand/k9f2g08u0c.c
+++ b/src/flashdb/slcnand/k9f2g08u0c.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f2g08u0c.h>
diff --git a/src/flashdb/slcnand/k9f4g08u0a.c b/src/flashdb/slcnand/k9f4g08u0a.c
index 99054f6..ebf3845 100644
--- a/src/flashdb/slcnand/k9f4g08u0a.c
+++ b/src/flashdb/slcnand/k9f4g08u0a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f4g08u0a.h>
diff --git a/src/flashdb/slcnand/k9f4g08u0e.c b/src/flashdb/slcnand/k9f4g08u0e.c
index c5b56a6..ad08c60 100644
--- a/src/flashdb/slcnand/k9f4g08u0e.c
+++ b/src/flashdb/slcnand/k9f4g08u0e.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/03/06 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f4g08u0e.h>
diff --git a/src/flashdb/slcnand/k9f5608.c b/src/flashdb/slcnand/k9f5608.c
index aa80cfb..c1c76d0 100644
--- a/src/flashdb/slcnand/k9f5608.c
+++ b/src/flashdb/slcnand/k9f5608.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9f5608.h>
diff --git a/src/flashdb/slcnand/k9k4g08.c b/src/flashdb/slcnand/k9k4g08.c
index ca3aeb5..8d4df76 100644
--- a/src/flashdb/slcnand/k9k4g08.c
+++ b/src/flashdb/slcnand/k9k4g08.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9k4g08.h>
diff --git a/src/flashdb/slcnand/k9k8g08.c b/src/flashdb/slcnand/k9k8g08.c
index 5f488e3..a677dc6 100644
--- a/src/flashdb/slcnand/k9k8g08.c
+++ b/src/flashdb/slcnand/k9k8g08.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9k8g08.h>
diff --git a/src/flashdb/slcnand/k9nbg08.c b/src/flashdb/slcnand/k9nbg08.c
index 7fffea3..a8a3521 100644
--- a/src/flashdb/slcnand/k9nbg08.c
+++ b/src/flashdb/slcnand/k9nbg08.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9nbg08.h>
diff --git a/src/flashdb/slcnand/k9w8g08.c b/src/flashdb/slcnand/k9w8g08.c
index a309159..9892141 100644
--- a/src/flashdb/slcnand/k9w8g08.c
+++ b/src/flashdb/slcnand/k9w8g08.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9w8g08.h>
diff --git a/src/flashdb/slcnand/k9wag08.c b/src/flashdb/slcnand/k9wag08.c
index 8960da9..52b2d89 100644
--- a/src/flashdb/slcnand/k9wag08.c
+++ b/src/flashdb/slcnand/k9wag08.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/k9wag08.h>
diff --git a/src/flashdb/slcnand/mt29f1g08abaea.c b/src/flashdb/slcnand/mt29f1g08abaea.c
index 9ea90e1..80c26ca 100644
--- a/src/flashdb/slcnand/mt29f1g08abaea.c
+++ b/src/flashdb/slcnand/mt29f1g08abaea.c
@@ -4,12 +4,30 @@
  * History:
  *    2015/04/07 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/mt29f1g08abaea.h>
diff --git a/src/flashdb/slcnand/mt29f2g08aac.c b/src/flashdb/slcnand/mt29f2g08aac.c
index a321913..3ff2cf5 100644
--- a/src/flashdb/slcnand/mt29f2g08aac.c
+++ b/src/flashdb/slcnand/mt29f2g08aac.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/mt29f2g08aac.h>
diff --git a/src/flashdb/slcnand/mt29f2g08aba.c b/src/flashdb/slcnand/mt29f2g08aba.c
index 83fb685..c67fe19 100644
--- a/src/flashdb/slcnand/mt29f2g08aba.c
+++ b/src/flashdb/slcnand/mt29f2g08aba.c
@@ -4,12 +4,30 @@
  * History:
  *    2010/06/28 - [Evan Chen] created file
  *
- * Copyright (C) 2010-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/mt29f2g08aba.h>
diff --git a/src/flashdb/slcnand/mt29f2g08abafa.c b/src/flashdb/slcnand/mt29f2g08abafa.c
index 480a211..5e6d59d 100644
--- a/src/flashdb/slcnand/mt29f2g08abafa.c
+++ b/src/flashdb/slcnand/mt29f2g08abafa.c
@@ -4,12 +4,30 @@
  * History:
  *    2015/04/15 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/mt29f2g08abafa.h>
diff --git a/src/flashdb/slcnand/mt29f2g08abaga.c b/src/flashdb/slcnand/mt29f2g08abaga.c
new file mode 100644
index 0000000..c4477f5
--- /dev/null
+++ b/src/flashdb/slcnand/mt29f2g08abaga.c
@@ -0,0 +1,41 @@
+/**
+ * system/src/flashdb/slcnandl/mt29f2g08abaga.c
+ *
+ * History:
+ *    2017/09/14 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <flash/slcnand/mt29f2g08abaga.h>
+#include <flash/nanddb.h>
+
+#ifndef NAND_DEVICES
+#define NAND_DEVICES	1
+#endif
+
+IMPLEMENT_NAND_DB_DEV(mt29f2g08abaga);
+
diff --git a/src/flashdb/slcnand/mt29f2g08abbea.c b/src/flashdb/slcnand/mt29f2g08abbea.c
new file mode 100644
index 0000000..7161134
--- /dev/null
+++ b/src/flashdb/slcnand/mt29f2g08abbea.c
@@ -0,0 +1,40 @@
+/**
+ * system/src/flashdb/slcnandl/mt29f2g08abbea.c
+ *
+ * History:
+ *    2016/11/09 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <flash/slcnand/mt29f2g08abbea.h>
+#include <flash/nanddb.h>
+
+#ifndef NAND_DEVICES
+#define NAND_DEVICES	1
+#endif
+
+IMPLEMENT_NAND_DB_DEV(mt29f2g08abbea);
diff --git a/src/flashdb/slcnand/mt29f4g08abada.c b/src/flashdb/slcnand/mt29f4g08abada.c
new file mode 100644
index 0000000..f141f16
--- /dev/null
+++ b/src/flashdb/slcnand/mt29f4g08abada.c
@@ -0,0 +1,40 @@
+/**
+ * system/src/flashdb/slcnandl/mt29f4g08abada.c
+ *
+ * History:
+ *    2016/02/04 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <flash/slcnand/mt29f4g08abada.h>
+#include <flash/nanddb.h>
+
+#ifndef NAND_DEVICES
+#define NAND_DEVICES	1
+#endif
+
+IMPLEMENT_NAND_DB_DEV(mt29f4g08abada);
diff --git a/src/flashdb/slcnand/mt29f4g08abbda.c b/src/flashdb/slcnand/mt29f4g08abbda.c
new file mode 100644
index 0000000..ca733eb
--- /dev/null
+++ b/src/flashdb/slcnand/mt29f4g08abbda.c
@@ -0,0 +1,40 @@
+/**
+ * system/src/flashdb/slcnandl/mt29f4g08abbda.c
+ *
+ * History:
+ *    2016/08/08 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <flash/slcnand/mt29f4g08abbda.h>
+#include <flash/nanddb.h>
+
+#ifndef NAND_DEVICES
+#define NAND_DEVICES	1
+#endif
+
+IMPLEMENT_NAND_DB_DEV(mt29f4g08abbda);
diff --git a/src/flashdb/slcnand/mt29f8g08daa.c b/src/flashdb/slcnand/mt29f8g08daa.c
index 95dad13..9eef1d4 100644
--- a/src/flashdb/slcnand/mt29f8g08daa.c
+++ b/src/flashdb/slcnand/mt29f8g08daa.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/mt29f8g08daa.h>
diff --git a/src/flashdb/slcnand/mx30lf1g08aa.c b/src/flashdb/slcnand/mx30lf1g08aa.c
index 750b7a6..f43d745 100644
--- a/src/flashdb/slcnand/mx30lf1g08aa.c
+++ b/src/flashdb/slcnand/mx30lf1g08aa.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/03/27 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/mx30lf1g08aa.h>
diff --git a/src/flashdb/slcnand/mx30lf1ge8ab.c b/src/flashdb/slcnand/mx30lf1ge8ab.c
index b3f7476..1968c24 100644
--- a/src/flashdb/slcnand/mx30lf1ge8ab.c
+++ b/src/flashdb/slcnand/mx30lf1ge8ab.c
@@ -4,12 +4,30 @@
  * History:
  *    2015/07/30 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/mx30lf1ge8ab.h>
diff --git a/src/flashdb/slcnand/mx30lf2ge8ab.c b/src/flashdb/slcnand/mx30lf2ge8ab.c
index ca8c52f..4771a3c 100644
--- a/src/flashdb/slcnand/mx30lf2ge8ab.c
+++ b/src/flashdb/slcnand/mx30lf2ge8ab.c
@@ -4,12 +4,30 @@
  * History:
  *    2015/04/08 - [Ken He] created file
  *
- * Copyright (C) 2014-2018, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/mx30lf2ge8ab.h>
diff --git a/src/flashdb/slcnand/mx30lf4ge8ab.c b/src/flashdb/slcnand/mx30lf4ge8ab.c
new file mode 100644
index 0000000..34eacc4
--- /dev/null
+++ b/src/flashdb/slcnand/mx30lf4ge8ab.c
@@ -0,0 +1,40 @@
+/**
+ * system/src/flashdb/slcnandl/mx30lf4ge8ab.c
+ *
+ * History:
+ *    2015/12/24 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <flash/slcnand/mx30lf4ge8ab.h>
+#include <flash/nanddb.h>
+
+#ifndef NAND_DEVICES
+#define NAND_DEVICES	1
+#endif
+
+IMPLEMENT_NAND_DB_DEV(mx30lf4ge8ab);
diff --git a/src/flashdb/slcnand/numonyx02gw3b2d.c b/src/flashdb/slcnand/numonyx02gw3b2d.c
index 179b7ac..c6f0be8 100644
--- a/src/flashdb/slcnand/numonyx02gw3b2d.c
+++ b/src/flashdb/slcnand/numonyx02gw3b2d.c
@@ -4,12 +4,30 @@
  * History:
  *    2009/08/05 - [Evan Chen] created file
  *
- * Copyright (C) 2004-2009, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/numonyx02gw3b2d.h>
diff --git a/src/flashdb/slcnand/s34ml01g1.c b/src/flashdb/slcnand/s34ml01g1.c
index 1fc44e1..0ae7766 100644
--- a/src/flashdb/slcnand/s34ml01g1.c
+++ b/src/flashdb/slcnand/s34ml01g1.c
@@ -4,12 +4,30 @@
  * History:
  *    2012/12/27 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/s34ml01g1.h>
diff --git a/src/flashdb/slcnand/s34ml01g2.c b/src/flashdb/slcnand/s34ml01g2.c
index a382093..03ed560 100644
--- a/src/flashdb/slcnand/s34ml01g2.c
+++ b/src/flashdb/slcnand/s34ml01g2.c
@@ -4,12 +4,30 @@
  * History:
  *    2012/12/27 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/s34ml01g2.h>
diff --git a/src/flashdb/slcnand/s34ml02g1.c b/src/flashdb/slcnand/s34ml02g1.c
index 5ff41e1..3b0998c 100644
--- a/src/flashdb/slcnand/s34ml02g1.c
+++ b/src/flashdb/slcnand/s34ml02g1.c
@@ -4,12 +4,30 @@
  * History:
  *    2012/12/27 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/s34ml02g1.h>
diff --git a/src/flashdb/slcnand/s34ml02g2.c b/src/flashdb/slcnand/s34ml02g2.c
index 980d86e..6eda6c1 100644
--- a/src/flashdb/slcnand/s34ml02g2.c
+++ b/src/flashdb/slcnand/s34ml02g2.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/02/14 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/s34ml02g2.h>
diff --git a/src/flashdb/slcnand/s34ml04g1.c b/src/flashdb/slcnand/s34ml04g1.c
index ea73138..93f0944 100644
--- a/src/flashdb/slcnand/s34ml04g1.c
+++ b/src/flashdb/slcnand/s34ml04g1.c
@@ -4,12 +4,30 @@
  * History:
  *    2012/12/27 - [Ken He] created file
  *
- * Copyright (C) 2012-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/s34ml04g1.h>
diff --git a/src/flashdb/slcnand/s34ml04g2.c b/src/flashdb/slcnand/s34ml04g2.c
index 8181091..cec06ba 100644
--- a/src/flashdb/slcnand/s34ml04g2.c
+++ b/src/flashdb/slcnand/s34ml04g2.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/01/24 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/s34ml04g2.h>
diff --git a/src/flashdb/slcnand/s34ml08g1.c b/src/flashdb/slcnand/s34ml08g1.c
new file mode 100644
index 0000000..4166409
--- /dev/null
+++ b/src/flashdb/slcnand/s34ml08g1.c
@@ -0,0 +1,40 @@
+/**
+ * system/src/flashdb/slcnandl/s34ml08g1.c
+ *
+ * History:
+ *    2017/05/10 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <flash/slcnand/s34ml08g1.h>
+#include <flash/nanddb.h>
+
+#ifndef NAND_DEVICES
+#define NAND_DEVICES	1
+#endif
+
+IMPLEMENT_NAND_DB_DEV(s34ml08g1);
diff --git a/src/flashdb/slcnand/s34ms02g1.c b/src/flashdb/slcnand/s34ms02g1.c
new file mode 100644
index 0000000..0e9e0a0
--- /dev/null
+++ b/src/flashdb/slcnand/s34ms02g1.c
@@ -0,0 +1,40 @@
+/**
+ * system/src/flashdb/slcnandl/s34ms02g1.c
+ *
+ * History:
+ *    2017/07/06 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <flash/slcnand/s34ms02g1.h>
+#include <flash/nanddb.h>
+
+#ifndef NAND_DEVICES
+#define NAND_DEVICES	1
+#endif
+
+IMPLEMENT_NAND_DB_DEV(s34ms02g1);
diff --git a/src/flashdb/slcnand/s34ms04g1.c b/src/flashdb/slcnand/s34ms04g1.c
new file mode 100644
index 0000000..8e50de0
--- /dev/null
+++ b/src/flashdb/slcnand/s34ms04g1.c
@@ -0,0 +1,40 @@
+/**
+ * system/src/flashdb/slcnandl/s34ms04g1.c
+ *
+ * History:
+ *    2017/05/19 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <flash/slcnand/s34ms04g1.h>
+#include <flash/nanddb.h>
+
+#ifndef NAND_DEVICES
+#define NAND_DEVICES	1
+#endif
+
+IMPLEMENT_NAND_DB_DEV(s34ms04g1);
diff --git a/src/flashdb/slcnand/st01gw3a.c b/src/flashdb/slcnand/st01gw3a.c
index b029f59..d3d86c2 100644
--- a/src/flashdb/slcnand/st01gw3a.c
+++ b/src/flashdb/slcnand/st01gw3a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/st01gw3a.h>
diff --git a/src/flashdb/slcnand/st01gw3b.c b/src/flashdb/slcnand/st01gw3b.c
index b8e9cc0..f6d8fcf 100644
--- a/src/flashdb/slcnand/st01gw3b.c
+++ b/src/flashdb/slcnand/st01gw3b.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/st01gw3b.h>
diff --git a/src/flashdb/slcnand/st02gw3b.c b/src/flashdb/slcnand/st02gw3b.c
index 1a32a61..ff6e657 100644
--- a/src/flashdb/slcnand/st02gw3b.c
+++ b/src/flashdb/slcnand/st02gw3b.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/st02gw3b.h>
diff --git a/src/flashdb/slcnand/st128w3a.c b/src/flashdb/slcnand/st128w3a.c
index 5223e40..529da67 100644
--- a/src/flashdb/slcnand/st128w3a.c
+++ b/src/flashdb/slcnand/st128w3a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/st128w3a.h>
diff --git a/src/flashdb/slcnand/st256w3a.c b/src/flashdb/slcnand/st256w3a.c
index c8e558f..c04033c 100644
--- a/src/flashdb/slcnand/st256w3a.c
+++ b/src/flashdb/slcnand/st256w3a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/st256w3a.h>
diff --git a/src/flashdb/slcnand/st512w3a.c b/src/flashdb/slcnand/st512w3a.c
index 9066df2..ff407e6 100644
--- a/src/flashdb/slcnand/st512w3a.c
+++ b/src/flashdb/slcnand/st512w3a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/st512w3a.h>
diff --git a/src/flashdb/slcnand/tc58bvg0s3h.c b/src/flashdb/slcnand/tc58bvg0s3h.c
index aefdde4..86635fc 100644
--- a/src/flashdb/slcnand/tc58bvg0s3h.c
+++ b/src/flashdb/slcnand/tc58bvg0s3h.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/03/11 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58bvg0s3h.h>
diff --git a/src/flashdb/slcnand/tc58bvg1s3h.c b/src/flashdb/slcnand/tc58bvg1s3h.c
index 4c6ef47..273e890 100644
--- a/src/flashdb/slcnand/tc58bvg1s3h.c
+++ b/src/flashdb/slcnand/tc58bvg1s3h.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/05/14 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58bvg1s3h.h>
diff --git a/src/flashdb/slcnand/tc58dvm72a.c b/src/flashdb/slcnand/tc58dvm72a.c
index a45c872..e1a9bcd 100644
--- a/src/flashdb/slcnand/tc58dvm72a.c
+++ b/src/flashdb/slcnand/tc58dvm72a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58dvm72a.h>
diff --git a/src/flashdb/slcnand/tc58dvm82a.c b/src/flashdb/slcnand/tc58dvm82a.c
index 23264cc..490fef9 100644
--- a/src/flashdb/slcnand/tc58dvm82a.c
+++ b/src/flashdb/slcnand/tc58dvm82a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Charles Chiou] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58dvm82a.h>
diff --git a/src/flashdb/slcnand/tc58dvm92a.c b/src/flashdb/slcnand/tc58dvm92a.c
index 9abe98a..77cfe90 100644
--- a/src/flashdb/slcnand/tc58dvm92a.c
+++ b/src/flashdb/slcnand/tc58dvm92a.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58dvm92a.h>
diff --git a/src/flashdb/slcnand/tc58nvg0s3c.c b/src/flashdb/slcnand/tc58nvg0s3c.c
index 3984599..d246e48 100644
--- a/src/flashdb/slcnand/tc58nvg0s3c.c
+++ b/src/flashdb/slcnand/tc58nvg0s3c.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58nvg0s3c.h>
diff --git a/src/flashdb/slcnand/tc58nvg0s3e.c b/src/flashdb/slcnand/tc58nvg0s3e.c
index 5ff26a1..667cb74 100644
--- a/src/flashdb/slcnand/tc58nvg0s3e.c
+++ b/src/flashdb/slcnand/tc58nvg0s3e.c
@@ -4,12 +4,30 @@
  * History:
  *    2007/10/03 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58nvg0s3e.h>
diff --git a/src/flashdb/slcnand/tc58nvg0s3h.c b/src/flashdb/slcnand/tc58nvg0s3h.c
index 14d005b..16cea85 100644
--- a/src/flashdb/slcnand/tc58nvg0s3h.c
+++ b/src/flashdb/slcnand/tc58nvg0s3h.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/02/21 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58nvg0s3h.h>
diff --git a/src/flashdb/slcnand/tc58nvg1s3e.c b/src/flashdb/slcnand/tc58nvg1s3e.c
index 2bd9f95..c95416b 100644
--- a/src/flashdb/slcnand/tc58nvg1s3e.c
+++ b/src/flashdb/slcnand/tc58nvg1s3e.c
@@ -4,12 +4,30 @@
  * History:
  *    2010/05/18 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2004-2007, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58nvg1s3e.h>
diff --git a/src/flashdb/slcnand/tc58nvg1s3h.c b/src/flashdb/slcnand/tc58nvg1s3h.c
index 99066ab..1937ee0 100644
--- a/src/flashdb/slcnand/tc58nvg1s3h.c
+++ b/src/flashdb/slcnand/tc58nvg1s3h.c
@@ -4,12 +4,30 @@
  * History:
  *    2015/03/24 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58nvg1s3h.h>
diff --git a/src/flashdb/slcnand/tc58nvg2s3e.c b/src/flashdb/slcnand/tc58nvg2s3e.c
index d87863c..918d244 100644
--- a/src/flashdb/slcnand/tc58nvg2s3e.c
+++ b/src/flashdb/slcnand/tc58nvg2s3e.c
@@ -4,12 +4,30 @@
  * History:
  *    2010/05/20 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2010-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58nvg2s3e.h>
diff --git a/src/flashdb/slcnand/tc58nvm9s3c.c b/src/flashdb/slcnand/tc58nvm9s3c.c
index a096dae..5efef7a 100644
--- a/src/flashdb/slcnand/tc58nvm9s3c.c
+++ b/src/flashdb/slcnand/tc58nvm9s3c.c
@@ -4,12 +4,30 @@
  * History:
  *    2010/05/17 - [Evan(Kuan-Fu) Chen] created file
  *
- * Copyright (C) 2010-2014, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/tc58nvm9s3c.h>
diff --git a/src/flashdb/slcnand/w29n01gvscaa.c b/src/flashdb/slcnand/w29n01gvscaa.c
index 00838d6..b2b8b96 100644
--- a/src/flashdb/slcnand/w29n01gvscaa.c
+++ b/src/flashdb/slcnand/w29n01gvscaa.c
@@ -4,12 +4,30 @@
  * History:
  *    2014/03/27 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/w29n01gvscaa.h>
diff --git a/src/flashdb/slcnand/w29n01hvxinf.c b/src/flashdb/slcnand/w29n01hvxinf.c
new file mode 100644
index 0000000..28fd858
--- /dev/null
+++ b/src/flashdb/slcnand/w29n01hvxinf.c
@@ -0,0 +1,40 @@
+/**
+ * system/src/flashdb/slcnandl/w29n01hvxinf.c
+ *
+ * History:
+ *    2016/04/22 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <flash/slcnand/w29n01hvxinf.h>
+#include <flash/nanddb.h>
+
+#ifndef NAND_DEVICES
+#define NAND_DEVICES	1
+#endif
+
+IMPLEMENT_NAND_DB_DEV(w29n01hvxinf);
diff --git a/src/flashdb/slcnand/w29n02gvsiaa.c b/src/flashdb/slcnand/w29n02gvsiaa.c
index ffd9b06..ede3162 100644
--- a/src/flashdb/slcnand/w29n02gvsiaa.c
+++ b/src/flashdb/slcnand/w29n02gvsiaa.c
@@ -4,12 +4,30 @@
  * History:
  *    2015/03/13 - [Ken He] created file
  *
- * Copyright (C) 2014-2016, Ambarella, Inc.
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
  */
 
 #include <flash/slcnand/w29n02gvsiaa.h>
diff --git a/src/flashdb/spinand/gd5f1gq4uc.c b/src/flashdb/spinand/gd5f1gq4uc.c
new file mode 100644
index 0000000..15b89eb
--- /dev/null
+++ b/src/flashdb/spinand/gd5f1gq4uc.c
@@ -0,0 +1,45 @@
+/**
+ * /src/flashdb/spinand/gd5f1gq4uc.c
+ *
+ * History:
+ *    2015/10/26 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <bldfunc.h>
+#include <ambhw/spinor.h>
+#include <flash/spinand/gd5f1gq4uc.h>
+
+
+int spinand_flash_reset(void)
+{
+	spinor_send_alone_cmd(0xFF);
+	spinand_wait_till_ready();
+
+	return 0;
+}
+
+
diff --git a/src/flashdb/spinand/gd5f2gq4uc.c b/src/flashdb/spinand/gd5f2gq4uc.c
new file mode 100644
index 0000000..740044a
--- /dev/null
+++ b/src/flashdb/spinand/gd5f2gq4uc.c
@@ -0,0 +1,45 @@
+/**
+ * /src/flashdb/spinand/gd5f2gq4uc.c
+ *
+ * History:
+ *    2015/10/26 - [Ken He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <bldfunc.h>
+#include <ambhw/spinor.h>
+#include <flash/spinand/gd5f2gq4uc.h>
+
+
+int spinand_flash_reset(void)
+{
+	spinor_send_alone_cmd(0xFF);
+	spinand_wait_till_ready();
+
+	return 0;
+}
+
+
diff --git a/src/flashdb/spinand/make.inc b/src/flashdb/spinand/make.inc
new file mode 100644
index 0000000..3663299
--- /dev/null
+++ b/src/flashdb/spinand/make.inc
@@ -0,0 +1,36 @@
+##
+## system/src/flashdb/spinand/make.inc
+##
+## History:
+##    2015/10/26 - [Ken He] created file
+##
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+
+SPINANDDB_SRCS = \
+	$(TOP)/src/flashdb/spinand/spinand_flash.c
+SPINANDDB_OBJS = \
+	spinand_flash.o
+
diff --git a/src/flashdb/spinand/spinand_flash.c b/src/flashdb/spinand/spinand_flash.c
new file mode 100644
index 0000000..63dc6d1
--- /dev/null
+++ b/src/flashdb/spinand/spinand_flash.c
@@ -0,0 +1,40 @@
+/**
+ * /src/flashdb/spinand/spinand_flash.c
+ *
+ * History:
+ *    2015/10/26 - [Cao Rongrong] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <bldfunc.h>
+#include <ambhw/spinor.h>
+
+#if defined(CONFIG_SPI_NAND_GD5F2GQ4UC)
+#include "gd5f2gq4uc.c"
+#elif defined(CONFIG_SPI_NAND_GD5F1GQ4UC)
+#include "gd5f1gq4uc.c"
+#endif
+
diff --git a/sv/s2l/bin/lnx64/amba_usb_s2l.ads b/sv/s2l/bin/lnx64/amba_usb_s2l.ads
new file mode 100644
index 0000000..15e9ffb
--- /dev/null
+++ b/sv/s2l/bin/lnx64/amba_usb_s2l.ads
@@ -0,0 +1,49 @@
+# AMBAUSB: Init DRAM controller...
+
+write 0xec1700dc,0x36100000
+write 0xec170110,0x3f770000
+write 0xec170114,0x00068300
+write 0xec1700dc,0x36100001
+write 0xec1700dc,0x36100000
+write 0xec170090,0x00260020
+write 0xec170094,0x00260020
+write 0xec1700f0,0x00260020
+write 0xec1700f4,0x00260020
+write 0xec17023c,0x00008001
+write 0xec170240,0x00008001
+write 0xec170244,0x00008001
+write 0xec170248,0x00008001
+write 0xec170158,0x12e50000
+usleep 1000000
+write 0xdffe0804,0x082708b8
+write 0xdffe0808,0x21679dde
+write 0xdffe080c,0x67dd54cb
+write 0xdffe0810,0x70447141
+write 0xdffe0820,0x000000a0
+write 0xdffe0828,0x00000060
+write 0xdffe0824,0x00020034
+write 0xdffe0800,0x00000008
+usleep 1000000
+write 0xdffe0800,0x0000000c
+usleep 1000000
+write 0xdffe0818,0x01020010
+poll 0xdffe0818,0x80000000,0x00000000
+write 0xdffe0818,0x01030000
+poll 0xdffe0818,0x80000000,0x00000000
+write 0xdffe0818,0x01010040
+poll 0xdffe0818,0x80000000,0x00000000
+write 0xdffe0818,0x01001d51
+poll 0xdffe0818,0x80000000,0x00000000
+write 0xdffe0814,0x00000010
+poll 0xdffe0814,0x00000010,0x00000000
+write 0xdffe0814,0x00000008
+poll 0xdffe0814,0x00000008,0x00000000
+write 0xdffe0800,0x0000000e
+write 0xdffe0814,0x00000020
+poll 0xdffe0814,0x00000020,0x00000000
+write 0xdffe0814,0x00000004
+poll 0xdffe0814,0x00000004,0x00000000
+write 0xdffe0820,0x00000040
+write 0xdffe0828,0x00000026
+write 0xdffe0800,0x0000000f
+#DRAM controller is initialized...
diff --git a/sv/s2l/image/amboot_bst_ddr3.map b/sv/s2l/image/amboot_bst_ddr3.map
index dc012fa..41914bb 100644
--- a/sv/s2l/image/amboot_bst_ddr3.map
+++ b/sv/s2l/image/amboot_bst_ddr3.map
@@ -1,47 +1,47 @@
 00080000 A DRAM_BST_START
-000804d0 T __postreloc_ram_start
-000804d0 T start_post_relocate
-000804dc T nand_load_bld
-00080520 t nand_jump_to_bld
-00080530 t do_nand_bld
-00080544 t nand_512
-00080568 t nand_2k
-00080580 t done_size_setup
-00080598 t set_6bit_ecc
-000805b0 t set_8bit_ecc
-000805c4 t done_ecc
-000805cc t start_load_bld
-000805f8 t nand_load_block_loop
-00080608 t start_loading_good_block
-00080620 t nand_load_next_block
-00080628 t nand_check_block
-00080630 t nand_check_block_loop
-0008065c t nand_load_block
-00080688 t _controlreg_main_area
-00080690 t _controlreg_spare_area
-00080698 t _done_controlreg
-000806d0 t _dma_fifo_dsm_done
-000806e8 t set_main_dma_burst
-000806f4 t set_spare_dma_burst
-000806fc t done_set_dma_burst
-00080700 t flash_no_fixup
-00080710 t set_main_fiodma_burst
-0008071c t set_spare_fiodma_burst
-00080724 t set_fiodma_dsm_burst
-0008073c t done_set_fiodma_burst
-00080740 t _wait_nand_cmd_done
-00080750 t _wait_nand_fiodma_done
-0008076c t _wait_nand_dma_done
-00080798 t eot_nand
-0008079c t RT_NAND_BYTES_PER_BLOCK
-000807a0 t RT_NAND_CONTROL
-000807a4 t RT_FIO_DSM_BUFFER
-000807a8 t NAND_BB_MARKER_OFFSET_RAM
-000807ac t FIO_CTR_MAIN
-000807b0 t DMA_CHANX_CTR
-000807b4 t FIO_DMACTR
-000807b8 t RT_NAND_ECC_BITS
-000807e0 T __postreloc_ram_end
+000804e4 T __postreloc_ram_start
+000804e4 T start_post_relocate
+000804f0 T nand_load_bld
+00080534 t nand_jump_to_bld
+00080544 t do_nand_bld
+00080558 t nand_512
+0008057c t nand_2k
+00080594 t done_size_setup
+000805ac t set_6bit_ecc
+000805c4 t set_8bit_ecc
+000805d8 t done_ecc
+000805e0 t start_load_bld
+0008060c t nand_load_block_loop
+0008061c t start_loading_good_block
+00080634 t nand_load_next_block
+0008063c t nand_check_block
+0008064c t nand_check_block_loop
+0008067c t nand_load_block
+000806a8 t _controlreg_main_area
+000806b0 t _controlreg_spare_area
+000806b8 t _done_controlreg
+000806f0 t _dma_fifo_dsm_done
+00080708 t set_main_dma_burst
+00080714 t set_spare_dma_burst
+0008071c t done_set_dma_burst
+00080720 t flash_no_fixup
+00080730 t set_main_fiodma_burst
+0008073c t set_spare_fiodma_burst
+00080744 t set_fiodma_dsm_burst
+0008075c t done_set_fiodma_burst
+00080760 t _wait_nand_cmd_done
+00080770 t _wait_nand_fiodma_done
+0008078c t _wait_nand_dma_done
+000807b8 t eot_nand
+000807bc t RT_NAND_BYTES_PER_BLOCK
+000807c0 t RT_NAND_CONTROL
+000807c4 t RT_FIO_DSM_BUFFER
+000807c8 t NAND_BB_MARKER_OFFSET_RAM
+000807cc t FIO_CTR_MAIN
+000807d0 t DMA_CHANX_CTR
+000807d4 t FIO_DMACTR
+000807d8 t RT_NAND_ECC_BITS
+00080800 T __postreloc_ram_end
 00090000 A DRAM_TO_BOOT
 ffff0000 A BOOT_BST_START
 ffff0004 t chipname
@@ -100,27 +100,29 @@ ffff00cc D pll_idsp_ctrl_param
 ffff00d0 D pll_cortex_ctrl_param
 ffff00d4 D pll_cortex_frac_param
 ffff00d8 D scaler_misc
-ffff00dc d end_dram_table
-ffff00dc T memsetup
-ffff00dc D __table_end
-ffff00e2 t self_refresh_check
-ffff010e t disconnect_dram_reset
-ffff0128 t set_rct_pll
-ffff0128 t sr_check_exit
-ffff017e t setup_dram_dll
-ffff0220 t issue_zqcl_cmd
-ffff0256 t set_dram_mode
-ffff0262 t set_init_ctl
-ffff02b4 T rct_delay_proc
-ffff02ba t rct_timer_read
-ffff02c2 T loop_delay_proc
-ffff02ca T rct_pll_set_value
-ffff02fc T start
-ffff03b8 t relocate
-ffff03c8 t relocate_2ndstage
-ffff03e4 t dram_arbiter_cfg
-ffff0444 t copy_loop
-ffff0498 T self_refresh_jump
-ffff04c8 t sr_jump_exit
-ffff04d0 A __postreloc_start
-ffff07e0 A __postreloc_end
+ffff00dc D mcu_notify_gpio
+ffff00e0 D emmc_boot_param
+ffff00e4 d end_dram_table
+ffff00e4 T memsetup
+ffff00e4 D __table_end
+ffff00ea t self_refresh_check
+ffff0122 t disconnect_dram_reset
+ffff013c t set_rct_pll
+ffff013c t sr_check_exit
+ffff0192 t setup_dram_dll
+ffff0234 t issue_zqcl_cmd
+ffff026a t set_dram_mode
+ffff0276 t set_init_ctl
+ffff02c8 T rct_delay_proc
+ffff02ce t rct_timer_read
+ffff02d6 T loop_delay_proc
+ffff02de T rct_pll_set_value
+ffff0310 T start
+ffff03cc t relocate
+ffff03dc t relocate_2ndstage
+ffff03f8 t dram_arbiter_cfg
+ffff0458 t copy_loop
+ffff04ac T self_refresh_jump
+ffff04dc t sr_jump_exit
+ffff04e4 A __postreloc_start
+ffff0800 A __postreloc_end
diff --git a/sv/s2l/image/amboot_bst_lpddr3.map b/sv/s2l/image/amboot_bst_lpddr3.map
index 212ca48..0d14b13 100644
--- a/sv/s2l/image/amboot_bst_lpddr3.map
+++ b/sv/s2l/image/amboot_bst_lpddr3.map
@@ -1,47 +1,47 @@
 00080000 A DRAM_BST_START
-00080528 T __postreloc_ram_start
-00080528 T start_post_relocate
-00080534 T nand_load_bld
-00080578 t nand_jump_to_bld
-00080588 t do_nand_bld
-0008059c t nand_512
-000805c0 t nand_2k
-000805d8 t done_size_setup
-000805f0 t set_6bit_ecc
-00080608 t set_8bit_ecc
-0008061c t done_ecc
-00080624 t start_load_bld
-00080650 t nand_load_block_loop
-00080660 t start_loading_good_block
-00080678 t nand_load_next_block
-00080680 t nand_check_block
-00080688 t nand_check_block_loop
-000806b4 t nand_load_block
-000806e0 t _controlreg_main_area
-000806e8 t _controlreg_spare_area
-000806f0 t _done_controlreg
-00080728 t _dma_fifo_dsm_done
-00080740 t set_main_dma_burst
-0008074c t set_spare_dma_burst
-00080754 t done_set_dma_burst
-00080758 t flash_no_fixup
-00080768 t set_main_fiodma_burst
-00080774 t set_spare_fiodma_burst
-0008077c t set_fiodma_dsm_burst
-00080794 t done_set_fiodma_burst
-00080798 t _wait_nand_cmd_done
-000807a8 t _wait_nand_fiodma_done
-000807c4 t _wait_nand_dma_done
-000807f0 t eot_nand
-000807f4 t RT_NAND_BYTES_PER_BLOCK
-000807f8 t RT_NAND_CONTROL
-000807fc t RT_FIO_DSM_BUFFER
-00080800 t NAND_BB_MARKER_OFFSET_RAM
-00080804 t FIO_CTR_MAIN
-00080808 t DMA_CHANX_CTR
-0008080c t FIO_DMACTR
-00080810 t RT_NAND_ECC_BITS
-00080838 T __postreloc_ram_end
+00080530 T __postreloc_ram_start
+00080530 T start_post_relocate
+0008053c T nand_load_bld
+00080580 t nand_jump_to_bld
+00080590 t do_nand_bld
+000805a4 t nand_512
+000805c8 t nand_2k
+000805e0 t done_size_setup
+000805f8 t set_6bit_ecc
+00080610 t set_8bit_ecc
+00080624 t done_ecc
+0008062c t start_load_bld
+00080658 t nand_load_block_loop
+00080668 t start_loading_good_block
+00080680 t nand_load_next_block
+00080688 t nand_check_block
+00080698 t nand_check_block_loop
+000806c8 t nand_load_block
+000806f4 t _controlreg_main_area
+000806fc t _controlreg_spare_area
+00080704 t _done_controlreg
+0008073c t _dma_fifo_dsm_done
+00080754 t set_main_dma_burst
+00080760 t set_spare_dma_burst
+00080768 t done_set_dma_burst
+0008076c t flash_no_fixup
+0008077c t set_main_fiodma_burst
+00080788 t set_spare_fiodma_burst
+00080790 t set_fiodma_dsm_burst
+000807a8 t done_set_fiodma_burst
+000807ac t _wait_nand_cmd_done
+000807bc t _wait_nand_fiodma_done
+000807d8 t _wait_nand_dma_done
+00080804 t eot_nand
+00080808 t RT_NAND_BYTES_PER_BLOCK
+0008080c t RT_NAND_CONTROL
+00080810 t RT_FIO_DSM_BUFFER
+00080814 t NAND_BB_MARKER_OFFSET_RAM
+00080818 t FIO_CTR_MAIN
+0008081c t DMA_CHANX_CTR
+00080820 t FIO_DMACTR
+00080824 t RT_NAND_ECC_BITS
+0008084c T __postreloc_ram_end
 00090000 A DRAM_TO_BOOT
 ffff0000 A BOOT_BST_START
 ffff0004 t chipname
@@ -100,27 +100,28 @@ ffff00cc D pll_idsp_ctrl_param
 ffff00d0 D pll_cortex_ctrl_param
 ffff00d4 D pll_cortex_frac_param
 ffff00d8 D scaler_misc
-ffff00dc d end_dram_table
-ffff00dc T memsetup
-ffff00dc D __table_end
-ffff00e2 t self_refresh_check
-ffff010e t disconnect_dram_reset
-ffff0128 t set_rct_pll
-ffff0128 t sr_check_exit
-ffff017e t setup_dram_dll
-ffff028c t LOOP_MR0
-ffff0298 t set_dram_mode
-ffff02a4 t set_init_ctl
-ffff030c T rct_delay_proc
-ffff0312 t rct_timer_read
-ffff031a T loop_delay_proc
-ffff0322 T rct_pll_set_value
-ffff0354 T start
-ffff0410 t relocate
-ffff0420 t relocate_2ndstage
-ffff043c t dram_arbiter_cfg
-ffff049c t copy_loop
-ffff04f0 T self_refresh_jump
-ffff0520 t sr_jump_exit
-ffff0528 A __postreloc_start
-ffff0838 A __postreloc_end
+ffff00dc D mcu_notify_gpio
+ffff00e0 D emmc_boot_param
+ffff00e4 d end_dram_table
+ffff00e4 T memsetup
+ffff00e4 D __table_end
+ffff00ea t self_refresh_check
+ffff0122 t disconnect_dram_reset
+ffff013c t set_rct_pll
+ffff013c t sr_check_exit
+ffff0192 t setup_dram_dll
+ffff02a6 t set_dram_mode
+ffff02b2 t set_init_ctl
+ffff0314 T rct_delay_proc
+ffff031a t rct_timer_read
+ffff0322 T loop_delay_proc
+ffff032a T rct_pll_set_value
+ffff035c T start
+ffff0418 t relocate
+ffff0428 t relocate_2ndstage
+ffff0444 t dram_arbiter_cfg
+ffff04a4 t copy_loop
+ffff04f8 T self_refresh_jump
+ffff0528 t sr_jump_exit
+ffff0530 A __postreloc_start
+ffff084c A __postreloc_end
diff --git a/sv/s2l/image/amboot_emmc_ddr3.map b/sv/s2l/image/amboot_emmc_ddr3.map
index 05c6f82..f500a30 100644
--- a/sv/s2l/image/amboot_emmc_ddr3.map
+++ b/sv/s2l/image/amboot_emmc_ddr3.map
@@ -1,30 +1,31 @@
 00080000 A DRAM_BST_START
-000804d0 T __postreloc_ram_start
-000804d0 T start_post_relocate
-000804dc T emmc_load_bld
-000804e8 t emmc_init_wait_reset_done
-000804fa t emmc_init_wait_clock_stable
-00080522 t emmc_init_setup_mmc_card
-00080558 t emmc_test_poc
-0008056e t emmc_test_hs_done
-00080582 t emmc_bus_1bit
-0008058a t emmc_bus_4bit
-0008059a t emmc_bus_8bit
-000805a8 t emmc_setup_card_done
-000805b6 t emmc_wait_clk_off
-000805bc t emmc_wait_clock_stable
-000805d0 t emmc_boot
-000805e6 t emmc_boot_wait_dma_done
-000805fa t sdmmc_command
-00080600 t sdmmc_command_wait_complete
-00080610 t emmc_read_sector
-00080612 t emmc_read_sector_wait_cmdline_ready
-0008061c t emmc_read_sector_wait_data_line_ready
-0008063a t emmc_read_sector_wait_cmd_complete
-0008064e t emmc_read_sector_wait_transfer_complete
-00080662 t emmc_boot_fail
-00080664 t RT_SD_CLOCK_CONTROL
-000806c0 T __postreloc_ram_end
+000804e4 T __postreloc_ram_start
+000804e4 T start_post_relocate
+000804f0 T emmc_load_bld
+000804fc t emmc_init_wait_reset_done
+0008050e t emmc_init_wait_clock_stable
+00080536 t emmc_init_setup_mmc_card
+0008056c t emmc_test_poc
+00080582 t emmc_test_hs_done
+00080596 t emmc_bus_1bit
+0008059e t emmc_bus_4bit
+000805ae t emmc_bus_8bit
+000805bc t emmc_setup_card_done
+000805ca t emmc_wait_clk_off
+000805d0 t emmc_wait_clock_stable
+000805e4 t emmc_switch_partition
+000805ee t emmc_boot
+00080604 t emmc_boot_wait_dma_done
+00080618 t sdmmc_command
+0008061e t sdmmc_command_wait_complete
+0008062e t emmc_read_sector
+00080630 t emmc_read_sector_wait_cmdline_ready
+0008063a t emmc_read_sector_wait_data_line_ready
+00080658 t emmc_read_sector_wait_cmd_complete
+0008066c t emmc_read_sector_wait_transfer_complete
+00080680 t emmc_boot_fail
+00080684 t RT_SD_CLOCK_CONTROL
+000806e4 T __postreloc_ram_end
 00090000 A DRAM_TO_BOOT
 ffff0000 A BOOT_BST_START
 ffff0004 t chipname
@@ -83,27 +84,29 @@ ffff00cc D pll_idsp_ctrl_param
 ffff00d0 D pll_cortex_ctrl_param
 ffff00d4 D pll_cortex_frac_param
 ffff00d8 D scaler_misc
-ffff00dc d end_dram_table
-ffff00dc T memsetup
-ffff00dc D __table_end
-ffff00e2 t self_refresh_check
-ffff010e t disconnect_dram_reset
-ffff0128 t set_rct_pll
-ffff0128 t sr_check_exit
-ffff017e t setup_dram_dll
-ffff0220 t issue_zqcl_cmd
-ffff0256 t set_dram_mode
-ffff0262 t set_init_ctl
-ffff02b4 T rct_delay_proc
-ffff02ba t rct_timer_read
-ffff02c2 T loop_delay_proc
-ffff02ca T rct_pll_set_value
-ffff02fc T start
-ffff03b8 t relocate
-ffff03c8 t relocate_2ndstage
-ffff03e4 t dram_arbiter_cfg
-ffff0444 t copy_loop
-ffff0498 T self_refresh_jump
-ffff04c8 t sr_jump_exit
-ffff04d0 A __postreloc_start
-ffff06c0 A __postreloc_end
+ffff00dc D mcu_notify_gpio
+ffff00e0 D emmc_boot_param
+ffff00e4 d end_dram_table
+ffff00e4 T memsetup
+ffff00e4 D __table_end
+ffff00ea t self_refresh_check
+ffff0122 t disconnect_dram_reset
+ffff013c t set_rct_pll
+ffff013c t sr_check_exit
+ffff0192 t setup_dram_dll
+ffff0234 t issue_zqcl_cmd
+ffff026a t set_dram_mode
+ffff0276 t set_init_ctl
+ffff02c8 T rct_delay_proc
+ffff02ce t rct_timer_read
+ffff02d6 T loop_delay_proc
+ffff02de T rct_pll_set_value
+ffff0310 T start
+ffff03cc t relocate
+ffff03dc t relocate_2ndstage
+ffff03f8 t dram_arbiter_cfg
+ffff0458 t copy_loop
+ffff04ac T self_refresh_jump
+ffff04dc t sr_jump_exit
+ffff04e4 A __postreloc_start
+ffff06e4 A __postreloc_end
diff --git a/sv/s2l/image/amboot_emmc_lpddr3.map b/sv/s2l/image/amboot_emmc_lpddr3.map
index 91f3c75..19bca81 100644
--- a/sv/s2l/image/amboot_emmc_lpddr3.map
+++ b/sv/s2l/image/amboot_emmc_lpddr3.map
@@ -1,30 +1,31 @@
 00080000 A DRAM_BST_START
-00080528 T __postreloc_ram_start
-00080528 T start_post_relocate
-00080534 T emmc_load_bld
-00080540 t emmc_init_wait_reset_done
-00080552 t emmc_init_wait_clock_stable
-0008057a t emmc_init_setup_mmc_card
-000805b0 t emmc_test_poc
-000805c6 t emmc_test_hs_done
-000805da t emmc_bus_1bit
-000805e2 t emmc_bus_4bit
-000805f2 t emmc_bus_8bit
-00080600 t emmc_setup_card_done
-0008060e t emmc_wait_clk_off
-00080614 t emmc_wait_clock_stable
-00080628 t emmc_boot
-0008063e t emmc_boot_wait_dma_done
-00080652 t sdmmc_command
-00080658 t sdmmc_command_wait_complete
-00080668 t emmc_read_sector
-0008066a t emmc_read_sector_wait_cmdline_ready
-00080674 t emmc_read_sector_wait_data_line_ready
-00080692 t emmc_read_sector_wait_cmd_complete
-000806a6 t emmc_read_sector_wait_transfer_complete
-000806ba t emmc_boot_fail
-000806bc t RT_SD_CLOCK_CONTROL
-00080718 T __postreloc_ram_end
+00080530 T __postreloc_ram_start
+00080530 T start_post_relocate
+0008053c T emmc_load_bld
+00080548 t emmc_init_wait_reset_done
+0008055a t emmc_init_wait_clock_stable
+00080582 t emmc_init_setup_mmc_card
+000805b8 t emmc_test_poc
+000805ce t emmc_test_hs_done
+000805e2 t emmc_bus_1bit
+000805ea t emmc_bus_4bit
+000805fa t emmc_bus_8bit
+00080608 t emmc_setup_card_done
+00080616 t emmc_wait_clk_off
+0008061c t emmc_wait_clock_stable
+00080630 t emmc_switch_partition
+0008063a t emmc_boot
+00080650 t emmc_boot_wait_dma_done
+00080664 t sdmmc_command
+0008066a t sdmmc_command_wait_complete
+0008067a t emmc_read_sector
+0008067c t emmc_read_sector_wait_cmdline_ready
+00080686 t emmc_read_sector_wait_data_line_ready
+000806a4 t emmc_read_sector_wait_cmd_complete
+000806b8 t emmc_read_sector_wait_transfer_complete
+000806cc t emmc_boot_fail
+000806d0 t RT_SD_CLOCK_CONTROL
+00080730 T __postreloc_ram_end
 00090000 A DRAM_TO_BOOT
 ffff0000 A BOOT_BST_START
 ffff0004 t chipname
@@ -83,27 +84,28 @@ ffff00cc D pll_idsp_ctrl_param
 ffff00d0 D pll_cortex_ctrl_param
 ffff00d4 D pll_cortex_frac_param
 ffff00d8 D scaler_misc
-ffff00dc d end_dram_table
-ffff00dc T memsetup
-ffff00dc D __table_end
-ffff00e2 t self_refresh_check
-ffff010e t disconnect_dram_reset
-ffff0128 t set_rct_pll
-ffff0128 t sr_check_exit
-ffff017e t setup_dram_dll
-ffff028c t LOOP_MR0
-ffff0298 t set_dram_mode
-ffff02a4 t set_init_ctl
-ffff030c T rct_delay_proc
-ffff0312 t rct_timer_read
-ffff031a T loop_delay_proc
-ffff0322 T rct_pll_set_value
-ffff0354 T start
-ffff0410 t relocate
-ffff0420 t relocate_2ndstage
-ffff043c t dram_arbiter_cfg
-ffff049c t copy_loop
-ffff04f0 T self_refresh_jump
-ffff0520 t sr_jump_exit
-ffff0528 A __postreloc_start
-ffff0718 A __postreloc_end
+ffff00dc D mcu_notify_gpio
+ffff00e0 D emmc_boot_param
+ffff00e4 d end_dram_table
+ffff00e4 T memsetup
+ffff00e4 D __table_end
+ffff00ea t self_refresh_check
+ffff0122 t disconnect_dram_reset
+ffff013c t set_rct_pll
+ffff013c t sr_check_exit
+ffff0192 t setup_dram_dll
+ffff02a6 t set_dram_mode
+ffff02b2 t set_init_ctl
+ffff0314 T rct_delay_proc
+ffff031a t rct_timer_read
+ffff0322 T loop_delay_proc
+ffff032a T rct_pll_set_value
+ffff035c T start
+ffff0418 t relocate
+ffff0428 t relocate_2ndstage
+ffff0444 t dram_arbiter_cfg
+ffff04a4 t copy_loop
+ffff04f8 T self_refresh_jump
+ffff0528 t sr_jump_exit
+ffff0530 A __postreloc_start
+ffff0730 A __postreloc_end
diff --git a/sv/s2l/image/amboot_spinand_ddr3.map b/sv/s2l/image/amboot_spinand_ddr3.map
new file mode 100644
index 0000000..7bd30ad
--- /dev/null
+++ b/sv/s2l/image/amboot_spinand_ddr3.map
@@ -0,0 +1,105 @@
+00080000 A DRAM_BST_START
+00080464 T __postreloc_ram_start
+00080464 T start_post_relocate
+00080470 T spinand_load_bld
+00080478 t spinand_jump_to_bld
+00080488 t do_spinand_bld
+000804cc t spinand_load_block_loop
+000804e0 t start_loading_good_block
+000804f4 t spinand_check_block
+00080544 t spinand_disable_ecc
+00080578 t spinand_enable_ecc
+000805ac t spinand_load_block
+000805b4 t spinand_read_pages
+00080600 t check_spinand_status
+00080614 t wait_ready
+0008067c t spinand_send_cmd
+00080688 t spinand_set_cmd
+000806d4 t spinand_read
+00080714 t spinand_read_page
+00080718 t spinand_read_loop
+00080754 T __postreloc_ram_end
+20050000 A DRAM_TO_BOOT
+e0030000 A BOOT_BST_START
+e0030004 t chipname
+e003000c t version
+e0030010 d dram_delay1_param
+e0030010 d dram_params_table
+e0030014 d dram_cfg_param
+e0030018 d dram_timing1_param
+e003001c d dram_timing2_param
+e0030020 d dram_timing3_param
+e0030024 d por_delay_param
+e0030028 d dram_mode_reg0_param
+e0030028 d modereg_reset_lpddr2_param
+e003002c d dram_mode_reg1_param
+e0030030 d dram_mode_reg2_param
+e0030034 d dram_mode_reg3_param
+e0030034 d reset_delay_lpddr2_param
+e0030038 d dram_self_ref_param
+e003003c d dram_dqs_sync
+e0030040 d dram_pad_term
+e0030044 d dram_zq_calibration
+e0030048 d dram_delay2_param
+e003004c d pll_ddr_ctrl_param
+e0030050 d pll_ddr_ctrl2_param
+e0030054 d pll_ddr_ctrl3_param
+e0030058 d dram_dll0_param
+e003005c d dram_dll1_param
+e0030060 d dram_dll2_param
+e0030064 d dram_dll3_param
+e0030068 d dram_ctrl_sel_0_param
+e003006c d dram_ctrl_sel_1_param
+e0030070 d dram_ctrl_sel_2_param
+e0030074 d dram_ctrl_sel_3_param
+e0030078 d dram_ctrl_sel_misc_param
+e003007c d dram_byte_map
+e0030080 d dram_dqs_sync_prertt
+e0030084 d dram_zq_calibration_prertt
+e0030088 d dram_delay3_param
+e003008c d dram_rsvd_space
+e0030090 d pll_program_delay
+e0030094 d dll_program_delay
+e0030098 d cg_ddr_init_param
+e003009c d cg_ddr_normal_param
+e00300a0 d dll_reset_delay
+e00300a4 D amboot_bld_ram_start
+e00300a8 D amboot_bld_media_start
+e00300ac D amboot_bld_media_size
+e00300b0 D nand_flash_timing0
+e00300b4 D nand_flash_timing1
+e00300b8 D nand_flash_timing2
+e00300bc D nand_flash_timing3
+e00300c0 D nand_flash_timing4
+e00300c4 D nand_flash_timing5
+e00300c8 D pll_core_ctrl_param
+e00300cc D pll_idsp_ctrl_param
+e00300d0 D pll_cortex_ctrl_param
+e00300d4 D pll_cortex_frac_param
+e00300d8 D scaler_misc
+e00300dc D mcu_notify_gpio
+e00300e0 D emmc_boot_param
+e00300e4 d end_dram_table
+e00300e4 T memsetup
+e00300e4 D __table_end
+e00300ea t self_refresh_check
+e0030122 t disconnect_dram_reset
+e003013c t set_rct_pll
+e003013c t sr_check_exit
+e0030192 t setup_dram_dll
+e0030234 t issue_zqcl_cmd
+e003026a t set_dram_mode
+e0030276 t set_init_ctl
+e00302c8 T rct_delay_proc
+e00302ce t rct_timer_read
+e00302d6 T loop_delay_proc
+e00302de T rct_pll_set_value
+e0030310 T start
+e003034c t relocate
+e003035c t relocate_2ndstage
+e0030378 t dram_arbiter_cfg
+e00303d8 t copy_loop
+e003042c T self_refresh_jump
+e003045c t sr_jump_exit
+e0030464 A __postreloc_start
+e0030754 A __postreloc_end
diff --git a/sv/s2l/image/amboot_spinand_lpddr3.map b/sv/s2l/image/amboot_spinand_lpddr3.map
new file mode 100644
index 0000000..2aab5bd
--- /dev/null
+++ b/sv/s2l/image/amboot_spinand_lpddr3.map
@@ -0,0 +1,104 @@
+00080000 A DRAM_BST_START
+000804b0 T __postreloc_ram_start
+000804b0 T start_post_relocate
+000804bc T spinand_load_bld
+000804c4 t spinand_jump_to_bld
+000804d4 t do_spinand_bld
+00080518 t spinand_load_block_loop
+0008052c t start_loading_good_block
+00080540 t spinand_check_block
+00080590 t spinand_disable_ecc
+000805c4 t spinand_enable_ecc
+000805f8 t spinand_load_block
+00080600 t spinand_read_pages
+0008064c t check_spinand_status
+00080660 t wait_ready
+000806c8 t spinand_send_cmd
+000806d4 t spinand_set_cmd
+00080720 t spinand_read
+00080760 t spinand_read_page
+00080764 t spinand_read_loop
+000807a0 T __postreloc_ram_end
+20050000 A DRAM_TO_BOOT
+e0030000 A BOOT_BST_START
+e0030004 t chipname
+e003000c t version
+e0030010 d dram_delay1_param
+e0030010 d dram_params_table
+e0030014 d dram_cfg_param
+e0030018 d dram_timing1_param
+e003001c d dram_timing2_param
+e0030020 d dram_timing3_param
+e0030024 d por_delay_param
+e0030028 d dram_mode_reg0_param
+e0030028 d modereg_reset_lpddr2_param
+e003002c d dram_mode_reg1_param
+e0030030 d dram_mode_reg2_param
+e0030034 d dram_mode_reg3_param
+e0030034 d reset_delay_lpddr2_param
+e0030038 d dram_self_ref_param
+e003003c d dram_dqs_sync
+e0030040 d dram_pad_term
+e0030044 d dram_zq_calibration
+e0030048 d dram_delay2_param
+e003004c d pll_ddr_ctrl_param
+e0030050 d pll_ddr_ctrl2_param
+e0030054 d pll_ddr_ctrl3_param
+e0030058 d dram_dll0_param
+e003005c d dram_dll1_param
+e0030060 d dram_dll2_param
+e0030064 d dram_dll3_param
+e0030068 d dram_ctrl_sel_0_param
+e003006c d dram_ctrl_sel_1_param
+e0030070 d dram_ctrl_sel_2_param
+e0030074 d dram_ctrl_sel_3_param
+e0030078 d dram_ctrl_sel_misc_param
+e003007c d dram_byte_map
+e0030080 d dram_dqs_sync_prertt
+e0030084 d dram_zq_calibration_prertt
+e0030088 d dram_delay3_param
+e003008c d dram_rsvd_space
+e0030090 d pll_program_delay
+e0030094 d dll_program_delay
+e0030098 d cg_ddr_init_param
+e003009c d cg_ddr_normal_param
+e00300a0 d dll_reset_delay
+e00300a4 D amboot_bld_ram_start
+e00300a8 D amboot_bld_media_start
+e00300ac D amboot_bld_media_size
+e00300b0 D nand_flash_timing0
+e00300b4 D nand_flash_timing1
+e00300b8 D nand_flash_timing2
+e00300bc D nand_flash_timing3
+e00300c0 D nand_flash_timing4
+e00300c4 D nand_flash_timing5
+e00300c8 D pll_core_ctrl_param
+e00300cc D pll_idsp_ctrl_param
+e00300d0 D pll_cortex_ctrl_param
+e00300d4 D pll_cortex_frac_param
+e00300d8 D scaler_misc
+e00300dc D mcu_notify_gpio
+e00300e0 D emmc_boot_param
+e00300e4 d end_dram_table
+e00300e4 T memsetup
+e00300e4 D __table_end
+e00300ea t self_refresh_check
+e0030122 t disconnect_dram_reset
+e003013c t set_rct_pll
+e003013c t sr_check_exit
+e0030192 t setup_dram_dll
+e00302a6 t set_dram_mode
+e00302b2 t set_init_ctl
+e0030314 T rct_delay_proc
+e003031a t rct_timer_read
+e0030322 T loop_delay_proc
+e003032a T rct_pll_set_value
+e003035c T start
+e0030398 t relocate
+e00303a8 t relocate_2ndstage
+e00303c4 t dram_arbiter_cfg
+e0030424 t copy_loop
+e0030478 T self_refresh_jump
+e00304a8 t sr_jump_exit
+e00304b0 A __postreloc_start
+e00307a0 A __postreloc_end
diff --git a/sv/s2l/image/amboot_spinor_ddr3.map b/sv/s2l/image/amboot_spinor_ddr3.map
index e87afb2..57465bd 100644
--- a/sv/s2l/image/amboot_spinor_ddr3.map
+++ b/sv/s2l/image/amboot_spinor_ddr3.map
@@ -1,11 +1,11 @@
 00080000 A DRAM_BST_START
-000804d0 T __postreloc_ram_start
-000804d0 T start_post_relocate
-000804dc T spinor_load_bld
-000804e4 t spinor_jump_to_bld
-000804f0 t do_spinor_bld
-00080564 t read_spinor_loop
-000805a0 T __postreloc_ram_end
+000804e4 T __postreloc_ram_start
+000804e4 T start_post_relocate
+000804f0 T spinor_load_bld
+000804f8 t spinor_jump_to_bld
+00080504 t do_spinor_bld
+00080578 t read_spinor_loop
+000805b4 T __postreloc_ram_end
 20050000 A DRAM_TO_BOOT
 e0030000 A BOOT_BST_START
 e0030004 t chipname
@@ -64,27 +64,29 @@ e00300cc D pll_idsp_ctrl_param
 e00300d0 D pll_cortex_ctrl_param
 e00300d4 D pll_cortex_frac_param
 e00300d8 D scaler_misc
-e00300dc d end_dram_table
-e00300dc T memsetup
-e00300dc D __table_end
-e00300e2 t self_refresh_check
-e003010e t disconnect_dram_reset
-e0030128 t set_rct_pll
-e0030128 t sr_check_exit
-e003017e t setup_dram_dll
-e0030220 t issue_zqcl_cmd
-e0030256 t set_dram_mode
-e0030262 t set_init_ctl
-e00302b4 T rct_delay_proc
-e00302ba t rct_timer_read
-e00302c2 T loop_delay_proc
-e00302ca T rct_pll_set_value
-e00302fc T start
-e00303b8 t relocate
-e00303c8 t relocate_2ndstage
-e00303e4 t dram_arbiter_cfg
-e0030444 t copy_loop
-e0030498 T self_refresh_jump
-e00304c8 t sr_jump_exit
-e00304d0 A __postreloc_start
-e00305a0 A __postreloc_end
+e00300dc D mcu_notify_gpio
+e00300e0 D emmc_boot_param
+e00300e4 d end_dram_table
+e00300e4 T memsetup
+e00300e4 D __table_end
+e00300ea t self_refresh_check
+e0030122 t disconnect_dram_reset
+e003013c t set_rct_pll
+e003013c t sr_check_exit
+e0030192 t setup_dram_dll
+e0030234 t issue_zqcl_cmd
+e003026a t set_dram_mode
+e0030276 t set_init_ctl
+e00302c8 T rct_delay_proc
+e00302ce t rct_timer_read
+e00302d6 T loop_delay_proc
+e00302de T rct_pll_set_value
+e0030310 T start
+e00303cc t relocate
+e00303dc t relocate_2ndstage
+e00303f8 t dram_arbiter_cfg
+e0030458 t copy_loop
+e00304ac T self_refresh_jump
+e00304dc t sr_jump_exit
+e00304e4 A __postreloc_start
+e00305b4 A __postreloc_end
diff --git a/sv/s2l/image/amboot_spinor_lpddr3.map b/sv/s2l/image/amboot_spinor_lpddr3.map
index 254c6bd..127fe27 100644
--- a/sv/s2l/image/amboot_spinor_lpddr3.map
+++ b/sv/s2l/image/amboot_spinor_lpddr3.map
@@ -1,11 +1,11 @@
 00080000 A DRAM_BST_START
-00080528 T __postreloc_ram_start
-00080528 T start_post_relocate
-00080534 T spinor_load_bld
-0008053c t spinor_jump_to_bld
-00080548 t do_spinor_bld
-000805bc t read_spinor_loop
-000805f8 T __postreloc_ram_end
+00080530 T __postreloc_ram_start
+00080530 T start_post_relocate
+0008053c T spinor_load_bld
+00080544 t spinor_jump_to_bld
+00080550 t do_spinor_bld
+000805c4 t read_spinor_loop
+00080600 T __postreloc_ram_end
 20050000 A DRAM_TO_BOOT
 e0030000 A BOOT_BST_START
 e0030004 t chipname
@@ -64,27 +64,28 @@ e00300cc D pll_idsp_ctrl_param
 e00300d0 D pll_cortex_ctrl_param
 e00300d4 D pll_cortex_frac_param
 e00300d8 D scaler_misc
-e00300dc d end_dram_table
-e00300dc T memsetup
-e00300dc D __table_end
-e00300e2 t self_refresh_check
-e003010e t disconnect_dram_reset
-e0030128 t set_rct_pll
-e0030128 t sr_check_exit
-e003017e t setup_dram_dll
-e003028c t LOOP_MR0
-e0030298 t set_dram_mode
-e00302a4 t set_init_ctl
-e003030c T rct_delay_proc
-e0030312 t rct_timer_read
-e003031a T loop_delay_proc
-e0030322 T rct_pll_set_value
-e0030354 T start
-e0030410 t relocate
-e0030420 t relocate_2ndstage
-e003043c t dram_arbiter_cfg
-e003049c t copy_loop
-e00304f0 T self_refresh_jump
-e0030520 t sr_jump_exit
-e0030528 A __postreloc_start
-e00305f8 A __postreloc_end
+e00300dc D mcu_notify_gpio
+e00300e0 D emmc_boot_param
+e00300e4 d end_dram_table
+e00300e4 T memsetup
+e00300e4 D __table_end
+e00300ea t self_refresh_check
+e0030122 t disconnect_dram_reset
+e003013c t set_rct_pll
+e003013c t sr_check_exit
+e0030192 t setup_dram_dll
+e00302a6 t set_dram_mode
+e00302b2 t set_init_ctl
+e0030314 T rct_delay_proc
+e003031a t rct_timer_read
+e0030322 T loop_delay_proc
+e003032a T rct_pll_set_value
+e003035c T start
+e0030418 t relocate
+e0030428 t relocate_2ndstage
+e0030444 t dram_arbiter_cfg
+e00304a4 t copy_loop
+e00304f8 T self_refresh_jump
+e0030528 t sr_jump_exit
+e0030530 A __postreloc_start
+e0030600 A __postreloc_end
diff --git a/sv/s2l/image_4k/amboot_bst_ddr3.map b/sv/s2l/image_4k/amboot_bst_ddr3.map
new file mode 100644
index 0000000..3ae316b
--- /dev/null
+++ b/sv/s2l/image_4k/amboot_bst_ddr3.map
@@ -0,0 +1,131 @@
+00080000 A DRAM_BST_START
+00080508 T __postreloc_ram_start
+00080508 T start_post_relocate
+00080514 T nand_load_bld
+00080558 t nand_jump_to_bld
+00080568 t do_nand_bld
+0008057c t nand_512
+000805a0 t nand_2k
+000805b8 t done_size_setup
+000805d0 t set_6bit_ecc
+000805e8 t set_8bit_ecc
+000805fc t done_ecc
+00080604 t start_load_bld
+00080630 t nand_load_block_loop
+00080640 t start_loading_good_block
+00080658 t nand_load_next_block
+00080660 t nand_check_block
+00080670 t nand_check_block_loop
+000806a0 t nand_load_block
+000806cc t _controlreg_main_area
+000806d4 t _controlreg_spare_area
+000806dc t _done_controlreg
+00080714 t _dma_fifo_dsm_done
+0008072c t set_main_dma_burst
+00080738 t set_spare_dma_burst
+00080740 t done_set_dma_burst
+00080744 t flash_no_fixup
+00080754 t set_main_fiodma_burst
+00080760 t set_spare_fiodma_burst
+00080768 t set_fiodma_dsm_burst
+00080780 t done_set_fiodma_burst
+00080784 t _wait_nand_cmd_done
+00080794 t _wait_nand_fiodma_done
+000807b0 t _wait_nand_dma_done
+000807dc t eot_nand
+000807e0 t RT_NAND_BYTES_PER_BLOCK
+000807e4 t RT_NAND_CONTROL
+000807e8 t RT_FIO_DSM_BUFFER
+000807ec t NAND_BB_MARKER_OFFSET_RAM
+000807f0 t FIO_CTR_MAIN
+000807f4 t DMA_CHANX_CTR
+000807f8 t FIO_DMACTR
+000807fc t RT_NAND_ECC_BITS
+00080824 T __postreloc_ram_end
+00090000 A DRAM_TO_BOOT
+ffff0000 A BOOT_BST_START
+ffff0004 t chipname
+ffff000c t version
+ffff0010 d dram_delay1_param
+ffff0010 d dram_params_table
+ffff0014 d dram_cfg_param
+ffff0018 d dram_timing1_param
+ffff001c d dram_timing2_param
+ffff0020 d dram_timing3_param
+ffff0024 d por_delay_param
+ffff0028 d dram_mode_reg0_param
+ffff0028 d modereg_reset_lpddr2_param
+ffff002c d dram_mode_reg1_param
+ffff0030 d dram_mode_reg2_param
+ffff0034 d dram_mode_reg3_param
+ffff0034 d reset_delay_lpddr2_param
+ffff0038 d dram_self_ref_param
+ffff003c d dram_dqs_sync
+ffff0040 d dram_pad_term
+ffff0044 d dram_zq_calibration
+ffff0048 d dram_delay2_param
+ffff004c d pll_ddr_ctrl_param
+ffff0050 d pll_ddr_ctrl2_param
+ffff0054 d pll_ddr_ctrl3_param
+ffff0058 d dram_dll0_param
+ffff005c d dram_dll1_param
+ffff0060 d dram_dll2_param
+ffff0064 d dram_dll3_param
+ffff0068 d dram_ctrl_sel_0_param
+ffff006c d dram_ctrl_sel_1_param
+ffff0070 d dram_ctrl_sel_2_param
+ffff0074 d dram_ctrl_sel_3_param
+ffff0078 d dram_ctrl_sel_misc_param
+ffff007c d dram_byte_map
+ffff0080 d dram_dqs_sync_prertt
+ffff0084 d dram_zq_calibration_prertt
+ffff0088 d dram_delay3_param
+ffff008c d dram_rsvd_space
+ffff0090 d pll_program_delay
+ffff0094 d dll_program_delay
+ffff0098 d cg_ddr_init_param
+ffff009c d cg_ddr_normal_param
+ffff00a0 d dll_reset_delay
+ffff00a4 D amboot_bld_ram_start
+ffff00a8 D amboot_bld_media_start
+ffff00ac D amboot_bld_media_size
+ffff00b0 D nand_flash_timing0
+ffff00b4 D nand_flash_timing1
+ffff00b8 D nand_flash_timing2
+ffff00bc D nand_flash_timing3
+ffff00c0 D nand_flash_timing4
+ffff00c4 D nand_flash_timing5
+ffff00c8 D pll_core_ctrl_param
+ffff00cc D pll_idsp_ctrl_param
+ffff00d0 D pll_cortex_ctrl_param
+ffff00d4 D pll_cortex_frac_param
+ffff00d8 D scaler_misc
+ffff00dc D mcu_notify_gpio
+ffff00e0 D emmc_boot_param
+ffff00e4 d end_dram_table
+ffff00e4 T memsetup
+ffff00e4 D __table_end
+ffff00ea t self_refresh_check
+ffff00f0 t sr_check_mcu
+ffff0114 t sr_check_mcu_exit
+ffff0114 t sr_check_pwc
+ffff0146 t disconnect_dram_reset
+ffff0160 t set_rct_pll
+ffff0160 t sr_check_exit
+ffff01b6 t setup_dram_dll
+ffff0258 t issue_zqcl_cmd
+ffff028e t set_dram_mode
+ffff029a t set_init_ctl
+ffff02ec T rct_delay_proc
+ffff02f2 t rct_timer_read
+ffff02fa T loop_delay_proc
+ffff0302 T rct_pll_set_value
+ffff0334 T start
+ffff03f0 t relocate
+ffff0400 t relocate_2ndstage
+ffff041c t dram_arbiter_cfg
+ffff047c t copy_loop
+ffff04d0 T self_refresh_jump
+ffff0500 t sr_jump_exit
+ffff0508 A __postreloc_start
+ffff0824 A __postreloc_end
diff --git a/sv/s2l/image_4k/amboot_bst_lpddr3.map b/sv/s2l/image_4k/amboot_bst_lpddr3.map
new file mode 100644
index 0000000..d4fce5d
--- /dev/null
+++ b/sv/s2l/image_4k/amboot_bst_lpddr3.map
@@ -0,0 +1,130 @@
+00080000 A DRAM_BST_START
+00080554 T __postreloc_ram_start
+00080554 T start_post_relocate
+00080560 T nand_load_bld
+000805a4 t nand_jump_to_bld
+000805b4 t do_nand_bld
+000805c8 t nand_512
+000805ec t nand_2k
+00080604 t done_size_setup
+0008061c t set_6bit_ecc
+00080634 t set_8bit_ecc
+00080648 t done_ecc
+00080650 t start_load_bld
+0008067c t nand_load_block_loop
+0008068c t start_loading_good_block
+000806a4 t nand_load_next_block
+000806ac t nand_check_block
+000806bc t nand_check_block_loop
+000806ec t nand_load_block
+00080718 t _controlreg_main_area
+00080720 t _controlreg_spare_area
+00080728 t _done_controlreg
+00080760 t _dma_fifo_dsm_done
+00080778 t set_main_dma_burst
+00080784 t set_spare_dma_burst
+0008078c t done_set_dma_burst
+00080790 t flash_no_fixup
+000807a0 t set_main_fiodma_burst
+000807ac t set_spare_fiodma_burst
+000807b4 t set_fiodma_dsm_burst
+000807cc t done_set_fiodma_burst
+000807d0 t _wait_nand_cmd_done
+000807e0 t _wait_nand_fiodma_done
+000807fc t _wait_nand_dma_done
+00080828 t eot_nand
+0008082c t RT_NAND_BYTES_PER_BLOCK
+00080830 t RT_NAND_CONTROL
+00080834 t RT_FIO_DSM_BUFFER
+00080838 t NAND_BB_MARKER_OFFSET_RAM
+0008083c t FIO_CTR_MAIN
+00080840 t DMA_CHANX_CTR
+00080844 t FIO_DMACTR
+00080848 t RT_NAND_ECC_BITS
+00080870 T __postreloc_ram_end
+00090000 A DRAM_TO_BOOT
+ffff0000 A BOOT_BST_START
+ffff0004 t chipname
+ffff000c t version
+ffff0010 d dram_delay1_param
+ffff0010 d dram_params_table
+ffff0014 d dram_cfg_param
+ffff0018 d dram_timing1_param
+ffff001c d dram_timing2_param
+ffff0020 d dram_timing3_param
+ffff0024 d por_delay_param
+ffff0028 d dram_mode_reg0_param
+ffff0028 d modereg_reset_lpddr2_param
+ffff002c d dram_mode_reg1_param
+ffff0030 d dram_mode_reg2_param
+ffff0034 d dram_mode_reg3_param
+ffff0034 d reset_delay_lpddr2_param
+ffff0038 d dram_self_ref_param
+ffff003c d dram_dqs_sync
+ffff0040 d dram_pad_term
+ffff0044 d dram_zq_calibration
+ffff0048 d dram_delay2_param
+ffff004c d pll_ddr_ctrl_param
+ffff0050 d pll_ddr_ctrl2_param
+ffff0054 d pll_ddr_ctrl3_param
+ffff0058 d dram_dll0_param
+ffff005c d dram_dll1_param
+ffff0060 d dram_dll2_param
+ffff0064 d dram_dll3_param
+ffff0068 d dram_ctrl_sel_0_param
+ffff006c d dram_ctrl_sel_1_param
+ffff0070 d dram_ctrl_sel_2_param
+ffff0074 d dram_ctrl_sel_3_param
+ffff0078 d dram_ctrl_sel_misc_param
+ffff007c d dram_byte_map
+ffff0080 d dram_dqs_sync_prertt
+ffff0084 d dram_zq_calibration_prertt
+ffff0088 d dram_delay3_param
+ffff008c d dram_rsvd_space
+ffff0090 d pll_program_delay
+ffff0094 d dll_program_delay
+ffff0098 d cg_ddr_init_param
+ffff009c d cg_ddr_normal_param
+ffff00a0 d dll_reset_delay
+ffff00a4 D amboot_bld_ram_start
+ffff00a8 D amboot_bld_media_start
+ffff00ac D amboot_bld_media_size
+ffff00b0 D nand_flash_timing0
+ffff00b4 D nand_flash_timing1
+ffff00b8 D nand_flash_timing2
+ffff00bc D nand_flash_timing3
+ffff00c0 D nand_flash_timing4
+ffff00c4 D nand_flash_timing5
+ffff00c8 D pll_core_ctrl_param
+ffff00cc D pll_idsp_ctrl_param
+ffff00d0 D pll_cortex_ctrl_param
+ffff00d4 D pll_cortex_frac_param
+ffff00d8 D scaler_misc
+ffff00dc D mcu_notify_gpio
+ffff00e0 D emmc_boot_param
+ffff00e4 d end_dram_table
+ffff00e4 T memsetup
+ffff00e4 D __table_end
+ffff00ea t self_refresh_check
+ffff00f0 t sr_check_mcu
+ffff0114 t sr_check_mcu_exit
+ffff0114 t sr_check_pwc
+ffff0146 t disconnect_dram_reset
+ffff0160 t set_rct_pll
+ffff0160 t sr_check_exit
+ffff01b6 t setup_dram_dll
+ffff02ca t set_dram_mode
+ffff02d6 t set_init_ctl
+ffff0338 T rct_delay_proc
+ffff033e t rct_timer_read
+ffff0346 T loop_delay_proc
+ffff034e T rct_pll_set_value
+ffff0380 T start
+ffff043c t relocate
+ffff044c t relocate_2ndstage
+ffff0468 t dram_arbiter_cfg
+ffff04c8 t copy_loop
+ffff051c T self_refresh_jump
+ffff054c t sr_jump_exit
+ffff0554 A __postreloc_start
+ffff0870 A __postreloc_end
diff --git a/sv/s2l/image_4k/amboot_emmc_ddr3.map b/sv/s2l/image_4k/amboot_emmc_ddr3.map
new file mode 100644
index 0000000..877081c
--- /dev/null
+++ b/sv/s2l/image_4k/amboot_emmc_ddr3.map
@@ -0,0 +1,115 @@
+00080000 A DRAM_BST_START
+00080508 T __postreloc_ram_start
+00080508 T start_post_relocate
+00080514 T emmc_load_bld
+00080520 t emmc_init_wait_reset_done
+00080532 t emmc_init_wait_clock_stable
+0008055a t emmc_init_setup_mmc_card
+00080590 t emmc_test_poc
+000805a6 t emmc_test_hs_done
+000805ba t emmc_bus_1bit
+000805c2 t emmc_bus_4bit
+000805d2 t emmc_bus_8bit
+000805e0 t emmc_setup_card_done
+000805ee t emmc_wait_clk_off
+000805f4 t emmc_wait_clock_stable
+00080608 t emmc_switch_partition
+00080612 t emmc_boot
+00080628 t emmc_boot_wait_dma_done
+0008063c t sdmmc_command
+00080642 t sdmmc_command_wait_complete
+00080652 t emmc_read_sector
+00080654 t emmc_read_sector_wait_cmdline_ready
+0008065e t emmc_read_sector_wait_data_line_ready
+0008067c t emmc_read_sector_wait_cmd_complete
+00080690 t emmc_read_sector_wait_transfer_complete
+000806a4 t emmc_boot_fail
+000806a8 t RT_SD_CLOCK_CONTROL
+00080708 T __postreloc_ram_end
+00090000 A DRAM_TO_BOOT
+ffff0000 A BOOT_BST_START
+ffff0004 t chipname
+ffff000c t version
+ffff0010 d dram_delay1_param
+ffff0010 d dram_params_table
+ffff0014 d dram_cfg_param
+ffff0018 d dram_timing1_param
+ffff001c d dram_timing2_param
+ffff0020 d dram_timing3_param
+ffff0024 d por_delay_param
+ffff0028 d dram_mode_reg0_param
+ffff0028 d modereg_reset_lpddr2_param
+ffff002c d dram_mode_reg1_param
+ffff0030 d dram_mode_reg2_param
+ffff0034 d dram_mode_reg3_param
+ffff0034 d reset_delay_lpddr2_param
+ffff0038 d dram_self_ref_param
+ffff003c d dram_dqs_sync
+ffff0040 d dram_pad_term
+ffff0044 d dram_zq_calibration
+ffff0048 d dram_delay2_param
+ffff004c d pll_ddr_ctrl_param
+ffff0050 d pll_ddr_ctrl2_param
+ffff0054 d pll_ddr_ctrl3_param
+ffff0058 d dram_dll0_param
+ffff005c d dram_dll1_param
+ffff0060 d dram_dll2_param
+ffff0064 d dram_dll3_param
+ffff0068 d dram_ctrl_sel_0_param
+ffff006c d dram_ctrl_sel_1_param
+ffff0070 d dram_ctrl_sel_2_param
+ffff0074 d dram_ctrl_sel_3_param
+ffff0078 d dram_ctrl_sel_misc_param
+ffff007c d dram_byte_map
+ffff0080 d dram_dqs_sync_prertt
+ffff0084 d dram_zq_calibration_prertt
+ffff0088 d dram_delay3_param
+ffff008c d dram_rsvd_space
+ffff0090 d pll_program_delay
+ffff0094 d dll_program_delay
+ffff0098 d cg_ddr_init_param
+ffff009c d cg_ddr_normal_param
+ffff00a0 d dll_reset_delay
+ffff00a4 D amboot_bld_ram_start
+ffff00a8 D amboot_bld_media_start
+ffff00ac D amboot_bld_media_size
+ffff00b0 D nand_flash_timing0
+ffff00b4 D nand_flash_timing1
+ffff00b8 D nand_flash_timing2
+ffff00bc D nand_flash_timing3
+ffff00c0 D nand_flash_timing4
+ffff00c4 D nand_flash_timing5
+ffff00c8 D pll_core_ctrl_param
+ffff00cc D pll_idsp_ctrl_param
+ffff00d0 D pll_cortex_ctrl_param
+ffff00d4 D pll_cortex_frac_param
+ffff00d8 D scaler_misc
+ffff00dc D mcu_notify_gpio
+ffff00e0 D emmc_boot_param
+ffff00e4 d end_dram_table
+ffff00e4 T memsetup
+ffff00e4 D __table_end
+ffff00ea t self_refresh_check
+ffff00f0 t sr_check_mcu
+ffff0114 t sr_check_mcu_exit
+ffff0114 t sr_check_pwc
+ffff0146 t disconnect_dram_reset
+ffff0160 t set_rct_pll
+ffff0160 t sr_check_exit
+ffff01b6 t setup_dram_dll
+ffff0258 t issue_zqcl_cmd
+ffff028e t set_dram_mode
+ffff029a t set_init_ctl
+ffff02ec T rct_delay_proc
+ffff02f2 t rct_timer_read
+ffff02fa T loop_delay_proc
+ffff0302 T rct_pll_set_value
+ffff0334 T start
+ffff03f0 t relocate
+ffff0400 t relocate_2ndstage
+ffff041c t dram_arbiter_cfg
+ffff047c t copy_loop
+ffff04d0 T self_refresh_jump
+ffff0500 t sr_jump_exit
+ffff0508 A __postreloc_start
+ffff0708 A __postreloc_end
diff --git a/sv/s2l/image_4k/amboot_emmc_lpddr3.map b/sv/s2l/image_4k/amboot_emmc_lpddr3.map
new file mode 100644
index 0000000..8c8b832
--- /dev/null
+++ b/sv/s2l/image_4k/amboot_emmc_lpddr3.map
@@ -0,0 +1,114 @@
+00080000 A DRAM_BST_START
+00080554 T __postreloc_ram_start
+00080554 T start_post_relocate
+00080560 T emmc_load_bld
+0008056c t emmc_init_wait_reset_done
+0008057e t emmc_init_wait_clock_stable
+000805a6 t emmc_init_setup_mmc_card
+000805dc t emmc_test_poc
+000805f2 t emmc_test_hs_done
+00080606 t emmc_bus_1bit
+0008060e t emmc_bus_4bit
+0008061e t emmc_bus_8bit
+0008062c t emmc_setup_card_done
+0008063a t emmc_wait_clk_off
+00080640 t emmc_wait_clock_stable
+00080654 t emmc_switch_partition
+0008065e t emmc_boot
+00080674 t emmc_boot_wait_dma_done
+00080688 t sdmmc_command
+0008068e t sdmmc_command_wait_complete
+0008069e t emmc_read_sector
+000806a0 t emmc_read_sector_wait_cmdline_ready
+000806aa t emmc_read_sector_wait_data_line_ready
+000806c8 t emmc_read_sector_wait_cmd_complete
+000806dc t emmc_read_sector_wait_transfer_complete
+000806f0 t emmc_boot_fail
+000806f4 t RT_SD_CLOCK_CONTROL
+00080754 T __postreloc_ram_end
+00090000 A DRAM_TO_BOOT
+ffff0000 A BOOT_BST_START
+ffff0004 t chipname
+ffff000c t version
+ffff0010 d dram_delay1_param
+ffff0010 d dram_params_table
+ffff0014 d dram_cfg_param
+ffff0018 d dram_timing1_param
+ffff001c d dram_timing2_param
+ffff0020 d dram_timing3_param
+ffff0024 d por_delay_param
+ffff0028 d dram_mode_reg0_param
+ffff0028 d modereg_reset_lpddr2_param
+ffff002c d dram_mode_reg1_param
+ffff0030 d dram_mode_reg2_param
+ffff0034 d dram_mode_reg3_param
+ffff0034 d reset_delay_lpddr2_param
+ffff0038 d dram_self_ref_param
+ffff003c d dram_dqs_sync
+ffff0040 d dram_pad_term
+ffff0044 d dram_zq_calibration
+ffff0048 d dram_delay2_param
+ffff004c d pll_ddr_ctrl_param
+ffff0050 d pll_ddr_ctrl2_param
+ffff0054 d pll_ddr_ctrl3_param
+ffff0058 d dram_dll0_param
+ffff005c d dram_dll1_param
+ffff0060 d dram_dll2_param
+ffff0064 d dram_dll3_param
+ffff0068 d dram_ctrl_sel_0_param
+ffff006c d dram_ctrl_sel_1_param
+ffff0070 d dram_ctrl_sel_2_param
+ffff0074 d dram_ctrl_sel_3_param
+ffff0078 d dram_ctrl_sel_misc_param
+ffff007c d dram_byte_map
+ffff0080 d dram_dqs_sync_prertt
+ffff0084 d dram_zq_calibration_prertt
+ffff0088 d dram_delay3_param
+ffff008c d dram_rsvd_space
+ffff0090 d pll_program_delay
+ffff0094 d dll_program_delay
+ffff0098 d cg_ddr_init_param
+ffff009c d cg_ddr_normal_param
+ffff00a0 d dll_reset_delay
+ffff00a4 D amboot_bld_ram_start
+ffff00a8 D amboot_bld_media_start
+ffff00ac D amboot_bld_media_size
+ffff00b0 D nand_flash_timing0
+ffff00b4 D nand_flash_timing1
+ffff00b8 D nand_flash_timing2
+ffff00bc D nand_flash_timing3
+ffff00c0 D nand_flash_timing4
+ffff00c4 D nand_flash_timing5
+ffff00c8 D pll_core_ctrl_param
+ffff00cc D pll_idsp_ctrl_param
+ffff00d0 D pll_cortex_ctrl_param
+ffff00d4 D pll_cortex_frac_param
+ffff00d8 D scaler_misc
+ffff00dc D mcu_notify_gpio
+ffff00e0 D emmc_boot_param
+ffff00e4 d end_dram_table
+ffff00e4 T memsetup
+ffff00e4 D __table_end
+ffff00ea t self_refresh_check
+ffff00f0 t sr_check_mcu
+ffff0114 t sr_check_mcu_exit
+ffff0114 t sr_check_pwc
+ffff0146 t disconnect_dram_reset
+ffff0160 t set_rct_pll
+ffff0160 t sr_check_exit
+ffff01b6 t setup_dram_dll
+ffff02ca t set_dram_mode
+ffff02d6 t set_init_ctl
+ffff0338 T rct_delay_proc
+ffff033e t rct_timer_read
+ffff0346 T loop_delay_proc
+ffff034e T rct_pll_set_value
+ffff0380 T start
+ffff043c t relocate
+ffff044c t relocate_2ndstage
+ffff0468 t dram_arbiter_cfg
+ffff04c8 t copy_loop
+ffff051c T self_refresh_jump
+ffff054c t sr_jump_exit
+ffff0554 A __postreloc_start
+ffff0754 A __postreloc_end
diff --git a/sv/s2l/image_4k/amboot_spinand_ddr3.map b/sv/s2l/image_4k/amboot_spinand_ddr3.map
new file mode 100644
index 0000000..fb47435
--- /dev/null
+++ b/sv/s2l/image_4k/amboot_spinand_ddr3.map
@@ -0,0 +1,108 @@
+00080000 A DRAM_BST_START
+00080488 T __postreloc_ram_start
+00080488 T start_post_relocate
+00080494 T spinand_load_bld
+0008049c t spinand_jump_to_bld
+000804ac t do_spinand_bld
+000804f0 t spinand_load_block_loop
+00080504 t start_loading_good_block
+00080518 t spinand_check_block
+00080568 t spinand_disable_ecc
+0008059c t spinand_enable_ecc
+000805d0 t spinand_load_block
+000805d8 t spinand_read_pages
+00080624 t check_spinand_status
+00080638 t wait_ready
+000806a0 t spinand_send_cmd
+000806ac t spinand_set_cmd
+000806f8 t spinand_read
+00080738 t spinand_read_page
+0008073c t spinand_read_loop
+00080778 T __postreloc_ram_end
+20050000 A DRAM_TO_BOOT
+e0030000 A BOOT_BST_START
+e0030004 t chipname
+e003000c t version
+e0030010 d dram_delay1_param
+e0030010 d dram_params_table
+e0030014 d dram_cfg_param
+e0030018 d dram_timing1_param
+e003001c d dram_timing2_param
+e0030020 d dram_timing3_param
+e0030024 d por_delay_param
+e0030028 d dram_mode_reg0_param
+e0030028 d modereg_reset_lpddr2_param
+e003002c d dram_mode_reg1_param
+e0030030 d dram_mode_reg2_param
+e0030034 d dram_mode_reg3_param
+e0030034 d reset_delay_lpddr2_param
+e0030038 d dram_self_ref_param
+e003003c d dram_dqs_sync
+e0030040 d dram_pad_term
+e0030044 d dram_zq_calibration
+e0030048 d dram_delay2_param
+e003004c d pll_ddr_ctrl_param
+e0030050 d pll_ddr_ctrl2_param
+e0030054 d pll_ddr_ctrl3_param
+e0030058 d dram_dll0_param
+e003005c d dram_dll1_param
+e0030060 d dram_dll2_param
+e0030064 d dram_dll3_param
+e0030068 d dram_ctrl_sel_0_param
+e003006c d dram_ctrl_sel_1_param
+e0030070 d dram_ctrl_sel_2_param
+e0030074 d dram_ctrl_sel_3_param
+e0030078 d dram_ctrl_sel_misc_param
+e003007c d dram_byte_map
+e0030080 d dram_dqs_sync_prertt
+e0030084 d dram_zq_calibration_prertt
+e0030088 d dram_delay3_param
+e003008c d dram_rsvd_space
+e0030090 d pll_program_delay
+e0030094 d dll_program_delay
+e0030098 d cg_ddr_init_param
+e003009c d cg_ddr_normal_param
+e00300a0 d dll_reset_delay
+e00300a4 D amboot_bld_ram_start
+e00300a8 D amboot_bld_media_start
+e00300ac D amboot_bld_media_size
+e00300b0 D nand_flash_timing0
+e00300b4 D nand_flash_timing1
+e00300b8 D nand_flash_timing2
+e00300bc D nand_flash_timing3
+e00300c0 D nand_flash_timing4
+e00300c4 D nand_flash_timing5
+e00300c8 D pll_core_ctrl_param
+e00300cc D pll_idsp_ctrl_param
+e00300d0 D pll_cortex_ctrl_param
+e00300d4 D pll_cortex_frac_param
+e00300d8 D scaler_misc
+e00300dc D mcu_notify_gpio
+e00300e0 D emmc_boot_param
+e00300e4 d end_dram_table
+e00300e4 T memsetup
+e00300e4 D __table_end
+e00300ea t self_refresh_check
+e00300f0 t sr_check_mcu
+e0030114 t sr_check_mcu_exit
+e0030114 t sr_check_pwc
+e0030146 t disconnect_dram_reset
+e0030160 t set_rct_pll
+e0030160 t sr_check_exit
+e00301b6 t setup_dram_dll
+e0030258 t issue_zqcl_cmd
+e003028e t set_dram_mode
+e003029a t set_init_ctl
+e00302ec T rct_delay_proc
+e00302f2 t rct_timer_read
+e00302fa T loop_delay_proc
+e0030302 T rct_pll_set_value
+e0030334 T start
+e0030370 t relocate
+e0030380 t relocate_2ndstage
+e003039c t dram_arbiter_cfg
+e00303fc t copy_loop
+e0030450 T self_refresh_jump
+e0030480 t sr_jump_exit
+e0030488 A __postreloc_start
+e0030778 A __postreloc_end
diff --git a/sv/s2l/image_4k/amboot_spinand_lpddr3.map b/sv/s2l/image_4k/amboot_spinand_lpddr3.map
new file mode 100644
index 0000000..79ebbfa
--- /dev/null
+++ b/sv/s2l/image_4k/amboot_spinand_lpddr3.map
@@ -0,0 +1,107 @@
+00080000 A DRAM_BST_START
+000804d4 T __postreloc_ram_start
+000804d4 T start_post_relocate
+000804e0 T spinand_load_bld
+000804e8 t spinand_jump_to_bld
+000804f8 t do_spinand_bld
+0008053c t spinand_load_block_loop
+00080550 t start_loading_good_block
+00080564 t spinand_check_block
+000805b4 t spinand_disable_ecc
+000805e8 t spinand_enable_ecc
+0008061c t spinand_load_block
+00080624 t spinand_read_pages
+00080670 t check_spinand_status
+00080684 t wait_ready
+000806ec t spinand_send_cmd
+000806f8 t spinand_set_cmd
+00080744 t spinand_read
+00080784 t spinand_read_page
+00080788 t spinand_read_loop
+000807c4 T __postreloc_ram_end
+20050000 A DRAM_TO_BOOT
+e0030000 A BOOT_BST_START
+e0030004 t chipname
+e003000c t version
+e0030010 d dram_delay1_param
+e0030010 d dram_params_table
+e0030014 d dram_cfg_param
+e0030018 d dram_timing1_param
+e003001c d dram_timing2_param
+e0030020 d dram_timing3_param
+e0030024 d por_delay_param
+e0030028 d dram_mode_reg0_param
+e0030028 d modereg_reset_lpddr2_param
+e003002c d dram_mode_reg1_param
+e0030030 d dram_mode_reg2_param
+e0030034 d dram_mode_reg3_param
+e0030034 d reset_delay_lpddr2_param
+e0030038 d dram_self_ref_param
+e003003c d dram_dqs_sync
+e0030040 d dram_pad_term
+e0030044 d dram_zq_calibration
+e0030048 d dram_delay2_param
+e003004c d pll_ddr_ctrl_param
+e0030050 d pll_ddr_ctrl2_param
+e0030054 d pll_ddr_ctrl3_param
+e0030058 d dram_dll0_param
+e003005c d dram_dll1_param
+e0030060 d dram_dll2_param
+e0030064 d dram_dll3_param
+e0030068 d dram_ctrl_sel_0_param
+e003006c d dram_ctrl_sel_1_param
+e0030070 d dram_ctrl_sel_2_param
+e0030074 d dram_ctrl_sel_3_param
+e0030078 d dram_ctrl_sel_misc_param
+e003007c d dram_byte_map
+e0030080 d dram_dqs_sync_prertt
+e0030084 d dram_zq_calibration_prertt
+e0030088 d dram_delay3_param
+e003008c d dram_rsvd_space
+e0030090 d pll_program_delay
+e0030094 d dll_program_delay
+e0030098 d cg_ddr_init_param
+e003009c d cg_ddr_normal_param
+e00300a0 d dll_reset_delay
+e00300a4 D amboot_bld_ram_start
+e00300a8 D amboot_bld_media_start
+e00300ac D amboot_bld_media_size
+e00300b0 D nand_flash_timing0
+e00300b4 D nand_flash_timing1
+e00300b8 D nand_flash_timing2
+e00300bc D nand_flash_timing3
+e00300c0 D nand_flash_timing4
+e00300c4 D nand_flash_timing5
+e00300c8 D pll_core_ctrl_param
+e00300cc D pll_idsp_ctrl_param
+e00300d0 D pll_cortex_ctrl_param
+e00300d4 D pll_cortex_frac_param
+e00300d8 D scaler_misc
+e00300dc D mcu_notify_gpio
+e00300e0 D emmc_boot_param
+e00300e4 d end_dram_table
+e00300e4 T memsetup
+e00300e4 D __table_end
+e00300ea t self_refresh_check
+e00300f0 t sr_check_mcu
+e0030114 t sr_check_mcu_exit
+e0030114 t sr_check_pwc
+e0030146 t disconnect_dram_reset
+e0030160 t set_rct_pll
+e0030160 t sr_check_exit
+e00301b6 t setup_dram_dll
+e00302ca t set_dram_mode
+e00302d6 t set_init_ctl
+e0030338 T rct_delay_proc
+e003033e t rct_timer_read
+e0030346 T loop_delay_proc
+e003034e T rct_pll_set_value
+e0030380 T start
+e00303bc t relocate
+e00303cc t relocate_2ndstage
+e00303e8 t dram_arbiter_cfg
+e0030448 t copy_loop
+e003049c T self_refresh_jump
+e00304cc t sr_jump_exit
+e00304d4 A __postreloc_start
+e00307c4 A __postreloc_end
diff --git a/sv/s2l/image_4k/amboot_spinor_ddr3.map b/sv/s2l/image_4k/amboot_spinor_ddr3.map
new file mode 100644
index 0000000..c4b947e
--- /dev/null
+++ b/sv/s2l/image_4k/amboot_spinor_ddr3.map
@@ -0,0 +1,95 @@
+00080000 A DRAM_BST_START
+00080508 T __postreloc_ram_start
+00080508 T start_post_relocate
+00080514 T spinor_load_bld
+0008051c t spinor_jump_to_bld
+00080528 t do_spinor_bld
+0008059c t read_spinor_loop
+000805d8 T __postreloc_ram_end
+20050000 A DRAM_TO_BOOT
+e0030000 A BOOT_BST_START
+e0030004 t chipname
+e003000c t version
+e0030010 d dram_delay1_param
+e0030010 d dram_params_table
+e0030014 d dram_cfg_param
+e0030018 d dram_timing1_param
+e003001c d dram_timing2_param
+e0030020 d dram_timing3_param
+e0030024 d por_delay_param
+e0030028 d dram_mode_reg0_param
+e0030028 d modereg_reset_lpddr2_param
+e003002c d dram_mode_reg1_param
+e0030030 d dram_mode_reg2_param
+e0030034 d dram_mode_reg3_param
+e0030034 d reset_delay_lpddr2_param
+e0030038 d dram_self_ref_param
+e003003c d dram_dqs_sync
+e0030040 d dram_pad_term
+e0030044 d dram_zq_calibration
+e0030048 d dram_delay2_param
+e003004c d pll_ddr_ctrl_param
+e0030050 d pll_ddr_ctrl2_param
+e0030054 d pll_ddr_ctrl3_param
+e0030058 d dram_dll0_param
+e003005c d dram_dll1_param
+e0030060 d dram_dll2_param
+e0030064 d dram_dll3_param
+e0030068 d dram_ctrl_sel_0_param
+e003006c d dram_ctrl_sel_1_param
+e0030070 d dram_ctrl_sel_2_param
+e0030074 d dram_ctrl_sel_3_param
+e0030078 d dram_ctrl_sel_misc_param
+e003007c d dram_byte_map
+e0030080 d dram_dqs_sync_prertt
+e0030084 d dram_zq_calibration_prertt
+e0030088 d dram_delay3_param
+e003008c d dram_rsvd_space
+e0030090 d pll_program_delay
+e0030094 d dll_program_delay
+e0030098 d cg_ddr_init_param
+e003009c d cg_ddr_normal_param
+e00300a0 d dll_reset_delay
+e00300a4 D amboot_bld_ram_start
+e00300a8 D amboot_bld_media_start
+e00300ac D amboot_bld_media_size
+e00300b0 D nand_flash_timing0
+e00300b4 D nand_flash_timing1
+e00300b8 D nand_flash_timing2
+e00300bc D nand_flash_timing3
+e00300c0 D nand_flash_timing4
+e00300c4 D nand_flash_timing5
+e00300c8 D pll_core_ctrl_param
+e00300cc D pll_idsp_ctrl_param
+e00300d0 D pll_cortex_ctrl_param
+e00300d4 D pll_cortex_frac_param
+e00300d8 D scaler_misc
+e00300dc D mcu_notify_gpio
+e00300e0 D emmc_boot_param
+e00300e4 d end_dram_table
+e00300e4 T memsetup
+e00300e4 D __table_end
+e00300ea t self_refresh_check
+e00300f0 t sr_check_mcu
+e0030114 t sr_check_mcu_exit
+e0030114 t sr_check_pwc
+e0030146 t disconnect_dram_reset
+e0030160 t set_rct_pll
+e0030160 t sr_check_exit
+e00301b6 t setup_dram_dll
+e0030258 t issue_zqcl_cmd
+e003028e t set_dram_mode
+e003029a t set_init_ctl
+e00302ec T rct_delay_proc
+e00302f2 t rct_timer_read
+e00302fa T loop_delay_proc
+e0030302 T rct_pll_set_value
+e0030334 T start
+e00303f0 t relocate
+e0030400 t relocate_2ndstage
+e003041c t dram_arbiter_cfg
+e003047c t copy_loop
+e00304d0 T self_refresh_jump
+e0030500 t sr_jump_exit
+e0030508 A __postreloc_start
+e00305d8 A __postreloc_end
diff --git a/sv/s2l/image_4k/amboot_spinor_lpddr3.map b/sv/s2l/image_4k/amboot_spinor_lpddr3.map
new file mode 100644
index 0000000..ff337dc
--- /dev/null
+++ b/sv/s2l/image_4k/amboot_spinor_lpddr3.map
@@ -0,0 +1,94 @@
+00080000 A DRAM_BST_START
+00080554 T __postreloc_ram_start
+00080554 T start_post_relocate
+00080560 T spinor_load_bld
+00080568 t spinor_jump_to_bld
+00080574 t do_spinor_bld
+000805e8 t read_spinor_loop
+00080624 T __postreloc_ram_end
+20050000 A DRAM_TO_BOOT
+e0030000 A BOOT_BST_START
+e0030004 t chipname
+e003000c t version
+e0030010 d dram_delay1_param
+e0030010 d dram_params_table
+e0030014 d dram_cfg_param
+e0030018 d dram_timing1_param
+e003001c d dram_timing2_param
+e0030020 d dram_timing3_param
+e0030024 d por_delay_param
+e0030028 d dram_mode_reg0_param
+e0030028 d modereg_reset_lpddr2_param
+e003002c d dram_mode_reg1_param
+e0030030 d dram_mode_reg2_param
+e0030034 d dram_mode_reg3_param
+e0030034 d reset_delay_lpddr2_param
+e0030038 d dram_self_ref_param
+e003003c d dram_dqs_sync
+e0030040 d dram_pad_term
+e0030044 d dram_zq_calibration
+e0030048 d dram_delay2_param
+e003004c d pll_ddr_ctrl_param
+e0030050 d pll_ddr_ctrl2_param
+e0030054 d pll_ddr_ctrl3_param
+e0030058 d dram_dll0_param
+e003005c d dram_dll1_param
+e0030060 d dram_dll2_param
+e0030064 d dram_dll3_param
+e0030068 d dram_ctrl_sel_0_param
+e003006c d dram_ctrl_sel_1_param
+e0030070 d dram_ctrl_sel_2_param
+e0030074 d dram_ctrl_sel_3_param
+e0030078 d dram_ctrl_sel_misc_param
+e003007c d dram_byte_map
+e0030080 d dram_dqs_sync_prertt
+e0030084 d dram_zq_calibration_prertt
+e0030088 d dram_delay3_param
+e003008c d dram_rsvd_space
+e0030090 d pll_program_delay
+e0030094 d dll_program_delay
+e0030098 d cg_ddr_init_param
+e003009c d cg_ddr_normal_param
+e00300a0 d dll_reset_delay
+e00300a4 D amboot_bld_ram_start
+e00300a8 D amboot_bld_media_start
+e00300ac D amboot_bld_media_size
+e00300b0 D nand_flash_timing0
+e00300b4 D nand_flash_timing1
+e00300b8 D nand_flash_timing2
+e00300bc D nand_flash_timing3
+e00300c0 D nand_flash_timing4
+e00300c4 D nand_flash_timing5
+e00300c8 D pll_core_ctrl_param
+e00300cc D pll_idsp_ctrl_param
+e00300d0 D pll_cortex_ctrl_param
+e00300d4 D pll_cortex_frac_param
+e00300d8 D scaler_misc
+e00300dc D mcu_notify_gpio
+e00300e0 D emmc_boot_param
+e00300e4 d end_dram_table
+e00300e4 T memsetup
+e00300e4 D __table_end
+e00300ea t self_refresh_check
+e00300f0 t sr_check_mcu
+e0030114 t sr_check_mcu_exit
+e0030114 t sr_check_pwc
+e0030146 t disconnect_dram_reset
+e0030160 t set_rct_pll
+e0030160 t sr_check_exit
+e00301b6 t setup_dram_dll
+e00302ca t set_dram_mode
+e00302d6 t set_init_ctl
+e0030338 T rct_delay_proc
+e003033e t rct_timer_read
+e0030346 T loop_delay_proc
+e003034e T rct_pll_set_value
+e0030380 T start
+e003043c t relocate
+e003044c t relocate_2ndstage
+e0030468 t dram_arbiter_cfg
+e00304c8 t copy_loop
+e003051c T self_refresh_jump
+e003054c t sr_jump_exit
+e0030554 A __postreloc_start
+e0030624 A __postreloc_end
diff --git a/vif/atf.info b/vif/atf.info
new file mode 100644
index 0000000..617f7d9
--- /dev/null
+++ b/vif/atf.info
@@ -0,0 +1,30 @@
+/**
+ * vif/atf.info
+ *
+ * Version info for the kernel firmware.
+ *
+ * Author: Cao Rongrong <rrcao@ambarella.com>
+ *
+ * Copyright (C) 2012-2016, Ambarella, Inc.
+ *
+ * All rights reserved. No Part of this file may be reproduced, stored
+ * in a retrieval system, or transmitted, in any form, or by any means,
+ * electronic, mechanical, photocopying, recording, or otherwise,
+ * without the prior consent of Ambarella, Inc.
+ */
+
+#ifndef __VERSION_INFO__
+#define __VERSION_INFO__
+
+#include <amboot.h>
+
+#define FIRM_VER_NUM	AMB_VER_NUM(0,1)
+#if defined(__YEAR__) && defined(__MONTH__) && defined(__DAY__)
+#define FIRM_VER_DATE	AMB_VER_DATE(__YEAR__,__MONTH__,__DAY__)
+#else
+#define FIRM_VER_DATE	AMB_VER_DATE(2007,10,24)
+#endif
+#define FIRM_MEM_ADDR	0x0
+#define FIRM_FLAG	PART_LOAD
+
+#endif
diff --git a/vif/kernel.info b/vif/kernel.info
new file mode 100644
index 0000000..f2ef735
--- /dev/null
+++ b/vif/kernel.info
@@ -0,0 +1,31 @@
+/**
+ * vif/linux.info
+ *
+ * Version info for the kernel firmware.
+ *
+ * History:
+ *    2007/10/24 - [Charles Chiou] created file
+ *
+ * Copyright (C) 2004-2014, Ambarella, Inc.
+ *
+ * All rights reserved. No Part of this file may be reproduced, stored
+ * in a retrieval system, or transmitted, in any form, or by any means,
+ * electronic, mechanical, photocopying, recording, or otherwise,
+ * without the prior consent of Ambarella, Inc.
+ */
+
+#ifndef __VERSION_INFO__
+#define __VERSION_INFO__
+
+#include <amboot.h>
+
+#define FIRM_VER_NUM	AMB_VER_NUM(0,1)
+#if defined(__YEAR__) && defined(__MONTH__) && defined(__DAY__)
+#define FIRM_VER_DATE	AMB_VER_DATE(__YEAR__,__MONTH__,__DAY__)
+#else
+#define FIRM_VER_DATE	AMB_VER_DATE(2007,10,24)
+#endif
+#define FIRM_MEM_ADDR	KERNEL_RAM_START
+#define FIRM_FLAG	PART_LOAD
+
+#endif
