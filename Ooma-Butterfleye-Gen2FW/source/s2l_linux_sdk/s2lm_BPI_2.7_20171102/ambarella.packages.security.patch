diff --git a/AmbaConfig b/AmbaConfig
index 22cc869..954ca5d 100644
--- a/AmbaConfig
+++ b/AmbaConfig
@@ -1,16 +1,34 @@
-##
+###############################################################################
 ## Packages/security/AmbaConfig
 ##
 ## History:
 ##    2015/08/03 - [Zhi He]
 ##
-## Copyright (C) 2015-2025, Ambarella, Inc.
+## Copyright (c) 2016 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
+##################################################################################
 
 menuconfig BUILD_AMBARELLA_SECURITY_PACKAGE
 	bool "Build Ambarella Security Package"
@@ -22,6 +40,7 @@ if BUILD_AMBARELLA_SECURITY_PACKAGE
 
 config BUILD_OPENSSL_WRAPPER_LIBRARY
 	bool "Build OpenSSL Wrapper Library"
+	select CONFIG_AMBARELLA_OPENSSL_SUPPORT
 	default y
 	help
 		Build OpenSSL Wrapper Library.
@@ -55,101 +74,6 @@ config CONFIG_DIGITAL_SIGNATURE_LIBRARY_OPENSSL
 
 endchoice
 
-menuconfig BUILD_AMBARELLA_LW_MEDIA
-	bool "Build Ambarella Lightweight Media Library"
-	default y
-	help
-		Build Ambarella Lightweight Media Library.
-
-
-if BUILD_AMBARELLA_LW_MEDIA
-
-config BUILD_AMBARELLA_LW_MEDIA_UT
-  bool "Build lw_media unit test"
-  default n
-  help
-    Build lw_media unit test
-
-config BUILD_AMBARELLA_LW_MEDIA_DEMUXER_RTSP
-  bool "RTSP Demuxer"
-  default y
-  help
-    Select RTSP Demuxer
-
-config BUILD_AMBARELLA_LW_MEDIA_DEMUXER_MP4
-  bool "MP4 Demuxer"
-  default y
-  help
-    Select Module MP4 Demuxer
-
-config BUILD_AMBARELLA_LW_MEDIA_DEMUXER_TS
-  bool "TS Demuxer"
-  default n
-  help
-    Select TS Demuxer
-
-config BUILD_AMBARELLA_LW_MEDIA_MUXER_MP4
-  bool "MP4 Muxer"
-  default y
-  help
-    Select Module MP4 Muxer
-
-config BUILD_AMBARELLA_LW_MEDIA_MUXER_TS
-  bool "TS Muxer"
-  default n
-  help
-    Select TS Muxer
-
-config BUILD_AMBARELLA_LW_MEDIA_LINUXFB
-  bool "LinuxFB Video Renderer"
-  default n
-  help
-    Select LinuxFB Video Renderer
-
-config BUILD_AMBARELLA_LW_MEDIA_ALSA_LIBRARY
-  bool "Enable ALSA Library"
-  select CONFIG_AMBARELLA_ALSA_SUPPORT
-  default y
-  help
-    Enable Audio ALSA Library
-
-config BUILD_AMBARELLA_LW_MEDIA_FFMPEG_LIBRARY
-  bool "Enable FFMpeg Library"
-  select CONFIG_AMBARELLA_FFMPEG_SUPPORT
-  default n
-  help
-    Enable FFMpeg Library
-
-config BUILD_AMBARELLA_LW_MEDIA_AMBA_AAC_LIBRARY
-  bool "Enable Ambarella AAC Library"
-  default y
-  help
-    Enable Ambarella AAC Library
-
-menuconfig BUILD_AMBARELLA_LW_MEDIA_AMBA_DSP
-  bool "Enable Ambarella DSP related"
-  default y
-  help
-    Enable Ambarella DSP related module
-
-if BUILD_AMBARELLA_LW_MEDIA_AMBA_DSP
-
-config BUILD_AMBARELLA_LW_MEDIA_VIDEO_DECODER_AMBA
-  bool "Ambarella Video Decoder"
-  default y
-  help
-    Select Ambarella Video Decoder
-
-config BUILD_AMBARELLA_LW_MEDIA_VIDEO_RENDERER_AMBA
-  bool "Ambarella Video Renderer"
-  default y
-  help
-    Select Ambarella Video Renderer
-
-endif
-
-endif
-
 config BUILD_AMBARELLA_CRYPTOCHIP_LIBRARY
 	bool "Build Cryptochip Library"
 	select BUILD_PRIVATE_DRIVER_FOR_CRYPTOCHIP
@@ -165,10 +89,17 @@ config BUILD_AMBARELLA_CRYPTOCHIP_LIBRARY_FROM_SOURCE
 	help
 		Build Cryptochip Library from source code.
 
+config BUILD_AMBARELLA_UNIQUEID_PUF_BPP
+	bool "Build Ambarella Unique ID based on PUF BPP"
+	select BUILD_AMBARELLA_LW_CRYPTOGRAPHY
+	default n
+	help
+		Build Ambarella Unique ID, based on PUF BPP (Bad Pixel Pattern).
+
 config BUILD_AMBARELLA_DIGITAL_WATERMARKER
 	bool "Build Ambarella Digital Watermarker"
 	default n
 	help
 		Build Ambarella Digital Watermarker.
 
-endif
\ No newline at end of file
+endif
diff --git a/cryptochip_library/cryptochip_library_if.h b/cryptochip_library/cryptochip_library_if.h
index 245d38a..aa73613 100644
--- a/cryptochip_library/cryptochip_library_if.h
+++ b/cryptochip_library/cryptochip_library_if.h
@@ -1,17 +1,34 @@
-/*
+/*******************************************************************************
  * cryptochip_library_if.h
  *
  * History:
  *	2015/09/21 - [Zhi He] create file for cryptochip library
  *
- * Copyright (C) 2015 -2025, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #ifndef __CRYPTOCHIP_LIBRARY_IF_H__
 #define __CRYPTOCHIP_LIBRARY_IF_H__
@@ -24,7 +41,7 @@ typedef void* (*TFCCCreateHandle)();
 typedef void (*TFCCDestroyHandle)(void *handle);
 
 typedef int (*TFCCQueryChipStatus)(void *handle, unsigned int *is_config_zone_locked, unsigned int *is_otp_data_zone_locked);
-typedef int (*TFCCQueryConfigZone)(void *handle, unsigned char *p_otp_data, unsigned int *data_size);
+typedef int (*TFCCQueryConfigZone)(void *handle, unsigned char *p_config, unsigned int *data_size);
 typedef int (*TFCCSetOTPZone)(void *handle, unsigned char *p_otp_data, unsigned int data_size);
 typedef int (*TFCCQueryOTPZone)(void *handle, unsigned char *p_otp_data, unsigned int data_size);
 typedef unsigned char * (*TFCCQuerySerialNumber)(void *handle, unsigned int *serial_number_length);
diff --git a/cryptochip_library/make.inc b/cryptochip_library/make.inc
index 2782bca..512e557 100644
--- a/cryptochip_library/make.inc
+++ b/cryptochip_library/make.inc
@@ -1,16 +1,34 @@
-##
+###############################################################################
 ## packages/security/cryptochip_library/make.inc
 ##
 ## History:
 ##    2015/09/22 - [Zhi He] Created file
 ##
-## Copyright (C) 2015-2025, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
+##################################################################################
 
 ifeq ($(BUILD_AMBARELLA_CRYPTOCHIP_LIBRARY), y)
 ifeq ($(BUILD_AMBARELLA_CRYPTOCHIP_LIBRARY_FROM_SOURCE), y)
diff --git a/digital_signature/digital_signature_if.h b/digital_signature/digital_signature_if.h
index eb6036c..c7f2dfa 100644
--- a/digital_signature/digital_signature_if.h
+++ b/digital_signature/digital_signature_if.h
@@ -1,17 +1,34 @@
-/*
+/*******************************************************************************
  * digital_signature_if.h
  *
  * History:
  *	2015/04/03 - [Zhi He] created file
  *
- * Copyright (C) 2015 - 2025, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #ifndef __DIGITAL_SIGNATURE_IF_H__
 #define __DIGITAL_SIGNATURE_IF_H__
diff --git a/digital_signature/digital_signature_native.cpp b/digital_signature/digital_signature_native.cpp
index 3ecede6..2a2e588 100644
--- a/digital_signature/digital_signature_native.cpp
+++ b/digital_signature/digital_signature_native.cpp
@@ -1,17 +1,34 @@
-/*
+/*******************************************************************************
  * digital_signature_native.cpp
  *
  * History:
  *	2015/09/10 - [Zhi He] created file
  *
- * Copyright (C) 2015 - 2025, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include <stdio.h>
 #include <string.h>
@@ -27,55 +44,18 @@
 
 #include "cryptography_if.h"
 
-#define DRSA_KEY_SIZE 1024
-
-#if 0
-static int __sw_random_generator(void* context, unsigned char* output, unsigned int output_len)
-{
-    static unsigned char seed1 = 29, seed2 = 43, seed3 = 17, seed4 = 97;
-
-#ifdef BUILD_OS_WINDOWS
-    SYSTEMTIME wtm1, wtm2;
-    GetLocalTime(&wtm1);
-    memcpy(output, &wtm1, sizeof(wtm1));
-    Sleep(wtm1.wMilliseconds & 128);
-    memcpy(output + sizeof(wtm1), &wtm2, sizeof(wtm2));
-    GetLocalTime(&wtm2);
-    seed1 += ((unsigned int)(wtm2.wMilliseconds - wtm1.wMilliseconds)) & 0xf;
-    seed2 += (((unsigned int)(wtm2.wMilliseconds - wtm1.wMilliseconds)) >> 2) & 0xf;
-    seed3 += (((unsigned int)(wtm2.wMilliseconds - wtm1.wMilliseconds)) >> 4) & 0xf;
-    seed4 += (((unsigned int)(wtm2.wMilliseconds - wtm1.wMilliseconds)) >> 8) & 0xf;
-#else
-    struct timeval tv1, tv2;
-    gettimeofday(&tv1, NULL);
-    memcpy(output, &tv1, sizeof(tv1));
-    usleep(10 * tv1.tv_usec);
-    memcpy(output + sizeof(tv1), &tv2, sizeof(tv2));
-    gettimeofday(&tv2, NULL);
-    seed1 += ((unsigned int)(tv2.tv_usec - tv1.tv_usec )) & 0xff;
-    seed2 += (((unsigned int)(tv2.tv_usec - tv1.tv_usec )) >> 4) & 0xff;
-    seed3 += (((unsigned int)(tv2.tv_usec - tv1.tv_usec )) >> 8) & 0xff;
-    seed4 += (((unsigned int)(tv2.tv_usec - tv1.tv_usec )) >> 12) & 0xff;
-#endif
-
-    digest_sha256(output, 32, output + 32);
-    output[0] += output[32] ^ seed1;
-    output[1] += output[33] ^ seed2;
-    output[2] += output[34] ^ seed3;
-    output[3] += output[35] ^ seed4;
-    output[4] += output[36] ^ seed1;
-    output[5] += output[37] ^ seed2;
-    output[6] += output[38] ^ seed3;
-    output[7] += output[39] ^ seed4;
+#define DMAX_RSA_KEY_SIZE 2048
 
-    pseudo_random_scamble_sequence(output, output_len);
+#define D_DUMP_FOR_DEBUG
 
-    seed1 += 163;
-    seed2 += 59;
-    seed3 += 101;
-    seed4 += 23;
-
-    return 0;
+#ifdef D_DUMP_FOR_DEBUG
+static void __print_binary(unsigned char *p, unsigned int len)
+{
+    while (len >= 8) {
+        printf("0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x,\n", p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
+        p += 8;
+        len -= 8;
+    }
 }
 #endif
 
@@ -118,7 +98,10 @@ int generate_rsa_key(char* output_file, int bits, int pubexp, int key_format)
         printf("bad params, output_file %p, bits %d, pubexp %d\n", output_file, bits, pubexp);
         return (-1);
     }
-    bits = DRSA_KEY_SIZE;
+
+    if (bits > DMAX_RSA_KEY_SIZE) {
+        bits = DMAX_RSA_KEY_SIZE;
+    }
 
     rsa_init(&rsa, RSA_PKCS_V15, 0);
 
@@ -135,6 +118,7 @@ int generate_rsa_key(char* output_file, int bits, int pubexp, int key_format)
         return (-2);
     }
 
+    ret = big_number_write_file("RN = ", &rsa.RN, 16, f);
     ret = big_number_write_file("N = " , &rsa.N , 16, f);
     ret = big_number_write_file("E = " , &rsa.E , 16, f);
     ret = big_number_write_file("D = " , &rsa.D , 16, f);
@@ -171,6 +155,7 @@ int get_public_rsa_key(char* output_file, char* input_file)
         return (-2);
     }
 
+    ret = big_number_read_file(&rsa.RN , 16, f);
     ret = big_number_read_file(&rsa.N , 16, f);
     ret = big_number_read_file(&rsa.E , 16, f);
     if (ret) {
@@ -187,6 +172,7 @@ int get_public_rsa_key(char* output_file, char* input_file)
         return (-3);
     }
 
+    ret = big_number_write_file("RN = ", &rsa.RN, 16, f);
     ret = big_number_write_file("N = ", &rsa.N, 16, f);
     ret = big_number_write_file("E = ", &rsa.E, 16, f);
 
@@ -201,7 +187,7 @@ int signature_file(char* file, char* digital_signature, char* keyfile, int sha_t
     FILE *f = NULL;
     rsa_context_t rsa;
     unsigned char digest[32] = {0};
-    unsigned char buf[DRSA_KEY_SIZE] = {0};
+    unsigned char buf[DMAX_RSA_KEY_SIZE] = {0};
 
     if ((!file) || (!digital_signature) || (!keyfile) || (SHA_TYPE_SHA256 != sha_type)) {
         printf("bad params, file %p, digital_signature %p, keyfile %p, sha_type %d\n", file, digital_signature, keyfile, sha_type);
@@ -216,6 +202,7 @@ int signature_file(char* file, char* digital_signature, char* keyfile, int sha_t
         return (-2);
     }
 
+    ret = big_number_read_file(&rsa.RN, 16, f);
     ret = big_number_read_file(&rsa.N , 16, f);
     ret = big_number_read_file(&rsa.E , 16, f);
     ret = big_number_read_file(&rsa.D , 16, f);
@@ -241,12 +228,22 @@ int signature_file(char* file, char* digital_signature, char* keyfile, int sha_t
         return (-4);
     }
 
+#ifdef D_DUMP_FOR_DEBUG
+    printf("hash\n");
+    __print_binary(digest, 32);
+#endif
+
     ret = rsa_sha256_sign(&rsa, digest, buf);
     if (ret) {
         printf("rsa_sha256_sign fail, ret %d\n", ret);
         return (-5);
     }
 
+#ifdef D_DUMP_FOR_DEBUG
+    printf("signature\n");
+    __print_binary(buf, 256);
+#endif
+
     f = fopen(digital_signature, "wb+");
     if (!f) {
         printf("open signature file(%s) fail\n", digital_signature);
@@ -263,7 +260,7 @@ int verify_signature(char* file, char* digital_signature, char* keyfile, int sha
     int ret = 0;
     FILE *f = NULL;
     unsigned char digest[32] = {0};
-    unsigned char buf[DRSA_KEY_SIZE];
+    unsigned char buf[DMAX_RSA_KEY_SIZE];
     rsa_context_t rsa;
 
     if ((!file) || (!digital_signature) || (!keyfile) || (SHA_TYPE_SHA256 != sha_type)) {
@@ -280,6 +277,7 @@ int verify_signature(char* file, char* digital_signature, char* keyfile, int sha
 
     rsa_init(&rsa, RSA_PKCS_V15, 0);
 
+    ret = big_number_read_file(&rsa.RN, 16, f);
     ret = big_number_read_file(&rsa.N , 16, f);
     ret = big_number_read_file(&rsa.E , 16, f);
 
@@ -290,19 +288,33 @@ int verify_signature(char* file, char* digital_signature, char* keyfile, int sha
     ret = digest_sha256_file(file, digest);
     if (ret) {
         printf("digest_sha256_file(%s) fail\n", file);
+        rsa_free(&rsa);
         return (-3);
     }
 
+#ifdef D_DUMP_FOR_DEBUG
+    printf("hash\n");
+    __print_binary(digest, 32);
+#endif
+
     f = fopen(digital_signature, "rb");
     if (!f) {
         printf("open signature file(%s) fail\n", digital_signature);
+        rsa_free(&rsa);
         return (-4);
     }
-    ret = fread(buf, 1, DRSA_KEY_SIZE, f);
+    ret = fread(buf, 1, DMAX_RSA_KEY_SIZE / 8, f);
     fclose(f);
 
+#ifdef D_DUMP_FOR_DEBUG
+    printf("signature\n");
+    __print_binary(buf, 256);
+#endif
+
     ret = rsa_sha256_verify(&rsa, digest, buf);
 
+    rsa_free(&rsa);
+
     return ret;
 }
 
diff --git a/digital_signature/digital_signature_openssl.cpp b/digital_signature/digital_signature_openssl.cpp
index 324bb19..de01daf 100644
--- a/digital_signature/digital_signature_openssl.cpp
+++ b/digital_signature/digital_signature_openssl.cpp
@@ -1,17 +1,34 @@
-/*
+/*******************************************************************************
  * digital_signature_openssl.cpp
  *
  * History:
  *	2015/04/03 - [Zhi He] created file
  *
- * Copyright (C) 2015 - 2025, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include <stdio.h>
 #include <string.h>
diff --git a/digital_signature/make.inc b/digital_signature/make.inc
index 02c815c..836465d 100644
--- a/digital_signature/make.inc
+++ b/digital_signature/make.inc
@@ -1,16 +1,34 @@
-##
+###############################################################################
 ## packages/security/digital_signature/make.inc
 ##
 ## History:
 ##    2015/04/03 - [Zhi He] Created file
 ##
-## Copyright (C) 2015-2025, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
+##################################################################################
 
 ifeq ($(BUILD_AMBARELLA_DIGITAL_SIGNATURE), y)
 
diff --git a/digital_signature/test_convert_openssl_key.cpp b/digital_signature/test_convert_openssl_key.cpp
new file mode 100644
index 0000000..1717791
--- /dev/null
+++ b/digital_signature/test_convert_openssl_key.cpp
@@ -0,0 +1,388 @@
+/*******************************************************************************
+ * test_convert_openssl_key.cpp
+ *
+ * History:
+ *  2016/12/01 - [Zhi He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <openssl/bio.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/objects.h>
+#include <openssl/x509.h>
+#include <openssl/pem.h>
+#include <openssl/hmac.h>
+#include <openssl/engine.h>
+
+typedef struct
+{
+    unsigned char convert_public_key;
+    unsigned char convert_private_key;
+    unsigned char reserved1;
+    unsigned char reserved2;
+
+    char *input_file;
+    char *output_file;
+} tcok_context;
+
+static char * __remove_heading_zerozero(char *p, int length)
+{
+    char * t = p;
+    while (2 < length) {
+        if ((t[0] == '0') && t[1] == '0') {
+            t += 2;
+            length -= 2;
+            continue;
+        }
+        break;
+    }
+    return t;
+}
+
+static int __dump_bignumber(char *hex_text, int max_string_buffer_length, BIGNUM *big_num)
+{
+    const char hex_text_table[] = "0123456789ABCDEF";
+    int i = big_num->dmax - 1;
+    BN_ULONG value = 0;
+    char *p_cur = hex_text;
+    int string_length = 0;
+
+#if __WORDSIZE == 64
+    i = big_num->dmax - 1;
+    while (0 <= i) {
+        value = big_num->d[i];
+        p_cur[0] = hex_text_table[(value >> 60) & 0x0f];
+        p_cur[1] = hex_text_table[(value >> 56) & 0x0f];
+        p_cur[2] = hex_text_table[(value >> 52) & 0x0f];
+        p_cur[3] = hex_text_table[(value >> 48) & 0x0f];
+        p_cur[4] = hex_text_table[(value >> 44) & 0x0f];
+        p_cur[5] = hex_text_table[(value >> 40) & 0x0f];
+        p_cur[6] = hex_text_table[(value >> 36) & 0x0f];
+        p_cur[7] = hex_text_table[(value >> 32) & 0x0f];
+        p_cur[8] = hex_text_table[(value >> 28) & 0x0f];
+        p_cur[9] = hex_text_table[(value >> 24) & 0x0f];
+        p_cur[10] = hex_text_table[(value >> 20) & 0x0f];
+        p_cur[11] = hex_text_table[(value >> 16) & 0x0f];
+        p_cur[12] = hex_text_table[(value >> 12) & 0x0f];
+        p_cur[13] = hex_text_table[(value >> 8) & 0x0f];
+        p_cur[14] = hex_text_table[(value >> 4) & 0x0f];
+        p_cur[15] = hex_text_table[(value) & 0x0f];
+        p_cur += 16;
+        string_length += 16;
+        i --;
+        if ((string_length + 16) > max_string_buffer_length) {
+            printf("must have errors, the length exceed!\n");
+            break;
+        }
+    }
+#else
+    i = big_num->dmax - 1;
+    while (0 <= i) {
+        value = big_num->d[i];
+        p_cur[0] = hex_text_table[(value >> 28) & 0x0f];
+        p_cur[1] = hex_text_table[(value >> 24) & 0x0f];
+        p_cur[2] = hex_text_table[(value >> 20) & 0x0f];
+        p_cur[3] = hex_text_table[(value >> 16) & 0x0f];
+        p_cur[4] = hex_text_table[(value >> 12) & 0x0f];
+        p_cur[5] = hex_text_table[(value >> 8) & 0x0f];
+        p_cur[6] = hex_text_table[(value >> 4) & 0x0f];
+        p_cur[7] = hex_text_table[(value) & 0x0f];
+        p_cur += 8;
+        string_length += 8;
+        i --;
+        if ((string_length + 8) > max_string_buffer_length) {
+            printf("must have errors, the length exceed!\n");
+            break;
+        }
+    }
+#endif
+
+    return string_length;
+}
+
+static int dump_rsa_pem_privkey(const char *file, const char *output_file)
+{
+    int ret = 0;
+    BIO *key = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    if ((file == NULL) || (output_file == NULL)) {
+        printf("[error]: no keyfile specified\n");
+        return (-1);
+    }
+
+    key = BIO_new(BIO_s_file());
+    if (key == NULL) {
+        printf("[error]: no memory, BIO_new fail\n");
+        return (-2);
+    }
+
+    ret = BIO_read_filename(key, file);
+    if (ret <= 0) {
+        printf("[error]: BIO_read_filename fail\n");
+        return (-3);
+    }
+
+    pkey = PEM_read_bio_PrivateKey(key, NULL, NULL, NULL);
+
+    BIO_free(key);
+
+    if (pkey) {
+        char max_string_buffer[2048 + 2] = {0};
+        int string_length = 0;
+        char *p_num = NULL;
+
+        FILE *p_out_file = fopen(output_file, "wt+");
+        if (p_out_file) {
+            fprintf(p_out_file, "N = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->n);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "E = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->e);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "D = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->d);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "P = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->p);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "Q = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->q);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "DP = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->dmp1);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "DQ = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->dmq1);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "QP = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->iqmp);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fflush(p_out_file);
+            fclose(p_out_file);
+            p_out_file = NULL;
+        }
+
+        EVP_PKEY_free(pkey);
+        pkey = NULL;
+    } else {
+        printf("[error]: PEM_read_bio_PrivateKey fail\n");
+        return (-4);
+    }
+
+    return 0;
+}
+
+static int dump_rsa_pem_pubkey(const char *file, const char *output_file)
+{
+    int ret = 0;
+    BIO *key = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    if ((file == NULL) || (output_file == NULL)) {
+        printf("[error]: no keyfile specified\n");
+        return (-1);
+    }
+
+    key = BIO_new(BIO_s_file());
+    if (key == NULL) {
+        printf("[error]: no memory, BIO_new fail\n");
+        return (-2);
+    }
+
+    ret = BIO_read_filename(key, file);
+    if (ret <= 0) {
+        printf("[error]: BIO_read_filename fail\n");
+        return (-3);
+    }
+
+    pkey = PEM_read_bio_PUBKEY(key, NULL, NULL, NULL);
+
+    BIO_free(key);
+
+    if (pkey) {
+        char max_string_buffer[2048 + 2] = {0};
+        int string_length = 0;
+        char *p_num = NULL;
+
+        FILE *p_out_file = fopen(output_file, "wt+");
+        if (p_out_file) {
+            fprintf(p_out_file, "N = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->n);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fprintf(p_out_file, "E = ");
+            string_length = __dump_bignumber((char *)max_string_buffer, 2048, pkey->pkey.rsa->e);
+            max_string_buffer[string_length] = 0x0;
+            p_num = __remove_heading_zerozero(max_string_buffer, string_length);
+            fprintf(p_out_file, "%s", p_num);
+            fprintf(p_out_file, "\r\n");
+
+            fflush(p_out_file);
+            fclose(p_out_file);
+            p_out_file = NULL;
+        }
+
+        EVP_PKEY_free(pkey);
+        pkey = NULL;
+    } else {
+        printf("[error]: PEM_read_bio_PUBKEY fail\n");
+        return (-4);
+    }
+
+    return 0;
+}
+
+static void __tcok_show_usage()
+{
+    printf("test_convert_openssl_key usage:\n");
+    printf("\t--convert-private convert private key\n");
+    printf("\t--convert-public convert public key\n");
+    printf("\t-i [file name] input file name, (pem)\n");
+    printf("\t-o [file name] output file name, plaint text\n");
+
+    printf("\t--help: show usage\n");
+}
+
+static int __tcok_init_params(int argc, char **argv, tcok_context* context)
+{
+    int i = 0;
+
+    for (i = 1; i < argc; i ++) {
+        if (!strcmp("-i", argv[i])) {
+            if ((i + 1) < argc) {
+                context->input_file = argv[i + 1];
+                printf("[input file]: %s.\n", context->input_file);
+            } else {
+                printf("[input argument error]: '-i', should follow with input file name, argc %d, i %d.\n", argc, i);
+                return (-1);
+            }
+            i ++;
+        } else if (!strcmp("-o", argv[i])) {
+            if ((i + 1) < argc) {
+                context->output_file = argv[i + 1];
+                printf("[output file]: %s.\n", context->output_file);
+            } else {
+                printf("[input argument error]: '-o', should follow with output file name, argc %d, i %d.\n", argc, i);
+                return (-2);
+            }
+            i ++;
+        } else if (!strcmp("--convert-private", argv[i])) {
+            context->convert_private_key = 1;
+        } else if (!strcmp("--convert-public", argv[i])) {
+            context->convert_public_key = 1;
+        } else if (!strcmp("--help", argv[i])) {
+            __tcok_show_usage();
+            return 1;
+        } else {
+            printf("[input argument error]: unknwon input params, [%d][%s]\n", i, argv[i]);
+            return (-20);
+        }
+    }
+
+    return 0;
+}
+
+int main(int argc, char** argv)
+{
+    tcok_context context;
+    memset(&context, 0x0, sizeof(context));
+
+    if (argc < 2) {
+        __tcok_show_usage();
+        return 1;
+    }
+
+    int ret = __tcok_init_params(argc, argv, &context);
+    if (0 > ret) {
+        return ret;
+    }
+
+    if ((!context.input_file) || (!context.output_file)) {
+        printf("input or output file not specidied\n");
+        return (-1);
+    }
+
+    if (1 == context.convert_private_key) {
+        ret = dump_rsa_pem_privkey(context.input_file, context.output_file);
+        if (ret) {
+            printf("[error]: dump_rsa_pem_privkey fail, ret %d\n", ret);
+            return ret;
+        }
+    } else if (1 == context.convert_public_key) {
+        ret = dump_rsa_pem_pubkey(context.input_file, context.output_file);
+        if (ret) {
+            printf("[error]: dump_rsa_pem_pubkey fail, ret %d\n", ret);
+            return ret;
+        }
+    } else {
+        printf("[error]: should set mode, either convert private key, or convert public key\n");
+        return (-10);
+    }
+
+    return 0;
+}
+
diff --git a/digital_signature/test_digital_signature.cpp b/digital_signature/test_digital_signature.cpp
new file mode 100644
index 0000000..7a8cc7a
--- /dev/null
+++ b/digital_signature/test_digital_signature.cpp
@@ -0,0 +1,197 @@
+/*******************************************************************************
+ * test_digital_signature.cpp
+ *
+ * History:
+ *  2015/04/03 - [Zhi He] created file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "digital_signature_if.h"
+
+#define SU_MAX_FILE_NAME_LENGTH 512
+
+typedef struct
+{
+    unsigned char mode;
+    unsigned char reserved0, reserved1, reserved2;
+
+    char rsa_private_key_file[SU_MAX_FILE_NAME_LENGTH];
+    char rsa_public_key_file[SU_MAX_FILE_NAME_LENGTH];
+    int rsa_bits;
+    int rsa_exp;
+
+    char file[SU_MAX_FILE_NAME_LENGTH];
+    char signature_file[SU_MAX_FILE_NAME_LENGTH];
+} su_context;
+
+static void show_usage()
+{
+    printf("test_digital_signature usage:\n");
+    printf("\t--genrsakey [key file name base]\n");
+    printf("\t--sign [file name] [private key file name] [signature file]\n");
+    printf("\t--verifysign [file name] [public key file name] [signature file]\n");
+
+    printf("\t--rsabits [bits]\n");
+    printf("\t--rsaexp [exp]\n");
+
+    printf("\t--help: show usage\n");
+}
+
+static int init_params(int argc, char **argv, su_context* context)
+{
+    int i = 0;
+    int val = 0;
+
+    for (i = 1; i < argc; i ++) {
+        if (!strcmp("--genrsakey", argv[i])) {
+            if ((i + 1) < argc) {
+                snprintf(context->rsa_private_key_file, SU_MAX_FILE_NAME_LENGTH, "%s_private.pem", argv[i + 1]);
+                snprintf(context->rsa_public_key_file, SU_MAX_FILE_NAME_LENGTH, "%s_public.pem", argv[i + 1]);
+                context->mode = 1;
+                printf("[input argument]: '--genrsakey': (private %s, public %s).\n", context->rsa_private_key_file, context->rsa_public_key_file);
+            } else {
+                printf("[input argument error]: '--genrsakey', should follow with file name base, argc %d, i %d.\n", argc, i);
+                return (-1);
+            }
+            i ++;
+        } else if (!strcmp("--rsabits", argv[i])) {
+            if (((i + 1) < argc) && (1 == sscanf(argv[i + 1], "%d", &val))) {
+                context->rsa_bits = val;
+                printf("[input argument]: '--rsabits': (%d).\n", context->rsa_bits);
+            } else {
+                printf("[input argument error]: '--rsabits', should follow with integer(bits), argc %d, i %d.\n", argc, i);
+                return (-2);
+            }
+            i ++;
+        } else if (!strcmp("--rsaexp", argv[i])) {
+            if (((i + 1) < argc) && (1 == sscanf(argv[i + 1], "%d", &val))) {
+                context->rsa_exp = val;
+                printf("[input argument]: '--rsaexp': (%d).\n", context->rsa_exp);
+            } else {
+                printf("[input argument error]: '--rsaexp', should follow with integer(exp), argc %d, i %d.\n", argc, i);
+                return (-3);
+            }
+            i ++;
+        } else if (!strcmp("--sign", argv[i])) {
+            if (((i + 3) < argc)) {
+                snprintf(context->file, SU_MAX_FILE_NAME_LENGTH, "%s", argv[i + 1]);
+                snprintf(context->rsa_private_key_file, SU_MAX_FILE_NAME_LENGTH, "%s", argv[i + 2]);
+                snprintf(context->signature_file, SU_MAX_FILE_NAME_LENGTH, "%s", argv[i + 3]);
+                context->mode = 2;
+                printf("[input argument]: '--sign': file (%s), key file (%s), signature file (%s).\n", context->file, context->rsa_private_key_file, context->signature_file);
+            } else {
+                printf("[input argument error]: '--sign', should follow with three filenames: [file], [private key file], [signature file], argc %d, i %d.\n", argc, i);
+                return (-4);
+            }
+            i += 3;
+        } else if (!strcmp("--verifysign", argv[i])) {
+            if (((i + 3) < argc)) {
+                snprintf(context->file, SU_MAX_FILE_NAME_LENGTH, "%s", argv[i + 1]);
+                snprintf(context->rsa_public_key_file, SU_MAX_FILE_NAME_LENGTH, "%s", argv[i + 2]);
+                snprintf(context->signature_file, SU_MAX_FILE_NAME_LENGTH, "%s", argv[i + 3]);
+                context->mode = 3;
+                printf("[input argument]: '--verifysign': file (%s), key file (%s), signature file (%s).\n", context->file, context->rsa_public_key_file, context->signature_file);
+            } else {
+                printf("[input argument error]: '--verifysign', should follow with three filenames: [file], [public key file], [signature file], argc %d, i %d.\n", argc, i);
+                return (-5);
+            }
+            i += 3;
+        } else if (!strcmp("--help", argv[i])) {
+            show_usage();
+            return 1;
+        } else {
+            printf("[input argument error]: unknwon input params, [%d][%s]\n", i, argv[i]);
+            return (-20);
+        }
+    }
+
+    return 0;
+}
+
+int main(int argc, char** argv)
+{
+    su_context context;
+    memset(&context, 0x0, sizeof(context));
+
+    if (argc < 2) {
+        show_usage();
+        return 1;
+    }
+
+    int ret = init_params(argc, argv, &context);
+    if (0 > ret) {
+        return ret;
+    }
+
+    if (!context.rsa_bits) {
+        context.rsa_bits = 2048;
+    }
+
+    if (!context.rsa_exp) {
+        context.rsa_exp = 65537;
+    }
+
+    printf("rsa bits %d, exp %d\n", context.rsa_bits, context.rsa_exp);
+
+    if (1 == context.mode) {
+        ret = generate_rsa_key(context.rsa_private_key_file, context.rsa_bits, context.rsa_exp, KEY_FORMAT_PEM);
+        if (SU_ECODE_OK != ret) {
+            printf("[error]: generate_rsa_key fail, ret %d\n", ret);
+            return ret;
+        }
+        ret = get_public_rsa_key(context.rsa_public_key_file, context.rsa_private_key_file);
+        if (SU_ECODE_OK != ret) {
+            printf("[error]: get_public_rsa_key fail, ret %d\n", ret);
+            return ret;
+        }
+        printf("RSA key pair generate [%s, %s] done\n", context.rsa_private_key_file, context.rsa_public_key_file);
+    } else if (2 == context.mode) {
+        ret = signature_file(context.file, context.signature_file, context.rsa_private_key_file, SHA_TYPE_SHA256);
+        if (SU_ECODE_OK != ret) {
+            printf("[error]: signature_file fail, ret %d\n", ret);
+            return ret;
+        }
+        printf("Signature [%s] done\n", context.signature_file);
+    } else if (3 == context.mode) {
+        ret = verify_signature(context.file, context.signature_file, context.rsa_public_key_file, SHA_TYPE_SHA256);
+        if (SU_ECODE_OK != ret) {
+            printf("[error]: verify_signature fail, ret %d\n", ret);
+            return ret;
+        }
+        printf("Verify signature OK\n");
+    } else {
+        printf("[error]: should set mode, either generate rsa key, signature or verify signatrue\n");
+        return (-10);
+    }
+
+    return 0;
+}
+
diff --git a/lw_cryptography/code.list b/lw_cryptography/code.list
new file mode 100644
index 0000000..a86daba
--- /dev/null
+++ b/lw_cryptography/code.list
@@ -0,0 +1,3 @@
+include
+src
+unit_test
\ No newline at end of file
diff --git a/lw_cryptography/include/cryptography_if.h b/lw_cryptography/include/cryptography_if.h
index b6da531..18048b4 100644
--- a/lw_cryptography/include/cryptography_if.h
+++ b/lw_cryptography/include/cryptography_if.h
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * cryptography_if.h
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #ifndef __CRYPTOGRAPHY_IF_H__
 #define __CRYPTOGRAPHY_IF_H__
@@ -24,6 +42,8 @@ extern "C" {
 #define NULL ((void *) 0x0)
 #endif
 
+#define DCONFIG_AES_USE_PRECALCULATED_TABLE
+
 #define DCRYPT_LOG printf
 
 #define DAMBOOT_PUT_STRING putstr
@@ -39,6 +59,7 @@ enum {
     CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL = -0x05,
     CRYPTO_ECODE_GENERATE_KEY_FAIL = -0x06,
     CRYPTO_ECODE_SIGNATURE_INVALID_PADDING = -0x07,
+    CRYPTO_ECODE_SIGNATURE_INVALID_LENGTH = -0x08,
 
     CRYPTO_ECODE_INTERNAL_ERROR = -0x10,
     CRYPTO_ECODE_ERROR_NO_MEMORY = -0x11,
@@ -62,24 +83,20 @@ enum {
     CRYPTO_ECODE_OID_NOT_FOUND = -0x40,
 };
 
-typedef enum {
+enum {
     CRYPTO_SHA_TYPE_NONE = 0x0,
     CRYPTO_SHA_TYPE_SHA1 = 0x1,
     CRYPTO_SHA_TYPE_SHA224 = 0x2,
     CRYPTO_SHA_TYPE_SHA256 = 0x3,
     CRYPTO_SHA_TYPE_SHA384 = 0x4,
     CRYPTO_SHA_TYPE_SHA512 = 0x5,
-} sha_type_t;
+};
 
 #define DCRYPTO_SHA1_DIGEST_LENGTH 20
 #define DCRYPTO_SHA256_DIGEST_LENGTH 32
 #define DCRYPTO_SHA384_DIGEST_LENGTH 48
 #define DCRYPTO_SHA512_DIGEST_LENGTH 64
 
-enum {
-    CRYPTO_PKEY_TYPE_RSA = 0x1,
-};
-
 #define D_CLEAN_IF_FAILED(f) do { if ((ret = f) != CRYPTO_ECODE_OK) goto cleanup; } while(0)
 
 #define D_BIG_NUMBER_MAX_LIMBS                             10000
@@ -92,10 +109,45 @@ enum {
 #define RSA_PKCS_V15    0
 #define RSA_PKCS_V21    1
 
+
+#define D_DISABLE_ASM
+
+#ifndef D_DISABLE_ASM
+
+#if (defined(_MSC_VER) && defined(_M_AMD64))
+    typedef  long long TSINT;
+    typedef unsigned long long TUINT;
+    #define DHAVE_INT_64
+#else
+    #define DHAVE_DOUBLE_LONG_INT
+#if (defined(__GNUC__) && (defined(__amd64__) || defined(__x86_64__) || defined(__ia64__) || (defined(__arch64__))))
+    typedef  long long TSINT;
+    typedef unsigned long long TUINT;
+    typedef unsigned int TUDBL __attribute__((mode(TI)));
+    #define DHAVE_INT_64
+#else
+    typedef int TSINT;
+    typedef unsigned int TUINT;
+    typedef unsigned long long TUDBL;
+#endif
+#endif
+
+#else
+
+    typedef int TSINT;
+    typedef unsigned int TUINT;
+
+#if __WORDSIZE == 64
+    typedef unsigned long TUDBL;
+    #define DHAVE_DOUBLE_LONG_INT
+#endif
+
+#endif
+
 typedef struct {
     int s;
     unsigned int n;
-    unsigned int *p;
+    TUINT *p;
 } big_number_t;
 
 typedef struct {
@@ -123,6 +175,56 @@ typedef struct {
     int hash_id;
 } rsa_context_t;
 
+enum {
+    CRYPTO_ECC_DP_INVALID = 0,
+    CRYPTO_ECC_DP_SECP192R1,
+    CRYPTO_ECC_DP_SECP224R1,
+    CRYPTO_ECC_DP_SECP256R1,
+    CRYPTO_ECC_DP_SECP384R1,
+    CRYPTO_ECC_DP_SECP521R1,
+    CRYPTO_ECC_DP_BP256R1,
+    CRYPTO_ECC_DP_BP384R1,
+    CRYPTO_ECC_DP_BP512R1,
+    CRYPTO_ECC_DP_SECP192K1,
+    CRYPTO_ECC_DP_SECP224K1,
+    CRYPTO_ECC_DP_SECP256K1,
+};
+
+typedef struct {
+    big_number_t X;
+    big_number_t Y;
+    big_number_t Z;
+} ecc_point_t;
+
+typedef struct {
+    int id;
+    big_number_t P;
+    big_number_t A;
+    big_number_t B;
+    ecc_point_t G;
+    big_number_t N;
+    unsigned int pbits;
+    unsigned int nbits;
+    int (*modp)(big_number_t *); //for future optimization
+    ecc_point_t *T;
+    unsigned int T_size;
+} ecc_group_t;
+
+typedef struct {
+    ecc_group_t group;
+    big_number_t d;
+    ecc_point_t Q;
+} ecc_keypair_t;
+
+typedef struct
+{
+    ecc_group_t group;
+    big_number_t d;
+    ecc_point_t Q;
+    big_number_t r;
+    big_number_t s;
+} ecdsa_context_t;
+
 void pseudo_random_scamble_sequence(unsigned char* p, unsigned int len);
 
 void digest_sha256(const unsigned char* message, unsigned int len, unsigned char* digest);
@@ -143,7 +245,7 @@ void digest_md5_final(void* ctx, unsigned char* digest);
 #endif
 
 void rsa_init(rsa_context_t* ctx, int padding, int hash_id);
-void rsa_free(rsa_context_t* ctx );
+void rsa_free(rsa_context_t* ctx);
 int rsa_check_pubkey(const rsa_context_t* ctx);
 int rsa_check_privkey(const rsa_context_t* ctx);
 int rsa_check_key_pair(const rsa_context_t* pub, const rsa_context_t* prv);
@@ -151,6 +253,29 @@ int rsa_gen_key(rsa_context_t* ctx, int (*f_rng)(void*, unsigned char*, unsigned
 int rsa_sha256_sign(rsa_context_t* ctx, const unsigned char* hash, unsigned char* sig);
 int rsa_sha256_verify(rsa_context_t* ctx, const unsigned char* hash, const unsigned char* sig);
 
+void ecdsa_init(ecdsa_context_t *ctx);
+void ecdsa_free(ecdsa_context_t *ctx);
+int ecc_setup_group(int ecc_dp, ecc_group_t *group);
+int ecc_check_pubkey(const ecc_group_t *group, const ecc_point_t *pt);
+int ecc_check_privkey(const ecc_group_t *group, const big_number_t *d);
+int ecc_check_key_pair(const ecc_keypair_t *pub, const ecc_keypair_t *prv);
+int ecc_gen_key(int ecc_dp, ecc_keypair_t *key,
+    int (*f_rng)(void *, unsigned char *, unsigned int), void *p_rng);
+int ecdsa_sign(ecc_group_t *group, big_number_t *r, big_number_t *s,
+    const big_number_t *d, const unsigned char *buf, unsigned int blen,
+    int (*f_rng)(void *, unsigned char *, unsigned int), void *p_rng);
+int ecdsa_verify(ecc_group_t *group,
+    const unsigned char *buf, unsigned int blen,
+    const ecc_point_t *Q, const big_number_t *r, const big_number_t *s);
+int ecdsa_read_asn1_signature(ecdsa_context_t *ctx,
+    const unsigned char *hash, unsigned int hlen,
+    const unsigned char *sig, unsigned int slen);
+int ecdsa_write_asn1_signature(ecdsa_context_t *ctx,
+    const unsigned char *hash, unsigned int hlen,
+    unsigned char *sig, unsigned int *slen,
+    int (*f_rng)(void *, unsigned char *, unsigned int),
+    void *p_rng);
+
 extern int big_number_read_string(big_number_t* X, int radix, const char* s);
 extern int big_number_write_string(const big_number_t* X, int radix, char* s, unsigned int* slen);
 
@@ -166,6 +291,60 @@ extern unsigned int big_number_size(const big_number_t* X);
 extern unsigned int big_number_msb(const big_number_t *X);
 
 
+typedef struct {
+    unsigned int round;
+    unsigned int p_round_key[72];
+    unsigned int cur_position;
+} aes_context_t;
+
+aes_context_t *aes_init();
+void aes_destroy(aes_context_t *ctx);
+
+int aes_set_encrypt_key(aes_context_t *ctx, const unsigned char *key, unsigned int key_length);
+int aes_set_decrypt_key(aes_context_t *ctx, const unsigned char *key, unsigned int key_length);
+
+//ecb mode
+int aes_ecb_encrypt(aes_context_t *ctx, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_ecb_decrypt(aes_context_t *ctx, unsigned char *input, unsigned char *output, unsigned int data_length);
+
+//ctr mode
+int aes_ctr_crypt(aes_context_t *ctx, unsigned char *p_nonce, unsigned char *input, unsigned char *output, unsigned int data_length);
+
+//cbc mode
+int aes_cbc_encrypt(aes_context_t *ctx, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_cbc_decrypt(aes_context_t *ctx, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length);
+
+
+//one shot api
+int aes_ecb_encrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_ecb_decrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_ctr_crypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *p_nonce, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_cbc_encrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length);
+int aes_cbc_decrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length);
+
+
+//internal define
+//ASN1
+#define ASN1_BOOLEAN                 0x01
+#define ASN1_INTEGER                 0x02
+#define ASN1_BIT_STRING              0x03
+#define ASN1_OCTET_STRING            0x04
+#define ASN1_NULL                    0x05
+#define ASN1_OID                     0x06
+#define ASN1_UTF8_STRING             0x0C
+#define ASN1_SEQUENCE                0x10
+#define ASN1_SET                     0x11
+#define ASN1_PRINTABLE_STRING        0x13
+#define ASN1_T61_STRING              0x14
+#define ASN1_IA5_STRING              0x16
+#define ASN1_UTC_TIME                0x17
+#define ASN1_GENERALIZED_TIME        0x18
+#define ASN1_UNIVERSAL_STRING        0x1C
+#define ASN1_BMP_STRING              0x1E
+#define ASN1_PRIMITIVE               0x00
+#define ASN1_CONSTRUCTED             0x20
+#define ASN1_CONTEXT_SPECIFIC        0x80
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lw_cryptography/src/aes.c b/lw_cryptography/src/aes.c
new file mode 100644
index 0000000..df3db06
--- /dev/null
+++ b/lw_cryptography/src/aes.c
@@ -0,0 +1,1239 @@
+/*******************************************************************************
+ * aes.c
+ *
+ * History:
+ *  2017/02/24 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include "cryptography_if.h"
+
+#ifndef DNOT_INCLUDE_C_HEADER
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#else
+#include <bldfunc.h>
+#endif
+
+#ifdef DCONFIG_AES_USE_PRECALCULATED_TABLE
+
+//precalculated tables from aes_precalc_table.c
+
+static const unsigned char gcsForwardSBox[256] = {
+    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
+};
+
+
+static const unsigned char gcsReverseSBox[256] = {
+    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
+    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
+    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
+    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
+    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
+    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
+    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
+    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
+    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
+    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
+    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
+    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
+    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
+    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
+    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
+    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
+};
+
+
+static const unsigned int gcsForwardTable0[256] = {
+    0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,
+    0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,
+    0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,
+    0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,
+    0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,
+    0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,
+    0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,
+    0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,
+    0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,
+    0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,
+    0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,
+    0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,
+    0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,
+    0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,
+    0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,
+    0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,
+    0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,
+    0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,
+    0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,
+    0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,
+    0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,
+    0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,
+    0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,
+    0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,
+    0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,
+    0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,
+    0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,
+    0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,
+    0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,
+    0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,
+    0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,
+    0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,
+    0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,
+    0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,
+    0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,
+    0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,
+    0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,
+    0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,
+    0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,
+    0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,
+    0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,
+    0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,
+    0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,
+    0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,
+    0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,
+    0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,
+    0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,
+    0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,
+    0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,
+    0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,
+    0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,
+    0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,
+    0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,
+    0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,
+    0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,
+    0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,
+    0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,
+    0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,
+    0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,
+    0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,
+    0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,
+    0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,
+    0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,
+    0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c,
+};
+
+
+static const unsigned int gcsForwardTable1[256] = {
+    0x6363c6a5, 0x7c7cf884, 0x7777ee99, 0x7b7bf68d,
+    0xf2f2ff0d, 0x6b6bd6bd, 0x6f6fdeb1, 0xc5c59154,
+    0x30306050, 0x01010203, 0x6767cea9, 0x2b2b567d,
+    0xfefee719, 0xd7d7b562, 0xabab4de6, 0x7676ec9a,
+    0xcaca8f45, 0x82821f9d, 0xc9c98940, 0x7d7dfa87,
+    0xfafaef15, 0x5959b2eb, 0x47478ec9, 0xf0f0fb0b,
+    0xadad41ec, 0xd4d4b367, 0xa2a25ffd, 0xafaf45ea,
+    0x9c9c23bf, 0xa4a453f7, 0x7272e496, 0xc0c09b5b,
+    0xb7b775c2, 0xfdfde11c, 0x93933dae, 0x26264c6a,
+    0x36366c5a, 0x3f3f7e41, 0xf7f7f502, 0xcccc834f,
+    0x3434685c, 0xa5a551f4, 0xe5e5d134, 0xf1f1f908,
+    0x7171e293, 0xd8d8ab73, 0x31316253, 0x15152a3f,
+    0x0404080c, 0xc7c79552, 0x23234665, 0xc3c39d5e,
+    0x18183028, 0x969637a1, 0x05050a0f, 0x9a9a2fb5,
+    0x07070e09, 0x12122436, 0x80801b9b, 0xe2e2df3d,
+    0xebebcd26, 0x27274e69, 0xb2b27fcd, 0x7575ea9f,
+    0x0909121b, 0x83831d9e, 0x2c2c5874, 0x1a1a342e,
+    0x1b1b362d, 0x6e6edcb2, 0x5a5ab4ee, 0xa0a05bfb,
+    0x5252a4f6, 0x3b3b764d, 0xd6d6b761, 0xb3b37dce,
+    0x2929527b, 0xe3e3dd3e, 0x2f2f5e71, 0x84841397,
+    0x5353a6f5, 0xd1d1b968, 0x00000000, 0xededc12c,
+    0x20204060, 0xfcfce31f, 0xb1b179c8, 0x5b5bb6ed,
+    0x6a6ad4be, 0xcbcb8d46, 0xbebe67d9, 0x3939724b,
+    0x4a4a94de, 0x4c4c98d4, 0x5858b0e8, 0xcfcf854a,
+    0xd0d0bb6b, 0xefefc52a, 0xaaaa4fe5, 0xfbfbed16,
+    0x434386c5, 0x4d4d9ad7, 0x33336655, 0x85851194,
+    0x45458acf, 0xf9f9e910, 0x02020406, 0x7f7ffe81,
+    0x5050a0f0, 0x3c3c7844, 0x9f9f25ba, 0xa8a84be3,
+    0x5151a2f3, 0xa3a35dfe, 0x404080c0, 0x8f8f058a,
+    0x92923fad, 0x9d9d21bc, 0x38387048, 0xf5f5f104,
+    0xbcbc63df, 0xb6b677c1, 0xdadaaf75, 0x21214263,
+    0x10102030, 0xffffe51a, 0xf3f3fd0e, 0xd2d2bf6d,
+    0xcdcd814c, 0x0c0c1814, 0x13132635, 0xececc32f,
+    0x5f5fbee1, 0x979735a2, 0x444488cc, 0x17172e39,
+    0xc4c49357, 0xa7a755f2, 0x7e7efc82, 0x3d3d7a47,
+    0x6464c8ac, 0x5d5dbae7, 0x1919322b, 0x7373e695,
+    0x6060c0a0, 0x81811998, 0x4f4f9ed1, 0xdcdca37f,
+    0x22224466, 0x2a2a547e, 0x90903bab, 0x88880b83,
+    0x46468cca, 0xeeeec729, 0xb8b86bd3, 0x1414283c,
+    0xdedea779, 0x5e5ebce2, 0x0b0b161d, 0xdbdbad76,
+    0xe0e0db3b, 0x32326456, 0x3a3a744e, 0x0a0a141e,
+    0x494992db, 0x06060c0a, 0x2424486c, 0x5c5cb8e4,
+    0xc2c29f5d, 0xd3d3bd6e, 0xacac43ef, 0x6262c4a6,
+    0x919139a8, 0x959531a4, 0xe4e4d337, 0x7979f28b,
+    0xe7e7d532, 0xc8c88b43, 0x37376e59, 0x6d6ddab7,
+    0x8d8d018c, 0xd5d5b164, 0x4e4e9cd2, 0xa9a949e0,
+    0x6c6cd8b4, 0x5656acfa, 0xf4f4f307, 0xeaeacf25,
+    0x6565caaf, 0x7a7af48e, 0xaeae47e9, 0x08081018,
+    0xbaba6fd5, 0x7878f088, 0x25254a6f, 0x2e2e5c72,
+    0x1c1c3824, 0xa6a657f1, 0xb4b473c7, 0xc6c69751,
+    0xe8e8cb23, 0xdddda17c, 0x7474e89c, 0x1f1f3e21,
+    0x4b4b96dd, 0xbdbd61dc, 0x8b8b0d86, 0x8a8a0f85,
+    0x7070e090, 0x3e3e7c42, 0xb5b571c4, 0x6666ccaa,
+    0x484890d8, 0x03030605, 0xf6f6f701, 0x0e0e1c12,
+    0x6161c2a3, 0x35356a5f, 0x5757aef9, 0xb9b969d0,
+    0x86861791, 0xc1c19958, 0x1d1d3a27, 0x9e9e27b9,
+    0xe1e1d938, 0xf8f8eb13, 0x98982bb3, 0x11112233,
+    0x6969d2bb, 0xd9d9a970, 0x8e8e0789, 0x949433a7,
+    0x9b9b2db6, 0x1e1e3c22, 0x87871592, 0xe9e9c920,
+    0xcece8749, 0x5555aaff, 0x28285078, 0xdfdfa57a,
+    0x8c8c038f, 0xa1a159f8, 0x89890980, 0x0d0d1a17,
+    0xbfbf65da, 0xe6e6d731, 0x424284c6, 0x6868d0b8,
+    0x414182c3, 0x999929b0, 0x2d2d5a77, 0x0f0f1e11,
+    0xb0b07bcb, 0x5454a8fc, 0xbbbb6dd6, 0x16162c3a,
+};
+
+
+static const unsigned int gcsForwardTable2[256] = {
+    0x63c6a563, 0x7cf8847c, 0x77ee9977, 0x7bf68d7b,
+    0xf2ff0df2, 0x6bd6bd6b, 0x6fdeb16f, 0xc59154c5,
+    0x30605030, 0x01020301, 0x67cea967, 0x2b567d2b,
+    0xfee719fe, 0xd7b562d7, 0xab4de6ab, 0x76ec9a76,
+    0xca8f45ca, 0x821f9d82, 0xc98940c9, 0x7dfa877d,
+    0xfaef15fa, 0x59b2eb59, 0x478ec947, 0xf0fb0bf0,
+    0xad41ecad, 0xd4b367d4, 0xa25ffda2, 0xaf45eaaf,
+    0x9c23bf9c, 0xa453f7a4, 0x72e49672, 0xc09b5bc0,
+    0xb775c2b7, 0xfde11cfd, 0x933dae93, 0x264c6a26,
+    0x366c5a36, 0x3f7e413f, 0xf7f502f7, 0xcc834fcc,
+    0x34685c34, 0xa551f4a5, 0xe5d134e5, 0xf1f908f1,
+    0x71e29371, 0xd8ab73d8, 0x31625331, 0x152a3f15,
+    0x04080c04, 0xc79552c7, 0x23466523, 0xc39d5ec3,
+    0x18302818, 0x9637a196, 0x050a0f05, 0x9a2fb59a,
+    0x070e0907, 0x12243612, 0x801b9b80, 0xe2df3de2,
+    0xebcd26eb, 0x274e6927, 0xb27fcdb2, 0x75ea9f75,
+    0x09121b09, 0x831d9e83, 0x2c58742c, 0x1a342e1a,
+    0x1b362d1b, 0x6edcb26e, 0x5ab4ee5a, 0xa05bfba0,
+    0x52a4f652, 0x3b764d3b, 0xd6b761d6, 0xb37dceb3,
+    0x29527b29, 0xe3dd3ee3, 0x2f5e712f, 0x84139784,
+    0x53a6f553, 0xd1b968d1, 0x00000000, 0xedc12ced,
+    0x20406020, 0xfce31ffc, 0xb179c8b1, 0x5bb6ed5b,
+    0x6ad4be6a, 0xcb8d46cb, 0xbe67d9be, 0x39724b39,
+    0x4a94de4a, 0x4c98d44c, 0x58b0e858, 0xcf854acf,
+    0xd0bb6bd0, 0xefc52aef, 0xaa4fe5aa, 0xfbed16fb,
+    0x4386c543, 0x4d9ad74d, 0x33665533, 0x85119485,
+    0x458acf45, 0xf9e910f9, 0x02040602, 0x7ffe817f,
+    0x50a0f050, 0x3c78443c, 0x9f25ba9f, 0xa84be3a8,
+    0x51a2f351, 0xa35dfea3, 0x4080c040, 0x8f058a8f,
+    0x923fad92, 0x9d21bc9d, 0x38704838, 0xf5f104f5,
+    0xbc63dfbc, 0xb677c1b6, 0xdaaf75da, 0x21426321,
+    0x10203010, 0xffe51aff, 0xf3fd0ef3, 0xd2bf6dd2,
+    0xcd814ccd, 0x0c18140c, 0x13263513, 0xecc32fec,
+    0x5fbee15f, 0x9735a297, 0x4488cc44, 0x172e3917,
+    0xc49357c4, 0xa755f2a7, 0x7efc827e, 0x3d7a473d,
+    0x64c8ac64, 0x5dbae75d, 0x19322b19, 0x73e69573,
+    0x60c0a060, 0x81199881, 0x4f9ed14f, 0xdca37fdc,
+    0x22446622, 0x2a547e2a, 0x903bab90, 0x880b8388,
+    0x468cca46, 0xeec729ee, 0xb86bd3b8, 0x14283c14,
+    0xdea779de, 0x5ebce25e, 0x0b161d0b, 0xdbad76db,
+    0xe0db3be0, 0x32645632, 0x3a744e3a, 0x0a141e0a,
+    0x4992db49, 0x060c0a06, 0x24486c24, 0x5cb8e45c,
+    0xc29f5dc2, 0xd3bd6ed3, 0xac43efac, 0x62c4a662,
+    0x9139a891, 0x9531a495, 0xe4d337e4, 0x79f28b79,
+    0xe7d532e7, 0xc88b43c8, 0x376e5937, 0x6ddab76d,
+    0x8d018c8d, 0xd5b164d5, 0x4e9cd24e, 0xa949e0a9,
+    0x6cd8b46c, 0x56acfa56, 0xf4f307f4, 0xeacf25ea,
+    0x65caaf65, 0x7af48e7a, 0xae47e9ae, 0x08101808,
+    0xba6fd5ba, 0x78f08878, 0x254a6f25, 0x2e5c722e,
+    0x1c38241c, 0xa657f1a6, 0xb473c7b4, 0xc69751c6,
+    0xe8cb23e8, 0xdda17cdd, 0x74e89c74, 0x1f3e211f,
+    0x4b96dd4b, 0xbd61dcbd, 0x8b0d868b, 0x8a0f858a,
+    0x70e09070, 0x3e7c423e, 0xb571c4b5, 0x66ccaa66,
+    0x4890d848, 0x03060503, 0xf6f701f6, 0x0e1c120e,
+    0x61c2a361, 0x356a5f35, 0x57aef957, 0xb969d0b9,
+    0x86179186, 0xc19958c1, 0x1d3a271d, 0x9e27b99e,
+    0xe1d938e1, 0xf8eb13f8, 0x982bb398, 0x11223311,
+    0x69d2bb69, 0xd9a970d9, 0x8e07898e, 0x9433a794,
+    0x9b2db69b, 0x1e3c221e, 0x87159287, 0xe9c920e9,
+    0xce8749ce, 0x55aaff55, 0x28507828, 0xdfa57adf,
+    0x8c038f8c, 0xa159f8a1, 0x89098089, 0x0d1a170d,
+    0xbf65dabf, 0xe6d731e6, 0x4284c642, 0x68d0b868,
+    0x4182c341, 0x9929b099, 0x2d5a772d, 0x0f1e110f,
+    0xb07bcbb0, 0x54a8fc54, 0xbb6dd6bb, 0x162c3a16,
+};
+
+
+static const unsigned int gcsForwardTable3[256] = {
+    0xc6a56363, 0xf8847c7c, 0xee997777, 0xf68d7b7b,
+    0xff0df2f2, 0xd6bd6b6b, 0xdeb16f6f, 0x9154c5c5,
+    0x60503030, 0x02030101, 0xcea96767, 0x567d2b2b,
+    0xe719fefe, 0xb562d7d7, 0x4de6abab, 0xec9a7676,
+    0x8f45caca, 0x1f9d8282, 0x8940c9c9, 0xfa877d7d,
+    0xef15fafa, 0xb2eb5959, 0x8ec94747, 0xfb0bf0f0,
+    0x41ecadad, 0xb367d4d4, 0x5ffda2a2, 0x45eaafaf,
+    0x23bf9c9c, 0x53f7a4a4, 0xe4967272, 0x9b5bc0c0,
+    0x75c2b7b7, 0xe11cfdfd, 0x3dae9393, 0x4c6a2626,
+    0x6c5a3636, 0x7e413f3f, 0xf502f7f7, 0x834fcccc,
+    0x685c3434, 0x51f4a5a5, 0xd134e5e5, 0xf908f1f1,
+    0xe2937171, 0xab73d8d8, 0x62533131, 0x2a3f1515,
+    0x080c0404, 0x9552c7c7, 0x46652323, 0x9d5ec3c3,
+    0x30281818, 0x37a19696, 0x0a0f0505, 0x2fb59a9a,
+    0x0e090707, 0x24361212, 0x1b9b8080, 0xdf3de2e2,
+    0xcd26ebeb, 0x4e692727, 0x7fcdb2b2, 0xea9f7575,
+    0x121b0909, 0x1d9e8383, 0x58742c2c, 0x342e1a1a,
+    0x362d1b1b, 0xdcb26e6e, 0xb4ee5a5a, 0x5bfba0a0,
+    0xa4f65252, 0x764d3b3b, 0xb761d6d6, 0x7dceb3b3,
+    0x527b2929, 0xdd3ee3e3, 0x5e712f2f, 0x13978484,
+    0xa6f55353, 0xb968d1d1, 0x00000000, 0xc12ceded,
+    0x40602020, 0xe31ffcfc, 0x79c8b1b1, 0xb6ed5b5b,
+    0xd4be6a6a, 0x8d46cbcb, 0x67d9bebe, 0x724b3939,
+    0x94de4a4a, 0x98d44c4c, 0xb0e85858, 0x854acfcf,
+    0xbb6bd0d0, 0xc52aefef, 0x4fe5aaaa, 0xed16fbfb,
+    0x86c54343, 0x9ad74d4d, 0x66553333, 0x11948585,
+    0x8acf4545, 0xe910f9f9, 0x04060202, 0xfe817f7f,
+    0xa0f05050, 0x78443c3c, 0x25ba9f9f, 0x4be3a8a8,
+    0xa2f35151, 0x5dfea3a3, 0x80c04040, 0x058a8f8f,
+    0x3fad9292, 0x21bc9d9d, 0x70483838, 0xf104f5f5,
+    0x63dfbcbc, 0x77c1b6b6, 0xaf75dada, 0x42632121,
+    0x20301010, 0xe51affff, 0xfd0ef3f3, 0xbf6dd2d2,
+    0x814ccdcd, 0x18140c0c, 0x26351313, 0xc32fecec,
+    0xbee15f5f, 0x35a29797, 0x88cc4444, 0x2e391717,
+    0x9357c4c4, 0x55f2a7a7, 0xfc827e7e, 0x7a473d3d,
+    0xc8ac6464, 0xbae75d5d, 0x322b1919, 0xe6957373,
+    0xc0a06060, 0x19988181, 0x9ed14f4f, 0xa37fdcdc,
+    0x44662222, 0x547e2a2a, 0x3bab9090, 0x0b838888,
+    0x8cca4646, 0xc729eeee, 0x6bd3b8b8, 0x283c1414,
+    0xa779dede, 0xbce25e5e, 0x161d0b0b, 0xad76dbdb,
+    0xdb3be0e0, 0x64563232, 0x744e3a3a, 0x141e0a0a,
+    0x92db4949, 0x0c0a0606, 0x486c2424, 0xb8e45c5c,
+    0x9f5dc2c2, 0xbd6ed3d3, 0x43efacac, 0xc4a66262,
+    0x39a89191, 0x31a49595, 0xd337e4e4, 0xf28b7979,
+    0xd532e7e7, 0x8b43c8c8, 0x6e593737, 0xdab76d6d,
+    0x018c8d8d, 0xb164d5d5, 0x9cd24e4e, 0x49e0a9a9,
+    0xd8b46c6c, 0xacfa5656, 0xf307f4f4, 0xcf25eaea,
+    0xcaaf6565, 0xf48e7a7a, 0x47e9aeae, 0x10180808,
+    0x6fd5baba, 0xf0887878, 0x4a6f2525, 0x5c722e2e,
+    0x38241c1c, 0x57f1a6a6, 0x73c7b4b4, 0x9751c6c6,
+    0xcb23e8e8, 0xa17cdddd, 0xe89c7474, 0x3e211f1f,
+    0x96dd4b4b, 0x61dcbdbd, 0x0d868b8b, 0x0f858a8a,
+    0xe0907070, 0x7c423e3e, 0x71c4b5b5, 0xccaa6666,
+    0x90d84848, 0x06050303, 0xf701f6f6, 0x1c120e0e,
+    0xc2a36161, 0x6a5f3535, 0xaef95757, 0x69d0b9b9,
+    0x17918686, 0x9958c1c1, 0x3a271d1d, 0x27b99e9e,
+    0xd938e1e1, 0xeb13f8f8, 0x2bb39898, 0x22331111,
+    0xd2bb6969, 0xa970d9d9, 0x07898e8e, 0x33a79494,
+    0x2db69b9b, 0x3c221e1e, 0x15928787, 0xc920e9e9,
+    0x8749cece, 0xaaff5555, 0x50782828, 0xa57adfdf,
+    0x038f8c8c, 0x59f8a1a1, 0x09808989, 0x1a170d0d,
+    0x65dabfbf, 0xd731e6e6, 0x84c64242, 0xd0b86868,
+    0x82c34141, 0x29b09999, 0x5a772d2d, 0x1e110f0f,
+    0x7bcbb0b0, 0xa8fc5454, 0x6dd6bbbb, 0x2c3a1616,
+};
+
+
+static const unsigned int gcsReverseTable0[256] = {
+    0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a,
+    0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b,
+    0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5,
+    0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5,
+    0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d,
+    0x02752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b,
+    0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295,
+    0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e,
+    0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927,
+    0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d,
+    0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362,
+    0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9,
+    0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52,
+    0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566,
+    0x0728ebb2, 0x03c2b52f, 0x9a7bc586, 0xa50837d3,
+    0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed,
+    0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e,
+    0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4,
+    0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4,
+    0x39ec830b, 0xaaef6040, 0x069f715e, 0x51106ebd,
+    0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d,
+    0xb58d5491, 0x055dc471, 0x6fd40604, 0xff155060,
+    0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967,
+    0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879,
+    0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x00000000,
+    0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c,
+    0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36,
+    0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624,
+    0xb1670a0c, 0x0fe75793, 0xd296eeb4, 0x9e919b1b,
+    0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c,
+    0x0aba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12,
+    0x0b0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14,
+    0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3,
+    0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b,
+    0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8,
+    0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684,
+    0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7,
+    0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177,
+    0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947,
+    0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322,
+    0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498,
+    0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f,
+    0xe49d3a2c, 0x0d927850, 0x9bcc5f6a, 0x62467e54,
+    0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382,
+    0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf,
+    0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb,
+    0x097826cd, 0xf418596e, 0x01b79aec, 0xa89a4f83,
+    0x656e95e6, 0x7ee6ffaa, 0x08cfbc21, 0xe6e815ef,
+    0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029,
+    0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235,
+    0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733,
+    0x4a9804f1, 0xf7daec41, 0x0e50cd7f, 0x2ff69117,
+    0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4,
+    0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546,
+    0x04ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb,
+    0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d,
+    0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb,
+    0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a,
+    0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773,
+    0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478,
+    0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2,
+    0x72c31d16, 0x0c25e2bc, 0x8b493c28, 0x41950dff,
+    0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664,
+    0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0,
+};
+
+
+static const unsigned int gcsReverseTable1[256] = {
+    0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96,
+    0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x03e34b93,
+    0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525,
+    0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f,
+    0x5ab1de49, 0x1bba2567, 0x0eea4598, 0xc0fe5de1,
+    0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6,
+    0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da,
+    0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44,
+    0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd,
+    0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4,
+    0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245,
+    0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994,
+    0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7,
+    0xd373ab23, 0x024b72e2, 0x8f1fe357, 0xab55662a,
+    0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x0837d3a5,
+    0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c,
+    0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1,
+    0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a,
+    0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475,
+    0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51,
+    0x8a213ef9, 0x06dd963d, 0x053eddae, 0xbde64d46,
+    0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff,
+    0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777,
+    0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db,
+    0x0a7ca147, 0x0f427ce9, 0x1e84f8c9, 0x00000000,
+    0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e,
+    0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627,
+    0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a,
+    0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e,
+    0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16,
+    0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d,
+    0x0d090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8,
+    0x19f15785, 0x0775af4c, 0xdd99eebb, 0x607fa3fd,
+    0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34,
+    0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863,
+    0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420,
+    0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d,
+    0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0,
+    0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722,
+    0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef,
+    0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0x0bd49836,
+    0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4,
+    0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462,
+    0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5,
+    0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3,
+    0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b,
+    0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8,
+    0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6,
+    0x9be7bad9, 0x366f4ace, 0x099fead4, 0x7cb029d6,
+    0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0,
+    0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315,
+    0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f,
+    0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x0496e4df,
+    0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f,
+    0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e,
+    0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13,
+    0x61d79a8c, 0x0ca1377a, 0x14f8598e, 0x3c13eb89,
+    0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c,
+    0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf,
+    0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886,
+    0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f,
+    0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41,
+    0x01a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490,
+    0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042,
+};
+
+
+static const unsigned int gcsReverseTable2[256] = {
+    0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e,
+    0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303,
+    0x302055fa, 0x76adf66d, 0xcc889176, 0x02f5254c,
+    0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3,
+    0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0,
+    0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9,
+    0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59,
+    0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8,
+    0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71,
+    0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a,
+    0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f,
+    0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x08f9942b,
+    0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8,
+    0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab,
+    0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508,
+    0x2830f287, 0xbf23b2a5, 0x0302ba6a, 0x16ed5c82,
+    0xcf8a2b1c, 0x79a792b4, 0x07f3f0f2, 0x694ea1e2,
+    0xda65cdf4, 0x0506d5be, 0x34d11f62, 0xa6c48afe,
+    0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb,
+    0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110,
+    0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd,
+    0x5491b58d, 0xc471055d, 0x06046fd4, 0x5060ff15,
+    0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e,
+    0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee,
+    0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x00000000,
+    0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72,
+    0x0efdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739,
+    0x0f0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e,
+    0x0a0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91,
+    0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a,
+    0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17,
+    0x090e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9,
+    0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60,
+    0x01f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e,
+    0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1,
+    0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011,
+    0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1,
+    0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3,
+    0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264,
+    0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90,
+    0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b,
+    0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf,
+    0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246,
+    0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af,
+    0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312,
+    0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb,
+    0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a,
+    0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8,
+    0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c,
+    0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066,
+    0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8,
+    0x04f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6,
+    0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04,
+    0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51,
+    0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0x0bfb2e41,
+    0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347,
+    0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c,
+    0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1,
+    0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37,
+    0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db,
+    0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40,
+    0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0x0dff4195,
+    0xa8397101, 0x0c08deb3, 0xb4d89ce4, 0x566490c1,
+    0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257,
+};
+
+
+static const unsigned int gcsReverseTable3[256] = {
+    0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27,
+    0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3,
+    0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02,
+    0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362,
+    0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe,
+    0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3,
+    0x03e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952,
+    0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9,
+    0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9,
+    0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace,
+    0x63184adf, 0xe582311a, 0x97603351, 0x62457f53,
+    0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08,
+    0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b,
+    0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55,
+    0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837,
+    0x30f28728, 0x23b2a5bf, 0x02ba6a03, 0xed5c8216,
+    0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269,
+    0x65cdf4da, 0x06d5be05, 0xd11f6234, 0xc48afea6,
+    0x349d532e, 0xa2a055f3, 0x0532e18a, 0xa475ebf6,
+    0x0b39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e,
+    0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6,
+    0x91b58d54, 0x71055dc4, 0x046fd406, 0x60ff1550,
+    0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9,
+    0xb0bd42e8, 0x07888b89, 0xe7385b19, 0x79dbeec8,
+    0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x00000000,
+    0x09838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a,
+    0xfdfbff0e, 0x0f563885, 0x3d1ed5ae, 0x3627392d,
+    0x0a64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36,
+    0x0cb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b,
+    0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12,
+    0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b,
+    0x0e0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e,
+    0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f,
+    0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb,
+    0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4,
+    0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6,
+    0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129,
+    0x1d4b2f9e, 0xdcf330b2, 0x0dec5286, 0x77d0e3c1,
+    0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9,
+    0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033,
+    0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4,
+    0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad,
+    0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e,
+    0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3,
+    0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225,
+    0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b,
+    0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f,
+    0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815,
+    0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0,
+    0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2,
+    0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7,
+    0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691,
+    0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496,
+    0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165,
+    0x9d04ea5e, 0x015d358c, 0xfa737487, 0xfb2e410b,
+    0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6,
+    0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13,
+    0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147,
+    0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7,
+    0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44,
+    0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3,
+    0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d,
+    0x397101a8, 0x08deb30c, 0xd89ce4b4, 0x6490c156,
+    0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8,
+};
+
+
+static const unsigned int gcsRoundConstant[10] = {
+    0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010,
+    0x00000020, 0x00000040, 0x00000080, 0x0000001b, 0x00000036,
+};
+
+#define DReadLE32(x, p) \
+{ \
+    x = ((unsigned int) p[0]) \
+        | ((unsigned int) p[1] << 8) \
+        | ((unsigned int) p[2] << 16) \
+        | ((unsigned int) p[3] << 24); \
+}
+
+#define DWriteLE32(x, p) \
+{ \
+    p[0] = (0xff & x); \
+    p[1] = (0xff & (x >> 8)); \
+    p[2] = (0xff & (x >> 16)); \
+    p[3] = (0xff & (x >> 24)); \
+}
+
+static int __aes_set_encrypt_key(unsigned int *p_rk, const unsigned char *key, unsigned int key_length)
+{
+    unsigned int i = 0;
+
+    //read key
+    for (i = 0; i < ( key_length >> 5 ); i++ ) {
+        DReadLE32(p_rk[i], key);
+        key += 4;
+    }
+
+    //generate round keys
+    if (128 == key_length) {
+        for (i = 0; i < 10; i++, p_rk += 4) {
+            p_rk[4]  = p_rk[0] ^ gcsRoundConstant[i] ^
+                ((unsigned int) gcsForwardSBox[(p_rk[3] >>  8) & 0xFF]) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[3] >> 16) & 0xFF] <<  8) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[3] >> 24) & 0xFF] << 16) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[3]) & 0xFF] << 24);
+
+            p_rk[5]  = p_rk[1] ^ p_rk[4];
+            p_rk[6]  = p_rk[2] ^ p_rk[5];
+            p_rk[7]  = p_rk[3] ^ p_rk[6];
+        }
+    } else if (192 == key_length) {
+        for (i = 0; i < 8; i++, p_rk += 6) {
+            p_rk[6] = p_rk[0] ^ gcsRoundConstant[i] ^
+                ((unsigned int) gcsForwardSBox[(p_rk[5] >>  8) & 0xFF]) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[5] >> 16) & 0xFF] <<  8) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[5] >> 24) & 0xFF] << 16) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[5]) & 0xFF] << 24);
+
+            p_rk[7]  = p_rk[1] ^ p_rk[6];
+            p_rk[8]  = p_rk[2] ^ p_rk[7];
+            p_rk[9]  = p_rk[3] ^ p_rk[8];
+            p_rk[10] = p_rk[4] ^ p_rk[9];
+            p_rk[11] = p_rk[5] ^ p_rk[10];
+        }
+    } else if (256 == key_length) {
+        for (i = 0; i < 7; i++, p_rk += 8 ) {
+            p_rk[8]  = p_rk[0] ^ gcsRoundConstant[i] ^
+                ((unsigned int) gcsForwardSBox[(p_rk[7] >>  8) & 0xFF]) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[7] >> 16) & 0xFF] <<  8) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[7] >> 24) & 0xFF] << 16) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[7]) & 0xFF] << 24);
+
+            p_rk[9]  = p_rk[1] ^ p_rk[8];
+            p_rk[10] = p_rk[2] ^ p_rk[9];
+            p_rk[11] = p_rk[3] ^ p_rk[10];
+
+            p_rk[12] = p_rk[4] ^
+                ((unsigned int) gcsForwardSBox[(p_rk[11]) & 0xFF]) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[11] >>  8) & 0xFF] <<  8) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[11] >> 16) & 0xFF] << 16) ^
+                ((unsigned int) gcsForwardSBox[(p_rk[11] >> 24) & 0xFF] << 24);
+
+            p_rk[13] = p_rk[5] ^ p_rk[12];
+            p_rk[14] = p_rk[6] ^ p_rk[13];
+            p_rk[15] = p_rk[7] ^ p_rk[14];
+        }
+    } else {
+        DCRYPT_LOG("error: invalid key_length.. %d\n", key_length);
+        return (-2);
+    }
+
+    return( 0 );
+}
+
+static void __aes_encrypt_block(aes_context_t *ctx, const unsigned char *input, unsigned char *output)
+{
+
+#define D_AES_FORWARD_ROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
+{                                               \
+    X0 = *p_rk++ ^ gcsForwardTable0[(Y0) & 0xFF] ^   \
+         gcsForwardTable1[(Y1 >>  8) & 0xFF] ^   \
+         gcsForwardTable2[(Y2 >> 16) & 0xFF] ^   \
+         gcsForwardTable3[(Y3 >> 24) & 0xFF];    \
+    X1 = *p_rk++ ^ gcsForwardTable0[(Y1) & 0xFF] ^   \
+         gcsForwardTable1[(Y2 >>  8) & 0xFF] ^   \
+         gcsForwardTable2[(Y3 >> 16) & 0xFF] ^   \
+         gcsForwardTable3[(Y0 >> 24) & 0xFF];    \
+    X2 = *p_rk++ ^ gcsForwardTable0[(Y2) & 0xFF] ^   \
+         gcsForwardTable1[(Y3 >>  8) & 0xFF] ^   \
+         gcsForwardTable2[(Y0 >> 16) & 0xFF] ^   \
+         gcsForwardTable3[(Y1 >> 24) & 0xFF];    \
+    X3 = *p_rk++ ^ gcsForwardTable0[(Y3) & 0xFF] ^   \
+         gcsForwardTable1[(Y0 >>  8) & 0xFF] ^   \
+         gcsForwardTable2[(Y1 >> 16) & 0xFF] ^   \
+         gcsForwardTable3[(Y2 >> 24) & 0xFF];    \
+}
+
+    int i;
+    unsigned int *p_rk, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+    p_rk = ctx->p_round_key;
+
+    DReadLE32(X0, input);
+    input += 4;
+    X0 ^= *p_rk++;
+    DReadLE32(X1, input);
+    input += 4;
+    X1 ^= *p_rk++;
+    DReadLE32(X2, input);
+    input += 4;
+    X2 ^= *p_rk++;
+    DReadLE32(X3, input);
+    input += 4;
+    X3 ^= *p_rk++;
+
+    for( i = (ctx->round >> 1) - 1; i > 0; i--) {
+        D_AES_FORWARD_ROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+        D_AES_FORWARD_ROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);
+    }
+
+    D_AES_FORWARD_ROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+
+    X0 = *p_rk++ ^ \
+        ((unsigned int) gcsForwardSBox[(Y0) & 0xFF]) ^
+        ((unsigned int) gcsForwardSBox[(Y1 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsForwardSBox[(Y2 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsForwardSBox[(Y3 >> 24) & 0xFF] << 24);
+
+    X1 = *p_rk++ ^ \
+        ((unsigned int) gcsForwardSBox[(Y1) & 0xFF]) ^
+        ((unsigned int) gcsForwardSBox[(Y2 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsForwardSBox[(Y3 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsForwardSBox[(Y0 >> 24) & 0xFF] << 24);
+
+    X2 = *p_rk++ ^ \
+        ((unsigned int) gcsForwardSBox[(Y2) & 0xFF]) ^
+        ((unsigned int) gcsForwardSBox[(Y3 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsForwardSBox[(Y0 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsForwardSBox[(Y1 >> 24) & 0xFF] << 24);
+
+    X3 = *p_rk++ ^ \
+        ((unsigned int) gcsForwardSBox[(Y3) & 0xFF]) ^
+        ((unsigned int) gcsForwardSBox[(Y0 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsForwardSBox[(Y1 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsForwardSBox[(Y2 >> 24) & 0xFF] << 24);
+
+    DWriteLE32(X0, output);
+    output += 4;
+    DWriteLE32(X1, output);
+    output += 4;
+    DWriteLE32(X2, output);
+    output += 4;
+    DWriteLE32(X3, output);
+
+    return;
+}
+
+static void __aes_decrypt_block(aes_context_t *ctx, const unsigned char *input, unsigned char *output)
+{
+
+#define D_AES_REVERSE_ROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
+{                                               \
+    X0 = *p_rk++ ^ gcsReverseTable0[(Y0) & 0xFF] ^   \
+         gcsReverseTable1[(Y3 >>  8) & 0xFF] ^   \
+         gcsReverseTable2[(Y2 >> 16) & 0xFF] ^   \
+         gcsReverseTable3[(Y1 >> 24) & 0xFF];    \
+    X1 = *p_rk++ ^ gcsReverseTable0[(Y1) & 0xFF] ^   \
+         gcsReverseTable1[(Y0 >>  8) & 0xFF] ^   \
+         gcsReverseTable2[(Y3 >> 16) & 0xFF] ^   \
+         gcsReverseTable3[(Y2 >> 24) & 0xFF];    \
+    X2 = *p_rk++ ^ gcsReverseTable0[(Y2) & 0xFF] ^   \
+         gcsReverseTable1[(Y1 >>  8) & 0xFF] ^   \
+         gcsReverseTable2[(Y0 >> 16) & 0xFF] ^   \
+         gcsReverseTable3[(Y3 >> 24) & 0xFF];    \
+    X3 = *p_rk++ ^ gcsReverseTable0[(Y3) & 0xFF] ^   \
+         gcsReverseTable1[(Y2 >>  8) & 0xFF] ^   \
+         gcsReverseTable2[(Y1 >> 16) & 0xFF] ^   \
+         gcsReverseTable3[(Y0 >> 24) & 0xFF];    \
+}
+
+    int i;
+    unsigned int *p_rk, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
+
+    p_rk = ctx->p_round_key;
+
+    DReadLE32(X0, input);
+    input += 4;
+    X0 ^= *p_rk++;
+    DReadLE32(X1, input);
+    input += 4;
+    X1 ^= *p_rk++;
+    DReadLE32(X2, input);
+    input += 4;
+    X2 ^= *p_rk++;
+    DReadLE32(X3, input);
+    input += 4;
+    X3 ^= *p_rk++;
+
+    for (i = (ctx->round >> 1) - 1; i > 0; i--) {
+        D_AES_REVERSE_ROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+        D_AES_REVERSE_ROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);
+    }
+    D_AES_REVERSE_ROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);
+
+    X0 = *p_rk++ ^ \
+        ((unsigned int) gcsReverseSBox[(Y0) & 0xFF]) ^
+        ((unsigned int) gcsReverseSBox[(Y3 >>  8 ) & 0xFF] <<  8) ^
+        ((unsigned int) gcsReverseSBox[(Y2 >> 16 ) & 0xFF] << 16) ^
+        ((unsigned int) gcsReverseSBox[(Y1 >> 24 ) & 0xFF] << 24);
+
+    X1 = *p_rk++ ^ \
+        ((unsigned int) gcsReverseSBox[(Y1) & 0xFF]) ^
+        ((unsigned int) gcsReverseSBox[(Y0 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsReverseSBox[(Y3 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsReverseSBox[(Y2 >> 24) & 0xFF] << 24);
+
+    X2 = *p_rk++ ^ \
+        ((unsigned int) gcsReverseSBox[(Y2) & 0xFF]) ^
+        ((unsigned int) gcsReverseSBox[(Y1 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsReverseSBox[(Y0 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsReverseSBox[(Y3 >> 24) & 0xFF] << 24);
+
+    X3 = *p_rk++ ^ \
+        ((unsigned int) gcsReverseSBox[(Y3) & 0xFF]) ^
+        ((unsigned int) gcsReverseSBox[(Y2 >>  8) & 0xFF] <<  8) ^
+        ((unsigned int) gcsReverseSBox[(Y1 >> 16) & 0xFF] << 16) ^
+        ((unsigned int) gcsReverseSBox[(Y0 >> 24) & 0xFF] << 24);
+
+    DWriteLE32(X0, output);
+    output += 4;
+    DWriteLE32(X1, output);
+    output += 4;
+    DWriteLE32(X2, output);
+    output += 4;
+    DWriteLE32(X3, output);
+
+    return;
+}
+
+aes_context_t *aes_init()
+{
+    aes_context_t *thiz = (aes_context_t *) malloc(sizeof(aes_context_t));
+    if (thiz) {
+        memset(thiz, 0x0, sizeof(aes_context_t));
+    } else {
+        DCRYPT_LOG("error: no memory\n");
+    }
+    return thiz;
+}
+
+void aes_destroy(aes_context_t *ctx)
+{
+    if (ctx) {
+        free(ctx);
+    }
+}
+
+int aes_set_encrypt_key(aes_context_t *ctx, const unsigned char *key, unsigned int key_length)
+{
+    if ((!ctx) || (!key)) {
+        DCRYPT_LOG("error: null pointer\n");
+        return (-1);
+    }
+
+    if (128 == key_length) {
+        ctx->round = 10;
+    } else if (192 == key_length) {
+        ctx->round = 12;
+    } else if (256 == key_length) {
+        ctx->round = 14;
+    } else {
+        DCRYPT_LOG("error: enc invalid key_length %d\n", key_length);
+        return (-2);
+    }
+
+    return __aes_set_encrypt_key(ctx->p_round_key, key, key_length);
+}
+
+int aes_set_decrypt_key(aes_context_t *ctx, const unsigned char *key, unsigned int key_length)
+{
+    int ret = 0;
+    unsigned int i = 0, j = 0;
+    unsigned int enc_rk[72] = {0};
+    unsigned int *p_rk = NULL;
+    unsigned int *p_enc_rk = NULL;
+
+    if ((!ctx) || (!key)) {
+        DCRYPT_LOG("error: null pointer\n");
+        return (-1);
+    }
+
+    if (128 == key_length) {
+        ctx->round = 10;
+    } else if (192 == key_length) {
+        ctx->round = 12;
+    } else if (256 == key_length) {
+        ctx->round = 14;
+    } else {
+        DCRYPT_LOG("error: dec invalid key_length %d\n", key_length);
+        return (-2);
+    }
+
+    ret = __aes_set_encrypt_key(enc_rk, key, key_length);
+    if (0 > ret) {
+        return ret;
+    }
+
+    p_rk = ctx->p_round_key;
+
+    p_enc_rk = (unsigned int *) enc_rk + ctx->round * 4;
+
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+
+    for (i = ctx->round - 1, p_enc_rk -= 8; i > 0; i--, p_enc_rk -= 8) {
+        for (j = 0; j < 4; j++, p_enc_rk++ ) {
+            *p_rk++ = gcsReverseTable0[gcsForwardSBox[(*p_enc_rk) & 0xFF]] ^
+                gcsReverseTable1[gcsForwardSBox[(*p_enc_rk >>  8) & 0xFF]] ^
+                gcsReverseTable2[gcsForwardSBox[(*p_enc_rk >> 16) & 0xFF]] ^
+                gcsReverseTable3[gcsForwardSBox[(*p_enc_rk >> 24) & 0xFF]];
+        }
+    }
+
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+    *p_rk++ = *p_enc_rk++;
+
+    return 0;
+}
+
+int aes_ecb_encrypt(aes_context_t *ctx, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        __aes_encrypt_block(ctx, input, output);
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+int aes_ecb_decrypt(aes_context_t *ctx, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        __aes_decrypt_block(ctx, input, output);
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+int aes_ctr_crypt(aes_context_t *ctx, unsigned char *p_nonce, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    unsigned int i;
+    unsigned int cur = ctx->cur_position;
+    unsigned char block[16] = {0};
+
+    while (data_length--) {
+        if (!cur) {
+            __aes_encrypt_block(ctx, input, block);
+            for (i = 16; i > 0; i--) {
+                if (++ p_nonce[i - 1] != 0) {
+                    break;
+                }
+            }
+        }
+        *output++ = ((*input++) ^ block[cur]);
+        cur = (cur + 1) & 0x0F;
+    }
+    ctx->cur_position = cur;
+
+    return 0;
+}
+
+int aes_cbc_encrypt(aes_context_t *ctx, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    unsigned int i;
+
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        for (i = 0; i < 16; i++) {
+            output[i] = input[i] ^ iv[i];
+        }
+
+        __aes_encrypt_block(ctx, output, output);
+        memcpy(iv, output, 16);
+
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+int aes_cbc_decrypt(aes_context_t *ctx, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    unsigned int i;
+    unsigned char temp[16] = {0};
+
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        memcpy(temp, input, 16);
+        __aes_decrypt_block(ctx, input, output);
+
+        for (i = 0; i < 16; i++) {
+            output[i] = output[i] ^ iv[i];
+        }
+
+        memcpy(iv, temp, 16);
+
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+
+//one shot api
+
+int aes_ecb_encrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_encrypt_key(thiz, key, key_length);
+    if (ret) {
+        return (-2);
+    }
+
+    aes_ecb_encrypt(thiz, input, output, data_length);
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+int aes_ecb_decrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_decrypt_key(thiz, key, key_length);
+    if (ret) {
+        return (-2);
+    }
+
+    aes_ecb_decrypt(thiz, input, output, data_length);
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+int aes_ctr_crypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *p_nonce, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !p_nonce || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_encrypt_key(thiz, key, key_length);
+    if (ret) {
+        return (-2);
+    }
+
+    aes_ctr_crypt(thiz, p_nonce, input, output, data_length);
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+
+int aes_cbc_encrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !iv || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_encrypt_key(thiz, key, key_length);
+    if (ret) {
+        return ret;
+    }
+
+    ret = aes_cbc_encrypt(thiz, iv, input, output, data_length);
+    if (ret) {
+        return ret;
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+int aes_cbc_decrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !iv || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_decrypt_key(thiz, key, key_length);
+    if (ret) {
+        return ret;
+    }
+
+    ret = aes_cbc_decrypt(thiz, iv, input, output, data_length);
+    if (ret) {
+        return ret;
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+#endif
+
diff --git a/lw_cryptography/src/aes_non_precal.c b/lw_cryptography/src/aes_non_precal.c
new file mode 100644
index 0000000..5d50331
--- /dev/null
+++ b/lw_cryptography/src/aes_non_precal.c
@@ -0,0 +1,696 @@
+/*******************************************************************************
+ * aes_non_precal.c
+ *
+ * History:
+ *  2017/03/21 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include "cryptography_if.h"
+
+#ifndef DNOT_INCLUDE_C_HEADER
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#else
+#include <bldfunc.h>
+#endif
+
+#ifndef DCONFIG_AES_USE_PRECALCULATED_TABLE
+
+#define DGF28Time(x) ((x << 1) ^ ((x & 0x80) ? 0x1B : 0x00))
+#define DGF28Multiple(x, y) \
+    (((y & 1) * x) ^ \
+    ((y>>1 & 1) * DGF28Time(x)) ^ \
+    ((y>>2 & 1) * DGF28Time(DGF28Time(x))) ^ \
+    ((y>>3 & 1) * DGF28Time(DGF28Time(DGF28Time(x)))) ^ \
+    ((y>>4 & 1) * DGF28Time(DGF28Time(DGF28Time(DGF28Time(x)))))) \
+
+
+
+static const unsigned char gcsForwardSBox[256] = {
+    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
+};
+
+
+static const unsigned char gcsReverseSBox[256] = {
+    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
+    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
+    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
+    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
+    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
+    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
+    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
+    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
+    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
+    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
+    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
+    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
+    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
+    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
+    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
+    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
+};
+
+
+static const unsigned char gcsRoundConstant[10] = {
+    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,
+};
+
+static int __aes_set_key(unsigned int *p_rk, const unsigned char *key, unsigned int key_length)
+{
+    unsigned int i;
+    unsigned char v0, v1, v2, v3;
+    unsigned int v;
+    unsigned int *p_32bit_key = (unsigned int *) key;
+    unsigned int *p_ori_rk = p_rk;
+
+    if (128 == key_length) {
+
+        p_rk[0] = p_32bit_key[0];
+        p_rk[1] = p_32bit_key[1];
+        p_rk[2] = p_32bit_key[2];
+        p_rk[3] = p_32bit_key[3];
+
+        for (i = 0; i < 10; i ++, p_rk += 4) {
+            //rotate
+            v0 = (p_rk[3] >> 8) & 0xff;
+            v1 = (p_rk[3] >> 16) & 0xff;
+            v2 = (p_rk[3] >> 24) & 0xff;
+            v3 = (p_rk[3]) & 0xff;
+
+            //replace
+            v0 = gcsForwardSBox[v0];
+            v1 = gcsForwardSBox[v1];
+            v2 = gcsForwardSBox[v2];
+            v3 = gcsForwardSBox[v3];
+
+            //xor
+            v0 = v0 ^ gcsRoundConstant[i];
+            v = ((unsigned int) v0) | (((unsigned int) v1) << 8) | (((unsigned int) v2) << 16) | (((unsigned int) v3) << 24);
+
+            p_rk[4] = p_rk[0] ^ v;
+
+            p_rk[5] = p_rk[1] ^ p_rk[4];
+            p_rk[6] = p_rk[2] ^ p_rk[5];
+            p_rk[7] = p_rk[3] ^ p_rk[6];
+        }
+
+    } else if (192 == key_length) {
+
+        p_rk[0] = p_32bit_key[0];
+        p_rk[1] = p_32bit_key[1];
+        p_rk[2] = p_32bit_key[2];
+        p_rk[3] = p_32bit_key[3];
+        p_rk[4] = p_32bit_key[4];
+        p_rk[5] = p_32bit_key[5];
+
+        for (i = 0; i < 8; i ++, p_rk += 6) {
+            //rotate
+            v0 = (p_rk[5] >> 8) & 0xff;
+            v1 = (p_rk[5] >> 16) & 0xff;
+            v2 = (p_rk[5] >> 24) & 0xff;
+            v3 = (p_rk[5]) & 0xff;
+
+            //replace
+            v0 = gcsForwardSBox[v0];
+            v1 = gcsForwardSBox[v1];
+            v2 = gcsForwardSBox[v2];
+            v3 = gcsForwardSBox[v3];
+
+            //xor
+            v0 = v0 ^ gcsRoundConstant[i];
+            v = ((unsigned int) v0) | (((unsigned int) v1) << 8) | (((unsigned int) v2) << 16) | (((unsigned int) v3) << 24);
+
+            p_rk[6] = p_rk[0] ^ v;
+
+            p_rk[7] = p_rk[1] ^ p_rk[6];
+            p_rk[8] = p_rk[2] ^ p_rk[7];
+            p_rk[9] = p_rk[3] ^ p_rk[8];
+            p_rk[10] = p_rk[4] ^ p_rk[9];
+            p_rk[11] = p_rk[5] ^ p_rk[10];
+        }
+
+    } else if (256 == key_length) {
+
+        p_rk[0] = p_32bit_key[0];
+        p_rk[1] = p_32bit_key[1];
+        p_rk[2] = p_32bit_key[2];
+        p_rk[3] = p_32bit_key[3];
+        p_rk[4] = p_32bit_key[4];
+        p_rk[5] = p_32bit_key[5];
+        p_rk[6] = p_32bit_key[6];
+        p_rk[7] = p_32bit_key[7];
+
+        for (i = 0; i < 7; i ++, p_rk += 8) {
+            //rotate
+            v0 = (p_rk[7] >> 8) & 0xff;
+            v1 = (p_rk[7] >> 16) & 0xff;
+            v2 = (p_rk[7] >> 24) & 0xff;
+            v3 = (p_rk[7]) & 0xff;
+
+            //replace
+            v0 = gcsForwardSBox[v0];
+            v1 = gcsForwardSBox[v1];
+            v2 = gcsForwardSBox[v2];
+            v3 = gcsForwardSBox[v3];
+
+            //xor
+            v0 = v0 ^ gcsRoundConstant[i];
+            v = ((unsigned int) v0) | (((unsigned int) v1) << 8) | (((unsigned int) v2) << 16) | (((unsigned int) v3) << 24);
+
+            p_rk[8] = p_rk[0] ^ v;
+
+            p_rk[9] = p_rk[1] ^ p_rk[8];
+            p_rk[10] = p_rk[2] ^ p_rk[9];
+            p_rk[11] = p_rk[3] ^ p_rk[10];
+
+            //no rotate here
+            v0 = (p_rk[11]) & 0xff;
+            v1 = (p_rk[11] >> 8) & 0xff;
+            v2 = (p_rk[11] >> 16) & 0xff;
+            v3 = (p_rk[11] >> 24) & 0xff;
+
+            //replace
+            v0 = gcsForwardSBox[v0];
+            v1 = gcsForwardSBox[v1];
+            v2 = gcsForwardSBox[v2];
+            v3 = gcsForwardSBox[v3];
+
+            //no xor
+            v = ((unsigned int) v0) | (((unsigned int) v1) << 8) | (((unsigned int) v2) << 16) | (((unsigned int) v3) << 24);
+
+            p_rk[12] = p_rk[4] ^ v;
+
+            p_rk[13] = p_rk[5] ^ p_rk[12];
+            p_rk[14] = p_rk[6] ^ p_rk[13];
+            p_rk[15] = p_rk[7] ^ p_rk[14];
+        }
+
+    }
+
+    return 0;
+}
+
+static void __add_round_key(unsigned int *data, unsigned int *p_rk)
+{
+    data[0] ^= p_rk[0];
+    data[1] ^= p_rk[1];
+    data[2] ^= p_rk[2];
+    data[3] ^= p_rk[3];
+}
+
+static void __substitute_bytes_and_shift_rows(unsigned char *in, unsigned char *out)
+{
+    out[0] = gcsForwardSBox[in[0]];
+    out[1] = gcsForwardSBox[in[5]];
+    out[2] = gcsForwardSBox[in[10]];
+    out[3] = gcsForwardSBox[in[15]];
+
+    out[4] = gcsForwardSBox[in[4]];
+    out[5] = gcsForwardSBox[in[9]];
+    out[6] = gcsForwardSBox[in[14]];
+    out[7] = gcsForwardSBox[in[3]];
+
+    out[8] = gcsForwardSBox[in[8]];
+    out[9] = gcsForwardSBox[in[13]];
+    out[10] = gcsForwardSBox[in[2]];
+    out[11] = gcsForwardSBox[in[7]];
+
+    out[12] = gcsForwardSBox[in[12]];
+    out[13] = gcsForwardSBox[in[1]];
+    out[14] = gcsForwardSBox[in[6]];
+    out[15] = gcsForwardSBox[in[11]];
+}
+
+static void __mix_columns(unsigned char *in, unsigned char *out)
+{
+    unsigned int i;
+    unsigned char v1, v2, v3;
+
+    for (i = 0; i < 4; i ++, in += 4, out += 4) {
+        v1 = in[0];
+        v3 = in[0] ^ in[1] ^ in[2] ^ in[3];
+
+        v2  = in[0] ^ in[1];
+        v2 = DGF28Time(v2);
+        out[0] = in[0] ^ v2 ^ v3;
+
+        v2  = in[1] ^ in[2];
+        v2 = DGF28Time(v2);
+        out[1] = in[1] ^ v2 ^ v3;
+
+        v2  = in[2] ^ in[3];
+        v2 = DGF28Time(v2);
+        out[2] = in[2] ^ v2 ^ v3;
+
+        v2  = in[3] ^ v1;
+        v2 = DGF28Time(v2);
+        out[3] = in[3] ^ v2 ^ v3;
+    }
+}
+
+static void __inverse_substitute_bytes_and_shift_rows(unsigned char *in, unsigned char *out)
+{
+    out[0] = gcsReverseSBox[in[0]];
+    out[1] = gcsReverseSBox[in[13]];
+    out[2] = gcsReverseSBox[in[10]];
+    out[3] = gcsReverseSBox[in[7]];
+
+    out[4] = gcsReverseSBox[in[4]];
+    out[5] = gcsReverseSBox[in[1]];
+    out[6] = gcsReverseSBox[in[14]];
+    out[7] = gcsReverseSBox[in[11]];
+
+    out[8] = gcsReverseSBox[in[8]];
+    out[9] = gcsReverseSBox[in[5]];
+    out[10] = gcsReverseSBox[in[2]];
+    out[11] = gcsReverseSBox[in[15]];
+
+    out[12] = gcsReverseSBox[in[12]];
+    out[13] = gcsReverseSBox[in[9]];
+    out[14] = gcsReverseSBox[in[6]];
+    out[15] = gcsReverseSBox[in[3]];
+}
+
+static void __inverse_mix_columns(unsigned char *in, unsigned char *out)
+{
+    unsigned int i;
+    unsigned char v1, v2, v3, v4;
+
+    for(i = 0; i < 4; i ++, in += 4, out += 4) {
+        v1 = in[0];
+        v2 = in[1];
+        v3 = in[2];
+        v4 = in[3];
+
+        out[0] = DGF28Multiple(v1, 0x0e) ^ DGF28Multiple(v2, 0x0b) ^ DGF28Multiple(v3, 0x0d) ^ DGF28Multiple(v4, 0x09);
+        out[1] = DGF28Multiple(v1, 0x09) ^ DGF28Multiple(v2, 0x0e) ^ DGF28Multiple(v3, 0x0b) ^ DGF28Multiple(v4, 0x0d);
+        out[2] = DGF28Multiple(v1, 0x0d) ^ DGF28Multiple(v2, 0x09) ^ DGF28Multiple(v3, 0x0e) ^ DGF28Multiple(v4, 0x0b);
+        out[3] = DGF28Multiple(v1, 0x0b) ^ DGF28Multiple(v2, 0x0d) ^ DGF28Multiple(v3, 0x09) ^ DGF28Multiple(v4, 0x0e);
+    }
+}
+
+static void __aes_encrypt_block(aes_context_t *ctx, unsigned char *p_input, unsigned char *output)
+{
+    unsigned int round = 0;
+    unsigned char rev_input[16];
+    unsigned char *input;
+
+    memcpy(rev_input, p_input, 16);
+    input = (unsigned char *) rev_input;
+
+    __add_round_key((unsigned int *) input, (unsigned int *) ctx->p_round_key);
+
+    for (round = 1; round < ctx->round; round ++) {
+        __substitute_bytes_and_shift_rows(input, output);
+        __mix_columns(output, input);
+        __add_round_key((unsigned int *) input, (unsigned int *) ctx->p_round_key + (round << 2));
+    }
+
+    __substitute_bytes_and_shift_rows(input, output);
+    __add_round_key((unsigned int *) output, (unsigned int *) ctx->p_round_key + (ctx->round << 2));
+}
+
+static void __aes_decrypt_block(aes_context_t *ctx, const unsigned char *p_input, unsigned char *output)
+{
+    unsigned int round = 0;
+    unsigned char rev_input[16];
+    unsigned char *input;
+
+    memcpy(rev_input, p_input, 16);
+    input = (unsigned char *) rev_input;
+
+    __add_round_key((unsigned int *) input, (unsigned int *) ctx->p_round_key + (ctx->round << 2));
+
+    for (round = ctx->round - 1; round > 0; round --) {
+        __inverse_substitute_bytes_and_shift_rows(input, output);
+        __add_round_key((unsigned int *) output, (unsigned int *) ctx->p_round_key + (round << 2));
+        __inverse_mix_columns(output, input);
+    }
+
+    __inverse_substitute_bytes_and_shift_rows(input, output);
+    __add_round_key((unsigned int *) output, (unsigned int *) ctx->p_round_key);
+}
+
+aes_context_t *aes_init()
+{
+    aes_context_t *thiz = (aes_context_t *) malloc(sizeof(aes_context_t));
+    if (thiz) {
+        memset(thiz, 0x0, sizeof(aes_context_t));
+    } else {
+        DCRYPT_LOG("error: no memory\n");
+    }
+    return thiz;
+}
+
+void aes_destroy(aes_context_t *ctx)
+{
+    if (ctx) {
+        free(ctx);
+    }
+}
+
+int aes_set_encrypt_key(aes_context_t *ctx, const unsigned char *key, unsigned int key_length)
+{
+    if ((!ctx) || (!key)) {
+        DCRYPT_LOG("error: null pointer\n");
+        return (-1);
+    }
+
+    if (128 == key_length) {
+        ctx->round = 10;
+    } else if (192 == key_length) {
+        ctx->round = 12;
+    } else if (256 == key_length) {
+        ctx->round = 14;
+    } else {
+        DCRYPT_LOG("error: enc invalid key_length %d\n", key_length);
+        return (-2);
+    }
+
+    return __aes_set_key(ctx->p_round_key, key, key_length);
+}
+
+int aes_set_decrypt_key(aes_context_t *ctx, const unsigned char *key, unsigned int key_length)
+{
+    if ((!ctx) || (!key)) {
+        DCRYPT_LOG("error: null pointer\n");
+        return (-1);
+    }
+
+    if (128 == key_length) {
+        ctx->round = 10;
+    } else if (192 == key_length) {
+        ctx->round = 12;
+    } else if (256 == key_length) {
+        ctx->round = 14;
+    } else {
+        DCRYPT_LOG("error: enc invalid key_length %d\n", key_length);
+        return (-2);
+    }
+
+    return __aes_set_key(ctx->p_round_key, key, key_length);
+}
+
+int aes_ecb_encrypt(aes_context_t *ctx, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        __aes_encrypt_block(ctx, input, output);
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+int aes_ecb_decrypt(aes_context_t *ctx, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        __aes_decrypt_block(ctx, input, output);
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+int aes_ctr_crypt(aes_context_t *ctx, unsigned char *p_nonce, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    unsigned int i;
+    unsigned int cur = ctx->cur_position;
+    unsigned char block[16] = {0};
+
+    while (data_length--) {
+        if (!cur) {
+            __aes_encrypt_block(ctx, input, block);
+            for (i = 16; i > 0; i--) {
+                if (++ p_nonce[i - 1] != 0) {
+                    break;
+                }
+            }
+        }
+        *output++ = ((*input++) ^ block[cur]);
+        cur = (cur + 1) & 0x0F;
+    }
+    ctx->cur_position = cur;
+
+    return 0;
+}
+
+int aes_cbc_encrypt(aes_context_t *ctx, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    unsigned int i;
+
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        for (i = 0; i < 16; i++) {
+            output[i] = input[i] ^ iv[i];
+        }
+
+        __aes_encrypt_block(ctx, output, output);
+        memcpy(iv, output, 16);
+
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+int aes_cbc_decrypt(aes_context_t *ctx, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    unsigned int i;
+    unsigned char temp[16] = {0};
+
+    if (data_length & 0xf) {
+        DCRYPT_LOG("error: invalid data_length, should be multiple of 16\n");
+        return (-2);
+    }
+
+    while (data_length > 0) {
+        memcpy(temp, input, 16);
+        __aes_decrypt_block(ctx, input, output);
+
+        for (i = 0; i < 16; i++) {
+            output[i] = output[i] ^ iv[i];
+        }
+
+        memcpy(iv, temp, 16);
+
+        input  += 16;
+        output += 16;
+        data_length -= 16;
+    }
+
+    return 0;
+}
+
+
+//one shot api
+
+int aes_ecb_encrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_encrypt_key(thiz, key, key_length);
+    if (ret) {
+        return (-2);
+    }
+
+    aes_ecb_encrypt(thiz, input, output, data_length);
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+int aes_ecb_decrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_decrypt_key(thiz, key, key_length);
+    if (ret) {
+        return (-2);
+    }
+
+    aes_ecb_decrypt(thiz, input, output, data_length);
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+int aes_ctr_crypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *p_nonce, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !p_nonce || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_encrypt_key(thiz, key, key_length);
+    if (ret) {
+        return (-2);
+    }
+
+    aes_ctr_crypt(thiz, p_nonce, input, output, data_length);
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+
+int aes_cbc_encrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !iv || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_encrypt_key(thiz, key, key_length);
+    if (ret) {
+        return ret;
+    }
+
+    ret = aes_cbc_encrypt(thiz, iv, input, output, data_length);
+    if (ret) {
+        return ret;
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+int aes_cbc_decrypt_one_shot(const unsigned char *key, unsigned int key_length, unsigned char *iv, unsigned char *input, unsigned char *output, unsigned int data_length)
+{
+    int ret = 0;
+    aes_context_t *thiz = NULL;
+
+    if (!key || !iv || !input || !output || !data_length) {
+        DCRYPT_LOG("error: invalid parameters\n");
+        return (-1);
+    }
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    ret = aes_set_decrypt_key(thiz, key, key_length);
+    if (ret) {
+        return ret;
+    }
+
+    ret = aes_cbc_decrypt(thiz, iv, input, output, data_length);
+    if (ret) {
+        return ret;
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    return 0;
+}
+
+#endif
+
diff --git a/lw_cryptography/src/aes_precalc_table.c b/lw_cryptography/src/aes_precalc_table.c
new file mode 100644
index 0000000..682c2b9
--- /dev/null
+++ b/lw_cryptography/src/aes_precalc_table.c
@@ -0,0 +1,251 @@
+/*******************************************************************************
+ * aes_precalc_table.c
+ *
+ * History:
+ *  2017/02/27 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+static unsigned char gsForwardSBox[256] = {0};
+static unsigned int gsForwardTable0[256] = {0};
+static unsigned int gsForwardTable1[256] = {0};
+static unsigned int gsForwardTable2[256] = {0};
+static unsigned int gsForwardTable3[256] = {0};
+
+static unsigned char gsReverseSBox[256] = {0};
+static unsigned int gsReverseTable0[256] = {0};
+static unsigned int gsReverseTable1[256] = {0};
+static unsigned int gsReverseTable2[256] = {0};
+static unsigned int gsReverseTable3[256] = {0};
+
+static unsigned int gsRoundConstant[10] = {0};
+
+static void __write_precalulated_tables(const char *filename)
+{
+    unsigned int i = 0, j = 0, index = 0;
+    FILE *p_file = fopen(filename, "wt+");
+
+    if (p_file) {
+
+        index = 0;
+        fprintf(p_file, "static const unsigned char gcsForwardSBox[256] = {\n");
+        for (j = 0; j < 16; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 16; i ++, index ++) {
+                fprintf(p_file, "0x%02x, ", gsForwardSBox[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+        index = 0;
+        fprintf(p_file, "static const unsigned char gcsReverseSBox[256] = {\n");
+        for (j = 0; j < 16; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 16; i ++, index ++) {
+                fprintf(p_file, "0x%02x, ", gsReverseSBox[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+
+        index = 0;
+        fprintf(p_file, "static const unsigned int gcsForwardTable0[256] = {\n");
+        for (j = 0; j < 64; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 4; i ++, index ++) {
+                fprintf(p_file, "0x%08x, ", gsForwardTable0[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+        index = 0;
+        fprintf(p_file, "static const unsigned int gcsForwardTable1[256] = {\n");
+        for (j = 0; j < 64; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 4; i ++, index ++) {
+                fprintf(p_file, "0x%08x, ", gsForwardTable1[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+        index = 0;
+        fprintf(p_file, "static const unsigned int gcsForwardTable2[256] = {\n");
+        for (j = 0; j < 64; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 4; i ++, index ++) {
+                fprintf(p_file, "0x%08x, ", gsForwardTable2[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+        index = 0;
+        fprintf(p_file, "static const unsigned int gcsForwardTable3[256] = {\n");
+        for (j = 0; j < 64; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 4; i ++, index ++) {
+                fprintf(p_file, "0x%08x, ", gsForwardTable3[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+        index = 0;
+        fprintf(p_file, "static const unsigned int gcsReverseTable0[256] = {\n");
+        for (j = 0; j < 64; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 4; i ++, index ++) {
+                fprintf(p_file, "0x%08x, ", gsReverseTable0[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+        index = 0;
+        fprintf(p_file, "static const unsigned int gcsReverseTable1[256] = {\n");
+        for (j = 0; j < 64; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 4; i ++, index ++) {
+                fprintf(p_file, "0x%08x, ", gsReverseTable1[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+        index = 0;
+        fprintf(p_file, "static const unsigned int gcsReverseTable2[256] = {\n");
+        for (j = 0; j < 64; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 4; i ++, index ++) {
+                fprintf(p_file, "0x%08x, ", gsReverseTable2[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+        index = 0;
+        fprintf(p_file, "static const unsigned int gcsReverseTable3[256] = {\n");
+        for (j = 0; j < 64; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 4; i ++, index ++) {
+                fprintf(p_file, "0x%08x, ", gsReverseTable3[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+        index = 0;
+        fprintf(p_file, "static const unsigned int gcsRoundConstant[10] = {\n");
+        for (j = 0; j < 2; j ++) {
+            fprintf(p_file, "    ");
+            for (i = 0; i < 5; i ++, index ++) {
+                fprintf(p_file, "0x%08x, ", gsRoundConstant[index]);
+            }
+            fprintf(p_file, "\n");
+        }
+        fprintf(p_file, "};\n\n\n");
+
+    }
+
+    return;
+}
+
+int main()
+{
+
+#define DLogicLeftRotate8(x) ((x << 8) & 0xFFFFFFFF) | (x >> 24)
+#define DGF28Time(x) ((x << 1) ^ ((x & 0x80) ? 0x1B : 0x00))
+#define DGF28Multiply(x,y) ((x && y) ? pow[(log[x] + log[y]) % 255] : 0)
+
+    unsigned int i, x, y, z;
+    unsigned int pow[256] = {0};
+    unsigned int log[256] = {0};
+
+    for ( i = 0, x = 1; i < 256; i++ ) {
+        pow[i] = x;
+        log[x] = i;
+        x = (x ^ DGF28Time(x)) & 0xFF;
+    }
+
+    for ( i = 0, x = 1; i < 10; i++ ) {
+        gsRoundConstant[i] = (unsigned int) x;
+        x = DGF28Time(x) & 0xFF;
+    }
+
+    gsForwardSBox[0x00] = 0x63;
+    gsReverseSBox[0x63] = 0x00;
+
+    for ( i = 1; i < 256; i++ ) {
+        x = pow[255 - log[i]];
+        y  = x;
+        y = ((y << 1) | (y >> 7)) & 0xFF;
+        x ^= y;
+        y = ((y << 1) | (y >> 7)) & 0xFF;
+        x ^= y;
+        y = ((y << 1) | (y >> 7)) & 0xFF;
+        x ^= y;
+        y = ((y << 1) | (y >> 7)) & 0xFF;
+        x ^= y ^ 0x63;
+
+        gsForwardSBox[i] = (unsigned char) x;
+        gsReverseSBox[x] = (unsigned char) i;
+    }
+
+    for( i = 0; i < 256; i ++ ) {
+        x = gsForwardSBox[i];
+        y = DGF28Time(x) & 0xFF;
+        z =  (y ^ x) & 0xFF;
+
+        gsForwardTable0[i] = y ^ (x <<  8) ^ (x << 16) ^ (z << 24);
+
+        gsForwardTable1[i] = DLogicLeftRotate8(gsForwardTable0[i]);
+        gsForwardTable2[i] = DLogicLeftRotate8(gsForwardTable1[i]);
+        gsForwardTable3[i] = DLogicLeftRotate8(gsForwardTable2[i]);
+
+        x = gsReverseSBox[i];
+
+        gsReverseTable0[i] = (DGF28Multiply(0x0E, x)) ^ (DGF28Multiply(0x09, x) <<  8) ^ (DGF28Multiply(0x0D, x) << 16) ^ (DGF28Multiply(0x0B, x) << 24);
+
+        gsReverseTable1[i] = DLogicLeftRotate8(gsReverseTable0[i]);
+        gsReverseTable2[i] = DLogicLeftRotate8(gsReverseTable1[i]);
+        gsReverseTable3[i] = DLogicLeftRotate8(gsReverseTable2[i]);
+    }
+
+    __write_precalulated_tables("precalc_aes_tables.txt");
+
+    return 0;
+}
+
+
diff --git a/lw_cryptography/src/big_number.c b/lw_cryptography/src/big_number.c
index ecb9ada..8c06d01 100644
--- a/lw_cryptography/src/big_number.c
+++ b/lw_cryptography/src/big_number.c
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * big_number.c
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include "cryptography_if.h"
 
@@ -20,23 +38,43 @@
 #include <stdlib.h>
 #else
 #include <bldfunc.h>
+typedef unsigned int size_t;
 #endif
 
 #include "big_number.h"
 #include "big_number_asm.h"
 
+//#define D_DUMP_FOR_DEBUG
+
+#ifdef D_DUMP_FOR_DEBUG
+void __dump_file(const char *filename_base, int index, unsigned char *p, unsigned int size)
+{
+    char __filename[256] = {0};
+    snprintf(__filename, sizeof(__filename), "%s_%d.dump", filename_base, index);
+    FILE *pf = fopen(__filename, "wb+");
+    if (pf) {
+        fwrite(p, 1, size, pf);
+        fclose(pf);
+    }
+}
+#endif
+
 #define D_BIG_NUMBER_MAX_BITS_SCALE100          (100 * D_BIG_NUMBER_MAX_BITS)
 #define D_LN_2_DIV_LN_10_SCALE100                 332
 #define D_BIG_NUMBER_RW_BUFFER_SIZE             (((D_BIG_NUMBER_MAX_BITS_SCALE100 + D_LN_2_DIV_LN_10_SCALE100 - 1) / D_LN_2_DIV_LN_10_SCALE100) + 10 + 6)
 
-#define DCHARS_IN_LIMB    (sizeof(unsigned int))
+#define DCHARS_IN_LIMB    (sizeof(TUINT))
 #define DBITS_IN_LIMB    (DCHARS_IN_LIMB << 3)
 #define DHALF_BITS_IN_LIMB    (DCHARS_IN_LIMB << 2)
 
-#define DBITS_TO_LIMBS(i)  (((i) + DBITS_IN_LIMB - 1) / DBITS_IN_LIMB)
-#define DCHARS_TO_LIMBS(i) (((i) + DCHARS_IN_LIMB - 1) / DCHARS_IN_LIMB)
+#define MPI_SIZE_T_MAX  ( (size_t) -1 ) /* SIZE_T_MAX is not standard */
 
-static void __zeroize(void *v, unsigned int n)
+//#define DBITS_TO_LIMBS(i)  (((i) + DBITS_IN_LIMB - 1) / DBITS_IN_LIMB)
+//#define DCHARS_TO_LIMBS(i) (((i) + DCHARS_IN_LIMB - 1) / DCHARS_IN_LIMB)
+#define DBITS_TO_LIMBS(i)  ((i) / DBITS_IN_LIMB + ( (i) % DBITS_IN_LIMB != 0 ))
+#define DCHARS_TO_LIMBS(i) ((i) / DCHARS_IN_LIMB + ( (i) % DCHARS_IN_LIMB != 0 ))
+
+static void __zerosize(void *v, unsigned int n)
 {
     volatile unsigned char *p = v;
 
@@ -73,7 +111,7 @@ void big_number_free(big_number_t* X)
     }
 
     if ( X->p != NULL ) {
-        __zeroize(X->p, X->n * DCHARS_IN_LIMB);
+        __zerosize(X->p, X->n * DCHARS_IN_LIMB);
         free(X->p);
     }
 
@@ -84,7 +122,7 @@ void big_number_free(big_number_t* X)
 
 int big_number_grow(big_number_t* X, unsigned int nblimbs)
 {
-    unsigned int *p;
+    TUINT *p;
 
     if (nblimbs > D_BIG_NUMBER_MAX_LIMBS) {
         return CRYPTO_ECODE_ERROR_NO_MEMORY;
@@ -99,7 +137,7 @@ int big_number_grow(big_number_t* X, unsigned int nblimbs)
 
         if (X->p != NULL) {
             memcpy(p, X->p, X->n * DCHARS_IN_LIMB);
-            __zeroize(X->p, X->n * DCHARS_IN_LIMB);
+            __zerosize(X->p, X->n * DCHARS_IN_LIMB);
             free(X->p);
         }
 
@@ -112,7 +150,7 @@ int big_number_grow(big_number_t* X, unsigned int nblimbs)
 
 int big_number_shrink(big_number_t* X, unsigned int nblimbs)
 {
-    unsigned int *p;
+    TUINT *p;
     unsigned int i;
 
     if (X->n <= nblimbs) {
@@ -138,7 +176,7 @@ int big_number_shrink(big_number_t* X, unsigned int nblimbs)
 
     if (X->p != NULL) {
         memcpy(p, X->p, i * DCHARS_IN_LIMB);
-        __zeroize(X->p, X->n * DCHARS_IN_LIMB);
+        __zerosize(X->p, X->n * DCHARS_IN_LIMB);
         free (X->p);
     }
 
@@ -217,7 +255,7 @@ int big_number_safe_cond_swap(big_number_t *X, big_number_t *Y, unsigned char sw
 {
     int ret, s;
     unsigned int i;
-    unsigned int tmp;
+    TUINT tmp;
 
     if (X == Y) {
         return CRYPTO_ECODE_OK;
@@ -243,11 +281,11 @@ cleanup:
     return ret;
 }
 
-int big_number_lset(big_number_t *X, int z)
+int big_number_lset(big_number_t *X, TSINT z)
 {
     int ret;
 
-    D_CLEAN_IF_FAILED( big_number_grow(X, 1));
+    D_CLEAN_IF_FAILED(big_number_grow(X, 1));
     memset(X->p, 0, X->n * DCHARS_IN_LIMB);
 
     X->p[0] = (z < 0) ? -z : z;
@@ -285,8 +323,8 @@ int big_number_set_bit( big_number_t *X, unsigned int pos, unsigned char val )
         D_CLEAN_IF_FAILED( big_number_grow(X, off + 1));
     }
 
-    X->p[off] &= ~((unsigned int) 0x01 << idx);
-    X->p[off] |= (unsigned int) val << idx;
+    X->p[off] &= ~((TUINT) 0x01 << idx);
+    X->p[off] |= (TUINT) val << idx;
 
 cleanup:
 
@@ -336,7 +374,7 @@ unsigned int big_number_size(const big_number_t *X)
     return ((big_number_msb(X) + 7) >> 3);
 }
 
-static int big_number_get_digit(unsigned int *d, int radix, char c)
+static int big_number_get_digit(TUINT *d, int radix, char c)
 {
     *d = 255;
 
@@ -352,7 +390,7 @@ static int big_number_get_digit(unsigned int *d, int radix, char c)
         *d = c - 0x57;
     }
 
-    if ( *d >= (unsigned int) radix ) {
+    if (*d >= (TUINT) radix) {
         return CRYPTO_ECODE_INVALID_CHARACTER;
     }
 
@@ -363,7 +401,7 @@ int big_number_read_string(big_number_t *X, int radix, const char *s)
 {
     int ret;
     unsigned int i, j, slen, n;
-    unsigned int d;
+    TUINT d;
     big_number_t T;
 
     if (radix < 2 || radix > 16) {
@@ -375,6 +413,9 @@ int big_number_read_string(big_number_t *X, int radix, const char *s)
     slen = strlen(s);
 
     if (radix == 16) {
+        if ( slen > MPI_SIZE_T_MAX >> 2 ) {
+             return( CRYPTO_ECODE_BAD_INPUT_DATA );
+        }
         n = DBITS_TO_LIMBS(slen << 2);
 
         D_CLEAN_IF_FAILED(big_number_grow( X, n));
@@ -419,7 +460,7 @@ cleanup:
 static int big_number_write_hlp(big_number_t *X, int radix, char **p)
 {
     int ret;
-    unsigned int r;
+    TUINT r;
 
     if (radix < 2 || radix > 16) {
         return CRYPTO_ECODE_BAD_INPUT_DATA;
@@ -518,7 +559,7 @@ cleanup:
 #ifndef DNOT_INCLUDE_C_HEADER
 int big_number_read_file(big_number_t* X, int radix, void* f)
 {
-    unsigned int d;
+    TUINT d;
     unsigned int slen;
     char *p;
     FILE* fin = (FILE*) f;
@@ -608,7 +649,7 @@ int big_number_read_binary(big_number_t* X, const unsigned char* buf, unsigned i
     D_CLEAN_IF_FAILED(big_number_lset(X, 0));
 
     for (i = buflen, j = 0; i > n; i--, j++) {
-        X->p[j / DCHARS_IN_LIMB] |= ((unsigned int) buf[i - 1]) << ((j % DCHARS_IN_LIMB) << 3);
+        X->p[j / DCHARS_IN_LIMB] |= ((TUINT) buf[i - 1]) << ((j % DCHARS_IN_LIMB) << 3);
     }
 
 cleanup:
@@ -639,7 +680,7 @@ int big_number_shift_l(big_number_t* X, unsigned int count)
 {
     int ret;
     unsigned int i, v0, t1;
-    unsigned int r0 = 0, r1;
+    TUINT r0 = 0, r1;
 
     v0 = count / (DBITS_IN_LIMB);
     t1 = count & (DBITS_IN_LIMB - 1);
@@ -679,7 +720,7 @@ cleanup:
 int big_number_shift_r(big_number_t* X, unsigned int count)
 {
     unsigned int i, v0, v1;
-    unsigned int r0 = 0, r1;
+    TUINT r0 = 0, r1;
 
     v0 = count /  DBITS_IN_LIMB;
     v1 = count & (DBITS_IN_LIMB - 1);
@@ -800,10 +841,10 @@ int big_number_cmp_big_number(const big_number_t* X, const big_number_t* Y)
     return 0;
 }
 
-int big_number_cmp_int(const big_number_t *X, int z)
+int big_number_cmp_int(const big_number_t *X, TSINT z)
 {
     big_number_t Y;
-    unsigned int p[1];
+    TUINT p[1];
 
     *p  = (z < 0) ? -z : z;
     Y.s = (z < 0) ? -1 : 1;
@@ -817,7 +858,7 @@ int big_number_add_abs(big_number_t *X, const big_number_t *A, const big_number_
 {
     int ret;
     unsigned int i, j;
-    unsigned int *o, *p, c;
+    TUINT *o, *p, c;
 
     if (X == B) {
         const big_number_t *T = A; A = X; B = T;
@@ -858,10 +899,10 @@ cleanup:
     return ret;
 }
 
-static void big_number_sub_hlp(unsigned int n, unsigned int* s, unsigned int* d)
+static void big_number_sub_hlp(unsigned int n, TUINT *s, TUINT *d)
 {
     unsigned int i;
-    unsigned int c, z;
+    TUINT c, z;
 
     for (i = c = 0; i < n; i++, s++, d++) {
         z = (*d <  c);     *d -=  c;
@@ -958,10 +999,10 @@ cleanup:
     return ret;
 }
 
-int big_number_add_int(big_number_t* X, const big_number_t* A, int b)
+int big_number_add_int(big_number_t* X, const big_number_t* A, TSINT b)
 {
     big_number_t _B;
-    unsigned int p[1];
+    TUINT p[1];
 
     p[0] = ( b < 0 ) ? -b : b;
     _B.s = ( b < 0 ) ? -1 : 1;
@@ -971,10 +1012,10 @@ int big_number_add_int(big_number_t* X, const big_number_t* A, int b)
     return (big_number_add_big_number(X, A, &_B));
 }
 
-int big_number_sub_int(big_number_t* X, const big_number_t* A, int b)
+int big_number_sub_int(big_number_t* X, const big_number_t* A, TSINT b)
 {
     big_number_t _B;
-    unsigned int p[1];
+    TUINT p[1];
 
     p[0] = ( b < 0 ) ? -b : b;
     _B.s = ( b < 0 ) ? -1 : 1;
@@ -984,9 +1025,9 @@ int big_number_sub_int(big_number_t* X, const big_number_t* A, int b)
     return (big_number_sub_big_number(X, A, &_B));
 }
 
-static void big_number_mul_hlp(unsigned int i, unsigned int* s, unsigned int* d, unsigned int b)
+static void big_number_mul_hlp(unsigned int i, TUINT *s, TUINT *d, TUINT b)
 {
-    unsigned int c = 0, t = 0;
+    TUINT c = 0, t = 0;
 
 #if defined(MULADDC_HUIT)
 
@@ -1090,10 +1131,10 @@ cleanup:
     return( ret );
 }
 
-int big_number_mul_int(big_number_t* X, const big_number_t* A, int b)
+int big_number_mul_int(big_number_t* X, const big_number_t* A, TSINT b)
 {
     big_number_t _B;
-    unsigned int p[1];
+    TUINT p[1];
 
     _B.s = 1;
     _B.n = 1;
@@ -1165,17 +1206,55 @@ int big_number_div_big_number(big_number_t* Q, big_number_t* R, const big_number
         if (X.p[i] >= Y.p[t]) {
             Z.p[i - t - 1] = ~0;
         } else {
-            unsigned long long r;
+#ifdef DHAVE_DOUBLE_LONG_INT
+            TUDBL r;
 
-            r  = (unsigned long long) X.p[i] << DBITS_IN_LIMB;
-            r |= (unsigned long long) X.p[i - 1];
+            r  = (TUDBL) X.p[i] << DBITS_IN_LIMB;
+            r |= (TUDBL) X.p[i - 1];
             r /= Y.p[t];
+            if (r > ((TUDBL) 1 << DBITS_IN_LIMB) - 1) {
+                r = ((TUDBL) 1 << DBITS_IN_LIMB) - 1;
+            }
 
-            if (r > ((unsigned long long) 1 << DBITS_IN_LIMB) - 1) {
-                r = ((unsigned long long) 1 << DBITS_IN_LIMB) - 1;
+            Z.p[i - t - 1] = (TUINT) r;
+#else
+            TUINT q0, q1, r0, r1;
+            TUINT d0, d1, d, m;
+
+            d  = Y.p[t];
+            d0 = ( d << DHALF_BITS_IN_LIMB ) >> DHALF_BITS_IN_LIMB;
+            d1 = ( d >> DHALF_BITS_IN_LIMB );
+
+            q1 = X.p[i] / d1;
+            r1 = X.p[i] - d1 * q1;
+            r1 <<= DHALF_BITS_IN_LIMB;
+            r1 |= ( X.p[i - 1] >> DHALF_BITS_IN_LIMB );
+
+            m = q1 * d0;
+            if( r1 < m )
+            {
+                q1--, r1 += d;
+                while( r1 >= d && r1 < m )
+                    q1--, r1 += d;
             }
+            r1 -= m;
+
+            q0 = r1 / d1;
+            r0 = r1 - d1 * q0;
+            r0 <<= DHALF_BITS_IN_LIMB;
+            r0 |= ( X.p[i - 1] << DHALF_BITS_IN_LIMB ) >> DHALF_BITS_IN_LIMB;
+
+            m = q0 * d0;
+            if( r0 < m )
+            {
+                q0--, r0 += d;
+                while( r0 >= d && r0 < m )
+                    q0--, r0 += d;
+            }
+            r0 -= m;
 
-            Z.p[i - t - 1] = (unsigned int) r;
+            Z.p[i - t - 1] = ( q1 << DHALF_BITS_IN_LIMB ) | q0;
+#endif
         }
 
         Z.p[i - t - 1]++;
@@ -1232,10 +1311,10 @@ cleanup:
     return ret;
 }
 
-int big_number_div_int(big_number_t *Q, big_number_t *R, const big_number_t *A, int b)
+int big_number_div_int(big_number_t *Q, big_number_t *R, const big_number_t *A, TSINT b)
 {
     big_number_t _B;
-    unsigned int p[1];
+    TUINT p[1];
 
     p[0] = ( b < 0 ) ? -b : b;
     _B.s = ( b < 0 ) ? -1 : 1;
@@ -1245,7 +1324,7 @@ int big_number_div_int(big_number_t *Q, big_number_t *R, const big_number_t *A,
     return (big_number_div_big_number(Q, R, A, &_B));
 }
 
-int big_number_mod_big_number(big_number_t* R, const big_number_t* A, const big_number_t* B)
+int big_number_mod_big_number(big_number_t *R, const big_number_t *A, const big_number_t *B)
 {
     int ret;
 
@@ -1268,10 +1347,10 @@ cleanup:
     return ret;
 }
 
-int big_number_mod_int(unsigned int* r, const big_number_t* A, int b)
+int big_number_mod_int(TUINT *r, const big_number_t *A, TSINT b)
 {
     unsigned int i;
-    unsigned int x, y, z;
+    TUINT x, y, z;
 
     if (b == 0) {
         return CRYPTO_ECODE_DIVISION_BY_ZERO;
@@ -1312,9 +1391,9 @@ int big_number_mod_int(unsigned int* r, const big_number_t* A, int b)
     return CRYPTO_ECODE_OK;
 }
 
-static void big_number_montg_init(unsigned int* mm, const big_number_t* N)
+static void big_number_montg_init(TUINT *mm, const big_number_t* N)
 {
-    unsigned int x, m0 = N->p[0];
+    TUINT x, m0 = N->p[0];
     unsigned int i;
 
     x  = m0;
@@ -1327,10 +1406,10 @@ static void big_number_montg_init(unsigned int* mm, const big_number_t* N)
     *mm = ~x + 1;
 }
 
-static void big_number_montmul(big_number_t* A, const big_number_t* B, const big_number_t* N, unsigned int mm, const big_number_t* T)
+static void big_number_montmul(big_number_t* A, const big_number_t* B, const big_number_t* N, TUINT mm, const big_number_t* T)
 {
     unsigned int i, n, m;
-    unsigned int u0, u1, *d;
+    TUINT u0, u1, *d;
 
     memset(T->p, 0, T->n * DCHARS_IN_LIMB);
 
@@ -1357,9 +1436,9 @@ static void big_number_montmul(big_number_t* A, const big_number_t* B, const big
     }
 }
 
-static void big_number_montred(big_number_t* A, const big_number_t* N, unsigned int mm, const big_number_t* T)
+static void big_number_montred(big_number_t* A, const big_number_t* N, TUINT mm, const big_number_t* T)
 {
-    unsigned int z = 1;
+    TUINT z = 1;
     big_number_t U;
 
     U.n = U.s = (int) z;
@@ -1374,7 +1453,8 @@ int big_number_exp_mod(big_number_t* X, const big_number_t* A, const big_number_
     unsigned int wbits, wsize, one = 1;
     unsigned int i, j, nblimbs;
     unsigned int bufsize, nbits;
-    unsigned int ei, mm, state;
+    TUINT ei, mm, state;
+    unsigned int cal_count = 0;
     big_number_t RR, T, W[2 << D_BIG_NUMBER_WINDOW_SIZE], Apos;
     int neg;
 
@@ -1432,11 +1512,31 @@ int big_number_exp_mod(big_number_t* X, const big_number_t* A, const big_number_
         D_CLEAN_IF_FAILED(big_number_copy(&W[1], A));
     }
 
+#ifdef D_DUMP_FOR_DEBUG
+//#if 0
+    printf("mm 0x%08x\n", mm);
+    __dump_file("RRmodN_input", 0, (unsigned char *) RR.p, RR.n * DCHARS_IN_LIMB);
+    __dump_file("W_input", 0, (unsigned char *) W[1].p, W[1].n * DCHARS_IN_LIMB);
+    __dump_file("N_input", 0, (unsigned char *) N->p, N->n * DCHARS_IN_LIMB);
+#endif
+
     big_number_montmul(&W[1], &RR, N, mm, &T);
 
     D_CLEAN_IF_FAILED(big_number_copy(X, &RR));
+
+#ifdef D_DUMP_FOR_DEBUG
+//#if 0
+    __dump_file("X_start", 0, (unsigned char *) X->p, X->n * DCHARS_IN_LIMB);
+    __dump_file("W_start", 0, (unsigned char *) W[1].p, W[1].n * DCHARS_IN_LIMB);
+#endif
+
     big_number_montred(X, N, mm, &T);
 
+#ifdef D_DUMP_FOR_DEBUG
+//#if 0
+    __dump_file("X_red", 0, (unsigned char *) X->p, X->n * DCHARS_IN_LIMB);
+#endif
+
     if (wsize > 1) {
         j =  one << ( wsize - 1 );
 
@@ -1469,7 +1569,7 @@ int big_number_exp_mod(big_number_t* X, const big_number_t* A, const big_number_
 
             nblimbs--;
 
-            bufsize = sizeof( unsigned int ) << 3;
+            bufsize = sizeof(TUINT) << 3;
         }
 
         bufsize--;
@@ -1482,6 +1582,10 @@ int big_number_exp_mod(big_number_t* X, const big_number_t* A, const big_number_
 
         if (ei == 0 && state == 1) {
             big_number_montmul(X, X, N, mm, &T);
+#ifdef D_DUMP_FOR_DEBUG
+            __dump_file("X", cal_count - 1, (unsigned char *) X->p, X->n * DCHARS_IN_LIMB);
+#endif
+            cal_count ++;
             continue;
         }
 
@@ -1493,10 +1597,29 @@ int big_number_exp_mod(big_number_t* X, const big_number_t* A, const big_number_
         if (nbits == wsize) {
             for (i = 0; i < wsize; i++) {
                 big_number_montmul(X, X, N, mm, &T);
+#ifdef D_DUMP_FOR_DEBUG
+                if (cal_count) {
+                    __dump_file("X", cal_count - 1, (unsigned char *) X->p, X->n * DCHARS_IN_LIMB);
+                } else {
+                    __dump_file("X_ooo", 0, (unsigned char *) X->p, X->n * DCHARS_IN_LIMB);
+                    printf("wbits %d\n", wbits);
+                    __dump_file("W_ooo", 0, (unsigned char *) W[wbits].p, W[wbits].n * DCHARS_IN_LIMB);
+                    __dump_file("N_ooo", 0, (unsigned char *) N->p, N->n * DCHARS_IN_LIMB);
+                }
+#endif
             }
 
             big_number_montmul(X, &W[wbits], N, mm, &T);
 
+#ifdef D_DUMP_FOR_DEBUG
+            if (!cal_count) {
+                __dump_file("X_first_bit", 0, (unsigned char *) X->p, X->n * DCHARS_IN_LIMB);
+            } else {
+                __dump_file("X_end_mul", 0, (unsigned char *) X->p, X->n * DCHARS_IN_LIMB);
+            }
+#endif
+
+            cal_count ++;
             state--;
             nbits = 0;
             wbits = 0;
@@ -1515,6 +1638,10 @@ int big_number_exp_mod(big_number_t* X, const big_number_t* A, const big_number_
 
     big_number_montred(X, N, mm, &T);
 
+#ifdef D_DUMP_FOR_DEBUG
+        __dump_file("X_end", 1, (unsigned char *) X->p, X->n * DCHARS_IN_LIMB);
+#endif
+
     if (neg) {
         X->s = -1;
         D_CLEAN_IF_FAILED(big_number_add_big_number(X, N, X));
@@ -1603,7 +1730,7 @@ cleanup:
     return ret;
 }
 
-int big_number_inv_mod(big_number_t* X, const big_number_t* A, const big_number_t*N )
+int big_number_inv_mod(big_number_t* X, const big_number_t* A, const big_number_t*N)
 {
     int ret;
     big_number_t G, TA, TU, U1, U2, TB, TV, V1, V2;
@@ -1675,11 +1802,11 @@ int big_number_inv_mod(big_number_t* X, const big_number_t* A, const big_number_
         }
     } while (big_number_cmp_int(&TU, 0) != 0);
 
-    while (big_number_cmp_int( &V1, 0 ) < 0) {
+    while (big_number_cmp_int(&V1, 0) < 0) {
         D_CLEAN_IF_FAILED(big_number_add_big_number(&V1, &V1, N));
     }
 
-    while (big_number_cmp_big_number( &V1, N ) >= 0) {
+    while (big_number_cmp_big_number( &V1, N) >= 0) {
         D_CLEAN_IF_FAILED(big_number_sub_big_number(&V1, &V1, N));
     }
 
@@ -1728,7 +1855,7 @@ static int big_number_check_small_factors(const big_number_t* X)
 {
     int ret = 0;
     unsigned int i;
-    unsigned int r;
+    TUINT r;
 
     if ((X->p[0] & 1) == 0) {
         return CRYPTO_ECODE_NOT_ACCEPTABLE;
@@ -1861,7 +1988,7 @@ int big_number_gen_prime(big_number_t* X, unsigned int nbits, int dh_flag, int (
 {
     int ret;
     unsigned int k, n;
-    unsigned int r;
+    TUINT r;
     big_number_t Y;
 
     if (nbits < 3 || nbits > D_BIG_NUMBER_MAX_BITS) {
diff --git a/lw_cryptography/src/big_number.h b/lw_cryptography/src/big_number.h
index 0f13565..71d1f34 100644
--- a/lw_cryptography/src/big_number.h
+++ b/lw_cryptography/src/big_number.h
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * big_number.h
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 
 #ifndef __BIG_NUMBER_H__
@@ -28,7 +46,7 @@ int big_number_copy(big_number_t* X, const big_number_t* Y);
 void big_number_swap(big_number_t* X, big_number_t* Y);
 int big_number_safe_cond_assign(big_number_t* X, const big_number_t* Y, unsigned char assign);
 int big_number_safe_cond_swap(big_number_t* X, big_number_t* Y, unsigned char assign);
-int big_number_lset(big_number_t* X, int z);
+int big_number_lset(big_number_t* X, TSINT z);
 int big_number_get_bit(const big_number_t* X, unsigned int pos);
 int big_number_set_bit(big_number_t* X, unsigned int pos, unsigned char val);
 unsigned int big_number_lsb(const big_number_t* X);
@@ -41,19 +59,19 @@ int big_number_shift_l(big_number_t* X, unsigned int count);
 int big_number_shift_r(big_number_t* X, unsigned int count);
 int big_number_cmp_abs(const big_number_t* X, const big_number_t* Y);
 int big_number_cmp_big_number(const big_number_t* X, const big_number_t* Y);
-int big_number_cmp_int(const big_number_t* X, int z);
+int big_number_cmp_int(const big_number_t* X, TSINT z);
 int big_number_add_abs(big_number_t* X, const big_number_t* A, const big_number_t* B);
 int big_number_sub_abs(big_number_t* X, const big_number_t* A, const big_number_t* B);
 int big_number_add_big_number(big_number_t* X, const big_number_t* A, const big_number_t* B);
 int big_number_sub_big_number(big_number_t* X, const big_number_t* A, const big_number_t* B);
-int big_number_add_int(big_number_t* X, const big_number_t* A, int b);
-int big_number_sub_int(big_number_t* X, const big_number_t* A, int b);
+int big_number_add_int(big_number_t* X, const big_number_t* A, TSINT b);
+int big_number_sub_int(big_number_t* X, const big_number_t* A, TSINT b);
 int big_number_mul_big_number(big_number_t* X, const big_number_t* A, const big_number_t* B);
-int big_number_mul_int(big_number_t* X, const big_number_t* A, int b);
+int big_number_mul_int(big_number_t* X, const big_number_t* A, TSINT b);
 int big_number_div_big_number(big_number_t* Q, big_number_t* R, const big_number_t* A, const big_number_t* B);
-int big_number_div_int(big_number_t* Q, big_number_t* R, const big_number_t* A, int b);
+int big_number_div_int(big_number_t* Q, big_number_t* R, const big_number_t* A, TSINT b);
 int big_number_mod_big_number(big_number_t* R, const big_number_t* A, const big_number_t* B);
-int big_number_mod_int(unsigned int* r, const big_number_t* A, int b);
+int big_number_mod_int(TUINT *r, const big_number_t *A, TSINT b);
 int big_number_exp_mod(big_number_t* X, const big_number_t* A, const big_number_t* E, const big_number_t* N, big_number_t* _RR);
 int big_number_fill_random(big_number_t* X, unsigned int size, int (*f_rng)(void*, unsigned char*, unsigned int), void* p_rng);
 int big_number_gcd(big_number_t* G, const big_number_t* A, const big_number_t* B);
diff --git a/lw_cryptography/src/big_number_asm.h b/lw_cryptography/src/big_number_asm.h
index e3158eb..58da383 100644
--- a/lw_cryptography/src/big_number_asm.h
+++ b/lw_cryptography/src/big_number_asm.h
@@ -1,30 +1,50 @@
-/**
+/*******************************************************************************
  * big_number_asm.h
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #ifndef __BIG_NUMBER_ASM_H__
 #define __BIG_NUMBER_ASM_H__
 
+#ifndef D_DISABLE_ASM
+
 #if defined(__GNUC__)
 #if defined(__i386__)
 
 #define MULADDC_INIT                        \
     asm(                                    \
-                                            "movl   %%ebx, %0           \n\t"   \
-                                            "movl   %5, %%esi           \n\t"   \
-                                            "movl   %6, %%edi           \n\t"   \
-                                            "movl   %7, %%ecx           \n\t"   \
-                                            "movl   %8, %%ebx           \n\t"
+        "movl   %%ebx, %0           \n\t"   \
+        "movl   %5, %%esi           \n\t"   \
+        "movl   %6, %%edi           \n\t"   \
+        "movl   %7, %%ecx           \n\t"   \
+        "movl   %8, %%ebx           \n\t"
 
 #define MULADDC_CORE                        \
     "lodsl                      \n\t"   \
@@ -36,7 +56,7 @@
     "movl   %%edx,   %%ecx      \n\t"   \
     "stosl                      \n\t"
 
-#if defined(POLARSSL_HAVE_SSE2)
+#if defined(HAVE_SSE2)
 
 #define MULADDC_HUIT                            \
     "movd     %%ecx,     %%mm1      \n\t"   \
@@ -130,11 +150,11 @@
 
 #define MULADDC_INIT                        \
     asm(                                    \
-                                            "movq   %3, %%rsi           \n\t"   \
-                                            "movq   %4, %%rdi           \n\t"   \
-                                            "movq   %5, %%rcx           \n\t"   \
-                                            "movq   %6, %%rbx           \n\t"   \
-                                            "xorq   %%r8, %%r8          \n\t"
+        "movq   %3, %%rsi           \n\t"   \
+        "movq   %4, %%rdi           \n\t"   \
+        "movq   %5, %%rcx           \n\t"   \
+        "movq   %6, %%rbx           \n\t"   \
+        "xorq   %%r8, %%r8          \n\t"
 
 #define MULADDC_CORE                        \
     "movq   (%%rsi), %%rax      \n\t"   \
@@ -159,396 +179,25 @@
 
 #endif /* AMD64 */
 
-#if defined(__mc68020__) || defined(__mcpu32__)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-                                        "movl   %3, %%a2        \n\t"   \
-                                        "movl   %4, %%a3        \n\t"   \
-                                        "movl   %5, %%d3        \n\t"   \
-                                        "movl   %6, %%d2        \n\t"   \
-                                        "moveq  #0, %%d0        \n\t"
-
-#define MULADDC_CORE                    \
-    "movel  %%a2@+, %%d1    \n\t"   \
-    "mulul  %%d2, %%d4:%%d1 \n\t"   \
-    "addl   %%d3, %%d1      \n\t"   \
-    "addxl  %%d0, %%d4      \n\t"   \
-    "moveq  #0,   %%d3      \n\t"   \
-    "addl   %%d1, %%a3@+    \n\t"   \
-    "addxl  %%d4, %%d3      \n\t"
-
-#define MULADDC_STOP                    \
-    "movl   %%d3, %0        \n\t"   \
-    "movl   %%a3, %1        \n\t"   \
-    "movl   %%a2, %2        \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "d0", "d1", "d2", "d3", "d4", "a2", "a3"  \
-        );
-
-#define MULADDC_HUIT                        \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d4:%%d1  \n\t"   \
-    "addxl  %%d3,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d4       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d3:%%d1  \n\t"   \
-    "addxl  %%d4,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d3       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d4:%%d1  \n\t"   \
-    "addxl  %%d3,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d4       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d3:%%d1  \n\t"   \
-    "addxl  %%d4,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d3       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d4:%%d1  \n\t"   \
-    "addxl  %%d3,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d4       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d3:%%d1  \n\t"   \
-    "addxl  %%d4,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d3       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d4:%%d1  \n\t"   \
-    "addxl  %%d3,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d4       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "movel  %%a2@+,  %%d1       \n\t"   \
-    "mulul  %%d2,    %%d3:%%d1  \n\t"   \
-    "addxl  %%d4,    %%d1       \n\t"   \
-    "addxl  %%d0,    %%d3       \n\t"   \
-    "addl   %%d1,    %%a3@+     \n\t"   \
-    "addxl  %%d0,    %%d3       \n\t"
-
-#endif /* MC68000 */
-
-#if defined(__powerpc64__) || defined(__ppc64__)
-
-#if defined(__MACH__) && defined(__APPLE__)
-
-#define MULADDC_INIT                        \
-    asm(                                    \
-                                            "ld     r3, %3              \n\t"   \
-                                            "ld     r4, %4              \n\t"   \
-                                            "ld     r5, %5              \n\t"   \
-                                            "ld     r6, %6              \n\t"   \
-                                            "addi   r3, r3, -8          \n\t"   \
-                                            "addi   r4, r4, -8          \n\t"   \
-                                            "addic  r5, r5,  0          \n\t"
-
-#define MULADDC_CORE                        \
-    "ldu    r7, 8(r3)           \n\t"   \
-    "mulld  r8, r7, r6          \n\t"   \
-    "mulhdu r9, r7, r6          \n\t"   \
-    "adde   r8, r8, r5          \n\t"   \
-    "ld     r7, 8(r4)           \n\t"   \
-    "addze  r5, r9              \n\t"   \
-    "addc   r8, r8, r7          \n\t"   \
-    "stdu   r8, 8(r4)           \n\t"
-
-#define MULADDC_STOP                        \
-    "addze  r5, r5              \n\t"   \
-    "addi   r4, r4, 8           \n\t"   \
-    "addi   r3, r3, 8           \n\t"   \
-    "std    r5, %0              \n\t"   \
-    "std    r4, %1              \n\t"   \
-    "std    r3, %2              \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-        );
-
-
-#else /* __MACH__ && __APPLE__ */
-
-#define MULADDC_INIT                        \
-    asm(                                    \
-                                            "ld     %%r3, %3            \n\t"   \
-                                            "ld     %%r4, %4            \n\t"   \
-                                            "ld     %%r5, %5            \n\t"   \
-                                            "ld     %%r6, %6            \n\t"   \
-                                            "addi   %%r3, %%r3, -8      \n\t"   \
-                                            "addi   %%r4, %%r4, -8      \n\t"   \
-                                            "addic  %%r5, %%r5,  0      \n\t"
-
-#define MULADDC_CORE                        \
-    "ldu    %%r7, 8(%%r3)       \n\t"   \
-    "mulld  %%r8, %%r7, %%r6    \n\t"   \
-    "mulhdu %%r9, %%r7, %%r6    \n\t"   \
-    "adde   %%r8, %%r8, %%r5    \n\t"   \
-    "ld     %%r7, 8(%%r4)       \n\t"   \
-    "addze  %%r5, %%r9          \n\t"   \
-    "addc   %%r8, %%r8, %%r7    \n\t"   \
-    "stdu   %%r8, 8(%%r4)       \n\t"
-
-#define MULADDC_STOP                        \
-    "addze  %%r5, %%r5          \n\t"   \
-    "addi   %%r4, %%r4, 8       \n\t"   \
-    "addi   %%r3, %%r3, 8       \n\t"   \
-    "std    %%r5, %0            \n\t"   \
-    "std    %%r4, %1            \n\t"   \
-    "std    %%r3, %2            \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-        );
-
-#endif /* __MACH__ && __APPLE__ */
-
-#elif defined(__powerpc__) || defined(__ppc__) /* end PPC64/begin PPC32  */
-
-#if defined(__MACH__) && defined(__APPLE__)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-                                        "lwz    r3, %3          \n\t"   \
-                                        "lwz    r4, %4          \n\t"   \
-                                        "lwz    r5, %5          \n\t"   \
-                                        "lwz    r6, %6          \n\t"   \
-                                        "addi   r3, r3, -4      \n\t"   \
-                                        "addi   r4, r4, -4      \n\t"   \
-                                        "addic  r5, r5,  0      \n\t"
-
-#define MULADDC_CORE                    \
-    "lwzu   r7, 4(r3)       \n\t"   \
-    "mullw  r8, r7, r6      \n\t"   \
-    "mulhwu r9, r7, r6      \n\t"   \
-    "adde   r8, r8, r5      \n\t"   \
-    "lwz    r7, 4(r4)       \n\t"   \
-    "addze  r5, r9          \n\t"   \
-    "addc   r8, r8, r7      \n\t"   \
-    "stwu   r8, 4(r4)       \n\t"
-
-#define MULADDC_STOP                    \
-    "addze  r5, r5          \n\t"   \
-    "addi   r4, r4, 4       \n\t"   \
-    "addi   r3, r3, 4       \n\t"   \
-    "stw    r5, %0          \n\t"   \
-    "stw    r4, %1          \n\t"   \
-    "stw    r3, %2          \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-        );
-
-#else /* __MACH__ && __APPLE__ */
-
-#define MULADDC_INIT                        \
-    asm(                                    \
-                                            "lwz    %%r3, %3            \n\t"   \
-                                            "lwz    %%r4, %4            \n\t"   \
-                                            "lwz    %%r5, %5            \n\t"   \
-                                            "lwz    %%r6, %6            \n\t"   \
-                                            "addi   %%r3, %%r3, -4      \n\t"   \
-                                            "addi   %%r4, %%r4, -4      \n\t"   \
-                                            "addic  %%r5, %%r5,  0      \n\t"
-
-#define MULADDC_CORE                        \
-    "lwzu   %%r7, 4(%%r3)       \n\t"   \
-    "mullw  %%r8, %%r7, %%r6    \n\t"   \
-    "mulhwu %%r9, %%r7, %%r6    \n\t"   \
-    "adde   %%r8, %%r8, %%r5    \n\t"   \
-    "lwz    %%r7, 4(%%r4)       \n\t"   \
-    "addze  %%r5, %%r9          \n\t"   \
-    "addc   %%r8, %%r8, %%r7    \n\t"   \
-    "stwu   %%r8, 4(%%r4)       \n\t"
-
-#define MULADDC_STOP                        \
-    "addze  %%r5, %%r5          \n\t"   \
-    "addi   %%r4, %%r4, 4       \n\t"   \
-    "addi   %%r3, %%r3, 4       \n\t"   \
-    "stw    %%r5, %0            \n\t"   \
-    "stw    %%r4, %1            \n\t"   \
-    "stw    %%r3, %2            \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4", "r5", "r6", "r7", "r8", "r9"  \
-        );
-
-#endif /* __MACH__ && __APPLE__ */
-
-#endif /* PPC32 */
-
-/*
- * The Sparc64 assembly is reported to be broken.
- * Disable it for now, until we're able to fix it.
- */
-#if 0 && defined(__sparc__) && defined(__sparc64__)
-
-#define MULADDC_INIT                                    \
-    asm(                                                \
-            "ldx     %3, %%o0               \n\t"   \
-            "ldx     %4, %%o1               \n\t"   \
-            "ld      %5, %%o2               \n\t"   \
-            "ld      %6, %%o3               \n\t"
-
-#define MULADDC_CORE                                    \
-    "ld      [%%o0], %%o4           \n\t"   \
-    "inc     4, %%o0                \n\t"   \
-    "ld      [%%o1], %%o5           \n\t"   \
-    "umul    %%o3, %%o4, %%o4       \n\t"   \
-    "addcc   %%o4, %%o2, %%o4       \n\t"   \
-    "rd      %%y, %%g1              \n\t"   \
-    "addx    %%g1, 0, %%g1          \n\t"   \
-    "addcc   %%o4, %%o5, %%o4       \n\t"   \
-    "st      %%o4, [%%o1]           \n\t"   \
-    "addx    %%g1, 0, %%o2          \n\t"   \
-    "inc     4, %%o1                \n\t"
-
-#define MULADDC_STOP                            \
-    "st      %%o2, %0               \n\t"   \
-    "stx     %%o1, %1               \n\t"   \
-    "stx     %%o0, %2               \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)          \
-        : "m" (s), "m" (d), "m" (c), "m" (b)    \
-        : "g1", "o0", "o1", "o2", "o3", "o4",   \
-        "o5"                                  \
-        );
-#endif /* SPARCv9 */
-
-#if defined(__sparc__) && !defined(__sparc64__)
-
-#define MULADDC_INIT                                    \
-    asm(                                                \
-            "ld      %3, %%o0               \n\t"   \
-            "ld      %4, %%o1               \n\t"   \
-            "ld      %5, %%o2               \n\t"   \
-            "ld      %6, %%o3               \n\t"
-
-#define MULADDC_CORE                                    \
-    "ld      [%%o0], %%o4           \n\t"   \
-    "inc     4, %%o0                \n\t"   \
-    "ld      [%%o1], %%o5           \n\t"   \
-    "umul    %%o3, %%o4, %%o4       \n\t"   \
-    "addcc   %%o4, %%o2, %%o4       \n\t"   \
-    "rd      %%y, %%g1              \n\t"   \
-    "addx    %%g1, 0, %%g1          \n\t"   \
-    "addcc   %%o4, %%o5, %%o4       \n\t"   \
-    "st      %%o4, [%%o1]           \n\t"   \
-    "addx    %%g1, 0, %%o2          \n\t"   \
-    "inc     4, %%o1                \n\t"
-
-#define MULADDC_STOP                                    \
-    "st      %%o2, %0               \n\t"   \
-    "st      %%o1, %1               \n\t"   \
-    "st      %%o0, %2               \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)          \
-        : "m" (s), "m" (d), "m" (c), "m" (b)    \
-        : "g1", "o0", "o1", "o2", "o3", "o4",   \
-        "o5"                                  \
-        );
-
-#endif /* SPARCv8 */
-
-#if defined(__microblaze__) || defined(microblaze)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-                                        "lwi   r3,   %3         \n\t"   \
-                                        "lwi   r4,   %4         \n\t"   \
-                                        "lwi   r5,   %5         \n\t"   \
-                                        "lwi   r6,   %6         \n\t"   \
-                                        "andi  r7,   r6, 0xffff \n\t"   \
-                                        "bsrli r6,   r6, 16     \n\t"
-
-#define MULADDC_CORE                    \
-    "lhui  r8,   r3,   0    \n\t"   \
-    "addi  r3,   r3,   2    \n\t"   \
-    "lhui  r9,   r3,   0    \n\t"   \
-    "addi  r3,   r3,   2    \n\t"   \
-    "mul   r10,  r9,  r6    \n\t"   \
-    "mul   r11,  r8,  r7    \n\t"   \
-    "mul   r12,  r9,  r7    \n\t"   \
-    "mul   r13,  r8,  r6    \n\t"   \
-    "bsrli  r8, r10,  16    \n\t"   \
-    "bsrli  r9, r11,  16    \n\t"   \
-    "add   r13, r13,  r8    \n\t"   \
-    "add   r13, r13,  r9    \n\t"   \
-    "bslli r10, r10,  16    \n\t"   \
-    "bslli r11, r11,  16    \n\t"   \
-    "add   r12, r12, r10    \n\t"   \
-    "addc  r13, r13,  r0    \n\t"   \
-    "add   r12, r12, r11    \n\t"   \
-    "addc  r13, r13,  r0    \n\t"   \
-    "lwi   r10,  r4,   0    \n\t"   \
-    "add   r12, r12, r10    \n\t"   \
-    "addc  r13, r13,  r0    \n\t"   \
-    "add   r12, r12,  r5    \n\t"   \
-    "addc   r5, r13,  r0    \n\t"   \
-    "swi   r12,  r4,   0    \n\t"   \
-    "addi   r4,  r4,   4    \n\t"
-
-#define MULADDC_STOP                    \
-    "swi   r5,   %0         \n\t"   \
-    "swi   r4,   %1         \n\t"   \
-    "swi   r3,   %2         \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "r3", "r4"  "r5", "r6", "r7", "r8",       \
-        "r9", "r10", "r11", "r12", "r13"          \
-        );
-
-#endif /* MicroBlaze */
-
-#if defined(__tricore__)
-
-#define MULADDC_INIT                            \
-    asm(                                        \
-            "ld.a   %%a2, %3                \n\t"   \
-            "ld.a   %%a3, %4                \n\t"   \
-            "ld.w   %%d4, %5                \n\t"   \
-            "ld.w   %%d1, %6                \n\t"   \
-            "xor    %%d5, %%d5              \n\t"
-
-#define MULADDC_CORE                            \
-    "ld.w   %%d0,   [%%a2+]         \n\t"   \
-    "madd.u %%e2, %%e4, %%d0, %%d1  \n\t"   \
-    "ld.w   %%d0,   [%%a3]          \n\t"   \
-    "addx   %%d2,    %%d2,  %%d0    \n\t"   \
-    "addc   %%d3,    %%d3,    0     \n\t"   \
-    "mov    %%d4,    %%d3           \n\t"   \
-    "st.w  [%%a3+],  %%d2           \n\t"
-
-#define MULADDC_STOP                            \
-    "st.w   %0, %%d4                \n\t"   \
-    "st.a   %1, %%a3                \n\t"   \
-    "st.a   %2, %%a2                \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)          \
-        : "m" (s), "m" (d), "m" (c), "m" (b)    \
-        : "d0", "d1", "e2", "d4", "a2", "a3"    \
-        );
-
-#endif /* TriCore */
-
 #if defined(__arm__)
 
 #if defined(__thumb__) && !defined(__thumb2__)
 
 #define MULADDC_INIT                                    \
     asm(                                                \
-            "ldr    r0, %3                      \n\t"   \
-            "ldr    r1, %4                      \n\t"   \
-            "ldr    r2, %5                      \n\t"   \
-            "ldr    r3, %6                      \n\t"   \
-            "lsr    r7, r3, #16                 \n\t"   \
-            "mov    r9, r7                      \n\t"   \
-            "lsl    r7, r3, #16                 \n\t"   \
-            "lsr    r7, r7, #16                 \n\t"   \
-            "mov    r8, r7                      \n\t"
+        "ldr    r0, %3                      \n\t"   \
+        "ldr    r1, %4                      \n\t"   \
+        "ldr    r2, %5                      \n\t"   \
+        "ldr    r3, %6                      \n\t"   \
+        "lsr    r10, r3, #16                 \n\t"   \
+        "mov    r9, r10                      \n\t"   \
+        "lsl    r10, r3, #16                 \n\t"   \
+        "lsr    r10, r10, #16                 \n\t"   \
+        "mov    r8, r10                      \n\t"
 
 #define MULADDC_CORE                                    \
     "ldmia  r0!, {r6}                   \n\t"   \
-    "lsr    r7, r6, #16                 \n\t"   \
+    "lsr    r10, r6, #16                 \n\t"   \
     "lsl    r6, r6, #16                 \n\t"   \
     "lsr    r6, r6, #16                 \n\t"   \
     "mov    r4, r8                      \n\t"   \
@@ -556,12 +205,12 @@
     "mov    r3, r9                      \n\t"   \
     "mul    r6, r3                      \n\t"   \
     "mov    r5, r9                      \n\t"   \
-    "mul    r5, r7                      \n\t"   \
+    "mul    r5, r10                      \n\t"   \
     "mov    r3, r8                      \n\t"   \
-    "mul    r7, r3                      \n\t"   \
+    "mul    r10, r3                      \n\t"   \
     "lsr    r3, r6, #16                 \n\t"   \
     "add    r5, r5, r3                  \n\t"   \
-    "lsr    r3, r7, #16                 \n\t"   \
+    "lsr    r3, r10, #16                 \n\t"   \
     "add    r5, r5, r3                  \n\t"   \
     "add    r4, r4, r2                  \n\t"   \
     "mov    r2, #0                      \n\t"   \
@@ -569,7 +218,7 @@
     "lsl    r3, r6, #16                 \n\t"   \
     "add    r4, r4, r3                  \n\t"   \
     "adc    r5, r2                      \n\t"   \
-    "lsl    r3, r7, #16                 \n\t"   \
+    "lsl    r3, r10, #16                 \n\t"   \
     "add    r4, r4, r3                  \n\t"   \
     "adc    r5, r2                      \n\t"   \
     "ldr    r3, [r1]                    \n\t"   \
@@ -584,26 +233,26 @@
     : "=m" (c),  "=m" (d), "=m" (s)        \
         : "m" (s), "m" (d), "m" (c), "m" (b)   \
         : "r0", "r1", "r2", "r3", "r4", "r5",  \
-        "r6", "r7", "r8", "r9", "cc"         \
+        "r6", "r10", "r8", "r9", "cc"         \
         );
 
 #else
 
 #define MULADDC_INIT                                    \
     asm(                                                \
-            "ldr    r0, %3                      \n\t"   \
-            "ldr    r1, %4                      \n\t"   \
-            "ldr    r2, %5                      \n\t"   \
-            "ldr    r3, %6                      \n\t"
+        "ldr    r0, %3                      \n\t"   \
+        "ldr    r1, %4                      \n\t"   \
+        "ldr    r2, %5                      \n\t"   \
+        "ldr    r3, %6                      \n\t"
 
 #define MULADDC_CORE                                    \
     "ldr    r4, [r0], #4                \n\t"   \
     "mov    r5, #0                      \n\t"   \
     "ldr    r6, [r1]                    \n\t"   \
     "umlal  r2, r5, r3, r4              \n\t"   \
-    "adds   r7, r6, r2                  \n\t"   \
+    "adds   r10, r6, r2                  \n\t"   \
     "adc    r2, r5, #0                  \n\t"   \
-    "str    r7, [r1], #4                \n\t"
+    "str    r10, [r1], #4                \n\t"
 
 #define MULADDC_STOP                                    \
     "str    r2, %0                      \n\t"   \
@@ -612,82 +261,13 @@
     : "=m" (c),  "=m" (d), "=m" (s)        \
         : "m" (s), "m" (d), "m" (c), "m" (b)   \
         : "r0", "r1", "r2", "r3", "r4", "r5",  \
-        "r6", "r7", "cc"                     \
+        "r6", "r10", "cc"                     \
         );
 
 #endif /* Thumb */
 
 #endif /* ARMv3 */
 
-#if defined(__alpha__)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-                                        "ldq    $1, %3          \n\t"   \
-                                        "ldq    $2, %4          \n\t"   \
-                                        "ldq    $3, %5          \n\t"   \
-                                        "ldq    $4, %6          \n\t"
-
-#define MULADDC_CORE                    \
-    "ldq    $6,  0($1)      \n\t"   \
-    "addq   $1,  8, $1      \n\t"   \
-    "mulq   $6, $4, $7      \n\t"   \
-    "umulh  $6, $4, $6      \n\t"   \
-    "addq   $7, $3, $7      \n\t"   \
-    "cmpult $7, $3, $3      \n\t"   \
-    "ldq    $5,  0($2)      \n\t"   \
-    "addq   $7, $5, $7      \n\t"   \
-    "cmpult $7, $5, $5      \n\t"   \
-    "stq    $7,  0($2)      \n\t"   \
-    "addq   $2,  8, $2      \n\t"   \
-    "addq   $6, $3, $3      \n\t"   \
-    "addq   $5, $3, $3      \n\t"
-
-#define MULADDC_STOP                                    \
-    "stq    $3, %0          \n\t"   \
-    "stq    $2, %1          \n\t"   \
-    "stq    $1, %2          \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)              \
-        : "m" (s), "m" (d), "m" (c), "m" (b)        \
-        : "$1", "$2", "$3", "$4", "$5", "$6", "$7"  \
-        );
-#endif /* Alpha */
-
-#if defined(__mips__) && !defined(__mips64)
-
-#define MULADDC_INIT                    \
-    asm(                                \
-                                        "lw     $10, %3         \n\t"   \
-                                        "lw     $11, %4         \n\t"   \
-                                        "lw     $12, %5         \n\t"   \
-                                        "lw     $13, %6         \n\t"
-
-#define MULADDC_CORE                    \
-    "lw     $14, 0($10)     \n\t"   \
-    "multu  $13, $14        \n\t"   \
-    "addi   $10, $10, 4     \n\t"   \
-    "mflo   $14             \n\t"   \
-    "mfhi   $9              \n\t"   \
-    "addu   $14, $12, $14   \n\t"   \
-    "lw     $15, 0($11)     \n\t"   \
-    "sltu   $12, $14, $12   \n\t"   \
-    "addu   $15, $14, $15   \n\t"   \
-    "sltu   $14, $15, $14   \n\t"   \
-    "addu   $12, $12, $9    \n\t"   \
-    "sw     $15, 0($11)     \n\t"   \
-    "addu   $12, $12, $14   \n\t"   \
-    "addi   $11, $11, 4     \n\t"
-
-#define MULADDC_STOP                    \
-    "sw     $12, %0         \n\t"   \
-    "sw     $11, %1         \n\t"   \
-    "sw     $10, %2         \n\t"   \
-    : "=m" (c), "=m" (d), "=m" (s)                      \
-        : "m" (s), "m" (d), "m" (c), "m" (b)                \
-        : "$9", "$10", "$11", "$12", "$13", "$14", "$15"    \
-        );
-
-#endif /* MIPS */
 #endif /* GNUC */
 
 #if (defined(_MSC_VER) && defined(_M_IX86)) || defined(__WATCOMC__)
@@ -708,7 +288,7 @@
     __asm   mov     ecx, edx                    \
     __asm   stosd
 
-#if defined(POLARSSL_HAVE_SSE2)
+#if defined(HAVE_SSE2)
 
 #define EMIT __asm _emit
 
@@ -791,23 +371,54 @@
 #endif /* SSE2 */
 #endif /* MSVC */
 
+#endif
+
 #if !defined(MULADDC_CORE)
+#if defined(DHAVE_DOUBLE_LONG_INT)
 
 #define MULADDC_INIT                    \
-    {                                       \
-        t_udbl r;                           \
-        t_uint r0, r1;
+{                                       \
+    TUDBL r;                           \
+    TUINT r0, r1;
 
 #define MULADDC_CORE                    \
-    r   = *(s++) * (t_udbl) b;          \
-    r0  = (t_uint) r;                   \
-    r1  = (t_uint)( r >> biL );         \
+    r   = *(s++) * (TUDBL) b;          \
+    r0  = (TUINT) r;                   \
+    r1  = (TUINT)( r >> DBITS_IN_LIMB );         \
     r0 += c;  r1 += (r0 <  c);          \
     r0 += *d; r1 += (r0 < *d);          \
     c = r1; *(d++) = r0;
 
 #define MULADDC_STOP                    \
-    }
+}
+
+#else
+#define MULADDC_INIT                    \
+{                                       \
+    TUINT s0, s1, b0, b1;              \
+    TUINT r0, r1, rx, ry;              \
+    b0 = ( b << DHALF_BITS_IN_LIMB ) >> DHALF_BITS_IN_LIMB;           \
+    b1 = ( b >> DHALF_BITS_IN_LIMB );
+
+#define MULADDC_CORE                    \
+    s0 = ( *s << DHALF_BITS_IN_LIMB ) >> DHALF_BITS_IN_LIMB;          \
+    s1 = ( *s >> DHALF_BITS_IN_LIMB ); s++;            \
+    rx = s0 * b1; r0 = s0 * b0;         \
+    ry = s1 * b0; r1 = s1 * b1;         \
+    r1 += ( rx >> DHALF_BITS_IN_LIMB );                \
+    r1 += ( ry >> DHALF_BITS_IN_LIMB );                \
+    rx <<= DHALF_BITS_IN_LIMB; ry <<= DHALF_BITS_IN_LIMB;             \
+    r0 += rx; r1 += (r0 < rx);          \
+    r0 += ry; r1 += (r0 < ry);          \
+    r0 +=  c; r1 += (r0 <  c);          \
+    r0 += *d; r1 += (r0 < *d);          \
+    c = r1; *(d++) = r0;
+
+#define MULADDC_STOP                    \
+}
+
+#endif /* C (generic)  */
+
 
 #endif
 
diff --git a/lw_cryptography/src/crypt_utils.c b/lw_cryptography/src/crypt_utils.c
index 493e050..d84d9a2 100644
--- a/lw_cryptography/src/crypt_utils.c
+++ b/lw_cryptography/src/crypt_utils.c
@@ -1,17 +1,34 @@
-/*
+/*******************************************************************************
  * crypt_utils.c
  *
  * History:
  *  2015/06/16 - [Zhi He] create utils file for cryptography library
  *
- * Copyright (C) 2015 -2025, Ambarella, Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of Ambarella, Inc.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- */
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include "cryptography_if.h"
 
diff --git a/lw_cryptography/src/digest_md5.c b/lw_cryptography/src/digest_md5.c
index d583a83..56eb7f4 100644
--- a/lw_cryptography/src/digest_md5.c
+++ b/lw_cryptography/src/digest_md5.c
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * digest_md5.c
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include "cryptography_if.h"
 
diff --git a/lw_cryptography/src/digest_sha256.c b/lw_cryptography/src/digest_sha256.c
index f8f16fe..6e800c3 100644
--- a/lw_cryptography/src/digest_sha256.c
+++ b/lw_cryptography/src/digest_sha256.c
@@ -1,314 +1,332 @@
-/**
- * digest_sha256.c
+/*******************************************************************************
+ * digest_sha256.c
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
-
-
-#include "cryptography_if.h"
-
-#ifndef DNOT_INCLUDE_C_HEADER
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-#else
-#include <bldfunc.h>
-#endif
-
-#define DSHA256_BLOCK_SIZE  (512 / 8)
-
-typedef struct {
-    unsigned int tot_len;
-    unsigned int len;
-    unsigned char block[2 * DSHA256_BLOCK_SIZE];
-    unsigned int h[8];
-} sha256_ctx_t;
-
-#define DSHFR(x, n)    (x >> n)
-#define DROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
-#define DROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
-#define DCH(x, y, z)  ((x & y) ^ (~x & z))
-#define DMAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
-
-#define DSHA256_F1(x) (DROTR(x,  2) ^ DROTR(x, 13) ^ DROTR(x, 22))
-#define DSHA256_F2(x) (DROTR(x,  6) ^ DROTR(x, 11) ^ DROTR(x, 25))
-#define DSHA256_F3(x) (DROTR(x,  7) ^ DROTR(x, 18) ^ DSHFR(x,  3))
-#define DSHA256_F4(x) (DROTR(x, 17) ^ DROTR(x, 19) ^ DSHFR(x, 10))
-
-#define DUNPACK32(x, str)                      \
-    {                                             \
-        *((str) + 3) = (unsigned char) ((x));       \
-        *((str) + 2) = (unsigned char) ((x) >>  8);       \
-        *((str) + 1) = (unsigned char) ((x) >> 16);       \
-        *((str) + 0) = (unsigned char) ((x) >> 24);       \
-    }
-
-#define DPACK32(str, x)                        \
-    {                                             \
-        *(x) =   ((unsigned int) *((str) + 3))    \
-                 | ((unsigned int) *((str) + 2) <<  8)    \
-                 | ((unsigned int) *((str) + 1) << 16)    \
-                 | ((unsigned int) *((str) + 0) << 24);   \
-    }
-
-#define DSHA256_SCR(i)                         \
-    {                                             \
-        w[i] =  DSHA256_F4(w[i -  2]) + w[i -  7]  \
-                + DSHA256_F3(w[i - 15]) + w[i - 16]; \
-    }
-
-#define DSHA256_EXP(a, b, c, d, e, f, g, h, j)               \
-    {                                                           \
-        t1 = wv[h] + DSHA256_F2(wv[e]) + DCH(wv[e], wv[f], wv[g]) \
-             + g_sha256_k[j] + w[j];                              \
-        t2 = DSHA256_F1(wv[a]) + DMAJ(wv[a], wv[b], wv[c]);       \
-        wv[d] += t1;                                            \
-        wv[h] = t1 + t2;                                        \
-    }
-
-static unsigned int g_sha256_h0[8] = {
-    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
-    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
-};
-
-static unsigned int g_sha256_k[64] = {
-    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
-    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
-    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
-    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
-    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
-    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
-    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
-    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
-    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
-    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
-    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
-    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
-    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
-    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
-    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
-    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
-};
-
-static void __sha256_transf(sha256_ctx_t* ctx, const unsigned char* message, unsigned int block_nb)
-{
-    unsigned int w[64];
-    unsigned int wv[8];
-
-    unsigned int t1, t2;
-    const unsigned char *sub_block;
-    int i;
-
-    for (i = 0; i < (int) block_nb; i++) {
-        sub_block = message + (i << 6);
-
-        DPACK32(&sub_block[ 0], &w[ 0]); DPACK32(&sub_block[ 4], &w[ 1]);
-        DPACK32(&sub_block[ 8], &w[ 2]); DPACK32(&sub_block[12], &w[ 3]);
-        DPACK32(&sub_block[16], &w[ 4]); DPACK32(&sub_block[20], &w[ 5]);
-        DPACK32(&sub_block[24], &w[ 6]); DPACK32(&sub_block[28], &w[ 7]);
-        DPACK32(&sub_block[32], &w[ 8]); DPACK32(&sub_block[36], &w[ 9]);
-        DPACK32(&sub_block[40], &w[10]); DPACK32(&sub_block[44], &w[11]);
-        DPACK32(&sub_block[48], &w[12]); DPACK32(&sub_block[52], &w[13]);
-        DPACK32(&sub_block[56], &w[14]); DPACK32(&sub_block[60], &w[15]);
-
-        DSHA256_SCR(16); DSHA256_SCR(17); DSHA256_SCR(18); DSHA256_SCR(19);
-        DSHA256_SCR(20); DSHA256_SCR(21); DSHA256_SCR(22); DSHA256_SCR(23);
-        DSHA256_SCR(24); DSHA256_SCR(25); DSHA256_SCR(26); DSHA256_SCR(27);
-        DSHA256_SCR(28); DSHA256_SCR(29); DSHA256_SCR(30); DSHA256_SCR(31);
-        DSHA256_SCR(32); DSHA256_SCR(33); DSHA256_SCR(34); DSHA256_SCR(35);
-        DSHA256_SCR(36); DSHA256_SCR(37); DSHA256_SCR(38); DSHA256_SCR(39);
-        DSHA256_SCR(40); DSHA256_SCR(41); DSHA256_SCR(42); DSHA256_SCR(43);
-        DSHA256_SCR(44); DSHA256_SCR(45); DSHA256_SCR(46); DSHA256_SCR(47);
-        DSHA256_SCR(48); DSHA256_SCR(49); DSHA256_SCR(50); DSHA256_SCR(51);
-        DSHA256_SCR(52); DSHA256_SCR(53); DSHA256_SCR(54); DSHA256_SCR(55);
-        DSHA256_SCR(56); DSHA256_SCR(57); DSHA256_SCR(58); DSHA256_SCR(59);
-        DSHA256_SCR(60); DSHA256_SCR(61); DSHA256_SCR(62); DSHA256_SCR(63);
-
-        wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
-        wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
-        wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
-        wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
-
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 0); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 1);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 2); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 3);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 4); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 5);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 6); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 7);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 8); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 9);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 10); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 11);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 12); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 13);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 14); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 15);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 16); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 17);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 18); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 19);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 20); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 21);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 22); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 23);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 24); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 25);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 26); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 27);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 28); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 29);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 30); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 31);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 32); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 33);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 34); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 35);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 36); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 37);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 38); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 39);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 40); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 41);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 42); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 43);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 44); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 45);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 46); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 47);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 48); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 49);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 50); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 51);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 52); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 53);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 54); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 55);
-        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 56); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 57);
-        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 58); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 59);
-        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 60); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 61);
-        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 62); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 63);
-
-        ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
-        ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
-        ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
-        ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
-    }
-}
-
-static void __sha256_init(sha256_ctx_t *ctx)
-{
-    ctx->h[0] = g_sha256_h0[0]; ctx->h[1] = g_sha256_h0[1];
-    ctx->h[2] = g_sha256_h0[2]; ctx->h[3] = g_sha256_h0[3];
-    ctx->h[4] = g_sha256_h0[4]; ctx->h[5] = g_sha256_h0[5];
-    ctx->h[6] = g_sha256_h0[6]; ctx->h[7] = g_sha256_h0[7];
-
-    ctx->len = 0;
-    ctx->tot_len = 0;
-}
-
-static void __sha256_update(sha256_ctx_t* ctx, const unsigned char* message, unsigned int len)
-{
-    unsigned int block_nb;
-    unsigned int new_len, rem_len, tmp_len;
-    const unsigned char *shifted_message;
-
-    tmp_len = DSHA256_BLOCK_SIZE - ctx->len;
-    rem_len = len < tmp_len ? len : tmp_len;
-
-    memcpy(&ctx->block[ctx->len], message, rem_len);
-
-    if (ctx->len + len < DSHA256_BLOCK_SIZE) {
-        ctx->len += len;
-        return;
-    }
-
-    new_len = len - rem_len;
-    block_nb = new_len / DSHA256_BLOCK_SIZE;
-
-    shifted_message = message + rem_len;
-
-    __sha256_transf(ctx, ctx->block, 1);
-    __sha256_transf(ctx, shifted_message, block_nb);
-
-    rem_len = new_len % DSHA256_BLOCK_SIZE;
-
-    memcpy(ctx->block, &shifted_message[block_nb << 6], rem_len);
-
-    ctx->len = rem_len;
-    ctx->tot_len += (block_nb + 1) << 6;
-}
-
-static void __sha256_final(sha256_ctx_t* ctx, unsigned char* digest)
-{
-    unsigned int block_nb;
-    unsigned int pm_len;
-    unsigned int len_b;
-
-    block_nb = (1 + ((DSHA256_BLOCK_SIZE - 9) < (ctx->len % DSHA256_BLOCK_SIZE)));
-
-    len_b = (ctx->tot_len + ctx->len) << 3;
-    pm_len = block_nb << 6;
-
-    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
-    ctx->block[ctx->len] = 0x80;
-    DUNPACK32(len_b, ctx->block + pm_len - 4);
-
-    __sha256_transf(ctx, ctx->block, block_nb);
-
-    DUNPACK32(ctx->h[0], &digest[ 0]);
-    DUNPACK32(ctx->h[1], &digest[ 4]);
-    DUNPACK32(ctx->h[2], &digest[ 8]);
-    DUNPACK32(ctx->h[3], &digest[12]);
-    DUNPACK32(ctx->h[4], &digest[16]);
-    DUNPACK32(ctx->h[5], &digest[20]);
-    DUNPACK32(ctx->h[6], &digest[24]);
-    DUNPACK32(ctx->h[7], &digest[28]);
-}
-
-void digest_sha256(const unsigned char* message, unsigned int len, unsigned char* digest)
-{
-    sha256_ctx_t ctx;
-
-    __sha256_init(&ctx);
-    __sha256_update(&ctx, message, len);
-    __sha256_final(&ctx, digest);
-}
-
-#ifndef DNOT_INCLUDE_C_HEADER
-int digest_sha256_file(const char* file, unsigned char* digest)
-{
-    FILE *f;
-    unsigned int n;
-    sha256_ctx_t ctx;
-    unsigned char buf[1024];
-
-    if ((f = fopen(file, "rb")) == NULL) {
-        return (-1);
-    }
-
-    __sha256_init(&ctx);
-    while ((n = fread( buf, 1, sizeof( buf ), f)) > 0) {
-        __sha256_update(&ctx, buf, n);
-    }
-
-    __sha256_final(&ctx, digest);
-
-    fclose(f);
-
-    return 0;
-}
-
-void* digest_sha256_init()
-{
-    sha256_ctx_t* ctx = (sha256_ctx_t*) malloc(sizeof(sha256_ctx_t));
-    if (ctx) {
-        __sha256_init(ctx);
-        return (void*) ctx;
-    }
-
-    printf("error: digest_sha256_init, malloc fail\n");
-    return NULL;
-}
-
-void digest_sha256_update(void* ctx, const unsigned char* message, unsigned int len)
-{
-    if (ctx && message && len) {
-        __sha256_update((sha256_ctx_t* )ctx, message, len);
-    } else {
-        printf("error: digest_sha256_update, bad input parameters\n");
-    }
-    return;
-}
-
-void digest_sha256_final(void* ctx, unsigned char* digest)
-{
-    if (ctx && digest) {
-        __sha256_final((sha256_ctx_t* )ctx, digest);
-    } else {
-        printf("error: digest_sha256_final, bad input parameters\n");
-    }
-}
-#endif
-
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+
+#include "cryptography_if.h"
+
+#ifndef DNOT_INCLUDE_C_HEADER
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#else
+#include <bldfunc.h>
+#endif
+
+#define DSHA256_BLOCK_SIZE  (512 / 8)
+
+typedef struct {
+    unsigned int tot_len;
+    unsigned int len;
+    unsigned char block[2 * DSHA256_BLOCK_SIZE];
+    unsigned int h[8];
+} sha256_ctx_t;
+
+#define DSHFR(x, n)    (x >> n)
+#define DROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
+#define DROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
+#define DCH(x, y, z)  ((x & y) ^ (~x & z))
+#define DMAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
+
+#define DSHA256_F1(x) (DROTR(x,  2) ^ DROTR(x, 13) ^ DROTR(x, 22))
+#define DSHA256_F2(x) (DROTR(x,  6) ^ DROTR(x, 11) ^ DROTR(x, 25))
+#define DSHA256_F3(x) (DROTR(x,  7) ^ DROTR(x, 18) ^ DSHFR(x,  3))
+#define DSHA256_F4(x) (DROTR(x, 17) ^ DROTR(x, 19) ^ DSHFR(x, 10))
+
+#define DUNPACK32(x, str)                      \
+    {                                             \
+        *((str) + 3) = (unsigned char) ((x));       \
+        *((str) + 2) = (unsigned char) ((x) >>  8);       \
+        *((str) + 1) = (unsigned char) ((x) >> 16);       \
+        *((str) + 0) = (unsigned char) ((x) >> 24);       \
+    }
+
+#define DPACK32(str, x)                        \
+    {                                             \
+        *(x) =   ((unsigned int) *((str) + 3))    \
+                 | ((unsigned int) *((str) + 2) <<  8)    \
+                 | ((unsigned int) *((str) + 1) << 16)    \
+                 | ((unsigned int) *((str) + 0) << 24);   \
+    }
+
+#define DSHA256_SCR(i)                         \
+    {                                             \
+        w[i] =  DSHA256_F4(w[i -  2]) + w[i -  7]  \
+                + DSHA256_F3(w[i - 15]) + w[i - 16]; \
+    }
+
+#define DSHA256_EXP(a, b, c, d, e, f, g, h, j)               \
+    {                                                           \
+        t1 = wv[h] + DSHA256_F2(wv[e]) + DCH(wv[e], wv[f], wv[g]) \
+             + g_sha256_k[j] + w[j];                              \
+        t2 = DSHA256_F1(wv[a]) + DMAJ(wv[a], wv[b], wv[c]);       \
+        wv[d] += t1;                                            \
+        wv[h] = t1 + t2;                                        \
+    }
+
+static unsigned int g_sha256_h0[8] = {
+    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
+    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
+};
+
+static unsigned int g_sha256_k[64] = {
+    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+static void __sha256_transf(sha256_ctx_t* ctx, const unsigned char* message, unsigned int block_nb)
+{
+    unsigned int w[64];
+    unsigned int wv[8];
+
+    unsigned int t1, t2;
+    const unsigned char *sub_block;
+    int i;
+
+    for (i = 0; i < (int) block_nb; i++) {
+        sub_block = message + (i << 6);
+
+        DPACK32(&sub_block[ 0], &w[ 0]); DPACK32(&sub_block[ 4], &w[ 1]);
+        DPACK32(&sub_block[ 8], &w[ 2]); DPACK32(&sub_block[12], &w[ 3]);
+        DPACK32(&sub_block[16], &w[ 4]); DPACK32(&sub_block[20], &w[ 5]);
+        DPACK32(&sub_block[24], &w[ 6]); DPACK32(&sub_block[28], &w[ 7]);
+        DPACK32(&sub_block[32], &w[ 8]); DPACK32(&sub_block[36], &w[ 9]);
+        DPACK32(&sub_block[40], &w[10]); DPACK32(&sub_block[44], &w[11]);
+        DPACK32(&sub_block[48], &w[12]); DPACK32(&sub_block[52], &w[13]);
+        DPACK32(&sub_block[56], &w[14]); DPACK32(&sub_block[60], &w[15]);
+
+        DSHA256_SCR(16); DSHA256_SCR(17); DSHA256_SCR(18); DSHA256_SCR(19);
+        DSHA256_SCR(20); DSHA256_SCR(21); DSHA256_SCR(22); DSHA256_SCR(23);
+        DSHA256_SCR(24); DSHA256_SCR(25); DSHA256_SCR(26); DSHA256_SCR(27);
+        DSHA256_SCR(28); DSHA256_SCR(29); DSHA256_SCR(30); DSHA256_SCR(31);
+        DSHA256_SCR(32); DSHA256_SCR(33); DSHA256_SCR(34); DSHA256_SCR(35);
+        DSHA256_SCR(36); DSHA256_SCR(37); DSHA256_SCR(38); DSHA256_SCR(39);
+        DSHA256_SCR(40); DSHA256_SCR(41); DSHA256_SCR(42); DSHA256_SCR(43);
+        DSHA256_SCR(44); DSHA256_SCR(45); DSHA256_SCR(46); DSHA256_SCR(47);
+        DSHA256_SCR(48); DSHA256_SCR(49); DSHA256_SCR(50); DSHA256_SCR(51);
+        DSHA256_SCR(52); DSHA256_SCR(53); DSHA256_SCR(54); DSHA256_SCR(55);
+        DSHA256_SCR(56); DSHA256_SCR(57); DSHA256_SCR(58); DSHA256_SCR(59);
+        DSHA256_SCR(60); DSHA256_SCR(61); DSHA256_SCR(62); DSHA256_SCR(63);
+
+        wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
+        wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
+        wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
+        wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
+
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 0); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 1);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 2); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 3);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 4); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 5);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 6); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 7);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 8); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 9);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 10); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 11);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 12); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 13);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 14); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 15);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 16); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 17);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 18); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 19);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 20); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 21);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 22); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 23);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 24); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 25);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 26); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 27);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 28); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 29);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 30); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 31);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 32); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 33);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 34); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 35);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 36); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 37);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 38); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 39);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 40); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 41);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 42); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 43);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 44); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 45);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 46); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 47);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 48); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 49);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 50); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 51);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 52); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 53);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 54); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 55);
+        DSHA256_EXP(0, 1, 2, 3, 4, 5, 6, 7, 56); DSHA256_EXP(7, 0, 1, 2, 3, 4, 5, 6, 57);
+        DSHA256_EXP(6, 7, 0, 1, 2, 3, 4, 5, 58); DSHA256_EXP(5, 6, 7, 0, 1, 2, 3, 4, 59);
+        DSHA256_EXP(4, 5, 6, 7, 0, 1, 2, 3, 60); DSHA256_EXP(3, 4, 5, 6, 7, 0, 1, 2, 61);
+        DSHA256_EXP(2, 3, 4, 5, 6, 7, 0, 1, 62); DSHA256_EXP(1, 2, 3, 4, 5, 6, 7, 0, 63);
+
+        ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
+        ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
+        ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
+        ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
+    }
+}
+
+static void __sha256_init(sha256_ctx_t *ctx)
+{
+    ctx->h[0] = g_sha256_h0[0]; ctx->h[1] = g_sha256_h0[1];
+    ctx->h[2] = g_sha256_h0[2]; ctx->h[3] = g_sha256_h0[3];
+    ctx->h[4] = g_sha256_h0[4]; ctx->h[5] = g_sha256_h0[5];
+    ctx->h[6] = g_sha256_h0[6]; ctx->h[7] = g_sha256_h0[7];
+
+    ctx->len = 0;
+    ctx->tot_len = 0;
+}
+
+static void __sha256_update(sha256_ctx_t* ctx, const unsigned char* message, unsigned int len)
+{
+    unsigned int block_nb;
+    unsigned int new_len, rem_len, tmp_len;
+    const unsigned char *shifted_message;
+
+    tmp_len = DSHA256_BLOCK_SIZE - ctx->len;
+    rem_len = len < tmp_len ? len : tmp_len;
+
+    memcpy(&ctx->block[ctx->len], message, rem_len);
+
+    if (ctx->len + len < DSHA256_BLOCK_SIZE) {
+        ctx->len += len;
+        return;
+    }
+
+    new_len = len - rem_len;
+    block_nb = new_len / DSHA256_BLOCK_SIZE;
+
+    shifted_message = message + rem_len;
+
+    __sha256_transf(ctx, ctx->block, 1);
+    __sha256_transf(ctx, shifted_message, block_nb);
+
+    rem_len = new_len % DSHA256_BLOCK_SIZE;
+
+    memcpy(ctx->block, &shifted_message[block_nb << 6], rem_len);
+
+    ctx->len = rem_len;
+    ctx->tot_len += (block_nb + 1) << 6;
+}
+
+static void __sha256_final(sha256_ctx_t* ctx, unsigned char* digest)
+{
+    unsigned int block_nb;
+    unsigned int pm_len;
+    unsigned int len_b;
+
+    block_nb = (1 + ((DSHA256_BLOCK_SIZE - 9) < (ctx->len % DSHA256_BLOCK_SIZE)));
+
+    len_b = (ctx->tot_len + ctx->len) << 3;
+    pm_len = block_nb << 6;
+
+    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
+    ctx->block[ctx->len] = 0x80;
+    DUNPACK32(len_b, ctx->block + pm_len - 4);
+
+    __sha256_transf(ctx, ctx->block, block_nb);
+
+    DUNPACK32(ctx->h[0], &digest[ 0]);
+    DUNPACK32(ctx->h[1], &digest[ 4]);
+    DUNPACK32(ctx->h[2], &digest[ 8]);
+    DUNPACK32(ctx->h[3], &digest[12]);
+    DUNPACK32(ctx->h[4], &digest[16]);
+    DUNPACK32(ctx->h[5], &digest[20]);
+    DUNPACK32(ctx->h[6], &digest[24]);
+    DUNPACK32(ctx->h[7], &digest[28]);
+}
+
+void digest_sha256(const unsigned char* message, unsigned int len, unsigned char* digest)
+{
+    sha256_ctx_t ctx;
+
+    __sha256_init(&ctx);
+    __sha256_update(&ctx, message, len);
+    __sha256_final(&ctx, digest);
+}
+
+#ifndef DNOT_INCLUDE_C_HEADER
+int digest_sha256_file(const char* file, unsigned char* digest)
+{
+    FILE *f;
+    unsigned int n;
+    sha256_ctx_t ctx;
+    unsigned char buf[1024];
+
+    if ((f = fopen(file, "rb")) == NULL) {
+        return (-1);
+    }
+
+    __sha256_init(&ctx);
+    while ((n = fread( buf, 1, sizeof( buf ), f)) > 0) {
+        __sha256_update(&ctx, buf, n);
+    }
+
+    __sha256_final(&ctx, digest);
+
+    fclose(f);
+
+    return 0;
+}
+
+void* digest_sha256_init()
+{
+    sha256_ctx_t* ctx = (sha256_ctx_t*) malloc(sizeof(sha256_ctx_t));
+    if (ctx) {
+        __sha256_init(ctx);
+        return (void*) ctx;
+    }
+
+    printf("error: digest_sha256_init, malloc fail\n");
+    return NULL;
+}
+
+void digest_sha256_update(void* ctx, const unsigned char* message, unsigned int len)
+{
+    if (ctx && message && len) {
+        __sha256_update((sha256_ctx_t* )ctx, message, len);
+    } else {
+        printf("error: digest_sha256_update, bad input parameters\n");
+    }
+    return;
+}
+
+void digest_sha256_final(void* ctx, unsigned char* digest)
+{
+    if (ctx && digest) {
+        __sha256_final((sha256_ctx_t* )ctx, digest);
+    } else {
+        printf("error: digest_sha256_final, bad input parameters\n");
+    }
+}
+#endif
+
diff --git a/lw_cryptography/src/make.inc b/lw_cryptography/src/make.inc
index fbb29a2..e54f59f 100644
--- a/lw_cryptography/src/make.inc
+++ b/lw_cryptography/src/make.inc
@@ -1,16 +1,34 @@
-##
+###############################################################################
 ## packages/security/lw_cryptography/src/make.inc
 ##
 ## History:
 ##    2015/08/03 - [Zhi He] Created file
 ##
-## Copyright (C) 2015-2025, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
+##################################################################################
 
 ifeq ($(BUILD_AMBARELLA_LW_CRYPTOGRAPHY), y)
 
@@ -21,7 +39,7 @@ include $(CLEAR_VARS)
 
 LOCAL_CFLAGS    := -I$(LOCAL_PATH)/../include
 LOCAL_TARGET	:= liblwcryptography.a
-LOCAL_SRCS	:= $(LOCAL_PATH)/big_number.c $(LOCAL_PATH)/crypt_utils.c $(LOCAL_PATH)/digest_md5.c $(LOCAL_PATH)/digest_sha256.c $(LOCAL_PATH)/pk_rsa.c $(LOCAL_PATH)/tiny_asn1.c $(LOCAL_PATH)/tiny_oid.c
+LOCAL_SRCS	:= $(LOCAL_PATH)/big_number.c $(LOCAL_PATH)/crypt_utils.c $(LOCAL_PATH)/digest_md5.c $(LOCAL_PATH)/digest_sha256.c $(LOCAL_PATH)/pk_rsa.c $(LOCAL_PATH)/pk_ecc.c $(LOCAL_PATH)/aes.c $(LOCAL_PATH)/aes_non_precal.c
 
 include $(BUILD_APP)
 
diff --git a/lw_cryptography/src/pk_ecc.c b/lw_cryptography/src/pk_ecc.c
new file mode 100644
index 0000000..9c619a8
--- /dev/null
+++ b/lw_cryptography/src/pk_ecc.c
@@ -0,0 +1,2045 @@
+/*******************************************************************************
+ * pk_ecc.c
+ *
+ * History:
+ *  2017/03/27 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include "cryptography_if.h"
+
+#ifndef DNOT_INCLUDE_C_HEADER
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#else
+#include <bldfunc.h>
+#endif
+
+#include "big_number.h"
+
+#define DECC_ENABLE_SECP192R1
+#define DECC_ENABLE_SECP224R1
+#define DECC_ENABLE_SECP256R1
+#define DECC_ENABLE_SECP384R1
+#define DECC_ENABLE_SECP521R1
+#define DECC_ENABLE_SECP192K1
+#define DECC_ENABLE_SECP224K1
+#define DECC_ENABLE_SECP256K1
+#define DECC_ENABLE_BP256R1
+#define DECC_ENABLE_BP384R1
+#define DECC_ENABLE_BP512R1
+
+#define DMAX_ECC_BITS 521
+#define DMAX_ECC_BYTES  ((DMAX_ECC_BITS + 7) >> 3)
+#define DMAX_ECC_PAYLOAD_LENGTH   (2 * DMAX_ECC_BYTES + 1)
+
+#define DECC_WINDOW_SIZE 6
+
+#ifdef DECC_ENABLE_SECP192R1
+static const unsigned char gc_secp192r1_p[] __attribute__((aligned(8))) = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+
+static const unsigned char gc_secp192r1_b[] __attribute__((aligned(8))) = {
+    0xB1, 0xB9, 0x46, 0xC1, 0xEC, 0xDE, 0xB8, 0xFE,
+    0x49, 0x30, 0x24, 0x72, 0xAB, 0xE9, 0xA7, 0x0F,
+    0xE7, 0x80, 0x9C, 0xE5, 0x19, 0x05, 0x21, 0x64,
+};
+
+static const unsigned char gc_secp192r1_gx[] __attribute__((aligned(8))) = {
+    0x12, 0x10, 0xFF, 0x82, 0xFD, 0x0A, 0xFF, 0xF4,
+    0x00, 0x88, 0xA1, 0x43, 0xEB, 0x20, 0xBF, 0x7C,
+    0xF6, 0x90, 0x30, 0xB0, 0x0E, 0xA8, 0x8D, 0x18,
+};
+
+static const unsigned char gc_secp192r1_gy[] __attribute__((aligned(8))) = {
+    0x11, 0x48, 0x79, 0x1E, 0xA1, 0x77, 0xF9, 0x73,
+    0xD5, 0xCD, 0x24, 0x6B, 0xED, 0x11, 0x10, 0x63,
+    0x78, 0xDA, 0xC8, 0xFF, 0x95, 0x2B, 0x19, 0x07,
+};
+
+static const unsigned char gc_secp192r1_n[] __attribute__((aligned(8))) = {
+    0x31, 0x28, 0xD2, 0xB4, 0xB1, 0xC9, 0x6B, 0x14,
+    0x36, 0xF8, 0xDE, 0x99, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+#endif
+
+
+#ifdef DECC_ENABLE_SECP224R1
+static const unsigned char gc_secp224r1_p[] __attribute__((aligned(8))) = {
+    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp224r1_b[] __attribute__((aligned(8))) = {
+    0xB4, 0xFF, 0x55, 0x23, 0x43, 0x39, 0x0B, 0x27,
+    0xBA, 0xD8, 0xBF, 0xD7, 0xB7, 0xB0, 0x44, 0x50,
+    0x56, 0x32, 0x41, 0xF5, 0xAB, 0xB3, 0x04, 0x0C,
+    0x85, 0x0A, 0x05, 0xB4, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp224r1_gx[] __attribute__((aligned(8))) = {
+    0x21, 0x1D, 0x5C, 0x11, 0xD6, 0x80, 0x32, 0x34,
+    0x22, 0x11, 0xC2, 0x56, 0xD3, 0xC1, 0x03, 0x4A,
+    0xB9, 0x90, 0x13, 0x32, 0x7F, 0xBF, 0xB4, 0x6B,
+    0xBD, 0x0C, 0x0E, 0xB7, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp224r1_gy[] __attribute__((aligned(8))) = {
+    0x34, 0x7E, 0x00, 0x85, 0x99, 0x81, 0xD5, 0x44,
+    0x64, 0x47, 0x07, 0x5A, 0xA0, 0x75, 0x43, 0xCD,
+    0xE6, 0xDF, 0x22, 0x4C, 0xFB, 0x23, 0xF7, 0xB5,
+    0x88, 0x63, 0x37, 0xBD, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp224r1_n[] __attribute__((aligned(8))) = {
+    0x3D, 0x2A, 0x5C, 0x5C, 0x45, 0x29, 0xDD, 0x13,
+    0x3E, 0xF0, 0xB8, 0xE0, 0xA2, 0x16, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+};
+#endif
+
+
+#ifdef DECC_ENABLE_SECP256R1
+static const unsigned char gc_secp256r1_p[] __attribute__((aligned(8))) = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+
+static const unsigned char gc_secp256r1_b[] __attribute__((aligned(8))) = {
+    0x4B, 0x60, 0xD2, 0x27, 0x3E, 0x3C, 0xCE, 0x3B,
+    0xF6, 0xB0, 0x53, 0xCC, 0xB0, 0x06, 0x1D, 0x65,
+    0xBC, 0x86, 0x98, 0x76, 0x55, 0xBD, 0xEB, 0xB3,
+    0xE7, 0x93, 0x3A, 0xAA, 0xD8, 0x35, 0xC6, 0x5A,
+};
+
+static const unsigned char gc_secp256r1_gx[] __attribute__((aligned(8))) = {
+    0x96, 0xC2, 0x98, 0xD8, 0x45, 0x39, 0xA1, 0xF4,
+    0xA0, 0x33, 0xEB, 0x2D, 0x81, 0x7D, 0x03, 0x77,
+    0xF2, 0x40, 0xA4, 0x63, 0xE5, 0xE6, 0xBC, 0xF8,
+    0x47, 0x42, 0x2C, 0xE1, 0xF2, 0xD1, 0x17, 0x6B,
+};
+
+static const unsigned char gc_secp256r1_gy[] __attribute__((aligned(8))) = {
+    0xF5, 0x51, 0xBF, 0x37, 0x68, 0x40, 0xB6, 0xCB,
+    0xCE, 0x5E, 0x31, 0x6B, 0x57, 0x33, 0xCE, 0x2B,
+    0x16, 0x9E, 0x0F, 0x7C, 0x4A, 0xEB, 0xE7, 0x8E,
+    0x9B, 0x7F, 0x1A, 0xFE, 0xE2, 0x42, 0xE3, 0x4F,
+};
+
+static const unsigned char gc_secp256r1_n[] __attribute__((aligned(8))) = {
+    0x51, 0x25, 0x63, 0xFC, 0xC2, 0xCA, 0xB9, 0xF3,
+    0x84, 0x9E, 0x17, 0xA7, 0xAD, 0xFA, 0xE6, 0xBC,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+#endif
+
+
+#ifdef DECC_ENABLE_SECP384R1
+static const unsigned char gc_secp384r1_p[] __attribute__((aligned(8))) = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+
+static const unsigned char gc_secp384r1_b[] __attribute__((aligned(8))) = {
+    0xEF, 0x2A, 0xEC, 0xD3, 0xED, 0xC8, 0x85, 0x2A,
+    0x9D, 0xD1, 0x2E, 0x8A, 0x8D, 0x39, 0x56, 0xC6,
+    0x5A, 0x87, 0x13, 0x50, 0x8F, 0x08, 0x14, 0x03,
+    0x12, 0x41, 0x81, 0xFE, 0x6E, 0x9C, 0x1D, 0x18,
+    0x19, 0x2D, 0xF8, 0xE3, 0x6B, 0x05, 0x8E, 0x98,
+    0xE4, 0xE7, 0x3E, 0xE2, 0xA7, 0x2F, 0x31, 0xB3,
+};
+
+static const unsigned char gc_secp384r1_gx[] __attribute__((aligned(8))) = {
+    0xB7, 0x0A, 0x76, 0x72, 0x38, 0x5E, 0x54, 0x3A,
+    0x6C, 0x29, 0x55, 0xBF, 0x5D, 0xF2, 0x02, 0x55,
+    0x38, 0x2A, 0x54, 0x82, 0xE0, 0x41, 0xF7, 0x59,
+    0x98, 0x9B, 0xA7, 0x8B, 0x62, 0x3B, 0x1D, 0x6E,
+    0x74, 0xAD, 0x20, 0xF3, 0x1E, 0xC7, 0xB1, 0x8E,
+    0x37, 0x05, 0x8B, 0xBE, 0x22, 0xCA, 0x87, 0xAA,
+};
+
+static const unsigned char gc_secp384r1_gy[] __attribute__((aligned(8))) = {
+    0x5F, 0x0E, 0xEA, 0x90, 0x7C, 0x1D, 0x43, 0x7A,
+    0x9D, 0x81, 0x7E, 0x1D, 0xCE, 0xB1, 0x60, 0x0A,
+    0xC0, 0xB8, 0xF0, 0xB5, 0x13, 0x31, 0xDA, 0xE9,
+    0x7C, 0x14, 0x9A, 0x28, 0xBD, 0x1D, 0xF4, 0xF8,
+    0x29, 0xDC, 0x92, 0x92, 0xBF, 0x98, 0x9E, 0x5D,
+    0x6F, 0x2C, 0x26, 0x96, 0x4A, 0xDE, 0x17, 0x36,
+};
+
+static const unsigned char gc_secp384r1_n[] __attribute__((aligned(8))) = {
+    0x73, 0x29, 0xC5, 0xCC, 0x6A, 0x19, 0xEC, 0xEC,
+    0x7A, 0xA7, 0xB0, 0x48, 0xB2, 0x0D, 0x1A, 0x58,
+    0xDF, 0x2D, 0x37, 0xF4, 0x81, 0x4D, 0x63, 0xC7,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+#endif
+
+
+#ifdef DECC_ENABLE_SECP521R1
+static const unsigned char gc_secp521r1_p[] __attribute__((aligned(8))) = {
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp521r1_b[] __attribute__((aligned(8))) = {
+    0x00, 0x3F, 0x50, 0x6B, 0xD4, 0x1F, 0x45, 0xEF,
+    0xF1, 0x34, 0x2C, 0x3D, 0x88, 0xDF, 0x73, 0x35,
+    0x07, 0xBF, 0xB1, 0x3B, 0xBD, 0xC0, 0x52, 0x16,
+    0x7B, 0x93, 0x7E, 0xEC, 0x51, 0x39, 0x19, 0x56,
+    0xE1, 0x09, 0xF1, 0x8E, 0x91, 0x89, 0xB4, 0xB8,
+    0xF3, 0x15, 0xB3, 0x99, 0x5B, 0x72, 0xDA, 0xA2,
+    0xEE, 0x40, 0x85, 0xB6, 0xA0, 0x21, 0x9A, 0x92,
+    0x1F, 0x9A, 0x1C, 0x8E, 0x61, 0xB9, 0x3E, 0x95,
+    0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp521r1_gx[] __attribute__((aligned(8))) = {
+    0x66, 0xBD, 0xE5, 0xC2, 0x31, 0x7E, 0x7E, 0xF9,
+    0x9B, 0x42, 0x6A, 0x85, 0xC1, 0xB3, 0x48, 0x33,
+    0xDE, 0xA8, 0xFF, 0xA2, 0x27, 0xC1, 0x1D, 0xFE,
+    0x28, 0x59, 0xE7, 0xEF, 0x77, 0x5E, 0x4B, 0xA1,
+    0xBA, 0x3D, 0x4D, 0x6B, 0x60, 0xAF, 0x28, 0xF8,
+    0x21, 0xB5, 0x3F, 0x05, 0x39, 0x81, 0x64, 0x9C,
+    0x42, 0xB4, 0x95, 0x23, 0x66, 0xCB, 0x3E, 0x9E,
+    0xCD, 0xE9, 0x04, 0x04, 0xB7, 0x06, 0x8E, 0x85,
+    0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp521r1_gy[] __attribute__((aligned(8))) = {
+    0x50, 0x66, 0xD1, 0x9F, 0x76, 0x94, 0xBE, 0x88,
+    0x40, 0xC2, 0x72, 0xA2, 0x86, 0x70, 0x3C, 0x35,
+    0x61, 0x07, 0xAD, 0x3F, 0x01, 0xB9, 0x50, 0xC5,
+    0x40, 0x26, 0xF4, 0x5E, 0x99, 0x72, 0xEE, 0x97,
+    0x2C, 0x66, 0x3E, 0x27, 0x17, 0xBD, 0xAF, 0x17,
+    0x68, 0x44, 0x9B, 0x57, 0x49, 0x44, 0xF5, 0x98,
+    0xD9, 0x1B, 0x7D, 0x2C, 0xB4, 0x5F, 0x8A, 0x5C,
+    0x04, 0xC0, 0x3B, 0x9A, 0x78, 0x6A, 0x29, 0x39,
+    0x18, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp521r1_n[] __attribute__((aligned(8))) = {
+    0x09, 0x64, 0x38, 0x91, 0x1E, 0xB7, 0x6F, 0xBB,
+    0xAE, 0x47, 0x9C, 0x89, 0xB8, 0xC9, 0xB5, 0x3B,
+    0xD0, 0xA5, 0x09, 0xF7, 0x48, 0x01, 0xCC, 0x7F,
+    0x6B, 0x96, 0x2F, 0xBF, 0x83, 0x87, 0x86, 0x51,
+    0xFA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+#endif
+
+
+#ifdef DECC_ENABLE_SECP192K1
+static const unsigned char gc_secp192k1_p[] __attribute__((aligned(8))) = {
+    0x37, 0xEE, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+
+static const unsigned char gc_secp192k1_a[] __attribute__((aligned(8))) = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp192k1_b[] __attribute__((aligned(8))) = {
+    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp192k1_gx[] __attribute__((aligned(8))) = {
+    0x7D, 0x6C, 0xE0, 0xEA, 0xB1, 0xD1, 0xA5, 0x1D,
+    0x34, 0xF4, 0xB7, 0x80, 0x02, 0x7D, 0xB0, 0x26,
+    0xAE, 0xE9, 0x57, 0xC0, 0x0E, 0xF1, 0x4F, 0xDB,
+};
+
+static const unsigned char gc_secp192k1_gy[] __attribute__((aligned(8))) = {
+    0x9D, 0x2F, 0x5E, 0xD9, 0x88, 0xAA, 0x82, 0x40,
+    0x34, 0x86, 0xBE, 0x15, 0xD0, 0x63, 0x41, 0x84,
+    0xA7, 0x28, 0x56, 0x9C, 0x6D, 0x2F, 0x2F, 0x9B,
+};
+
+static const unsigned char gc_secp192k1_n[] __attribute__((aligned(8))) = {
+    0x8D, 0xFD, 0xDE, 0x74, 0x6A, 0x46, 0x69, 0x0F,
+    0x17, 0xFC, 0xF2, 0x26, 0xFE, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+#endif
+
+
+#ifdef DECC_ENABLE_SECP224K1
+static const unsigned char gc_secp224k1_p[] __attribute__((aligned(8))) = {
+    0x6D, 0xE5, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp224k1_a[] __attribute__((aligned(8))) = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp224k1_b[] __attribute__((aligned(8))) = {
+    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp224k1_gx[] __attribute__((aligned(8))) = {
+    0x5C, 0xA4, 0xB7, 0xB6, 0x0E, 0x65, 0x7E, 0x0F,
+    0xA9, 0x75, 0x70, 0xE4, 0xE9, 0x67, 0xA4, 0x69,
+    0xA1, 0x28, 0xFC, 0x30, 0xDF, 0x99, 0xF0, 0x4D,
+    0x33, 0x5B, 0x45, 0xA1, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp224k1_gy[] __attribute__((aligned(8))) = {
+    0xA5, 0x61, 0x6D, 0x55, 0xDB, 0x4B, 0xCA, 0xE2,
+    0x59, 0xBD, 0xB0, 0xC0, 0xF7, 0x19, 0xE3, 0xF7,
+    0xD6, 0xFB, 0xCA, 0x82, 0x42, 0x34, 0xBA, 0x7F,
+    0xED, 0x9F, 0x08, 0x7E, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp224k1_n[] __attribute__((aligned(8))) = {
+    0xF7, 0xB1, 0x9F, 0x76, 0x71, 0xA9, 0xF0, 0xCA,
+    0x84, 0x61, 0xEC, 0xD2, 0xE8, 0xDC, 0x01, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+};
+#endif
+
+
+#ifdef DECC_ENABLE_SECP256K1
+static const unsigned char gc_secp256k1_p[] __attribute__((aligned(8))) = {
+    0x2F, 0xFC, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+
+static const unsigned char gc_secp256k1_a[] __attribute__((aligned(8))) = {
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp256k1_b[] __attribute__((aligned(8))) = {
+    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+static const unsigned char gc_secp256k1_gx[] __attribute__((aligned(8))) = {
+    0x98, 0x17, 0xF8, 0x16, 0x5B, 0x81, 0xF2, 0x59,
+    0xD9, 0x28, 0xCE, 0x2D, 0xDB, 0xFC, 0x9B, 0x02,
+    0x07, 0x0B, 0x87, 0xCE, 0x95, 0x62, 0xA0, 0x55,
+    0xAC, 0xBB, 0xDC, 0xF9, 0x7E, 0x66, 0xBE, 0x79,
+};
+
+static const unsigned char gc_secp256k1_gy[] __attribute__((aligned(8))) = {
+    0xB8, 0xD4, 0x10, 0xFB, 0x8F, 0xD0, 0x47, 0x9C,
+    0x19, 0x54, 0x85, 0xA6, 0x48, 0xB4, 0x17, 0xFD,
+    0xA8, 0x08, 0x11, 0x0E, 0xFC, 0xFB, 0xA4, 0x5D,
+    0x65, 0xC4, 0xA3, 0x26, 0x77, 0xDA, 0x3A, 0x48,
+};
+
+static const unsigned char gc_secp256k1_n[] __attribute__((aligned(8))) = {
+    0x41, 0x41, 0x36, 0xD0, 0x8C, 0x5E, 0xD2, 0xBF,
+    0x3B, 0xA0, 0x48, 0xAF, 0xE6, 0xDC, 0xAE, 0xBA,
+    0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+};
+#endif
+
+
+#ifdef DECC_ENABLE_BP256R1
+static const unsigned char gc_bp256r1_p[] __attribute__((aligned(8))) = {
+    0x77, 0x53, 0x6E, 0x1F, 0x1D, 0x48, 0x13, 0x20,
+    0x28, 0x20, 0x26, 0xD5, 0x23, 0xF6, 0x3B, 0x6E,
+    0x72, 0x8D, 0x83, 0x9D, 0x90, 0x0A, 0x66, 0x3E,
+    0xBC, 0xA9, 0xEE, 0xA1, 0xDB, 0x57, 0xFB, 0xA9,
+};
+
+static const unsigned char gc_bp256r1_a[] __attribute__((aligned(8))) = {
+    0xD9, 0xB5, 0x30, 0xF3, 0x44, 0x4B, 0x4A, 0xE9,
+    0x6C, 0x5C, 0xDC, 0x26, 0xC1, 0x55, 0x80, 0xFB,
+    0xE7, 0xFF, 0x7A, 0x41, 0x30, 0x75, 0xF6, 0xEE,
+    0x57, 0x30, 0x2C, 0xFC, 0x75, 0x09, 0x5A, 0x7D,
+};
+
+static const unsigned char gc_bp256r1_b[] __attribute__((aligned(8))) = {
+    0xB6, 0x07, 0x8C, 0xFF, 0x18, 0xDC, 0xCC, 0x6B,
+    0xCE, 0xE1, 0xF7, 0x5C, 0x29, 0x16, 0x84, 0x95,
+    0xBF, 0x7C, 0xD7, 0xBB, 0xD9, 0xB5, 0x30, 0xF3,
+    0x44, 0x4B, 0x4A, 0xE9, 0x6C, 0x5C, 0xDC, 0x26,
+};
+
+static const unsigned char gc_bp256r1_gx[] __attribute__((aligned(8))) = {
+    0x62, 0x32, 0xCE, 0x9A, 0xBD, 0x53, 0x44, 0x3A,
+    0xC2, 0x23, 0xBD, 0xE3, 0xE1, 0x27, 0xDE, 0xB9,
+    0xAF, 0xB7, 0x81, 0xFC, 0x2F, 0x48, 0x4B, 0x2C,
+    0xCB, 0x57, 0x7E, 0xCB, 0xB9, 0xAE, 0xD2, 0x8B,
+};
+
+static const unsigned char gc_bp256r1_gy[] __attribute__((aligned(8))) = {
+    0x97, 0x69, 0x04, 0x2F, 0xC7, 0x54, 0x1D, 0x5C,
+    0x54, 0x8E, 0xED, 0x2D, 0x13, 0x45, 0x77, 0xC2,
+    0xC9, 0x1D, 0x61, 0x14, 0x1A, 0x46, 0xF8, 0x97,
+    0xFD, 0xC4, 0xDA, 0xC3, 0x35, 0xF8, 0x7E, 0x54,
+};
+
+static const unsigned char gc_bp256r1_n[] __attribute__((aligned(8))) = {
+    0xA7, 0x56, 0x48, 0x97, 0x82, 0x0E, 0x1E, 0x90,
+    0xF7, 0xA6, 0x61, 0xB5, 0xA3, 0x7A, 0x39, 0x8C,
+    0x71, 0x8D, 0x83, 0x9D, 0x90, 0x0A, 0x66, 0x3E,
+    0xBC, 0xA9, 0xEE, 0xA1, 0xDB, 0x57, 0xFB, 0xA9,
+};
+#endif
+
+
+#ifdef DECC_ENABLE_BP384R1
+static const unsigned char gc_bp384r1_p[] __attribute__((aligned(8))) = {
+    0x53, 0xEC, 0x07, 0x31, 0x13, 0x00, 0x47, 0x87,
+    0x71, 0x1A, 0x1D, 0x90, 0x29, 0xA7, 0xD3, 0xAC,
+    0x23, 0x11, 0xB7, 0x7F, 0x19, 0xDA, 0xB1, 0x12,
+    0xB4, 0x56, 0x54, 0xED, 0x09, 0x71, 0x2F, 0x15,
+    0xDF, 0x41, 0xE6, 0x50, 0x7E, 0x6F, 0x5D, 0x0F,
+    0x28, 0x6D, 0x38, 0xA3, 0x82, 0x1E, 0xB9, 0x8C,
+};
+
+static const unsigned char gc_bp384r1_a[] __attribute__((aligned(8))) = {
+    0x26, 0x28, 0xCE, 0x22, 0xDD, 0xC7, 0xA8, 0x04,
+    0xEB, 0xD4, 0x3A, 0x50, 0x4A, 0x81, 0xA5, 0x8A,
+    0x0F, 0xF9, 0x91, 0xBA, 0xEF, 0x65, 0x91, 0x13,
+    0x87, 0x27, 0xB2, 0x4F, 0x8E, 0xA2, 0xBE, 0xC2,
+    0xA0, 0xAF, 0x05, 0xCE, 0x0A, 0x08, 0x72, 0x3C,
+    0x0C, 0x15, 0x8C, 0x3D, 0xC6, 0x82, 0xC3, 0x7B,
+};
+
+static const unsigned char gc_bp384r1_b[] __attribute__((aligned(8))) = {
+    0x11, 0x4C, 0x50, 0xFA, 0x96, 0x86, 0xB7, 0x3A,
+    0x94, 0xC9, 0xDB, 0x95, 0x02, 0x39, 0xB4, 0x7C,
+    0xD5, 0x62, 0xEB, 0x3E, 0xA5, 0x0E, 0x88, 0x2E,
+    0xA6, 0xD2, 0xDC, 0x07, 0xE1, 0x7D, 0xB7, 0x2F,
+    0x7C, 0x44, 0xF0, 0x16, 0x54, 0xB5, 0x39, 0x8B,
+    0x26, 0x28, 0xCE, 0x22, 0xDD, 0xC7, 0xA8, 0x04,
+};
+
+static const unsigned char gc_bp384r1_gx[] __attribute__((aligned(8))) = {
+    0x1E, 0xAF, 0xD4, 0x47, 0xE2, 0xB2, 0x87, 0xEF,
+    0xAA, 0x46, 0xD6, 0x36, 0x34, 0xE0, 0x26, 0xE8,
+    0xE8, 0x10, 0xBD, 0x0C, 0xFE, 0xCA, 0x7F, 0xDB,
+    0xE3, 0x4F, 0xF1, 0x7E, 0xE7, 0xA3, 0x47, 0x88,
+    0x6B, 0x3F, 0xC1, 0xB7, 0x81, 0x3A, 0xA6, 0xA2,
+    0xFF, 0x45, 0xCF, 0x68, 0xF0, 0x64, 0x1C, 0x1D,
+};
+
+static const unsigned char gc_bp384r1_gy[] __attribute__((aligned(8))) = {
+    0x15, 0x53, 0x3C, 0x26, 0x41, 0x03, 0x82, 0x42,
+    0x11, 0x81, 0x91, 0x77, 0x21, 0x46, 0x46, 0x0E,
+    0x28, 0x29, 0x91, 0xF9, 0x4F, 0x05, 0x9C, 0xE1,
+    0x64, 0x58, 0xEC, 0xFE, 0x29, 0x0B, 0xB7, 0x62,
+    0x52, 0xD5, 0xCF, 0x95, 0x8E, 0xEB, 0xB1, 0x5C,
+    0xA4, 0xC2, 0xF9, 0x20, 0x75, 0x1D, 0xBE, 0x8A,
+};
+
+static const unsigned char gc_bp384r1_n[] __attribute__((aligned(8))) = {
+    0x65, 0x65, 0x04, 0xE9, 0x02, 0x32, 0x88, 0x3B,
+    0x10, 0xC3, 0x7F, 0x6B, 0xAF, 0xB6, 0x3A, 0xCF,
+    0xA7, 0x25, 0x04, 0xAC, 0x6C, 0x6E, 0x16, 0x1F,
+    0xB3, 0x56, 0x54, 0xED, 0x09, 0x71, 0x2F, 0x15,
+    0xDF, 0x41, 0xE6, 0x50, 0x7E, 0x6F, 0x5D, 0x0F,
+    0x28, 0x6D, 0x38, 0xA3, 0x82, 0x1E, 0xB9, 0x8C,
+};
+#endif
+
+
+#ifdef DECC_ENABLE_BP512R1
+static const unsigned char gc_bp512r1_p[] __attribute__((aligned(8))) = {
+    0xF3, 0x48, 0x3A, 0x58, 0x56, 0x60, 0xAA, 0x28,
+    0x85, 0xC6, 0x82, 0x2D, 0x2F, 0xFF, 0x81, 0x28,
+    0xE6, 0x80, 0xA3, 0xE6, 0x2A, 0xA1, 0xCD, 0xAE,
+    0x42, 0x68, 0xC6, 0x9B, 0x00, 0x9B, 0x4D, 0x7D,
+    0x71, 0x08, 0x33, 0x70, 0xCA, 0x9C, 0x63, 0xD6,
+    0x0E, 0xD2, 0xC9, 0xB3, 0xB3, 0x8D, 0x30, 0xCB,
+    0x07, 0xFC, 0xC9, 0x33, 0xAE, 0xE6, 0xD4, 0x3F,
+    0x8B, 0xC4, 0xE9, 0xDB, 0xB8, 0x9D, 0xDD, 0xAA,
+};
+
+static const unsigned char gc_bp512r1_a[] __attribute__((aligned(8))) = {
+    0xCA, 0x94, 0xFC, 0x77, 0x4D, 0xAC, 0xC1, 0xE7,
+    0xB9, 0xC7, 0xF2, 0x2B, 0xA7, 0x17, 0x11, 0x7F,
+    0xB5, 0xC8, 0x9A, 0x8B, 0xC9, 0xF1, 0x2E, 0x0A,
+    0xA1, 0x3A, 0x25, 0xA8, 0x5A, 0x5D, 0xED, 0x2D,
+    0xBC, 0x63, 0x98, 0xEA, 0xCA, 0x41, 0x34, 0xA8,
+    0x10, 0x16, 0xF9, 0x3D, 0x8D, 0xDD, 0xCB, 0x94,
+    0xC5, 0x4C, 0x23, 0xAC, 0x45, 0x71, 0x32, 0xE2,
+    0x89, 0x3B, 0x60, 0x8B, 0x31, 0xA3, 0x30, 0x78,
+};
+
+static const unsigned char gc_bp512r1_b[] __attribute__((aligned(8))) = {
+    0x23, 0xF7, 0x16, 0x80, 0x63, 0xBD, 0x09, 0x28,
+    0xDD, 0xE5, 0xBA, 0x5E, 0xB7, 0x50, 0x40, 0x98,
+    0x67, 0x3E, 0x08, 0xDC, 0xCA, 0x94, 0xFC, 0x77,
+    0x4D, 0xAC, 0xC1, 0xE7, 0xB9, 0xC7, 0xF2, 0x2B,
+    0xA7, 0x17, 0x11, 0x7F, 0xB5, 0xC8, 0x9A, 0x8B,
+    0xC9, 0xF1, 0x2E, 0x0A, 0xA1, 0x3A, 0x25, 0xA8,
+    0x5A, 0x5D, 0xED, 0x2D, 0xBC, 0x63, 0x98, 0xEA,
+    0xCA, 0x41, 0x34, 0xA8, 0x10, 0x16, 0xF9, 0x3D,
+};
+
+static const unsigned char gc_bp512r1_gx[] __attribute__((aligned(8))) = {
+    0x22, 0xF8, 0xB9, 0xBC, 0x09, 0x22, 0x35, 0x8B,
+    0x68, 0x5E, 0x6A, 0x40, 0x47, 0x50, 0x6D, 0x7C,
+    0x5F, 0x7D, 0xB9, 0x93, 0x7B, 0x68, 0xD1, 0x50,
+    0x8D, 0xD4, 0xD0, 0xE2, 0x78, 0x1F, 0x3B, 0xFF,
+    0x8E, 0x09, 0xD0, 0xF4, 0xEE, 0x62, 0x3B, 0xB4,
+    0xC1, 0x16, 0xD9, 0xB5, 0x70, 0x9F, 0xED, 0x85,
+    0x93, 0x6A, 0x4C, 0x9C, 0x2E, 0x32, 0x21, 0x5A,
+    0x64, 0xD9, 0x2E, 0xD8, 0xBD, 0xE4, 0xAE, 0x81,
+};
+
+static const unsigned char gc_bp512r1_gy[] __attribute__((aligned(8))) = {
+    0x92, 0x08, 0xD8, 0x3A, 0x0F, 0x1E, 0xCD, 0x78,
+    0x06, 0x54, 0xF0, 0xA8, 0x2F, 0x2B, 0xCA, 0xD1,
+    0xAE, 0x63, 0x27, 0x8A, 0xD8, 0x4B, 0xCA, 0x5B,
+    0x5E, 0x48, 0x5F, 0x4A, 0x49, 0xDE, 0xDC, 0xB2,
+    0x11, 0x81, 0x1F, 0x88, 0x5B, 0xC5, 0x00, 0xA0,
+    0x1A, 0x7B, 0xA5, 0x24, 0x00, 0xF7, 0x09, 0xF2,
+    0xFD, 0x22, 0x78, 0xCF, 0xA9, 0xBF, 0xEA, 0xC0,
+    0xEC, 0x32, 0x63, 0x56, 0x5D, 0x38, 0xDE, 0x7D,
+};
+
+static const unsigned char gc_bp512r1_n[] __attribute__((aligned(8))) = {
+    0x69, 0x00, 0xA9, 0x9C, 0x82, 0x96, 0x87, 0xB5,
+    0xDD, 0xDA, 0x5D, 0x08, 0x81, 0xD3, 0xB1, 0x1D,
+    0x47, 0x10, 0xAC, 0x7F, 0x19, 0x61, 0x86, 0x41,
+    0x19, 0x26, 0xA9, 0x4C, 0x41, 0x5C, 0x3E, 0x55,
+    0x70, 0x08, 0x33, 0x70, 0xCA, 0x9C, 0x63, 0xD6,
+    0x0E, 0xD2, 0xC9, 0xB3, 0xB3, 0x8D, 0x30, 0xCB,
+    0x07, 0xFC, 0xC9, 0x33, 0xAE, 0xE6, 0xD4, 0x3F,
+    0x8B, 0xC4, 0xE9, 0xDB, 0xB8, 0x9D, 0xDD, 0xAA,
+};
+#endif
+
+
+static void ecc_point_init(ecc_point_t *point)
+{
+    big_number_init(&point->X);
+    big_number_init(&point->Y);
+    big_number_init(&point->Z);
+}
+
+static void ecc_group_init(ecc_group_t *group)
+{
+    memset(group, 0, sizeof(ecc_group_t));
+}
+
+static void ecc_keypair_init(ecc_keypair_t *key)
+{
+    ecc_group_init(&key->group);
+    big_number_init(&key->d);
+    ecc_point_init(&key->Q);
+}
+
+static void ecc_point_free(ecc_point_t *point)
+{
+    big_number_free(&(point->X));
+    big_number_free(&(point->Y));
+    big_number_free(&(point->Z));
+}
+
+static void ecc_group_free(ecc_group_t *group)
+{
+    unsigned int i;
+
+    if (group->T) {
+        for (i = 0; i < group->T_size; i++) {
+            ecc_point_free(&group->T[i]);
+        }
+        free(group->T);
+    }
+
+    memset(group, 0x0, sizeof(ecc_group_t));
+}
+
+static void ecc_keypair_free(ecc_keypair_t *key)
+{
+    ecc_group_free(&key->group);
+    big_number_free(&key->d);
+    ecc_point_free(&key->Q);
+}
+
+static int ecc_copy(ecc_point_t *P, const ecc_point_t *Q)
+{
+    int ret;
+
+    ret = big_number_copy(&P->X, &Q->X);
+    ret = big_number_copy(&P->Y, &Q->Y);
+    ret = big_number_copy(&P->Z, &Q->Z);
+
+    return ret;
+}
+
+static void ecc_big_number_load(big_number_t *X, const TUINT *p, unsigned int len)
+{
+    X->s = 1;
+    X->n = len / sizeof(TUINT);
+    X->p = (TUINT *) p;
+}
+
+static void ecc_big_number_set1(big_number_t *X)
+{
+    static TUINT one[] = {1};
+    X->s = 1;
+    X->n = 1;
+    X->p = one;
+}
+
+static void ecc_load_group(ecc_group_t *group,
+    const TUINT *p,  unsigned int plen,
+    const TUINT *a,  unsigned int alen,
+    const TUINT *b,  unsigned int blen,
+    const TUINT *gx, unsigned int gxlen,
+    const TUINT *gy, unsigned int gylen,
+    const TUINT *n,  unsigned int nlen)
+{
+    ecc_big_number_load(&group->P, p, plen);
+    if (a != NULL) {
+        ecc_big_number_load(&group->A, a, alen);
+    }
+    ecc_big_number_load(&group->B, b, blen);
+    ecc_big_number_load(&group->N, n, nlen);
+
+    ecc_big_number_load(&group->G.X, gx, gxlen);
+    ecc_big_number_load(&group->G.Y, gy, gylen);
+    ecc_big_number_set1(&group->G.Z);
+
+    group->pbits = big_number_msb(&group->P);
+    group->nbits = big_number_msb(&group->N);
+}
+
+int ecc_setup_group(int ecc_dp, ecc_group_t *group)
+{
+    ecc_group_init(group);
+    group->id = ecc_dp;
+    switch (ecc_dp) {
+
+        case CRYPTO_ECC_DP_SECP192R1:
+#ifdef DECC_ENABLE_SECP192R1
+            ecc_load_group(group,
+                (const TUINT *) gc_secp192r1_p, (unsigned int) sizeof(gc_secp192r1_p),
+                NULL, 0,
+                (const TUINT *) gc_secp192r1_b, (unsigned int) sizeof(gc_secp192r1_b),
+                (const TUINT *) gc_secp192r1_gx, (unsigned int) sizeof(gc_secp192r1_gx),
+                (const TUINT *) gc_secp192r1_gy, (unsigned int) sizeof(gc_secp192r1_gy),
+                (const TUINT *) gc_secp192r1_n, (unsigned int) sizeof(gc_secp192r1_n));
+            return 0;
+#endif
+            break;
+
+        case CRYPTO_ECC_DP_SECP224R1:
+#ifdef DECC_ENABLE_SECP224R1
+            ecc_load_group(group,
+                (const TUINT *) gc_secp224r1_p, (unsigned int) sizeof(gc_secp224r1_p),
+                NULL, 0,
+                (const TUINT *) gc_secp224r1_b, (unsigned int) sizeof(gc_secp224r1_b),
+                (const TUINT *) gc_secp224r1_gx, (unsigned int) sizeof(gc_secp224r1_gx),
+                (const TUINT *) gc_secp224r1_gy, (unsigned int) sizeof(gc_secp224r1_gy),
+                (const TUINT *) gc_secp224r1_n, (unsigned int) sizeof(gc_secp224r1_n));
+            return 0;
+#endif
+            break;
+
+        case CRYPTO_ECC_DP_SECP256R1:
+#ifdef DECC_ENABLE_SECP256R1
+            ecc_load_group(group,
+                (const TUINT *) gc_secp256r1_p, (unsigned int) sizeof(gc_secp256r1_p),
+                NULL, 0,
+                (const TUINT *) gc_secp256r1_b, (unsigned int) sizeof(gc_secp256r1_b),
+                (const TUINT *) gc_secp256r1_gx, (unsigned int) sizeof(gc_secp256r1_gx),
+                (const TUINT *) gc_secp256r1_gy, (unsigned int) sizeof(gc_secp256r1_gy),
+                (const TUINT *) gc_secp256r1_n, (unsigned int) sizeof(gc_secp256r1_n));
+            return 0;
+#endif
+            break;
+
+        case CRYPTO_ECC_DP_SECP384R1:
+#ifdef DECC_ENABLE_SECP384R1
+            ecc_load_group(group,
+                (const TUINT *) gc_secp384r1_p, (unsigned int) sizeof(gc_secp384r1_p),
+                NULL, 0,
+                (const TUINT *) gc_secp384r1_b, (unsigned int) sizeof(gc_secp384r1_b),
+                (const TUINT *) gc_secp384r1_gx, (unsigned int) sizeof(gc_secp384r1_gx),
+                (const TUINT *) gc_secp384r1_gy, (unsigned int) sizeof(gc_secp384r1_gy),
+                (const TUINT *) gc_secp384r1_n, (unsigned int) sizeof(gc_secp384r1_n));
+            return 0;
+#endif
+            break;
+
+        case CRYPTO_ECC_DP_SECP521R1:
+#ifdef DECC_ENABLE_SECP521R1
+            ecc_load_group(group,
+                (const TUINT *) gc_secp521r1_p, (unsigned int) sizeof(gc_secp521r1_p),
+                NULL, 0,
+                (const TUINT *) gc_secp521r1_b, (unsigned int) sizeof(gc_secp521r1_b),
+                (const TUINT *) gc_secp521r1_gx, (unsigned int) sizeof(gc_secp521r1_gx),
+                (const TUINT *) gc_secp521r1_gy, (unsigned int) sizeof(gc_secp521r1_gy),
+                (const TUINT *) gc_secp521r1_n, (unsigned int) sizeof(gc_secp521r1_n));
+            return 0;
+#endif
+            break;
+
+        case CRYPTO_ECC_DP_SECP192K1:
+#ifdef DECC_ENABLE_SECP192K1
+            ecc_load_group(group,
+                (const TUINT *) gc_secp192k1_p, (unsigned int) sizeof(gc_secp192k1_p),
+                (const TUINT *) gc_secp192k1_a, (unsigned int) sizeof(gc_secp192k1_a),
+                (const TUINT *) gc_secp192k1_b, (unsigned int) sizeof(gc_secp192k1_b),
+                (const TUINT *) gc_secp192k1_gx, (unsigned int) sizeof(gc_secp192k1_gx),
+                (const TUINT *) gc_secp192k1_gy, (unsigned int) sizeof(gc_secp192k1_gy),
+                (const TUINT *) gc_secp192k1_n, (unsigned int) sizeof(gc_secp192k1_n));
+            return 0;
+#endif
+            break;
+
+        case CRYPTO_ECC_DP_SECP224K1:
+#ifdef DECC_ENABLE_SECP224K1
+            ecc_load_group(group,
+                (const TUINT *) gc_secp224k1_p, (unsigned int) sizeof(gc_secp224k1_p),
+                (const TUINT *) gc_secp224k1_a, (unsigned int) sizeof(gc_secp224k1_a),
+                (const TUINT *) gc_secp224k1_b, (unsigned int) sizeof(gc_secp224k1_b),
+                (const TUINT *) gc_secp224k1_gx, (unsigned int) sizeof(gc_secp224k1_gx),
+                (const TUINT *) gc_secp224k1_gy, (unsigned int) sizeof(gc_secp224k1_gy),
+                (const TUINT *) gc_secp224k1_n, (unsigned int) sizeof(gc_secp224k1_n));
+            return 0;
+#endif
+            break;
+
+        case CRYPTO_ECC_DP_SECP256K1:
+#ifdef DECC_ENABLE_SECP256K1
+            ecc_load_group(group,
+                (const TUINT *) gc_secp256k1_p, (unsigned int) sizeof(gc_secp256k1_p),
+                (const TUINT *) gc_secp256k1_a, (unsigned int) sizeof(gc_secp256k1_a),
+                (const TUINT *) gc_secp256k1_b, (unsigned int) sizeof(gc_secp256k1_b),
+                (const TUINT *) gc_secp256k1_gx, (unsigned int) sizeof(gc_secp256k1_gx),
+                (const TUINT *) gc_secp256k1_gy, (unsigned int) sizeof(gc_secp256k1_gy),
+                (const TUINT *) gc_secp256k1_n, (unsigned int) sizeof(gc_secp256k1_n));
+            return 0;
+#endif
+            break;
+
+        case CRYPTO_ECC_DP_BP256R1:
+#ifdef DECC_ENABLE_BP256R1
+            ecc_load_group(group,
+                (const TUINT *) gc_bp256r1_p, (unsigned int) sizeof(gc_bp256r1_p),
+                (const TUINT *) gc_bp256r1_a, (unsigned int) sizeof(gc_bp256r1_a),
+                (const TUINT *) gc_bp256r1_b, (unsigned int) sizeof(gc_bp256r1_b),
+                (const TUINT *) gc_bp256r1_gx, (unsigned int) sizeof(gc_bp256r1_gx),
+                (const TUINT *) gc_bp256r1_gy, (unsigned int) sizeof(gc_bp256r1_gy),
+                (const TUINT *) gc_bp256r1_n, (unsigned int) sizeof(gc_bp256r1_n));
+            return 0;
+#endif
+            break;
+
+        case CRYPTO_ECC_DP_BP384R1:
+#ifdef DECC_ENABLE_BP384R1
+            ecc_load_group(group,
+                (const TUINT *) gc_bp384r1_p, (unsigned int) sizeof(gc_bp384r1_p),
+                (const TUINT *) gc_bp384r1_a, (unsigned int) sizeof(gc_bp384r1_a),
+                (const TUINT *) gc_bp384r1_b, (unsigned int) sizeof(gc_bp384r1_b),
+                (const TUINT *) gc_bp384r1_gx, (unsigned int) sizeof(gc_bp384r1_gx),
+                (const TUINT *) gc_bp384r1_gy, (unsigned int) sizeof(gc_bp384r1_gy),
+                (const TUINT *) gc_bp384r1_n, (unsigned int) sizeof(gc_bp384r1_n));
+            return 0;
+#endif
+            break;
+
+        case CRYPTO_ECC_DP_BP512R1:
+#ifdef DECC_ENABLE_BP512R1
+            ecc_load_group(group,
+                (const TUINT *) gc_bp512r1_p, (unsigned int) sizeof(gc_bp512r1_p),
+                (const TUINT *) gc_bp512r1_a, (unsigned int) sizeof(gc_bp512r1_a),
+                (const TUINT *) gc_bp512r1_b, (unsigned int) sizeof(gc_bp512r1_b),
+                (const TUINT *) gc_bp512r1_gx, (unsigned int) sizeof(gc_bp512r1_gx),
+                (const TUINT *) gc_bp512r1_gy, (unsigned int) sizeof(gc_bp512r1_gy),
+                (const TUINT *) gc_bp512r1_n, (unsigned int) sizeof(gc_bp512r1_n));
+            return 0;
+#endif
+            break;
+
+        default:
+            break;
+    }
+
+    DCRYPT_LOG("not supported ecc %d\n", ecc_dp);
+    return (-1);
+}
+
+static void ecc_set_zero( ecc_point_t *pt )
+{
+    big_number_lset(&pt->X, 1);
+    big_number_lset(&pt->Y, 1);
+    big_number_lset(&pt->Z, 0);
+}
+
+static int ecc_is_zero(ecc_point_t *pt)
+{
+    return (big_number_cmp_int(&pt->Z, 0) == 0);
+}
+
+
+int ecc_point_read_string(ecc_point_t *P, int radix,
+    const char *x, const char *y)
+{
+    int ret;
+
+    D_CLEAN_IF_FAILED(big_number_read_string(&P->X, radix, x));
+    D_CLEAN_IF_FAILED(big_number_read_string(&P->Y, radix, y));
+    D_CLEAN_IF_FAILED(big_number_lset(&P->Z, 1));
+
+cleanup:
+    return ret;
+}
+
+int ecc_group_read_string(ecc_group_t *group, int radix,
+    const char *p, const char *b,
+    const char *gx, const char *gy, const char *n)
+{
+    int ret;
+
+    D_CLEAN_IF_FAILED(big_number_read_string(&group->P, radix, p));
+    D_CLEAN_IF_FAILED(big_number_read_string(&group->B, radix, b));
+    D_CLEAN_IF_FAILED(ecc_point_read_string(&group->G, radix, gx, gy));
+    D_CLEAN_IF_FAILED(big_number_read_string(&group->N, radix, n));
+
+    group->pbits = big_number_msb(&group->P);
+    group->nbits = big_number_msb(&group->N);
+
+cleanup:
+    if (ret != 0) {
+        ecc_group_free(group);
+    }
+
+    return ret;
+}
+
+static int ecc_modp(big_number_t *N, const ecc_group_t *group)
+{
+    int ret;
+
+    if (group->modp == NULL) {
+        return big_number_mod_big_number(N, N, &group->P);
+    }
+
+    if ((N->s < 0 && big_number_cmp_int( N, 0) != 0) || big_number_msb(N) > 2 * group->pbits) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    D_CLEAN_IF_FAILED(group->modp(N));
+
+    while (N->s < 0 && big_number_cmp_int(N, 0) != 0) {
+        D_CLEAN_IF_FAILED(big_number_add_big_number(N, N, &group->P));
+    }
+
+    while (big_number_cmp_big_number(N, &group->P) >= 0) {
+        D_CLEAN_IF_FAILED(big_number_sub_abs(N, N, &group->P));
+    }
+
+cleanup:
+    return ret;
+}
+
+#define MOD_MUL(N) do { D_CLEAN_IF_FAILED( ecc_modp(&N, group)); } \
+    while (0)
+
+#define MOD_SUB(N)                                \
+    while (N.s < 0 && big_number_cmp_int(&N, 0) != 0)   \
+        D_CLEAN_IF_FAILED(big_number_add_big_number(&N, &N, &group->P))
+
+#define MOD_ADD(N)                                \
+    while (big_number_cmp_big_number(&N, &group->P) >= 0)        \
+        D_CLEAN_IF_FAILED(big_number_sub_abs(&N, &N, &group->P))
+
+static int ecc_normalize_jac(const ecc_group_t *group, ecc_point_t *pt)
+{
+    int ret;
+    big_number_t Zi, ZZi;
+
+    if (big_number_cmp_int(&pt->Z, 0) == 0) {
+        return 0;
+    }
+
+    big_number_init(&Zi);
+    big_number_init(&ZZi);
+
+    D_CLEAN_IF_FAILED(big_number_inv_mod(&Zi, &pt->Z, &group->P));
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&ZZi, &Zi, &Zi));
+    MOD_MUL(ZZi);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&pt->X, &pt->X, &ZZi));
+    MOD_MUL(pt->X);
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&pt->Y, &pt->Y, &ZZi));
+    MOD_MUL(pt->Y);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&pt->Y, &pt->Y, &Zi));
+    MOD_MUL(pt->Y);
+
+    D_CLEAN_IF_FAILED(big_number_lset(&pt->Z, 1));
+
+cleanup:
+
+    big_number_free(&Zi);
+    big_number_free(&ZZi);
+
+    return ret;
+}
+
+static int ecc_normalize_jac_many(const ecc_group_t *group,
+    ecc_point_t *T[], unsigned int t_len)
+{
+    int ret;
+    unsigned int i;
+    big_number_t *c, u, Zi, ZZi;
+
+    if (t_len < 2) {
+        return ecc_normalize_jac(group, *T);
+    }
+
+    if ((c = malloc(t_len * sizeof(big_number_t))) == NULL) {
+        return CRYPTO_ECODE_ERROR_NO_MEMORY;
+    }
+
+    big_number_init(&u);
+    big_number_init(&Zi);
+    big_number_init(&ZZi);
+    for (i = 0; i < t_len; i++) {
+        big_number_init(&c[i]);
+    }
+
+    D_CLEAN_IF_FAILED(big_number_copy(&c[0], &T[0]->Z));
+    for (i = 1; i < t_len; i++) {
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(&c[i], &c[i-1], &T[i]->Z));
+        MOD_MUL(c[i]);
+    }
+
+    D_CLEAN_IF_FAILED(big_number_inv_mod(&u, &c[t_len-1], &group->P));
+
+    for (i = t_len - 1; ; i--) {
+        if (i == 0) {
+            D_CLEAN_IF_FAILED(big_number_copy(&Zi, &u));
+        } else {
+            D_CLEAN_IF_FAILED(big_number_mul_big_number(&Zi, &u, &c[i-1]));
+            MOD_MUL(Zi);
+            D_CLEAN_IF_FAILED(big_number_mul_big_number(&u,  &u, &T[i]->Z));
+            MOD_MUL(u);
+        }
+
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(&ZZi, &Zi, &Zi));
+        MOD_MUL(ZZi);
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(&T[i]->X, &T[i]->X, &ZZi));
+        MOD_MUL(T[i]->X);
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(&T[i]->Y, &T[i]->Y, &ZZi));
+        MOD_MUL(T[i]->Y);
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(&T[i]->Y, &T[i]->Y, &Zi));
+        MOD_MUL(T[i]->Y);
+
+        D_CLEAN_IF_FAILED(big_number_shrink(&T[i]->X, group->P.n));
+        D_CLEAN_IF_FAILED(big_number_shrink(&T[i]->Y, group->P.n));
+        big_number_free(&T[i]->Z);
+
+        if (i == 0) {
+            break;
+        }
+    }
+
+cleanup:
+
+    big_number_free(&u);
+    big_number_free(&Zi);
+    big_number_free(&ZZi);
+    for (i = 0; i < t_len; i++) {
+        big_number_free(&c[i]);
+    }
+    free(c);
+
+    return ret;
+}
+
+static int ecc_safe_invert_jac(const ecc_group_t *group,
+    ecc_point_t *Q, unsigned char inv)
+{
+    int ret;
+    unsigned char nonzero;
+    big_number_t mQY;
+
+    big_number_init(&mQY);
+
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&mQY, &group->P, &Q->Y));
+    nonzero = big_number_cmp_int(&Q->Y, 0) != 0;
+    D_CLEAN_IF_FAILED(big_number_safe_cond_assign(&Q->Y, &mQY, inv & nonzero));
+
+cleanup:
+    big_number_free(&mQY);
+
+    return ret;
+}
+
+static int ecc_double_jac(const ecc_group_t *group, ecc_point_t *R,
+    const ecc_point_t *P)
+{
+    int ret;
+    big_number_t M, S, T, U;
+
+    big_number_init(&M);
+    big_number_init(&S);
+    big_number_init(&T);
+    big_number_init(&U);
+
+    if (!group->A.p) {
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(&S, &P->Z, &P->Z));
+        MOD_MUL(S);
+        D_CLEAN_IF_FAILED(big_number_add_big_number(&T, &P->X, &S));
+        MOD_ADD(T);
+        D_CLEAN_IF_FAILED(big_number_sub_big_number(&U, &P->X, &S));
+        MOD_SUB(U);
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(&S, &T, &U));
+        MOD_MUL(S);
+        D_CLEAN_IF_FAILED(big_number_mul_int(&M, &S, 3));
+        MOD_ADD(M);
+    } else {
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(&S, &P->X, &P->X));
+        MOD_MUL(S);
+        D_CLEAN_IF_FAILED(big_number_mul_int(&M, &S, 3));
+        MOD_ADD(M);
+
+        if (big_number_cmp_int(&group->A, 0) != 0) {
+            D_CLEAN_IF_FAILED(big_number_mul_big_number(&S, &P->Z, &P->Z));
+            MOD_MUL(S);
+            D_CLEAN_IF_FAILED(big_number_mul_big_number(&T, &S, &S));
+            MOD_MUL(T);
+            D_CLEAN_IF_FAILED(big_number_mul_big_number(&S, &T, &group->A));
+            MOD_MUL(S);
+            D_CLEAN_IF_FAILED(big_number_add_big_number(&M, &M, &S));
+            MOD_ADD(M);
+        }
+    }
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T, &P->Y, &P->Y));
+    MOD_MUL(T);
+    D_CLEAN_IF_FAILED(big_number_shift_l(&T, 1));
+    MOD_ADD(T);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&S, &P->X, &T));
+    MOD_MUL(S);
+    D_CLEAN_IF_FAILED(big_number_shift_l(&S, 1));
+    MOD_ADD(S);
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&U, &T, &T));
+    MOD_MUL(U);
+    D_CLEAN_IF_FAILED(big_number_shift_l(&U, 1));
+    MOD_ADD(U);
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T, &M, &M));
+    MOD_MUL(T);
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&T, &T, &S));
+    MOD_SUB(T);
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&T, &T, &S));
+    MOD_SUB(T);
+
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&S, &S, &T));
+    MOD_SUB(S);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&S, &S, &M));
+    MOD_MUL(S);
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&S, &S, &U));
+    MOD_SUB(S);
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&U, &P->Y, &P->Z));
+    MOD_MUL(U);
+    D_CLEAN_IF_FAILED(big_number_shift_l(&U, 1));
+    MOD_ADD(U);
+
+    D_CLEAN_IF_FAILED(big_number_copy(&R->X, &T));
+    D_CLEAN_IF_FAILED(big_number_copy(&R->Y, &S));
+    D_CLEAN_IF_FAILED(big_number_copy(&R->Z, &U));
+
+cleanup:
+    big_number_free(&M);
+    big_number_free(&S);
+    big_number_free(&T);
+    big_number_free(&U);
+
+    return ret;
+}
+
+static int ecc_add_mixed(const ecc_group_t *group, ecc_point_t *R,
+    const ecc_point_t *P, const ecc_point_t *Q)
+{
+    int ret;
+    big_number_t T1, T2, T3, T4, X, Y, Z;
+
+    if (big_number_cmp_int(&P->Z, 0) == 0) {
+        return ecc_copy(R, Q);
+    }
+
+    if (Q->Z.p != NULL && big_number_cmp_int(&Q->Z, 0) == 0) {
+        return ecc_copy(R, P);
+    }
+
+    if (Q->Z.p != NULL && big_number_cmp_int(&Q->Z, 1) != 0) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    big_number_init(&T1);
+    big_number_init(&T2);
+    big_number_init(&T3);
+    big_number_init(&T4);
+    big_number_init(&X);
+    big_number_init(&Y);
+    big_number_init(&Z);
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T1, &P->Z, &P->Z));
+    MOD_MUL(T1);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T2, &T1, &P->Z));
+    MOD_MUL(T2);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T1, &T1, &Q->X));
+    MOD_MUL(T1);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T2, &T2, &Q->Y));
+    MOD_MUL(T2);
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&T1, &T1, &P->X));
+    MOD_SUB(T1);
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&T2, &T2, &P->Y));
+    MOD_SUB(T2);
+
+    if (big_number_cmp_int(&T1, 0) == 0) {
+        if (big_number_cmp_int(&T2, 0) == 0) {
+            ret = ecc_double_jac(group, R, P);
+            goto cleanup;
+        } else {
+            ecc_set_zero(R);
+            goto cleanup;
+        }
+    }
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&Z, &P->Z, &T1));
+    MOD_MUL(Z);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T3, &T1, &T1));
+    MOD_MUL(T3);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T4, &T3, &T1));
+    MOD_MUL(T4);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T3, &T3, &P->X));
+    MOD_MUL(T3);
+    D_CLEAN_IF_FAILED(big_number_mul_int(&T1, &T3, 2));
+    MOD_ADD(T1);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&X, &T2, &T2));
+    MOD_MUL(X);
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&X, &X, &T1));
+    MOD_SUB(X);
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&X, &X, &T4));
+    MOD_SUB(X);
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&T3, &T3, &X));
+    MOD_SUB(T3);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T3, &T3, &T2));
+    MOD_MUL(T3);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&T4, &T4, &P->Y));
+    MOD_MUL(T4);
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&Y, &T3, &T4));
+    MOD_SUB(Y);
+
+    D_CLEAN_IF_FAILED(big_number_copy(&R->X, &X));
+    D_CLEAN_IF_FAILED(big_number_copy(&R->Y, &Y));
+    D_CLEAN_IF_FAILED(big_number_copy(&R->Z, &Z));
+
+cleanup:
+
+    big_number_free(&T1);
+    big_number_free(&T2);
+    big_number_free(&T3);
+    big_number_free(&T4);
+    big_number_free(&X);
+    big_number_free(&Y);
+    big_number_free(&Z);
+
+    return ret;
+}
+
+int ecc_add(const ecc_group_t *group, ecc_point_t *R,
+    const ecc_point_t *P, const ecc_point_t *Q)
+{
+    int ret;
+
+    D_CLEAN_IF_FAILED(ecc_add_mixed(group, R, P, Q));
+    D_CLEAN_IF_FAILED(ecc_normalize_jac(group, R));
+
+cleanup:
+    return ret;
+}
+
+int ecc_sub(const ecc_group_t *group, ecc_point_t *R,
+    const ecc_point_t *P, const ecc_point_t *Q)
+{
+    int ret;
+    ecc_point_t mQ;
+
+    ecc_point_init(&mQ);
+
+    D_CLEAN_IF_FAILED(ecc_copy(&mQ, Q));
+    if (big_number_cmp_int(&mQ.Y, 0) != 0) {
+        D_CLEAN_IF_FAILED(big_number_sub_big_number(&mQ.Y, &group->P, &mQ.Y));
+    }
+
+    D_CLEAN_IF_FAILED(ecc_add_mixed(group, R, P, &mQ));
+    D_CLEAN_IF_FAILED(ecc_normalize_jac(group, R));
+
+cleanup:
+    ecc_point_free(&mQ);
+
+    return ret;
+}
+
+static int ecc_randomize_jac(const ecc_group_t *group, ecc_point_t *pt,
+    int (*f_rng)(void *, unsigned char *, unsigned int), void *p_rng)
+{
+    int ret;
+    big_number_t l, ll;
+    unsigned int p_size = ( group->pbits + 7 ) / 8;
+    int count = 0;
+
+    big_number_init(&l);
+    big_number_init(&ll);
+
+    do {
+        big_number_fill_random(&l, p_size, f_rng, p_rng);
+
+        while (big_number_cmp_big_number(&l, &group->P ) >= 0) {
+            D_CLEAN_IF_FAILED(big_number_shift_r(&l, 1));
+        }
+
+        if (count ++ > 12) {
+            return CRYPTO_ECODE_RANDOM_NUMBER_GENERATION_FAILED;
+        }
+    } while (big_number_cmp_int(&l, 1) <= 0);
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&pt->Z, &pt->Z, &l));
+    MOD_MUL(pt->Z);
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&ll, &l, &l));
+    MOD_MUL(ll);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&pt->X, &pt->X, &ll));
+    MOD_MUL(pt->X);
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&ll, &ll, &l));
+    MOD_MUL(ll);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&pt->Y, &pt->Y, &ll));
+    MOD_MUL(pt->Y);
+
+cleanup:
+    big_number_free(&l);
+    big_number_free(&ll);
+
+    return ret;
+}
+
+#define COMB_MAX_D      (DMAX_ECC_BITS + 1) / 2
+
+#define COMB_MAX_PRE    (1 << (DECC_WINDOW_SIZE - 1))
+
+static void ecc_comb_fixed(unsigned char x[], unsigned int d,
+    unsigned char w, const big_number_t *m)
+{
+    unsigned int i, j;
+    unsigned char c, cc, adjust;
+
+    memset(x, 0, d + 1);
+
+    for (i = 0; i < d; i++) {
+        for (j = 0; j < w; j++) {
+            x[i] |= big_number_get_bit(m, i + d * j) << j;
+        }
+    }
+
+    c = 0;
+    for (i = 1; i <= d; i++) {
+        cc = x[i] & c;
+        x[i] = x[i] ^ c;
+        c = cc;
+
+        adjust = 1 - (x[i] & 0x01);
+        c |= x[i] & (x[i-1] * adjust);
+        x[i] = x[i] ^ (x[i-1] * adjust);
+        x[i-1] |= adjust << 7;
+    }
+}
+
+static int ecc_precompute_comb(const ecc_group_t *group,
+    ecc_point_t T[], const ecc_point_t *P,
+    unsigned char w, unsigned int d)
+{
+    int ret;
+    unsigned char i, k;
+    unsigned int j;
+    ecc_point_t *cur, *TT[COMB_MAX_PRE - 1];
+
+    D_CLEAN_IF_FAILED(ecc_copy( &T[0], P));
+
+    k = 0;
+    for (i = 1; i < (1U << ( w - 1)); i <<= 1) {
+        cur = T + i;
+        D_CLEAN_IF_FAILED(ecc_copy(cur, T + ( i >> 1)));
+        for (j = 0; j < d; j++) {
+            D_CLEAN_IF_FAILED(ecc_double_jac(group, cur, cur));
+        }
+
+        TT[k++] = cur;
+    }
+
+    D_CLEAN_IF_FAILED(ecc_normalize_jac_many(group, TT, k));
+
+    k = 0;
+    for (i = 1; i < ( 1U << ( w - 1 ) ); i <<= 1) {
+        j = i;
+        while (j--) {
+            D_CLEAN_IF_FAILED(ecc_add_mixed(group, &T[i + j], &T[j], &T[i]));
+            TT[k++] = &T[i + j];
+        }
+    }
+
+    D_CLEAN_IF_FAILED(ecc_normalize_jac_many(group, TT, k));
+
+cleanup:
+    return ret;
+}
+
+static int ecc_select_comb(const ecc_group_t *group, ecc_point_t *R,
+    const ecc_point_t T[], unsigned char t_len,
+    unsigned char i)
+{
+    int ret;
+    unsigned char ii, j;
+
+    ii =  (i & 0x7Fu) >> 1;
+
+    for (j = 0; j < t_len; j++) {
+        D_CLEAN_IF_FAILED(big_number_safe_cond_assign(&R->X, &T[j].X, j == ii));
+        D_CLEAN_IF_FAILED(big_number_safe_cond_assign(&R->Y, &T[j].Y, j == ii));
+    }
+
+    D_CLEAN_IF_FAILED(ecc_safe_invert_jac(group, R, i >> 7));
+
+cleanup:
+    return ret;
+}
+
+static int ecc_mul_comb_core(const ecc_group_t *group, ecc_point_t *R,
+    const ecc_point_t T[], unsigned char t_len,
+    const unsigned char x[], unsigned int d,
+    int (*f_rng)(void *, unsigned char *, unsigned int),
+    void *p_rng)
+{
+    int ret;
+    ecc_point_t Txi;
+    unsigned int i;
+
+    ecc_point_init(&Txi);
+
+    i = d;
+    D_CLEAN_IF_FAILED(ecc_select_comb(group, R, T, t_len, x[i]));
+    D_CLEAN_IF_FAILED(big_number_lset(&R->Z, 1));
+    if (f_rng != 0) {
+        D_CLEAN_IF_FAILED(ecc_randomize_jac(group, R, f_rng, p_rng));
+    }
+
+    while (i-- != 0) {
+        D_CLEAN_IF_FAILED(ecc_double_jac(group, R, R));
+        D_CLEAN_IF_FAILED(ecc_select_comb(group, &Txi, T, t_len, x[i]));
+        D_CLEAN_IF_FAILED(ecc_add_mixed(group, R, R, &Txi));
+    }
+
+cleanup:
+    ecc_point_free(&Txi);
+
+    return ret;
+}
+
+static int ecc_mul_comb(ecc_group_t *group, ecc_point_t *R,
+    const big_number_t *m, const ecc_point_t *P,
+    int (*f_rng)(void *, unsigned char *, unsigned int), void *p_rng)
+{
+    int ret;
+    unsigned char w, m_is_odd, p_eq_g, pre_len, i;
+    unsigned int d;
+    unsigned char k[COMB_MAX_D + 1];
+    ecc_point_t *T;
+    big_number_t M, mm;
+
+    big_number_init(&M);
+    big_number_init(&mm);
+
+    if (big_number_get_bit(&group->N, 0) != 1) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    w = group->nbits >= 384 ? 5 : 4;
+
+    p_eq_g = 0;
+
+    if (w > DECC_WINDOW_SIZE) {
+        w = DECC_WINDOW_SIZE;
+    }
+    if (w >= group->nbits) {
+        w = 2;
+    }
+
+    pre_len = 1U << (w - 1);
+    d = (group->nbits + w - 1) / w;
+
+    T = p_eq_g ? group->T : NULL;
+
+    if (!T) {
+        T = malloc(pre_len * sizeof(ecc_point_t));
+        if (T == NULL) {
+            ret = CRYPTO_ECODE_ERROR_NO_MEMORY;
+            goto cleanup;
+        }
+
+        for (i = 0; i < pre_len; i++) {
+            ecc_point_init(&T[i]);
+        }
+
+        D_CLEAN_IF_FAILED(ecc_precompute_comb(group, T, P, w, d));
+
+        if (p_eq_g) {
+            group->T = T;
+            group->T_size = pre_len;
+        }
+    }
+
+    m_is_odd = (big_number_get_bit(m, 0) == 1);
+    D_CLEAN_IF_FAILED(big_number_copy(&M, m));
+    D_CLEAN_IF_FAILED(big_number_sub_big_number(&mm, &group->N, m));
+    D_CLEAN_IF_FAILED(big_number_safe_cond_assign(&M, &mm, ! m_is_odd));
+
+    ecc_comb_fixed(k, d, w, &M);
+    D_CLEAN_IF_FAILED(ecc_mul_comb_core(group, R, T, pre_len, k, d, f_rng, p_rng));
+
+    D_CLEAN_IF_FAILED(ecc_safe_invert_jac(group, R, ! m_is_odd));
+    D_CLEAN_IF_FAILED(ecc_normalize_jac(group, R));
+
+cleanup:
+
+    if (T != NULL && ! p_eq_g) {
+        for (i = 0; i < pre_len; i++) {
+            ecc_point_free(&T[i]);
+        }
+        free(T);
+    }
+
+    big_number_free(&M);
+    big_number_free(&mm);
+
+    if (ret != 0) {
+        ecc_point_free(R);
+    }
+
+    return ret;
+}
+
+int ecc_mul(ecc_group_t *group, ecc_point_t *R,
+    const big_number_t *m, const ecc_point_t *P,
+    int (*f_rng)(void *, unsigned char *, unsigned int), void *p_rng)
+{
+    int ret;
+
+    if (big_number_cmp_int(&P->Z, 1) != 0) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    if ((ret = ecc_check_privkey(group, m)) != 0 ||
+        (ret = ecc_check_pubkey(group, P)) != 0) {
+        return ret;
+    }
+
+    return ecc_mul_comb(group, R, m, P, f_rng, p_rng);
+}
+
+static int ecc_check_pubkey_sw(const ecc_group_t *group, const ecc_point_t *pt)
+{
+    int ret;
+    big_number_t YY, RHS;
+
+    if (big_number_cmp_int(&pt->X, 0) < 0 ||
+        big_number_cmp_int(&pt->Y, 0) < 0 ||
+        big_number_cmp_big_number(&pt->X, &group->P) >= 0 ||
+        big_number_cmp_big_number(&pt->Y, &group->P) >= 0) {
+        return CRYPTO_ECODE_INVALID_KEY;
+    }
+
+    big_number_init(&YY);
+    big_number_init(&RHS);
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&YY, &pt->Y, &pt->Y));
+    MOD_MUL(YY);
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&RHS, &pt->X, &pt->X));
+    MOD_MUL(RHS);
+
+    if (group->A.p == NULL) {
+        D_CLEAN_IF_FAILED(big_number_sub_int(&RHS, &RHS, 3));
+        MOD_SUB(RHS);
+    } else {
+        D_CLEAN_IF_FAILED(big_number_add_big_number(&RHS, &RHS, &group->A));
+        MOD_ADD(RHS);
+    }
+
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&RHS, &RHS, &pt->X));
+    MOD_MUL(RHS);
+    D_CLEAN_IF_FAILED(big_number_add_big_number(&RHS, &RHS, &group->B));
+    MOD_ADD(RHS);
+
+    if (big_number_cmp_big_number(&YY, &RHS) != 0) {
+        ret = CRYPTO_ECODE_INVALID_KEY;
+    }
+
+cleanup:
+
+    big_number_free(&YY);
+    big_number_free(&RHS);
+
+    return ret;
+}
+
+int ecc_check_pubkey(const ecc_group_t *group, const ecc_point_t *pt)
+{
+    if (big_number_cmp_int(&pt->Z, 1) != 0) {
+        return CRYPTO_ECODE_INVALID_KEY;
+    }
+
+    return ecc_check_pubkey_sw(group, pt);
+}
+
+int ecc_check_privkey(const ecc_group_t *group, const big_number_t *d)
+{
+    if (big_number_cmp_int(d, 1) < 0 || big_number_cmp_big_number(d, &group->N) >= 0) {
+        return CRYPTO_ECODE_INVALID_KEY;
+    }
+    return 0;
+}
+
+static int ecc_gen_keypair(ecc_group_t *group, big_number_t *d, ecc_point_t *Q,
+    int (*f_rng)(void *, unsigned char *, unsigned int), void *p_rng)
+{
+    int ret;
+    unsigned int n_size = (group->nbits + 7) / 8;
+
+    int count = 0;
+    unsigned char rnd[DMAX_ECC_BYTES];
+
+    do {
+        f_rng(p_rng, rnd, n_size);
+        D_CLEAN_IF_FAILED(big_number_read_binary(d, rnd, n_size));
+        D_CLEAN_IF_FAILED(big_number_shift_r(d, 8 * n_size - group->nbits));
+
+        if (++count > 32) {
+            return CRYPTO_ECODE_RANDOM_NUMBER_GENERATION_FAILED;
+        }
+    } while (big_number_cmp_int(d, 1) < 0 ||
+        big_number_cmp_big_number(d, &group->N) >= 0);
+
+cleanup:
+    if (ret != 0) {
+        return ret;
+    }
+
+    return ecc_mul(group, Q, d, &group->G, f_rng, p_rng);
+}
+
+int ecc_gen_key(int ecc_dp, ecc_keypair_t *key,
+    int (*f_rng)(void *, unsigned char *, unsigned int), void *p_rng)
+{
+    int ret = -1;
+
+    ecc_keypair_init(key);
+    ret = ecc_setup_group(ecc_dp, &key->group);
+    if (!ret) {
+        ret = ecc_gen_keypair(&key->group, &key->d, &key->Q, f_rng, p_rng);
+        if (ret) {
+            ecc_keypair_free(key);
+        }
+    }
+
+    return ret;
+}
+
+int ecc_check_key_pair(const ecc_keypair_t *pub, const ecc_keypair_t *prv)
+{
+    int ret;
+    ecc_point_t Q;
+    ecc_group_t group;
+
+    if (pub->group.id != prv->group.id ||
+        big_number_cmp_big_number(&pub->Q.X, &prv->Q.X) ||
+        big_number_cmp_big_number(&pub->Q.Y, &prv->Q.Y) ||
+        big_number_cmp_big_number(&pub->Q.Z, &prv->Q.Z)) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    ecc_point_init(&Q);
+    ecc_group_init(&group);
+
+    ecc_setup_group(prv->group.id, &group);
+
+    D_CLEAN_IF_FAILED(ecc_mul(&group, &Q, &prv->d, &prv->group.G, NULL, NULL));
+
+    if (big_number_cmp_big_number(&Q.X, &prv->Q.X) ||
+        big_number_cmp_big_number(&Q.Y, &prv->Q.Y) ||
+        big_number_cmp_big_number(&Q.Z, &prv->Q.Z)) {
+        ret = CRYPTO_ECODE_BAD_INPUT_DATA;
+        goto cleanup;
+    }
+
+cleanup:
+    ecc_point_free(&Q);
+    ecc_group_free(&group);
+
+    return ret;
+}
+
+static int __derive_big_number(const ecc_group_t *group, big_number_t *x,
+    const unsigned char *buf, unsigned int blen)
+{
+    int ret;
+    unsigned int n_size = ( group->nbits + 7 ) / 8;
+    unsigned int use_size = blen > n_size ? n_size : blen;
+
+    D_CLEAN_IF_FAILED(big_number_read_binary( x, buf, use_size));
+    if (use_size * 8 > group->nbits) {
+        D_CLEAN_IF_FAILED(big_number_shift_r(x, use_size * 8 - group->nbits));
+    }
+
+    if (big_number_cmp_big_number(x, &group->N) >= 0) {
+        D_CLEAN_IF_FAILED(big_number_sub_big_number(x, x, &group->N));
+    }
+
+cleanup:
+    return ret;
+}
+
+void ecdsa_init(ecdsa_context_t *ctx)
+{
+    ecc_group_init(&ctx->group);
+    big_number_init(&ctx->d);
+    ecc_point_init(&ctx->Q);
+    big_number_init(&ctx->r);
+    big_number_init(&ctx->s);
+}
+
+void ecdsa_free(ecdsa_context_t *ctx)
+{
+    ecc_group_free(&ctx->group);
+    big_number_free(&ctx->d);
+    ecc_point_free(&ctx->Q);
+    big_number_free(&ctx->r);
+    big_number_free(&ctx->s);
+}
+
+int ecdsa_sign(ecc_group_t *group, big_number_t *r, big_number_t *s,
+    const big_number_t *d, const unsigned char *buf, unsigned int blen,
+    int (*f_rng)(void *, unsigned char *, unsigned int), void *p_rng)
+{
+    int ret, key_tries, sign_tries, blind_tries;
+    ecc_point_t R;
+    big_number_t k, e, t;
+
+    if (!group->N.p) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    ecc_point_init(&R);
+    big_number_init(&k);
+    big_number_init(&e);
+    big_number_init(&t);
+
+    sign_tries = 0;
+    do {
+        key_tries = 0;
+        do {
+            D_CLEAN_IF_FAILED(ecc_gen_keypair(group, &k, &R, f_rng, p_rng));
+            D_CLEAN_IF_FAILED(big_number_mod_big_number(r, &R.X, &group->N));
+
+            if (key_tries ++ > 12) {
+                ret = CRYPTO_ECODE_RANDOM_NUMBER_GENERATION_FAILED;
+                goto cleanup;
+            }
+        } while (big_number_cmp_int(r, 0) == 0);
+
+        D_CLEAN_IF_FAILED(__derive_big_number(group, &e, buf, blen));
+
+        blind_tries = 0;
+        do {
+            unsigned int n_size = (group->nbits + 7) / 8;
+            D_CLEAN_IF_FAILED(big_number_fill_random(&t, n_size, f_rng, p_rng));
+            D_CLEAN_IF_FAILED(big_number_shift_r(&t, 8 * n_size - group->nbits));
+
+            if (++blind_tries > 30) {
+                return CRYPTO_ECODE_RANDOM_NUMBER_GENERATION_FAILED;
+            }
+        } while (big_number_cmp_int(&t, 1) < 0 ||
+               big_number_cmp_big_number(&t, &group->N) >= 0);
+
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(s, r, d));
+        D_CLEAN_IF_FAILED(big_number_add_big_number(&e, &e, s));
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(&e, &e, &t));
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(&k, &k, &t));
+        D_CLEAN_IF_FAILED(big_number_inv_mod(s, &k, &group->N));
+        D_CLEAN_IF_FAILED(big_number_mul_big_number(s, s, &e));
+        D_CLEAN_IF_FAILED(big_number_mod_big_number(s, s, &group->N));
+
+        if (sign_tries++ > 10) {
+            ret = CRYPTO_ECODE_RANDOM_NUMBER_GENERATION_FAILED;
+            goto cleanup;
+        }
+    }
+    while(big_number_cmp_int(s, 0) == 0);
+
+cleanup:
+    ecc_point_free(&R);
+    big_number_free(&k);
+    big_number_free(&e);
+    big_number_free(&t);
+
+    return ret;
+}
+
+int ecdsa_verify(ecc_group_t *group,
+    const unsigned char *buf, unsigned int blen,
+    const ecc_point_t *Q, const big_number_t *r, const big_number_t *s)
+{
+    int ret;
+    big_number_t e, s_inv, u1, u2;
+    ecc_point_t R, P;
+
+    ecc_point_init(&R);
+    ecc_point_init(&P);
+    big_number_init(&e);
+    big_number_init(&s_inv);
+    big_number_init(&u1);
+    big_number_init(&u2);
+
+    if (!group->N.p) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    if (big_number_cmp_int(r, 1) < 0 || big_number_cmp_big_number(r, &group->N) >= 0 ||
+        big_number_cmp_int(s, 1) < 0 || big_number_cmp_big_number(s, &group->N) >= 0) {
+        ret = CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
+        goto cleanup;
+    }
+
+    D_CLEAN_IF_FAILED(ecc_check_pubkey(group, Q));
+    D_CLEAN_IF_FAILED(__derive_big_number(group, &e, buf, blen));
+
+    D_CLEAN_IF_FAILED(big_number_inv_mod(&s_inv, s, &group->N));
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&u1, &e, &s_inv));
+    D_CLEAN_IF_FAILED(big_number_mod_big_number(&u1, &u1, &group->N));
+    D_CLEAN_IF_FAILED(big_number_mul_big_number(&u2, r, &s_inv));
+    D_CLEAN_IF_FAILED(big_number_mod_big_number(&u2, &u2, &group->N));
+
+    D_CLEAN_IF_FAILED(ecc_mul(group, &R, &u1, &group->G, NULL, NULL));
+    D_CLEAN_IF_FAILED(ecc_mul(group, &P, &u2, Q, NULL, NULL));
+    D_CLEAN_IF_FAILED(ecc_add(group, &R, &R, &P));
+
+    if (ecc_is_zero(&R)) {
+        ret = CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
+        goto cleanup;
+    }
+
+    D_CLEAN_IF_FAILED(big_number_mod_big_number(&R.X, &R.X, &group->N));
+    if (big_number_cmp_big_number(&R.X, r) != 0) {
+        ret = CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
+        goto cleanup;
+    }
+
+cleanup:
+    ecc_point_free(&R);
+    ecc_point_free(&P);
+    big_number_free(&e);
+    big_number_free(&s_inv);
+    big_number_free(&u1);
+    big_number_free(&u2);
+
+    return ret;
+}
+
+int ecdsa_read_asn1_signature(ecdsa_context_t *ctx,
+    const unsigned char *hash, unsigned int hlen,
+    const unsigned char *sig, unsigned int slen)
+{
+    int ret;
+    unsigned char *p = (unsigned char *) sig;
+    const unsigned char *end = sig + slen;
+    unsigned int len;
+
+    //asn1 1
+    if ((ASN1_CONSTRUCTED | ASN1_SEQUENCE) != p[0]) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+    p ++;
+
+    if (0x82 == p[0]) {
+        len = (p[1] << 8) | p[2];
+        p += 3;
+    } else if (0x81 == p[0]) {
+        len = p[1];
+        p += 2;
+    } else if (128 > p[0]) {
+        len = p[0];
+        p ++;
+    } else {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    if (p + len != end) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    //asn1 r
+    if (ASN1_INTEGER != p[0]) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+    p ++;
+
+    if (0x82 == p[0]) {
+        len = (p[1] << 8) | p[2];
+        p += 3;
+    } else if (0x81 == p[0]) {
+        len = p[1];
+        p += 2;
+    } else if (128 > p[0]) {
+        len = p[0];
+        p ++;
+    } else {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    ret = big_number_read_binary(&ctx->r, (const unsigned char *) p, len);
+    if (ret) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+    p += len;
+
+    //asn1 s
+    if (ASN1_INTEGER != p[0]) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+    p ++;
+
+    if (0x82 == p[0]) {
+        len = (p[1] << 8) | p[2];
+        p += 3;
+    } else if (0x81 == p[0]) {
+        len = p[1];
+        p += 2;
+    } else if (128 > p[0]) {
+        len = p[0];
+        p ++;
+    } else {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+
+    ret = big_number_read_binary(&ctx->s, (const unsigned char *) p, len);
+    if (ret) {
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
+    }
+    p += len;
+
+    if ((ret = ecdsa_verify(&ctx->group, hash, hlen, &ctx->Q, &ctx->r, &ctx->s)) != 0) {
+        return ret;
+    }
+
+    if (p != end) {
+        return CRYPTO_ECODE_SIGNATURE_INVALID_LENGTH;
+    }
+
+    return 0;
+}
+
+int ecdsa_write_asn1_signature(ecdsa_context_t *ctx,
+    const unsigned char *hash, unsigned int hlen,
+    unsigned char *sig, unsigned int *slen,
+    int (*f_rng)(void *, unsigned char *, unsigned int),
+    void *p_rng)
+{
+    int ret = 0;
+    unsigned char r_buf[DMAX_ECC_BYTES + 4];
+    unsigned char s_buf[DMAX_ECC_BYTES + 4];
+
+    unsigned int r_len = 0;
+    unsigned int s_len = 0;
+    unsigned int r_need_zero_heading = 0;
+    unsigned int s_need_zero_heading = 0;
+    unsigned int r_lentag_len = 0;
+    unsigned int s_lentag_len = 0;
+
+    unsigned int len = 0;
+    unsigned int write_len = 0;
+
+    ret = ecdsa_sign(&ctx->group, &ctx->r, &ctx->s, &ctx->d, hash, hlen, f_rng, p_rng);
+    if (ret) {
+        DCRYPT_LOG("error: ecdsa_sign fail\n");
+        return ret;
+    }
+
+    r_len = big_number_size(&ctx->r);
+    s_len = big_number_size(&ctx->s);
+
+    if ((r_len > sizeof(r_buf)) || (s_len > sizeof(s_buf))) {
+        DCRYPT_LOG("error: r/s too long\n");
+        return CRYPTO_ECODE_INTERNAL_ERROR;
+    }
+
+    big_number_write_binary(&ctx->r, r_buf, r_len);
+    big_number_write_binary(&ctx->s, s_buf, s_len);
+
+    if (ctx->r.s && (r_buf[0] & 0x80)) {
+        r_need_zero_heading = 1;
+    }
+
+    if (ctx->s.s && (s_buf[0] & 0x80)) {
+        s_need_zero_heading = 1;
+    }
+
+    if ((r_len + r_need_zero_heading) < 128) {
+        r_lentag_len = 1;
+    } else if ((r_len + r_need_zero_heading) < 256) {
+        r_lentag_len = 2;
+    } else if ((r_len + r_need_zero_heading) < 65536) {
+        r_lentag_len = 3;
+    }
+
+    if ((s_len + s_need_zero_heading) < 128) {
+        s_lentag_len = 1;
+    } else if ((s_len + s_need_zero_heading) < 256) {
+        s_lentag_len = 2;
+    } else if ((s_len + s_need_zero_heading) < 65536) {
+        s_lentag_len = 3;
+    }
+
+    len = r_len + s_len + r_need_zero_heading + s_need_zero_heading + 1 + 1 + r_lentag_len + s_lentag_len;
+
+    write_len = 0;
+
+    //asn1 1
+    sig[write_len] = ASN1_CONSTRUCTED | ASN1_SEQUENCE;
+    write_len ++;
+
+    if (len < 128) {
+        sig[write_len] = len;
+        write_len ++;
+    } else if (len < 256) {
+        sig[write_len] = 0x81;
+        sig[write_len + 1] = len;
+        write_len += 2;
+    } else if (len < 65536) {
+        sig[write_len] = 0x82;
+        sig[write_len + 1] = (len >> 8) & 0xff;
+        sig[write_len + 2] = len & 0xff;
+        write_len += 3;
+    }
+
+    //asn1 r
+    sig[write_len] = ASN1_INTEGER;
+    write_len ++;
+
+    len = r_len + r_need_zero_heading;
+    if (1 == r_lentag_len) {
+        sig[write_len] = len;
+        write_len ++;
+    } else if (2 == r_lentag_len) {
+        sig[write_len] = 0x81;
+        sig[write_len + 1] = len;
+        write_len += 2;
+    } else if (3 == r_lentag_len) {
+        sig[write_len] = 0x82;
+        sig[write_len + 1] = (len >> 8) & 0xff;
+        sig[write_len + 2] = len & 0xff;
+        write_len += 3;
+    }
+
+    if (r_need_zero_heading) {
+        sig[write_len] = 0;
+        write_len ++;
+    }
+
+    memcpy(sig + write_len, r_buf, r_len);
+    write_len += r_len;
+
+    //asn1 s
+    sig[write_len] = ASN1_INTEGER;
+    write_len ++;
+
+    len = s_len + s_need_zero_heading;
+    if (1 == s_lentag_len) {
+        sig[write_len] = len;
+        write_len ++;
+    } else if (2 == s_lentag_len) {
+        sig[write_len] = 0x81;
+        sig[write_len + 1] = len;
+        write_len += 2;
+    } else if (3 == s_lentag_len) {
+        sig[write_len] = 0x82;
+        sig[write_len + 1] = (len >> 8) & 0xff;
+        sig[write_len + 2] = len & 0xff;
+        write_len += 3;
+    }
+
+    if (s_need_zero_heading) {
+        sig[write_len] = 0;
+        write_len ++;
+    }
+
+    memcpy(sig + write_len, s_buf, s_len);
+    write_len += s_len;
+
+    *slen = write_len;
+
+    return 0;
+}
+
diff --git a/lw_cryptography/src/pk_rsa.c b/lw_cryptography/src/pk_rsa.c
index 19ce590..0aaaff0 100644
--- a/lw_cryptography/src/pk_rsa.c
+++ b/lw_cryptography/src/pk_rsa.c
@@ -1,16 +1,34 @@
-/**
+/*******************************************************************************
  * pk_rsa.c
  *
  * History:
  *  2015/06/25 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include "cryptography_if.h"
 
@@ -23,8 +41,31 @@
 #endif
 
 #include "big_number.h"
-#include "tiny_asn1.h"
-#include "tiny_oid.h"
+
+//#define D_DUMP_FOR_DEBUG
+
+#ifdef D_DUMP_FOR_DEBUG
+void __dump_file_pk_rsa(const char *filename_base, int index, unsigned char *p, unsigned int size)
+{
+    char __filename[256] = {0};
+    snprintf(__filename, sizeof(__filename), "%s_%d.dump", filename_base, index);
+    FILE *pf = fopen(__filename, "wb+");
+    if (pf) {
+        fwrite(p, 1, size, pf);
+        fclose(pf);
+    }
+}
+#endif
+
+//OIDs
+static unsigned char gsOIDDigestSHA256[] = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01};
+//{ joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 1 }
+
+//static unsigned char gsOIDDigestSHA384[] = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02};
+//{ joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 2 }
+
+//static unsigned char gsOIDDigestSHA512[] = {0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03};
+//{ joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 3 }
 
 #define DRSA_SIGN   1
 #define DRSA_CRYPT  2
@@ -98,6 +139,10 @@ int rsa_gen_key(rsa_context_t *ctx, int (*f_rng)(void *, unsigned char *, unsign
     D_CLEAN_IF_FAILED(big_number_mod_big_number(&ctx->DQ, &ctx->D, &Q1));
     D_CLEAN_IF_FAILED(big_number_inv_mod(&ctx->QP, &ctx->Q, &ctx->P));
 
+    D_CLEAN_IF_FAILED(big_number_lset(&ctx->RN, 1));
+    D_CLEAN_IF_FAILED(big_number_shift_l(&ctx->RN, ctx->N.n * 2 * 8 * sizeof(TUINT)));
+    D_CLEAN_IF_FAILED(big_number_mod_big_number(&ctx->RN, &ctx->RN, &ctx->N));
+
     ctx->len = (big_number_msb(&ctx->N) + 7) >> 3;
 
 cleanup:
@@ -258,10 +303,6 @@ static int __rsa_private(rsa_context_t* ctx, const unsigned char* input, unsigne
     int ret;
     unsigned int olen;
     big_number_t T, T1, T2;
-    //big_number_t* Vi, * Vf;
-
-    //Vi = &ctx->Vi;
-    //Vf = &ctx->Vf;
 
     big_number_init(&T);
     big_number_init(&T1);
@@ -304,40 +345,45 @@ int rsa_sha256_sign(rsa_context_t* ctx, const unsigned char* hash, unsigned char
 {
     unsigned int nb_pad, olen, oid_size = 0;
     unsigned char *p = sig;
-    const char *oid = NULL;
 
     olen = ctx->len;
     nb_pad = olen - 3;
 
-    if (oid_get_oid_by_sha(CRYPTO_SHA_TYPE_SHA256, &oid, &oid_size) != 0) {
-        return CRYPTO_ECODE_BAD_INPUT_DATA;
-    }
+    oid_size = sizeof(gsOIDDigestSHA256);
 
     nb_pad -= 10 + oid_size;
     nb_pad -= DCRYPTO_SHA256_DIGEST_LENGTH;
 
     if (( nb_pad < 8 ) || ( nb_pad > olen )) {
-        return( CRYPTO_ECODE_BAD_INPUT_DATA );
+        return CRYPTO_ECODE_BAD_INPUT_DATA;
     }
 
     *p++ = 0;
     *p++ = DRSA_SIGN;
-    memset( p, 0xFF, nb_pad );
+    memset(p, 0xFF, nb_pad);
     p += nb_pad;
     *p++ = 0;
 
+    //ASN1 1
     *p++ = ASN1_SEQUENCE | ASN1_CONSTRUCTED;
     *p++ = (unsigned char) (0x08 + oid_size + DCRYPTO_SHA256_DIGEST_LENGTH);
+
+    //ASN1 2
     *p++ = ASN1_SEQUENCE | ASN1_CONSTRUCTED;
     *p++ = (unsigned char) (0x04 + oid_size);
+
+    //OID
     *p++ = ASN1_OID;
     *p++ = oid_size & 0xFF;
-    memcpy( p, oid, oid_size );
+    memcpy(p, gsOIDDigestSHA256, oid_size);
     p += oid_size;
+
     *p++ = ASN1_NULL;
     *p++ = 0x00;
     *p++ = ASN1_OCTET_STRING;
     *p++ = DCRYPTO_SHA256_DIGEST_LENGTH;
+
+    //digest
     memcpy(p, hash, DCRYPTO_SHA256_DIGEST_LENGTH);
 
     return __rsa_private(ctx, sig, sig);
@@ -346,11 +392,9 @@ int rsa_sha256_sign(rsa_context_t* ctx, const unsigned char* hash, unsigned char
 int rsa_sha256_verify(rsa_context_t* ctx, const unsigned char* hash, const unsigned char* sig)
 {
     int ret;
-    unsigned int len, siglen, asn1_len;
-    unsigned char *p, *end;
+    unsigned int len, siglen;
+    unsigned char *p;
     unsigned char buf[D_BIG_NUMBER_MAX_SIZE];
-    sha_type_t sha_type = CRYPTO_SHA_TYPE_SHA256;
-    asn1_buf oid;
 
     siglen = ctx->len;
 
@@ -358,8 +402,17 @@ int rsa_sha256_verify(rsa_context_t* ctx, const unsigned char* hash, const unsig
         return CRYPTO_ECODE_BAD_INPUT_DATA;
     }
 
+#ifdef D_DUMP_FOR_DEBUG
+    __dump_file_pk_rsa("input_hash", 0, (unsigned char *) hash, 32);
+    __dump_file_pk_rsa("input_sig", 0, (unsigned char *) sig, siglen);
+#endif
+
     ret = __rsa_public(ctx, sig, buf);
 
+#ifdef D_DUMP_FOR_DEBUG
+    __dump_file_pk_rsa("output_sig", 0, (unsigned char *) buf, siglen);
+#endif
+
     if (CRYPTO_ECODE_OK != ret) {
         return ret;
     }
@@ -379,59 +432,58 @@ int rsa_sha256_verify(rsa_context_t* ctx, const unsigned char* hash, const unsig
 
     p++;
     len = siglen - ( p - buf );
-    end = p + len;
 
-    if ((ret = asn1_get_tag( &p, end, &asn1_len, ASN1_CONSTRUCTED | ASN1_SEQUENCE)) != CRYPTO_ECODE_OK) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL);
+    //check ASN1 header 1
+    if ((ASN1_CONSTRUCTED | ASN1_SEQUENCE) != p[0]) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p ++;
 
-    if (asn1_len + 2 != len) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 1);
+    //check ASN1 size 1
+    if (p[0] & 0x80) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
-
-    if ((ret = asn1_get_tag( &p, end, &asn1_len, ASN1_CONSTRUCTED | ASN1_SEQUENCE)) != 0) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 2);
+    if (p[0] + 2 != len) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p ++;
 
-    if (asn1_len + 6 + DCRYPTO_SHA256_DIGEST_LENGTH != len) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 3);
+    //check ASN1 header 2
+    if ((ASN1_CONSTRUCTED | ASN1_SEQUENCE) != p[0]) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p ++;
 
-    if ((ret = asn1_get_tag( &p, end, &oid.len, ASN1_OID)) != CRYPTO_ECODE_OK) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 4);
+    //check ASN1 size 2
+    if (p[0] + 6 + DCRYPTO_SHA256_DIGEST_LENGTH != len) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p ++;
 
-    oid.p = p;
-    p += oid.len;
-
-    if (oid_get_sha_type(&oid, &sha_type) != 0) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 5);
+    //check ASN1 for OID
+    if ((ASN1_OID != p[0]) || (sizeof(gsOIDDigestSHA256) != p[1])) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p += 2;
 
-    //if (CRYPTO_SHA_TYPE_SHA256 != sha_type ) {
-    //    return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 6);
-    //}
-
-    if ((ret = asn1_get_tag(&p, end, &asn1_len, ASN1_NULL)) != CRYPTO_ECODE_OK) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 7);
+    //check OID
+    if (memcmp(gsOIDDigestSHA256, p, sizeof(gsOIDDigestSHA256))) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p += sizeof(gsOIDDigestSHA256);
 
-    if ((ret = asn1_get_tag(&p, end, &asn1_len, ASN1_OCTET_STRING)) != CRYPTO_ECODE_OK) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 8);
+    if ((p[0] != ASN1_NULL) || (0 != p[1])) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p += 2;
 
-    if (asn1_len != DCRYPTO_SHA256_DIGEST_LENGTH) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 9);
+    if ((p[0] != ASN1_OCTET_STRING) || (DCRYPTO_SHA256_DIGEST_LENGTH != p[1])) {
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
+    p += 2;
 
     if (memcmp( p, hash, DCRYPTO_SHA256_DIGEST_LENGTH) != 0) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 10);
-    }
-
-    p += DCRYPTO_SHA256_DIGEST_LENGTH;
-
-    if (p != end) {
-        return (CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL - 11);
+        return CRYPTO_ECODE_SIGNATURE_VERIFY_FAIL;
     }
 
     return CRYPTO_ECODE_OK;
diff --git a/lw_cryptography/src/precalc_aes_tables.txt b/lw_cryptography/src/precalc_aes_tables.txt
new file mode 100644
index 0000000..a65bca0
--- /dev/null
+++ b/lw_cryptography/src/precalc_aes_tables.txt
@@ -0,0 +1,590 @@
+static const unsigned char gcsForwardSBox[256] = {
+    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 
+    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 
+    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 
+    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 
+    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 
+    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 
+    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 
+    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 
+    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 
+    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 
+    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 
+    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 
+    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 
+    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 
+    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 
+    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16, 
+};
+
+
+static const unsigned char gcsReverseSBox[256] = {
+    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 
+    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 
+    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 
+    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 
+    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 
+    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 
+    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 
+    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 
+    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 
+    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 
+    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 
+    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 
+    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 
+    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 
+    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 
+    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d, 
+};
+
+
+static const unsigned int gcsForwardTable0[256] = {
+    0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6, 
+    0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591, 
+    0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56, 
+    0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec, 
+    0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa, 
+    0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb, 
+    0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45, 
+    0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b, 
+    0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c, 
+    0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83, 
+    0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9, 
+    0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a, 
+    0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d, 
+    0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f, 
+    0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df, 
+    0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea, 
+    0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34, 
+    0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b, 
+    0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d, 
+    0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413, 
+    0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1, 
+    0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6, 
+    0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972, 
+    0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85, 
+    0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed, 
+    0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511, 
+    0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe, 
+    0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b, 
+    0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05, 
+    0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1, 
+    0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142, 
+    0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf, 
+    0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3, 
+    0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e, 
+    0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a, 
+    0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6, 
+    0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3, 
+    0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b, 
+    0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428, 
+    0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad, 
+    0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14, 
+    0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8, 
+    0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4, 
+    0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2, 
+    0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda, 
+    0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949, 
+    0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf, 
+    0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810, 
+    0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c, 
+    0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697, 
+    0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e, 
+    0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f, 
+    0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc, 
+    0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c, 
+    0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969, 
+    0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27, 
+    0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122, 
+    0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433, 
+    0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9, 
+    0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5, 
+    0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a, 
+    0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0, 
+    0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e, 
+    0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c, 
+};
+
+
+static const unsigned int gcsForwardTable1[256] = {
+    0x6363c6a5, 0x7c7cf884, 0x7777ee99, 0x7b7bf68d, 
+    0xf2f2ff0d, 0x6b6bd6bd, 0x6f6fdeb1, 0xc5c59154, 
+    0x30306050, 0x01010203, 0x6767cea9, 0x2b2b567d, 
+    0xfefee719, 0xd7d7b562, 0xabab4de6, 0x7676ec9a, 
+    0xcaca8f45, 0x82821f9d, 0xc9c98940, 0x7d7dfa87, 
+    0xfafaef15, 0x5959b2eb, 0x47478ec9, 0xf0f0fb0b, 
+    0xadad41ec, 0xd4d4b367, 0xa2a25ffd, 0xafaf45ea, 
+    0x9c9c23bf, 0xa4a453f7, 0x7272e496, 0xc0c09b5b, 
+    0xb7b775c2, 0xfdfde11c, 0x93933dae, 0x26264c6a, 
+    0x36366c5a, 0x3f3f7e41, 0xf7f7f502, 0xcccc834f, 
+    0x3434685c, 0xa5a551f4, 0xe5e5d134, 0xf1f1f908, 
+    0x7171e293, 0xd8d8ab73, 0x31316253, 0x15152a3f, 
+    0x0404080c, 0xc7c79552, 0x23234665, 0xc3c39d5e, 
+    0x18183028, 0x969637a1, 0x05050a0f, 0x9a9a2fb5, 
+    0x07070e09, 0x12122436, 0x80801b9b, 0xe2e2df3d, 
+    0xebebcd26, 0x27274e69, 0xb2b27fcd, 0x7575ea9f, 
+    0x0909121b, 0x83831d9e, 0x2c2c5874, 0x1a1a342e, 
+    0x1b1b362d, 0x6e6edcb2, 0x5a5ab4ee, 0xa0a05bfb, 
+    0x5252a4f6, 0x3b3b764d, 0xd6d6b761, 0xb3b37dce, 
+    0x2929527b, 0xe3e3dd3e, 0x2f2f5e71, 0x84841397, 
+    0x5353a6f5, 0xd1d1b968, 0x00000000, 0xededc12c, 
+    0x20204060, 0xfcfce31f, 0xb1b179c8, 0x5b5bb6ed, 
+    0x6a6ad4be, 0xcbcb8d46, 0xbebe67d9, 0x3939724b, 
+    0x4a4a94de, 0x4c4c98d4, 0x5858b0e8, 0xcfcf854a, 
+    0xd0d0bb6b, 0xefefc52a, 0xaaaa4fe5, 0xfbfbed16, 
+    0x434386c5, 0x4d4d9ad7, 0x33336655, 0x85851194, 
+    0x45458acf, 0xf9f9e910, 0x02020406, 0x7f7ffe81, 
+    0x5050a0f0, 0x3c3c7844, 0x9f9f25ba, 0xa8a84be3, 
+    0x5151a2f3, 0xa3a35dfe, 0x404080c0, 0x8f8f058a, 
+    0x92923fad, 0x9d9d21bc, 0x38387048, 0xf5f5f104, 
+    0xbcbc63df, 0xb6b677c1, 0xdadaaf75, 0x21214263, 
+    0x10102030, 0xffffe51a, 0xf3f3fd0e, 0xd2d2bf6d, 
+    0xcdcd814c, 0x0c0c1814, 0x13132635, 0xececc32f, 
+    0x5f5fbee1, 0x979735a2, 0x444488cc, 0x17172e39, 
+    0xc4c49357, 0xa7a755f2, 0x7e7efc82, 0x3d3d7a47, 
+    0x6464c8ac, 0x5d5dbae7, 0x1919322b, 0x7373e695, 
+    0x6060c0a0, 0x81811998, 0x4f4f9ed1, 0xdcdca37f, 
+    0x22224466, 0x2a2a547e, 0x90903bab, 0x88880b83, 
+    0x46468cca, 0xeeeec729, 0xb8b86bd3, 0x1414283c, 
+    0xdedea779, 0x5e5ebce2, 0x0b0b161d, 0xdbdbad76, 
+    0xe0e0db3b, 0x32326456, 0x3a3a744e, 0x0a0a141e, 
+    0x494992db, 0x06060c0a, 0x2424486c, 0x5c5cb8e4, 
+    0xc2c29f5d, 0xd3d3bd6e, 0xacac43ef, 0x6262c4a6, 
+    0x919139a8, 0x959531a4, 0xe4e4d337, 0x7979f28b, 
+    0xe7e7d532, 0xc8c88b43, 0x37376e59, 0x6d6ddab7, 
+    0x8d8d018c, 0xd5d5b164, 0x4e4e9cd2, 0xa9a949e0, 
+    0x6c6cd8b4, 0x5656acfa, 0xf4f4f307, 0xeaeacf25, 
+    0x6565caaf, 0x7a7af48e, 0xaeae47e9, 0x08081018, 
+    0xbaba6fd5, 0x7878f088, 0x25254a6f, 0x2e2e5c72, 
+    0x1c1c3824, 0xa6a657f1, 0xb4b473c7, 0xc6c69751, 
+    0xe8e8cb23, 0xdddda17c, 0x7474e89c, 0x1f1f3e21, 
+    0x4b4b96dd, 0xbdbd61dc, 0x8b8b0d86, 0x8a8a0f85, 
+    0x7070e090, 0x3e3e7c42, 0xb5b571c4, 0x6666ccaa, 
+    0x484890d8, 0x03030605, 0xf6f6f701, 0x0e0e1c12, 
+    0x6161c2a3, 0x35356a5f, 0x5757aef9, 0xb9b969d0, 
+    0x86861791, 0xc1c19958, 0x1d1d3a27, 0x9e9e27b9, 
+    0xe1e1d938, 0xf8f8eb13, 0x98982bb3, 0x11112233, 
+    0x6969d2bb, 0xd9d9a970, 0x8e8e0789, 0x949433a7, 
+    0x9b9b2db6, 0x1e1e3c22, 0x87871592, 0xe9e9c920, 
+    0xcece8749, 0x5555aaff, 0x28285078, 0xdfdfa57a, 
+    0x8c8c038f, 0xa1a159f8, 0x89890980, 0x0d0d1a17, 
+    0xbfbf65da, 0xe6e6d731, 0x424284c6, 0x6868d0b8, 
+    0x414182c3, 0x999929b0, 0x2d2d5a77, 0x0f0f1e11, 
+    0xb0b07bcb, 0x5454a8fc, 0xbbbb6dd6, 0x16162c3a, 
+};
+
+
+static const unsigned int gcsForwardTable2[256] = {
+    0x63c6a563, 0x7cf8847c, 0x77ee9977, 0x7bf68d7b, 
+    0xf2ff0df2, 0x6bd6bd6b, 0x6fdeb16f, 0xc59154c5, 
+    0x30605030, 0x01020301, 0x67cea967, 0x2b567d2b, 
+    0xfee719fe, 0xd7b562d7, 0xab4de6ab, 0x76ec9a76, 
+    0xca8f45ca, 0x821f9d82, 0xc98940c9, 0x7dfa877d, 
+    0xfaef15fa, 0x59b2eb59, 0x478ec947, 0xf0fb0bf0, 
+    0xad41ecad, 0xd4b367d4, 0xa25ffda2, 0xaf45eaaf, 
+    0x9c23bf9c, 0xa453f7a4, 0x72e49672, 0xc09b5bc0, 
+    0xb775c2b7, 0xfde11cfd, 0x933dae93, 0x264c6a26, 
+    0x366c5a36, 0x3f7e413f, 0xf7f502f7, 0xcc834fcc, 
+    0x34685c34, 0xa551f4a5, 0xe5d134e5, 0xf1f908f1, 
+    0x71e29371, 0xd8ab73d8, 0x31625331, 0x152a3f15, 
+    0x04080c04, 0xc79552c7, 0x23466523, 0xc39d5ec3, 
+    0x18302818, 0x9637a196, 0x050a0f05, 0x9a2fb59a, 
+    0x070e0907, 0x12243612, 0x801b9b80, 0xe2df3de2, 
+    0xebcd26eb, 0x274e6927, 0xb27fcdb2, 0x75ea9f75, 
+    0x09121b09, 0x831d9e83, 0x2c58742c, 0x1a342e1a, 
+    0x1b362d1b, 0x6edcb26e, 0x5ab4ee5a, 0xa05bfba0, 
+    0x52a4f652, 0x3b764d3b, 0xd6b761d6, 0xb37dceb3, 
+    0x29527b29, 0xe3dd3ee3, 0x2f5e712f, 0x84139784, 
+    0x53a6f553, 0xd1b968d1, 0x00000000, 0xedc12ced, 
+    0x20406020, 0xfce31ffc, 0xb179c8b1, 0x5bb6ed5b, 
+    0x6ad4be6a, 0xcb8d46cb, 0xbe67d9be, 0x39724b39, 
+    0x4a94de4a, 0x4c98d44c, 0x58b0e858, 0xcf854acf, 
+    0xd0bb6bd0, 0xefc52aef, 0xaa4fe5aa, 0xfbed16fb, 
+    0x4386c543, 0x4d9ad74d, 0x33665533, 0x85119485, 
+    0x458acf45, 0xf9e910f9, 0x02040602, 0x7ffe817f, 
+    0x50a0f050, 0x3c78443c, 0x9f25ba9f, 0xa84be3a8, 
+    0x51a2f351, 0xa35dfea3, 0x4080c040, 0x8f058a8f, 
+    0x923fad92, 0x9d21bc9d, 0x38704838, 0xf5f104f5, 
+    0xbc63dfbc, 0xb677c1b6, 0xdaaf75da, 0x21426321, 
+    0x10203010, 0xffe51aff, 0xf3fd0ef3, 0xd2bf6dd2, 
+    0xcd814ccd, 0x0c18140c, 0x13263513, 0xecc32fec, 
+    0x5fbee15f, 0x9735a297, 0x4488cc44, 0x172e3917, 
+    0xc49357c4, 0xa755f2a7, 0x7efc827e, 0x3d7a473d, 
+    0x64c8ac64, 0x5dbae75d, 0x19322b19, 0x73e69573, 
+    0x60c0a060, 0x81199881, 0x4f9ed14f, 0xdca37fdc, 
+    0x22446622, 0x2a547e2a, 0x903bab90, 0x880b8388, 
+    0x468cca46, 0xeec729ee, 0xb86bd3b8, 0x14283c14, 
+    0xdea779de, 0x5ebce25e, 0x0b161d0b, 0xdbad76db, 
+    0xe0db3be0, 0x32645632, 0x3a744e3a, 0x0a141e0a, 
+    0x4992db49, 0x060c0a06, 0x24486c24, 0x5cb8e45c, 
+    0xc29f5dc2, 0xd3bd6ed3, 0xac43efac, 0x62c4a662, 
+    0x9139a891, 0x9531a495, 0xe4d337e4, 0x79f28b79, 
+    0xe7d532e7, 0xc88b43c8, 0x376e5937, 0x6ddab76d, 
+    0x8d018c8d, 0xd5b164d5, 0x4e9cd24e, 0xa949e0a9, 
+    0x6cd8b46c, 0x56acfa56, 0xf4f307f4, 0xeacf25ea, 
+    0x65caaf65, 0x7af48e7a, 0xae47e9ae, 0x08101808, 
+    0xba6fd5ba, 0x78f08878, 0x254a6f25, 0x2e5c722e, 
+    0x1c38241c, 0xa657f1a6, 0xb473c7b4, 0xc69751c6, 
+    0xe8cb23e8, 0xdda17cdd, 0x74e89c74, 0x1f3e211f, 
+    0x4b96dd4b, 0xbd61dcbd, 0x8b0d868b, 0x8a0f858a, 
+    0x70e09070, 0x3e7c423e, 0xb571c4b5, 0x66ccaa66, 
+    0x4890d848, 0x03060503, 0xf6f701f6, 0x0e1c120e, 
+    0x61c2a361, 0x356a5f35, 0x57aef957, 0xb969d0b9, 
+    0x86179186, 0xc19958c1, 0x1d3a271d, 0x9e27b99e, 
+    0xe1d938e1, 0xf8eb13f8, 0x982bb398, 0x11223311, 
+    0x69d2bb69, 0xd9a970d9, 0x8e07898e, 0x9433a794, 
+    0x9b2db69b, 0x1e3c221e, 0x87159287, 0xe9c920e9, 
+    0xce8749ce, 0x55aaff55, 0x28507828, 0xdfa57adf, 
+    0x8c038f8c, 0xa159f8a1, 0x89098089, 0x0d1a170d, 
+    0xbf65dabf, 0xe6d731e6, 0x4284c642, 0x68d0b868, 
+    0x4182c341, 0x9929b099, 0x2d5a772d, 0x0f1e110f, 
+    0xb07bcbb0, 0x54a8fc54, 0xbb6dd6bb, 0x162c3a16, 
+};
+
+
+static const unsigned int gcsForwardTable3[256] = {
+    0xc6a56363, 0xf8847c7c, 0xee997777, 0xf68d7b7b, 
+    0xff0df2f2, 0xd6bd6b6b, 0xdeb16f6f, 0x9154c5c5, 
+    0x60503030, 0x02030101, 0xcea96767, 0x567d2b2b, 
+    0xe719fefe, 0xb562d7d7, 0x4de6abab, 0xec9a7676, 
+    0x8f45caca, 0x1f9d8282, 0x8940c9c9, 0xfa877d7d, 
+    0xef15fafa, 0xb2eb5959, 0x8ec94747, 0xfb0bf0f0, 
+    0x41ecadad, 0xb367d4d4, 0x5ffda2a2, 0x45eaafaf, 
+    0x23bf9c9c, 0x53f7a4a4, 0xe4967272, 0x9b5bc0c0, 
+    0x75c2b7b7, 0xe11cfdfd, 0x3dae9393, 0x4c6a2626, 
+    0x6c5a3636, 0x7e413f3f, 0xf502f7f7, 0x834fcccc, 
+    0x685c3434, 0x51f4a5a5, 0xd134e5e5, 0xf908f1f1, 
+    0xe2937171, 0xab73d8d8, 0x62533131, 0x2a3f1515, 
+    0x080c0404, 0x9552c7c7, 0x46652323, 0x9d5ec3c3, 
+    0x30281818, 0x37a19696, 0x0a0f0505, 0x2fb59a9a, 
+    0x0e090707, 0x24361212, 0x1b9b8080, 0xdf3de2e2, 
+    0xcd26ebeb, 0x4e692727, 0x7fcdb2b2, 0xea9f7575, 
+    0x121b0909, 0x1d9e8383, 0x58742c2c, 0x342e1a1a, 
+    0x362d1b1b, 0xdcb26e6e, 0xb4ee5a5a, 0x5bfba0a0, 
+    0xa4f65252, 0x764d3b3b, 0xb761d6d6, 0x7dceb3b3, 
+    0x527b2929, 0xdd3ee3e3, 0x5e712f2f, 0x13978484, 
+    0xa6f55353, 0xb968d1d1, 0x00000000, 0xc12ceded, 
+    0x40602020, 0xe31ffcfc, 0x79c8b1b1, 0xb6ed5b5b, 
+    0xd4be6a6a, 0x8d46cbcb, 0x67d9bebe, 0x724b3939, 
+    0x94de4a4a, 0x98d44c4c, 0xb0e85858, 0x854acfcf, 
+    0xbb6bd0d0, 0xc52aefef, 0x4fe5aaaa, 0xed16fbfb, 
+    0x86c54343, 0x9ad74d4d, 0x66553333, 0x11948585, 
+    0x8acf4545, 0xe910f9f9, 0x04060202, 0xfe817f7f, 
+    0xa0f05050, 0x78443c3c, 0x25ba9f9f, 0x4be3a8a8, 
+    0xa2f35151, 0x5dfea3a3, 0x80c04040, 0x058a8f8f, 
+    0x3fad9292, 0x21bc9d9d, 0x70483838, 0xf104f5f5, 
+    0x63dfbcbc, 0x77c1b6b6, 0xaf75dada, 0x42632121, 
+    0x20301010, 0xe51affff, 0xfd0ef3f3, 0xbf6dd2d2, 
+    0x814ccdcd, 0x18140c0c, 0x26351313, 0xc32fecec, 
+    0xbee15f5f, 0x35a29797, 0x88cc4444, 0x2e391717, 
+    0x9357c4c4, 0x55f2a7a7, 0xfc827e7e, 0x7a473d3d, 
+    0xc8ac6464, 0xbae75d5d, 0x322b1919, 0xe6957373, 
+    0xc0a06060, 0x19988181, 0x9ed14f4f, 0xa37fdcdc, 
+    0x44662222, 0x547e2a2a, 0x3bab9090, 0x0b838888, 
+    0x8cca4646, 0xc729eeee, 0x6bd3b8b8, 0x283c1414, 
+    0xa779dede, 0xbce25e5e, 0x161d0b0b, 0xad76dbdb, 
+    0xdb3be0e0, 0x64563232, 0x744e3a3a, 0x141e0a0a, 
+    0x92db4949, 0x0c0a0606, 0x486c2424, 0xb8e45c5c, 
+    0x9f5dc2c2, 0xbd6ed3d3, 0x43efacac, 0xc4a66262, 
+    0x39a89191, 0x31a49595, 0xd337e4e4, 0xf28b7979, 
+    0xd532e7e7, 0x8b43c8c8, 0x6e593737, 0xdab76d6d, 
+    0x018c8d8d, 0xb164d5d5, 0x9cd24e4e, 0x49e0a9a9, 
+    0xd8b46c6c, 0xacfa5656, 0xf307f4f4, 0xcf25eaea, 
+    0xcaaf6565, 0xf48e7a7a, 0x47e9aeae, 0x10180808, 
+    0x6fd5baba, 0xf0887878, 0x4a6f2525, 0x5c722e2e, 
+    0x38241c1c, 0x57f1a6a6, 0x73c7b4b4, 0x9751c6c6, 
+    0xcb23e8e8, 0xa17cdddd, 0xe89c7474, 0x3e211f1f, 
+    0x96dd4b4b, 0x61dcbdbd, 0x0d868b8b, 0x0f858a8a, 
+    0xe0907070, 0x7c423e3e, 0x71c4b5b5, 0xccaa6666, 
+    0x90d84848, 0x06050303, 0xf701f6f6, 0x1c120e0e, 
+    0xc2a36161, 0x6a5f3535, 0xaef95757, 0x69d0b9b9, 
+    0x17918686, 0x9958c1c1, 0x3a271d1d, 0x27b99e9e, 
+    0xd938e1e1, 0xeb13f8f8, 0x2bb39898, 0x22331111, 
+    0xd2bb6969, 0xa970d9d9, 0x07898e8e, 0x33a79494, 
+    0x2db69b9b, 0x3c221e1e, 0x15928787, 0xc920e9e9, 
+    0x8749cece, 0xaaff5555, 0x50782828, 0xa57adfdf, 
+    0x038f8c8c, 0x59f8a1a1, 0x09808989, 0x1a170d0d, 
+    0x65dabfbf, 0xd731e6e6, 0x84c64242, 0xd0b86868, 
+    0x82c34141, 0x29b09999, 0x5a772d2d, 0x1e110f0f, 
+    0x7bcbb0b0, 0xa8fc5454, 0x6dd6bbbb, 0x2c3a1616, 
+};
+
+
+static const unsigned int gcsReverseTable0[256] = {
+    0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a, 
+    0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b, 
+    0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5, 
+    0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5, 
+    0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d, 
+    0x02752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b, 
+    0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295, 
+    0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e, 
+    0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927, 
+    0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d, 
+    0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362, 
+    0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9, 
+    0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52, 
+    0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566, 
+    0x0728ebb2, 0x03c2b52f, 0x9a7bc586, 0xa50837d3, 
+    0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed, 
+    0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e, 
+    0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4, 
+    0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4, 
+    0x39ec830b, 0xaaef6040, 0x069f715e, 0x51106ebd, 
+    0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d, 
+    0xb58d5491, 0x055dc471, 0x6fd40604, 0xff155060, 
+    0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967, 
+    0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879, 
+    0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x00000000, 
+    0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c, 
+    0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36, 
+    0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624, 
+    0xb1670a0c, 0x0fe75793, 0xd296eeb4, 0x9e919b1b, 
+    0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c, 
+    0x0aba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12, 
+    0x0b0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14, 
+    0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3, 
+    0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b, 
+    0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8, 
+    0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684, 
+    0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7, 
+    0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177, 
+    0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947, 
+    0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322, 
+    0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498, 
+    0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f, 
+    0xe49d3a2c, 0x0d927850, 0x9bcc5f6a, 0x62467e54, 
+    0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382, 
+    0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf, 
+    0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb, 
+    0x097826cd, 0xf418596e, 0x01b79aec, 0xa89a4f83, 
+    0x656e95e6, 0x7ee6ffaa, 0x08cfbc21, 0xe6e815ef, 
+    0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029, 
+    0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235, 
+    0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733, 
+    0x4a9804f1, 0xf7daec41, 0x0e50cd7f, 0x2ff69117, 
+    0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4, 
+    0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546, 
+    0x04ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb, 
+    0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d, 
+    0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb, 
+    0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a, 
+    0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773, 
+    0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478, 
+    0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2, 
+    0x72c31d16, 0x0c25e2bc, 0x8b493c28, 0x41950dff, 
+    0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664, 
+    0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0, 
+};
+
+
+static const unsigned int gcsReverseTable1[256] = {
+    0xa7f45150, 0x65417e53, 0xa4171ac3, 0x5e273a96, 
+    0x6bab3bcb, 0x459d1ff1, 0x58faacab, 0x03e34b93, 
+    0xfa302055, 0x6d76adf6, 0x76cc8891, 0x4c02f525, 
+    0xd7e54ffc, 0xcb2ac5d7, 0x44352680, 0xa362b58f, 
+    0x5ab1de49, 0x1bba2567, 0x0eea4598, 0xc0fe5de1, 
+    0x752fc302, 0xf04c8112, 0x97468da3, 0xf9d36bc6, 
+    0x5f8f03e7, 0x9c921595, 0x7a6dbfeb, 0x595295da, 
+    0x83bed42d, 0x217458d3, 0x69e04929, 0xc8c98e44, 
+    0x89c2756a, 0x798ef478, 0x3e58996b, 0x71b927dd, 
+    0x4fe1beb6, 0xad88f017, 0xac20c966, 0x3ace7db4, 
+    0x4adf6318, 0x311ae582, 0x33519760, 0x7f536245, 
+    0x7764b1e0, 0xae6bbb84, 0xa081fe1c, 0x2b08f994, 
+    0x68487058, 0xfd458f19, 0x6cde9487, 0xf87b52b7, 
+    0xd373ab23, 0x024b72e2, 0x8f1fe357, 0xab55662a, 
+    0x28ebb207, 0xc2b52f03, 0x7bc5869a, 0x0837d3a5, 
+    0x872830f2, 0xa5bf23b2, 0x6a0302ba, 0x8216ed5c, 
+    0x1ccf8a2b, 0xb479a792, 0xf207f3f0, 0xe2694ea1, 
+    0xf4da65cd, 0xbe0506d5, 0x6234d11f, 0xfea6c48a, 
+    0x532e349d, 0x55f3a2a0, 0xe18a0532, 0xebf6a475, 
+    0xec830b39, 0xef6040aa, 0x9f715e06, 0x106ebd51, 
+    0x8a213ef9, 0x06dd963d, 0x053eddae, 0xbde64d46, 
+    0x8d5491b5, 0x5dc47105, 0xd406046f, 0x155060ff, 
+    0xfb981924, 0xe9bdd697, 0x434089cc, 0x9ed96777, 
+    0x42e8b0bd, 0x8b890788, 0x5b19e738, 0xeec879db, 
+    0x0a7ca147, 0x0f427ce9, 0x1e84f8c9, 0x00000000, 
+    0x86800983, 0xed2b3248, 0x70111eac, 0x725a6c4e, 
+    0xff0efdfb, 0x38850f56, 0xd5ae3d1e, 0x392d3627, 
+    0xd90f0a64, 0xa65c6821, 0x545b9bd1, 0x2e36243a, 
+    0x670a0cb1, 0xe757930f, 0x96eeb4d2, 0x919b1b9e, 
+    0xc5c0804f, 0x20dc61a2, 0x4b775a69, 0x1a121c16, 
+    0xba93e20a, 0x2aa0c0e5, 0xe0223c43, 0x171b121d, 
+    0x0d090e0b, 0xc78bf2ad, 0xa8b62db9, 0xa91e14c8, 
+    0x19f15785, 0x0775af4c, 0xdd99eebb, 0x607fa3fd, 
+    0x2601f79f, 0xf5725cbc, 0x3b6644c5, 0x7efb5b34, 
+    0x29438b76, 0xc623cbdc, 0xfcedb668, 0xf1e4b863, 
+    0xdc31d7ca, 0x85634210, 0x22971340, 0x11c68420, 
+    0x244a857d, 0x3dbbd2f8, 0x32f9ae11, 0xa129c76d, 
+    0x2f9e1d4b, 0x30b2dcf3, 0x52860dec, 0xe3c177d0, 
+    0x16b32b6c, 0xb970a999, 0x489411fa, 0x64e94722, 
+    0x8cfca8c4, 0x3ff0a01a, 0x2c7d56d8, 0x903322ef, 
+    0x4e4987c7, 0xd138d9c1, 0xa2ca8cfe, 0x0bd49836, 
+    0x81f5a6cf, 0xde7aa528, 0x8eb7da26, 0xbfad3fa4, 
+    0x9d3a2ce4, 0x9278500d, 0xcc5f6a9b, 0x467e5462, 
+    0x138df6c2, 0xb8d890e8, 0xf7392e5e, 0xafc382f5, 
+    0x805d9fbe, 0x93d0697c, 0x2dd56fa9, 0x1225cfb3, 
+    0x99acc83b, 0x7d1810a7, 0x639ce86e, 0xbb3bdb7b, 
+    0x7826cd09, 0x18596ef4, 0xb79aec01, 0x9a4f83a8, 
+    0x6e95e665, 0xe6ffaa7e, 0xcfbc2108, 0xe815efe6, 
+    0x9be7bad9, 0x366f4ace, 0x099fead4, 0x7cb029d6, 
+    0xb2a431af, 0x233f2a31, 0x94a5c630, 0x66a235c0, 
+    0xbc4e7437, 0xca82fca6, 0xd090e0b0, 0xd8a73315, 
+    0x9804f14a, 0xdaec41f7, 0x50cd7f0e, 0xf691172f, 
+    0xd64d768d, 0xb0ef434d, 0x4daacc54, 0x0496e4df, 
+    0xb5d19ee3, 0x886a4c1b, 0x1f2cc1b8, 0x5165467f, 
+    0xea5e9d04, 0x358c015d, 0x7487fa73, 0x410bfb2e, 
+    0x1d67b35a, 0xd2db9252, 0x5610e933, 0x47d66d13, 
+    0x61d79a8c, 0x0ca1377a, 0x14f8598e, 0x3c13eb89, 
+    0x27a9ceee, 0xc961b735, 0xe51ce1ed, 0xb1477a3c, 
+    0xdfd29c59, 0x73f2553f, 0xce141879, 0x37c773bf, 
+    0xcdf753ea, 0xaafd5f5b, 0x6f3ddf14, 0xdb447886, 
+    0xf3afca81, 0xc468b93e, 0x3424382c, 0x40a3c25f, 
+    0xc31d1672, 0x25e2bc0c, 0x493c288b, 0x950dff41, 
+    0x01a83971, 0xb30c08de, 0xe4b4d89c, 0xc1566490, 
+    0x84cb7b61, 0xb632d570, 0x5c6c4874, 0x57b8d042, 
+};
+
+
+static const unsigned int gcsReverseTable2[256] = {
+    0xf45150a7, 0x417e5365, 0x171ac3a4, 0x273a965e, 
+    0xab3bcb6b, 0x9d1ff145, 0xfaacab58, 0xe34b9303, 
+    0x302055fa, 0x76adf66d, 0xcc889176, 0x02f5254c, 
+    0xe54ffcd7, 0x2ac5d7cb, 0x35268044, 0x62b58fa3, 
+    0xb1de495a, 0xba25671b, 0xea45980e, 0xfe5de1c0, 
+    0x2fc30275, 0x4c8112f0, 0x468da397, 0xd36bc6f9, 
+    0x8f03e75f, 0x9215959c, 0x6dbfeb7a, 0x5295da59, 
+    0xbed42d83, 0x7458d321, 0xe0492969, 0xc98e44c8, 
+    0xc2756a89, 0x8ef47879, 0x58996b3e, 0xb927dd71, 
+    0xe1beb64f, 0x88f017ad, 0x20c966ac, 0xce7db43a, 
+    0xdf63184a, 0x1ae58231, 0x51976033, 0x5362457f, 
+    0x64b1e077, 0x6bbb84ae, 0x81fe1ca0, 0x08f9942b, 
+    0x48705868, 0x458f19fd, 0xde94876c, 0x7b52b7f8, 
+    0x73ab23d3, 0x4b72e202, 0x1fe3578f, 0x55662aab, 
+    0xebb20728, 0xb52f03c2, 0xc5869a7b, 0x37d3a508, 
+    0x2830f287, 0xbf23b2a5, 0x0302ba6a, 0x16ed5c82, 
+    0xcf8a2b1c, 0x79a792b4, 0x07f3f0f2, 0x694ea1e2, 
+    0xda65cdf4, 0x0506d5be, 0x34d11f62, 0xa6c48afe, 
+    0x2e349d53, 0xf3a2a055, 0x8a0532e1, 0xf6a475eb, 
+    0x830b39ec, 0x6040aaef, 0x715e069f, 0x6ebd5110, 
+    0x213ef98a, 0xdd963d06, 0x3eddae05, 0xe64d46bd, 
+    0x5491b58d, 0xc471055d, 0x06046fd4, 0x5060ff15, 
+    0x981924fb, 0xbdd697e9, 0x4089cc43, 0xd967779e, 
+    0xe8b0bd42, 0x8907888b, 0x19e7385b, 0xc879dbee, 
+    0x7ca1470a, 0x427ce90f, 0x84f8c91e, 0x00000000, 
+    0x80098386, 0x2b3248ed, 0x111eac70, 0x5a6c4e72, 
+    0x0efdfbff, 0x850f5638, 0xae3d1ed5, 0x2d362739, 
+    0x0f0a64d9, 0x5c6821a6, 0x5b9bd154, 0x36243a2e, 
+    0x0a0cb167, 0x57930fe7, 0xeeb4d296, 0x9b1b9e91, 
+    0xc0804fc5, 0xdc61a220, 0x775a694b, 0x121c161a, 
+    0x93e20aba, 0xa0c0e52a, 0x223c43e0, 0x1b121d17, 
+    0x090e0b0d, 0x8bf2adc7, 0xb62db9a8, 0x1e14c8a9, 
+    0xf1578519, 0x75af4c07, 0x99eebbdd, 0x7fa3fd60, 
+    0x01f79f26, 0x725cbcf5, 0x6644c53b, 0xfb5b347e, 
+    0x438b7629, 0x23cbdcc6, 0xedb668fc, 0xe4b863f1, 
+    0x31d7cadc, 0x63421085, 0x97134022, 0xc6842011, 
+    0x4a857d24, 0xbbd2f83d, 0xf9ae1132, 0x29c76da1, 
+    0x9e1d4b2f, 0xb2dcf330, 0x860dec52, 0xc177d0e3, 
+    0xb32b6c16, 0x70a999b9, 0x9411fa48, 0xe9472264, 
+    0xfca8c48c, 0xf0a01a3f, 0x7d56d82c, 0x3322ef90, 
+    0x4987c74e, 0x38d9c1d1, 0xca8cfea2, 0xd498360b, 
+    0xf5a6cf81, 0x7aa528de, 0xb7da268e, 0xad3fa4bf, 
+    0x3a2ce49d, 0x78500d92, 0x5f6a9bcc, 0x7e546246, 
+    0x8df6c213, 0xd890e8b8, 0x392e5ef7, 0xc382f5af, 
+    0x5d9fbe80, 0xd0697c93, 0xd56fa92d, 0x25cfb312, 
+    0xacc83b99, 0x1810a77d, 0x9ce86e63, 0x3bdb7bbb, 
+    0x26cd0978, 0x596ef418, 0x9aec01b7, 0x4f83a89a, 
+    0x95e6656e, 0xffaa7ee6, 0xbc2108cf, 0x15efe6e8, 
+    0xe7bad99b, 0x6f4ace36, 0x9fead409, 0xb029d67c, 
+    0xa431afb2, 0x3f2a3123, 0xa5c63094, 0xa235c066, 
+    0x4e7437bc, 0x82fca6ca, 0x90e0b0d0, 0xa73315d8, 
+    0x04f14a98, 0xec41f7da, 0xcd7f0e50, 0x91172ff6, 
+    0x4d768dd6, 0xef434db0, 0xaacc544d, 0x96e4df04, 
+    0xd19ee3b5, 0x6a4c1b88, 0x2cc1b81f, 0x65467f51, 
+    0x5e9d04ea, 0x8c015d35, 0x87fa7374, 0x0bfb2e41, 
+    0x67b35a1d, 0xdb9252d2, 0x10e93356, 0xd66d1347, 
+    0xd79a8c61, 0xa1377a0c, 0xf8598e14, 0x13eb893c, 
+    0xa9ceee27, 0x61b735c9, 0x1ce1ede5, 0x477a3cb1, 
+    0xd29c59df, 0xf2553f73, 0x141879ce, 0xc773bf37, 
+    0xf753eacd, 0xfd5f5baa, 0x3ddf146f, 0x447886db, 
+    0xafca81f3, 0x68b93ec4, 0x24382c34, 0xa3c25f40, 
+    0x1d1672c3, 0xe2bc0c25, 0x3c288b49, 0x0dff4195, 
+    0xa8397101, 0x0c08deb3, 0xb4d89ce4, 0x566490c1, 
+    0xcb7b6184, 0x32d570b6, 0x6c48745c, 0xb8d04257, 
+};
+
+
+static const unsigned int gcsReverseTable3[256] = {
+    0x5150a7f4, 0x7e536541, 0x1ac3a417, 0x3a965e27, 
+    0x3bcb6bab, 0x1ff1459d, 0xacab58fa, 0x4b9303e3, 
+    0x2055fa30, 0xadf66d76, 0x889176cc, 0xf5254c02, 
+    0x4ffcd7e5, 0xc5d7cb2a, 0x26804435, 0xb58fa362, 
+    0xde495ab1, 0x25671bba, 0x45980eea, 0x5de1c0fe, 
+    0xc302752f, 0x8112f04c, 0x8da39746, 0x6bc6f9d3, 
+    0x03e75f8f, 0x15959c92, 0xbfeb7a6d, 0x95da5952, 
+    0xd42d83be, 0x58d32174, 0x492969e0, 0x8e44c8c9, 
+    0x756a89c2, 0xf478798e, 0x996b3e58, 0x27dd71b9, 
+    0xbeb64fe1, 0xf017ad88, 0xc966ac20, 0x7db43ace, 
+    0x63184adf, 0xe582311a, 0x97603351, 0x62457f53, 
+    0xb1e07764, 0xbb84ae6b, 0xfe1ca081, 0xf9942b08, 
+    0x70586848, 0x8f19fd45, 0x94876cde, 0x52b7f87b, 
+    0xab23d373, 0x72e2024b, 0xe3578f1f, 0x662aab55, 
+    0xb20728eb, 0x2f03c2b5, 0x869a7bc5, 0xd3a50837, 
+    0x30f28728, 0x23b2a5bf, 0x02ba6a03, 0xed5c8216, 
+    0x8a2b1ccf, 0xa792b479, 0xf3f0f207, 0x4ea1e269, 
+    0x65cdf4da, 0x06d5be05, 0xd11f6234, 0xc48afea6, 
+    0x349d532e, 0xa2a055f3, 0x0532e18a, 0xa475ebf6, 
+    0x0b39ec83, 0x40aaef60, 0x5e069f71, 0xbd51106e, 
+    0x3ef98a21, 0x963d06dd, 0xddae053e, 0x4d46bde6, 
+    0x91b58d54, 0x71055dc4, 0x046fd406, 0x60ff1550, 
+    0x1924fb98, 0xd697e9bd, 0x89cc4340, 0x67779ed9, 
+    0xb0bd42e8, 0x07888b89, 0xe7385b19, 0x79dbeec8, 
+    0xa1470a7c, 0x7ce90f42, 0xf8c91e84, 0x00000000, 
+    0x09838680, 0x3248ed2b, 0x1eac7011, 0x6c4e725a, 
+    0xfdfbff0e, 0x0f563885, 0x3d1ed5ae, 0x3627392d, 
+    0x0a64d90f, 0x6821a65c, 0x9bd1545b, 0x243a2e36, 
+    0x0cb1670a, 0x930fe757, 0xb4d296ee, 0x1b9e919b, 
+    0x804fc5c0, 0x61a220dc, 0x5a694b77, 0x1c161a12, 
+    0xe20aba93, 0xc0e52aa0, 0x3c43e022, 0x121d171b, 
+    0x0e0b0d09, 0xf2adc78b, 0x2db9a8b6, 0x14c8a91e, 
+    0x578519f1, 0xaf4c0775, 0xeebbdd99, 0xa3fd607f, 
+    0xf79f2601, 0x5cbcf572, 0x44c53b66, 0x5b347efb, 
+    0x8b762943, 0xcbdcc623, 0xb668fced, 0xb863f1e4, 
+    0xd7cadc31, 0x42108563, 0x13402297, 0x842011c6, 
+    0x857d244a, 0xd2f83dbb, 0xae1132f9, 0xc76da129, 
+    0x1d4b2f9e, 0xdcf330b2, 0x0dec5286, 0x77d0e3c1, 
+    0x2b6c16b3, 0xa999b970, 0x11fa4894, 0x472264e9, 
+    0xa8c48cfc, 0xa01a3ff0, 0x56d82c7d, 0x22ef9033, 
+    0x87c74e49, 0xd9c1d138, 0x8cfea2ca, 0x98360bd4, 
+    0xa6cf81f5, 0xa528de7a, 0xda268eb7, 0x3fa4bfad, 
+    0x2ce49d3a, 0x500d9278, 0x6a9bcc5f, 0x5462467e, 
+    0xf6c2138d, 0x90e8b8d8, 0x2e5ef739, 0x82f5afc3, 
+    0x9fbe805d, 0x697c93d0, 0x6fa92dd5, 0xcfb31225, 
+    0xc83b99ac, 0x10a77d18, 0xe86e639c, 0xdb7bbb3b, 
+    0xcd097826, 0x6ef41859, 0xec01b79a, 0x83a89a4f, 
+    0xe6656e95, 0xaa7ee6ff, 0x2108cfbc, 0xefe6e815, 
+    0xbad99be7, 0x4ace366f, 0xead4099f, 0x29d67cb0, 
+    0x31afb2a4, 0x2a31233f, 0xc63094a5, 0x35c066a2, 
+    0x7437bc4e, 0xfca6ca82, 0xe0b0d090, 0x3315d8a7, 
+    0xf14a9804, 0x41f7daec, 0x7f0e50cd, 0x172ff691, 
+    0x768dd64d, 0x434db0ef, 0xcc544daa, 0xe4df0496, 
+    0x9ee3b5d1, 0x4c1b886a, 0xc1b81f2c, 0x467f5165, 
+    0x9d04ea5e, 0x015d358c, 0xfa737487, 0xfb2e410b, 
+    0xb35a1d67, 0x9252d2db, 0xe9335610, 0x6d1347d6, 
+    0x9a8c61d7, 0x377a0ca1, 0x598e14f8, 0xeb893c13, 
+    0xceee27a9, 0xb735c961, 0xe1ede51c, 0x7a3cb147, 
+    0x9c59dfd2, 0x553f73f2, 0x1879ce14, 0x73bf37c7, 
+    0x53eacdf7, 0x5f5baafd, 0xdf146f3d, 0x7886db44, 
+    0xca81f3af, 0xb93ec468, 0x382c3424, 0xc25f40a3, 
+    0x1672c31d, 0xbc0c25e2, 0x288b493c, 0xff41950d, 
+    0x397101a8, 0x08deb30c, 0xd89ce4b4, 0x6490c156, 
+    0x7b6184cb, 0xd570b632, 0x48745c6c, 0xd04257b8, 
+};
+
+
+static const unsigned int gcsRoundConstant[10] = {
+    0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 
+    0x00000020, 0x00000040, 0x00000080, 0x0000001b, 0x00000036, 
+};
+
+
diff --git a/lw_cryptography/unit_test/ecc_genkey.c b/lw_cryptography/unit_test/ecc_genkey.c
new file mode 100644
index 0000000..5fb41d1
--- /dev/null
+++ b/lw_cryptography/unit_test/ecc_genkey.c
@@ -0,0 +1,149 @@
+/*******************************************************************************
+ * ecc_genkey.c
+ *
+ * History:
+ *  2017/03/30 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+
+#if defined (_WIN32) || defined(_WIN64)
+#include <time.h>
+#include <windows.h>
+#else
+#include <sys/time.h>
+#endif
+
+#include "cryptography_if.h"
+
+static int __random_generator(void* context, unsigned char* output, unsigned int output_len)
+{
+    static unsigned char seed4 = 29, seed3 = 43, seed2 = 17, seed1 = 97;
+    //unsigned char digest[32] = {0};
+    //unsigned int i = 0 , len0 = 0;
+
+#if defined (_WIN32) || defined(_WIN64)
+    SYSTEMTIME wtm;
+    GetLocalTime(&wtm);
+    memcpy(output, &wtm, sizeof(wtm));
+#else
+    struct timeval tt;
+    gettimeofday(&tt, NULL);
+    memcpy(output, &tt, sizeof(tt));
+#endif
+
+#if 0
+    if (32 > output_len) {
+        len0 = output_len;
+    } else {
+        len0 = 32;
+    }
+#endif
+
+    output[0] = output[1] ^ seed1;
+    output[1] = output[2] ^ seed2;
+    output[2] = output[3] ^ seed3;
+    output[3] = output[0] ^ seed4;
+
+    pseudo_random_scamble_sequence(output, output_len);
+#if 0
+    digest_sha256(output, output_len, digest);
+    for (i = 0; i < len0; i ++) {
+        output[i] = output[i] ^ digest[i];
+    }
+
+    pseudo_random_scamble_sequence(output, output_len);
+    digest_sha256(output, output_len, digest);
+    for (i = 0; i < len0; i ++) {
+        output[i] = output[i] ^ digest[i];
+    }
+#endif
+    seed1 += 163;
+    seed2 += 59;
+    seed3 += 101;
+    seed4 += 23;
+
+    return 0;
+}
+
+int main()
+{
+    int ret;
+    ecc_keypair_t key_pair;
+    FILE *fpub  = NULL;
+    FILE *fpriv = NULL;
+
+    ret = ecc_gen_key(CRYPTO_ECC_DP_SECP192R1, &key_pair, __random_generator, NULL);
+
+    if ((fpub = fopen( "ecc_pub.txt", "wb+")) == NULL) {
+        printf("cannot open ecc_pub.txt\n");
+        ret = 1;
+        goto exit;
+    }
+
+    if ((ret = big_number_write_file("X = ", &key_pair.Q.X, 16, fpub)) != 0 ||
+        (ret = big_number_write_file("Y = ", &key_pair.Q.Y, 16, fpub)) != 0 ||
+        (ret = big_number_write_file("Z = ", &key_pair.Q.Z, 16, fpub)) != 0) {
+        printf("big_number_write_file fail, ret %d\n", ret);
+        goto exit;
+    }
+
+    if ((fpriv = fopen("ecc_priv.txt", "wb+")) == NULL) {
+        printf("cannot open ecc_priv.txt\n");
+        ret = 1;
+        goto exit;
+    }
+
+    if ((ret = big_number_write_file("X = ", &key_pair.Q.X, 16, fpriv)) != 0 ||
+        (ret = big_number_write_file("Y = ", &key_pair.Q.Y, 16, fpriv)) != 0 ||
+        (ret = big_number_write_file("Z = ", &key_pair.Q.Z, 16, fpriv)) != 0 ||
+        (ret = big_number_write_file("d = ", &key_pair.d, 16, fpriv)) != 0) {
+        printf("big_number_write_file fail, ret %d\n", ret);
+        goto exit;
+    }
+
+exit:
+
+    if (fpub != NULL)
+        fclose(fpub);
+
+    if (fpriv != NULL)
+        fclose(fpriv);
+
+    big_number_free(&key_pair.Q);
+    big_number_free(&key_pair.d);
+
+#if defined(_WIN32)
+    printf("press any key to exit\n" );
+    fflush(stdout); getchar();
+#endif
+
+    return ret;
+}
+
diff --git a/lw_cryptography/unit_test/ecc_sign.c b/lw_cryptography/unit_test/ecc_sign.c
new file mode 100644
index 0000000..c3f4353
--- /dev/null
+++ b/lw_cryptography/unit_test/ecc_sign.c
@@ -0,0 +1,167 @@
+/*******************************************************************************
+ * ecc_sign.c
+ *
+ * History:
+ *  2017/03/30 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+
+#if defined (_WIN32) || defined(_WIN64)
+#include <time.h>
+#include <windows.h>
+#else
+#include <sys/time.h>
+#endif
+
+#include "cryptography_if.h"
+
+static int __random_generator(void* context, unsigned char* output, unsigned int output_len)
+{
+    static unsigned char seed4 = 29, seed3 = 43, seed2 = 17, seed1 = 97;
+    unsigned char digest[32] = {0};
+    unsigned int i = 0 , len0 = 0;
+
+#if defined (_WIN32) || defined(_WIN64)
+    SYSTEMTIME wtm;
+    GetLocalTime(&wtm);
+    memcpy(output, &wtm, sizeof(wtm));
+#else
+    struct timeval tt;
+    gettimeofday(&tt, NULL);
+    memcpy(output, &tt, sizeof(tt));
+#endif
+
+    if (32 > output_len) {
+        len0 = output_len;
+    } else {
+        len0 = 32;
+    }
+
+    output[0] = output[1] ^ seed1;
+    output[1] = output[2] ^ seed2;
+    output[2] = output[3] ^ seed3;
+    output[3] = output[0] ^ seed4;
+
+    pseudo_random_scamble_sequence(output, output_len);
+    digest_sha256(output, output_len, digest);
+    for (i = 0; i < len0; i ++) {
+        output[i] = output[i] ^ digest[i];
+    }
+
+    pseudo_random_scamble_sequence(output, output_len);
+    digest_sha256(output, output_len, digest);
+    for (i = 0; i < len0; i ++) {
+        output[i] = output[i] ^ digest[i];
+    }
+
+    seed4 += 163;
+    seed3 += 59;
+    seed2 += 101;
+    seed1 += 23;
+
+    return 0;
+}
+
+int main()
+{
+    FILE *f = NULL;
+    int ret = 0;
+    unsigned int i;
+    ecdsa_context_t ecdsa;
+    unsigned char fake_digest[32] = {
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef
+    };
+    unsigned char signature[512];
+    unsigned int signature_length = sizeof(signature);
+
+    ecdsa_init(&ecdsa);
+
+    if ((f = fopen( "ecc_priv.txt", "rb")) == NULL) {
+        ret = 1;
+        printf("cannot open ecc_priv.txt\n");
+        goto exit;
+    }
+
+    if ((ret = big_number_read_file(&ecdsa.Q.X, 16, f)) != 0 ||
+        (ret = big_number_read_file(&ecdsa.Q.Y, 16, f)) != 0 ||
+        (ret = big_number_read_file(&ecdsa.Q.Z, 16, f)) != 0 ||
+        (ret = big_number_read_file(&ecdsa.d, 16, f)) != 0) {
+        printf("big_number_read_file fail, return %d\n", ret);
+        goto exit;
+    }
+
+    fclose(f);
+    f = NULL;
+
+    ret = ecc_setup_group(CRYPTO_ECC_DP_SECP192R1, &ecdsa.group);
+    if (ret) {
+        printf("ecc curve not supported, return %d\n", ret);
+        goto exit;
+    }
+
+    ret = ecdsa_write_asn1_signature(&ecdsa, fake_digest, sizeof(fake_digest), signature, &signature_length, __random_generator, NULL);
+    if (ret) {
+        printf("ecdsa signature fail, ret %d\n", ret);
+        goto exit;
+    }
+
+    if (signature_length > sizeof(signature)) {
+        printf("input file too large, %d\n", signature_length);
+        goto exit;
+    }
+
+    if ((f = fopen("ecc.sign", "wb+")) == NULL) {
+        ret = 1;
+        printf("cannot open ecc.sign\n");
+        goto exit;
+    }
+
+    fwrite(signature, 1, signature_length, f);
+
+    printf("sign done\n");
+exit:
+
+    if (f != NULL) {
+        fclose(f);
+    }
+
+    ecdsa_free(&ecdsa);
+
+#if defined(_WIN32)
+    printf("press any key to exit.\n" );
+    fflush(stdout); getchar();
+#endif
+
+    return ret;
+}
+
diff --git a/lw_cryptography/unit_test/ecc_verify.c b/lw_cryptography/unit_test/ecc_verify.c
new file mode 100644
index 0000000..a738ffe
--- /dev/null
+++ b/lw_cryptography/unit_test/ecc_verify.c
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * ecc_verify.c
+ *
+ * History:
+ *  2017/03/30 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "cryptography_if.h"
+
+int main()
+{
+    FILE *f = NULL;
+    int ret = 0;
+    unsigned int i;
+    ecdsa_context_t ecdsa;
+    unsigned char fake_digest[32] = {
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef
+    };
+    unsigned char signature[512];
+    unsigned int signature_length = 0;
+
+    ecdsa_init(&ecdsa);
+
+    if ((f = fopen( "ecc_pub.txt", "rb")) == NULL) {
+        printf( "cannot open ecc_pub.txt\n");
+        goto exit;
+    }
+
+    if ((ret = big_number_read_file(&ecdsa.Q.X, 16, f)) != 0 ||
+        (ret = big_number_read_file(&ecdsa.Q.Y, 16, f)) != 0 ||
+        (ret = big_number_read_file(&ecdsa.Q.Z, 16, f)) != 0) {
+        printf("big_number_read_file fail, return %d\n", ret);
+        goto exit;
+    }
+
+    fclose(f);
+    f = NULL;
+
+    ret = ecc_setup_group(CRYPTO_ECC_DP_SECP192R1, &ecdsa.group);
+    if (ret) {
+        printf("ecc curve not supported, return %d\n", ret);
+        goto exit;
+    }
+
+    if ((f = fopen("ecc.sign", "rb")) == NULL) {
+        printf("cannot open ecc.sign\n");
+        goto exit;
+    }
+
+    fseek(f, 0, SEEK_END);
+    signature_length = ftell(f);
+    fseek(f, 0, SEEK_SET);
+
+    if (signature_length > sizeof(signature)) {
+        printf("input file too large, %d\n", signature_length);
+        goto exit;
+    }
+
+    ret = fread(signature, 1, signature_length, f);
+    fclose(f);
+    f = NULL;
+
+    ret = ecdsa_read_asn1_signature(&ecdsa, fake_digest, sizeof(fake_digest), signature, signature_length);
+
+    if (ret) {
+        printf( "ecdsa_read_asn1_signature fail, retruen %d\n", ret);
+        goto exit;
+    }
+
+    printf("verify OK\n");
+
+exit:
+
+    if (f != NULL) {
+        fclose(f);
+    }
+
+    ecdsa_free(&ecdsa);
+
+#if defined(_WIN32)
+    printf("press any key to exit.\n" );
+    fflush(stdout); getchar();
+#endif
+
+    return ret;
+}
+
diff --git a/lw_cryptography/unit_test/rsa_genkey.c b/lw_cryptography/unit_test/rsa_genkey.c
index da719ac..1559659 100644
--- a/lw_cryptography/unit_test/rsa_genkey.c
+++ b/lw_cryptography/unit_test/rsa_genkey.c
@@ -1,50 +1,88 @@
-/*
- *  Example RSA key generation program
+/*******************************************************************************
+ * rsa_genkey.c
  *
- *  Copyright (C) 2006-2011, ARM Limited, All Rights Reserved
+ * History:
+ *  2015/06/25 - [Zhi He] create file
  *
- *  This file is part of mbed TLS (https://tls.mbed.org)
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
+ ******************************************************************************/
 
 #include <stdio.h>
+#include <string.h>
+
+#if defined (_WIN32) || defined(_WIN64)
 #include <time.h>
 #include <windows.h>
+#else
+#include <sys/time.h>
+#endif
 
 #include "cryptography_if.h"
 
-#include <stdio.h>
-#include <string.h>
-
 #define KEY_SIZE 1024
 #define EXPONENT 65537
 
 static int __random_generator(void* context, unsigned char* output, unsigned int output_len)
 {
     static unsigned char seed1 = 29, seed2 = 43, seed3 = 17, seed4 = 97;
+    unsigned char digest[32] = {0};
+    unsigned int i = 0 , len0 = 0;
 
+#if defined (_WIN32) || defined(_WIN64)
     SYSTEMTIME wtm;
     GetLocalTime(&wtm);
     memcpy(output, &wtm, sizeof(wtm));
+#else
+    struct timeval tt;
+    gettimeofday(&tt, NULL);
+    memcpy(output, &tt, sizeof(tt));
+#endif
+
+    if (32 > output_len) {
+        len0 = output_len;
+    } else {
+        len0 = 32;
+    }
 
     output[0] = output[1] ^ seed1;
     output[1] = output[2] ^ seed2;
     output[2] = output[3] ^ seed3;
     output[3] = output[0] ^ seed4;
+
     pseudo_random_scamble_sequence(output, output_len);
+    digest_sha256(output, output_len, digest);
+    for (i = 0; i < len0; i ++) {
+        output[i] = output[i] ^ digest[i];
+    }
+
+    pseudo_random_scamble_sequence(output, output_len);
+    digest_sha256(output, output_len, digest);
+    for (i = 0; i < len0; i ++) {
+        output[i] = output[i] ^ digest[i];
+    }
 
     seed1 += 163;
     seed2 += 59;
@@ -54,83 +92,65 @@ static int __random_generator(void* context, unsigned char* output, unsigned int
     return 0;
 }
 
-int main( void )
+int main()
 {
     int ret;
     rsa_context_t rsa;
     FILE *fpub  = NULL;
     FILE *fpriv = NULL;
-    const char *pers = "rsa_genkey";
 
-    printf( ". Generating the RSA key [ %d-bit ]...", KEY_SIZE );
-    fflush( stdout );
+    rsa_init(&rsa, RSA_PKCS_V15, 0);
 
-    rsa_init( &rsa, RSA_PKCS_V15, 0 );
-
-    if( ( ret = rsa_gen_key( &rsa, __random_generator, NULL, KEY_SIZE,
-                             EXPONENT ) ) != 0 )
-    {
-        printf( " failed\n  ! rsa_gen_key returned %d\n\n", ret );
+    if ((ret = rsa_gen_key( &rsa, __random_generator, NULL, KEY_SIZE, EXPONENT)) != 0) {
+        printf("rsa_gen_key fail, ret %d\n", ret);
         goto exit;
     }
 
-    printf( " ok\n  . Exporting the public  key in rsa_pub.txt...." );
-    fflush( stdout );
-
-    if( ( fpub = fopen( "rsa_pub.txt", "wb+" ) ) == NULL )
-    {
-        printf( " failed\n  ! could not open rsa_pub.txt for writing\n\n" );
+    if ((fpub = fopen( "rsa_pub.txt", "wb+")) == NULL) {
+        printf("cannot open rsa_pub.txt\n");
         ret = 1;
         goto exit;
     }
 
-    if( ( ret = big_number_write_file( "N = ", &rsa.N, 16, fpub ) ) != 0 ||
-        ( ret = big_number_write_file( "E = ", &rsa.E, 16, fpub ) ) != 0 )
-    {
-        printf( " failed\n  ! big_number_write_file returned %d\n\n", ret );
+    if ((ret = big_number_write_file("N = ", &rsa.N, 16, fpub)) != 0 ||
+        (ret = big_number_write_file("E = ", &rsa.E, 16, fpub )) != 0) {
+        printf("big_number_write_file fail, return %d\n", ret);
         goto exit;
     }
 
-    printf( " ok\n  . Exporting the private key in rsa_priv.txt..." );
-    fflush( stdout );
-
-    if( ( fpriv = fopen( "rsa_priv.txt", "wb+" ) ) == NULL )
-    {
-        printf( " failed\n  ! could not open rsa_priv.txt for writing\n" );
+    if ((fpriv = fopen("rsa_priv.txt", "wb+")) == NULL) {
+        printf("cannot open rsa_priv.txt\n");
         ret = 1;
         goto exit;
     }
 
-    if( ( ret = big_number_write_file( "N = " , &rsa.N , 16, fpriv ) ) != 0 ||
-        ( ret = big_number_write_file( "E = " , &rsa.E , 16, fpriv ) ) != 0 ||
-        ( ret = big_number_write_file( "D = " , &rsa.D , 16, fpriv ) ) != 0 ||
-        ( ret = big_number_write_file( "P = " , &rsa.P , 16, fpriv ) ) != 0 ||
-        ( ret = big_number_write_file( "Q = " , &rsa.Q , 16, fpriv ) ) != 0 ||
-        ( ret = big_number_write_file( "DP = ", &rsa.DP, 16, fpriv ) ) != 0 ||
-        ( ret = big_number_write_file( "DQ = ", &rsa.DQ, 16, fpriv ) ) != 0 ||
-        ( ret = big_number_write_file( "QP = ", &rsa.QP, 16, fpriv ) ) != 0 )
-    {
-        printf( " failed\n  ! big_number_write_file returned %d\n\n", ret );
+    if ((ret = big_number_write_file("N = ", &rsa.N, 16, fpriv)) != 0 ||
+        (ret = big_number_write_file("E = ", &rsa.E, 16, fpriv)) != 0 ||
+        (ret = big_number_write_file("D = ", &rsa.D, 16, fpriv)) != 0 ||
+        (ret = big_number_write_file("P = " , &rsa.P, 16, fpriv)) != 0 ||
+        (ret = big_number_write_file("Q = " , &rsa.Q, 16, fpriv)) != 0 ||
+        (ret = big_number_write_file("DP = ", &rsa.DP, 16, fpriv)) != 0 ||
+        (ret = big_number_write_file("DQ = ", &rsa.DQ, 16, fpriv)) != 0 ||
+        (ret = big_number_write_file("QP = ", &rsa.QP, 16, fpriv)) != 0) {
+        printf("big_number_write_file fail, ret %d\n", ret);
         goto exit;
     }
 
-    printf( " ok\n\n" );
-
 exit:
 
-    if( fpub  != NULL )
-        fclose( fpub );
+    if (fpub != NULL)
+        fclose(fpub);
 
-    if( fpriv != NULL )
-        fclose( fpriv );
+    if (fpriv != NULL)
+        fclose(fpriv);
 
-    rsa_free( &rsa );
+    rsa_free(&rsa);
 
 #if defined(_WIN32)
-    printf( "  Press Enter to exit this program.\n" );
-    fflush( stdout ); getchar();
+    printf("press any key to exit\n" );
+    fflush(stdout); getchar();
 #endif
 
-    return( ret );
+    return ret;
 }
 
diff --git a/lw_cryptography/unit_test/rsa_sign.c b/lw_cryptography/unit_test/rsa_sign.c
index 23e554e..1ad8f11 100644
--- a/lw_cryptography/unit_test/rsa_sign.c
+++ b/lw_cryptography/unit_test/rsa_sign.c
@@ -1,125 +1,114 @@
-/*
- *  RSA/SHA-256 signature creation program
+/*******************************************************************************
+ * rsa_sign.c
  *
- *  Copyright (C) 2006-2011, ARM Limited, All Rights Reserved
+ * History:
+ *  2015/06/25 - [Zhi He] create file
  *
- *  This file is part of mbed TLS (https://tls.mbed.org)
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
+ ******************************************************************************/
 
 #include <stdio.h>
 #include <string.h>
-#include <stdio.h>
 
 #include "cryptography_if.h"
 
-int main( int argc, char *argv[] )
+int main()
 {
-    FILE *f;
-    int ret;
+    FILE *f = NULL;
+    int ret = 0;
     unsigned int i;
     rsa_context_t rsa;
-    unsigned char hash[32] = {
+    unsigned char fake_digest[32] = {
         0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
         0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
         0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
         0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef
     };
-    unsigned char buf[D_BIG_NUMBER_MAX_SIZE];
+    unsigned char signature[128];
 
-    ret = 1;
+    rsa_init(&rsa, RSA_PKCS_V15, 0);
 
-    if( ( f = fopen( "rsa_priv.txt", "rb" ) ) == NULL )
-    {
+    if ((f = fopen( "rsa_priv.txt", "rb")) == NULL) {
         ret = 1;
-        printf( " failed\n  ! Could not open rsa_priv.txt\n" \
-                "  ! Please run rsa_genkey first\n\n" );
+        printf("cannot open rsa_priv.txt\n");
         goto exit;
     }
 
-    rsa_init( &rsa, RSA_PKCS_V15, 0 );
-
-    if( ( ret = big_number_read_file( &rsa.N , 16, f ) ) != 0 ||
-        ( ret = big_number_read_file( &rsa.E , 16, f ) ) != 0 ||
-        ( ret = big_number_read_file( &rsa.D , 16, f ) ) != 0 ||
-        ( ret = big_number_read_file( &rsa.P , 16, f ) ) != 0 ||
-        ( ret = big_number_read_file( &rsa.Q , 16, f ) ) != 0 ||
-        ( ret = big_number_read_file( &rsa.DP, 16, f ) ) != 0 ||
-        ( ret = big_number_read_file( &rsa.DQ, 16, f ) ) != 0 ||
-        ( ret = big_number_read_file( &rsa.QP, 16, f ) ) != 0 )
-    {
-        printf( " failed\n  ! big_number_read_file returned %d\n\n", ret );
+    if ((ret = big_number_read_file(&rsa.N, 16, f)) != 0 ||
+        (ret = big_number_read_file(&rsa.E, 16, f)) != 0 ||
+        (ret = big_number_read_file(&rsa.D, 16, f)) != 0 ||
+        (ret = big_number_read_file(&rsa.P, 16, f)) != 0 ||
+        (ret = big_number_read_file(&rsa.Q, 16, f)) != 0 ||
+        (ret = big_number_read_file(&rsa.DP, 16, f)) != 0 ||
+        (ret = big_number_read_file(&rsa.DQ, 16, f)) != 0 ||
+        (ret = big_number_read_file(&rsa.QP, 16, f)) != 0) {
+        printf("big_number_read_file fail, return %d\n", ret);
         goto exit;
     }
 
-    rsa.len = ( big_number_msb( &rsa.N ) + 7 ) >> 3;
-
-    fclose( f );
+    fclose(f);
+    f = NULL;
 
-    printf( "\n  . Checking the private key" );
-    fflush( stdout );
-    if( ( ret = rsa_check_privkey( &rsa ) ) != 0 )
-    {
-        printf( " failed\n  ! rsa_check_privkey failed with -0x%0x\n", -ret );
+    rsa.len = (big_number_msb(&rsa.N) + 7) >> 3;
+    if (128 != rsa.len){
+        printf("only support 1024 bit rsa, len %d\n", rsa.len);
         goto exit;
     }
 
-    /*
-     * Compute the SHA-256 hash of the input file,
-     * then calculate the RSA signature of the hash.
-     */
-    printf( "\n  . Generating the RSA/SHA-256 signature" );
-    fflush( stdout );
-
-#if 0
-    if( ( ret = sha1_file( argv[1], hash ) ) != 0 )
-    {
-        printf( " failed\n  ! Could not open or read %s\n\n", argv[1] );
+    if ((ret = rsa_check_privkey(&rsa)) != 0) {
+        printf("rsa_check_privkey fail, return %d\n",ret);
         goto exit;
     }
-#endif
 
-    if ((ret = rsa_sha256_sign(&rsa, hash, buf ) ) != 0 )
-    {
-        printf( " failed\n  ! rsa_pkcs1_sign returned -0x%0x\n\n", -ret );
+    if ((ret = rsa_sha256_sign(&rsa, fake_digest, signature)) != 0) {
+        printf("rsa_sha256_sign fail, return %d\n\n", ret);
         goto exit;
     }
 
-    if( ( f = fopen("test.sign", "wb+" ) ) == NULL )
-    {
+    if ((f = fopen("test.sign", "wb+")) == NULL) {
         ret = 1;
-        printf( " failed\n  ! Could not create %s\n\n", argv[1] );
+        printf("cannot open test.sign\n");
         goto exit;
     }
 
-    for( i = 0; i < rsa.len; i++ )
-        fprintf( f, "%02X%s", buf[i],
-                 ( i + 1 ) % 16 == 0 ? "\r\n" : " " );
+    fwrite(signature, 1, sizeof(signature), f);
 
-    fclose( f );
+    printf("sign done\n");
+exit:
 
-    printf( "\n  . Done (created \"%s\")\n\n", argv[1] );
+    if (f != NULL)
+        fclose(f);
 
-exit:
+    rsa_free(&rsa);
 
 #if defined(_WIN32)
-    printf( "  + Press Enter to exit this program.\n" );
-    fflush( stdout ); getchar();
+    printf("press any key to exit.\n" );
+    fflush(stdout); getchar();
 #endif
 
-    return( ret );
+    return ret;
 }
 
diff --git a/lw_cryptography/unit_test/rsa_verify.c b/lw_cryptography/unit_test/rsa_verify.c
index b56970b..9510fe8 100644
--- a/lw_cryptography/unit_test/rsa_verify.c
+++ b/lw_cryptography/unit_test/rsa_verify.c
@@ -1,24 +1,34 @@
-/*
- *  RSA/SHA-256 signature verification program
+/*******************************************************************************
+ * rsa_verify.c
  *
- *  Copyright (C) 2006-2011, ARM Limited, All Rights Reserved
+ * History:
+ *  2015/06/25 - [Zhi He] create file
  *
- *  This file is part of mbed TLS (https://tls.mbed.org)
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
  *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
  *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
+ ******************************************************************************/
 
 #include <stdio.h>
 #include <string.h>
@@ -26,97 +36,70 @@
 
 #include "cryptography_if.h"
 
-int main( int argc, char *argv[] )
+int main()
 {
-    FILE *f;
-    int ret, c;
+    FILE *f = NULL;
+    int ret = 0;
     unsigned int i = 0;
     rsa_context_t rsa;
-    unsigned char hash[32] = {
+    unsigned char fake_digest[32] = {
         0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
         0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
         0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
         0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef
     };
-    unsigned char buf[D_BIG_NUMBER_MAX_SIZE];
-
-    ret = 1;
-
-    if( ( f = fopen( "rsa_pub.txt", "rb" ) ) == NULL )
-    {
-        printf( " failed\n  ! Could not open rsa_pub.txt\n" \
-                "  ! Please run rsa_genkey first\n\n" );
-        goto exit;
-    }
+    unsigned char signature[128];
 
     rsa_init(&rsa, RSA_PKCS_V15, 0 );
 
-    if( ( ret = big_number_read_file( &rsa.N, 16, f ) ) != 0 ||
-        ( ret = big_number_read_file( &rsa.E, 16, f ) ) != 0 )
-    {
-        printf( " failed\n  ! big_number_read_file returned %d\n\n", ret );
+    if ((f = fopen( "rsa_pub.txt", "rb")) == NULL) {
+        printf( "cannot open rsa_pub.txt\n");
         goto exit;
     }
 
-    rsa.len = ( big_number_msb( &rsa.N ) + 7 ) >> 3;
-
-    fclose( f );
-
-    /*
-     * Extract the RSA signature from the text file
-     */
-    ret = 1;
-
-    if( ( f = fopen("test.sign", "rb" ) ) == NULL )
-    {
-        printf( "\n  ! Could not open %s\n\n", argv[1] );
+    if ((ret = big_number_read_file(&rsa.N, 16, f)) != 0 ||
+        (ret = big_number_read_file(&rsa.E, 16, f)) != 0) {
+        printf("big_number_read_file fail, return %d\n", ret);
         goto exit;
     }
 
-    while( fscanf( f, "%02X", &c ) > 0 &&
-           i < (int) sizeof( buf ) )
-        buf[i++] = (unsigned char) c;
+    fclose(f);
+    f = NULL;
 
-    fclose( f );
-
-    if( i != rsa.len )
-    {
-        printf( "\n  ! Invalid RSA signature format\n\n" );
+    rsa.len = (big_number_msb(&rsa.N) + 7) >> 3;
+    if (128 != rsa.len){
+        printf("only support 1024 bit rsa, len %d\n", rsa.len);
         goto exit;
     }
 
-    /*
-     * Compute the SHA-256 hash of the input file and compare
-     * it with the hash decrypted from the RSA signature.
-     */
-    printf( "\n  . Verifying the RSA/SHA-256 signature" );
-    fflush( stdout );
-
-#if 0
-    if( ( ret = sha1_file( argv[1], hash ) ) != 0 )
-    {
-        printf( " failed\n  ! Could not open or read %s\n\n", argv[1] );
+    if ((f = fopen("test.sign", "rb")) == NULL) {
+        printf("cannot open test.sign\n");
         goto exit;
     }
-#endif
 
-    if ((ret = rsa_sha256_verify(&rsa, hash, buf)) != 0)
-    {
-        printf( " failed\n  ! rsa_pkcs1_verify returned -0x%0x\n\n", -ret );
+    ret = fread(signature, 1, sizeof(signature), f);
+    fclose(f);
+    f = NULL;
+
+    if ((ret = rsa_sha256_verify(&rsa, fake_digest, signature)) != 0) {
+        printf( "rsa_sha256_verify fail, retruen %d\n", ret);
         goto exit;
     }
 
-    printf( "\n  . OK (the decrypted SHA-256 hash matches)\n\n" );
-
-    ret = 0;
+    printf("verify OK\n");
 
 exit:
 
+    if (f != NULL)
+        fclose(f);
+
+    rsa_free(&rsa);
+
 #if defined(_WIN32)
-    printf( "  + Press Enter to exit this program.\n" );
-    fflush( stdout ); getchar();
+    printf("press any key to exit.\n" );
+    fflush(stdout); getchar();
 #endif
 
-    return( ret );
+    return ret;
 }
 
diff --git a/lw_cryptography/unit_test/verify_aes.c b/lw_cryptography/unit_test/verify_aes.c
new file mode 100644
index 0000000..f348b02
--- /dev/null
+++ b/lw_cryptography/unit_test/verify_aes.c
@@ -0,0 +1,550 @@
+/*******************************************************************************
+ * verify_aes.c
+ *
+ * History:
+ *  2017/02/28 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "cryptography_if.h"
+
+//AES test vectors from: http://csrc.nist.gov/archive/aes/rijndael/rijndael-vals.zip
+
+//ECB
+static const unsigned char gs_aes128_dec_test_ecb_vector[16] =
+{
+    0x44, 0x41, 0x6A, 0xC2, 0xD1, 0xF5, 0x3C, 0x58,
+    0x33, 0x03, 0x91, 0x7E, 0x6B, 0xE9, 0xEB, 0xE0
+};
+
+static const unsigned char gs_aes192_dec_test_ecb_vector[16] =
+{
+    0x48, 0xE3, 0x1E, 0x9E, 0x25, 0x67, 0x18, 0xF2,
+    0x92, 0x29, 0x31, 0x9C, 0x19, 0xF1, 0x5B, 0xA4
+};
+
+static const unsigned char gs_aes256_dec_test_ecb_vector[16] =
+{
+    0x05, 0x8C, 0xCF, 0xFD, 0xBB, 0xCB, 0x38, 0x2D,
+    0x1F, 0x6F, 0x56, 0x58, 0x5D, 0x8A, 0x4A, 0xDE
+};
+
+static const unsigned char gs_aes128_enc_test_ecb_vector[16] =
+{
+    0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,
+    0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F
+};
+
+static const unsigned char gs_aes192_enc_test_ecb_vector[16] =
+{
+    0xF3, 0xF6, 0x75, 0x2A, 0xE8, 0xD7, 0x83, 0x11,
+    0x38, 0xF0, 0x41, 0x56, 0x06, 0x31, 0xB1, 0x14
+};
+
+static const unsigned char gs_aes256_enc_test_ecb_vector[16] =
+{
+    0x8B, 0x79, 0xEE, 0xCC, 0x93, 0xA0, 0xEE, 0x5D,
+    0xFF, 0x30, 0xB4, 0xEA, 0x21, 0x63, 0x6D, 0xA4
+};
+
+//CBC
+
+static const unsigned char gs_aes128_dec_test_cbc_vector[16] =
+{
+    0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73,
+    0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86
+};
+
+static const unsigned char gs_aes192_dec_test_cbc_vector[16] =
+{
+    0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75,
+    0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B
+};
+
+static const unsigned char gs_aes256_dec_test_cbc_vector[16] =
+{
+    0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75,
+    0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13
+};
+
+static const unsigned char gs_aes128_enc_test_cbc_vector[16] =
+{
+    0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84,
+    0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D
+};
+
+static const unsigned char gs_aes192_enc_test_cbc_vector[16] =
+{
+    0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB,
+    0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04
+};
+
+static const unsigned char gs_aes256_enc_test_cbc_vector[16] =
+{
+    0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5,
+    0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0
+};
+
+static void __print_mem(unsigned char * p, unsigned int len)
+{
+    while (len > 15) {
+        DCRYPT_LOG("%02x %02x %02x %02x ", p[0], p[1], p[2], p[3]);
+        DCRYPT_LOG("%02x %02x %02x %02x\n", p[4], p[5], p[6], p[7]);
+        DCRYPT_LOG("%02x %02x %02x %02x ", p[8], p[9], p[10], p[11]);
+        DCRYPT_LOG("%02x %02x %02x %02x\n", p[12], p[13], p[14], p[15]);
+        p += 16;
+        len -= 16;
+    }
+    if (len > 0) {
+        while (len > 0) {
+            DCRYPT_LOG("%02x ", p[0]);
+            p ++;
+            len --;
+        }
+        DCRYPT_LOG("\n");
+    }
+}
+
+//ECB
+
+static int __verify_aes_ecb_decrypt()
+{
+    int ret = 0;
+    unsigned int i = 0;
+    aes_context_t *thiz = NULL;
+    unsigned char key[32] = {0};
+    unsigned char buf[64] = {0};
+
+    printf("verify aes128 ecb decryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    ret = aes_set_decrypt_key(thiz, key, 128);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_ecb_decrypt(thiz, buf, buf, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(buf, gs_aes128_dec_test_ecb_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    printf("verify aes192 ecb decryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    ret = aes_set_decrypt_key(thiz, key, 192);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_ecb_decrypt(thiz, buf, buf, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(buf, gs_aes192_dec_test_ecb_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    printf("verify aes256 ecb decryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    ret = aes_set_decrypt_key(thiz, key, 256);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_ecb_decrypt(thiz, buf, buf, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(buf, gs_aes256_dec_test_ecb_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    return 0;
+}
+
+static int __verify_aes_ecb_encrypt()
+{
+    int ret = 0;
+    unsigned int i = 0;
+    aes_context_t *thiz = NULL;
+    unsigned char key[32] = {0};
+    unsigned char buf[64] = {0};
+
+    printf("verify aes128 ecb encryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    ret = aes_set_encrypt_key(thiz, key, 128);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_ecb_encrypt(thiz, buf, buf, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(buf, gs_aes128_enc_test_ecb_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    printf("verify aes192 ecb encryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    ret = aes_set_encrypt_key(thiz, key, 192);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_ecb_encrypt(thiz, buf, buf, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(buf, gs_aes192_enc_test_ecb_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    printf("verify aes256 ecb encryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    ret = aes_set_encrypt_key(thiz, key, 256);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_ecb_encrypt(thiz, buf, buf, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(buf, gs_aes256_enc_test_ecb_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    return 0;
+}
+
+//CBC
+
+static int __verify_aes_cbc_decrypt()
+{
+    int ret = 0;
+    unsigned int i = 0;
+    aes_context_t *thiz = NULL;
+    unsigned char key[32] = {0};
+    unsigned char buf[64] = {0};
+    unsigned char iv[16] = {0};
+
+    printf("verify aes128 cbc decryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    memset(iv, 0x0, sizeof(iv));
+    ret = aes_set_decrypt_key(thiz, key, 128);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_cbc_decrypt(thiz, iv, buf, buf, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(buf, gs_aes128_dec_test_cbc_vector, 16)) {
+        printf("  fail\n");
+    } else {
+        printf("  pass\n");
+    }
+
+    printf("verify aes192 cbc decryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    memset(iv, 0x0, sizeof(iv));
+    ret = aes_set_decrypt_key(thiz, key, 192);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_cbc_decrypt(thiz, iv, buf, buf, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(buf, gs_aes192_dec_test_cbc_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    printf("verify aes256 cbc decryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    memset(iv, 0x0, sizeof(iv));
+    ret = aes_set_decrypt_key(thiz, key, 256);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_cbc_decrypt(thiz, iv, buf, buf, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(buf, gs_aes256_dec_test_cbc_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    return 0;
+}
+
+static int __verify_aes_cbc_encrypt()
+{
+    int ret = 0;
+    unsigned int i = 0;
+    aes_context_t *thiz = NULL;
+    unsigned char key[32] = {0};
+    unsigned char buf[64] = {0};
+    unsigned char iv[16] = {0};
+    unsigned char tmp[16] = {0};
+    unsigned char prv[16] = {0};
+
+    printf("verify aes128 cbc encryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    memset(iv, 0x0, sizeof(iv));
+    memset(prv, 0x0, sizeof(prv));
+    ret = aes_set_encrypt_key(thiz, key, 128);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_cbc_encrypt(thiz, iv, buf, buf, 16);
+        memcpy(tmp, prv, 16);
+        memcpy(prv, buf, 16);
+        memcpy(buf, tmp, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(prv, gs_aes128_enc_test_cbc_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    printf("verify aes192 cbc encryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    memset(iv, 0x0, sizeof(iv));
+    memset(prv, 0x0, sizeof(prv));
+    ret = aes_set_encrypt_key(thiz, key, 192);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_cbc_encrypt(thiz, iv, buf, buf, 16);
+        memcpy(tmp, prv, 16);
+        memcpy(prv, buf, 16);
+        memcpy(buf, tmp, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(prv, gs_aes192_enc_test_cbc_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    printf("verify aes256 cbc encryption ...\n");
+
+    thiz = aes_init();
+    if (!thiz) {
+        return (-1);
+    }
+
+    memset(buf, 0x0, sizeof(buf));
+    memset(key, 0x0, sizeof(key));
+    memset(iv, 0x0, sizeof(iv));
+    memset(prv, 0x0, sizeof(prv));
+    ret = aes_set_encrypt_key(thiz, key, 256);
+    if (ret) {
+        return (-2);
+    }
+
+    for (i = 0; i < 10000; i ++) {
+        aes_cbc_encrypt(thiz, iv, buf, buf, 16);
+        memcpy(tmp, prv, 16);
+        memcpy(prv, buf, 16);
+        memcpy(buf, tmp, 16);
+    }
+
+    aes_destroy(thiz);
+    thiz = NULL;
+
+    if (memcmp(prv, gs_aes256_enc_test_cbc_vector, 16)) {
+        printf("  fail\n");
+        __print_mem(buf, 16);
+    } else {
+        printf("  pass\n");
+    }
+
+    return 0;
+}
+
+
+int main()
+{
+    __verify_aes_ecb_decrypt();
+    __verify_aes_ecb_encrypt();
+    __verify_aes_cbc_decrypt();
+    __verify_aes_cbc_encrypt();
+    return 0;
+}
+
diff --git a/lw_cryptography/unit_test/verify_rsa_verify.c b/lw_cryptography/unit_test/verify_rsa_verify.c
new file mode 100644
index 0000000..aeeb393
--- /dev/null
+++ b/lw_cryptography/unit_test/verify_rsa_verify.c
@@ -0,0 +1,111 @@
+/*******************************************************************************
+ * verify_rsa_verify.c
+ *
+ * History:
+ *  2017/03/03 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "cryptography_if.h"
+
+int main()
+{
+    int ret = 0;
+    rsa_context_t rsa;
+
+    unsigned char digest[32] = {
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
+        0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef
+    };
+
+    unsigned char signature[128] = {
+        0xab, 0x5f, 0x36, 0x98, 0x16, 0x45, 0xa0, 0x1c,
+        0x0e, 0xe0, 0xae, 0x74, 0x70, 0x2e, 0xd5, 0x1c,
+        0x63, 0x4a, 0xc4, 0x0a, 0x5b, 0x56, 0xe5, 0x15,
+        0xf8, 0x22, 0x1f, 0x91, 0x8e, 0x97, 0xb3, 0xfe,
+        0x34, 0xe9, 0x76, 0x33, 0xc2, 0xdf, 0x7d, 0x01,
+        0x62, 0x74, 0x4d, 0xf0, 0x6b, 0x8d, 0x84, 0x14,
+        0xf7, 0xb5, 0x5d, 0x6a, 0x5c, 0xac, 0xc2, 0x9d,
+        0x8d, 0x34, 0xa2, 0x75, 0x49, 0x0d, 0xdd, 0x40,
+        0xad, 0x0c, 0x15, 0x9d, 0x61, 0xa2, 0xa2, 0x39,
+        0x34, 0x1e, 0xe7, 0xad, 0xfb, 0xea, 0x6c, 0x97,
+        0x58, 0xf9, 0xf9, 0xdc, 0xcb, 0x3b, 0x3b, 0x8b,
+        0x83, 0xba, 0xcd, 0xd5, 0x54, 0xc1, 0x43, 0xa3,
+        0x6f, 0x26, 0x7c, 0xe6, 0x68, 0xb7, 0x87, 0x4d,
+        0x1c, 0xd4, 0xad, 0xdf, 0xe4, 0x32, 0x41, 0xdc,
+        0xec, 0x41, 0x48, 0xaf, 0x92, 0x96, 0xde, 0x33,
+        0x82, 0xa7, 0xcd, 0xa3, 0x28, 0x68, 0xad, 0x3e,
+    };
+
+    char rsa_pub_key_n[] = "B317C5F0841504CBD415DA47CFD0138EC1160270E64FB0374E8E39E0E054232FE04A90EB02B03661BBD99CA4314AC69407FFB0DE520D033F63151842C42BCB8DC48144C509C16C348D533F4E65786F4D81F53A7887640ABDF5A9D46307DE77CA8360C83FE200195FDCE38B2736CE884DC567C6A152C0F64359D1854F0D5ED5C9";
+    char rsa_pub_key_e[] = "010001";
+
+    rsa_init(&rsa, RSA_PKCS_V15, 0);
+
+    if (256 < strlen(rsa_pub_key_n)) {
+        printf("bad N length %d\n", (unsigned int) strlen(rsa_pub_key_n));
+        goto exit;
+    }
+
+    ret = big_number_read_string(&rsa.N, 16, rsa_pub_key_n);
+    if (0 > ret) {
+        printf("read N fail\n");
+        goto exit;
+    }
+
+    ret = big_number_read_string(&rsa.E, 16, rsa_pub_key_e);
+    if (0 > ret) {
+        printf("read E fail\n");
+        goto exit;
+    }
+
+    rsa.len = (big_number_msb(&rsa.N) + 7) >> 3;
+    if (128 != rsa.len){
+        printf("only support 1024 bit rsa, len %d\n", rsa.len);
+        goto exit;
+    }
+
+    if ((ret = rsa_sha256_verify(&rsa, digest, signature)) != 0) {
+        printf( "rsa_sha256_verify fail, retruen %d\n", ret);
+        goto exit;
+    }
+
+    printf("verify OK\n");
+
+exit:
+
+    rsa_free(&rsa);
+
+    return ret;
+}
+
diff --git a/lw_cryptography/unit_test/verify_sha256.c b/lw_cryptography/unit_test/verify_sha256.c
new file mode 100644
index 0000000..5988088
--- /dev/null
+++ b/lw_cryptography/unit_test/verify_sha256.c
@@ -0,0 +1,125 @@
+/*******************************************************************************
+ * verify_sha256.c
+ *
+ * History:
+ *  2017/03/02 - [Zhi He] create file
+ *
+ * Copyright (c) 2016 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "cryptography_if.h"
+
+static const unsigned char gs_sha256_input_vector[128] =
+{
+    0x12, 0x56, 0x34, 0x78, 0xef, 0x9a, 0xcd, 0x0b,
+    0x10, 0x32, 0x54, 0x76, 0x98, 0xba, 0xdc, 0xfe,
+    0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
+    0x7a, 0x6c, 0xf2, 0xe5, 0x87, 0x03, 0xd2, 0xca,
+    0x42, 0x56, 0x34, 0x68, 0xef, 0x9a, 0xcd, 0xdb,
+    0x50, 0x32, 0x54, 0xa6, 0x98, 0xba, 0xdc, 0xde,
+    0x1a, 0xbb, 0xcc, 0xed, 0xee, 0xff, 0x00, 0x21,
+    0x8a, 0x6c, 0xf2, 0xe5, 0x87, 0x03, 0xd2, 0xc5,
+    0x12, 0x56, 0x34, 0x78, 0xef, 0x9a, 0xcd, 0x0b,
+    0x10, 0x32, 0x54, 0x76, 0x98, 0xba, 0xdc, 0xfe,
+    0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
+    0x7a, 0x6c, 0xf2, 0xe5, 0x87, 0x03, 0xd2, 0xca,
+    0x42, 0x56, 0x34, 0x68, 0xef, 0x9a, 0xcd, 0xdb,
+    0x50, 0x32, 0x54, 0xa6, 0x98, 0xba, 0xdc, 0xde,
+    0x1a, 0xbb, 0xcc, 0xed, 0xee, 0xff, 0x00, 0x21,
+    0x8a, 0x6c, 0xf2, 0xe5, 0x87, 0x03, 0xd2, 0xc5,
+};
+
+static const unsigned char gs_sha256_output_vector_64[32] =
+{
+    0x78, 0x4b, 0xe8, 0x88, 0x8c, 0xfe, 0x9d, 0xa9,
+    0x0b, 0x5f, 0x7c, 0xb7, 0xa7, 0x57, 0x7d, 0xf4,
+    0x15, 0x09, 0xaf, 0x2d, 0xd0, 0x83, 0x6a, 0xdb,
+    0x6a, 0xb2, 0x65, 0x6c, 0xdc, 0x13, 0x8d, 0x58,
+};
+
+static const unsigned char gs_sha256_output_vector_128[32] =
+{
+    0x66, 0xe4, 0xd8, 0x44, 0xa7, 0xe3, 0x01, 0x6e,
+    0xd1, 0xe5, 0x13, 0x76, 0xeb, 0x6d, 0x44, 0x7c,
+    0x1b, 0x61, 0x24, 0x1b, 0x3f, 0xae, 0xb2, 0xdb,
+    0x3b, 0x27, 0xfb, 0xc8, 0x03, 0x35, 0x9d, 0xee,
+};
+
+static void __print_mem(const unsigned char * p, unsigned int len)
+{
+    while (len > 15) {
+        DCRYPT_LOG("%02x %02x %02x %02x ", p[0], p[1], p[2], p[3]);
+        DCRYPT_LOG("%02x %02x %02x %02x\n", p[4], p[5], p[6], p[7]);
+        DCRYPT_LOG("%02x %02x %02x %02x ", p[8], p[9], p[10], p[11]);
+        DCRYPT_LOG("%02x %02x %02x %02x\n", p[12], p[13], p[14], p[15]);
+        p += 16;
+        len -= 16;
+    }
+    if (len > 0) {
+        while (len > 0) {
+            DCRYPT_LOG("%02x ", p[0]);
+            p ++;
+            len --;
+        }
+        DCRYPT_LOG("\n");
+    }
+}
+
+int main()
+{
+    unsigned char output[32] = {0};
+
+    printf("verify sha256 ...\n");
+
+    digest_sha256(gs_sha256_input_vector, 64, output);
+
+    if (memcmp(output, gs_sha256_output_vector_64, 32)) {
+        printf("fail, expect\n");
+        __print_mem(gs_sha256_output_vector_64, 32);
+        printf("but\n");
+        __print_mem((const unsigned char *) output, 32);
+    } else {
+        printf("pass\n");
+    }
+
+    digest_sha256(gs_sha256_input_vector, 128, output);
+
+    if (memcmp(output, gs_sha256_output_vector_128, 32)) {
+        printf("fail, expect\n");
+        __print_mem(gs_sha256_output_vector_128, 32);
+        printf("but\n");
+        __print_mem((const unsigned char *) output, 32);
+    } else {
+        printf("pass\n");
+    }
+
+    return 0;
+}
+
diff --git a/openssl_wrapper/make.inc b/openssl_wrapper/make.inc
index 40e65c7..6f2e686 100644
--- a/openssl_wrapper/make.inc
+++ b/openssl_wrapper/make.inc
@@ -1,16 +1,34 @@
-##
+###############################################################################
 ## packages/security/openssl_wrapper/make.inc
 ##
 ## History:
 ##    2015/05/19 - [Zhi He] Created file
 ##
-## Copyright (C) 2015-2025, Ambarella, Inc.
+## Copyright (C) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
 ##
-## All rights reserved. No Part of this file may be reproduced, stored
-## in a retrieval system, or transmitted, in any form, or by any means,
-## electronic, mechanical, photocopying, recording, or otherwise,
-## without the prior consent of Ambarella, Inc.
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
 ##
+##################################################################################
 
 ifeq ($(BUILD_OPENSSL_WRAPPER_LIBRARY), y)
 
@@ -18,19 +36,38 @@ LOCAL_PATH	:= $(call my-dir)
 
 ###
 include $(CLEAR_VARS)
+SSL_WRAPPER_VER_FILE = $(LOCAL_PATH)/openssl_wrapper.h
+SSL_WRAPPER_VER_PREFIX = SSL_WRAPPER
+SSL_WRAPPER_TARGET = libopensslwrapper.so
+
+LOCAL_TARGET  := $(SSL_WRAPPER_TARGET)
+LOCAL_SRCS    := $(LOCAL_PATH)/openssl_wrapper.cpp
+LOCAL_CFLAGS  := -I$(PREBUILD_3RD_PARTY_DIR)/openssl/include \
+                 -fvisibility=hidden                         \
+                 -std=c++11 -Werror
+
+LOCAL_LDFLAGS := -L$(PREBUILD_3RD_PARTY_DIR)/openssl/usr/lib -lssl -lcrypto
 
-LOCAL_CFLAGS	:= -I$(PREBUILD_3RD_PARTY_DIR)/openssl/include
-LOCAL_TARGET	:= libopensslwrapper.a
-LOCAL_SRCS	:= $(LOCAL_PATH)/openssl_wrapper.cpp
+SSL_WRAPPER_SO_VER_MAJOR  := $(shell awk '/define\ $(SSL_WRAPPER_VER_PREFIX)_LIB_MAJOR/{print $$3}' $(SSL_WRAPPER_VER_FILE))
+SSL_WRAPPER_SO_VER_MINOR  := $(shell awk '/define\ $(SSL_WRAPPER_VER_PREFIX)_LIB_MINOR/{print $$3}' $(SSL_WRAPPER_VER_FILE))
+SSL_WRAPPER_SO_VER_PATCH  := $(shell awk '/define\ $(SSL_WRAPPER_VER_PREFIX)_LIB_PATCH/{print $$3}' $(SSL_WRAPPER_VER_FILE))
+SSL_WRAPPER_SO_VER_STRING := $(SSL_WRAPPER_SO_VER_MAJOR).$(SSL_WRAPPER_SO_VER_MINOR).$(SSL_WRAPPER_SO_VER_PATCH)
+
+SSL_WRAPPER_SO_NAME   = $(patsubst %.so,%.so.$(SSL_WRAPPER_SO_VER_MAJOR), $(SSL_WRAPPER_TARGET))
+SSL_WRAPPER_SO_TARGET = $(patsubst %.so,%.so.$(SSL_WRAPPER_SO_VER_STRING), $(SSL_WRAPPER_TARGET))
+
+LOCAL_SO_NAME := $(SSL_WRAPPER_SO_NAME)
 
 include $(BUILD_APP)
 
 .PHONY: $(LOCAL_TARGET)
 
 $(LOCAL_TARGET): $(LOCAL_MODULE)
+	@mkdir -p $(FAKEROOT_DIR)/usr/lib
+	@cp -dpRf $< $(FAKEROOT_DIR)/usr/lib/$(SSL_WRAPPER_SO_TARGET)
+	@ln -sf $(SSL_WRAPPER_SO_TARGET) $(FAKEROOT_DIR)/usr/lib/$(SSL_WRAPPER_SO_NAME)
 	@echo "Build $@ Done."
 
 $(call add-target-into-build, $(LOCAL_TARGET))
 
 endif
-
diff --git a/openssl_wrapper/openssl_wrapper.cpp b/openssl_wrapper/openssl_wrapper.cpp
index c83e92e..2aad67e 100644
--- a/openssl_wrapper/openssl_wrapper.cpp
+++ b/openssl_wrapper/openssl_wrapper.cpp
@@ -1,16 +1,34 @@
-/*
+/*******************************************************************************
  * openssl_wrapper.cpp
  *
  * History:
- *	2015/04/14 - [Zhi He] create file
+ *  2015/04/14 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #include <stdio.h>
 #include <string.h>
@@ -672,19 +690,33 @@ s_symmetric_cypher* create_symmetric_cypher(unsigned char cypher_type, unsigned
         return NULL;
     }
 
-    if (BLOCK_CYPHER_MODE_CTR != cypher_mode) {
-        printf("[error]: create_symmetric_cypher: only support CTR mode now\n");
+    if ((BLOCK_CYPHER_MODE_CTR != cypher_mode) && (BLOCK_CYPHER_MODE_CBC != cypher_mode)) {
+        printf("[error]: create_symmetric_cypher: only support CTR and CBC mode now\n");
         return NULL;
     }
-
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
     s_symmetric_cypher* p_cypher = (s_symmetric_cypher*) malloc(sizeof(s_symmetric_cypher) + sizeof(EVP_CIPHER_CTX));
     if (!p_cypher) {
         printf("[error]: create_symmetric_cypher: no memory\n");
         return NULL;
     }
-
     memset(p_cypher, 0x0, sizeof(s_symmetric_cypher) + sizeof(EVP_CIPHER_CTX));
     p_cypher->p_cypher_private_context = (void*) ((unsigned char*)p_cypher + sizeof(s_symmetric_cypher));
+#else
+    s_symmetric_cypher *p_cypher = (s_symmetric_cypher*)malloc(sizeof(s_symmetric_cypher));
+    if (!p_cypher) {
+        printf("[error]: create_symmetric_cypher: no memory\n");
+        return NULL;
+    } else {
+        p_cypher->p_cypher_private_context = (void*)EVP_CIPHER_CTX_new();
+        if (!p_cypher->p_cypher_private_context) {
+            printf("[error]: EVP_CIPHER_CTX_new: no memory\n");
+            free(p_cypher);
+            return NULL;
+        }
+    }
+#endif
+
 
     p_cypher->cypher_type = cypher_type;
     p_cypher->cypher_mode = cypher_mode;
@@ -704,6 +736,9 @@ void destroy_symmetric_cypher(s_symmetric_cypher* cypher)
         if ((0 != cypher->state) && (cypher->p_cypher_private_context)) {
             EVP_CIPHER_CTX* p_ctx = (EVP_CIPHER_CTX*) cypher->p_cypher_private_context;
             EVP_CIPHER_CTX_cleanup(p_ctx);
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+            EVP_CIPHER_CTX_free(p_ctx);
+#endif
             cypher->state = 0;
         }
         free(cypher);
@@ -767,7 +802,14 @@ int begin_symmetric_cryption(s_symmetric_cypher* cypher, int enc)
     EVP_CIPHER_CTX* p_ctx = (EVP_CIPHER_CTX*) cypher->p_cypher_private_context;
     EVP_CIPHER_CTX_init(p_ctx);
 
-    EVP_CipherInit_ex(p_ctx, EVP_aes_128_ctr(), NULL, NULL, NULL, enc);
+    if (BLOCK_CYPHER_MODE_CTR == cypher->cypher_mode) {
+        EVP_CipherInit_ex(p_ctx, EVP_aes_128_ctr(), NULL, NULL, NULL, enc);
+    } else if (BLOCK_CYPHER_MODE_CBC == cypher->cypher_mode) {
+        EVP_CipherInit_ex(p_ctx, EVP_aes_128_cbc(), NULL, NULL, NULL, enc);
+    } else {
+        printf("[error]: only support CTR, CBC mode, %d\n", cypher->cypher_mode);
+        return (-4);
+    }
     EVP_CipherInit_ex(p_ctx, NULL, NULL, cypher->key, cypher->iv, enc);
 
     if (enc) {
diff --git a/openssl_wrapper/openssl_wrapper.h b/openssl_wrapper/openssl_wrapper.h
index baaa9e3..05b1adc 100644
--- a/openssl_wrapper/openssl_wrapper.h
+++ b/openssl_wrapper/openssl_wrapper.h
@@ -1,16 +1,34 @@
-/*
+/*******************************************************************************
  * openssl_wrapper.h
  *
  * History:
- *	2015/04/14 - [Zhi He] create file
+ *  2015/04/14 - [Zhi He] create file
  *
- * Copyright (C) 2014 - 2024, the Ambarella Inc.
+ * Copyright (C) 2015 Ambarella, Inc.
  *
- * All rights reserved. No Part of this file may be reproduced, stored
- * in a retrieval system, or transmitted, in any form, or by any means,
- * electronic, mechanical, photocopying, recording, or otherwise,
- * without the prior consent of the Ambarella Inc.
- */
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
 
 #ifndef __OPENSSL_WRAPPER_H__
 #define __OPENSSL_WRAPPER_H__
@@ -55,14 +73,23 @@ enum {
   BLOCK_CYPHER_MODE_OFB = 0x5,
 };
 
+#define SSL_WRAPPER_LIB_MAJOR 1
+#define SSL_WRAPPER_LIB_MINOR 1
+#define SSL_WRAPPER_LIB_PATCH 0
+#define SSL_WRAPPER_LIB_VERSION ((SSL_WRAPPER_LIB_MAJOR << 16) | \
+                                 (SSL_WRAPPER_LIB_MAJOR << 8)  | \
+                                 SSL_WRAPPER_LIB_PATCH)
+#define SSL_WRAPPER_VERSION_STR "1.0.0"
+
 #define DMAX_SYMMETRIC_KEY_LENGTH_BYTES 64
 #define DMAX_PASSPHRASE_LENGTH 32
+#define SSL_API __attribute__((visibility("default")))
 
-int generate_rsa_key(char* output_file, int bits, int pubexp, int key_format);
-int get_public_rsa_key(char* output_file, char* input_file);
+SSL_API int generate_rsa_key(char* output_file, int bits, int pubexp, int key_format);
+SSL_API int get_public_rsa_key(char* output_file, char* input_file);
 
-int signature_file(char* file, char* digital_signature, char* keyfile, int sha_type);
-int verify_signature(char* file, char* digital_signature, char* keyfile, int sha_type);
+SSL_API int signature_file(char* file, char* digital_signature, char* keyfile, int sha_type);
+SSL_API int verify_signature(char* file, char* digital_signature, char* keyfile, int sha_type);
 
 typedef struct
 {
@@ -85,15 +112,15 @@ typedef struct
     void* p_cypher_private_context;
 } s_symmetric_cypher;
 
-s_symmetric_cypher* create_symmetric_cypher(unsigned char cypher_type, unsigned char cypher_mode);
-void destroy_symmetric_cypher(s_symmetric_cypher* cypher);
+SSL_API s_symmetric_cypher* create_symmetric_cypher(unsigned char cypher_type, unsigned char cypher_mode);
+SSL_API void destroy_symmetric_cypher(s_symmetric_cypher* cypher);
 
-int set_symmetric_passphrase_salt(s_symmetric_cypher* cypher, char* passphrase, char* salt, unsigned char gen_method);
-int set_symmetric_key_iv(s_symmetric_cypher* cypher, char* key, char* iv);
+SSL_API int set_symmetric_passphrase_salt(s_symmetric_cypher* cypher, char* passphrase, char* salt, unsigned char gen_method);
+SSL_API int set_symmetric_key_iv(s_symmetric_cypher* cypher, char* key, char* iv);
 
-int begin_symmetric_cryption(s_symmetric_cypher* cypher, int enc);
-int symmetric_cryption(s_symmetric_cypher* cypher, unsigned char* p_buf, int buf_size, unsigned char* p_outbuf, int enc);
-int end_symmetric_cryption(s_symmetric_cypher* cypher);
+SSL_API int begin_symmetric_cryption(s_symmetric_cypher* cypher, int enc);
+SSL_API int symmetric_cryption(s_symmetric_cypher* cypher, unsigned char* p_buf, int buf_size, unsigned char* p_outbuf, int enc);
+SSL_API int end_symmetric_cryption(s_symmetric_cypher* cypher);
 
 #endif
 
diff --git a/uniqueid_puf_bpp/include/uniqueid_puf_bpp_if.h b/uniqueid_puf_bpp/include/uniqueid_puf_bpp_if.h
new file mode 100644
index 0000000..6dd92fa
--- /dev/null
+++ b/uniqueid_puf_bpp/include/uniqueid_puf_bpp_if.h
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * uniqueid_puf_bpp_if.h
+ *
+ * History:
+ *	2016/03/28 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#ifndef __UNIQUEID_PUF_BPP_IF_H__
+#define __UNIQUEID_PUF_BPP_IF_H__
+
+#define DUNIQUEID_MAX_NAME_LENGTH 8
+#define DUNIQUEID_LENGTH 64
+
+typedef struct {
+    unsigned char id[DUNIQUEID_LENGTH];
+} uniqueid_t;
+
+int get_name_from_id(uniqueid_t *id, char *name);
+int get_resolution_from_id(uniqueid_t *id, unsigned int *width, unsigned int *height);
+
+int generate_unique_id_from_puf_bpp(uniqueid_t *id, char *name, unsigned int input_buffer_num, unsigned int hot_pixel_number, unsigned int times);
+int verify_unique_id_from_puf_bpp(uniqueid_t *id);
+
+//for debug
+void debug_print_pixel_list(unsigned int enable);
+
+#endif
+
diff --git a/uniqueid_puf_bpp/src/arithm.c b/uniqueid_puf_bpp/src/arithm.c
new file mode 100644
index 0000000..fca6b14
--- /dev/null
+++ b/uniqueid_puf_bpp/src/arithm.c
@@ -0,0 +1,221 @@
+/*******************************************************************************
+ * arithm.c
+ *
+ * History:
+ *  2016/03/31 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "uniqueid_puf_bpp_if.h"
+
+#include "internal_include.h"
+
+int calculate_buffer_statistics(data_buffer_t *buf, double *average, double *standard_deviation)
+{
+    unsigned int tot_cnt = (unsigned int) buf->width * (unsigned int) buf->height, i = 0;
+    type_pixel_t *p = buf->p_buf;
+    double sum = 0, avg = 0, square_sum = 0;
+    double t = 0;
+
+    i = 0;
+    p = buf->p_buf;
+    while (i < tot_cnt) {
+        sum += (double) p[0];
+        p ++;
+        i ++;
+    }
+
+    t = sum / (double) tot_cnt;
+    avg = t;
+    if (average) {
+        *average = avg;
+    }
+
+    if (standard_deviation) {
+        i = 0;
+        p = buf->p_buf;
+        while (i < tot_cnt) {
+            square_sum += (double) (p[0] - avg) * (double) (p[0] - avg);
+            p ++;
+            i ++;
+        }
+
+        t = square_sum / (double) tot_cnt;
+        *standard_deviation = sqrt(t);
+    }
+
+    return 0;
+}
+
+int calculate_buffer_pixel_distribution(data_buffer_t *buf, unsigned int *distribution)
+{
+    unsigned int tot_cnt = (unsigned int) buf->width * (unsigned int) buf->height, i = 0;
+    type_pixel_t *p = buf->p_buf;
+
+    i = 0;
+    while (i < tot_cnt) {
+        if (DMAX_PIXEL_VALUE > p[0]) {
+            distribution[p[0]] ++;
+            p ++;
+            i ++;
+        } else {
+            DLOG_ERROR("pixel value 0x%08x exceed max value 0x%08x\n", p[0], DMAX_PIXEL_VALUE);
+        }
+    }
+
+    return 0;
+}
+
+int estimate_threshold(unsigned int *distribution, unsigned int range,
+    type_pixel_t *high_threshold, unsigned int *high_pixel_number)
+{
+    unsigned int *p = distribution + range - 1;
+    type_pixel_t current_index = range - 1;
+    unsigned int current_pixels = 0;
+
+    while (current_index > 0) {
+        if (p[0]) {
+            if ((p[0] + current_pixels) > high_pixel_number[0]) {
+                if (current_pixels) {
+                    high_threshold[0] = current_index;
+                    high_pixel_number[0] = current_pixels;
+                    DLOG_DEBUG("get threshold, current value 0x%08x, pixel number %d\n", current_index, current_pixels);
+                } else {
+                    DLOG_ERROR("[error]: do not get threshold, current value 0x%08x, pixel number %d\n", current_index, p[0]);
+                    return (-1);
+                }
+                return 0;
+            }
+        }
+        current_pixels += p[0];
+        current_index --;
+        p --;
+    }
+
+    return 0;
+}
+
+int estimate_threshold_high_low(unsigned int *distribution, unsigned int range,
+    type_pixel_t *high_threshold, type_pixel_t *low_threshold,
+    unsigned int *high_pixel_number, unsigned int *low_pixel_number)
+{
+    unsigned int *p = distribution + range;
+    type_pixel_t current_index = range;
+    unsigned int current_pixels = 0;
+    unsigned int get_high_threshold = 0;
+
+    while (current_index > 1) {
+        if (p[0]) {
+            if (!get_high_threshold) {
+                if ((p[0] + current_pixels) > high_pixel_number[0]) {
+                    get_high_threshold = 1;
+                    if (current_pixels) {
+                        high_threshold[0] = current_index;
+                        high_pixel_number[0] = current_pixels;
+                        DLOG_DEBUG("get high threshold, current value 0x%08x, pixel number %d\n", current_index, current_pixels);
+                    } else {
+                        DLOG_DEBUG("do not get high threshold, current value 0x%08x, pixel number %d\n", current_index, p[0]);
+                        high_threshold[0] = current_index - 1;
+                        high_pixel_number[0] = current_pixels + p[0];
+                    }
+                }
+            }
+            if ((p[0] + current_pixels) > low_pixel_number[0]) {
+                if (current_pixels) {
+                    low_threshold[0] = current_index;
+                    low_pixel_number[0] = current_pixels;
+                    DLOG_DEBUG("get low threshold, current value %d, pixel number %d\n", current_index, current_pixels);
+                } else {
+                    DLOG_DEBUG("do not get low threshold, current value %d, pixel number %d\n", current_index, p[0]);
+                    low_threshold[0] = current_index - 1;
+                    low_pixel_number[0] = current_pixels + p[0];
+                }
+                return 0;
+            }
+        }
+        current_pixels += p[0];
+        current_index --;
+        p --;
+    }
+
+    return 0;
+}
+
+int add_buffer(accumulate_buffer_t *acc_buf, data_buffer_t *buf1, data_buffer_t *buf2)
+{
+    unsigned int tot_cnt = (unsigned int) acc_buf->width * (unsigned int) acc_buf->height;
+    type_pixel_t *p1 = buf1->p_buf, *p2 = buf2->p_buf;
+    type_accumulate_pixel_t *pa = acc_buf->p_buf;
+
+    while (tot_cnt) {
+        pa[0] = p1[0] + p2[0];
+        pa ++;
+        p1 ++;
+        p2 ++;
+        tot_cnt --;
+    }
+
+    return 0;
+}
+
+int accumulate_buffer(accumulate_buffer_t *acc_buf, data_buffer_t *buf)
+{
+    unsigned int tot_cnt = (unsigned int) acc_buf->width * (unsigned int) acc_buf->height;
+    type_pixel_t *p1 = buf->p_buf;
+    type_accumulate_pixel_t *pa = acc_buf->p_buf;
+
+    while (tot_cnt) {
+        pa[0] += p1[0];
+        pa ++;
+        p1 ++;
+        tot_cnt --;
+    }
+
+    return 0;
+}
+
+int average_buffer(accumulate_buffer_t *acc_buf, data_buffer_t *buf, unsigned int buffer_number)
+{
+    unsigned int tot_cnt = (unsigned int) acc_buf->width * (unsigned int) acc_buf->height;
+    type_pixel_t *p1 = buf->p_buf;
+    type_accumulate_pixel_t *pa = acc_buf->p_buf;
+
+    while (tot_cnt) {
+        p1[0] = (type_pixel_t) pa[0] / buffer_number;
+        pa ++;
+        p1 ++;
+        tot_cnt --;
+    }
+
+    return 0;
+}
+
diff --git a/uniqueid_puf_bpp/src/data_source.c b/uniqueid_puf_bpp/src/data_source.c
new file mode 100644
index 0000000..3e7d82f
--- /dev/null
+++ b/uniqueid_puf_bpp/src/data_source.c
@@ -0,0 +1,61 @@
+/*******************************************************************************
+ * data_source.c
+ *
+ * History:
+ *  2016/03/31 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "uniqueid_puf_bpp_if.h"
+
+#include "internal_include.h"
+
+extern data_source_base_t *create_data_source_amba_dsp();
+
+data_source_base_t *create_data_source(E_DATA_SOURCE data_source)
+{
+    data_source_base_t *context = NULL;
+
+    switch (data_source) {
+
+        case E_DATA_SOURCE_SENSOR_RAW:
+            context = create_data_source_amba_dsp();
+            break;
+
+        default:
+            DLOG_ERROR("[error]: bad data source type %d\n", data_source);
+            break;
+    }
+
+    return context;
+}
+
+
diff --git a/uniqueid_puf_bpp/src/data_source_amba_dsp.c b/uniqueid_puf_bpp/src/data_source_amba_dsp.c
new file mode 100644
index 0000000..77a9f6e
--- /dev/null
+++ b/uniqueid_puf_bpp/src/data_source_amba_dsp.c
@@ -0,0 +1,138 @@
+/*******************************************************************************
+ * data_source_amba_dap.c
+ *
+ * History:
+ *  2016/03/31 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "uniqueid_puf_bpp_if.h"
+
+#include "internal_include.h"
+
+#include "platform_amba_dsp.h"
+#include "data_source_amba_dsp.h"
+
+static int __query_dimension_datasource_ambadsp(void *context, type_dimension_t *width, type_dimension_t *height)
+{
+    data_source_amba_dsp_t *thiz = (data_source_amba_dsp_t *) context;
+    *width = thiz->width;
+    *height = thiz->height;
+    return 0;
+}
+
+static int __read_data_datasource_ambadsp(void *context, data_buffer_t *buf)
+{
+    data_source_amba_dsp_t *thiz = (data_source_amba_dsp_t *) context;
+    rawbuf_desc_t rawbuf_desc;
+    int ret = 0;
+
+    ret = thiz->dsp_al.f_query_raw_buffer(thiz->iav_fd, &rawbuf_desc);
+    if (ret) {
+        DLOG_DEBUG("[error]: rawbuf_desc fail\n");
+        return ret;
+    }
+
+    memcpy(buf->p_buf, ((unsigned char *) thiz->dsp_map.base) + rawbuf_desc.raw_addr_offset, thiz->width * thiz->height * sizeof(type_pixel_t));
+
+    return 0;
+}
+
+static void __destroy_datasource_ambadsp(void *context)
+{
+    data_source_amba_dsp_t *thiz = (data_source_amba_dsp_t *) context;
+
+    if (thiz) {
+        if (0 < thiz->iav_fd) {
+            close_iav_handle(thiz->iav_fd);
+            thiz->iav_fd = -1;
+        }
+        free(thiz);
+    }
+}
+
+data_source_base_t *create_data_source_amba_dsp()
+{
+    rawbuf_desc_t desc;
+    int ret = 0;
+    data_source_amba_dsp_t *thiz = (data_source_amba_dsp_t *) malloc(sizeof(data_source_amba_dsp_t));
+
+    if (thiz) {
+
+        setup_amba_dsp(&thiz->dsp_al);
+        if ((!thiz->dsp_al.f_map_dsp) || (!thiz->dsp_al.f_query_raw_buffer)) {
+            DLOG_ERROR("[error]: f_map_dsp or f_query_raw_buffer not avaiable\n");
+            free(thiz);
+            return NULL;
+        }
+
+        DLOG_DEBUG("[flow]: open iav handle\n");
+        thiz->iav_fd = open_iav_handle();
+        if (0 > thiz->iav_fd) {
+            DLOG_ERROR("[error]: open iav fd fail\n");
+            free(thiz);
+            return NULL;
+        }
+
+        DLOG_DEBUG("[flow]: map dsp\n");
+        ret = thiz->dsp_al.f_map_dsp(thiz->iav_fd, &thiz->dsp_map);
+        if (ret) {
+            DLOG_ERROR("[error]: f_map_dsp fail\n");
+            free(thiz);
+            return NULL;
+        }
+
+        DLOG_DEBUG("[flow]: query raw buffer\n");
+        ret = thiz->dsp_al.f_query_raw_buffer(thiz->iav_fd, &desc);
+        if (ret) {
+            DLOG_ERROR("[error]: rawbuf_desc fail\n");
+            free(thiz);
+            return NULL;
+        }
+
+        thiz->width = desc.width;
+        thiz->height = desc.height;
+
+        DLOG_DEBUG("[flow]: dsp base 0x%08x, size 0x%08x, raw width %d, height %d\n",
+            (unsigned int) thiz->dsp_map.base, thiz->dsp_map.size, thiz->width, thiz->height);
+
+        thiz->base.f_query_dimension = __query_dimension_datasource_ambadsp;
+        thiz->base.f_read_raw_data = __read_data_datasource_ambadsp;
+        thiz->base.f_destroy = __destroy_datasource_ambadsp;
+
+    } else {
+        DLOG_ERROR("[error]: malloc conext fail\n");
+        return NULL;
+    }
+
+    return &thiz->base;
+}
+
diff --git a/uniqueid_puf_bpp/src/data_source_amba_dsp.h b/uniqueid_puf_bpp/src/data_source_amba_dsp.h
new file mode 100644
index 0000000..5052a7e
--- /dev/null
+++ b/uniqueid_puf_bpp/src/data_source_amba_dsp.h
@@ -0,0 +1,47 @@
+/*******************************************************************************
+ * data_source_amba_dsp.h
+ *
+ * History:
+ *	2016/03/28 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#ifndef __DATA_SOURCE_AMBA_DSP_H__
+#define __DATA_SOURCE_AMBA_DSP_H__
+
+typedef struct {
+    data_source_base_t base;
+    int iav_fd;
+    amba_dsp_t dsp_al;
+    dsp_map_t dsp_map;
+    unsigned int width, height;
+} data_source_amba_dsp_t;
+
+data_source_base_t *create_data_source_amba_dsp();
+
+#endif
+
diff --git a/uniqueid_puf_bpp/src/internal_include.h b/uniqueid_puf_bpp/src/internal_include.h
new file mode 100644
index 0000000..7ed72a2
--- /dev/null
+++ b/uniqueid_puf_bpp/src/internal_include.h
@@ -0,0 +1,173 @@
+/*******************************************************************************
+ * internal_include.h
+ *
+ * History:
+ *	2016/03/28 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#ifndef __INTERNAL_INCLUDE_H__
+#define __INTERNAL_INCLUDE_H__
+
+#define DMAX_INPUT_BUFFER_NUMBER 16
+
+#define DUNIQUEID_MARKER_BYTE 0xAB
+
+#define DUNIQUEID_DIGEST_SHA256_LENGTH 32
+#define DUNIQUEID_DIGEST_MD5_LENGTH 16
+#define DUNIQUEID_PARAM_PART_LENGTH 16
+
+#define DUNIQUEID_GENERATE_ADDITIONAL_TIMES 6
+
+#define DMAX_PIXEL_VALUE (1 << 14)
+
+#define DLOG_DEBUG(format, args...) (void)0
+//#define DLOG_DEBUG printf
+
+#define DLOG_ALWAYS __DLOG_ALWAYS
+#define DLOG_ERROR __DLOG_ERROR
+
+#define __DLOG_ERROR(format, args ...) do { \
+    printf("\033[40;31m\033[1m" format "\033[0m", ##args); \
+    printf("\t\t\[trace] file: %s.\n\t\t\t\tfunction: %s, line %d\n", __FILE__, __FUNCTION__, __LINE__); \
+    fflush(stdout); \
+} while (0)
+
+#define __DLOG_ALWAYS(format, args ...) do { \
+    printf("\033[40;35m\033[1m" format "\033[0m", ##args); \
+    fflush(stdout); \
+} while (0)
+
+typedef unsigned short type_pixel_t;
+typedef unsigned int type_accumulate_pixel_t;
+typedef unsigned short type_dimension_t;
+typedef unsigned long long type_caluculation_t;
+
+typedef struct {
+    unsigned char digest_sha256[DUNIQUEID_DIGEST_SHA256_LENGTH];
+    unsigned char digest_md5[DUNIQUEID_DIGEST_MD5_LENGTH];
+
+    unsigned char param_sensor_name[DUNIQUEID_MAX_NAME_LENGTH];
+    unsigned char param_resolution_width[2];
+    unsigned char param_resolution_height[2];
+    unsigned char param_hot_pixel_number[2];
+    unsigned char param_input_frame_number;
+    unsigned char param_repeat_times;
+} uniqueid_sensor_bpp_internal_t;
+
+typedef struct {
+    type_dimension_t width, height;
+    type_pixel_t *p_buf;
+} data_buffer_t;
+
+typedef struct {
+    type_dimension_t width, height;
+    type_accumulate_pixel_t *p_buf;
+} accumulate_buffer_t;
+
+typedef struct {
+    type_dimension_t width, height;
+    type_accumulate_pixel_t *p_buf;
+} statstics_accumulate_t;
+
+typedef struct {
+    type_dimension_t x, y;
+    type_pixel_t value;
+    type_pixel_t delta;
+
+    unsigned int acc_value;
+    unsigned int acc_delta;
+    unsigned int acc_count;
+
+    type_pixel_t delta_max;
+    type_pixel_t delta_min;
+    type_pixel_t delta_deviation;
+} hot_pixel_t;
+
+//data source
+typedef int (*tf_query_dimension)(void *context, type_dimension_t *width, type_dimension_t *height);
+typedef int (*tf_read_data)(void *context, data_buffer_t *buf);
+typedef void (*tf_destroy)(void *context);
+
+typedef struct {
+    tf_query_dimension f_query_dimension;
+    tf_read_data f_read_raw_data;
+    tf_destroy f_destroy;
+} data_source_base_t;
+
+typedef enum {
+    E_DATA_SOURCE_INVALID = 0x0,
+    E_DATA_SOURCE_SENSOR_RAW = 0x01,
+} E_DATA_SOURCE;
+
+data_source_base_t *create_data_source(E_DATA_SOURCE data_source);
+
+//storage
+typedef struct {
+    type_dimension_t x, y;
+    unsigned short delta;
+    unsigned short delta_deviation;
+} hot_pixel_storage_t;
+
+typedef struct {
+    unsigned char param_sensor_name[DUNIQUEID_MAX_NAME_LENGTH];
+    unsigned short param_resolution_width;
+    unsigned short param_resolution_height;
+    unsigned short param_hot_pixel_number;
+    unsigned char param_input_frame_number;
+    unsigned char param_repeat_times;
+
+    unsigned short number_of_pixel;
+    unsigned char reserved0;
+    unsigned char marker_byte; // should be DUNIQUEID_MARKER_BYTE
+
+    type_pixel_t pixel_avg;
+    type_pixel_t pixel_standard_deviation;
+
+    hot_pixel_storage_t *pixel_list;
+} hot_pixel_list_storage_t;
+
+//data statistics
+int calculate_buffer_statistics(data_buffer_t *buf, double *average, double *standard_deviation);
+int calculate_buffer_pixel_distribution(data_buffer_t *buf, unsigned int *distribution_end);
+int estimate_threshold(unsigned int *distribution, unsigned int range,
+    type_pixel_t *high_threshold, unsigned int *high_pixel_number);
+int estimate_threshold_high_low(unsigned int *distribution, unsigned int range,
+    type_pixel_t *high_threshold, type_pixel_t *low_threshold,
+    unsigned int *high_pixel_number, unsigned int *low_pixel_number);
+
+//buffer related
+int add_buffer(accumulate_buffer_t *acc_buf, data_buffer_t *buf1, data_buffer_t *buf2);
+int accumulate_buffer(accumulate_buffer_t *acc_buf, data_buffer_t *buf);
+int average_buffer(accumulate_buffer_t *acc_buf, data_buffer_t *buf, unsigned int buffer_number);
+
+//io related
+int write_hot_pixel_list_to_file(char *filename, hot_pixel_list_storage_t *storage);
+int read_hot_pixel_list_from_file(char *filename, hot_pixel_list_storage_t *storage);
+
+#endif
+
diff --git a/uniqueid_puf_bpp/src/io.c b/uniqueid_puf_bpp/src/io.c
new file mode 100644
index 0000000..d7335a4
--- /dev/null
+++ b/uniqueid_puf_bpp/src/io.c
@@ -0,0 +1,245 @@
+/*******************************************************************************
+ * io.c
+ *
+ * History:
+ *  2016/04/07 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "uniqueid_puf_bpp_if.h"
+
+#include "internal_include.h"
+
+int write_hot_pixel_list_to_file(char *filename, hot_pixel_list_storage_t *storage)
+{
+    int ret = 0;
+
+    if (filename && storage) {
+        FILE *file = fopen(filename, "wb+");
+        if (file) {
+            do {
+                ret = fwrite(storage->param_sensor_name, 1, sizeof(storage->param_sensor_name), file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write param_sensor_name fail\n");
+                    break;
+                }
+
+                ret = fwrite(&storage->param_resolution_width, sizeof(storage->param_resolution_width), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write param_resolution_width fail\n");
+                    break;
+                }
+
+                ret = fwrite(&storage->param_resolution_height, sizeof(storage->param_resolution_height), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write param_resolution_height fail\n");
+                    break;
+                }
+
+                ret = fwrite(&storage->param_hot_pixel_number, sizeof(storage->param_hot_pixel_number), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write param_hot_pixel_number fail\n");
+                    break;
+                }
+
+                ret = fwrite(&storage->param_input_frame_number, sizeof(storage->param_input_frame_number), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write param_input_frame_number fail\n");
+                    break;
+                }
+
+                ret = fwrite(&storage->param_repeat_times, sizeof(storage->param_repeat_times), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write param_repeat_times fail\n");
+                    break;
+                }
+
+                ret = fwrite(&storage->number_of_pixel, sizeof(storage->number_of_pixel), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write number_of_pixel fail\n");
+                    break;
+                }
+
+                ret = fwrite(&storage->reserved0, sizeof(storage->reserved0), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write delta_error fail\n");
+                    break;
+                }
+
+                ret = fwrite(&storage->marker_byte, sizeof(storage->marker_byte), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write marker_byte fail\n");
+                    break;
+                }
+
+                ret = fwrite(&storage->pixel_avg, sizeof(storage->pixel_avg), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write pixel_avg fail\n");
+                    break;
+                }
+
+                ret = fwrite(&storage->pixel_standard_deviation, sizeof(storage->pixel_standard_deviation), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write pixel_standard_deviation fail\n");
+                    break;
+                }
+
+                ret = fwrite(storage->pixel_list, sizeof(hot_pixel_storage_t), storage->number_of_pixel, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: write pixel_list fail\n");
+                    break;
+                }
+            } while (0);
+
+            fclose(file);
+        } else {
+            DLOG_ERROR("[error]: open file (%s) fail\n", filename);
+            return (-1);
+        }
+    } else {
+        DLOG_ERROR("[error]: bad params, filename %p, storage %p\n", filename, storage);
+        return (-2);
+    }
+
+    return ret;
+}
+
+int read_hot_pixel_list_from_file(char *filename, hot_pixel_list_storage_t *storage)
+{
+    int ret = 0;
+
+    if (filename && storage) {
+        FILE *file = fopen(filename, "rb");
+        if (file) {
+            do {
+                ret = fread(storage->param_sensor_name, 1, sizeof(storage->param_sensor_name), file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read param_sensor_name fail\n");
+                    break;
+                }
+
+                ret = fread(&storage->param_resolution_width, sizeof(storage->param_resolution_width), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read param_resolution_width fail\n");
+                    break;
+                }
+
+                ret = fread(&storage->param_resolution_height, sizeof(storage->param_resolution_height), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read param_resolution_height fail\n");
+                    break;
+                }
+
+                ret = fread(&storage->param_hot_pixel_number, sizeof(storage->param_hot_pixel_number), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read param_hot_pixel_number fail\n");
+                    break;
+                }
+
+                ret = fread(&storage->param_input_frame_number, sizeof(storage->param_input_frame_number), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read param_input_frame_number fail\n");
+                    break;
+                }
+
+                ret = fread(&storage->param_repeat_times, sizeof(storage->param_repeat_times), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read param_repeat_times fail\n");
+                    break;
+                }
+
+                ret = fread(&storage->number_of_pixel, sizeof(storage->number_of_pixel), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read number_of_pixel fail\n");
+                    break;
+                }
+
+                ret = fread(&storage->reserved0, sizeof(storage->reserved0), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read delta_error fail\n");
+                    break;
+                }
+
+                ret = fread(&storage->marker_byte, sizeof(storage->marker_byte), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read marker_byte fail\n");
+                    break;
+                }
+
+                ret = fread(&storage->pixel_avg, sizeof(storage->pixel_avg), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read pixel_avg fail\n");
+                    break;
+                }
+
+                ret = fread(&storage->pixel_standard_deviation, sizeof(storage->pixel_standard_deviation), 1, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read pixel_standard_deviation fail\n");
+                    break;
+                }
+
+                if (storage->pixel_list) {
+                    free(storage->pixel_list);
+                    storage->pixel_list = NULL;
+                }
+                storage->pixel_list = (hot_pixel_storage_t *) malloc(storage->number_of_pixel * sizeof(hot_pixel_storage_t));
+                if (!storage->pixel_list) {
+                    DLOG_ERROR("[error]: malloc fail, request size %d\n", storage->number_of_pixel * sizeof(hot_pixel_storage_t));
+                    break;
+                }
+
+                ret = fread(storage->pixel_list, sizeof(hot_pixel_storage_t), storage->number_of_pixel, file);
+                if (0 > ret) {
+                    DLOG_ERROR("[error]: read pixel_list fail\n");
+                    break;
+                }
+
+                if (ret != (storage->number_of_pixel)) {
+                    DLOG_ERROR("[error]: read pixel_list, size %d, %d not match\n", ret, storage->number_of_pixel);
+                    ret = (-10);
+                    break;
+                }
+
+                fclose(file);
+            } while (0);
+        } else {
+            DLOG_ERROR("[error]: open file (%s) fail\n", filename);
+            return (-1);
+        }
+    } else {
+        DLOG_ERROR("[error]: bad params, filename %p, storage %p\n", filename, storage);
+        return (-2);
+    }
+
+    return 0;
+}
+
diff --git a/uniqueid_puf_bpp/src/make.inc b/uniqueid_puf_bpp/src/make.inc
new file mode 100644
index 0000000..9f90662
--- /dev/null
+++ b/uniqueid_puf_bpp/src/make.inc
@@ -0,0 +1,54 @@
+###############################################################################
+## packages/security/uniqueid_puf_bpp/src/make.inc
+##
+## History:
+##    2016/04/01 - [Zhi He] Created file
+##
+## Copyright (C) 2015 Ambarella, Inc.
+##
+## This file and its contents ("Software") are protected by intellectual
+## property rights including, without limitation, U.S. and/or foreign
+## copyrights. This Software is also the confidential and proprietary
+## information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+## disclose, distribute, modify, or otherwise prepare derivative works of this
+## Software or any portion thereof except pursuant to a signed license agreement
+## or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+## In the absence of such an agreement, you agree to promptly notify and return
+## this Software to Ambarella, Inc.
+##
+## THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+## INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+## MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+## IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+## INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+## (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+## LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+## INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+## CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+##
+##################################################################################
+
+ifeq ($(BUILD_AMBARELLA_UNIQUEID_PUF_BPP), y)
+
+LOCAL_PATH	:= $(call my-dir)
+
+###
+include $(CLEAR_VARS)
+
+LOCAL_CFLAGS    := -I$(LOCAL_PATH)/../include -I$(LOCAL_PATH)/../../lw_cryptography/include
+LOCAL_TARGET	:= libuniqueidpufbpp.a
+LOCAL_SRCS	:= $(LOCAL_PATH)/arithm.c $(LOCAL_PATH)/data_source.c $(LOCAL_PATH)/io.c $(LOCAL_PATH)/data_source_amba_dsp.c $(LOCAL_PATH)/platform_amba_dsp.c $(LOCAL_PATH)/uniqueid_puf_bpp.c
+
+include $(BUILD_APP)
+
+.PHONY: $(LOCAL_TARGET)
+
+$(LOCAL_TARGET): $(LOCAL_MODULE)
+	@echo "Build $@ Done."
+
+$(call add-target-into-build, $(LOCAL_TARGET))
+
+endif
+
diff --git a/uniqueid_puf_bpp/src/platform_amba_dsp.c b/uniqueid_puf_bpp/src/platform_amba_dsp.c
new file mode 100644
index 0000000..4844795
--- /dev/null
+++ b/uniqueid_puf_bpp/src/platform_amba_dsp.c
@@ -0,0 +1,162 @@
+/*******************************************************************************
+ * platform_amba_dsp.cpp
+ *
+ * History:
+ *    2016/03/31 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "uniqueid_puf_bpp_if.h"
+#include "internal_include.h"
+#include "platform_amba_dsp.h"
+
+#include "config.h"
+
+#ifndef CONFIG_ARCH_A5S
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <time.h>
+#include <errno.h>
+#include <basetypes.h>
+
+#if defined(CONFIG_ARCH_S2) || defined (CONFIG_ARCH_S2E)
+#include "ambas_common.h"
+#include "iav_drv.h"
+
+void setup_amba_dsp(amba_dsp_t *al)
+{
+    al->f_map_dsp = NULL;
+    al->f_query_raw_buffer = NULL;
+}
+
+#else
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <iav_ioctl.h>
+
+static int __map_dsp(int iav_fd, dsp_map_t *map)
+{
+    struct iav_querybuf querybuf;
+
+    querybuf.buf = IAV_BUFFER_DSP;
+    if (ioctl(iav_fd, IAV_IOC_QUERY_BUF, &querybuf) < 0) {
+        perror("IAV_IOC_QUERY_BUF");
+        DLOG_ERROR("IAV_IOC_QUERY_BUF fail\n");
+        return -1;
+    }
+
+    map->size = querybuf.length;
+    map->base = mmap(NULL, map->size, PROT_READ, MAP_SHARED, iav_fd, querybuf.offset);
+    if (MAP_FAILED == map->base) {
+        perror("mmap");
+        DLOG_ERROR("mmap fail\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+static int __query_raw_buffer(int iav_fd, rawbuf_desc_t *desc)
+{
+    struct iav_rawbufdesc *raw_desc;
+    struct iav_querydesc query_desc;
+
+    memset(&query_desc, 0, sizeof(query_desc));
+    query_desc.qid = IAV_DESC_RAW;
+    raw_desc = &query_desc.arg.raw;
+    if (ioctl(iav_fd, IAV_IOC_QUERY_DESC, &query_desc) < 0) {
+        perror("IAV_IOC_QUERY_DESC");
+        DLOG_ERROR("IAV_IOC_QUERY_DESC fail\n");
+        return (-1);
+    }
+
+    desc->raw_addr_offset = raw_desc->raw_addr_offset;
+    desc->width = raw_desc->width;
+    desc->height = raw_desc->height;
+    desc->pitch = raw_desc->pitch;
+    desc->mono_pts = raw_desc->mono_pts;
+
+    return 0;
+}
+
+
+void setup_amba_dsp(amba_dsp_t *al)
+{
+    al->f_map_dsp = __map_dsp;
+    al->f_query_raw_buffer = __query_raw_buffer;
+}
+
+#endif
+
+#else
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <time.h>
+#include <errno.h>
+#include <basetypes.h>
+
+#include "ambas_common.h"
+#include "iav_drv.h"
+
+void setup_amba_dsp(amba_dsp_t *al)
+{
+    al->f_map_dsp = NULL;
+    al->f_query_raw_buffer = NULL;
+}
+
+#endif
+
+int open_iav_handle()
+{
+    int fd = open("/dev/iav", O_RDWR, 0);
+    if (0 > fd) {
+        DLOG_ERROR("open iav fail, %d.\n", fd);
+    }
+    return fd;
+}
+
+void close_iav_handle(int fd)
+{
+    if (0 > fd) {
+        DLOG_ERROR("bad fd %d\n", fd);
+        return;
+    }
+    close(fd);
+    return;
+}
+
diff --git a/uniqueid_puf_bpp/src/platform_amba_dsp.h b/uniqueid_puf_bpp/src/platform_amba_dsp.h
new file mode 100644
index 0000000..724dc87
--- /dev/null
+++ b/uniqueid_puf_bpp/src/platform_amba_dsp.h
@@ -0,0 +1,63 @@
+/*******************************************************************************
+ * platform_amba_dsp.h
+ *
+ * History:
+ *    2016/03/31 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#ifndef __PLATFORM_AMBA_DSP_H__
+#define __PLATFORM_AMBA_DSP_H__
+
+typedef struct {
+    void *base;
+    unsigned int size;
+} dsp_map_t;
+
+typedef struct {
+    unsigned int raw_addr_offset;
+    unsigned int width;
+    unsigned int height;
+    unsigned int pitch;
+    unsigned long long mono_pts;
+} rawbuf_desc_t;
+
+typedef int (*tf_map_dsp)(int iav_fd, dsp_map_t *map);
+typedef int (*tf_query_raw_buffer)(int iav_fd, rawbuf_desc_t *desc);
+
+typedef struct {
+    tf_map_dsp f_map_dsp;
+    tf_query_raw_buffer f_query_raw_buffer;
+} amba_dsp_t;
+
+void setup_amba_dsp(amba_dsp_t *al);
+
+int open_iav_handle();
+void close_iav_handle(int fd);
+
+#endif
+
diff --git a/uniqueid_puf_bpp/src/uniqueid_puf_bpp.c b/uniqueid_puf_bpp/src/uniqueid_puf_bpp.c
new file mode 100644
index 0000000..94624a9
--- /dev/null
+++ b/uniqueid_puf_bpp/src/uniqueid_puf_bpp.c
@@ -0,0 +1,1053 @@
+/*******************************************************************************
+ * uniqueid_puf_bpp.c
+ *
+ * History:
+ *  2016/03/31 - [Zhi He] create file
+ *
+ * Copyright (C) 2015 Ambarella, Inc.
+ *
+ * This file and its contents ("Software") are protected by intellectual
+ * property rights including, without limitation, U.S. and/or foreign
+ * copyrights. This Software is also the confidential and proprietary
+ * information of Ambarella, Inc. and its licensors. You may not use, reproduce,
+ * disclose, distribute, modify, or otherwise prepare derivative works of this
+ * Software or any portion thereof except pursuant to a signed license agreement
+ * or nondisclosure agreement with Ambarella, Inc. or its authorized affiliates.
+ * In the absence of such an agreement, you agree to promptly notify and return
+ * this Software to Ambarella, Inc.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL AMBARELLA, INC. OR ITS AFFILIATES BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; COMPUTER FAILURE OR MALFUNCTION; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "uniqueid_puf_bpp_if.h"
+
+#include "internal_include.h"
+
+#include "cryptography_if.h"
+
+typedef struct
+{
+    data_source_base_t *data_source;
+
+    accumulate_buffer_t acc_buffer;
+    data_buffer_t input_buffer[DMAX_INPUT_BUFFER_NUMBER];
+    data_buffer_t avg_buffer;
+
+    unsigned int *p_distribution;
+
+    hot_pixel_t *hot_pixel_list;
+
+    unsigned int input_buffer_num;
+    unsigned int hot_pixel_number;
+    type_pixel_t hot_pixel_threshold;
+
+    double avg_buffer_average, avg_buffer_standard_deviation;
+} calculation_context;
+
+unsigned int g_print_pixel_list = 0;
+
+static int __allocate_buffer(data_buffer_t *buf)
+{
+    unsigned int mem_size = buf->width * buf->height * sizeof(type_pixel_t);
+    if (mem_size) {
+        buf->p_buf = (type_pixel_t *) malloc(mem_size);
+        if (!buf->p_buf) {
+            DLOG_DEBUG("[error]: no memory, rerquest size %d\n", mem_size);
+            return (-1);
+        }
+    } else {
+        DLOG_DEBUG("[error]: bad params, width %d, height %d\n", buf->width, buf->height);
+        return (-2);
+    }
+    return 0;
+}
+
+static void __release_buffer(data_buffer_t *buf)
+{
+    if (buf->p_buf) {
+        free(buf->p_buf);
+        buf->p_buf = NULL;
+    }
+}
+
+static int __allocate_accumulate_buffer(accumulate_buffer_t *buf)
+{
+    unsigned int mem_size = buf->width * buf->height * sizeof(type_accumulate_pixel_t);
+    if (mem_size) {
+        buf->p_buf = (type_accumulate_pixel_t *) malloc(mem_size);
+        if (!buf->p_buf) {
+            DLOG_DEBUG("[error]: no memory, rerquest size %d\n", mem_size);
+            return (-1);
+        }
+    } else {
+        DLOG_DEBUG("[error]: bad params, width %d, height %d\n", buf->width, buf->height);
+        return (-2);
+    }
+    return 0;
+}
+
+static void __release_accumulate_buffer(accumulate_buffer_t *buf)
+{
+    if (buf->p_buf) {
+        free(buf->p_buf);
+        buf->p_buf = NULL;
+    }
+}
+
+static int __retrieve_hot_pixel_list(data_buffer_t *buf, type_pixel_t threashold, hot_pixel_t *hot_pixel_list, double avg, double deviation)
+{
+    type_dimension_t x = 0, y = 0;
+    unsigned int index = 0;
+    double vd = 0;
+    type_pixel_t *p = buf->p_buf;
+
+    for (y = 0; y < buf->height; y ++) {
+        for (x = 0; x < buf->width; x ++) {
+            if (p[0] > threashold) {
+                if (DMAX_PIXEL_VALUE > p[0]) {
+                    vd = (double) p[0];
+                    if (vd > avg) {
+                        vd = ((vd - avg) + (deviation / 2)) / deviation;
+                        hot_pixel_list[index].x = x;
+                        hot_pixel_list[index].y = y;
+                        hot_pixel_list[index].value = p[0];
+                        hot_pixel_list[index].delta = (unsigned int) vd;
+                        hot_pixel_list[index].delta_max = hot_pixel_list[index].delta;
+                        hot_pixel_list[index].delta_min = hot_pixel_list[index].delta;
+                        hot_pixel_list[index].acc_value = hot_pixel_list[index].value;
+                        hot_pixel_list[index].acc_delta = hot_pixel_list[index].delta;
+                        hot_pixel_list[index].acc_count = 1;
+                        index ++;
+                    } else {
+                        DLOG_ERROR("hot pixel value(%d) less than avg(%lf)?\n", p[0], avg);
+                    }
+                } else {
+                    DLOG_ERROR("pixel value 0x%08x exceed max value 0x%08x\n", p[0], DMAX_PIXEL_VALUE);
+                }
+            }
+            p ++;
+        }
+    }
+
+    return 0;
+}
+
+static int __process_data(calculation_context *context)
+{
+    unsigned int i = 0;
+    int ret = 0;
+
+    DLOG_DEBUG("[flow]: read data...\n");
+    for (i = 0; i < context->input_buffer_num; i ++) {
+        ret = context->data_source->f_read_raw_data(context->data_source, &context->input_buffer[i]);
+        if (ret) {
+            DLOG_ERROR("[error]: read_data[%d] fail\n", i);
+            return ret;
+        }
+    }
+
+    DLOG_DEBUG("[flow]: accumulate buffers...\n");
+    add_buffer(&context->acc_buffer, &context->input_buffer[0], &context->input_buffer[1]);
+    for (i = 2; i < context->input_buffer_num; i ++) {
+        accumulate_buffer(&context->acc_buffer, &context->input_buffer[i]);
+    }
+
+    DLOG_DEBUG("[flow]: average buffer...\n");
+    average_buffer(&context->acc_buffer, &context->avg_buffer, context->input_buffer_num);
+
+    DLOG_DEBUG("[flow]: calculate average buffer's average and standard deviation\n");
+    ret = calculate_buffer_statistics(&context->avg_buffer, &context->avg_buffer_average, &context->avg_buffer_standard_deviation);
+    if (ret) {
+        DLOG_ERROR("[error]: calculate_buffer_statistics[%d] fail\n", i);
+        return ret;
+    }
+    DLOG_DEBUG("[statistics]: average buffer's average is %lf, standard deviation is %lf\n", context->avg_buffer_average, context->avg_buffer_standard_deviation);
+
+    DLOG_DEBUG("[flow]: calculate pixel distribution\n");
+    ret = calculate_buffer_pixel_distribution(&context->avg_buffer, context->p_distribution);
+    if (ret) {
+        DLOG_ERROR("[error]: calculate_buffer_pixel_distribution fail\n");
+        return ret;
+    }
+
+    DLOG_DEBUG("[flow]: estimate threshold, pixel number %d\n", context->hot_pixel_number);
+    ret = estimate_threshold(context->p_distribution, DMAX_PIXEL_VALUE, &context->hot_pixel_threshold, &context->hot_pixel_number);
+    if (ret) {
+        DLOG_ERROR("[error]: estimate_threshold fail\n");
+        return ret;
+    }
+    DLOG_DEBUG("[statistics]: threshold 0x%08x, %d, number %d\n", context->hot_pixel_threshold, context->hot_pixel_threshold, context->hot_pixel_number);
+
+    context->hot_pixel_list = (hot_pixel_t *) malloc(context->hot_pixel_number * sizeof(hot_pixel_t));
+    if (!context->hot_pixel_list) {
+        DLOG_ERROR("[error]: alloc hot pixel list fail, pixel number %d, request size %d\n", context->hot_pixel_number, context->hot_pixel_number * sizeof(hot_pixel_t));
+        return (-2);
+    }
+    memset(context->hot_pixel_list, 0x0, context->hot_pixel_number * sizeof(hot_pixel_t));
+
+    ret = __retrieve_hot_pixel_list(&context->avg_buffer, context->hot_pixel_threshold, context->hot_pixel_list, context->avg_buffer_average, context->avg_buffer_standard_deviation);
+    if (ret) {
+        DLOG_ERROR("[error]: __retrieve_hot_pixel_list fail\n");
+        return ret;
+    }
+
+    return 0;
+}
+
+static int __pixel_in_list(hot_pixel_t *pixel, hot_pixel_t **pp_list, unsigned int *p_num)
+{
+    type_dimension_t x = pixel->x, y = pixel->y;
+    hot_pixel_t *cur = *pp_list;
+    unsigned int num = *p_num;
+
+    while (num) {
+        if ((cur->x == x) && cur->y == y) {
+            *pp_list = cur;
+            *p_num = num;
+            return 1;
+        }
+        num --;
+        cur ++;
+    }
+
+    return 0;
+}
+
+static unsigned int __get_common_pixels(hot_pixel_t *list1, unsigned int num_1, hot_pixel_t *list2, unsigned int num_2)
+{
+    hot_pixel_t *p0 = list1;
+    hot_pixel_t *p1 = list1;
+    int find = 0;
+    unsigned int remain_num = 0;
+    hot_pixel_t *tmp_list2 = list2;
+    unsigned int tmp_num_2 = num_2;
+
+    while (num_1) {
+        find = __pixel_in_list(p1, &tmp_list2, &tmp_num_2);
+        if (find) {
+            if (p0 != p1) {
+                p0->x = p1->x;
+                p0->y = p1->y;
+                p0->value = p1->value;
+                p0->delta = p1->delta;
+
+                p0->acc_value = p1->acc_value;
+                p0->acc_count = p1->acc_count;
+                p0->acc_delta = p1->acc_delta;
+
+                p0->delta_max = p1->delta_max;
+                p0->delta_min = p1->delta_min;
+            }
+
+            p0->acc_value += tmp_list2->value;
+            p0->acc_delta += tmp_list2->delta;
+            p0->acc_count ++;
+
+            if (p0->delta_max < tmp_list2->delta) {
+                p0->delta_max = tmp_list2->delta;
+            }
+
+            if (p0->delta_min > tmp_list2->delta) {
+                p0->delta_min = tmp_list2->delta;
+            }
+
+            p0 ++;
+            remain_num ++;
+        }
+        p1 ++;
+        num_1 --;
+    }
+
+    return remain_num;
+}
+
+static int __is_pixel_match_in_list(type_dimension_t x, type_dimension_t y, unsigned short delta, unsigned short delta_deviation, hot_pixel_t **pp_list, unsigned int *p_num)
+{
+    hot_pixel_t *cur = *pp_list;
+    unsigned int num = *p_num;
+
+    unsigned int delta_range = 0;
+
+    while (num) {
+        if ((cur->x == x) && cur->y == y) {
+            *pp_list = cur;
+            *p_num = num;
+            delta_range = (((delta * 3) + 5) / 10) + delta_deviation + 1;
+            if (((delta + delta_range + 10) >= cur->delta ) && (delta <= (cur->delta + delta_range))) {
+                return 1;
+            } else {
+                DLOG_ALWAYS("delta diff large, [%04d, %04d]: delta %d, delta_range %d, cur->delta %d\n", x, y, delta, delta_range, cur->delta);
+            }
+            return 0;
+        }
+        num --;
+        cur ++;
+    }
+
+    return 0;
+}
+
+static int __is_pixel_match_in_list_without_delta(type_dimension_t x, type_dimension_t y, hot_pixel_t **pp_list, unsigned int *p_num)
+{
+    hot_pixel_t *cur = *pp_list;
+    unsigned int num = *p_num;
+
+    while (num) {
+        if ((cur->x == x) && cur->y == y) {
+            *pp_list = cur;
+            *p_num = num;
+            return 1;
+        }
+        num --;
+        cur ++;
+    }
+
+    return 0;
+}
+
+static unsigned int __get_storage_stable_pixel_number(hot_pixel_storage_t *list, unsigned int num)
+{
+    unsigned int stable_pixel_num = 0;
+
+    while (num) {
+        if ((list->delta >= 5) && (list->delta >= (2 * list->delta_deviation + 1))) {
+            stable_pixel_num ++;
+        }
+        list ++;
+        num --;
+    }
+
+    return stable_pixel_num;
+}
+
+static unsigned int __get_stable_pixel_number(hot_pixel_t *list, unsigned int num)
+{
+    unsigned int stable_pixel_num = 0;
+
+    while (num) {
+        if ((list->delta >= 5) && (list->delta >= (2 * list->delta_deviation + 1))) {
+            stable_pixel_num ++;
+        }
+        list ++;
+        num --;
+    }
+
+    return stable_pixel_num;
+}
+
+static unsigned int __get_matched_pixel_number(hot_pixel_storage_t *list1, unsigned int num_1, hot_pixel_t *list2, unsigned int num_2)
+{
+    hot_pixel_storage_t *p0 = list1;
+    int find = 0;
+    unsigned int remain_num = 0;
+    hot_pixel_t *tmp_list2 = list2;
+    unsigned int tmp_num_2 = num_2;
+
+    while (num_1) {
+        find = __is_pixel_match_in_list(p0->x, p0->y, p0->delta, p0->delta_deviation, &tmp_list2, &tmp_num_2);
+        if (find) {
+            remain_num ++;
+        }
+        p0 ++;
+        num_1 --;
+    }
+
+    return remain_num;
+}
+
+static unsigned int __get_matched_pixel_number_without_delta(hot_pixel_storage_t *list1, unsigned int num_1, hot_pixel_t *list2, unsigned int num_2)
+{
+    hot_pixel_storage_t *p0 = list1;
+    int find = 0;
+    unsigned int remain_num = 0;
+    hot_pixel_t *tmp_list2 = list2;
+    unsigned int tmp_num_2 = num_2;
+
+    while (num_1) {
+        find = __is_pixel_match_in_list_without_delta(p0->x, p0->y, &tmp_list2, &tmp_num_2);
+        if (find) {
+            remain_num ++;
+        }
+        p0 ++;
+        num_1 --;
+    }
+
+    return remain_num;
+}
+
+static void __calculate_delta(hot_pixel_t *list, unsigned int num)
+{
+    while (num) {
+        list->delta = (list->acc_delta + (list->acc_count / 2)) / list->acc_count;
+        list->delta_deviation = list->delta_max - list->delta;
+        if (list->delta_deviation < (list->delta - list->delta_min)) {
+            list->delta_deviation = list->delta - list->delta_min;
+        }
+        list ++;
+        num --;
+    }
+
+}
+
+static void __print_pixel_list(hot_pixel_t *list, unsigned int num)
+{
+    DLOG_ALWAYS("pixel list, number %d:\n", num);
+
+    while (num) {
+        //DLOG_ALWAYS("[%04d, %04d], value 0x%08x, delta = %d, delta_deviation %d\n", list->x, list->y, list->acc_value / list->acc_count, list->delta, list->delta_deviation);
+        DLOG_ALWAYS("[%04d, %04d], delta = %d, delta_deviation %d\n", list->x, list->y, list->delta, list->delta_deviation);
+        list ++;
+        num --;
+    }
+
+}
+
+static void __print_storage(hot_pixel_list_storage_t *storage)
+{
+    unsigned int num = storage->number_of_pixel;
+    hot_pixel_storage_t *list = storage->pixel_list;
+
+    DLOG_ALWAYS("[storage]: params: resolution %dx%d, pixel number %d, input buffer %d, times %d\n",
+        storage->param_resolution_width, storage->param_resolution_height,
+        storage->param_hot_pixel_number, storage->param_input_frame_number, storage->param_repeat_times);
+    DLOG_ALWAYS("[storage]: number of pixels %d, pixel avg %d, pixel deviation %d\n",
+        storage->number_of_pixel, storage->pixel_avg, storage->pixel_standard_deviation);
+
+    while (num) {
+        DLOG_ALWAYS("[%04d, %04d], delta = %d, delta_deviation %d\n", list->x, list->y, list->delta, list->delta_deviation);
+        list ++;
+        num --;
+    }
+
+}
+
+static void __print_id(uniqueid_t *id)
+{
+    unsigned char *p =id->id;
+
+    DLOG_ALWAYS("unique id:\n");
+
+    DLOG_ALWAYS("\t%02x %02x %02x %02x, %02x %02x %02x %02x, %02x %02x %02x %02x, %02x %02x %02x %02x\n",
+        p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+    p += 16;
+    DLOG_ALWAYS("\t%02x %02x %02x %02x, %02x %02x %02x %02x, %02x %02x %02x %02x, %02x %02x %02x %02x\n",
+        p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+    p += 16;
+    DLOG_ALWAYS("\t%02x %02x %02x %02x, %02x %02x %02x %02x, %02x %02x %02x %02x, %02x %02x %02x %02x\n",
+        p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+    p += 16;
+    DLOG_ALWAYS("\t%02x %02x %02x %02x, %02x %02x %02x %02x, %02x %02x %02x %02x, %02x %02x %02x %02x\n",
+        p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+}
+
+static int __store_list_to_file(char *filename, hot_pixel_list_storage_t *storage, hot_pixel_t *pixel_list, unsigned int num)
+{
+    unsigned int i = 0;
+    storage->pixel_list = (hot_pixel_storage_t *) malloc(sizeof(hot_pixel_storage_t) * num);
+
+    for (i = 0; i < num; i ++) {
+        storage->pixel_list[i].x = pixel_list[i].x;
+        storage->pixel_list[i].y = pixel_list[i].y;
+        storage->pixel_list[i].delta = pixel_list[i].delta;
+        storage->pixel_list[i].delta_deviation = pixel_list[i].delta_deviation;
+    }
+
+    return write_hot_pixel_list_to_file(filename, storage);
+}
+
+int get_name_from_id(uniqueid_t *id, char *name)
+{
+    if (id && name) {
+        uniqueid_sensor_bpp_internal_t *iid = (uniqueid_sensor_bpp_internal_t *) id;
+        memcpy(name, iid->param_sensor_name, DUNIQUEID_MAX_NAME_LENGTH);
+    } else {
+        DLOG_ERROR("[error]: NULL input id %p, name %p\n", id, name);
+        return (-1);
+    }
+
+    return 0;
+}
+
+int get_resolution_from_id(uniqueid_t *id, unsigned int *width, unsigned int *height)
+{
+    if (id && width && height) {
+        uniqueid_sensor_bpp_internal_t *iid = (uniqueid_sensor_bpp_internal_t *) id;
+        * width = (((unsigned int) iid->param_resolution_width[0]) << 8) | ((unsigned int) iid->param_resolution_width[1]);
+        * height = (((unsigned int) iid->param_resolution_height[0]) << 8) | ((unsigned int) iid->param_resolution_height[1]);
+    } else {
+        DLOG_ERROR("[error]: NULL input id %p, width %p, height %p\n", id, width, height);
+        return (-1);
+    }
+
+    return 0;
+}
+
+int generate_unique_id_from_puf_bpp(uniqueid_t *id, char *name, unsigned int input_buffer_num, unsigned int hot_pixel_number, unsigned int times)
+{
+    unsigned int i = 0;
+    type_dimension_t width = 0, height = 0;
+    int ret = 0;
+
+    hot_pixel_t *current_list = NULL;
+    unsigned int current_hot_list_number = 0;
+    hot_pixel_list_storage_t storage;
+    calculation_context context;
+    uniqueid_sensor_bpp_internal_t *iid = (uniqueid_sensor_bpp_internal_t *) id;
+
+    if ((!id) || (!name) || (!input_buffer_num) || (!hot_pixel_number) || (!times)) {
+        DLOG_ERROR("[error]: bad parameters\n");
+        return (-1);
+    }
+
+    if (DMAX_INPUT_BUFFER_NUMBER < input_buffer_num) {
+        DLOG_ERROR("[error]: input buffer number(%d) too large, max value (%d)\n", input_buffer_num, DMAX_INPUT_BUFFER_NUMBER);
+        return (-1);
+    } else if (2 > input_buffer_num) {
+        DLOG_ERROR("[error]: input buffer number(%d) too small, min value (2)\n", input_buffer_num);
+        return (-1);
+    }
+
+    memset(&context, 0x0, sizeof(context));
+    memset(&storage, 0x0, sizeof(storage));
+
+    context.input_buffer_num = input_buffer_num;
+    context.hot_pixel_number = hot_pixel_number;
+    DLOG_DEBUG("buffer number %d, %d, pixel number %d, %d\n", input_buffer_num, context.input_buffer_num, hot_pixel_number, context.hot_pixel_number);
+
+    context.data_source = create_data_source(E_DATA_SOURCE_SENSOR_RAW);
+    if (!context.data_source) {
+        DLOG_ERROR("[error]: create_data_source fail\n");
+        return (-2);
+    }
+
+    ret = context.data_source->f_query_dimension(context.data_source, &width, &height);
+    if (ret) {
+        DLOG_ERROR("[error]: query dimension fail\n");
+        goto __generate_unique_id_from_puf_bpp_exit;
+    }
+    DLOG_DEBUG("[flow]: query dimension, %dx%d\n", width, height);
+
+    context.p_distribution = (unsigned int *) malloc(DMAX_PIXEL_VALUE * sizeof(unsigned int));
+    if (!context.p_distribution) {
+        DLOG_ERROR("[error]: alloc distribution memory fail\n");
+        ret = -4;
+        goto __generate_unique_id_from_puf_bpp_exit;
+    }
+
+    context.acc_buffer.width = width;
+    context.acc_buffer.height = height;
+    ret = __allocate_accumulate_buffer(&context.acc_buffer);
+    if (ret) {
+        DLOG_ERROR("[error]: __allocate_accumulate_buffer[%d] fail\n", i);
+        goto __generate_unique_id_from_puf_bpp_exit;
+    }
+
+    context.avg_buffer.width = width;
+    context.avg_buffer.height = height;
+    ret = __allocate_buffer(&context.avg_buffer);
+    if (ret) {
+        DLOG_ERROR("[error]: __allocate_buffer[%d] fail\n", i);
+        goto __generate_unique_id_from_puf_bpp_exit;
+    }
+
+    DLOG_DEBUG("[flow]: allocate buffers... (number %d, width %d, height %d)\n", input_buffer_num, width, height);
+    for (i = 0; i < input_buffer_num; i ++) {
+        context.input_buffer[i].width = width;
+        context.input_buffer[i].height = height;
+        ret = __allocate_buffer(&context.input_buffer[i]);
+        if (ret) {
+            DLOG_ERROR("[error]: __allocate_buffer[%d] fail\n", i);
+            goto __generate_unique_id_from_puf_bpp_exit;
+        }
+    }
+
+    DLOG_DEBUG("[flow]: processing... (times %d)\n", times);
+    for (i = 0; i < times + DUNIQUEID_GENERATE_ADDITIONAL_TIMES; i ++) {
+        memset(context.p_distribution, 0x0, DMAX_PIXEL_VALUE * sizeof(unsigned int));
+        ret = __process_data(&context);
+        if (ret) {
+            DLOG_ERROR("[error]: __process_data[%d] fail\n", i);
+            goto __generate_unique_id_from_puf_bpp_exit;
+        }
+
+        if (!current_list) {
+            current_list = context.hot_pixel_list;
+            current_hot_list_number = context.hot_pixel_number;
+        } else {
+            current_hot_list_number = __get_common_pixels(current_list, current_hot_list_number, context.hot_pixel_list, context.hot_pixel_number);
+            DLOG_DEBUG("[statistics]: after process, common pixel number %d\n", current_hot_list_number);
+
+            free(context.hot_pixel_list);
+            context.hot_pixel_list = NULL;
+
+            if (!current_hot_list_number) {
+                DLOG_ERROR("[error]: do not find common hot pixels\n");
+                ret = (-9);
+                goto __generate_unique_id_from_puf_bpp_exit;
+            }
+        }
+        context.hot_pixel_number = hot_pixel_number;
+        context.hot_pixel_list = NULL;
+    }
+
+    if (current_list && current_hot_list_number) {
+
+        __calculate_delta(current_list, current_hot_list_number);
+        //__print_pixel_list(current_list, current_hot_list_number);
+
+        unsigned int name_len = strlen(name);
+        if (name_len > DUNIQUEID_MAX_NAME_LENGTH) {
+            name_len = DUNIQUEID_MAX_NAME_LENGTH;
+        }
+        if (name_len) {
+            memcpy(storage.param_sensor_name, name, name_len);
+        }
+
+        storage.param_resolution_width = width;
+        storage.param_resolution_height = height;
+        storage.param_hot_pixel_number = hot_pixel_number;
+        storage.param_input_frame_number = input_buffer_num;
+        storage.param_repeat_times = times;
+
+        storage.number_of_pixel = current_hot_list_number;
+        storage.marker_byte = DUNIQUEID_MARKER_BYTE;
+
+        storage.pixel_avg = (type_pixel_t) context.avg_buffer_average;
+        storage.pixel_standard_deviation = (type_pixel_t) context.avg_buffer_standard_deviation;
+
+        __store_list_to_file((char *) "hotpixel.list", &storage, current_list, current_hot_list_number);
+
+        if (g_print_pixel_list) {
+            __print_storage(&storage);
+        }
+
+        if (storage.pixel_list) {
+            void* digest_context = NULL;
+
+            digest_context = digest_sha256_init();
+            if (digest_context) {
+                digest_sha256_update(digest_context, (const unsigned char *) &storage, sizeof(storage) - sizeof(storage.pixel_list));
+                digest_sha256_update(digest_context, (const unsigned char *) storage.pixel_list, storage.number_of_pixel * sizeof(hot_pixel_storage_t));
+                digest_sha256_final(digest_context, iid->digest_sha256);
+                free(digest_context);
+                digest_context = NULL;
+            }
+
+            digest_context = digest_md5_init();
+            if (digest_context) {
+                digest_md5_update(digest_context, (const unsigned char *) &storage, sizeof(storage) - sizeof(storage.pixel_list));
+                digest_md5_update(digest_context, (const unsigned char *) storage.pixel_list, storage.number_of_pixel * sizeof(hot_pixel_storage_t));
+                digest_md5_final(digest_context, iid->digest_md5);
+                free(digest_context);
+                digest_context = NULL;
+            }
+
+            memcpy(iid->param_sensor_name, storage.param_sensor_name, DUNIQUEID_MAX_NAME_LENGTH);
+            iid->param_resolution_width[0] = (width >> 8) & 0xff;
+            iid->param_resolution_width[1] = (width) & 0xff;
+            iid->param_resolution_height[0] = (height >> 8) & 0xff;
+            iid->param_resolution_height[1] = (height) & 0xff;
+            iid->param_hot_pixel_number[0] = (hot_pixel_number >> 8) & 0xff;
+            iid->param_hot_pixel_number[1] = (hot_pixel_number) & 0xff;
+            iid->param_input_frame_number = input_buffer_num;
+            iid->param_repeat_times = times;
+
+            __print_id(id);
+        } else {
+            DLOG_ERROR("[error]: store fail, list is NULL\n");
+            ret = -10;
+        }
+
+    } else {
+        DLOG_ERROR("[error]: do not get common hot pixel list\n");
+        ret = -11;
+    }
+
+__generate_unique_id_from_puf_bpp_exit:
+
+    __release_accumulate_buffer(&context.acc_buffer);
+
+    __release_buffer(&context.avg_buffer);
+
+    for (i = 0; i < input_buffer_num; i ++) {
+        __release_buffer(&context.input_buffer[i]);
+    }
+
+    if (context.p_distribution) {
+        free(context.p_distribution);
+        context.p_distribution = NULL;
+    }
+
+    if (context.data_source && context.data_source->f_destroy) {
+        context.data_source->f_destroy(context.data_source);
+        context.data_source= NULL;
+    }
+
+    if (current_list) {
+        free(current_list);
+        current_list = NULL;
+    }
+
+    if (context.hot_pixel_list) {
+        free(context.hot_pixel_list);
+        context.hot_pixel_list = NULL;
+    }
+
+    if (storage.pixel_list) {
+        free(storage.pixel_list);
+        storage.pixel_list = NULL;
+    }
+
+    if (context.data_source && context.data_source->f_destroy) {
+        context.data_source->f_destroy(context.data_source);
+        context.data_source = NULL;
+    }
+
+    return ret;
+}
+
+int verify_unique_id_from_puf_bpp(uniqueid_t *id)
+{
+    unsigned int i = 0;
+    type_dimension_t width = 0, height = 0;
+    unsigned int pixel_number = 0;
+    int ret = 0;
+
+    hot_pixel_t *current_list = NULL;
+    unsigned int current_hot_list_number = 0;
+    hot_pixel_list_storage_t storage;
+    calculation_context context;
+    uniqueid_sensor_bpp_internal_t *iid = (uniqueid_sensor_bpp_internal_t *) id;
+
+    if (!id) {
+        DLOG_ERROR("[error]: bad parameters\n");
+        return (-1);
+    }
+
+    __print_id(id);
+
+    memset(&context, 0x0, sizeof(context));
+    memset(&storage, 0x0, sizeof(storage));
+
+    ret = read_hot_pixel_list_from_file((char *) "hotpixel.list", &storage);
+    if (ret) {
+        DLOG_ERROR("[error]: read from file error\n");
+        ret = (-1);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+
+    if (storage.pixel_list) {
+        void* digest_context = NULL;
+        unsigned char digest[32] = {0};
+
+        digest_context = digest_sha256_init();
+        if (digest_context) {
+            digest_sha256_update(digest_context, (const unsigned char *) &storage, sizeof(storage) - sizeof(storage.pixel_list));
+            digest_sha256_update(digest_context, (const unsigned char *) storage.pixel_list, storage.number_of_pixel * sizeof(hot_pixel_storage_t));
+            digest_sha256_final(digest_context, digest);
+            free(digest_context);
+            digest_context = NULL;
+        }
+
+        if (memcmp(iid->digest_sha256, digest, 32)) {
+            DLOG_ERROR("[error]: sha256 not match\n");
+            ret = (-3);
+            goto __verify_unique_id_from_puf_bpp_exit;
+        }
+
+        digest_context = digest_md5_init();
+        if (digest_context) {
+            digest_md5_update(digest_context, (const unsigned char *) &storage, sizeof(storage) - sizeof(storage.pixel_list));
+            digest_md5_update(digest_context, (const unsigned char *) storage.pixel_list, storage.number_of_pixel * sizeof(hot_pixel_storage_t));
+            digest_md5_final(digest_context, digest);
+            free(digest_context);
+            digest_context = NULL;
+        }
+
+        if (memcmp(iid->digest_md5, digest, 16)) {
+            DLOG_ERROR("[error]: md5 not match\n");
+            ret = (-3);
+            goto __verify_unique_id_from_puf_bpp_exit;
+        }
+
+    } else {
+        DLOG_ERROR("[error]: load fail, list is NULL\n");
+        ret = (-10);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+
+    if (g_print_pixel_list) {
+        __print_storage(&storage);
+    }
+
+    if (DUNIQUEID_MARKER_BYTE != storage.marker_byte) {
+        DLOG_ERROR("[error]: storage's marker byte fail\n");
+        ret = (-1);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+
+    width = ((unsigned int) iid->param_resolution_width[0] << 8) | ((unsigned int) iid->param_resolution_width[1]);
+    height = ((unsigned int) iid->param_resolution_height[0] << 8) | ((unsigned int) iid->param_resolution_height[1]);
+    if ((storage.param_resolution_width != width) || (storage.param_resolution_height != height)) {
+        DLOG_ERROR("[error]: resolution not match, from id %dx%d, from storage %dx%d\n", width, height, storage.param_resolution_width, storage.param_resolution_height);
+        ret = (-2);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+
+    pixel_number = ((unsigned int) iid->param_hot_pixel_number[0] << 8) | ((unsigned int) iid->param_hot_pixel_number[1]);
+    if ((storage.param_hot_pixel_number != pixel_number) || (storage.param_input_frame_number != iid->param_input_frame_number) || (storage.param_repeat_times != iid->param_repeat_times)) {
+        DLOG_ERROR("[error]: process param not match, from id (pixel number %d, input buffer num %d, repeat times %d), from storage (pixel number %d, input buffer num %d, repeat times %d)\n", pixel_number, iid->param_input_frame_number, iid->param_repeat_times, storage.param_hot_pixel_number, storage.param_input_frame_number, storage.param_repeat_times);
+        ret = (-2);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+
+    context.input_buffer_num = storage.param_input_frame_number;
+    context.hot_pixel_number = storage.param_hot_pixel_number;
+    DLOG_DEBUG("buffer number %d, pixel number %d\n", context.input_buffer_num, context.hot_pixel_number);
+
+    context.data_source = create_data_source(E_DATA_SOURCE_SENSOR_RAW);
+    if (!context.data_source) {
+        DLOG_ERROR("[error]: create_data_source fail\n");
+        ret = (-2);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+
+    ret = context.data_source->f_query_dimension(context.data_source, &width, &height);
+    if (ret) {
+        DLOG_ERROR("[error]: query dimension fail\n");
+        ret = (-16);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+    DLOG_DEBUG("[flow]: query dimension, %dx%d\n", width, height);
+    if ((width != storage.param_resolution_width) || (height != storage.param_resolution_height)) {
+        DLOG_ERROR("[error]: dimension not match, query %dx%d, from storage %dx%d\n", width, height, storage.param_resolution_width, storage.param_resolution_height);
+        ret = (-17);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+
+    context.p_distribution = (unsigned int *) malloc(DMAX_PIXEL_VALUE * sizeof(unsigned int));
+    if (!context.p_distribution) {
+        DLOG_ERROR("[error]: alloc distribution memory fail\n");
+        ret = (-4);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+
+    context.acc_buffer.width = width;
+    context.acc_buffer.height = height;
+    ret = __allocate_accumulate_buffer(&context.acc_buffer);
+    if (ret) {
+        DLOG_ERROR("[error]: __allocate_accumulate_buffer[%d] fail\n", i);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+
+    context.avg_buffer.width = width;
+    context.avg_buffer.height = height;
+    ret = __allocate_buffer(&context.avg_buffer);
+    if (ret) {
+        DLOG_ERROR("[error]: __allocate_buffer[%d] fail\n", i);
+        goto __verify_unique_id_from_puf_bpp_exit;
+    }
+
+    DLOG_DEBUG("[flow]: allocate buffers... (number %d, width %d, height %d)\n", storage.param_input_frame_number, width, height);
+    for (i = 0; i < storage.param_input_frame_number; i ++) {
+        context.input_buffer[i].width = width;
+        context.input_buffer[i].height = height;
+        ret = __allocate_buffer(&context.input_buffer[i]);
+        if (ret) {
+            DLOG_ERROR("[error]: __allocate_buffer[%d] fail\n", i);
+            goto __verify_unique_id_from_puf_bpp_exit;
+        }
+    }
+
+    DLOG_DEBUG("[flow]: processing... (times %d)\n", storage.param_repeat_times);
+    for (i = 0; i < storage.param_repeat_times; i ++) {
+        memset(context.p_distribution, 0x0, DMAX_PIXEL_VALUE * sizeof(unsigned int));
+        ret = __process_data(&context);
+        if (ret) {
+            DLOG_ERROR("[error]: __process_data[%d] fail\n", i);
+            goto __verify_unique_id_from_puf_bpp_exit;
+        }
+
+        if (!current_list) {
+            current_list = context.hot_pixel_list;
+            current_hot_list_number = context.hot_pixel_number;
+        } else {
+            current_hot_list_number = __get_common_pixels(current_list, current_hot_list_number, context.hot_pixel_list, context.hot_pixel_number);
+            DLOG_DEBUG("[statistics]: after process, common pixel number %d\n", current_hot_list_number);
+
+            free(context.hot_pixel_list);
+            context.hot_pixel_list = NULL;
+
+            if (!current_hot_list_number) {
+                DLOG_ERROR("[error]: do not find common hot pixels\n");
+                ret = (-9);
+                goto __verify_unique_id_from_puf_bpp_exit;
+            }
+        }
+        context.hot_pixel_number = storage.param_hot_pixel_number;
+        context.hot_pixel_list = NULL;
+    }
+
+    if (current_list && current_hot_list_number) {
+        unsigned int matched_number = 0;
+        unsigned int storage_stable_pixel_number = __get_storage_stable_pixel_number(storage.pixel_list, storage.number_of_pixel);
+        unsigned int match_threshold = 0;
+        unsigned int current_stable_pixel_number = 0;
+
+        __calculate_delta(current_list, current_hot_list_number);
+        if (g_print_pixel_list) {
+            __print_pixel_list(current_list, current_hot_list_number);
+        }
+
+        current_stable_pixel_number = __get_stable_pixel_number(current_list, current_hot_list_number);
+        if ((current_stable_pixel_number >= 5) && (storage_stable_pixel_number >= 5)) {
+            if ((3 * current_stable_pixel_number) >= storage_stable_pixel_number) {
+                if (current_stable_pixel_number > storage_stable_pixel_number) {
+                    match_threshold = (storage_stable_pixel_number * 5) / 10;
+                } else {
+                    match_threshold = (current_stable_pixel_number * 5) / 10;
+                }
+            } else {
+                match_threshold = (current_stable_pixel_number * 5) / 10;
+            }
+        } else {
+            if (current_stable_pixel_number >= storage_stable_pixel_number) {
+                if (storage_stable_pixel_number > 3) {
+                    match_threshold = (storage_stable_pixel_number * 9) / 10;
+                } else {
+                    match_threshold = storage_stable_pixel_number;
+                }
+            } else {
+                if (current_stable_pixel_number > 2) {
+                    match_threshold = current_stable_pixel_number;
+                } else {
+                    DLOG_ALWAYS("delta deviation too large, calculate matched pixel without delta check\n");
+
+                    if ((current_hot_list_number >= 5) && (storage.number_of_pixel >= 5)) {
+                        if (current_hot_list_number > storage.number_of_pixel) {
+                            match_threshold = storage.number_of_pixel * 5 / 10;
+                        } else {
+                            match_threshold = current_hot_list_number * 5 / 10;
+                        }
+                    } else {
+                        if (current_hot_list_number >= storage.number_of_pixel) {
+                            if (storage.number_of_pixel > 3) {
+                                match_threshold = (storage.number_of_pixel * 9) / 10;
+                            }
+                        } else {
+                            match_threshold = current_hot_list_number;
+                        }
+                    }
+
+                    matched_number = __get_matched_pixel_number_without_delta(storage.pixel_list, storage.number_of_pixel, current_list, current_hot_list_number);
+
+                    if (g_print_pixel_list) {
+                        DLOG_ALWAYS("hot pixel number (%d, %d), matched number %d\n", current_hot_list_number, storage.number_of_pixel, matched_number);
+                    }
+
+                    if (match_threshold > matched_number) {
+                        if (matched_number >= 10) {
+                            DLOG_ALWAYS("result: match\n");
+                            ret = 0;
+                        } else {
+                            DLOG_ERROR("result: not match\n");
+                            ret = (-100);
+                        }
+                    } else {
+                        DLOG_ALWAYS("result: match\n");
+                        ret = 0;
+                    }
+                    goto __verify_unique_id_from_puf_bpp_exit;
+                }
+            }
+        }
+
+        matched_number = __get_matched_pixel_number(storage.pixel_list, storage.number_of_pixel, current_list, current_hot_list_number);
+
+        if (g_print_pixel_list) {
+            DLOG_ALWAYS("hot pixel number (%d, %d), stable number (%d, %d), matched number %d\n", current_hot_list_number, storage.number_of_pixel, current_stable_pixel_number, storage_stable_pixel_number, matched_number);
+        }
+
+        if (match_threshold > matched_number) {
+            if (matched_number >= 10) {
+                DLOG_ALWAYS("result: match\n");
+                ret = 0;
+                goto __verify_unique_id_from_puf_bpp_exit;
+            }
+
+            DLOG_ERROR("result: not match\n");
+            ret = (-100);
+        } else {
+            DLOG_ALWAYS("result: match\n");
+            ret = 0;
+        }
+
+    } else {
+        DLOG_ERROR("[error]: do not get common hot pixel list\n");
+        ret = -11;
+    }
+
+__verify_unique_id_from_puf_bpp_exit:
+
+    __release_accumulate_buffer(&context.acc_buffer);
+
+    __release_buffer(&context.avg_buffer);
+
+    for (i = 0; i < storage.param_input_frame_number; i ++) {
+        __release_buffer(&context.input_buffer[i]);
+    }
+
+    if (context.p_distribution) {
+        free(context.p_distribution);
+        context.p_distribution = NULL;
+    }
+
+    if (context.data_source && context.data_source->f_destroy) {
+        context.data_source->f_destroy(context.data_source);
+        context.data_source= NULL;
+    }
+
+    if (current_list) {
+        free(current_list);
+        current_list = NULL;
+    }
+
+    if (context.hot_pixel_list) {
+        free(context.hot_pixel_list);
+        context.hot_pixel_list = NULL;
+    }
+
+    if (storage.pixel_list) {
+        free(storage.pixel_list);
+        storage.pixel_list = NULL;
+    }
+
+    if (context.data_source && context.data_source->f_destroy) {
+        context.data_source->f_destroy(context.data_source);
+        context.data_source = NULL;
+    }
+
+    return ret;
+}
+
+void debug_print_pixel_list(unsigned int enable)
+{
+    g_print_pixel_list = 1;
+}
+
